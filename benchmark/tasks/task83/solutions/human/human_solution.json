[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef complex<double> P;\n\nint cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint dt(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\nint main(){\n  for(;;){int x,y; P t[3],c;int r;\n    for(int i=0;i<3;i++){cin>>x>>y;if((i|x|y)==0)return 0;t[i]=P(x,y);}\n    cin>>x>>y;c=P(x,y);cin>>r;\n    if(abs(t[0]-c)<=r&&abs(t[1]-c)<=r&&abs(t[2]-c)<=r){cout<<'b'<<endl;}\n    else{double d[3];bool f[2]={};\n      for(int i=0;i<3;i++){\n        P l=t[(i+1)%3]-t[i];\n        if(dt(l,c-t[i])>0&&dt(-l,c-t[(i+1)%3])>0){\n        \td[i]=fabs(cr(l,c-t[i])/abs(l));\n        \t}else{\n        \t\td[i]=min(abs(c-t[i]),abs(c-t[(i+1)%3]));\n        \t}f[cr(l,c-t[i])<0]=true;\n      \t  }if(f[0]^f[1]&&d[0]>=r&&d[1]>=r&&d[2]>=r){\n      \t\t  cout<<'a'<<endl;\n      \t  }else if(d[0]<=r||d[1]<=r||d[2]<=r){\n      \t\t  cout<<'c'<<endl;\n      \t  }else{\n    \t  cout<<'d'<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\npair<int, int> a;\npair<int, int> b;\npair<int, int> c;\npair<int, int> o;\nint r;\n\nint cross(pair<int, int> p1, pair<int, int> p2){\n  return p1.first * p2.second - p1.second * p2.first;\n}\n\ndouble length(pair<int, int> p){\n  return sqrt(p.first * p.first + p.second * p.second);\n}\n\nbool is_inside(){\n  if(cross(make_pair(b.first-a.first, b.second-a.second), \n\t   make_pair(o.first-a.first, o.second-a.second)) < 0) return false;\n  if(cross(make_pair(c.first-b.first, c.second-b.second), \n\t   make_pair(o.first-b.first, o.second-b.second)) < 0) return false;\n  if(cross(make_pair(a.first-c.first, a.second-c.second), \n\t   make_pair(o.first-c.first, o.second-c.second)) < 0) return false;\n  return true;\n}\n\ndouble dist(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3){\n  pair<int, int> p4 = make_pair(p2.first - p1.first, p2.second - p1.second);\n  pair<int, int> p5 = make_pair(p3.first - p1.first, p3.second - p1.second);\n  double tmp = length(p4);\n  return abs((double)cross(p4, p5) / tmp);\n}\n\nmain(){\n  while(cin >> a.first >> a.second && a.first && a.second){\n    cin >> b.first >> b.second;\n    cin >> c.first >> c.second;\n    cin >> o.first >> o.second;\n    cin >> r;\n    if(length(make_pair(a.first-o.first, a.second-o.second)) < (double)r+EPS && \n       length(make_pair(b.first-o.first, b.second-o.second)) < (double)r+EPS &&\n       length(make_pair(c.first-o.first, c.second-o.second)) < (double)r+EPS){\n      cout << \"b\" << endl;\n    }\n    else if(is_inside()){\n      if(dist(b, c, o) > (double)r-EPS && \n\t dist(a, c, o) > (double)r-EPS && \n\t dist(a, b, o) > (double)r-EPS){\n\tcout << \"a\" << endl;\n      }else{\n\tcout << \"c\" << endl;\n      }\n    }else{\n      if((length(make_pair(a.first-o.first, a.second-o.second)) < (double)r+EPS ||\n\t length(make_pair(b.first-o.first, b.second-o.second)) < (double)r+EPS ||\n\t length(make_pair(c.first-o.first, b.second-o.second)) < (double)r+EPS) &&\n\t (dist(b, c, o) < (double)r+EPS ||\n\t dist(a, c, o) < (double)r+EPS ||\n\t dist(a, b, o) < (double)r+EPS)){\n\tcout << \"c\" << endl;\n      }else{\n\tcout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs2(const point<T>& p){return SQ(p.x) + SQ(p.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(abs2(p));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n    if(rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS * len) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\n//多角形の面積\ntemplate<class T>\nT area(const vector<point<T> >& v){\n\tT ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S,const point<T> &p){ return sqrt(dist2(S,p)); }\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ntemplate<class T>\ndouble geodist(point<T> a,point<T> b,const circle<T> &C){\n\tdouble r=C.r;\n\tsegment<T> s(a,b);\n\tif(dist(s,C.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=C.c;\n\tb-=C.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntemplate<class T>\nstd::istream& operator>>(std::istream& is, point<T>& point){return ( is >> point.x >> point.y );}\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n\n//円の接点\nvector<P> GetContact(const P& p,const P& q,const double r){\n\tP a = p-q;\n\tdouble s = SQ(a.x) + SQ(a.y);\n\tdouble D = sqrt(s - SQ(r));\n\tdouble dx = r * D * a.y / s;\n\tdouble dy = r * D * a.x / s;\n\tdouble bx = SQ(r) * a.x / s;\n\tdouble by = SQ(r) * a.y / s;\n\tvector<P> ans(2);\n\tans[0].x = bx + dx;\n\tans[0].y = by - dy;\n\tans[1].x = bx - dx;\n\tans[1].y = by + dy;\n\n\tans[0] += q;\n\tans[1] += q;\n\n\treturn ans;\n}\n\n//todo : verifyしてないので、そのうち。\n// 円が交差しているか 「=」は問によって変更する\ntemplate<class T>\nint CircleCross(const circle<T> &c1,const circle<T> &c2){\n\tdouble l = abs(c1.c - c2.c);\n\tif(l >= c1.r + c2.r) return 3; //外部にある\n\tif(l + c1.r <= c2.r) return 2; //c1 ⊃ c2\n\tif(l + c2.r <= c1.r) return 1; //c1 ⊂ c2\n\treturn 0; //交差している\n}\n\n\ntypedef pair<P,P> PD;\n//円同士の交点\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\ninline void calc_abc(const L &l,double &a,double &b,double &c){  // l : ax+by+c=0\n    a=l.a.y-l.b.y;\n    b=l.b.x-l.a.x;\n    c=l.a.x*l.b.y-l.b.x*l.a.y;\n}\n \n//PからLへの垂線の足\nP perp_foot(const P &p,const L &l){\n    double a,b,c;\n    calc_abc(l,a,b,c);\n    return p-P(a,b) * ((a*p.x+b*p.y+c)/(a*a+b*b));\n}\n \n\nint intersect(const C &c,const L &l,P *p=NULL,P *q=NULL){\n    P m=perp_foot(c.c,l);\n    double d2=abs2(c.c-m);\n    if(c.r*c.r+EPS<d2)   return 0;\n    else if(abs(c.r*c.r-d2)<EPS){\n        if(p&&q)    *p=*q=m;\n        return 1;\n    }\n    else{\n        if(p&&q){\n            P v;\n            double n0=abs2(l.a-m),n1=abs2(l.b-m);\n            if(n0<n1)    v=l.b-m,n0=n1;\n            else        v=l.a-m;\n            v*=sqrt((c.r*c.r-d2)/n0);\n            *p=m+v,*q=m-v;\n        }\n        return 2;\n    }\n}\n\nint intersect(const C &c,const S &s,P *p=NULL,P *q=NULL){\n    P pp,qq;\n    int n=intersect(c,L(s.a,s.b),&pp,&qq);\n    if(n==0)    return 0;\n    else if(n==1){\n        if(dot(pp-s.a,pp-s.b)<EPS){\n            if(p&&q)    *p=*q=pp;\n            return 1;\n        }\n        return 0;\n    }\n    else{\n        bool bp=(dot(pp-s.a,pp-s.b)<EPS);\n        bool bq=(dot(qq-s.a,qq-s.b)<EPS);\n        if(bp&&bq){\n            if(p&&q)    *p=pp,*q=qq;\n            return 2;\n        }\n        if(bp||bq){\n            if(p&&q)    *p=(bp?pp:qq);\n            return 1;\n        }\n        return 0;\n    }\n}\n\nint main(){\n\tvector<P> p(3);\n\tC c;\n\twhile(cin>>p[0],p[0].x != 0 || p[0].y != 0){\n\t\tcin>>p[1]>>p[2];\n\t\tcin>>c.c>>c.r;\n\t\tP t[3];\n\t\tFOR(i,3) t[i] = perp_foot(c.c,L(p[i],p[(i+1)%3]));\n\t\tint c_sum = abs(ccw(t[0],t[1],c.c)+ccw(t[1],t[2],c.c)+ccw(t[2],t[0],c.c));\n\t\tif(c_sum == 3\n\t\t&& SQ(c.r) < abs2(t[0]-c.c)+EPS \n\t\t&& SQ(c.r) < abs2(t[1]-c.c)+EPS \n\t\t&& SQ(c.r) < abs2(t[2]-c.c)+EPS){\n\t\t\tputs(\"a\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t//in-circle\n\t\tif(abs2(p[0]-c.c) < SQ(c.r)+EPS\n\t\t&& abs2(p[1]-c.c) < SQ(c.r)+EPS\n\t\t&& abs2(p[2]-c.c) < SQ(c.r)+EPS){\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(intersect(c,S(p[0],p[1])) == 0\n\t\t&& intersect(c,S(p[1],p[2])) == 0\n\t\t&& intersect(c,S(p[2],p[0])) == 0){\n\t\t\tputs(\"d\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tputs(\"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    double ans=0;\n    for(int i=0;i<3;i++){\n\tint tmp=dist(p[i],C.p);\n\tif(tmp>ans){\n\t  ans=tmp;\n\t}\n    }\n    if(C.r>ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n    \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=100000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2){};\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn(s1.p1 + (s1.p2 - s1.p1) * t);\n}\n\ndouble arg(Vector p)\n{\n\treturn(atan2(p.y, p.x));\n}\n\nVector polar(double a, double r)\n{\n\treturn(Point(cos(r) * a, sin(r) * a));\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn(make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)));\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn(make_pair(pr - e * base, pr + e * base));\n}\n\nbool inc(Point p1, Point p2, Point p3, Point p4)\n{\n\tPoint e0 = p1 - p4;\n\tPoint e1 = p2 - p4;\n\tPoint e2 = p3 - p4;\n\tlong double d0 = cross(e0, e1);\n\tlong double d1 = cross(e1, e2);\n\tlong double d2 = cross(e2, e0);\n\tif (d0 * d1 > 0 && d1 * d2 > 0 && d2 * d0 > 0)\n\t{\n\t\treturn(true);\n\t}\n\treturn(false);\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tPoint p1;\n\twhile (cin >> p1.x >> p1.y, p1.x || p1.y)\n\t{\n\t\tPoint p2, p3, p4;\n\t\tint r;\n\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y >> r;\n\t\t\n\t\tif (r - getDistance(p4, p1) > 0 && r - getDistance(p4, p2) > 0 && r - getDistance(p4, p3) > 0)\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if (inc(p1, p2, p3, p4) && getDistanceSP(Segment(p1, p2), p4) - r >= 0 && getDistanceSP(Segment(p1, p3), p4) - r >= 0 && getDistanceSP(Segment(p2, p3), p4) - r >= 0)\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse if (inc(p1, p2, p3, p4) == false && getDistanceSP(Segment(p1, p2), p4) - r > 0 && getDistanceSP(Segment(p1, p3), p4) - r > 0 && getDistanceSP(Segment(p2, p3), p4) - r > 0)\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nenum POSITION {UNDER = -1, ON, ABOVE};\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return center.distance(p) < r;}\n    bool include(const Segment& s) const {return center.distance(s) < r;}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n    if(s.ccw(p) == ON) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x - y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + Point(t, t) * v2;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n    for(auto& e: edge) if(circle.include(e)) return \"c\";\n\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center) >= 0) ++ccw;\n        if(e.ccw(circle.center) <= 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "///verified by maroon_rk\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\n#define int ll\n\n#define rng(i, a, b) for (int i = int(a); i < int(b); i++)\n#define rep(i, b) rng(i, 0, b)\n#define gnr(i, a, b) for (int i = int(b) - 1; i >= a; i--)\n#define per(i, b) gnr(i, 0, b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg, x.ed\n#ifdef LOCAL\n#define dmp(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#else\n#define dmp(x) void(0)\n#endif\n#define tmp template <class t>\n\ntmp void chmax(t &a, t b)\n{\n    if (a < b)\n        a = b;\n}\ntmp void chmin(t &a, t b)\n{\n    if (a > b)\n        a = b;\n}\n\ntmp using vc = vector<t>;\ntmp using vvc = vc<vc<t>>;\n\nusing pi = pair<int, int>;\nusing vi = vc<int>;\n\ntemplate <class t, class u>\nostream &operator<<(ostream &os, const pair<t, u> &p)\n{\n    return os << \"{\" << p.a << \",\" << p.b << \"}\";\n}\n\ntmp ostream &operator<<(ostream &os, const vc<t> &v)\n{\n    os << \"{\";\n    for (auto e : v)\n        os << e << \",\";\n    return os << \"}\";\n}\n\nconstexpr ll ten(int n)\n{\n    return n == 0 ? 1 : ten(n - 1) * 10;\n}\n\ntmp void mkuni(vc<t> &v)\n{\n    sort(all(v));\n    v.erase(unique(all(v)), v.ed);\n}\n\nll read()\n{\n    ll i;\n    cin >> i;\n    return i;\n}\n\nusing ld = long double;\nusing cm = complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps = 1e-7;\nint sgn(ld a) { return a < -eps ? -1 : (a > eps ? 1 : 0); }\nauto cmcmp = [](const cm &a, const cm &b) {\n    if (sgn(a.x - b.x))\n        return a.x < b.x;\n    else\n        return sgn(a.y - b.y) < 0;\n};\nld dot(cm a, cm b) { return a.x * b.x + a.y * b.y; }\nld crs(cm a, cm b) { return a.x * b.y - a.y * b.x; }\nint ccw(cm a, cm b) { return sgn(crs(a, b)); }\nint ccw(cm a, cm b, cm c) { return ccw(b - a, c - a); }\n//AOJ1183\nint qeq(ld a, ld b, ld c, ld &d, ld &e)\n{\n    ld f = b * b - 4 * a * c;\n    if (sgn(f) < 0)\n        return 0;\n    ld g = sqrt(max(f, ld(0)));\n    d = (-b + g) / (2 * a);\n    e = (-b - g) / (2 * a);\n    return sgn(f) + 1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a, cm b, cm c)\n{\n    cm d = b - a;\n    ld e = dot(d, c - a);\n    if (sgn(e) <= 0)\n        return sgn(e) - 1;\n    return sgn(e - norm(d)) + 1;\n}\nld tri2(cm a, cm b, cm c)\n{\n    return crs(b - a, c - a);\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a, cm b, cm c, cm d)\n{\n    if (ccw(a, b, c) == -1)\n        swap(b, c);\n    return min({ccw(a, b, d), ccw(b, c, d), ccw(c, a, d)}) + 1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a, ld b, ld c)\n{\n    return acos(min(max((a * a + b * b - c * c) / (2 * a * b), ld(-1)), ld(1)));\n}\n\nusing ln = pair<cm, cm>;\ncm dir(ln a) { return a.b - a.a; }\ncm eval(ln a, ld b) { return a.a + dir(a) * b; }\ncm proj(ln a, cm b)\n{\n    cm c = dir(a);\n    return a.a + c * dot(c, b - a.a) / norm(c);\n}\ncm refl(ln a, cm b)\n{\n    return ld(2) * proj(a, b) - b;\n}\n//AOJ0153\nld dsp(ln a, cm b)\n{\n    cm c = proj(a, b);\n    if (abs(bet(a.a, a.b, c)) <= 1)\n        return abs(b - c);\n    return min(abs(b - a.a), abs(b - a.b));\n}\nint ccw(ln a, cm b) { return ccw(a.a, a.b, b); }\n//AOJ1157\n//0-no,1-yes(endpoint),2-yes(innner)\nint iss(ln a, ln b)\n{\n    int c = ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b);\n    int d = ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b);\n    int e = max(c, d);\n    if (e)\n        return 1 - e;\n    int f = bet(a.a, a.b, b.a), g = bet(a.a, a.b, b.b);\n    if (max(f, g) == -2 || min(f, g) == 2)\n        return 0;\n    return 1;\n}\n//AOJ1157\nld dss(ln a, ln b)\n{\n    if (iss(a, b))\n        return 0;\n    return min({dsp(a, b.a), dsp(a, b.b), dsp(b, a.a), dsp(b, a.b)});\n}\n\nusing cr = pair<cm, ld>;\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cr a, cm b)\n{\n    return sgn(a.b - abs(b - a.a)) + 1;\n}\n//AOJ0153\n//0-no,1-touch,2-cross\nint ids(cr a, ln b)\n{\n    return sgn(a.b - dsp(b, a.a)) + 1;\n}\n//AOJ0129 (touch以外)\n//0-no(in),1-touch(in),2-cross,3-touch(out),4-no(out)\nint ics(cr a, ln b)\n{\n    int c = ids(a, b);\n    if (c <= 1)\n        return 4 - c;\n    return sgn(max(abs(b.a - a.a), abs(b.b - a.a)) - a.b) + 1;\n}\n//AOJ1183\nint ccl(cr a, ln b, ld &c, ld &d)\n{\n    cm e = dir(b);\n    cm f = b.a - a.a;\n    return qeq(norm(e), 2 * dot(e, f), norm(f) - a.b * a.b, c, d);\n}\n//AOJ0023\n//0-apart,1-coinside,2-a<b,3-a<=b,4-a>b,5-a>=b,6-a touch b,7-a cross b\nint icc(cr a, cr b)\n{\n    ld c = abs(a.a - b.a);\n    if (sgn(c) == 0 && sgn(a.b - b.b) == 0)\n        return 1;\n    int d = sgn(c + a.b - b.b);\n    if (d <= 0)\n        return d + 3;\n    int e = sgn(c + b.b - a.b);\n    if (e <= 0)\n        return e + 5;\n    int f = sgn(a.b + b.b - c);\n    if (f >= 0)\n        return f + 6;\n    return 0;\n}\n//AOJ1183\n//two intersections l,r seen be a.a\n//assume two circles cross\nln ccc(cr a, cr b)\n{\n    ld c = arg(b.a - a.a);\n    ld d = arg(a.b, abs(b.a - a.a), b.b);\n    return ln(a.a + polar(a.b, c + d), a.a + polar(a.b, c - d));\n}\n\ncm readcm()\n{\n    ld a, b;\n    cin >> a >> b;\n    return cm(a, b);\n}\n\nld readld()\n{\n    ld a;\n    cin >> a;\n    return a;\n}\n\nsigned main()\n{\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    while (1)\n    {\n        cm a = readcm();\n        cm b = readcm();\n        cm c = readcm();\n        cr d{readcm(), readld()};\n        if (cin.eof())\n            break;\n        char ans;\n        if (cont(d, a) && cont(d, b) && cont(d, c))\n            ans = 'b';\n        else\n        {\n            int e = max({ids(d, ln{a, b}), ids(d, ln{b, c}), ids(d, ln{c, a})});\n            dmp(e);\n            if (e == 2)\n                ans = 'c';\n            else\n            {\n                if (cont(a, b, c, d.a))\n                    ans = 'a';\n                else\n                {\n                    if (e == 1)\n                        ans = 'c';\n                    else\n                        ans = 'd';\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\nclass Circle {\npublic:\n\tPoint p; long double r;\n\tCircle() : p(Point()), r(0.0L) {};\n\tCircle(Point p_) : p(p_), r(0.0L) {};\n\tCircle(Point p_, long double r_) : p(p_), r(r_) {};\n\tCircle(long double x_, long double y_) : p(Point(x_, y_)), r(0.0L) {};\n\tCircle(long double x_, long double y_, long double r_) : p(Point(x_, y_)), r(r_) {};\n\tfriend bool operator==(const Circle& c1, const Circle& c2) { return c1.p == c2.p && c1.r == c2.r; }\n\tfriend bool operator!=(const Circle& c1, const Circle& c2) { return !(c1 == c2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3; Segment l1, l2, l3; Circle c;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> c.p.px >> c.p.py >> c.r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, c.p) <= c.r && dst(p2, c.p) <= c.r && dst(p3, c.p) <= c.r) printf(\"b\\n\");\n\t\telse if(dst(l1, c.p) >= c.r && dst(l2, c.p) >= c.r && dst(l3, c.p) >= c.r) printf(contain({p1, p2, p3}, c.p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source().ccw(s.target(), source()) * s.source().ccw(s.target(), target()) <= EPS;\n    bool b = source().ccw(target(), s.source()) * source().ccw(target(), s.target()) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n\n    // 円の中心が三角形の内部\n    bool centerInTriangle = true;\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) == ABOVE) ++ccw;\n        if(e.ccw(circle.center()) == UNDER) ++cw;\n    }\n    centerInTriangle = (cw == 3) || (ccw == 3);\n\n    if(centerInTriangle && (edgesOutOfCircle == 3)) return \"a\";\n    if(!centerInTriangle && (edgesOutOfCircle == 3)) return \"d\";\n    return \"c\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1 + (a2 - a1) * (cross(b2 - b1,b1 - a1) / cross(b2 - b1,a2 - a1));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    point r=intersection_l(a1,a2,b1,b2);\n    return is_point_on_line(a1,a2,r) && is_point_on_line(b1,b2,r);\n  }\n\n}\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=100001;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n  \n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n    \n  return (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\n  double ans=0;\n  int tsz=t.size();\n\n  for(int i=0;i<tsz;i++){\n    double tmp=dist(t[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,t,tsz);\n  double res2=DBL_MAX;\n\n  t.push_back(t[0]);\n\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p;\n  vector<point> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    t.clear();\n    for(int i=0;i<3;i++){\n      cin >> p.x >> p.y;\n      if(p.x==0 && p.y==0)return 0;\n      t.push_back(p);\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(t,C);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble dist(const P& a, const P& b)\n{\n\treturn sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nbool isIntoC(const P& p, const C& c)\n{\n\treturn dist(p, c.p) < c.r+EPS;\n}\n\nbool isIntoC(const L& l, const C& c)\n{\n\treturn dist(l[0], c.p) < c.r+EPS && dist(l[1], c.p) < c.r+EPS;\n}\n\nbool intersectSC(const L& l, const C& c)\n{\n\tif(isIntoC(l, c)) return false;\n\t\n\tdouble vc=dot(l[1]-l[0], c.p-l[0]);\n\tif(vc+EPS<0)\n\t{\n\t\treturn dist(l[0], c.p)+EPS<c.r;\n\t}\n\t\n\tdouble vv=dot(l[1]-l[0], l[1]-l[0]);\n\t\n\tif(vc > vv)\n\t{\n\t\tdouble d=dist(l[1], c.p);\n\t\t\n\t\treturn d*d+EPS<c.r*c.r;\n\t}\n\t\n\tdouble cc=dot(c.p-l[0], c.p-l[0]);\n\t\n\treturn cc-(vc/vv)*vc+EPS < c.r*c.r;\n}\n\nint main()\n{\n\tint x,y,r;\n\twhile(scanf(\"%d%d\", &x, &y), (x||y))\n\t{\n\t\tvector<P> tri;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\ttri.push_back(P(x,y));\n\t\t\tif(i==2) break;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t}\n\t\n\t\tscanf(\"%d%d%d\", &x,&y,&r);\n\t\tC c(P(x,y), r);\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\tif(!isIntoC(tri[i], c))\n\t\t\t{\n\t\t\t\tg=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(g) \n\t\t{\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tg=false;\n\t\tfor(int i=0; i<tri.size(); i++)\n\t\tfor(int j=i+1; j<tri.size(); j++)\n\t\t{\n\t\t\tif(intersectSC(L(tri[i], tri[j]), c))\n\t\t\t{\n\t\t\t\tg=true;\n\t\t\t}\n\t\t}\n\t\tif(g)\n\t\t{\n\t\t\tputs(\"c\");\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tint cnt=0, cr[3];\n\t\tcr[0]=cross(tri[0]-tri[1], tri[0]-c.p);\n\t\tcr[1]=cross(tri[1]-tri[2], tri[1]-c.p);\n\t\tcr[2]=cross(tri[2]-tri[0], tri[2]-c.p);\n\t\t\n\t\tif(cr[0]>EPS&&cr[1]>EPS&&cr[2]>EPS) puts(\"a\");\n\t\telse puts(\"d\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<sstream>\n#include<functional>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define REP(i,s,e) for(int i=int(s);i<int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\n#define EPS 1e-9\n\nusing namespace std;\n\nbool f(double x1,double y1,double x2,double y2,double x4,double y4,double r){\n\ndouble p=(y2-y1)/(x2-x1);\ndouble q=y1-y4-p*(x1-x4);\ndouble d=p*p*q*q-(1+p*p)*(q*q-r*r);\n\nif(x1!=x2){\nif(d>=0 && (-p*q+sqrt(d))/(1+p*p)+EPS<max(x2-x4,x1-x4) && (-p*q-sqrt(d))/(1+p*p)>min(x2-x4,x1-x4)+EPS)\nreturn true;\nelse return false;\n}\nelse if(abs(x1-x4)<=r && max(y1-y4,y2-y4)>sqrt(r*r-(x1-x4)*(x1-x4))+EPS && min(y1-y4,y2-y4)+EPS<-sqrt(r*r-(x1-x4)*(x1-x4)))\nreturn true;\nelse return false;\n}\n\nbool g(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4,double r){\n\ndouble a=sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4));\ndouble b=(y1-y4)/(x1-x4);\ndouble c=(y2-y3)/(x2-x3);\ndouble x=(y2-y4-c*(x2-x4))/(b-c);\ndouble y=(b*(y2-y4)-b*c*(x2-x4))/(b-c);\n\nif(x1!=x4 && x2!=x3 && b!=c && a>sqrt((x-x1+x4)*(x-x1+x4)+(y-y1+y4)*(y-y1+y4))+EPS)\nreturn true;\nelse if(x1==x4 && x2!=x3 && abs(y1-y4)>abs(y1-y2+c*(x2-x4))+EPS)\nreturn true;\nelse if(x1!=x4 && x2==x3 && a>sqrt((x2-x1)*(x2-x1)+(b*(x2-x4)-y1+y4)*(b*(x2-x4)-y1+y4))+EPS)\nreturn true;\nelse return false;\n\n}\n\nint main(){\n\ndouble x1,y1,x2,y2,x3,y3,x4,y4,r;\n\nwhile(true){\n\ncin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\nif(x1==0 && y1==0) break;\n\n\ndouble a,b,c;\na=(x1-x4)*(x1-x4)+(y1-y4)*(y1-y4);\nb=(x2-x4)*(x2-x4)+(y2-y4)*(y2-y4);\nc=(x3-x4)*(x3-x4)+(y3-y4)*(y3-y4);\n\nif(a<r*r && b<r*r && c<r*r)\ncout << \"b\" << endl;\nif(!(a<r*r && b<r*r && c<r*r) && !(a>r*r && b>r*r && c>r*r))\ncout << \"c\" << endl;\n\nif(a>r*r && b>r*r && c>r*r){\nif(f(x1,y1,x2,y2,x4,y4,r) || f(x2,y2,x3,y3,x4,y4,r) || f(x1,y1,x3,y3,x4,y4,r))\ncout << \"c\" << endl;\nelse if(g(x1,y1,x2,y2,x3,y3,x4,y4,r) || g(x2,y2,x1,y1,x3,y3,x4,y4,r) || g(x3,y3,x2,y2,x1,y1,x4,y4,r))\ncout << \"d\" << endl;\nelse cout << \"a\" << endl;\n\n}\n}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])==OUT)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[i])==IN)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        if(contains(g,c))puts(\"a\");\n        else if(contains(c,g))puts(\"b\");\n        else{\n            bool x=false;\n            for(int i=0;i<g.size();i++){\n                if(intersectCS(c,Segment(g[i],next(g,i))))x=true;\n            }\n            puts(x?\"c\":\"d\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Point{ int x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Point c; int r; };\n\ninline double dist(const Point &p1, const Point &p2){\n\treturn sqrt( pow(p2.x-p1.x,2.0)+pow(p2.y-p1.y,2.0) );\n}\ninline double dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble b = 1;\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + b * p.y + c ) / sqrt( pow(a,2.0)+pow(b,2.0) );\n\t}\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) > 0;\n}\n\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( isLeft( t.a, t.b, p ) && isLeft( t.b, t.c, p ) && isLeft( t.c, t.a, p ) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r <= dist( t.a, t.b, c.c ) &&\n\t\t\tc.r <= dist( t.b, t.c, c.c ) &&\n\t\t\tc.r <= dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) <= c.r &&\n\t  dist( t.b, c.c ) <= c.r &&\n\t  dist( t.c, c.c ) <= c.r )\n\t  return true;\n  else\n\t  return false;\n}\nbool isCross(const Point &tp1, const Point &tp2, const Circle &c)\n{\n\tPoint p1 = tp1;\n\tPoint p2 = tp2;\n\tif( p2.x < p1.x )\n\t\tswap( p1, p2 );\n\n\tif( dist( p1, p2, c.c ) > c.r )\n\t\treturn false;\n\telse{\n\t\tif( p1.x != p2.x ){\n\t\t\tdouble x1, x2;\n\t\t\tdouble a = (p2.y - p1.y) / (p2.x - p1.x);\n\t\t\tdouble b = -a * p1.x + p1.y;\n\t\t\tdouble A = 1 + pow(a,2.0);\n\t\t\tdouble B = -( c.c.x - a * c.c.x + a * c.c.y );\n\t\t\tdouble C = pow( c.c.x, 2.0 ) + pow( b, 2.0 ) - 2*b*c.c.y + pow( c.c.y, 2.0 ) - pow( c.r,2.0 );\n\n\t\t\tx1 = ( -B + sqrt( pow(B,2.0) - A * C ) ) / A;\n\t\t\tx2 = ( -B - sqrt( pow(B,2.0) - A * C ) ) / A;\n\n\t\t\tif( p1.x <= x1 && x1 <= p2.x || p1.x <= x2 && x2 <= p2.x )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}else{\n\t\t\tif( p2.y < p1.y )\n\t\t\t\tswap( p1, p2 );\n\n\t\t\tdouble d = dist( p1, p2, c.c );\n\t\t\tdouble l = sqrt( pow(c.r,2.0) - pow(d,2.0) );\n\n\t\t\tdouble y1 = c.c.y - l;\n\t\t\tdouble y2 = c.c.y + l;\n\n\t\t\tif( p1.y <= y1 && y1 <= p2.y || p1.y <= y2 && y2 <= p2.y )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( !isCross(t.a,t.b,c) && !isCross(t.b,t.c,c) && !isCross(t.c,t.a,c) )\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t, c ) )\n\t\treturn 'b';\n\tif( isCross( t,c ) )\n\t\treturn 'c';\n\telse\n\t\treturn 'd';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define EPS (1e-8)\n\ntypedef complex<double> P;\ntypedef P Vec;\n\nstruct Line {\n\tP p;\n\tVec v;\n\t\n\tLine() {}\n\tLine(P p, Vec v) : p(p), v(v) {}\n\t\n\tP getPoint(double t) {\n\t\treturn p + v * t;\n\t}\n};\n\nstruct Circle {\n\tP p;\n\tdouble r;\n\t\n\tCircle() {}\n\tCircle(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot(Vec a, Vec b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Vec a, Vec b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool isInCir(Circle &c, P &p) {\n\treturn norm(c.p - p) <= c.r*c.r + EPS;\n}\n\nbool isInSeg(Line &s, P &p) {\n\tVec a = s.v, b = p - s.p;\n\tdouble l1 = abs(a), l2 = abs(b);\n\t\n\treturn dot(a, b) >= l1*l2 - EPS && dot(a, b) <= l1*l2 + EPS && l1 >= l2 - EPS;\n}\n\nbool isInTri(P &a, P &b, P &c, P &d) {\n\tP p[4];\n\tp[0] = a; p[1] = b; p[2] = c; p[3] = d;\n\t\n\tint cnt = 0;\n\tREP(i, 3) {\n\t\tVec v = p[3] - p[i];\n\t\tLine s(p[i], p[(i + 1) % 3] - p[i]);\n\t\t\n\t\t//if (isInSeg(s, p[3])) return true;\n\t\tif (cross(s.v, v) < -EPS) cnt++;\n\t}\n\treturn (cnt == 0 || cnt == 3);\n}\n\ndouble distanceSP(Line &s, P &p) {\n\tVec a = s.v, b = p - s.p;\n\treturn abs(cross(a, b)) / abs(a);\n}\n\nint main() {\n\tdouble x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile (cin >> x1 >> y1, x1 || y1) {\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\t\n\t\tP p[4] = {P(x1, y1), P(x2, y2), P(x3, y3), P(x4, y4)};\n\t\tLine seg[3] = {Line(p[0], p[1] - p[0]), Line(p[1], p[2] - p[1]), Line(p[2], p[0] - p[2])};\n\t\tCircle c(p[3], r);\t\t\n\t\t\n\t\tdouble m = min(distanceSP(seg[0], c.p), min(distanceSP(seg[1], c.p), distanceSP(seg[2], c.p)));\n\t\t\n\t\tif (abs(c.p - p[0]) <= c.r + EPS && abs(c.p - p[1]) <= c.r + EPS && abs(c.p - p[2]) <= c.r + EPS)\n\t\t\tputs(\"b\");\n\t\telse if (isInTri(p[0], p[1], p[2], p[3])) {\n\t\t\tif (c.r <= m + EPS) puts(\"a\");\n\t\t\telse puts(\"c\");\n\t\t}\n\t\telse if (c.r < m - EPS) puts(\"d\");\n\t\telse puts(\"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn (((cross(a,b)>0||EQ(0,cross(a,b)))&&(cross(b,c)>=0||EQ(0,cross(b,c)))&&(cross(c,a)>=0||EQ(0,cross(a,b))))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t&&((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r&&!EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r&&!EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r&&!EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=min(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>EPS)return 1; //intersect\n            if(in_triangle(p,t))return 2;//c in t\n            else if(r-d<-EPS)return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n}\n\n\nusing namespace geo;\n\nint main(){\n    int x,y,r;\n    while(cin>>x>>y,x!=0||y!=0){\n        Poly t={P(x,y)};\n        REP(i,2){\n            cin>>x>>y;\n            t.pb(P(x,y));\n        }\n        cin>>x>>y>>r;\n        C c(P(x,y),r);\n        int res=is_triangle_C(t,c);\n        if(res==2)cout<<\"a\"<<endl;\n        if(res==3)cout<<\"b\"<<endl;\n        if(res==1)cout<<\"c\"<<endl;\n        if(res==0)cout<<\"d\"<<endl;\n\n    }\n   \n    \n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n      getline(cin, str);\n\n      if(i == 0 && str == \"0 0\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\") break;\n\n\n    if(distance(&d->p[0], &c->p) <= c->radius&& distance(&d->p[1], &c->p) <= c->radius&& distance(&d->p[2], &c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) >= c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) >= c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) >= c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) <= distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) <= distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) <= distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else\n            cout << 'a' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) <= c->radius|| dist_line(&d->p[0], &d->p[2], &c->p) <= c->radius|| dist_line(&d->p[1], &d->p[2], &c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point& a, const Point& b) { return Point{ a.px - b.px,a.py - b.py }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dst(const Point& a, const Point& b) { return abs(Minus(b , a)); }\nlong double dst(const Line& a, const Point& b) {\n\tlong double E = dot(Minus(a.p2, a.p1), Minus(b, a.p1));\n\tlong double F = dot(Minus(a.p1, a.p2), Minus(b, a.p2));\n\tif (E < -1e-7)return abs(Minus(b, a.p1));\n\tif (F < -1e-7)return abs(Minus(b, a.p2));\n\treturn abs(crs(Minus(a.p2, a.p1), Minus(b, a.p1)) / abs(Minus(a.p2, a.p1)));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 1e-7 && 1e-7 < b.py)\n\t\t\tif (crs(a, b) < -1e-7) in = !in;\n\t\tif (fabs(crs(a, b)) <= 1e-7 && dot(a, b) <= 1e-7) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\twhile (true) {\n\t\tPoint r1, r2, r3, r4; long double r;\n\t\tcin >> r1.px >> r1.py; if (fabs(r1.px) <= 1e-7 && fabs(r1.py) <= 1e-7)break;\n\t\tcin >> r2.px >> r2.py >> r3.px >> r3.py >> r4.px >> r4.py >> r;\n\t\tLine l1 = Line{ r1,r2 }, l2 = { r2,r3 }, l3 = { r3,r1 };\n\t\tlong double c1 = min(dst(l1, r4), min(dst(l2, r4), dst(l3, r4)));\n\t\tlong double c2 = max(dst(r1, r4), max(dst(r2, r4), dst(r3, r4)));\n\t\tlong double c3 = min(dst(r1, r4), min(dst(r2, r4), dst(r3, r4)));\n\t\t//cout << dst(l1, r4) << ' ' << dst(l2, r4) << ' ' << dst(l3, r4) << endl;\n\t\tint c4 = contain({ r1,r2,r3 }, r4);\n\t\tif (c1 >= r - 1e-7 && c4 != 0) { cout << \"a\" << endl; }\n\t\telse if (c2 <= r + 1e-7) { cout << \"b\" << endl; }\n\t\telse if (c3 <= r + 1e-7) { cout << \"c\" << endl; }\n\t\telse { cout << \"d\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n\ndouble dot(P& a, P& b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P& a, P& b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint sign(double x){\n  if(x > EPS) return 1;\n  if(x < -EPS) return -1;\n  return 0;\n}\n\n//a -> b, a -> c\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(sign(cross(b, c)) > 0) return 1; //反時計\n  if(sign(cross(b, c)) < 0) return -1; //時計\n  if(sign(dot(b, c)) < 0) return +2; //c-a-b\n  if(norm(b) < norm(c)) return -2; //a-b-c\n  return 0; //a-c-b\n}\nbool cross(P a, P b, P c, double r){\n  double d1 = abs(c - a);\n  double d2 = abs(c - b);\n  if(d1 > d2) swap(d1, d2);\n  if(d1 < r && r < d2) return true;\n  if(ccw(a, b, c) == 0 && r < d2) return true;\n  if(ccw(a, b, c) != 1 && ccw(a, b, c) != -1) return false;\n  b -= a; c -= a;\n  double k = dot(b, c) / norm(b);\n  if(0 < k && k < 1 && abs(c - k * b) < r && r < d2) return true;\n  else return false;\n}\n\n\nstring solve(P p[3], P c, double r){\n  double maxdist = 0;\n  REP(i, 3) maxdist = max(maxdist, abs(p[i] -  c));\n  if(maxdist < r) return \"b\";\n  bool circle_in = false;\n  int ccw_v[3];\n  if(ccw(p[0], p[1], p[2]) == -1) swap(p[1], p[2]);\n  REP(i, 3) ccw_v[i] = ccw(p[i], p[(i + 1) % 3], c);\n  if(ccw_v[0] == ccw_v[1] && ccw_v[1] == ccw_v[2] && ccw_v[0] == 1){\n    circle_in = true;\n  }\n  bool iscross = false;\n  REP(i, 3) iscross |= cross(p[i], p[(i + 1) % 3], c, r);\n  if(circle_in && !iscross) return \"a\";\n  if(iscross) return \"c\";\n  else return \"d\";\n}\n\nint main(){\n  P p[3];\n  P c; double r;\n  while(cin>>p[0].X>>p[0].Y>>p[1].X>>p[1].Y>>p[2].X>>p[2].Y>>c.X>>c.Y>>r){\n    cout<<solve(p, c, r)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0){\n\t\t\tif(acx*acx+acy*acy<=r*r)return true;\n\t\t}else{\n\t\t\tif(abx*acx+aby*acy>abx*abx+aby*aby){\n\t\t\t\tif(bcx*bcx+bcy*bcy<=r*r)return true;\n\t\t\t}else if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<0)ok1=false;\n\telse ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<0)ok1=false;\n\telse ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<0)ok1=false;\n\telse ok2=false;\n\treturn ok1||ok2;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<=r*r&&(c-g)*(c-g)+(d-h)*(d-h)<=r*r&&(e-g)*(e-g)+(f-h)*(f-h)<=r*r)printf(\"b\\n\");\n\t\telse if(inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& _p, double _r) : p(_p), r(_r) {} \n};\n\n// code for problem\n\nint x, y, r;\nP tr[3];\nC cc;\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0 && d1 * d2 > 0 && d2 * d0 > 0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(6);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\td[3] = distP2LS(cc.p, L(tr[0], tr[1]));\n\td[4] = distP2LS(cc.p, L(tr[1], tr[2]));\n\td[5] = distP2LS(cc.p, L(tr[2], tr[0]));\n\tif(in && d[3] >= cc.r && d[4] >= cc.r && d[5] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tsort(d.begin(), d.end());\n\tif(d[0] <= cc.r) {\n\t\tprintf(\"c\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect\n\tprintf(\"d\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\n\nstruct Line{\n\tLine(){\n\n\t}\n\tLine(Point a,Point b){\n\t\tp[0] = a;\n\t\tp[1] = b;\n\t}\n\tPoint p[2];\n};\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n};\n\n\nPoint point[3];\nLine line[3];\nCircle circle;\ntypedef vector<Point> Polygon;\n\nPoint calc_minus(Point a,Point b){\n    Point ret;\n\n    ret.x = a.x-b.x;\n    ret.y = a.y-b.y;\n\n    return ret;\n}\n\ndouble calc_len(Vector a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\n//線分ではなく直線と点の距離\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0]))/calc_len(calc_minus(l.p[1],l.p[0])));\n}\n\n//点と線分の距離\ndouble getDistanceSP(Line l,Point p){\n\tif(dot(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0])) < 0.0)return calc_len(calc_minus(p,l.p[0]));\n\tif(dot(calc_minus(l.p[0],l.p[1]),calc_minus(p,l.p[1])) < 0.0)return calc_len(calc_minus(p,l.p[1]));\n\treturn getDistanceLP(l,p);\n}\n\n\n/*\n * IN 2\n * ON 1\n * OUT 0\n *\n */\nint contains(Polygon g,Point p){\n\tint n = g.size();\n\tbool x = false;\n\tfor(int i = 0; i < n; i++){\n\t\tPoint a = g[i]-p,b = g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS)return 1;\n\t\tif(a.y > b.y)swap(a,b);\n\t\tif(a.y < EPS && EPS < b.y && cross(a,b) > EPS) x = !x;\n\t}\n\treturn (x ? 2:0);\n}\n\ndouble calc_dist(Point A,Point B){\n\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\nvoid func(){\n\n\tfor(int i = 1; i <= 2; i++){\n\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t}\n\n\tfor(int i = 0; i <= 2; i++){\n\n\t\tline[i].p[0] = point[i];\n\t\tline[i].p[1] = point[(i+1)%3];\n\t}\n\n\tPolygon polygon;\n\tfor(int i = 0; i < 3; i++){\n\n\t\tpolygon.push_back(point[i]);\n\t}\n\n\tscanf(\"%lf %lf\",&circle.center.x,&circle.center.y);\n\tscanf(\"%lf\",&circle.r);\n\n\tdouble dist1 = getDistanceSP(line[0],circle.center);\n\tdouble dist2 = getDistanceSP(line[1],circle.center);\n\tdouble dist3 = getDistanceSP(line[2],circle.center);\n\tbool is_in = contains(polygon,circle.center);\n\n\tif(calc_dist(point[0],circle.center) <= circle.r && calc_dist(point[1],circle.center) <= circle.r\n\t\t\t&& calc_dist(point[2],circle.center) <= circle.r){\n\n\t\tprintf(\"b\\n\");\n\n\t}else if(is_in && dist1 >= circle.r && dist2 >= circle.r && dist3 >= circle.r){\n\n\t\tprintf(\"a\\n\");\n\n\t}else{\n\n\t\tif(dist1 > circle.r && dist2 > circle.r && dist3 > circle.r){\n\n\t\t\tprintf(\"d\\n\");\n\t\t}else{\n\n\t\t\tprintf(\"c\\n\");\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint x,y;\n\n\twhile(true){\n\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tif(x == 0 && y == 0)break;\n\n\t\tpoint[0].x = x;\n\t\tpoint[0].y = y;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\n\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nint ccw(P a, P b, P c) {\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) : x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y-l.x;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\nR distSP(const L &s, const P &p) {\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\nstruct T {\n    P d[3];\n    T() {}\n    T(P x, P y, P z) {\n        d[0] = x; d[1] = y; d[2] = z;\n    }\n    P& operator[](int p) {\n        return d[p];\n    }\n    const P& operator[](int p) const {\n        return d[p];\n    }\n    int size() const {\n        return 3;\n    }\n};\n\nP cu(const T &t, int i) {\n    return t[(i%3+3)%3];\n}\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const T &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nbool solve() {\n    T t;\n    for (int i = 0; i < 3; i++) {\n        double x, y;\n        if (scanf(\"%lf %lf\", &x, &y) != 2) return false;\n        t[i] = P(x, y);\n    }\n    C c;\n    double x, y;\n    cin >> x >> y;\n    c.p = P(x, y);\n    double r;\n    cin >> r;\n    c.r = r;\n\n    R ma = -1e9, mi = 1e9;\n    for (int i = 0; i < 3; i++) {\n        ma = max(ma, abs(t[i]-c.p));\n        mi = min(mi, distLP(L(cu(t, i), cu(t, i+1)), c.p));\n    }\n//    cout << ma << \" \" << mi << endl;\n    if (sgn(ma, c.r) != -1) {\n        cout << \"b\" << endl;\n        return true;\n    }\n\n    if (contains(t, c.p) != 0 && sgn(c.r, mi) != -1) {\n        cout << \"a\" << endl;\n        return true;\n    }\n\n    if (sgn(mi, c.r) != -1) {\n        cout << \"c\" << endl;\n        return true;\n    }\n    cout << \"d\" << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\ntypedef complex<double> P;\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nint chk(P a,P b,double r){\n\tdouble t = abs(a-b) - r;\n\tif( fabs(t) < EPS ) return 0;\n\treturn t < 0 ? -1 : 1;\n}\ndouble cross(P a,P b){\n\treturn imag(a*conj(b));\n}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\n\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nint main(){\n\tP a,b,c,d;\n\tdouble r;\n\twhile(cin >> a.real() >> a.imag() , a.real() != 0 || a.imag() != 0 ){\n\t\tcin >> b.real() >> b.imag();\n\t\tcin >> c.real() >> c.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tcin >> r;\n\t\t\n\t\tint in = 0;\n\t\tint mk = cross(a-d,b-d) <= 0 ;\n\t\tif( mk == (cross(b-d,c-d) <= 0) && mk == (cross(c-d,a-d) <= 0)){\n\t\t\tin = 1;\n\t\t}\n\t\t\n\t\tif( chk(a,d,r) <= 0 &&  chk(b,d,r) <= 0 &&  chk(c,d,r) <= 0 ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( chk(a,d,r) >= 0 &&  chk(b,d,r) >= 0 &&  chk(c,d,r) >= 0){\n\t\t\tif( distanceSP(L(a,b),d) < r - EPS || distanceSP(L(b,c),d) < r - EPS || distanceSP(L(a,c),d) < r - EPS  ){\n\t\t\t\tcout << \"c\" << endl;\n\t\t\t}else if( in ){\n\t\t\t\tcout << \"a\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"d\" << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-c,ar=d-a;\n\tP bb=b-a,br=d-b;\n\tP cc=c-b,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nbool foo2(P a,P b,P p,double r){\n\tdouble t=dot(b-a,p-a);\n\tif(t<-EPS){\n\t\t// cout<<\"a\"<<endl;\n\t\tif(r-abs(p-a)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tif(t-abs(b-a)*abs(b-a)>EPS){\n\t\t// cout<<\"b\"<<endl;\n\t\tif(r-abs(p-b)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t// cout<<\"c\"<<endl;\n\tdouble h=abs(p-a)*abs(p-a)-t*t/abs(b-a)/abs(b-a);\n\t// printf(\"%.6lf\\n\",h);\n\tif(h-r*r>EPS){\n\t\treturn false;\n\t}\n\treturn true;\n}\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tcin>>r;\n\t\t// cout<<r<<endl;\n\t\tif(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(r-t>-EPS){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(foo2(z[0],z[1],z[3],r)||foo2(z[1],z[2],z[3],r)||foo2(z[2],z[0],z[3],r)){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse cout<<\"d\\n\";\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n\t// cout<<abs(P(0,0)-P(1,1))<<endl;\n}\n\n\n\n}\nmain() try{\n\t// vector<P> d;\n\t// double r;\n\t// rep(i,3){\n\t\t// double x,y;\n\t\t// cin>>x>>y;\n\t\t// d.PB(P(x,y));\n\t// }\n\t// cin>>r;\n\t// cout<<foo2(d[0],d[1],d[2],r)<<endl;\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-c,ar=d-a;\n\tP bb=b-a,br=d-b;\n\tP cc=c-b,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tcin>>r;\n\t\t// cout<<r<<endl;\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(t<r){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t}\n\t\telse if(r>=abs(z[0]-z[3])||r>=abs(z[1]-z[3])||r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse cout<<\"d\\n\";\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nstruct Point{\n  int x;\n  int y;\n};\n\nstruct Delta{\n  Point p[3];\n};\n\nstruct Circle{\n  Point p;\n  int radius;\n};\n\ndouble distance(Point p1, Point p2){\n  return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n\ndouble dist_line(Point pl1, Point pl2, Point p){\n  int a = pl1.x - pl2.x;\n  int b = pl2.y - pl1.y;\n  int c = pl1.y * pl2.x - pl1.x * pl2.y;\n  double ans = b * p.x + a * p.y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n\t  cerr << \"cannot find the file\" << endl;\n\t  return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n\tDelta *d = (Delta *) malloc(sizeof(Delta));\n\tfor (int i = 0; i < 5; i++) {\n//\t\tgetline(ifs, str);\n\t\tcin >> str;\n\n      if(str == \"0 0\") break;\n\t  \n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n\t      if(str[j] == ' '){\t\t\t\n\t\t\tstr[j] = '\\0';\n\t\t\tbreak;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\t  \n    }\n    if(str == \"0 0\") break;\n\t\n\n    if(distance(d->p[0], c->p) <= c->radius&& distance(d->p[1], c->p) <= c->radius&& distance(d->p[2], c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(d->p[0], d->p[1], c->p) >= c->radius&& dist_line(d->p[0], d->p[2], c->p) >= c->radius&& dist_line(d->p[1], d->p[2], c->p) >= c->radius){\n\t\tif (dist_line(d->p[0], d->p[1], d->p[2]) <= distance(d->p[0], c->p) && dist_line(d->p[1], d->p[2], d->p[0]) <= distance(d->p[1], c->p) && dist_line(d->p[2], d->p[0], d->p[1]) <= distance(d->p[2], c->p))\n\t\t\tcout << 'd' << endl;\n\t\telse\n\t\t\tcout << 'a' << endl;\n    }\n    else if(dist_line(d->p[0], d->p[1], c->p) <= c->radius|| dist_line(d->p[0], d->p[2], c->p) <= c->radius|| dist_line(d->p[1], d->p[2], c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\ndouble sign(double r) { return r < -EPS ? -1.0 : r > EPS ? 1.0 : 0.0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0.0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) <= 0.0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n\n// code for problem\nint x, y, r;\nvector<P> T;\nC cc;\n\nbool isPinC() {\n\tP e0 = T[0] - cc.p;\n\tP e1 = T[1] - cc.p;\n\tP e2 = T[2] - cc.p;\n\tdouble d0 = e0.det(e1);\n\tdouble d1 = e1.det(e2);\n\tdouble d2 = e2.det(e0);\n\tif(sign(d0) == sign(d1) && sign(d0) == sign(d2)) return true;\n\treturn false;\n}\n\nvoid solve() {\n\tvector<double> d(3);\n\td[0] = (T[0] - cc.p).norm();\n\td[1] = (T[1] - cc.p).norm();\n\td[2] = (T[2] - cc.p).norm();\n\tif(sign(d[0] - cc.r) <= 0.0 && sign(d[1] - cc.r) <= 0.0 && sign(d[2] - cc.r) <= 0.0) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\tbool in = isPinC();\n\tL l0(T[0], T[1]);\n\tL l1(T[1], T[2]);\n\tL l2(T[2], T[0]);\n\td[0] = l0.dSP(cc.p);\n\td[1] = l1.dSP(cc.p);\n\td[2] = l2.dSP(cc.p);\n\tif(in && sign(d[0] - cc.r) >= 0.0 && sign(d[1] - cc.r) >= 0.0 && sign(d[2] - cc.r) >= 0.0) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > cc.r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\tT = vector<P>(3);\n\tfor(;;) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\tT[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n// ½ÊãÌ_ExNg\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// OÏ\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\n// àÏ\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\n// ¼ü\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n// ½p`\ntypedef vector<P> G;\n\n// ~\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0)   return +1; // ½vñè\n\tif(cross(b, c) < 0)   return -1; // vñè\n\tif(dot(b, c) < 0)     return +2; // c--a--b\n\tif(norm(b) < norm(c)) return -2; // a--b--c\n\treturn 0;\n}\n\n// üªÆ_Ìð·»è\nbool intersectSP(const L& s, const P& p){\n\treturn abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;\n}\n\n// ¼üãÌ_ÌËe\nP projection(const L& l, const P& p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\n// üªÆ_Ì£\ndouble distanceSP(const L& s, const P& p){\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nchar detect(const G& tri, const C& c)\n{\n\tbool inner[3];\n\trep(i, 3){\n\t\tinner[i] = abs(tri[i] - c.p) <= c.r;\n\t}\n\tif(inner[0] && inner[1] && inner[2])\n\t\treturn 'b';\n\tif(inner[0] || inner[1] || inner[2])\n\t\treturn 'c';\n\t\n\trep(i, 3){\n\t\tL l(tri[i], tri[(i+1)%3]);\n\t\tif(distanceSP(l, c.p) < c.r)\n\t\t\treturn 'c';\n\t}\n\t\n\tint v = 0;\n\trep(i, 3){\n\t\tint now = ccw(tri[i], tri[(i+1)%3], c.p);\n\t\tif(now * v < 0)\n\t\t\treturn 'd';\n\t\tv = now;\n\t}\n\t\n\treturn 'a';\n}\n\nint main()\n{\n\tfor(;;){\n\t\tG tri(3);\n\t\trep(i, 3){\n\t\t\tscanf(\"%lf%lf\", &tri[i].real(), &tri[i].imag());\n\t\t\tif(tri[i].real() == 0.0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(fabs(tri[0].real()) < EPS)\n\t\t\tbreak;\n\t\t\n\t\tP p;\n\t\tdouble r;\n\t\tscanf(\"%lf%lf%lf\", &p.real(), &p.imag(), &r);\n\t\tprintf(\"%c\\n\", detect(tri, C(p, r)));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define F first\n#define S second\n\n#define X real()\n#define Y imag()\n\n#define EPS (1e-7)\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\ntypedef pair<double, Point> Circle;\n\nbool isPointInCircle(const Point& p, const Circle& c) {\n  if(abs(p-c.S) < abs(c.F) + EPS) return true;\n  return false;\n}\n\ndouble dot(const Point& a, const Point& b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n\ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n  \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n\n\nenum struct ECont { OUT, ON, IN };\nECont contains(const Polygon& poly, const Point& p) {\n  bool in = 0;\n  for(int i=0; i<poly.size(); i++) {\n    Point a = poly[i] - p, b = poly[(i+1)%poly.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag()) {\n      if(cross(a, b) < 0) in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ECont::ON;\n  }\n  \n  return in ? ECont::IN : ECont::OUT;\n}\n\nint main() {\n  \n  while(1) {\n    Polygon points(3);\n    Circle circle;\n  \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n    \n      points[i] = Point(x, y);\n    }\n  \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n  \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n    \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3) {\n      int flg = 0;\n      for(int i=0; i<3; i++) {\n        if(contains(points, circle.S) == ECont::IN) {\n        //if(dot(points[(i+1)%3]-points[i], circle.S-points[i]) * dot(points[(i+2)%3]-points[(i+1)%3], circle.S-points[(i+1)%3]) > 0) {\n          flg ++;\n        }\n      }\n      if(flg == 3) { cout << 'a' << endl; continue; }\n    }\n\n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) <= circle.F + EPS;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P p;double r;};    //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(L a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//??´?????¨??´????????¢??? verified AOJ CGL_2\nint rLL(L a,L b){\n    if( cross(vec(a),vec(b))==0 ) return 2; //??????\n    if( dot(vec(a),vec(b))==0 )   return 1; //?????´\n    return 0;\n}\n\n// ?????¨??????????????????\nint contains(C c, P p){\n    double d = (c.p-p).abs();\n    if(d-c.r>EPS) return OUT;\n    if(abs(d-c.r)<EPS) return ON;\n    return IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n    if( dLP(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(L s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, L l){\n    int c1 = contains(c, l.p1);\n    int c2 = contains(c, l.p2);\n    if(c1 > c2) swap(c1, c2);\n    \n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (??\\????????¨???)\n    double d = dSP(l, c.p);\n    if(d-c.r<-EPS) return true;\n    if(d-c.r>EPS) return false;\n    return true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n    int c=0;\n    rep(i,pol.size()){\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n    }\n    if( c%pol.size() )return OUT;\n    return IN;\n}\n\n//?????¨???????§???¢???????????¶???????????????\nint CPOLarea(C c ,Polygon pol){\n    vector<L> lines;\n    vector<int> res(pol.size());\n    bool POLinC=true, isFar=true;\n    \n    rep(i,pol.size()){\n        if( contains(c,pol[i])==OUT )POLinC=false;\n        res[i] = contains(c,pol[i]);\n        lines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n        if( sqDist(c.p,pol[i])<=c.r*c.r )isFar=false;\n    }\n    \n    if( POLinC )                                        return 2;   //????§???¢??????????????¨b\n    if( isPointInsidePolygon(pol, c.p)==IN && isFar )   return 3;   //????§???¢????????¨??????a\n    rep(i,lines.size()) if( iCS(c,lines[i]) )           return 1;   //????§???¢??¨????????????c\n    return 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps),cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????´???????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b&&(a||b)){\n        Polygon pol(3);\n        pol[0] = P(a,b);\n        rep(i,2)cin>>pol[i+1].x>>pol[i+1].y;\n        C c;\n        cin>>c.p.x>>c.p.y>>c.r;\n        int res =  CPOLarea(c,pol);\n        \n        cout<<(char)('a'+(3-res))<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nstruct C {\n  P p;\n  double r;\n  C() : p(P(0,0)), r(0) {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2-s1,p-s1))/abs(s2-s1);\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2-s1, p-s1) < 0.0) return abs(p-s1);\n  if(dot(s1-s2, p-s2) < 0.0) return abs(p-s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nbool involve(const C &c, const P &s1, const P &s2) {\n  double dist = max(abs(c.p - s1), abs(c.p - s2));\n  return c.r - dist > -eps;\n}\n\nbool involve(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    double dist = getDistanceLP(a,b,c.p);\n    if(cross(b-a, c.p-a) > -eps && dist - c.r > -eps) {\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool involve(const C &c, const vector<P> &g) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(!involve(c, a, b)) return false;\n  }\n  return true;\n}\n\nbool isIntersect(const P &s1, const P &s2, const C &c) {\n  if(involve(c, s1, s2)) return false;\n  double dist = getDistanceSP(s1, s2, c.p);\n  return c.r - dist > eps;\n}\n\nbool isIntersect(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(isIntersect(a,b,c)) return true;\n  }\n  return false;\n}\n\nint main() {\n  vector<P> g(3);\n  C c;\n  while(1) {\n    for(int i = 0; i < g.size(); ++i) {\n      cin >> g[i].real() >> g[i].imag();\n      if(g[0].real() == 0 && g[0].imag() == 0) return 0;\n    }\n    if(cross(g[1]-g[0], g[2]-g[0]) < 0) swap(g[0], g[1]);\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n    if(involve(g,c)) cout << \"a\" << endl;\n    else if(involve(c,g)) cout << \"b\" << endl;\n    else if(isIntersect(g,c)) cout << \"c\" << endl;\n    else cout << \"d\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\ntypedef complex<ll> P;\n\nint x, y, r;\nP tri[3];\npair<P,ll> circle;\n\nll cross(P e1, P e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tll d0 = cross(e0, e1);\n\tll d1 = cross(e1, e2);\n\tll d2 = cross(e2, e0);\n\tif(d0 * d1 > 0 && d1 * d2 > 0 && d2 * d0 > 0) return true;\n\treturn false;\n}\n\nll norm2(P p) {\n\treturn p.real() * p.real() + p.imag() * p.imag();\n}\n\nvoid dist2(P p1, P p2, P p, ll& nm, ll& de) {\n\tll a = p2.imag() - p1.imag();\n\tll b = -(p2.real() - p1.real());\n\tll c = - a * p1.real() - b * p1.imag();\n\tnm = a * p.real() + b * p.imag() + c;\n\tnm = nm * nm;\n\tde = a * a + b * b;\n\tif(de == 0) {\n\t\tnm = norm2(p1 - p);\n\t\tde = 1;\n\t}\n}\n\n\nvoid solve() {\n\tll r2 = circle.second * circle.second;\n\tvector<pll> d(6);\n\td[3].first = norm2(tri[0] - circle.first); d[3].second = 1LL;\n\td[4].first = norm2(tri[1] - circle.first); d[4].second = 1LL;\n\td[5].first = norm2(tri[2] - circle.first); d[5].second = 1LL;\n\tif(d[3].first <= r2 && d[4].first <= r2 && d[5].first <= r2) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tbool iscin = inc();\n\tdist2(tri[0], tri[1], circle.first, d[0].first, d[0].second);\n\tdist2(tri[1], tri[2], circle.first, d[1].first, d[1].second);\n\tdist2(tri[2], tri[0], circle.first, d[2].first, d[2].second);\n\tif(iscin && (d[0].first >= r2 * d[0].second) &&\n\t\t        (d[1].first >= r2 * d[1].second) &&\n\t\t        (d[2].first >= r2 * d[2].second)) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\tbool inter = false;\n\trep(i,6) {\n\t\tif(d[i].first <= r2 * d[i].second) {\n\t\t\tinter = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(inter) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tscanf(\"%d\", &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct P{\n    P(){}\n    P(ll _r, ll _i):r(_r), i(_i){}\n    void real(const ll& v){r = v;}\n    void imag(const ll& v){i = v;}\n    ll r, i;\n};\n\nll real(const P& p){return p.r;}\nll imag(const P& p){return p.i;}\nll norm(const P& p){ll r = real(p), i = imag(p); return r * r + i * i;}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\nll cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\nll dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\n// (distance between ab and p) ^ 2\nll distance(const P& a, const P& b, const P& p){\n    ll c = cross(p-a, b-a);\n    return c * c / norm(b-a);\n}\n\nP ps[3], cc;\nll radius;\n\nbool doesLineAcrossCircle(const P& a, const P& b){\n    if(distance(a, b, cc) > radius * radius){return false;}\n    if(dot(cc-a, b-a) * dot(cc-b, b-a) >= 0){return false;}\n    return true;\n}\n\nbool isCircleInTriangle(){\n    REP(i, 3){\n        if(distance(ps[i], ps[(i+1)%3], cc) < radius * radius){return false;}\n    }\n\n    int count_n = 0, count_p = 0;\n    REP(i, 3){\n        ll c = cross(cc-ps[(i+1)%3], ps[(i+1)%3]-ps[i]);\n        if(c < 0){\n            count_n += 1;\n        }else if(c == 0){\n            count_n += 1; count_p += 1;\n        }else{\n            count_p += 1;\n        }\n    }\n\n    if(count_n % 3 == 0 || count_p % 3 == 0){return true;}\n    return false;\n}\n\nbool isTriangleInCircle(){\n    REP(i, 3){\n        if(norm(ps[i]-cc) > radius * radius){return false;}\n    }\n    return true;\n}\n\nbool isIntersected(){\n    REP(i, 3){\n        if(doesLineAcrossCircle(ps[i], ps[(i+1)%3])){return true;}\n    }\n    return false;\n}\n\nint main(){\n    ll re, im;\n    while(std::cin >> re >> im, re || im){\n        ps[0].real(re); ps[0].imag(im);\n        \n        FOR(i, 1, 3){\n            ll re, im;\n            std::cin >> re >> im;\n        \n            ps[i].real(re); ps[i].imag(im);\n        }\n        \n        {\n            ll re, im;\n            std::cin >> re >> im;\n            \n            cc.real(re); cc.imag(im);\n        }\n        \n        std::cin >> radius;\n        \n        if(isCircleInTriangle()){puts(\"a\");}\n        else if(isTriangleInCircle()){puts(\"b\");}\n        else if(isIntersected()){puts(\"c\");}\n        else{puts(\"d\");}\n    }   \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 0.0;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source().ccw(s.target(), source()) * s.source().ccw(s.target(), target()) <= EPS;\n    bool b = source().ccw(target(), s.source()) * source().ccw(target(), s.target()) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n\n    // 円の中心が三角形の内部\n    bool centerInTriangle = true;\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) == ABOVE) ++ccw;\n        if(e.ccw(circle.center()) == UNDER) ++cw;\n    }\n    centerInTriangle = (cw == 3) || (ccw == 3);\n\n    if(centerInTriangle && (edgesOutOfCircle == 3)) return \"a\";\n    if(!centerInTriangle && (edgesOutOfCircle == 3)) return \"d\";\n    return \"c\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-8\ntypedef long long int lli;\ntypedef complex<lli> C;\n\nC v[4];\nlli r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble zcross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  lli ina;\n  lli ir2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    ina = norm(a);\n    if (ina < ir2) {\n      c[i] = -1;\n    } else if (ina > ir2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0 && c[1]>=0 && c[2]>=0) {\n    return 1;\n  } else if (c[0]<=0 && c[1]<=0 && c[2]<=0) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  lli cab;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    cab = zcross(a,b);\n    f[i] = (cab > 0);\n    if (cab*cab < norm(a)*r*r) {\n      return false;\n    }\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double sd, s, t;\n  long long int ina, inb, idab, id;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    ina = norm(a);\n    inb = norm(b);\n    idab = dot(a,b);\n    id = idab*idab - ina*(inb-r*r);\n    if (id < 0) {\n      continue;\n    }\n    sd = sqrt((double)id);\n    s = (idab+sd)/ina;\n    t = (idab-sd)/ina;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (!id) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (t == 0) {\n        if (center_in_check()) {\n          cout << \"a\" << endl;\n        } else {\n          cout << \"c\" << endl;\n        }\n      } else {\n        if (center_in_check()) {\n          cout << \"a\" << endl;\n        } else {\n          cout << \"d\" << endl;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-1;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) <= c.r ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n\tif( ctt >= 1 ) return 2;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r - kyuriEPS ){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs( (t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x) );\n\t}\n\t//std::cout << area << \" \" << tS2 << std::endl;\n\t\n\tif( fabs( fabs(area) - tS2 ) == 0 ) return 0; \t\n\t\n\treturn 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n \n#define EPS 1E-10\n#define SAME_SIGN( a , b ) ( a * b > EPS ? true : false )\n \nnamespace geometry{\n \n    struct point{\n        double x;\n        double y;\n        point(){}\n        point( double x , double y ):x(x),y(y){}\n        point& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n        point& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n        point& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n        point& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n        bool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n        bool operator != ( const point& p ) const { return !(*this == p); }\n        double norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n    };\n \n    typedef point vector2d;\n \n    struct circle{\n        point center;\n        double radius;\n    };\n \n    struct triangle{\n        point a;\n        point b;\n        point c;\n    };\n \n    point operator + ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p += p2;\n            return p;\n        }\n        point operator - ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p -= p2;\n            return p;\n        }\n        point operator * ( const point& p1 , double factor ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator * ( double factor , const point& p1 ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator / ( const point& p1 , double factor ){\n            point p(p1);\n            p /= factor;\n            return p;\n        }\n \n    std::istream& operator >> ( std::istream& s , point& p )\n    {\n        return s >> p.x >> p.y;\n    }\n \n    double get_distance( const point& p1 , const point& p2 )\n    {\n        return sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n    }\n \n    double get_dot_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.x + oa.y * ob.y;\n    }\n \n    double get_cross_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.y - oa.y * ob.x;\n    }\n \n    point get_project( const point& s , const point& e , const point& p ){\n        double scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n        return s + scale * ( e - s ) / ( e - s ).norm();\n    }\n \n    bool is_inter_point( const point& s , const point& e , const point& p ){\n        return std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n    }\n}\n \nusing namespace geometry;\n \nbool input_data( triangle& tri , circle& cir )\n{\n    std::cin >> tri.a;\n    if( tri.a.x == 0 && tri.a.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.b;\n    if( tri.b.x == 0 && tri.b.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.c;\n    if( tri.c.x == 0 && tri.c.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.center;\n    if( cir.center.x == 0 && cir.center.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.radius;\n    return true;\n}\n \nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n    if( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n        if( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius ){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    else{\n        return false;\n    }\n}\n \nbool is_overlap( triangle& tri , circle& cir )\n{\n    // オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n    if( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n        !(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n        !(is_overlap_for_one_side( tri.c , tri.a , cir ))\n        ){\n            return false;\n    }\n    else{\n        return true;\n    }\n \n}\n \nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n    if( get_distance( tri.a , cir.center ) < cir.radius  &&\n        get_distance( tri.b , cir.center ) < cir.radius  &&\n        get_distance( tri.c , cir.center ) < cir.radius\n        ){\n            std::cout << \"b\" << std::endl;\n    }\n    else{\n        if( get_distance( tri.a , cir.center ) > cir.radius  &&\n            get_distance( tri.b , cir.center ) > cir.radius  &&\n            get_distance( tri.c , cir.center ) > cir.radius\n            ){\n                if( !(is_overlap( tri , cir )) ){\n                    if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                        SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                            std::cout << \"a\" << std::endl;\n                    }\n                    else{\n                        std::cout << \"d\" << std::endl;\n                    }\n                }\n                else{\n                    std::cout << \"c\" << std::endl;\n                }\n        }\n        else{\n            std::cout << \"c\" << std::endl;\n        }\n    }\n}\n \nint main(void)\n{\n    triangle tri;\n    circle cir;\n \n    while(input_data(tri, cir)){\n        output_positional_relation_of_circle_and_triangle( tri , cir );\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) { // ??´???l???????????????p?????????\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nint ccw(P a, P b, P c) { // ????????£???????????????????????¨???????????????????????¨????????????\n  b = vec(a,b); c = vec(a,c);\n\n  // a - b - c ????????????????????¨???\n  if(sgn(outp(b,c),0.0) > 0) return +1; // ???????¨???????\n  if(sgn(outp(b,c),0.0) < 0) return -1; // ????¨???????\n\n  // a - b - c ?????´??????????????¶??¨???\n  // sgn???????????????????£????????????£?????????\n  if(sgn(inp(b,c),0.0) < 0)  return +2; // c - a - b\n  if(sgn(abs(b),abs(c)) < 0) return -2; // a - b - c\n  return 0;                             // a - c - b\n}\n// ON = 0, IN = 1, OUT = -1\nint containsGP(vector<P> g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(g[i], g[(i+1)%g.size()], p) == 0) return 0;\n    P a = vec(p, g[i]);\n    P b = vec(p, g[(i+1)%g.size()]);\n    if(a.y > b.y) swap(a, b);\n    if(sgn(a.y, 0.0) <= 0 && sgn(b.y, 0.0) > 0 && sgn(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\nbool in_triangle(vector<P> g, P p) {\n  double a = 0.0, b = 0.0;\n  REP(i,3) {\n    a += abs(outp(g[i] - p, g[(i+1)%3] - p));\n    b += outp(g[i], g[(i+1)%3]);\n  }\n  return sgn(abs(a), abs(b)) == 0;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    // a\n    if(in_triangle(tri, cir.p) &&\n       sgn(cir.r, dLP(L(tri[0], tri[1]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[1], tri[2]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[2], tri[0]), cir.p)) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) > 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) > 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) > 0) {\n      cout << \"d\" << endl;\n      continue;\n    }\n    cout << \"c\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{ point a,b; };\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point t,point* p,int N){\n  int i,count=0,j=0;\n  segment lt,lp;\n  sort(p,p+N,cmp_x);\n  p[N]=p[0];\n  p[N+1]=p[1];\n\n  lt.a=lt.b=t;\n  lt.b.x=INT_MAX;\n\n  for(i=1;i<=N;i++){\n    lp.a=lp.b=p[i];\n\n    if(!is_intersected_ls(lp.a,lp.b,lt.a,lt.b)){\n      if(i==j+1){\n\tlp.b=p[j];\n\tif(is_intersected_ls(lp.a,lp.b,lt.a,lt.b))count++;\n      }\n      else if(ccw(lt.a,lt.b,p[i])*ccw(lt.a,lt.b,p[j])<0)count++;\n      j=i;\n    }\n  }\n  return count & 1;\n}\n\nint crossCP(point* ps, circle C, int sz){\n\n  double ans=0;\n\n  for(int i=0;i<sz;i++){\n    double tmp=dist(ps[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,ps,sz);\n\n  double res2=100000000;\n  ps[3]=ps[0];\n  for(int i=0;i<sz;i++)\n    res2=min(res2,distance_ls_p(ps[i],ps[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p[6];\n  vector<segment> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(p,C,3);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r&&!EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r&&!EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r&&!EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n\ndouble dot(P& a, P& b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P& a, P& b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint sign(double x){\n  if(x > EPS) return 1;\n  if(x < -EPS) return -1;\n  return 0;\n}\n\n//a -> b, a -> c\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(sign(cross(b, c)) > 0) return 1; //反時計\n  if(sign(cross(b, c)) < 0) return -1; //時計\n  if(sign(dot(b, c)) < 0) return +2; //c-a-b\n  if(norm(b) < norm(c)) return -2; //a-b-c\n  return 0; //a-c-b\n}\n\ndouble min_d(P a, P b, P c){\n  double d1 = abs(c - a);\n  double d2 = abs(c - b);\n  b -= a; c -= a;\n  double k = dot(b, c) / norm(b);\n  if(0 < k && k < 1) return abs(c - k * b);\n  else return min(d1, d2);\n}\n\nstring solve(P p[3], P c, double r){\n  if(ccw(p[0], p[1], p[2]) == -1) swap(p[1], p[2]);\n  double maxdist = 0, mindist = 1e18;\n  int ccw_v[3];\n  REP(i, 3){\n    maxdist = max(maxdist, abs(p[i] -  c));\n    mindist = min(mindist, min_d(p[i], p[(i + 1) % 3], c));\n    ccw_v[i] = ccw(p[i], p[(i + 1) % 3], c);\n  }\n  if(sign(maxdist - r) < 0) return \"b\";\n  if(ccw_v[0] == ccw_v[1] && ccw_v[1] == ccw_v[2] && ccw_v[0] == 1){\n    if(sign(mindist - r) >= 0) return \"a\";\n    else return \"c\";\n  }else{\n    if(sign(mindist - r) > 0) return \"d\";\n    else return \"c\";\n  }\n}\n\nint main(){\n  P p[3];\n  P c; double r;\n  while(cin>>p[0].X>>p[0].Y>>p[1].X>>p[1].Y>>p[2].X>>p[2].Y>>c.X>>c.Y>>r){\n    cout<<solve(p, c, r)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-6;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n    if( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n    return ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 点 a から 点 b への角度を返す [0,2π]\ndouble dir(P a, P b) {\n\tP p = a - b;\n\tdouble angle = atan2( p.Y , p.X );\n\tif( p.X < 0 ) angle += PI;\n\tif( angle < 0 ) angle += 2.0 * PI;\n\treturn angle;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n    double distance(Segment s) {\n        if( is_intersection(s) ) return 0.0;\n        return min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n    }\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n// Segment の順序を定義 (x座標の小さい端点で比較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の直交判定\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 点 p が直線上に乗っているか\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// 直線と点 p の距離\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 点 (*this)[0] から 点 (*this)[1] への角度を返す [0,2π]\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\tdouble angle = atan2( p.Y , p.X );\n\t\tif( p.X < 0 ) angle += PI;\n\t\tif( angle < 0 ) angle += 2.0 * PI;\n\t\treturn angle;\n\t}\n};\n\n// 円の表現\nstruct Circle{\n\t// 円の中心\n\tP p;\n\t// 円の半径\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// 円の面積\n\tdouble get_area() { return r * r * PI; }\n\t// 円周\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t// 直線と円の距離 (円の中心の点と直線の距離 - 円の半径)\n\tdouble distance(Line l){\n\t\treturn l.distance( p ) - r;\n\t}\n\t// 2つの円の位置関係\n\t// 2 つの円が離れている => 0\n\t// 2 つの円が外接する   => 1\n\t// 2 つの円が交わる     => 2\n\t// 2 つの円が内接する    => 3 (2つの円が等しいときは内接)\n\t// 円が含まれている       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // 離れている\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // 外接する\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // 内接する\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // 含まれる\n\t\t\treturn 4;\n\t\t}else { // 交わる\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// 円と直線の交わる点を返す\n\tpair<P,P> intersection(Line l) {\n\t\tpair<P,P> pp;\n\t\tif( this->distance(l) > EPS ) { // 円と直線の交点がないとき\t\n\t\t\tpp.first = pp.second = INF_P;\n\t\t}else { // 円と直線の交点があるとき\n\t\t\tdouble d = l.distance( p );\n\t\t\tdouble angle = -l.get_dir();\n\t\t\t// 点 l[0] を軸に点 l[1] と円の中心を回転\n\t\t\tP lp = rot2( l[0] , l[1] , angle );\n\t\t\tP cp = rot2( l[0] , p    , angle );\n\t\t\tdouble x1 = cp.X - sqrt( sq(r) - sq(d) );\n\t\t\tdouble x2 = cp.X + sqrt( sq(r) - sq(d) );\n\t\t\tP p1(x1,l[0].Y);\n\t\t\tP p2(x2,l[0].Y);\n\t\t\t// 回転して元に戻す\n\t\t\tp1 = rot2( l[0] , p1 , -angle );\n\t\t\tp2 = rot2( l[0] , p2 , -angle );\n\t\t\tpp.first = p1;\n\t\t\tpp.second = p2;\n\t\t}\n\t\treturn pp;\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.X, p.Y, r ); }\n};\n\n\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\tSegment AB(a,b), BC(b,c), CA(c,a);\n\t\treturn (AB.contain( p ) || BC.contain( p ) || CA.contain( p ) );\n\t}\n\t// 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\t// 点 p が三角形の辺上 or 頂点上 にあるときは誤差で正しい結果が返ってこないので注意!!!\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n\t// 三角形の内接円を返す\n\tCircle inscribed_circle() {\n\t\t// 三角形の外周の長さ\n\t\tdouble ABC = edgeA + edgeB + edgeC;\n\t\t\n\t\tdouble cx = (a.X * edgeA + b.X * edgeB + c.X * edgeC) / ABC;\n\t\tdouble cy = (a.Y * edgeA + b.Y * edgeB + c.Y * edgeC) / ABC;\n\t\tdouble r  = (2.0 * get_area()) / ABC ;\n\t\tCircle cir( P(cx,cy) , r );\n\t\treturn cir;\n\t}\n};\n\n\nint main(){\n\tint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile( cin >> x1 >> y1 , x1 || y1 ){\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tP p1(x1,y1), p2(x2,y2), p3(x3,y3), p4(x4,y4);\n\t\tSegment s1(p1,p2), s2(p2,p3), s3(p3,p1);\n\t\tLine    l1(p1,p2), l2(p2,p3), l3(p3,p1);\n\t\tCircle c( P(x4,y4), r );\n\t\tTriangle t( p1 , p2 , p3 );\n\t\t\n\t\t// 円の中に三角形\n\t\tif( dist(p4,p1) <= r && dist(p4,p2) <= r && dist(p4,p3) <= r ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else{\n\t\t\t// 円の中心が三角形の内部にあるかどうか\n\t\t\tif( t.is_inside(p4) ){\n\t\t\t\tpair<P,P> pp = c.intersection( l1 );\n\t\t\t\tbool flag = false;\n\t\t\t\tif( pp.first != INF_P && s1.contain(pp.first) || s1.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tpp = c.intersection( l2 );\n\t\t\t\tif( pp.first != INF_P && s2.contain(pp.first) || s2.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tpp = c.intersection( l3 );\n\t\t\t\tif( pp.first != INF_P && s3.contain(pp.first) || s3.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\t// 円と三角形の辺が交差するとき\n\t\t\t\tif( flag ){\n\t\t\t\t\tcout << \"c\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"a\" << endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdouble d1 = s1.distance(p4);\n\t\t\t\tdouble d2 = s2.distance(p4);\n\t\t\t\tdouble d3 = s3.distance(p4);\n\t\t\t\tif( r < d1+EPS && r < d2+EPS && r < d3+EPS ){\n\t\t\t\t\tcout << \"d\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"c\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD dis(P a,P b){\n\treturn sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\ndouble x1,x2,x3,y4,y2,y3,x,y,r;\nmain(){\n\twhile(cin>>x1>>y4,x1||y4){\n\t\tcin>>x2>>y2>>x3>>y3>>x>>y>>r;\n\t\tif(dis(P(x1,y4),P(x,y))<=r&&dis(P(x2,y2),P(x,y))<=r&&dis(P(x3,y3),P(x,y))<=r)cout<<'b'<<endl;\n\t\telse if(distSP(P(x1,y4),P(x2,y2),P(x,y))<=r||distSP(P(x3,y3),P(x2,y2),P(x,y))<=r||distSP(P(x1,y4),P(x3,y3),P(x,y))<=r)cout<<'c'<<endl;\n\t\telse if(ccw(P(x1,y4),P(x2,y2),P(x,y))==ccw(P(x2,y2),P(x3,y3),P(x,y))==ccw(P(x3,y3),P(x1,y4),P(x,y)))cout<<'a'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n\nconst double EPS=1e-9;\nconst double INFTY=1e12;\ntypedef complex<double> Point;\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x>0?1:-1;\n}\n\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tint sign=Signum(Cross(d1,d2));\n\t\n\tif(sign)\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\n// ツ点ツづ陳シツ静シツづ個仰猟猟」\ndouble DistancePL(Point p,Line l)\n{\n\treturn abs(Cross(p-l.pos,l.dir))/abs(l.dir);\n}\n// ツ点ツづ静シツ閉ェツづ個仰猟猟」\ndouble DistancePS(Point p,Line s)\n{\n\tPoint a=p-s.pos,b=s.dir;\n\tPoint c=b*Dot(a,b)/norm(b);\n\tdouble pos=abs(c)/abs(b);\n\tif(-EPS<pos && pos<1+EPS)\n\t\treturn abs(a-c);\n\telse\n\t\treturn min(abs(a),abs(b-a));\n}\n\nvoid solve(Point p[],Point c,double r)\n{\n\t{\t// triangle in circle\n\t\tdouble dist=0;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=max(dist,norm(p[i]-c));\n\t\tif(dist<=r*r){\n\t\t\tputs(\"b\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t{\t// circle in triangle\n\t\tbool res=true;\n\t\tint ccw=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint temp=CCW(p[i],p[(i+1)%3],c);\n\t\t\tif(abs(temp)==2)\n\t\t\t\tcontinue;\n\t\t\tres&=temp*ccw>=0;\n\t\t\tccw=temp;\n\t\t}\n\t\tif(res){\n\t\t\tdouble dist=INFTY;\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tdist=min(dist,DistancePL(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\t\tif(Signum(dist-r)>=0){\n\t\t\t\tputs(\"a\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t{\t// intersect\n\t\tdouble dist=INFTY;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=min(dist,DistancePS(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\tif(Signum(dist-r)<=0){\n\t\t\tputs(\"c\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tputs(\"d\");\n}\n\nint main()\n{\n\tfor(;;){\n\t\tPoint p[3],c;\n\t\tdouble r;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tcin>>real(p[i])>>imag(p[i]);\n\t\tcin>>real(c)>>imag(c)>>r;\n\t\tif(norm(p[0])==0)\n\t\t\tbreak;\n\t\t\n\t\t//for(int i=0;i<3;i++)\n\t\t//\tprintf(\"(%.3f,%.3f) \",real(p[i]),imag(p[i]));\n\t\t//printf(\"(%.3f,%.3f,%.3f)\\n\",real(c),imag(c),r);\n\t\t\n\t\tsolve(p,c,r);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS (1e-10)\n\ntypedef complex<double> P;\n\ndouble dot(P a, P b){\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a, P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble distance_ls_p(P a, P b, P c){\n\tif(dot(b-a, c-a) < EPS) return abs(c-a);\n\tif(dot(a-b, c-b) < EPS) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2){\n\treturn (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS) &&\n\t\t(cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS);\n}\n\nint point_in_polygon(int n, P p[], P q){\n\tint i,flg;\n\tP o = P(0,0);\n\n\tfor(i=0;i<n;o+=p[i],i++);\n\to /= n;\n\tflg = is_intersected_ls(p[n-1],p[0],q,o);\n\tfor(i=0;i<n-1;i++){\n\t\tflg = flg || is_intersected_ls(p[i],p[i+1],q,o);\n\t}\n\treturn !flg;\n}\n\nint main(void){\n\tint i,flg1,flg2;\n\tdouble r;\n\tP p[3],o;\n\n\twhile(1){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcin>>p[i].real()>>p[i].imag();\n\t\t\tif(!p[i].real() && !p[i].imag()) return 0;\n\t\t}\n\t\tcin>>o.real()>>o.imag()>>r;\n\n\t\tflg1 = distance_ls_p(p[0],p[1],o) > r;\n\t\tflg1 += distance_ls_p(p[1],p[2],o) > r;\n\t\tflg1 += distance_ls_p(p[2],p[0],o) > r;\n\n\t\tflg2 = abs(p[0]-o) < r;\n\t\tflg2 += abs(p[1]-o) < r;\n\t\tflg2 += abs(p[2]-o) < r;\n\n\t\tif(flg1==3){\n\t\t\tif(point_in_polygon(3,p,o)) cout<<\"a\\n\";\n\t\t\telse if(!flg2) cout<<\"d\\n\";\n\t\t}\n\t\telse if(flg2==3) cout<<\"b\\n\";\n\t\telse cout<<\"c\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-10\n\nusing namespace std;\n\ntypedef complex<double> Po;\n\nstruct Point \n{\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    \n\tdouble distance (const Point &o) const \n\t{\n        return sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));\n    }\n\n    Point operator+(const Point &o) const \n\t{\n        return Point(x+o.x, y+o.y);\n    }\n \n    Point operator-(const Point &o) const \n\t{\n        return Point(x-o.x, y-o.y);\n    }\n \t\n    Point operator*(const double m) const \n\t{\n   \t   return Point(x*m, y*m);\n    }\n\n    Point operator/(const double d) const \n\t{\n       return Point(x/d, y/d);\n    }\n\n    double cross(const Point &o) const \n\t{\n       return x * o.y - y * o.x;\n    }\n \n    double dot(const Point &o) const \n\t{\n        return x * o.x + y * o.y;\n    }\n \n    double atan() const \n\t{\n        return atan2(y, x);\n    }\n\n    double norm() const \n\t{\n        return sqrt(dot(*this));\n    }\n\n\tdouble area_abs(const Point &a,const Point &b) const\n\t{\n\t\tdouble t = (a.x - x) * (b.y - y);\n\t\tdouble t2 = (a.y - y) * (b.x - x);\n\t\tdouble areas = abs(t-t2);\n\t\treturn areas/2;\n\t}\n\n\t//符号付き面積\n\tdouble area(const Point &a,const Point &b)\n\t{\n\t\treturn ((a.x - x) * (b.y - y)) + ((b.x - x) * (y - a.y));\n\t}\n\t//線分abが自身の含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)\n\t\t{\n\t\t\treturn ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t\t}\n\t}\n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n\t\tif((b-a).dot(*this-a) < EPS) \n\t\t{\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS)\n\t\t{\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n\n\t//点a,b,cからなる三角形の中に自身が含まれているかどうか\n\tbool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n\t\tdouble t = (b-a).cross(*this-b);\n\t\tdouble t2 = (c-b).cross(*this-c);\n\t\tdouble t3 = (a-c).cross(*this-a);\n\n\t\tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\nint main()\n{\n\tdouble a,b;\n\twhile(cin >> a >> b)\n\t{\n\t\tif(a == 0 && b == 0) break;\n\t\t\n\t\tvector<Point> t;\n\t\tt.push_back(Point(a,b));\n\n\t\trep(i,2)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tt.push_back(Point(a,b));\n\t\t}\n\n\t\tdouble r;\n\t\tcin >> a >> b >> r;\n\t\tPoint c(a,b);\n\n\t\tint cnt = 0;\n\n\t\trep(i,3)\n\t\t{\n\t\t\tif(t[i].distance(c) >= r)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tif(cnt == 0) cout << \"b\" << endl;\n\t\telse if(cnt == 1 || cnt == 2) cout << \"c\" << endl;\n\t\telse\n\t\t{\n\t\t\tbool flag = false;\n\n\t\t\tif(c.distance_seg(t[0],t[1]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[1],t[2]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[2],t[0]) < r) flag = true;\n\t\t\t\n\t\t\tif(flag) cout << \"c\" << endl;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(c.hitPolygon(t[0],t[1],t[2]))\n\t\t\t\t{\n\t\t\t\t\tcout << \"a\" << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool flag2 = false;\n\n\t\t\t\t\tif(c.distance_seg(t[0],t[1]) == r) flag2 = true;\n\t\t\t\t\tif(c.distance_seg(t[1],t[2]) == r) flag2 = true;\n\t\t\t\t\tif(c.distance_seg(t[2],t[0]) == r) flag2 = true;\n\n\t\t\t\t\tif(flag2) cout << \"c\" << endl;\n\t\t\t\t\telse cout << \"d\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0){\n\t\t\tif(acx*acx+acy*acy<=r*r)return true;\n\t\t}else{\n\t\t\tif(abx*acx+aby*acy>abx*abx+aby*aby){\n\t\t\t\tif(bcx*bcx+bcy*bcy<=r*r)return true;\n\t\t\t}else if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<0)ok1=false;\n\telse ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<0)ok1=false;\n\telse ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<0)ok1=false;\n\telse ok2=false;\n\treturn ok1||ok2;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<r*r&&(c-g)*(c-g)+(d-h)*(d-h)<r*r&&(e-g)*(e-g)+(f-h)*(f-h)<r*r)printf(\"b\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse if(inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\npair<int, int> a;\npair<int, int> b;\npair<int, int> c;\npair<int, int> o;\nint r;\n\nint dot(pair<int, int> p1, pair<int, int> p2){\n  return p1.first * p2.first + p1.second * p2.second;\n}\n\nint cross(pair<int, int> p1, pair<int, int> p2){\n  return p1.first * p2.second - p1.second * p2.first;\n}\n\ndouble length(pair<int, int> p){\n  return sqrt(p.first * p.first + p.second * p.second);\n}\n\nbool is_inside(){\n  if(cross(make_pair(b.first-a.first, b.second-a.second), \n\t   make_pair(o.first-a.first, o.second-a.second)) < 0) return false;\n  if(cross(make_pair(c.first-b.first, c.second-b.second), \n\t   make_pair(o.first-b.first, o.second-b.second)) < 0) return false;\n  if(cross(make_pair(a.first-c.first, a.second-c.second), \n\t   make_pair(o.first-c.first, o.second-c.second)) < 0) return false;\n  return true;\n}\n\ndouble dist(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3){\n  pair<int, int> p4 = make_pair(p2.first - p1.first, p2.second - p1.second);\n  pair<int, int> p5 = make_pair(p3.first - p1.first, p3.second - p1.second);\n  double tmp = length(p4);\n  return abs((double)cross(p4, p5) / tmp);\n}\n\ndouble dist2(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3){\n  pair<int, int> p7 = make_pair(p2.first - p1.first, p2.second - p1.second);\n  pair<int, int> p4 = make_pair(p1.first - p2.first, p1.second - p2.second);\n  pair<int, int> p5 = make_pair(p3.first - p2.first, p3.second - p2.second);\n  pair<int, int> p6 = make_pair(p3.first - p1.first, p3.second - p1.second);\n  if(dot(p7, p6) < 0) return length(p6)*length(p6);\n  if(dot(p4, p5) < 0) return length(p5)*length(p5);\n  return dist(p1, p2, p3);\n}\n\nmain(){\n  while(cin >> a.first >> a.second && a.first && a.second){\n    cin >> b.first >> b.second;\n    cin >> c.first >> c.second;\n    cin >> o.first >> o.second;\n    cin >> r;\n    if(length(make_pair(a.first-o.first, a.second-o.second)) < (double)r+EPS && \n       length(make_pair(b.first-o.first, b.second-o.second)) < (double)r+EPS &&\n       length(make_pair(c.first-o.first, c.second-o.second)) < (double)r+EPS){\n      cout << \"b\" << endl;\n    }\n    else if(is_inside()){\n      if(dist(b, c, o) > (double)r-EPS && \n\t dist(a, c, o) > (double)r-EPS && \n\t dist(a, b, o) > (double)r-EPS){\n\tcout << \"a\" << endl;\n      }else{\n\tcout << \"c\" << endl;\n      }\n    }else{\n      if(dist2(b, c, o) < (double)r+EPS ||\n\t dist2(a, c, o) < (double)r+EPS ||\n\t dist2(a, b, o) < (double)r+EPS){\n\tcout << \"c\" << endl;\n      }else{\n\tcout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-6;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n    if( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n    return ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 点 a から 点 b への角度を返す [0,2π]\ndouble dir(P a, P b) {\n\tP p = a - b;\n\tdouble angle = atan2( p.Y , p.X );\n\tif( p.X < 0 ) angle += PI;\n\tif( angle < 0 ) angle += 2.0 * PI;\n\treturn angle;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n    double distance(Segment s) {\n        if( is_intersection(s) ) return 0.0;\n        return min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n    }\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n// Segment の順序を定義 (x座標の小さい端点で比較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の直交判定\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 点 p が直線上に乗っているか\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// 直線と点 p の距離\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 点 (*this)[0] から 点 (*this)[1] への角度を返す [0,2π]\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\tdouble angle = atan2( p.Y , p.X );\n\t\tif( p.X < 0 ) angle += PI;\n\t\tif( angle < 0 ) angle += 2.0 * PI;\n\t\treturn angle;\n\t}\n};\n\n// 円の表現\nstruct Circle{\n\t// 円の中心\n\tP p;\n\t// 円の半径\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// 円の面積\n\tdouble get_area() { return r * r * PI; }\n\t// 円周\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t// 直線と円の距離 (円の中心の点と直線の距離 - 円の半径)\n\tdouble distance(Line l){\n\t\treturn l.distance( p ) - r;\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.X, p.Y, r ); }\n};\n\n\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\tSegment AB(a,b), BC(b,c), CA(c,a);\n\t\treturn (AB.contain( p ) || BC.contain( p ) || CA.contain( p ) );\n\t}\n\t// 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\t// 点 p が三角形の辺上 or 頂点上 にあるときは誤差で正しい結果が返ってこないので注意!!!\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n\t// 三角形の内接円を返す\n\tCircle inscribed_circle() {\n\t\t// 三角形の外周の長さ\n\t\tdouble ABC = edgeA + edgeB + edgeC;\n\t\t\n\t\tdouble cx = (a.X * edgeA + b.X * edgeB + c.X * edgeC) / ABC;\n\t\tdouble cy = (a.Y * edgeA + b.Y * edgeB + c.Y * edgeC) / ABC;\n\t\tdouble r  = (2.0 * get_area()) / ABC ;\n\t\tCircle cir( P(cx,cy) , r );\n\t\treturn cir;\n\t}\n};\n\n\nint main(){\n\tint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile( cin >> x1 >> y1 , x1 || y1 ){\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tP p1(x1,y1), p2(x2,y2), p3(x3,y3), p4(x4,y4);\n\t\tSegment s1(p1,p2), s2(p2,p3), s3(p3,p1);\n\t\tCircle c( P(x4,y4), r );\n\t\tTriangle t( p1 , p2 , p3 );\n\t\t\n\t\tdouble d1 = dist(p4,p1);\n\t\tdouble d2 = dist(p4,p2);\n\t\tdouble d3 = dist(p4,p3);\n\t\tdouble R = min( s1.distance(p4) , min(s2.distance(p4),s3.distance(p4)) );\n\t\tCircle c1 = t.inscribed_circle();\n\t\t\n\t\tbool d_flag = false;\n\t\tif( !t.is_inside(p4) ){\n\t\t\tdouble d4 = s1.distance(p4);\n\t\t\tdouble d5 = s1.distance(p4);\n\t\t\tdouble d6 = s1.distance(p4);\n\t\t\tif( r < d4 && r < d5 && r < d6 ){\n\t\t\t\td_flag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( d1 <= r && d2 <= r && d3 <= r ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( d_flag ){\n\t\t\tcout << \"d\" << endl;\n\t\t}else if( dist(c.p,c1.p) < c1.r-c.r ){\n\t\t\tcout << \"a\" << endl;\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\t\n\t\t\n\t\t/*if( d1 <= r && d2 <= r && d3 <= r ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( t.is_inside(p4) && R <= r ){\n\t\t\tcout << \"a\" << endl;\n\t\t}else if( !t.is_inside(p4) && R < r ){\n\t\t\tcout << \"d\" << endl;\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn (((cross(a,b)>0||EQ(0,cross(a,b)))&&(cross(b,c)>=0||EQ(0,cross(b,c)))&&(cross(c,a)>=0||EQ(0,cross(a,b))))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))){\n\t\t\tif(isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t\t}\n\t\t\t// ~ÌSªOp`ÌÉ¶ÝµÈ¢ê\n\t\t\telse{\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t\t}\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && vec_abs(seg[i].b-seg[j].a)<=EPS){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    double ans=0;\n    for(int i=0;i<3;i++){\n\tint tmp=dist(p[i],C.p);\n\tif(tmp>ans)ans=tmp;\n    }\n    if(C.r>ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n    \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=100000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> Po;\n\n\nPo p[3],o;\n\ndouble cross(Po x, Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a, Po b, Po c){return abs(cross(b-a,c-a))/2;}\n\nbool inter(Po a, Po b, Po c, Po x){\n  return (fabs(area(a,b,x)+area(b,c,x)+area(c,a,x)-area(a,b,c)) < EPS);\n}\n\ndouble line_dis(Po a, Po b, Po c){return abs(cross(b-a,c-a))/abs(b-a);}\n\nint main(){\n  double x[4],y[4],r;\n\n  for(;;){\n    cin >> x[0] >> y[0];\n    if(!x[0] && !y[0])break;\n\n    for(int i=1;i<4;i++)cin >> x[i] >> y[i];\n    cin >> r;\n\n    for(int i=0;i<3;i++)p[i] = Po(x[i],y[i]);\n    o = Po(x[3],y[3]);\n\n\n    bool f[3];\n    if(inter(p[0],p[1],p[2],o)){\n      for(int i=0;i<3;i++)f[i] = (line_dis(p[i],p[(i+1)%3],o)>r+EPS);\n      if(f[0] && f[1] && f[2])cout << \"a\\n\";\n      else{\n\tfor(int i=0;i<3;i++)f[i] = (abs(o-p[i])<r+EPS);\n\tif(f[0] && f[1] && f[2])cout << \"b\\n\";\n\telse cout << \"c\\n\";\n      }\n    }else{\n      for(int i=0;i<3;i++)f[i] = (line_dis(p[i],p[(i+1)%3],o)<r+EPS);\n      if(f[0] || f[1] || f[2])cout << \"c\\n\";\n      else cout << \"d\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P p;double r;};    //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(L a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//??´?????¨??´????????¢??? verified AOJ CGL_2\nint rLL(L a,L b){\n    if( cross(vec(a),vec(b))==0 ) return 2; //??????\n    if( dot(vec(a),vec(b))==0 )   return 1; //?????´\n    return 0;\n}\n\n// ?????¨??????????????????\nint contains(C c, P p){\n    double d = (c.p-p).abs();\n    if(d-c.r>EPS) return OUT;\n    if(abs(d-c.r)<EPS) return ON;\n    return IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n    if( dLP(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(L s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, L l){\n    int c1 = contains(c, l.p1);\n    int c2 = contains(c, l.p2);\n    if(c1 > c2) swap(c1, c2);\n    \n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (??\\????????¨???)\n    double d = dSP(l, c.p);\n    if(d-c.r<-EPS) return true;\n    if(d-c.r>EPS) return false;\n    return true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nbool isPointInsidePolygon(vector<P> pol,P p){\n    int c=0;\n    rep(i,pol.size()){\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n    }\n    return !(c%pol.size());\n}\n\n//?????¨???????§???¢???????????¶???????????????\nint CPOLarea(C c ,Polygon pol){\n    vector<L> lines;\n    vector<int> res(pol.size());\n    bool POLinC=true;\n    \n    rep(i,pol.size()){\n        res[i] = contains(c,pol[i]);\n        lines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n    }\n    rep(i,res.size()) if( res[i]!=IN )POLinC=false;\n    \n    rep(i,lines.size()) if( iCS(c,lines[i]) )   return 1;   //????§???¢??¨????????????\n    if( POLinC )                                return 2;   //????§???¢??????????????¨\n    if( isPointInsidePolygon(pol, c.p) )        return 3;   //????§???¢????????¨??????\n    return 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps),cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????´???????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b&&(a||b)){\n        Polygon pol(3);\n        pol[0] = P(a,b);\n        rep(i,2)cin>>pol[i+1].x>>pol[i+1].y;\n        C c;\n        cin>>c.p.x>>c.p.y>>c.r;\n        int res =  CPOLarea(c,pol);\n        \n        cout<<(char)('a'+(3-res))<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#define PI 3.141592653589\nusing namespace std;\n\ndouble x[3],y[3],rx,ry,r;\n\nint trgin() {\n\tint i,k;\n\tdouble a,b,c,d=0;\n\tfor (i=0; i<3; i++) {\n\t k=(i+1) % 3;\n\t a=sqrt((x[i]-x[k])*(x[i]-x[k])+(y[i]-y[k])*(y[i]-y[k]));\n\t b=sqrt((x[i]-rx)*(x[i]-rx)+(y[i]-ry)*(y[i]-ry));\n\t c=sqrt((x[k]-rx)*(x[k]-rx)+(y[k]-ry)*(y[k]-ry));\n     d=d+acos((b*b+c*c-a*a)/(2*b*c));\n\t}\n\tif ((d-PI*2)<0.000001 && (d-PI*2)>-0.000001) return 1;\n\treturn 0;\n}\nint line(double x1,double y1,double x2,double y2) {\n    double x,y,m,d;\n\tif (y1==y2) { x=rx;y=y1;} else if (x1==x2) { x=x1;y=ry;}\n\telse {\n    m=(y2-y1)/(x2-x1);\n\tx=(ry-y1+m*x1+rx/m)/(m+1/m);\n\ty=y1+m*(x-x1);\n\t}\n\tif (((x>=x1 && x<=x2) || (x>=x2 && x<=x1)) && ((y>=y1 && y<=y2) || (y>=y2 && y<=y1))){\n\td=(rx-x)*(rx-x)+(ry-y)*(ry-y);\n    if (d==r*r) return 1; else if (d<r*r) return 2;\n\t}\n\treturn 0;\n}\nint main() {\n\tint i,j,k,f;\n\twhile(true) {\n\t\tfor (i=0;i<3;i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tif (x[i]==0) break;\n\t}\n    if (i!=3) break;\n\tcin >> rx >> ry >> r;\n    for (i=0;i<3;i++) if ((x[i]-rx)*(x[i]-rx)+(y[i]-ry)*(y[i]-ry)>r*r) break;\n\tif (i==3) { cout << 'b' << endl; continue;}\n\tfor (i=0,f=0,k=0;i<3;i++) {\n\t\tj=line(x[i],y[i],x[(i+1) % 3],y[(i+1) % 3]); k+=j;\n\t\tif (j>1) break;\n\t}\n\tif (i==3) if (trgin()==1) { cout << 'a' << endl; continue;} else if (k==0) {cout << 'd' << endl; continue;}\n\tcout << 'c' << endl;\n\t}\nreturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-c,ar=d-a;\n\tP bb=b-a,br=d-b;\n\tP cc=c-b,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nvoid mainmain(){\n\tint r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tcin>>r;\n\t\t// cout<<r<<endl;\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(t<r){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\telse if(r>abs(z[0]-z[3])&&r>abs(z[1]-z[3])&&r>abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t}\n\t\telse if(r>abs(z[0]-z[3])||r>abs(z[1]-z[3])||r>abs(z[2]-z[3])){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse cout<<\"d\\n\";\t\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nstatic constexpr real EPS = 1e-10;\nconst real pi = acos(real(-1));\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nbool sorty(Point a, Point b){\n    return (a.y != b.y ? a.y < b.y : a.x < b.x);\n}\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\n\nreal angle(Point A, Point B){\n    return acos(dot(A, B)/abs(A)/abs(B));\n}\n\n\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < -EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Line {\n    Point a, b;\n    Line(Point x, Point y) : a(x), b(y) {};\n};\n\nstruct Circle{\n    Point c; real r;\n    Circle(Point c, real r): c(c), r(r) {};\n};\n\nusing Polygon = vector<Point>;\n\nbool intersect(Segment s, Segment t){\n    return (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool intersect(Segment s, Line t){\n    int a = ccw(t.a, t.b, s.a), b = ccw(t.a, t.b, s.b);\n    return (!(a&1) || !(b&1) || a != b);\n}\n\nPoint polar(double r, double t){\n    return Point(r*cos(t), r*sin(t));\n}\n\ndouble arg(Point p){\n    return atan2(p.y, p.x);\n}\n\nstatic constexpr int CONTAIN = 0;\nstatic constexpr int INSCRIBE = 1;\nstatic constexpr int INTERSECT = 2;\nstatic constexpr int CIRCUMSCRIBED = 3;\nstatic constexpr int SEPARATE = 4;\n\nint intersect(Circle c1, Circle c2){\n    if(c1.r < c2.r) swap(c1, c2);\n    real d = abs(c1.c-c2.c);\n    real r = c1.r + c2.r;\n    if(fabs(d-r) < EPS) return CIRCUMSCRIBED;\n    if(d > r) return SEPARATE;\n    if(fabs(d+c2.r-c1.r) < EPS) return INSCRIBE;\n    if(d+c2.r < c1.r) return CONTAIN;\n    return INTERSECT;\n}\n\nreal distance(Line l, Point c){\n    return abs(cross(l.b-l.a, c-l.a)/abs(l.b-l.a));\n}\n\n\nreal distance(Segment s, Point c){\n    if(dot(s.b-s.a, c-s.a) < EPS) return abs(c-s.a);\n    if(dot(s.a-s.b, c-s.b) < EPS) return abs(c-s.b);\n    return abs(cross(s.b-s.a, c-s.a)) / abs(s.a-s.b);\n}\n\nreal distance(Segment s, Segment t){\n    if(intersect(s, t)) return 0.0;\n    return min({distance(s, t.a), distance(s, t.b),\n                distance(t, s.a), distance(t, s.b)});\n}\n\n\nPoint project(Line l, Point p){\n    Point Q = l.b-l.a;\n    return l.a + Q*(dot(p-l.a, Q) / dot(Q, Q));\n}\n\n\nPoint project(Segment s, Point p){\n    Point Q = s.b-s.a;\n    return s.a + Q*(dot(p-s.a, Q) / dot(Q, Q));\n}\n\nPoint refrect(Segment s, Point p){\n    Point Q = project(s, p);\n    return Q*2-p;\n}\n\nbool isOrthogonal(Segment s, Segment t){\n    return fabs(dot(s.b-s.a, t.b-t.a)) < EPS;\n}\n\nbool isparallel(Segment s, Segment t){\n    return fabs(cross(s.b-s.a, t.b-t.a)) < EPS;\n}\n\n\nPoint crossPoint(Segment s, Segment t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPoint crossPoint(Line s, Line t){\n    real d1 = cross(s.b-s.a, t.b-t.a);\n    real d2 = cross(s.b-s.a, s.b-t.a);\n    if(fabs(d1) < EPS && fabs(d2) < EPS) return t.a;\n    return t.a+(t.b-t.a)*d2/d1;\n}\n\nPolygon crossPoint(Circle c, Line l){\n    Point p = project(l, c.c), q = (l.b-l.a)/abs(l.b-l.a);\n    if(abs(distance(l, c.c)-c.r) < EPS){\n        return {p};\n    }\n    double k = sqrt(c.r*c.r-dot(p-c.c, p-c.c));\n    return {p-q*k, p+q*k};\n}\n\nPolygon crossPoint(Circle c, Segment s){\n    auto tmp = crossPoint(c, Line(s.a, s.b));\n    Polygon ret;\n    for (auto &&i : tmp) {\n        if(distance(s, i) < EPS) ret.emplace_back(i);\n    }\n    return ret;\n}\n\n\nPolygon crossPoint(Circle c1, Circle c2){\n    double d = abs(c1.c-c2.c);\n    double a = acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t = arg(c2.c-c1.c);\n    return {c1.c+polar(c1.r, t+a), c1.c+polar(c1.r, t-a)};\n}\n\nPolygon tangent(Circle c1, Point p){\n    Circle c2 = Circle(p, sqrt(dot(c1.c-p, c1.c-p)-c1.r*c1.r));\n    return crossPoint(c1, c2);\n}\nvector<Line> tangent(Circle c1, Circle c2){\n    vector<Line> ret;\n    if(c1.r < c2.r) swap(c1, c2);\n    double k = dot(c1.c-c2.c, c1.c-c2.c);\n    if(abs(k) < EPS) return {};\n    Point u = (c2.c-c1.c)/sqrt(k);\n    Point v(-u.y, u.x);\n    for (auto &&i : {-1, 1}) {\n        double h = (c1.r+i*c2.r)/sqrt(k);\n        if(abs(h*h-1) < EPS){\n            ret.emplace_back(c1.c+u*c1.r, c1.c+(u+v)*c1.r);\n        }else if(h*h < 1){\n            Point u2 = u*h, v2 = v*sqrt(1-h*h);\n            ret.emplace_back(c1.c+(u2+v2)*c1.r, c2.c-(u2+v2)*c2.r*i);\n            ret.emplace_back(c1.c+(u2-v2)*c1.r, c2.c-(u2-v2)*c2.r*i);\n        }\n    }\n    return ret;\n}\n\nreal area(Polygon v){\n    if(v.size() < 3) return 0.0;\n    real ans = 0.0;\n    for (int i = 0; i < v.size(); ++i) {\n        ans += cross(v[i], v[(i+1)%v.size()]);\n    }\n    return ans/2;\n}\n\nreal area(Circle c, Polygon &v){\n    int n = v.size();\n    real ans = 0.0;\n    Polygon u;\n    for (int i = 0; i < n; ++i) {\n        u.emplace_back(v[i]);\n        auto q = crossPoint(c, Segment(v[i], v[(i+1)%n]));\n        for (auto &&j : q) {\n            u.emplace_back(j);\n        }\n    }\n    for (int i = 0; i < u.size(); ++i) {\n        Point A = u[i]-c.c, B = u[(i+1)%u.size()]-c.c;\n        if(abs(A) >= c.r+EPS || abs(B) >= c.r+EPS){\n            Point C = polar(1, arg(B)-arg(A));\n            ans += c.r*c.r*arg(C)/2;\n        }else {\n            ans += cross(A, B)/2;\n        }\n    }\n    return ans;\n}\n\nPolygon convex_hull(Polygon v){\n    int n = v.size();\n    sort(v.begin(),v.end(), sorty);\n    int k = 0;\n    Polygon ret(n*2);\n    for (int i = 0; i < n; ++i) {\n        while(k > 1 && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    for(int i = n-2, t=k; i >= 0; i--){\n        while(k > t && cross(ret[k-1]-ret[k-2], v[i]-ret[k-1]) < 0) k--;\n        ret[k++] = v[i];\n    }\n    ret.resize(k-1);\n    return ret;\n}\n\nbool isconvex(Polygon v){\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        if(ccw(v[(i+n-1)%n], v[i], v[(i+1)%n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\nint contains(Polygon v, Point p){\n    int n = v.size();\n    bool x = false;\n    static constexpr int IN = 2;\n    static constexpr int ON = 1;\n    static constexpr int OUT = 0;\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i]-p, b = v[(i+1)%n]-p;\n        if(fabs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n        if(a.y > b.y) swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return (x?IN:OUT);\n}\n\nreal diameter(Polygon v){\n    int n = v.size();\n    if(n == 2) return abs(v[0]-v[1]);\n    int i = 0, j = 0;\n    for (int k = 0; k < n; ++k) {\n        if(v[i] < v[k]) i = k;\n        if(!(v[j] < v[k])) j = k;\n    }\n    real ret = 0;\n    int si = i, sj = j;\n    while(i != sj || j != si){\n        ret = max(ret, abs(v[i]-v[j]));\n        if(cross(v[(i+1)%n]-v[i], v[(j+1)%n]-v[j]) < 0.0) i = (i+1)%n;\n        else j = (j+1)%n;\n    }\n    return ret;\n}\n\nPolygon convexCut(Polygon v, Line l){\n    Polygon q;\n    int n = v.size();\n    for (int i = 0; i < n; ++i) {\n        Point a = v[i], b = v[(i+1)%n];\n        if(ccw(l.a, l.b, a) != -1) q.push_back(a);\n        if(ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0){\n            q.push_back(crossPoint(Line(a, b), l));\n        }\n    }\n    return q;\n}\n\nreal closest_pair(Polygon &v, int l = 0, int r = -1){\n    if(!(~r)){\n        r = v.size();\n        sort(v.begin(),v.end());\n    }\n    if(r - l < 2) {\n        return abs(v.front()-v.back());\n    }\n    int mid = (l+r)/2;\n    real p = v[mid].x;\n    real d = min(closest_pair(v, l, mid), closest_pair(v, mid, r));\n    inplace_merge(v.begin()+l, v.begin()+mid, v.begin()+r, sorty);\n    Polygon u;\n    for (int i = l; i < r; ++i) {\n        if(fabs(v[i].x-p) >= d) continue;\n        for (int j = 0; j < u.size(); ++j) {\n            real dy = v[i].y-next(u.rbegin(), j)->y;\n            if(dy >= d) break;\n            d = min(d, abs(v[i]-*next(u.rbegin(), j)));\n        }\n        u.emplace_back(v[i]);\n    }\n    return d;\n}\n\nint main() {\n    Point A, B, C, O;\n    real x;\n    while(cin >> A, A.x >= 0.5){\n        cin >> B >> C >> O >> x;\n        Polygon P{A, B, C};\n        P = convex_hull(P);\n        Circle X(O, x);\n        auto a = abs(area(P)), b = x*x*pi, c = area(X, P);\n        Segment p(A, B), q(B, C), r(C, A);\n        if(abs(a-c) < EPS) puts(\"b\");\n        else if(abs(b-c) < EPS) puts(\"a\");\n        else if(!crossPoint(X, p).empty() || !crossPoint(X, q).empty() || !crossPoint(X, r).empty()) puts(\"c\");\n        else puts(\"d\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble dist(const P& a, const P& b)\n{\n\treturn sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nbool isIntoC(const P& p, const C& c)\n{\n\treturn dist(p, c.p) < c.r+EPS;\n}\n\nbool isIntoC(const L& l, const C& c)\n{\n\treturn dist(l[0], c.p) < c.r+EPS && dist(l[1], c.p) < c.r+EPS;\n}\n\nbool intersectSC(const L& l, const C& c)\n{\n\tif(isIntoC(l, c)) return false;\n\t\n\tdouble vc=dot(l[1]-l[0], c.p-l[0]);\n\tif(vc+EPS<0)\n\t{\n\t\treturn dist(l[0], c.p)+EPS<c.r;\n\t}\n\t\n\tdouble vv=dot(l[1]-l[0], l[1]-l[0]);\n\t\n\tif(vc > vv)\n\t{\n\t\tdouble d=dist(l[1], c.p);\n\t\t\n\t\treturn d*d+EPS<c.r*c.r;\n\t}\n\t\n\tdouble cc=dot(c.p-l[0], c.p-l[0]);\n\t\n\treturn cc-(vc/vv)*vc+EPS < c.r*c.r;\n}\n\nint main()\n{\n\tint x,y,r;\n\twhile(scanf(\"%d%d\", &x, &y), (x||y))\n\t{\n\t\tvector<P> tri;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\ttri.push_back(P(x,y));\n\t\t\tif(i==2) break;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t}\n\t\n\t\tscanf(\"%d%d%d\", &x,&y,&r);\n\t\tC c(P(x,y), r);\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\tif(!isIntoC(tri[i], c))\n\t\t\t{\n\t\t\t\tg=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(g) \n\t\t{\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tg=false;\n\t\tfor(int i=0; i<tri.size(); i++)\n\t\tfor(int j=i+1; j<tri.size(); j++)\n\t\t{\n\t\t\tif(intersectSC(L(tri[i], tri[j]), c))\n\t\t\t{\n\t\t\t\tg=true;\n\t\t\t}\n\t\t}\n\t\tif(g)\n\t\t{\n\t\t\tputs(\"c\");\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tint cnt=0, cr[3];\n\t\tcr[0]=cross(tri[0]-tri[1], tri[0]-c.p);\n\t\tcr[1]=cross(tri[1]-tri[2], tri[1]-c.p);\n\t\tcr[2]=cross(tri[2]-tri[0], tri[2]-c.p);\n\t\t\n\t\tif(cr[0]<EPS&&cr[1]<EPS&&cr[2]<EPS||cr[0]>EPS&&cr[1]>EPS&&cr[2]>EPS) puts(\"a\");\n\t\telse puts(\"d\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n    if(rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS * len) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\n//多角形の面積\ntemplate<class T>\nT area(const vector<point<T> >& v){\n\tT ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S,const point<T> &p){ return sqrt(dist2(S,p)); }\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ntemplate<class T>\ndouble geodist(point<T> a,point<T> b,const circle<T> &C){\n\tdouble r=C.r;\n\tsegment<T> s(a,b);\n\tif(dist(s,C.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=C.c;\n\tb-=C.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntemplate<class T>\nstd::istream& operator>>(std::istream& is, point<T>& point){return ( is >> point.x >> point.y );}\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n\n//円の接点\nvector<P> GetContact(const P& p,const P& q,const double r){\n\tP a = p-q;\n\tdouble s = SQ(a.x) + SQ(a.y);\n\tdouble D = sqrt(s - SQ(r));\n\tdouble dx = r * D * a.y / s;\n\tdouble dy = r * D * a.x / s;\n\tdouble bx = SQ(r) * a.x / s;\n\tdouble by = SQ(r) * a.y / s;\n\tvector<P> ans(2);\n\tans[0].x = bx + dx;\n\tans[0].y = by - dy;\n\tans[1].x = bx - dx;\n\tans[1].y = by + dy;\n\n\tans[0] += q;\n\tans[1] += q;\n\n\treturn ans;\n}\n\n//todo : verifyしてないので、そのうち。\n// 円が交差しているか 「=」は問によって変更する\ntemplate<class T>\nint CircleCross(const circle<T> &c1,const circle<T> &c2){\n\tdouble l = abs(c1.c - c2.c);\n\tif(l >= c1.r + c2.r) return 3; //外部にある\n\tif(l + c1.r <= c2.r) return 2; //c1 ⊃ c2\n\tif(l + c2.r <= c1.r) return 1; //c1 ⊂ c2\n\treturn 0; //交差している\n}\n\n\ntypedef pair<P,P> PD;\n//円同士の交点\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\n\n//三角形の中にあるか\nbool InTri(const P p[3],const P& o){\n\treturn \n\t\t(ccw(p[0],p[1],p[2]) == ccw(p[0],p[1],o)) &&\n\t\t(ccw(p[1],p[2],p[0]) == ccw(p[1],p[2],o)) &&\n\t\t(ccw(p[2],p[0],p[1]) == ccw(p[2],p[0],o));\n}\n\n\nint main(){\n\tP p[3];\n\tC c;\n\twhile(cin>>p[0],p[0].x != 0 || p[0].y != 0){\n\t\tcin>>p[1]>>p[2];\n\t\tcin>>c.c>>c.r;\n\n\t\tbool ok = true;\n\t\tFOR(i,3){\n\t\t\tif(abs(p[i]-c.c) + EPS > c.r) ok = false;\n\t\t}\n\n\t\t//in-circle\n\t\tif(ok){ puts(\"b\"); continue; }\n\n\t\tok = false;\n\n\t\tFOR(i,3){\n\t\t\tdouble l = dist2(S(p[i],p[(i+1)%3]),c.c);\n\t\t\tif(l < c.r * c.r) ok = true;\n\t\t}\n\n\t\t//intersect\n\t\tif(ok){ puts(\"c\"); continue; }\n\n\t\tif(InTri(p,c.c))\n\t\t\tputs(\"a\"); //in-triangle\n\t\telse\n\t\t\tputs(\"d\"); //otherwise\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nbool contain(const polygon& p, const point& a) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(abs(p[i] - a) < EPS)\n\t\t\treturn true;\n\n\tvector<point> points;\n\tpoints.push_back(a);\n\n\tconst segment seg(point(0, a.y), point(10001, a.y));\n\tfor(int i = 0; i < p.size(); ++i) {\n\t\tsegment edge(p[i], p[(i + 1 + p.size()) % p.size()]);\n\t\tif(intersect(seg, edge))\n\t\t\tpoints.push_back(crosspoint(seg, edge));\n\t}\n\n\tif(points.size() < 3)\n\t\treturn false;\n\n\tsort(points.begin(), points.end());\n\n\treturn points[1] == a;\n}\n\nbool contain(const circle& c, const polygon& p) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(c.c, p[i]) > c.r - EPS)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool contain(const polygon& p, const circle& c) {\n\tif(!contain(p, c.c))\n\t\treturn false;\n\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(segment(p[i], p[(i + 1 + p.size()) % p.size()]), c.c) < c.r + EPS)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool intersect(const polygon& p, const circle& c) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(segment(p[i], p[(i + 1 + p.size()) % p.size()]), c.c) < c.r + EPS)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y; cin >> x >> y, x;) {\n\t\tpolygon triangle;\n\t\ttriangle.push_back(point(x, y));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y;\n\t\t\ttriangle.push_back(point(x, y));\n\t\t}\n\n\t\tint r;\n\t\tcin >> x >> y >> r;\n\t\tcircle c(point(x, y), r);\n\n\t\tif(contain(c, triangle))\n\t\t\tcout << 'b' << endl;\n\n\t\telse if(contain(triangle, c))\n\t\t\tcout << 'a' << endl;\n\n\t\telse if(intersect(triangle, c))\n\t\t\tcout << 'c' << endl;\n\n\t\telse\n\t\t\tcout << 'd' << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\n\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\n\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\nint main(){\n  G p;\n  L l[3];\n  C c;\n  p.resize(3);\n  while(cin >> p[0].real() >> p[0].imag(), p[0].real()||p[0].imag()){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> p[i].real() >> p[i].imag();\n    }\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      l[i] = L( p[i], p[(i+1)%3]);\n    }\n\n    bool flag = true;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(distance(l[i], c.p) + EPS < c.r) flag = false;\n    }\n    if(flag && contains( p, c.p)){\n      cout << 'a' << endl;\n      continue;\n    }\n    flag = false;\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(!contains( c, p[i])) flag = true;\n    }\n    if(!flag){\n      cout << 'b' << endl;\n      continue;\n    }\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(intersect( c, l[i]) > 0 || intersect(c,p[i])) flag = false;\n    }\n    if(!flag){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint sig(double r) { return r < -EPS ? -1 : r > EPS ? 1 : 0; }\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {}\n\tP operator+(const P &a) const { return P(x + a.x, y + a.y); }\n\tP operator-(const P &a) const { return P(x - a.x, y - a.y); }\n\tP operator*(const P &a) const { return P(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(const double &k) const { return P(x * k, y * k); }\n\tP operator/(const double &k) const { return P(x / k, y / k); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble abs() const { return sqrt(abs2()); }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const P &a) const { return x * a.x + y * a.y; }\n\tdouble det(const P &a) const { return x * a.y - y * a.x; }\n\tP proj(const P &a) const { double k = dot(a) / abs2(); return P(x * k, y * k); }\n\tbool operator<(const P &a) const { return x != a.x ? x < a.x : y < a.y; }\n\tbool operator==(const P &a) const { return sig(x - a.x) == 0 && sig(y - a.y) == 0; }\n};\n\nostream &operator<<(ostream&os, const P&a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\n\nstruct L {\n\tP a, b;\n\tL() {}\n\tL(P a, P b) : a(a), b(b) {}\n\tP vec() const { return b - a; }\n\tP proj(const P &p) const { return a + vec().proj(p - a); }\n\tP refl(const P &p) const { return proj(p) * 2 - p; }\n\tint iSP(const P &p) const {\n\t\tint s = sig(vec().det(p - a));\n\t\tif (s != 0) return s;\n\t\tif (sig(vec().dot(p - a)) < 0) return -2;\n\t\tif (sig(vec().dot(p - b)) < 0) return 2;\n\t\treturn 0;\n\t}\n\tint iLL(const L &l) const {\n\t\tif (sig(vec().det(l.vec()))) return 1;\n\t\tif (sig(vec().det(l.a - a))) return 0;\n\t\treturn -1;\n\t}\n\tbool iLS(const L &l) const { return sig(tri(a, b, l.a)) * sig(tri(a, b, l.b)) <= 0; }\n\tbool iSS(const L &l) const { return iLS(l) && l.iLS(*this); }\n\tP pLL(const L &l) const { return a + vec() * (l.a - a).det(l.vec()) / b.det(l.vec()); }\n\tdouble dLP(const P &p) const { return abs(tri(a, b, p)) / vec().abs(); }\n\tdouble dSP(const P &p) const {\n\t\tif (sig(vec().dot(p - a)) <= 0) return (p - a).abs();\n\t\tif (sig(vec().dot(p - b)) >= 0) return (p - b).abs();\n\t\treturn dLP(p);\n\t}\n\tdouble dLL(const L &l) const { return iLL(l) ? 0 : dLP(l.a); }\n\tdouble dLS(const L &l) const { return iLS(l) ? 0 : min(dLP(l.a), dLP(l.b)); }\n\tdouble dSS(const L &l) const { return iSS(l) ? 0 : min(min(dSP(l.a), dSP(l.b)), min(l.dSP(a), l.dSP(b))); }\n};\n\nstruct C {\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p, double r) : p(p), r(r) {}\n\tint iCC(C c) {\n\t\tdouble d = (c.p - p).abs();\n\t\tif (sig(d) == 0 && sig(r - c.r) == 0) return -1;\n\t\tif (sig(r - c.r - d) > 0) return 2;\n\t\tif (sig(c.r - r - d) > 0) return -2;\n\t\treturn (sig(r + c.r - d) >= 0) ? 1 : 0;\n\t}\n\tbool iCS(L l) {\n\t\treturn (sig(r - l.dSP(p)) >= 0&& sig(r - max((l.a - p).abs(), (l.b - p).abs())) <= 0);\n\t}\n\tpair<P,P> pCC(C c) {\n\t\tdouble d = (c.p - p).abs();\n\t\tdouble x = (d * d + r * r - c.r * c.r) / (d * 2);\n\t\tP e = (c.p - p) / d, w = e * P(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\t\treturn make_pair(p + e * x - w, p + e * x + w);\n\t}\n\tpair<P,P> pCL(L l) {\n\t\tP h = l.proj(p);\n\t\tdouble d = (h - p).abs();\n\t\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\t\tP e = (l.b - l.a) / (l.b - l.a).abs();\n\t\treturn make_pair(h - e * y, h + e * y);\n\t}\n\tpair<P,P> tCP(P p) {\n\t\tdouble d2 = (p - this->p).abs2();\n\t\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\t\tP h = this->p + (p - this->p) * (r * r / d2);\n\t\tP w = (p - this->p) * P(0, 1) * (x * r / d2);\n\t\treturn make_pair(h - w, h + w);\n\t}\n\tdouble aCC(C c) {\n\t\tdouble d = (p - c.p).abs();\n\t\tif (sig(r - c.r - d) >= 0) return c.r * c.r * PI;\n\t\tif (sig(c.r - r - d) >= 0) return r * r * PI;\n\t\tif (sig(r + c.r - d) <= 0) return 0;\n\t\tdouble x = (d * d + r * r - c.r * c.r) / (d * 2);\n\t\tdouble h = sqrt(r * r - x * x);\n\t\treturn r * r * atan2(h, x) + c.r * c.r * atan2(h, d - x) - d * h; \n\t}\n};\n\n\nint main() {\n\tint x[3], y[3];\n\tint xx, yy, r;\n\tP p[3],g;\n\tL s[3];\n\tC c;\n\tIL {\n\t\tcin >> x[0] >> y[0];\n\t\tif (x[0] == 0 && y[0] == 0) break;\n\t\tcin >> x[1] >> y[1];\n\t\tcin >> x[2] >> y[2];\n\t\tcin >> xx >> yy;\n\t\tcin >> r;\n\t\trep(i, 3) p[i] = P(x[i], y[i]);\n\t\tg = (p[0] + p[1] + p[2]) / 3;\n\t\trep(i, 3) s[i] = L(p[i], p[(i+1)%3]);\n\t\tc = C(P(xx, yy), r);\n\t\tif (!(L(g, c.p)).iSS(s[0]) && !(L(g, c.p)).iSS(s[1]) && !(L(g, c.p)).iSS(s[2]) && sig(s[0].dSP(c.p) - c.r) >= 0 && sig(s[1].dSP(c.p) - c.r) >= 0 && sig(s[2].dSP(c.p) - c.r) >= 0) {\n\t\t\tcout << \"a\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sig((c.p - p[0]).abs() - r) <= 0 && sig((c.p - p[1]).abs() - r) <= 0 && sig((c.p - p[2]).abs() - r) <= 0) {\n\t\t\tcout << \"b\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sig(s[0].dSP(c.p) - c.r) <= 0 || sig(s[1].dSP(c.p) - c.r) <= 0 || sig(s[2].dSP(c.p) - c.r) <= 0) {\n\t\t\tcout << \"c\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"d\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nD dis(P a,P b){\n\treturn sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\ndouble x1,x2,x3,y4,y2,y3,x,y,r;\nmain(){\n\twhile(cin>>x1>>y4,x1||y4){\n\t\tcin>>x2>>y2>>x3>>y3>>x>>y>>r;\n\t\tvector<P>v;\n\t\tv.push_back(P(x1,y4));\n\t\tv.push_back(P(x2,y2));\n\t\tv.push_back(P(x3,y3));\n\t\tsort(v.begin(),v.end());\n\t\tif(inConvex(P(x,y),v)&&dis(P(x1,y4),P(x,y))+EPS>r&&dis(P(x2,y2),P(x,y))+EPS>r&&dis(P(x3,y3),P(x,y))+EPS>r)cout<<'a'<<endl;\n\t\telse if(dis(P(x1,y4),P(x,y))<r+EPS&&dis(P(x2,y2),P(x,y))<r+EPS&&dis(P(x3,y3),P(x,y))<r+EPS)cout<<'b'<<endl;\n\t\telse if(distSP(P(x1,y4),P(x2,y2),P(x,y))<=r||distSP(P(x3,y3),P(x2,y2),P(x,y))<=r||distSP(P(x1,y4),P(x3,y3),P(x,y))<=r)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0){\n\t\t\tif(acx*acx+acy*acy<=r*r)return true;\n\t\t}else{\n\t\t\tif(abx*acx+aby*acy>abx*abx+aby*aby){\n\t\t\t\tif(bcx*bcx+bcy*bcy<=r*r)return true;\n\t\t\t}else if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<0)ok1=false;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)>0)ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<0)ok1=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)>0)ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<0)ok1=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)>0)ok2=false;\n\treturn ok1||ok2;\n}\ndouble dist(int ax,int ay,int bx,int by,int px,int py){\n\tdouble dx=bx-ax;\n\tdouble dy=by-ay;\n\tdouble A=dx*dx+dy*dy;\n\tdouble B=dx*(ax-px)+dy*(ay-py);\n\tdouble t=-B/A;\n\tif(t<0)t=0;\n\tif(t>1)t=1;\n\tdouble tx=ax+dx*t,ty=ay+dy*t;\n\treturn sqrt((px-tx)*(px-tx)+(py-ty)*(py-ty));\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<=r*r&&(c-g)*(c-g)+(d-h)*(d-h)<=r*r&&(e-g)*(e-g)+(f-h)*(f-h)<=r*r)printf(\"b\\n\");\n\t\telse if(dist(a,b,c,d,g,h)>(double)r-0.000001&&dist(a,b,e,f,g,h)>(double)r-0.000001&&dist(e,f,c,d,g,h)>(double)r-0.000001&&inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-8\ntypedef long long int lli;\ntypedef complex<lli> C;\n\nC v[4];\nlli r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble zcross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  lli ina;\n  lli ir2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    ina = norm(a);\n    if (ina < ir2) {\n      c[i] = -1;\n    } else if (ina > ir2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0 && c[1]>=0 && c[2]>=0) {\n    return 1;\n  } else if (c[0]<=0 && c[1]<=0 && c[2]<=0) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  lli cab;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    cab = zcross(a,b);\n    f[i] = (cab > 0);\n    if (cab*cab < norm(a)*r*r) {\n      return false;\n    }\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double sd, s, t;\n  long long int ina, inb, idab, id;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    ina = norm(a);\n    inb = norm(b);\n    idab = dot(a,b);\n    id = idab*idab - ina*(inb-r*r);\n    if (id < 0) {\n      continue;\n    }\n    sd = sqrt((double)id);\n    s = (idab+sd)/ina;\n    t = (idab-sd)/ina;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (!id) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ninline D inprd(const P &a, const P &b){ return (conj(a) * b).X; }\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\ninline D sign(D d){ return (d<0)?-1:d>0?1:0; }\n\nbool is_intriangle(const P &p1, const P &p2, const P &p3, const P &q){\n    D s1 = sign(outprd(p2-p1,q-p1)), s2 = sign(outprd(p3-p2,q-p2)), s3 = sign(outprd(p1-p3,q-p3));\n    return (s1 == s2 && s2 == s3);\n}\ninline P circum_center(const P &a, const P &b, const P &c){\n    P bc = c - b, ca = a - c, ab = b - a;\n    return (a + b - (inprd(bc, ca) / outprd(ab, bc)) * ab * P(0,1)) / 2.0;\n}\nD distance_ls_p(const P &a, const P &b, const P &c){\n    if(inprd(b-a, c-a) < EPS) return abs(c-a);\n    if(inprd(a-b, c-b) < EPS) return abs(c-b);\n    return abs(outprd(b-a, c-a)) / abs(b-a);\n}\n\nstring solve(P p1, P p2, P p3, P pc, int r){\n    D dr = r;\n    if( distance_ls_p(p1,p2,pc) >= dr - EPS &&\n        distance_ls_p(p2,p3,pc) >= dr - EPS &&\n        distance_ls_p(p3,p1,pc) >= dr - EPS &&\n        is_intriangle(p1,p2,p3,pc))\n        return \"a\";\n\n    if( distance_ls_p(p1,p2,pc) > dr &&\n        distance_ls_p(p2,p3,pc) > dr &&\n        distance_ls_p(p3,p1,pc) > dr &&\n        !is_intriangle(p1,p2,p3,pc))\n        return \"d\";\n\n    if(norm(p1-pc) <= r*r && norm(p2-pc) <= r*r && norm(p3-pc) <= r*r) return \"b\";\n\n    return \"c\";\n}\n\nint main(){\n    P p1,p2,p3,pc;\n    int r;\n    int x, y;\n    while(cin >> x >> y && x && y){\n        p1 = P(x,y);\n        cin >> x >> y;\n        p2 = P(x,y);\n        cin >> x >> y;\n        p3 = P(x,y);\n        cin >> x >> y >> r;\n        pc = P(x,y);\n        cout << solve(p1,p2,p3,pc,r) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#include<string>\n \n#define EPS 1E-10\n#define SAME_SIGN( a , b ) ( a * b > EPS ? true : false )\n \nnamespace geometry{\n \n    struct point{\n        double x;\n        double y;\n        point(){}\n        point( double x , double y ):x(x),y(y){}\n        point& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n        point& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n        point& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n        point& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n        bool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n        bool operator != ( const point& p ) const { return !(*this == p); }\n        double norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n    };\n \n    typedef point vector2d;\n \n    struct circle{\n        point center;\n        double radius;\n    };\n \n    struct triangle{\n        point a;\n        point b;\n        point c;\n    };\n \n    point operator + ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p += p2;\n            return p;\n        }\n        point operator - ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p -= p2;\n            return p;\n        }\n        point operator * ( const point& p1 , double factor ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator * ( double factor , const point& p1 ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator / ( const point& p1 , double factor ){\n            point p(p1);\n            p /= factor;\n            return p;\n        }\n \n    std::istream& operator >> ( std::istream& s , point& p )\n    {\n        return s >> p.x >> p.y;\n    }\n \n    double get_distance( const point& p1 , const point& p2 )\n    {\n\t\tdouble testDis = sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) ); // テスト用\n        return sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n    }\n \n    double get_dot_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.x + oa.y * ob.y;\n    }\n \n    double get_cross_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.y - oa.y * ob.x;\n    }\n \n    point get_project( const point& s , const point& e , const point& p ){\n        double scale = get_dot_product( p , e , s ) / ( e - s ).norm();\n        return s + scale * ( e - s ) / ( e - s ).norm();\n    }\n \n    bool is_inter_point( const point& s , const point& e , const point& p ){\n        return std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n    }\n}\n \nusing namespace geometry;\n \nbool input_data( triangle& tri , circle& cir )\n{\n    std::cin >> tri.a;\n    if( tri.a.x == 0 && tri.a.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.b;\n    if( tri.b.x == 0 && tri.b.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.c;\n    if( tri.c.x == 0 && tri.c.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.center;\n    if( cir.center.x == 0 && cir.center.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.radius;\n    return true;\n}\n \nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n    if( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n        if( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius + EPS ){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    else{\n        return false;\n    }\n}\n \nbool is_overlap( triangle& tri , circle& cir )\n{\n    // オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n    if( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n        !(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n        !(is_overlap_for_one_side( tri.c , tri.a , cir ))\n        ){\n            return false;\n    }\n    else{\n        return true;\n    }\n \n}\n \nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n    if( get_distance( tri.a , cir.center ) < cir.radius  &&\n        get_distance( tri.b , cir.center ) < cir.radius  &&\n        get_distance( tri.c , cir.center ) < cir.radius\n        ){\n            std::cout << \"b\" << std::endl;\n    }\n    else{\n        if( get_distance( tri.a , cir.center ) > cir.radius  &&\n            get_distance( tri.b , cir.center ) > cir.radius  &&\n            get_distance( tri.c , cir.center ) > cir.radius\n            ){\n                if( !(is_overlap( tri , cir )) ){\n                    if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                        SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                            std::cout << \"a\" << std::endl;\n                    }\n                    else{\n                        std::cout << \"d\" << std::endl;\n                    }\n                }\n                else{\n                    std::cout << \"c\" << std::endl;\n                }\n        }\n        else{\n            std::cout << \"c\" << std::endl;\n        }\n    }\n}\n\nstd::string output_positional_relation_of_circle_and_triangle_for_test( triangle& tri , circle& cir )\n{\n    if( get_distance( tri.a , cir.center ) < cir.radius  &&\n        get_distance( tri.b , cir.center ) < cir.radius  &&\n        get_distance( tri.c , cir.center ) < cir.radius\n        ){\n           return \"b\";\n    }\n    else{\n        if( get_distance( tri.a , cir.center ) > cir.radius  &&\n            get_distance( tri.b , cir.center ) > cir.radius  &&\n            get_distance( tri.c , cir.center ) > cir.radius\n            ){\n                if( !(is_overlap( tri , cir )) ){\n                    if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                        SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                           return \"a\";\n                    }\n                    else{\n                        return \"d\";\n                    }\n                }\n                else{\n                    return \"c\";\n                }\n        }\n        else{\n            return \"c\";\n        }\n    }\n}\n\nstruct TEST_CASE {\n\ttriangle tri;\n\tcircle cir;\n\tstd::string ans;\n\n\tvoid SetTestCase( int ax, int ay, int bx, int by, int cx, int cy, int ox, int oy, int r, std::string ans )\n\t{\n\t\tthis->tri.a.x = ax;\n\t\tthis->tri.a.y = ay;\n\t\tthis->tri.b.x = bx;\n\t\tthis->tri.b.y = by;\n\t\tthis->tri.c.x = cx;\n\t\tthis->tri.c.y = cy;\n\t\tthis->cir.center.x = ox;\n\t\tthis->cir.center.y = oy;\n\t\tthis->cir.radius = r;\n\t\tthis->ans = ans;\n\t}\n};\n\nvoid test(void)\n{\n\tTEST_CASE testCase[100];\n\n\ttestCase[0].SetTestCase(10, 20, 1, 5, 19, 5, 10, 10, 3, \"a\");\n\ttestCase[1].SetTestCase(10, 12, 12, 9, 8, 9, 10, 10, 3, \"b\");\n\ttestCase[2].SetTestCase(10, 12, 12, 9, 7, 10, 10, 10, 3, \"c\");\n\ttestCase[3].SetTestCase(20, 5, 40, 20, 40, 5, 20, 20, 12, \"c\");\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tstd::cout << \"testCase[\" << i << \"] : \";\n\t\tif( testCase[i].ans == output_positional_relation_of_circle_and_triangle_for_test(testCase[i].tri, testCase[i].cir) ){\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\t}\n\t\telse{\n\t\t\tstd::cout << \"NG\" << std::endl;\n\t\t}\n\t}\n}\n \nint main(void)\n{\n    triangle tri;\n    circle cir;\n \n\t// test();\n\n    while(input_data(tri, cir)){\n        output_positional_relation_of_circle_and_triangle( tri , cir );\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-6\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double na;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    na = norm(a);\n    if (na < r2) {\n      c[i] = -1;\n    } else if (na > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0 && c[1]>=0 && c[2]>=0) {\n    return 1;\n  } else if (c[0]<=0 && c[1]<=0 && c[2]<=0) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double na, nb, dab, d, sd, s, t;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    na = norm(a);\n    nb = norm(b);\n    dab = dot(a,b);\n    d = dab*dab - na*(nb-r*r);\n    if (d < -EPS) {\n      continue;\n    } else if (fabs(d) < EPS) {\n      d = 0.;\n    }\n    sd = sqrt(d);\n    s = (dab+sd)/na;\n    t = (dab-sd)/na;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (fabs(d) < EPS) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P p, const P q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P p, const P q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& p_, double r_) : p(p_), r(r_) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\tif(nm == 0.0) return min(distP2P(p, l[0]), distP2P(p, l[1]));\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0.0 && d1 * d2 > 0.0 && d2 * d0 > 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(3);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL r0(tr[1], tr[0]);\n\tL l1(tr[1], tr[2]);\n\tL r1(tr[2], tr[1]);\n\tL l2(tr[2], tr[0]);\n\tL r2(tr[0], tr[2]);\n\td[0] = max(distP2LS(cc.p, l0), distP2LS(cc.p, r0));\n\td[1] = max(distP2LS(cc.p, l1), distP2LS(cc.p, r1));\n\td[2] = max(distP2LS(cc.p, l2), distP2LS(cc.p, r2));\n\tif(in && d[0] >= cc.r && d[1] >= cc.r && d[2] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect ?\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\ndouble sign(double r) { return r < -EPS ? -1.0 : r > EPS ? 1.0 : 0.0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0.0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) <= 0.0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n\n// code for problem\nint x, y, r;\nvector<P> T;\nC cc;\n\nbool isPinC() {\n\tP e0 = T[0] - cc.p;\n\tP e1 = T[1] - cc.p;\n\tP e2 = T[2] - cc.p;\n\tdouble d0 = e0.det(e1);\n\tdouble d1 = e1.det(e2);\n\tdouble d2 = e2.det(e0);\n\tif(sign(d0 * d1) >= 0.0 && sign(d1 * d2) >= 0.0 && sign(d2 * d0) >= 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\tvector<double> d(3);\n\td[0] = (T[0] - cc.p).norm();\n\td[1] = (T[1] - cc.p).norm();\n\td[2] = (T[2] - cc.p).norm();\n\tif(sign(d[0] - cc.r) <= 0.0 && sign(d[1] - cc.r) <= 0.0 && sign(d[2] - cc.r) <= 0.0) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\tbool in = isPinC();\n\tL l0(T[0], T[1]);\n\tL l1(T[1], T[2]);\n\tL l2(T[2], T[0]);\n\td[0] = l0.dSP(cc.p);\n\td[1] = l1.dSP(cc.p);\n\td[2] = l2.dSP(cc.p);\n\tif(in && sign(d[0] - cc.r) >= 0.0 && sign(d[1] - cc.r) >= 0.0 && sign(d[2] - cc.r) >= 0.0) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(!in && sign(d[0] - cc.r) > 0.0) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\tT = vector<P>(3);\n\tfor(;;) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\tT[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}\n        "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\ndouble D(double x, double y){\n\treturn sqrt(x * x + y * y);\n}\n\ndouble inp(double x1, double x2, double y1, double y2){\n\treturn x1 * x2 + y1 * y2;\n}\n\nint main(){\n\tint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile( cin >> x1 >> y1 , x1 || y1 ){\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tx1 -= x4; x2 -= x4; x3 -= x4;\n\t\ty1 -= y4; y2 -= y4; y3 -= y4;\n\t\t\n\t\tdouble d = max(D(x1, y1), max(D(x2, y2), D(x3, y3)));\n\t\tif( d <= r ){\n\t\t\tputs(\"b\");\n\t\t}else{\n\t\t\tdouble d1, d2, d3;\n\t\t\tif(D(x1, y1) < inp(x1, x2, y1, y2) || D(x2, y2) < inp(x1, x2, y1, y2) ){\n\t\t\t\td1 = D(x1, y1);\n\t\t\t}else{\n\t\t\t\td1 = fabs(x1 * y2 - y1 * x2) / D(x2 - x1, y2 - y1);\n\t\t\t}\n\t\t\tif(D(x2, y2) < inp(x2, x3, y2, y3) || D(x3, y3) < inp(x2, x3, y2, y3) ){\n\t\t\t\td2 = D(x2, y2);\n\t\t\t}else{\n\t\t\t\td2 = fabs(x2 * y3 - y2 * x3) / D(x3 - x2, y3 - y2);\n\t\t\t}\n\t\t\tif(D(x3, y3) < inp(x3, x1, y3, y1) || D(x1, y1) < inp(x3, x1, y3, y1) ){\n\t\t\t\td3 = D(x3, y3);\n\t\t\t}else{\n\t\t\t\td3 = fabs(x3 * y1 - y3 * x1) / D(x1 - x3, y1 - y3);\n\t\t\t}\n\t\t\tdouble d = min(d1, min(d2, d3));\n\t\t\tint t = (x1 * y2 > y1 * x2) + (x2 * y3 > y2 * x3) + (x3 * y1 > y3 * x1);\n\t\t\tbool in = !(t && (t-3));\n\t\t\t\n\t\t\tif( in ){\n\t\t\t\tif( d < r ){\n\t\t\t\t\tputs(\"c\");\n\t\t\t\t}else{\n\t\t\t\t\tputs(\"a\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif( d <= r ){\n\t\t\t\t\tputs(\"c\");\n\t\t\t\t}else{\n\t\t\t\t\tputs(\"d\");\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cmath>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\nstatic const int CIRCLE_NON = 0;\nstatic const int CIRCLE_OUT = 1;\nstatic const int CIRCLE_IN = 2;\nstatic const int CIRCLE_CROSS = 3;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\ndouble getDistanceLP(Line s, Point p){ \n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\n\nbool isIntersect( Circle c1, Line l ){\n    double d = getDistanceLP(l, c1.c);\n    return ( equals(d, c1.r) || d < c1.r );\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Line l ){\n    assert( isIntersect( c1, l ) );\n    double d = getDistanceLP(l, c1.c);\n    Point v = l.p2 - l.p1;\n    if ( ccw(l.p1, l.p2, c1.c) == COUNTER_CLOCKWISE ){\n\tv = polar(abs(v), arg(v)-acos(-1)/2);\n    } else {\n\tv = polar(abs(v), arg(v)+acos(-1)/2);\n    }\n    double th = acos(d/c1.r);\n    Point v1 = polar(c1.r, arg(v) + th );\n    Point v2 = polar(c1.r, arg(v) - th );\n    return make_pair(c1.c+v1, c1.c+v2);\n}\n\nbool circleIsInTriangle(Circle c, Point t[3] ){\n    int ccw1 = ccw(t[0], t[1], c.c);\n    int ccw2 = ccw(t[1], t[2], c.c);\n    int ccw3 = ccw(t[2], t[0], c.c);\n    if ( !(ccw1 == ccw2 && ccw2 == ccw3 ) ) return false;\n    for ( int i = 0; i < 3; i++ ){\n\tLine l =  Line(t[i], t[(i+1)%3]);\n\tif ( c.r > getDistanceLP(l, c.c) ) return false;\n    }\n    return true;\n}\n\nbool triangleIsInCircle(Circle c, Point t[3] ){\n    for ( int i = 0; i < 3; i++ ){\n\tif ( c.r < getDistance(t[i], c.c) ) return false;\n    }\n    return true;\n}\n\nbool isIntersect(Circle c, Point t[3]){\n    for ( int i = 0; i < 3; i++ ){\n\tLine l =  Line(t[i], t[(i+1)%3]);\n\tif ( !isIntersect(c, l) ) continue;\n\tpair<Point, Point> pp = getCrossPoints(c, l);\n\tif ( ccw(l.p1, l.p2, pp.first) == ON_SEGMENT ) return true; \n\tif ( ccw(l.p1, l.p2, pp.second) == ON_SEGMENT ) return true;\n    }\n    return false;\n}\n\nint main(){\n    double x, y, r;\n    Circle c;\n    Point T[3];\n    while(1){\n\tcin >> x >> y;\n\tif ( x == 0 && y == 0 ) break;\n\tT[0] = Point(x, y);\n\tcin >> x >> y;\n\tT[1] = Point(x, y);\n\tcin >> x >> y;\n\tT[2] = Point(x, y);\n\tcin >> x >> y >> r;\n\tc = Circle(Point(x, y), r);\n\tif ( circleIsInTriangle(c, T) ) cout << \"a\" << endl;\n\telse if ( triangleIsInCircle(c, T) ) cout << \"b\" << endl;\n\telse if ( isIntersect(c, T) ) cout << \"c\" << endl;\n\telse cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Triangle and Circle\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool on_edge(const Point&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\n\nusing namespace std;\n\nstring solve(const Polygon& triangle, const Circle& circle) {\n    bool triangleInCircle = true;\n    for(const auto& p: triangle.vertex()) if(circle.center().distance(p) >= circle.r()) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    for(const auto& e: triangle.edge()) if(circle.include(e)) return \"c\";\n    if(triangle.on_edge(circle.center())) return \"c\";\n\n    if(triangle.include(circle.center())) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x, y, r;\n    while(cin >> x >> y, x != 0 || y != 0) {\n        Polygon triangle;\n        for(int i = 1; i < 4; ++i) {\n            triangle.add(Point(x, y));\n            cin >> x >> y;\n        }\n        cin >> r;\n        Circle circle(x, y, r);\n        cout << solve(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r&&!EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r&&!EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r&&!EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t&&((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r&&!EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r&&!EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r&&!EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point& a, const Point& b) { return Point{ a.px - b.px,a.py - b.py }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dst(const Point& a, const Point& b) { return abs(Minus(b , a)); }\nlong double dst(const Line& a, const Point& b) {\n\treturn dot(Minus(a.p2, a.p1), Minus(b, a.p1)) < 0.0 ? abs(Minus(b, a.p1)) : (dot(Minus(a.p1, a.p2), Minus(b, a.p2)) < 0.0 ? abs(Minus(b, a.p2)) : abs(crs(Minus(a.p2, a.p1), Minus(b, a.p1)) / abs(Minus(a.p2, a.p1))));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 1e-7 && 1e-7 < b.py)\n\t\t\tif (crs(a, b) < -1e-7) in = !in;\n\t\tif (fabs(crs(a, b)) <= 1e-7 && dot(a, b) <= 1e-7) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\twhile (true) {\n\t\tPoint r1, r2, r3, r4; long double r;\n\t\tcin >> r1.px >> r1.py; if (fabs(r1.px) <= 1e-7 && fabs(r1.py) <= 1e-7)break;\n\t\tcin >> r2.px >> r2.py >> r3.px >> r3.py >> r4.px >> r4.py >> r;\n\t\tLine l1 = Line{ r1,r2 }, l2 = { r2,r3 }, l3 = { r3,r1 };\n\t\tlong double c1 = min(dst(l1, r4), min(dst(l2, r4), dst(l3, r4)));\n\t\tlong double c2 = max(dst(r1, r4), max(dst(r2, r4), dst(r3, r4)));\n\t\tlong double c3 = min(dst(r1, r4), min(dst(r2, r4), dst(r3, r4)));\n\t\t//cout << dst(l1, r4) << ' ' << dst(l2, r4) << ' ' << dst(l3, r4) << endl;\n\t\tint c4 = contain({ r1,r2,r3 }, r4);\n\t\tif (c1 >= r - 1e-7 && c4 != 0) { cout << \"a\" << endl; }\n\t\telse if (c2 <= r + 1e-7) { cout << \"b\" << endl; }\n\t\telse if (c3 <= r + 1e-7) { cout << \"c\" << endl; }\n\t\telse { cout << \"d\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a+b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\trep(i,2)g[i+1]=pin();\n\t\tP p=pin();double r;cin>>r;\n\t\tC c(p,r);\n\t\tbool h=true;\n\t\tif(inconvex(g,c.c)!=2)h=false;\n\t\trep(i,3)if(distanceSP(L(g[i],g[(i+1)%3]),c.c)<c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'a'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\th=true;\n\t\trep(i,3)if(abs(g[i]-c.c)>c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'b'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,3)if(intersectCS(c,L(g[i],g[(i+1)%3])))h=true;\n\t\tif(h)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\npair<int, int> a;\npair<int, int> b;\npair<int, int> c;\npair<int, int> o;\nint r;\n\nint cross(pair<int, int> p1, pair<int, int> p2){\n  return p1.first * p2.second - p1.second * p2.first;\n}\n\ndouble length(pair<int, int> p){\n  return sqrt(p.first * p.first + p.second * p.second);\n}\n\nbool is_inside(){\n  if(cross(make_pair(b.first-a.first, b.second-a.second), \n\t   make_pair(o.first-a.first, o.second-a.second)) < 0) return false;\n  if(cross(make_pair(c.first-b.first, c.second-b.second), \n\t   make_pair(o.first-b.first, o.second-b.second)) < 0) return false;\n  if(cross(make_pair(a.first-c.first, a.second-c.second), \n\t   make_pair(o.first-c.first, o.second-c.second)) < 0) return false;\n  return true;\n}\n\ndouble dist(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3){\n  pair<int, int> p4 = make_pair(p2.first - p1.first, p2.second - p1.second);\n  pair<int, int> p5 = make_pair(p3.first - p1.first, p3.second - p1.second);\n  double tmp = length(p4);\n  return abs((double)cross(p4, p5) / tmp);\n}\n\nmain(){\n  while(cin >> a.first >> a.second && a.first && a.second){\n    cin >> b.first >> b.second;\n    cin >> c.first >> c.second;\n    cin >> o.first >> o.second;\n    cin >> r;\n    if(length(make_pair(a.first-o.first, a.second-o.second)) < (double)r+EPS && \n       length(make_pair(b.first-o.first, b.second-o.second)) < (double)r+EPS &&\n       length(make_pair(c.first-o.first, c.second-o.second)) < (double)r+EPS){\n      cout << \"b\" << endl;\n    }\n    else if(is_inside()){\n      if(dist(b, c, o) > (double)r-EPS && \n\t dist(a, c, o) > (double)r-EPS && \n\t dist(a, b, o) > (double)r-EPS){\n\tcout << \"a\" << endl;\n      }else{\n\tcout << \"c\" << endl;\n      }\n    }else{\n      if(length(make_pair(a.first-o.first, a.second-o.second)) < (double)r+EPS ||\n\t length(make_pair(b.first-o.first, b.second-o.second)) < (double)r+EPS ||\n\t length(make_pair(c.first-o.first, b.second-o.second)) < (double)r+EPS ||\n\t dist(b, c, o) < (double)r+EPS ||\n\t dist(a, c, o) < (double)r+EPS ||\n\t dist(a, b, o) < (double)r+EPS){\n\tcout << \"c\" << endl;\n      }else{\n\tcout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\nif(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\nreturn a+b;\n}\n\nstruct point{\ndouble x, y;\npoint(){}\npoint(double x,double y) : x(x) , y(y){}\n\npoint operator + (point p){\nreturn point(add(x,p.x), add(y,p.y));\n}\n\npoint operator - (point p){\nreturn point(add(x,-p.x), add(y,-p.y));\n}\n\npoint operator * (double d){\nreturn point(x*d,y*d);\n}\n\npoint operator / (double d){\nreturn point(x/d,y/d);\n}\n\nbool operator == ( const point &p ) const {\nreturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n}\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\nreturn sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\nif ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\nif ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\nreturn abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\nreturn sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\nreturn cross(b-a, c-a)==0.0 &&\n(dot(b-a, c-a) > -EPS) &&\n(dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\nif(cross(a1-a2,b1-b2)==0){\nreturn is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2)\n|| is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n}\nelse {\nreturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n}\n\nint crossCS(point a, point b, circle c){\ndouble res=distance_ls_p(a,b,c.p);\ndouble ac=dist(a,c.p);\ndouble bc=dist(b,c.p);\n\nif(res>c.r || (ac<c.r && bc<c.r))return 0;\nelse if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\nelse return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\npoint a,b;\na=b=p;\nb.x=DBL_MAX;\nps.push_back(ps[0]);\ndouble ymx=-DBL_MAX,ymn=DBL_MAX;\nfor(int i=0;i ymx=max(ymx,ps[i].y);\nymn=min(ymn,ps[i].y);\n}\nif(a.y<=ymn||a.y>=ymx)return 0;\n\nfor(int i=0;i<n;i++){\nif(is_point_on_line(ps[i],ps[i+1],p))return 1;\n}\n\nint cnt1=0;\nfor(int i=0;i<n;i++)\nif(is_point_on_line(a,b,ps[i]))cnt1++;\n\nint cnt=0;\nfor(int i=0;i<n;i++)\nif(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n\nreturn (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\ndouble ans=0;\nint tsz=t.size();\n\nfor(int i=0;i<tsz;i++){\ndouble tmp=dist(t[i],C.p);\nif(tmp>ans)ans=tmp;\n}\n\nif(C.r>=ans)return 2;\n\nint res1=inside(C.p,t,tsz);\ndouble res2=DBL_MAX;\n\nt.push_back(t[0]);\n\nfor(int i=0;i<tsz;i++)\nres2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\nif(res1 && C.r<=res2)return 1;\nelse if(!res1 && C.r else return 3;\n}\n\nint main(void){\npoint p;\nvector t;\ncircle C;\nstring ans=\"zabcd\";\n\nwhile(true){\nt.clear();\nfor(int i=0;i<3;i++){\ncin >> p.x >> p.y;\nif(p.x==0 && p.y==0)return 0;\nt.push_back(p);\n}\ncin >> C.p.x >> C.p.y >> C.r;\n\nint res=crossCP(t,C);\ncout << ans[res] << endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n\ndouble dot(P& a, P& b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P& a, P& b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint sign(double x){\n  if(x > EPS) return 1;\n  if(x < -EPS) return -1;\n  return 0;\n}\n\n//a -> b, a -> c\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(sign(cross(b, c)) > 0) return 1; //反時計\n  if(sign(cross(b, c)) < 0) return -1; //時計\n  if(sign(dot(b, c)) < 0) return +2; //c-a-b\n  if(norm(b) < norm(c)) return -2; //a-b-c\n  return 0; //a-c-b\n}\nbool cross(P a, P b, P c, double r){\n  double d1 = abs(c - a);\n  double d2 = abs(c - b);\n  if(d1 > d2) swap(d1, d2);\n  if(d1 < r && r < d2) return true;\n  if(ccw(a, b, c) == 0 && r < d2) return true;\n  if(ccw(a, b, c) != 1 && ccw(a, b, c) != -1) return false;\n  b -= a; c -= a;\n  double k = dot(b, c) / norm(b);\n  if(0 < k && k < 1 && abs(c - k * b) < r && r < d2) return true;\n  else return false;\n}\n\ndouble min_d(P a, P b, P c){\n  double d1 = abs(c - a);\n  double d2 = abs(c - b);\n  b -= a; c -= a;\n  double k = dot(b, c) / norm(b);\n  if(0 < k && k < 1) return abs(c - k * b);\n  else return min(d1, d2);\n}\n\n\nstring solve(P p[3], P c, double r){\n  if(ccw(p[0], p[1], p[2]) == -1) swap(p[1], p[2]);\n  double maxdist = 0, mindist = 1e18;\n  int ccw_v[3];\n  REP(i, 3){\n    maxdist = max(maxdist, abs(p[i] -  c));\n    mindist = min(mindist, min_d(p[i], p[(i + 1) % 3], c));\n    ccw_v[i] = ccw(p[i], p[(i + 1) % 3], c);\n  }\n  if(maxdist < r) return \"b\";\n  if(ccw_v[0] == ccw_v[1] && ccw_v[1] == ccw_v[2] && ccw_v[0] == 1){\n    if(mindist >= r) return \"a\";\n    else return \"c\";\n  }else{\n    if(mindist > r) return \"d\";\n    else return \"c\";\n  }\n}\n\nint main(){\n  P p[3];\n  P c; double r;\n  while(cin>>p[0].X>>p[0].Y>>p[1].X>>p[1].Y>>p[2].X>>p[2].Y>>c.X>>c.Y>>r){\n    cout<<solve(p, c, r)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-6\ntypedef complex<double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble dist(const P& a, const P& b)\n{\n\treturn sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nbool isIntoC(const P& p, const C& c)\n{\n\treturn dist(p, c.p) < c.r+EPS;\n}\n\nbool isIntoC(const L& l, const C& c)\n{\n\treturn dist(l[0], c.p) < c.r+EPS && dist(l[1], c.p) < c.r+EPS;\n}\n\nbool intersectSC(const L& l, const C& c, bool t)\n{\n\tif(isIntoC(l, c)) return false;\n\t\n\tdouble vc=dot(l[1]-l[0], c.p-l[0]);\n\tif(vc<0)\n\t{\n\t\tdouble dif=c.r-dist(l[0], c.p);\n\t\treturn dif+(t?EPS:0) > (t?0:EPS);\n\t}\n\t\n\tdouble vv=dot(l[1]-l[0], l[1]-l[0]);\n\t\n\tif(vc > vv)\n\t{\n\t\tdouble d=dist(l[1], c.p);\n\t\tdouble dif=c.r*c.r-d*d;\n\t\t\n\t\treturn dif+(t?EPS:0) > (t?0:EPS);\n\t}\n\t\n\tdouble cc=dot(c.p-l[0], c.p-l[0]);\n\tdouble dif=c.r*c.r-(cc-(vc/vv)*vc);\n\t\n\treturn dif+(t?EPS:0) > (t?0:EPS);\n}\n\nint main()\n{\n\tint x,y,r;\n\twhile(scanf(\"%d%d\", &x, &y), (x||y))\n\t{\n\t\tvector<P> tri;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\ttri.push_back(P(x,y));\n\t\t\tif(i==2) break;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t}\n\t\n\t\tscanf(\"%d%d%d\", &x,&y,&r);\n\t\tC c(P(x,y), r);\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\tif(!isIntoC(tri[i], c))\n\t\t\t{\n\t\t\t\tg=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(g) \n\t\t{\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i=0; i<tri.size(); i++)\n\t\tfor(int j=i+1; j<tri.size(); j++)\n\t\t{\n\t\t\tif(intersectSC(L(tri[i], tri[j]), c, false))\n\t\t\t{\n\t\t\t\tg=true;\n\t\t\t}\n\t\t}\n\t\tif(g)\n\t\t{\n\t\t\tputs(\"c\");\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tint cnt=0, cr[3];\n\t\tcr[0]=cross(tri[0]-tri[1], tri[0]-c.p);\n\t\tcr[1]=cross(tri[1]-tri[2], tri[1]-c.p);\n\t\tcr[2]=cross(tri[2]-tri[0], tri[2]-c.p);\n\t\t\n\t\tif(cr[0]<EPS&&cr[1]<EPS&&cr[2]<EPS||cr[0]+EPS>0&&cr[1]+EPS>0&&cr[2]+EPS>0) puts(\"a\");\n\t\telse puts(\"d\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-10\n\nusing namespace std;\n\nstruct Point \n{\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    \n\tdouble distance (const Point &o) const \n\t{\n        return sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));\n    }\n\n    Point operator+(const Point &o) const \n\t{\n        return Point(x+o.x, y+o.y);\n    }\n \n    Point operator-(const Point &o) const \n\t{\n        return Point(x-o.x, y-o.y);\n    }\n \t\n    Point operator*(const double m) const \n\t{\n   \t   return Point(x*m, y*m);\n    }\n\n    Point operator/(const double d) const \n\t{\n       return Point(x/d, y/d);\n    }\n\n    double cross(const Point &o) const \n\t{\n       return x * o.y - y * o.x;\n    }\n \n    double dot(const Point &o) const \n\t{\n        return x * o.x + y * o.y;\n    }\n \n    double atan() const \n\t{\n        return atan2(y, x);\n    }\n\n    double norm() const \n\t{\n        return sqrt(dot(*this));\n    }\n\n\tdouble area_abs(const Point &a,const Point &b) const\n\t{\n\t\tdouble t = (a.x - x) * (b.y - y);\n\t\tdouble t2 = (a.y - y) * (b.x - x);\n\t\tdouble areas = abs(t-t2);\n\t\treturn areas/2;\n\t}\n\n\t//符号付き面積\n\tdouble area(const Point &a,const Point &b)\n\t{\n\t\treturn ((a.x - x) * (b.y - y)) + ((b.x - x) * (y - a.y));\n\t}\n\t//線分abが自身の含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)\n\t\t{\n\t\t\treturn ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t\t}\n\t}\n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n\t\tif((b-a).dot(*this-a) < EPS) \n\t\t{\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS)\n\t\t{\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n\n\t//点a,b,cからなる三角形の中に自身が含まれているかどうか\n\tbool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n\t\tdouble t = (b-a).cross(*this-b);\n\t\tdouble t2 = (c-b).cross(*this-c);\n\t\tdouble t3 = (a-c).cross(*this-a);\n\t\t\n\t\tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\nint main()\n{\n\tdouble a,b;\n\twhile(cin >> a >> b)\n\t{\n\t\tif(a == 0 && b == 0) break;\n\t\t\n\t\tvector<Point> t;\n\t\tt.push_back(Point(a,b));\n\n\t\trep(i,2)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tt.push_back(Point(a,b));\n\t\t}\n\n\t\tdouble r;\n\t\tcin >> a >> b >> r;\n\t\tPoint c(a,b);\n\n\t\tint cnt = 0;\n\n\t\trep(i,3)\n\t\t{\n\t\t\tif(t[i].distance(c) >= r)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tif(cnt == 0) cout << \"b\" << endl;\n\t\telse if(cnt == 1 || cnt == 2) cout << \"c\" << endl;\n\t\telse\n\t\t{\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tif(c.distance_seg(t[0],t[1]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[1],t[2]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[2],t[0]) < r) flag = true;\n\t\t\t\n\t\t\tif(flag) cout << \"c\" << endl;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(c.hitPolygon(t[0],t[1],t[2]))\n\t\t\t\t{\n\t\t\t\t\tcout << \"a\" << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool flag2 = false;\n\n\t\t\t\t\tif(c.distance_seg(t[0],t[1]) == r + EPS) flag2 = true;\n\t\t\t\t\tif(c.distance_seg(t[1],t[2]) == r + EPS) flag2 = true;\n\t\t\t\t\tif(c.distance_seg(t[2],t[0]) == r + EPS) flag2 = true;\n\n\t\t\t\t\tif(flag2) cout << \"c\" << endl;\n\t\t\t\t\telse cout << \"d\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nstruct C {\n  P p;\n  double r;\n  C() : p(P(0,0)), r(0) {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2-s1,p-s1))/abs(s2-s1);\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2-s1, p-s1) < 0.0) return abs(p-s1);\n  if(dot(s1-s2, p-s2) < 0.0) return abs(p-s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nbool involve(const C &c, const P &s1, const P &s2) {\n  double dist = max(abs(c.p - s1), abs(c.p - s2));\n  return c.r - dist > -eps;\n}\n\nbool involve(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    double dist = getDistanceLP(a,b,c.p);\n    if(cross(b-a, c.p-a) > -eps && dist - c.r > -eps) {\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool involve(const C &c, const vector<P> &g) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(!involve(c, a, b)) return false;\n  }\n  return true;\n}\n\nbool isIntersect(const P &s1, const P &s2, const C &c) {\n  if(involve(c, s1, s2)) return false;\n  double dist = getDistanceSP(s1, s2, c.p);\n  return c.r - dist > -eps;\n}\n\nbool isIntersect(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(isIntersect(a,b,c)) return true;\n  }\n  return false;\n}\n\nint main() {\n  vector<P> g(3);\n  C c;\n  while(1) {\n    for(int i = 0; i < g.size(); ++i) {\n      cin >> g[i].real() >> g[i].imag();\n      if(g[0].real() == 0 && g[0].imag() == 0) return 0;\n    }\n    if(cross(g[1]-g[0], g[2]-g[0]) < 0) swap(g[0], g[1]);\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n    if(involve(g,c)) cout << \"a\" << endl;\n    else if(involve(c,g)) cout << \"b\" << endl;\n    else if(isIntersect(g,c)) cout << \"c\" << endl;\n    else cout << \"d\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n//      getline(ifs, str);\n        cin >> str;\n\n      if(str == \"0 0\\n\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n        str.pop_back();\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\\n\") break;\n\n\n    if(distance(&d->p[0], &c->p) <= c->radius&& distance(&d->p[1], &c->p) <= c->radius&& distance(&d->p[2], &c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) >= c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) >= c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) >= c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) <= distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) <= distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) <= distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else\n            cout << 'a' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) <= c->radius|| dist_line(&d->p[0], &d->p[2], &c->p) <= c->radius|| dist_line(&d->p[1], &d->p[2], &c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\n// OÏ\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\n// àÏ\ndouble dot(P a, P b)\n{\treturn a.real() * b.real() + a.imag() * b.imag();\t}\n\n// _ÆüªÌ£\ndouble dist(P a, P b, P c)\n{\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\t\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nbool LineCrossCircle(P a, P b, P c, double r)\n{\n\treturn dist(a, b, c) <= r && (r < abs(a - c) || r < abs(b - c));\n}\n\nbool CircleInTriangle(P p[3], P c, double r)\n{\n\trep(i, 3) if(dist(p[i], p[(i + 1) % 3], c) <= r) return false;\n\t\n\tdouble S = abs(cross(p[0] - p[2], p[1] - p[2]));\n\t\n\trep(i, 3) S -= abs(cross(p[(i + 1) % 3] - p[i], c - p[i]));\n\t\n\treturn abs(S) < EPS;\n}\n\nbool TriangleInCircle(P p[3], P c, double r)\n{\n\trep(i, 3) if(r < abs(p[i] - c)) return false;\n\t\n\treturn true;\n}\n\nbool TriangleCrossCircle(P p[3], P c, double r)\n{\n\trep(i, 3) if(LineCrossCircle(p[i], p[(i + 1) % 3], c, r)) return true;\t\n\t\n\treturn false;\n}\n\nint main()\n{\n    P p[3], c;\n\tdouble r;\n\t\n\twhile(cin >> p[0].real() >> p[0].imag() && (p[0].real() || p[0].imag()))\n\t{\n\t\trep(i, 2) cin >> p[i + 1].real() >> p[i + 1].imag();\n\t\t\n\t\tcin >> c.real() >> c.imag() >> r;\n\t\t\n\t\tif(CircleInTriangle(p, c, r))\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse if(TriangleInCircle(p, c, r))\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if(TriangleCrossCircle(p, c, r))\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Point{ int x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Point c; int r; };\n\ninline double dist(const Point &p1, const Point &p2){\n\treturn sqrt( pow(p2.x-p1.x,2.0)+pow(p2.y-p1.y,2.0) );\n}\ndouble dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble b = 1;\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + b * p.y + c ) / sqrt( pow(a,2.0)+pow(b,2.0) );\n\t}\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) > 0;\n}\n\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( !isLeft( t.a, t.b, p ) )\n\t\treturn false;\n\tif( !isLeft( t.b, t.c, p ) )\n\t\treturn false;\n\tif( !isLeft( t.c, t.a, p ) )\n\t\treturn false;\n\n\treturn true;\n}\n\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r < dist( t.a, t.b, c.c ) &&\n\t\t\tc.r < dist( t.b, t.c, c.c ) &&\n\t\t\tc.r < dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) < c.r &&\n\t  dist( t.b, c.c ) < c.r &&\n\t  dist( t.c, c.c ) < c.r )\n\t  return true;\n  else\n\t  return false;\n}\n\nbool isCross(const Point &p1, const Point &p2, const Circle &c)\n{\n\tif( dist( p1, p2, c.c ) > c.r )\n\t\treturn false;\n\telse{\n\t\tdouble l = dist( p1, p2 );\n\t\tif( ( dist(p1,c.c) > c.r && dist(p2,c.c) > c.r+l ) ||\n\t\t\t( dist(p2,c.c) > c.r && dist(p1,c.c) > c.r+l ) )\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( !isCross(t.a,t.b,c) && !isCross(t.b,t.c,c) && !isCross(t.c,t.a,c) )\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t, c ) )\n\t\treturn 'b';\n\tif( !isCross( t,c ) )\n\t\treturn 'd';\n\telse\n\t\treturn 'c';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P p;double r;};    //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(L a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//??´?????¨??´????????¢??? verified AOJ CGL_2\nint rLL(L a,L b){\n    if( cross(vec(a),vec(b))==0 ) return 2; //??????\n    if( dot(vec(a),vec(b))==0 )   return 1; //?????´\n    return 0;\n}\n\n// ?????¨??????????????????\nint contains(C c, P p){\n    double d = (c.p-p).abs();\n    if(d-c.r>EPS) return OUT;\n    if(abs(d-c.r)<EPS) return ON;\n    return IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n    if( dLP(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(L s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, L l){\n    int c1 = contains(c, l.p1);\n    int c2 = contains(c, l.p2);\n    if(c1 > c2) swap(c1, c2);\n    \n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (??\\????????¨???)\n    double d = dSP(l, c.p);\n    if(d-c.r<-EPS) return true;\n    if(d-c.r>EPS) return false;\n    return true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n    int c=0;\n    rep(i,pol.size()){\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n    }\n    if( c%pol.size() )return OUT;\n    return IN;\n}\n\n//?????¨???????§???¢???????????¶???????????????\nint CPOLarea(C c ,Polygon pol){\n    vector<L> lines;\n    vector<int> res(pol.size());\n    bool POLinC=true;\n    \n    rep(i,pol.size()){\n        res[i] = contains(c,pol[i]);\n        lines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n    }\n    rep(i,res.size()) if( res[i]!=IN )POLinC=false;\n    \n    rep(i,lines.size()) if( iCS(c,lines[i]) )   return 1;   //????§???¢??¨????????????\n    if( POLinC )                                return 2;   //????§???¢??????????????¨\n    if( isPointInsidePolygon(pol, c.p)==IN )    return 3;   //????§???¢????????¨??????\n    return 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps),cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????´???????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b&&(a||b)){\n        Polygon pol(3);\n        pol[0] = P(a,b);\n        rep(i,2)cin>>pol[i+1].x>>pol[i+1].y;\n        C c;\n        cin>>c.p.x>>c.p.y>>c.r;\n        int res =  CPOLarea(c,pol);\n        \n        cout<<(char)('a'+(3-res))<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point& a, const Point& b) { return Point{ a.px - b.px,a.py - b.py }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dst(const Point& a, const Point& b) { return abs(Minus(b , a)); }\nlong double dst(const Line& a, const Point& b) { return abs(crs(Minus(a.p2, a.p1), Minus(b, a.p1)) / abs(Minus(a.p2, a.p1))); }\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\twhile (true) {\n\t\tPoint r1, r2, r3, r4; long double r;\n\t\tcin >> r1.px >> r1.py; if (fabs(r1.px) <= 1e-10 && fabs(r1.py) <= 1e-10)break;\n\t\tcin >> r2.px >> r2.py >> r3.px >> r3.py >> r4.px >> r4.py >> r;\n\t\tLine l1 = Line{ r1,r2 }, l2 = { r2,r3 }, l3 = { r3,r1 };\n\t\tlong double c1 = min(dst(l1, r4), min(dst(l2, r4), dst(l3, r4)));\n\t\tlong double c2 = max(dst(r1, r4), max(dst(r2, r4), dst(r3, r4)));\n\t\tlong double c3 = min(dst(r1, r4), min(dst(r2, r4), dst(r3, r4)));\n\t\tint c4 = contain({ r1,r2,r3 }, r4);\n\t\tif (c1 >= r && c4 != 0) { cout << \"a\" << endl; }\n\t\telse if (c2 <= r) { cout << \"b\" << endl; }\n\t\telse if (c3 <= r) { cout << \"c\" << endl; }\n\t\telse { cout << \"d\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-6;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + Point((v1.dot(v2) / v2.norm()), 1.0) * v2);\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) == ABOVE) ++ccw;\n        if(e.ccw(circle.center()) == UNDER) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3, p; long double r; Segment l1, l2, l3;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> p.px >> p.py >> r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, p) <= r + 1e-10 && dst(p2, p) <= r + 1e-10 && dst(p3, p) <= r + 1e-10) printf(\"b\\n\");\n\t\telse if(dst(l1, p) >= r - 1e-10 && dst(l2, p) >= r - 1e-10 && dst(l3, p) >= r - 1e-10) printf(contain({p1, p2, p3}, p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define EPS 1E-5\n#define SAME_SIGN( a , b ) a * b > EPS\n\nnamespace geometry{\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius + EPS ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.b , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.c , cir.center ) <= cir.radius\n\t\t){\n\t\t\tstd::cout << 'b' << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << 'a' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << 'd' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << 'c' << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << 'c' << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <vector>\n\nusing namespace std;\n\n//-------------------------------------------------------------------------\n// geometric library\n \nnamespace geometry {\n \n#define EPS 1E-10 ///< 0とみなすサイズ。適当\n \n    struct point {\n        double x;\n        double y;\n \n\t\tpoint() {}\n\t\tpoint(double x, double y) : x(x), y(y) {}\n        point& operator += (const point& rhs) { x += rhs.x; y += rhs.y; return *this; }\n        point& operator -= (const point& rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n        point& operator /= (double factor) { x /= factor; y /= factor; return *this; }\n        point& operator *= (double factor) { x *= factor; y *= factor; return *this; }\n        bool operator == (const point& rhs) const { return (std::abs(x - rhs.x) < EPS) && (std::abs(y - rhs.y) < EPS); }\n        bool operator != (const point& rhs) const { return !(*this == rhs); }\n        bool operator <= (const point& rhs) const { return x < rhs.x || (x == rhs.x && y <= rhs.y); }\n        bool operator >= (const point& rhs) const { return x > rhs.x || (x == rhs.x && y >= rhs.y); }\n        bool operator < (const point& rhs) const { return !(*this >= rhs); }\n        bool operator > (const point& rhs) const { return !(*this <= rhs); }\n\t\tdouble arg() const { return atan2(y, x); }\n        double norm() const { return sqrt(x * x + y * y); }\n\t\tpoint get_normal() const { return point(-y, x); }\n    };\n\ttypedef point vec2d;\n \n    struct circle {\n        point center;\n        double radius;\n\t\tcircle() {}\n\t\tcircle(double x, double y, double r) : center(x, y), radius(r) {}\n    };\n \n\tstruct triangle {\n\t\tpoint p[3];\n\t};\n \n    enum rotate_dir {\n        rotate_None = 0,\n        rotate_CW = 1,\n        rotate_CCW = -1\n    };\n \n    point operator + (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p += p2;\n        return p;\n    }\n \n    point operator / (const point& p1, double factor)\n    {\n        point p(p1);\n        p /= factor;\n        return p;\n    }\n  \n    point operator * (const point& p1, double factor)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator * (double factor, const point& p1)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator - (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p -= p2;\n        return p;\n    }\n \n    std::istream& operator >> (std::istream& is, point& p)\n    {\n        is >> p.x >> p.y;\n        return is;\n    }\n\n    std::istream& operator >> (std::istream& is, circle& c)\n    {\n        is >> c.center >> c.radius;\n        return is;\n    }\n\n    ///! 2点の距離\n    double get_distance(const point& p1, const point& p2)\n    {\n        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    }\n \n    double cross_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.y - p2.x * p1.y;\n    }\n \n    double inner_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n\t///! 直線s-eにpを投影した点を求める\n\tpoint get_project(const point& s, const point& e, const point& p)\n\t{\n\t\tdouble scale = inner_product(p - s, e - s) / (e - s).norm();\n\t\treturn s + scale * (e - s) / (e - s).norm();\n\t}\n\n     ///! pがs-e間(s,e上含む)にあればtrue\n    bool is_inter_point(const point& s, const point& e, const point& p) {\n        double d = get_distance(s, p) + get_distance(p, e) - get_distance(s, e);\n        return abs(d) < EPS;\n    }\n \n    ///! p1-p2-p3が左右どちらの方向に折れているかを判定\n    rotate_dir direction(const point& p1, const point& p2, const point& p3)\n    {\n        point p1_p3 = p1 - p3;\n        point p2_p3 = p2 - p3;\n        double cross = cross_product(p1_p3, p2_p3);\n \n        if (std::abs(cross) < EPS) {\n            return rotate_None;\n        }\n        else if (cross > 0) {\n            return rotate_CW;\n        }\n        else {\n            return rotate_CCW;\n        }\n    }\n\n\tbool is_inside_circle(const point& p, const circle& c)\n\t{\n\t\treturn get_distance(p, c.center) <= c.radius + EPS;\n\t}\n\n\tbool is_inside_circle(const triangle& t, const circle& c)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (!is_inside_circle(t.p[i], c)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n \n    // (p1s, p1e)と(p2s, p2e)の線分交差判定.EPS以下で接している場合はtrue、重なっている場合はfalse\n    bool intersect(const point& p1s, const point& p1e, const point& p2s, const point& p2e)\n    {\n        assert(p1s != p1e && p2s != p2e);\n        return\n            (direction(p1s, p1e, p2s) != direction(p1s, p1e, p2e)) &&\n            (direction(p2s, p2e, p1s) != direction(p2s, p2e, p1e));\n    }\n\n\t// 円と三角形が交差するかどうか\n\tbool intersect(const circle& c, const triangle& t)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tpoint ps = t.p[i], pe = t.p [(i + 1) % 3];\n\n\t\t\tif (is_inside_circle(ps, c) != is_inside_circle(pe, c)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (is_inside_circle(ps, c) && is_inside_circle(pe, c)) {\n\t\t\t\tcontinue; // この辺は交差しない\n\t\t\t}\n\t\t\tpoint m = get_project(ps, pe, c.center);\n\n\t\t\tif (get_distance(m, c.center) <= c.radius + EPS && is_inter_point(ps, pe, m)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} \n\n    // targetが三角形p1,p2,p3の内部にあるかどうか\n    bool is_inside_triangle(const point& target, const point& p1, const point& p2, const point& p3)\n    {\n        point center_of_gravity = (p1 + p2 + p3) / 3; // 重心\n \n        if (center_of_gravity == target) return true;\n \n        // 重心とtargetを結んだ線分が三角形の辺と交叉するなら、点は三角形の外部にある\n        bool intersect_any =\n            intersect(p1, p2, center_of_gravity, target) ||\n            intersect(p2, p3, center_of_gravity, target) ||\n            intersect(p3, p1, center_of_gravity, target);\n \n        return !intersect_any;\n    }\n\n\tbool is_inside_triangle(const point& target, const triangle& t)\n\t{\n\t\treturn is_inside_triangle(target, t.p[0], t.p[1], t.p[2]);\n\t}\n \n\tbool is_inside_triangle(const circle& c, const triangle& t)\n\t{\n\t\tif (is_inside_triangle(c.center, t) && !intersect(c, t) && !is_inside_circle(t, c)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n \n} // namespace geometry\n\n\n//-----------------------------------------------\n//\n\nusing namespace geometry;\n\nint main(void) {\n\ttriangle triangle;\n\tcircle circle;\n\tint n = 1;\n\n\twhile (cin >> triangle.p[0]) {\n\t\tif (triangle.p[0].x == 0 && triangle.p[0].y == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> triangle.p[1] >> triangle.p [2] >> circle;\n\n\t\tif (is_inside_triangle(circle, triangle)) {\n\t\t\tcout << \"a\" << endl;\n\t\t} else if (is_inside_circle(triangle, circle)) {\n\t\t\tcout << \"b\" << endl;\n\t\t} else if (intersect(circle, triangle)) {\n\t\t\tcout << \"c\" << endl;\n\t\t} else {\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t\tn++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#include<string>\n  \n#define EPS 1E-10\n#define SAME_SIGN( a , b ) ( a * b > EPS ) // a, bのいずれもプラスか、あるいはいずれもマイナスの場合にtrue\n \nenum state {\n    OVERLAP,\n    JUST,\n    NONE,\n};\n  \nnamespace geometry{\n  \n    struct point{\n        double x;\n        double y;\n        point(){}\n        point( double x , double y ):x(x),y(y){}\n        point& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n        point& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n        point& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n        point& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n        bool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n        bool operator != ( const point& p ) const { return !(*this == p); }\n        double norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n    };\n  \n    typedef point vector2d;\n  \n    struct circle{\n        point center;\n        double radius;\n    };\n  \n    struct triangle{\n        point a;\n        point b;\n        point c;\n    };\n  \n    point operator + ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p += p2;\n            return p;\n        }\n        point operator - ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p -= p2;\n            return p;\n        }\n        point operator * ( const point& p1 , double factor ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator * ( double factor , const point& p1 ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator / ( const point& p1 , double factor ){\n            point p(p1);\n            p /= factor;\n            return p;\n        }\n  \n    std::istream& operator >> ( std::istream& s , point& p )\n    {\n        return s >> p.x >> p.y;\n    }\n  \n    double get_distance( const point& p1 , const point& p2 )\n    {\n        return sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n    }\n  \n    double get_dot_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.x + oa.y * ob.y;\n    }\n  \n    double get_cross_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.y - oa.y * ob.x;\n    }\n  \n    point get_project( const point& s , const point& e , const point& p ){\n        double scale = get_dot_product( p , e , s ) / ( e - s ).norm();\n        return s + scale * ( e - s ) / ( e - s ).norm();\n    }\n  \n    bool is_inter_point( const point& s , const point& e , const point& p ){\n        return std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n    }\n}\n  \nusing namespace geometry;\n  \nbool input_data( triangle& tri , circle& cir )\n{\n    std::cin >> tri.a;\n    if( tri.a.x == 0 && tri.a.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.b;\n    if( tri.b.x == 0 && tri.b.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.c;\n    if( tri.c.x == 0 && tri.c.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.center;\n    if( cir.center.x == 0 && cir.center.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.radius;\n    return true;\n}\n  \nstate is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n    if( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n        if( fabs(get_distance( get_project(p1 , p2 , cir.center ) , cir.center ) - cir.radius) < EPS ){\n            return JUST;\n        }\n        if( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) < cir.radius ){\n            return OVERLAP;\n        }\n        else{\n            return NONE;\n        }\n    }\n    else{\n        return NONE;\n    }\n}\n  \nstate is_overlap( triangle& tri , circle& cir )\n{\n    if( is_overlap_for_one_side( tri.a , tri.b , cir ) == OVERLAP || \n        is_overlap_for_one_side( tri.b , tri.c , cir ) == OVERLAP ||\n        is_overlap_for_one_side( tri.c , tri.a , cir ) == OVERLAP) {\n        return OVERLAP;\n    }\n    else if( is_overlap_for_one_side( tri.a , tri.b , cir ) == NONE && \n             is_overlap_for_one_side( tri.b , tri.c , cir ) == NONE &&\n             is_overlap_for_one_side( tri.c , tri.a , cir ) == NONE){\n        return NONE;\n    }\n    else if(is_overlap_for_one_side( tri.a , tri.b , cir ) == JUST || \n            is_overlap_for_one_side( tri.b , tri.c , cir ) == JUST ||\n            is_overlap_for_one_side( tri.c , tri.a , cir ) == JUST){\n        return JUST;\n    }\n    else{\n        std::cout << \"error\" << std::endl;\n    }\n  \n}\n \nstd::string get_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n    if( get_distance( tri.a , cir.center ) <= cir.radius  &&\n        get_distance( tri.b , cir.center ) <= cir.radius  &&\n        get_distance( tri.c , cir.center ) <= cir.radius\n        ){\n           return \"b\";\n\t}\n    if( get_distance( tri.a , cir.center ) > cir.radius  &&\n        get_distance( tri.b , cir.center ) > cir.radius  &&\n        get_distance( tri.c , cir.center ) > cir.radius\n        ){\n            if( is_overlap( tri , cir ) == NONE ){\n                if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                    SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                    ){\n                        return \"a\";\n                }\n                else{\n                    return \"d\";\n                }\n            }\n            else if( is_overlap( tri , cir ) == JUST ){\n                if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                    SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                    ){\n                        return \"a\";\n                }\n                else{\n                    return \"c\";\n                }\n            }\n            else if( is_overlap( tri , cir ) == OVERLAP ){\n                return \"c\";\n            }\n            else{\n                std::cout << \"error\" << std::endl;\n            }\n    }\n    else{\n        return \"c\";\n    }\n}\n \nstruct TEST_CASE {\n    triangle tri;\n    circle cir;\n    std::string ans;\n \n    void SetTestCase( int ax, int ay, int bx, int by, int cx, int cy, int ox, int oy, int r, std::string ans )\n    {\n        this->tri.a.x = ax;\n        this->tri.a.y = ay;\n        this->tri.b.x = bx;\n        this->tri.b.y = by;\n        this->tri.c.x = cx;\n        this->tri.c.y = cy;\n        this->cir.center.x = ox;\n        this->cir.center.y = oy;\n        this->cir.radius = r;\n        this->ans = ans;\n    }\n};\n \nvoid test(void)\n{\n    TEST_CASE testCase[100];\n \n    testCase[0].SetTestCase(10, 20, 1, 5, 19, 5, 10, 10, 3, \"a\");\n    testCase[1].SetTestCase(10, 12, 12, 9, 8, 9, 10, 10, 3, \"b\");\n    testCase[2].SetTestCase(10, 12, 12, 9, 7, 10, 10, 10, 3, \"b\");\n    testCase[3].SetTestCase(20, 5, 40, 20, 40, 5, 20, 20, 12, \"c\");\n    testCase[4].SetTestCase(20, 5, 41, 20, 40, 5, 20, 20, 12, \"d\");\n    testCase[5].SetTestCase(10, 13, 10, 16, 7, 13, 10, 10, 3, \"c\");\n    testCase[6].SetTestCase(2000, 500, 4000, 2000, 4000, 500, 2000, 2000, 1200, \"c\");\n    testCase[7].SetTestCase(2000, 500, 4001, 2000, 4000, 500, 2000, 2000, 1200, \"d\");\n    testCase[8].SetTestCase(2000, 500, 3999, 2000, 4000, 500, 2000, 2000, 1200, \"c\");\n    testCase[9].SetTestCase(1000, 2000, 100, 500, 1900, 500, 1000, 1000, 300, \"a\");\n    testCase[10].SetTestCase(1000, 1200, 1200, 900, 800, 900, 1000, 1000, 300, \"b\");\n    testCase[11].SetTestCase(1000, 1200, 1200, 900, 700, 1000, 1000, 1000, 300, \"b\");\n    testCase[12].SetTestCase(1000, 1300, 1000, 1600, 700, 1300, 1000, 1000, 300, \"c\");\n    testCase[13].SetTestCase(1, 4999, 9999, 4999, 5000, 9000, 5000, 5000, 1, \"a\");\n    testCase[14].SetTestCase(1, 4999, 9999, 4999, 5000, 9000, 5000, 5001, 1, \"a\");\n    testCase[15].SetTestCase(1, 4999, 9999, 5001, 5000, 9000, 5000, 5001, 1, \"c\");\n \n    for( int i = 0 ; i < 16 ; i++ )\n    {\n        std::cout << \"testCase[\" << i << \"] : \";\n        if( testCase[i].ans == get_positional_relation_of_circle_and_triangle(testCase[i].tri, testCase[i].cir) ){\n            std::cout << \"OK\" << std::endl;\n        }\n        else{\n            std::cout << \"NG\" << std::endl;\n        }\n    }\n}\n  \nint main(void)\n{\n    triangle tri;\n    circle cir;\n  \n    // test();\n \n    while(input_data(tri, cir)){\n        std::cout << get_positional_relation_of_circle_and_triangle( tri , cir ) << std::endl;\n    }\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-7\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0,double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n  Point operator * (double a){ return Point(x*a, y*a); }\n  Point operator / (double a){ return Point(x/a, y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nclass Segment{\npublic:\n  Vector t,s;\n  Segment(Vector t,Vector s) : t(t),s(s) {}\n  Point projection(Point &p){\n    Vector b = s - t;\n    double d = dot(p-t,b) / b.norm();\n    return t + b*d;\n  }\n};\n\nclass Circle{\npublic:\n  double x,y,r;\n  Circle(double x = 0.0,double y = 0.0,double r = 0.0) : x(x),y(y),r(r) {}\n};\n\nPoint point[3];\nCircle ci;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nbool check(){\n  int c1 = abs(ccw(point[0],point[1],ci.r));\n  int c2 = abs(ccw(point[1],point[2],ci.r));\n  int c3 = abs(ccw(point[2],point[0],ci.r));\n  if(c1 == c2 && c2 == c3) return true;\n  return false;\n}\n\ntypedef Segment Line;\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.s-l.t,p-l.t)/(l.s-l.t).abs());\n}\n\ndouble getDistanceSP(Segment seg,Point p){\n  if(dot(seg.s-seg.t,p-seg.t) < 0.0) return (p-seg.t).abs();\n  if(dot(seg.t-seg.s,p-seg.s) < 0.0) return (p-seg.s).abs(); \n  return getDistanceLP(seg,p);\n}\n\nint getStateCS(Circle c,Segment seg){\n  Point cp = Point(c.x,c.y);\n  Point p = seg.projection(cp);\n  Point pp = p - cp;\n  Vector a = seg.t - cp;\n  Vector b = seg.s - cp;\n    \n  if(a.abs() > c.r && b.abs() > c.r){\n    if(pp.abs()+EPS > c.r && ccw(seg.t,seg.s,p)==0){\n      return 1;\n    }\n  }else if(a.abs() < c.r && b.abs() < c.r){\n    if(pp.abs()-EPS < c.r && ccw(seg.t,seg.s,p)==0){\n      return 2;\n    }\n  }\n  return 3;\n}\n\nbool isCross(){\n  Point cp = Point(ci.x,ci.y);\n  for(int i = 0 ; i < 3 ; i++){\n    Point p = point[i];\n    Point diff = p - cp;\n    if(diff.abs() == ci.r) return true;\n  }\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  \n  for(int i = 0 ; i < 3 ; i++){\n    if(getDistanceSP(seg[i],cp) < ci.r){\n      return true;\n    }\n  }\n\n  for(int i = 0 ; i < 3 ; i++){\n    Segment ns = seg[i];\n    Point p1 = ns.t, p2 = ns.s;\n    if(p1.abs() < ci.r && p2.abs() > ci.r) return true;\n    if(p1.abs() > ci.r && p2.abs() < ci.r) return true;\n  }\n\n  return false;\n}\n\nvoid judge(){\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n\n  int TinC = 0,CinT = 0;\n  for(int i = 0 ; i < 3 ; i++){\n    int N = getStateCS(ci,seg[i]);\n    if(N == 1){\n      TinC++;\n    }else if(N == 2){\n      CinT++;\n    }\n  }\n\n  if(TinC == 3 && check()){\n    cout << 'a' << endl;\n  }else if(CinT == 3){\n    cout << 'b' << endl;\n  }else{\n    if(isCross()){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}\n\nint main(){\n  while(true){\n    cin >> point[0].x >> point[0].y;\n    if(!point[0].x && !point[0].y) break;\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> point[i+1].x >> point[i+1].y;\n    }\n    cin >> ci.x >> ci.y >> ci.r;\n    judge();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n\nconst double EPS=1e-9;\nconst double INFTY=1e12;\ntypedef complex<double> Point;\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x>0?1:-1;\n}\n\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tint sign=Signum(Cross(d1,d2));\n\t\n\tif(sign)\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\n// ツ点ツづ陳シツ静シツづ個仰猟猟」\ndouble DistancePL(Point p,Line l)\n{\n\treturn abs(Cross(p-l.pos,l.dir))/abs(l.dir);\n}\n// ツ点ツづ静シツ閉ェツづ個仰猟猟」\ndouble DistancePS(Point p,Line s)\n{\n\tPoint a=p-s.pos,b=s.dir;\n\tPoint c=b*Dot(a,b)/norm(b);\n\tdouble pos=abs(c)/abs(b);\n\tif(-EPS<pos && pos<1+EPS)\n\t\treturn abs(a-c);\n\telse\n\t\treturn min(abs(a),abs(b-a));\n}\n\nvoid solve(Point p[],Point c,double r)\n{\n\t{\t// triangle in circle\n\t\tdouble dist=0;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=max(dist,norm(p[i]-c));\n\t\tif(dist<=r*r){\n\t\t\tputs(\"b\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t{\t// circle in triangle\n\t\tbool res=true;\n\t\tint ccw=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint temp=CCW(p[i],p[(i+1)%3],c);\n\t\t\tif(temp==-2 || temp==2)\n\t\t\t\tcontinue;\n\t\t\tres&=temp*ccw>=0;\n\t\t\tccw=temp;\n\t\t}\n\t\tif(res){\n\t\t\tdouble dist=INFTY;\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tdist=min(dist,DistancePL(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\t\tif(Signum(dist-r)>=0){\n\t\t\t\tputs(\"a\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t{\t// intersect\n\t\tdouble dist=INFTY;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=min(dist,DistancePS(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\tif(Signum(dist-r)<=0){\n\t\t\tputs(\"c\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tputs(\"d\");\n}\n\nint main()\n{\n\tfor(;;){\n\t\tPoint p[3],c;\n\t\tdouble r;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tcin>>real(p[i])>>imag(p[i]);\n\t\tcin>>real(c)>>imag(c)>>r;\n\t\tif(norm(p[0])==0)\n\t\t\tbreak;\n\t\t\n\t\t//for(int i=0;i<3;i++)\n\t\t//\tprintf(\"(%.3f,%.3f) \",real(p[i]),imag(p[i]));\n\t\t//printf(\"(%.3f,%.3f,%.3f)\\n\",real(c),imag(c),r);\n\t\t\n\t\tsolve(p,c,r);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define F first\n#define S second\n\n#define X real()\n#define Y imag()\n\n#define EPS (1e-7)\n\ntypedef complex<double> Point;\ntypedef pair<double, Point> Circle;\n\nbool isPointInCircle(Point p, Circle c) {\n  if(abs(p-c.S) < abs(c.F)) return true;\n  return false;\n}\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n\ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n  \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n\nint main() {\n  \n  while(1) {\n    Point points[3];\n    Circle circle;\n  \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n    \n      points[i] = Point(x, y);\n    }\n  \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n  \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n    \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3) {\n      int flg = 0;\n      for(int i=0; i<3; i++) {\n        if(dot(points[(i+1)%3]-points[i], circle.S-points[i]) * dot(points[(i+2)%3]-points[(i+1)%3], circle.S-points[(i+1)%3]) > 0) {\n          flg ++;\n        }\n      }\n      if(flg == 3) { cout << 'a' << endl; continue; }\n    }\n\n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) + EPS < circle.F;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-10;\n\nclass Vector2\n{\npublic:\n\tdouble length() const\n\t{\n\t\treturn sqrt( static_cast<double>( x * x + y * y ) );\n\t}\n\tint clossProduct( const Vector2& v ) const\n\t{\n\t\treturn this->x * v.y - this->y * v.x;\n\t}\n\tVector2 operator-( const Vector2& v ) const\n\t{\n\t\tVector2 ret;\n\t\tret.x = this->x - v.x;\n\t\tret.y = this->y - v.y;\n\t\treturn ret;\n\t}\n\n\tint x, y;\n};\n\nint main()\n{\n\tVector2 tri[ 3 ];\n\tVector2 cir;\n\tint cirR;\n\n\twhile( cin >> tri[ 0 ].x >> tri[ 0 ].y && !( !tri[ 0 ].x && !tri[ 0 ].y ) ){\n\t\tfor( int i = 1; i < 3; ++i ){\n\t\t\tcin >> tri[ i ].x >> tri[ i ].y;\n\t\t}\n\t\tcin >> cir.x >> cir.y;\n\t\tcin >> cirR;\n\n\t\tint flags = 0;\n\t\tint tangency = false;\n\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\tVector2 ao = cir - tri[ i ];\n\t\t\tVector2 ab = tri[ ( i + 1 ) % 3 ] - tri[ i ];\n\t\t\tdouble distance = abs( ab.clossProduct( ao ) ) / ab.length();\n\t\t\tif( distance - cirR >= EPS ){\n\t\t\t\tflags |= ( 1 << i );\n\t\t\t}\n\t\t\tif( fabs( distance - cirR ) <= EPS ){\n\t\t\t\ttangency = true;\n\t\t\t}\n\t\t}\n\n\t\tchar result;\n\t\tif( flags == 7 ){\n\t\t\tint dir = 0;\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tVector2 oa = tri[ i ] - cir;\n\t\t\t\tVector2 ob = tri[ ( i + 1 ) % 3 ] - cir;\n\t\t\t\tif( oa.x * ob.y > oa.y * ob.x ){\n\t\t\t\t\tdir |= ( 1 << i );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dir % 7 == 0 ){\n\t\t\t\tresult = 'a';\n\t\t\t}else{\n\t\t\t\tif( tangency ){\n\t\t\t\t\tresult = 'c';\n\t\t\t\t}else{\n\t\t\t\t\tresult = 'd';\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( flags == 0 ){\n\t\t\tint dir = 0;\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tVector2 oa = tri[ i ] - cir;\n\t\t\t\tif( cirR - oa.length() >= EPS ){\n\t\t\t\t\tdir |= ( 1 << i );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dir == 7 ){\n\t\t\t\tresult = 'b';\n\t\t\t}else{\n\t\t\t\tresult = 'c';\n\t\t\t}\n\t\t}else{\n\t\t\tresult = 'c';\n\t\t}\n\n\t\tcout << result << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n    if(rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS * len) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\n//多角形の面積\ntemplate<class T>\nT area(const vector<point<T> >& v){\n\tT ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S,const point<T> &p){ return sqrt(dist2(S,p)); }\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ntemplate<class T>\ndouble geodist(point<T> a,point<T> b,const circle<T> &C){\n\tdouble r=C.r;\n\tsegment<T> s(a,b);\n\tif(dist(s,C.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=C.c;\n\tb-=C.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntemplate<class T>\nstd::istream& operator>>(std::istream& is, point<T>& point){return ( is >> point.x >> point.y );}\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n\n//円の接点\nvector<P> GetContact(const P& p,const P& q,const double r){\n\tP a = p-q;\n\tdouble s = SQ(a.x) + SQ(a.y);\n\tdouble D = sqrt(s - SQ(r));\n\tdouble dx = r * D * a.y / s;\n\tdouble dy = r * D * a.x / s;\n\tdouble bx = SQ(r) * a.x / s;\n\tdouble by = SQ(r) * a.y / s;\n\tvector<P> ans(2);\n\tans[0].x = bx + dx;\n\tans[0].y = by - dy;\n\tans[1].x = bx - dx;\n\tans[1].y = by + dy;\n\n\tans[0] += q;\n\tans[1] += q;\n\n\treturn ans;\n}\n\n//todo : verifyしてないので、そのうち。\n// 円が交差しているか 「=」は問によって変更する\ntemplate<class T>\nint CircleCross(const circle<T> &c1,const circle<T> &c2){\n\tdouble l = abs(c1.c - c2.c);\n\tif(l >= c1.r + c2.r) return 3; //外部にある\n\tif(l + c1.r <= c2.r) return 2; //c1 ⊃ c2\n\tif(l + c2.r <= c1.r) return 1; //c1 ⊂ c2\n\treturn 0; //交差している\n}\n\n\ntypedef pair<P,P> PD;\n//円同士の交点\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\n\n//三角形の中にあるか\nbool InTri(const P p[3],const P& o){\n\treturn \n\t\t(ccw(p[0],p[1],p[2]) * ccw(p[0],p[1],o) >= 0) &&\n\t\t(ccw(p[1],p[2],p[0]) * ccw(p[1],p[2],o) >= 0) &&\n\t\t(ccw(p[2],p[0],p[1]) * ccw(p[2],p[0],o) >= 0);\n}\n\n\nint main(){\n\tP p[3];\n\tC c;\n\twhile(cin>>p[0],p[0].x != 0 || p[0].y != 0){\n\t\tcin>>p[1]>>p[2];\n\t\tcin>>c.c>>c.r;\n\t\tbool ok = true;\n\t\tFOR(i,3){\n\t\t\tif(abs(p[i]-c.c) > c.r) ok = false;\n\t\t}\n\n\t\t//in-circle\n\t\tif(ok){ puts(\"b\"); continue; }\n\n\t\tFOR(i,3){\n\t\t\tdouble l = dist(S(p[i],p[(i+1)%3]),c.c);\n\t\t\tif(l < c.r) ok = true;\n\t\t}\n\n\t\t//intersect\n\t\tif(ok){ puts(\"c\"); continue; }\n\n\t\tif(InTri(p,c.c))\n\t\t\tputs(\"a\"); //in-triangle\n\t\telse\n\t\t\tputs(\"d\"); //otherwise\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{ point a,b; };\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && vec_abs(seg[i].b-seg[j].a)<=EPS){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint crossCP(point* ps, circle C, int sz){\n\n  double ans=0;\n\n  for(int i=0;i<sz;i++){\n    double tmp=dist(ps[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  vector<segment>t=construct_edge(ps,sz);\n\n  int tsz=t.size();\n  int res1=point_contain(t,C.p,tsz);\n\n  double res2=100000000;\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(p,C,3);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst double eps = 1e-8;\nint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\ndouble distDbl(double ax, double ay, double bx, double by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\nint distDbl(int ax, int ay, int bx, int by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\ndouble getPerpDistDbl(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, res;\n    if (ax == bx) {\n        res = (cx - ax) * (cx - ax);\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        res = (a * cx - cy + b) * (a * cx - cy + b) / (1 + a * a);\n    }\n    return res;\n}\n\ndouble getPerpDistSegDbl(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, x, y, res;\n    if (ax == bx) {\n        y = cy;\n        if (min(ay, by) <= y && y <= max(ay,by)) {\n            res = (cx - ax) * (cx - ax);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        x = (cx + a * (cy - b)) / (1 + a * a);\n        y = a * x + b;\n        if (min(ax, bx) <= x && x <= max(ax,bx) &&\n            min(ay, by) <= y && y <= max(ay,by)) {\n            res = distDbl(x,y,cx,cy);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    }\n    return res;\n}\n\nbool isA() {\n    int c = 0;\n    if (0 <= (x2-x1)*(y4-y1)-(y2-y1)*(x4-x1)) ++c;\n    if (0 <= (x3-x2)*(y4-y2)-(y3-y2)*(x4-x2)) ++c;\n    if (0 <= (x1-x3)*(y4-y3)-(y1-y3)*(x4-x3)) ++c;\n    if (c % 3 != 0) return false;\n    if (getPerpDistDbl(x1, y1, x2, y2, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x2, y2, x3, y3, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x3, y3, x1, y1, x4, y4) + eps < r*r) return false;\n    return true;\n}\n\nbool isB() {\n    if (distDbl(x1,y1,x4,y4) <= r*r && distDbl(x2,y2,x4,y4) <= r*r && distDbl(x3,y3,x4,y4) <= r*r) {\n        return true;\n    }\n    return false;\n}\n\nbool isC() {\n    if (getPerpDistSegDbl(x1,y1,x2,y2,x4,y4) + eps < r*r) return true;\n    if (getPerpDistSegDbl(x2,y2,x3,y3,x4,y4) + eps < r*r) return true;\n    if (getPerpDistSegDbl(x3,y3,x1,y1,x4,y4) + eps < r*r) return true;\n    return false;\n}\n\nint main() {\n    while (cin >> x1 >> y1, (x1 || y1)) {\n        cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n        if (isB()) cout << \"b\" << endl;\n        else if (isA()) cout << \"a\" << endl;\n        else if (isC()) cout << \"c\" << endl;\n        else cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& _p, double _r) : p(_p), r(_r) {} \n};\n\n// code for problem\n\nint x, y, r;\nP tr[3];\nC cc;\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 >= 0 && d1 * d2 >= 0 && d2 * d0 >= 0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(6);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\td[3] = distP2LS(cc.p, L(tr[0], tr[1]));\n\td[4] = distP2LS(cc.p, L(tr[1], tr[2]));\n\td[5] = distP2LS(cc.p, L(tr[2], tr[0]));\n\tif(in && d[3] >= cc.r && d[4] >= cc.r && d[5] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tsort(d.begin(), d.end());\n\tif(d[0] <= cc.r) {\n\t\tprintf(\"c\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect\n\tprintf(\"d\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#include<string>\n \n#define EPS 1E-10\n#define SAME_SIGN( a , b ) ( a * b > EPS ? true : false )\n\nenum state {\n\tOVERLAP,\n\tJUST,\n\tNONE,\n};\n \nnamespace geometry{\n \n    struct point{\n        double x;\n        double y;\n        point(){}\n        point( double x , double y ):x(x),y(y){}\n        point& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n        point& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n        point& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n        point& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n        bool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n        bool operator != ( const point& p ) const { return !(*this == p); }\n        double norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n    };\n \n    typedef point vector2d;\n \n    struct circle{\n        point center;\n        double radius;\n    };\n \n    struct triangle{\n        point a;\n        point b;\n        point c;\n    };\n \n    point operator + ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p += p2;\n            return p;\n        }\n        point operator - ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p -= p2;\n            return p;\n        }\n        point operator * ( const point& p1 , double factor ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator * ( double factor , const point& p1 ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator / ( const point& p1 , double factor ){\n            point p(p1);\n            p /= factor;\n            return p;\n        }\n \n    std::istream& operator >> ( std::istream& s , point& p )\n    {\n        return s >> p.x >> p.y;\n    }\n \n    double get_distance( const point& p1 , const point& p2 )\n    {\n\t\tdouble testDis = sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) ); // テスト用\n        return sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n    }\n \n    double get_dot_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.x + oa.y * ob.y;\n    }\n \n    double get_cross_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.y - oa.y * ob.x;\n    }\n \n    point get_project( const point& s , const point& e , const point& p ){\n        double scale = get_dot_product( p , e , s ) / ( e - s ).norm();\n        return s + scale * ( e - s ) / ( e - s ).norm();\n    }\n \n    bool is_inter_point( const point& s , const point& e , const point& p ){\n        return std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n    }\n}\n \nusing namespace geometry;\n \nbool input_data( triangle& tri , circle& cir )\n{\n    std::cin >> tri.a;\n    if( tri.a.x == 0 && tri.a.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.b;\n    if( tri.b.x == 0 && tri.b.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.c;\n    if( tri.c.x == 0 && tri.c.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.center;\n    if( cir.center.x == 0 && cir.center.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.radius;\n    return true;\n}\n \nstate is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\t// 一つの辺と三角形が交差する場合にtrueを返す。\n    if( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( fabs(get_distance( get_project(p1 , p2 , cir.center ) , cir.center ) - cir.radius) < EPS ){\n\t\t\treturn JUST;\n\t\t}\n        if( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) < cir.radius ){\n            return OVERLAP;\n        }\n        else{\n            return NONE;\n        }\n    }\n    else{\n        return NONE;\n    }\n}\n \nstate is_overlap( triangle& tri , circle& cir )\n{\n    // オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\t/*\n    if( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n        !(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n        !(is_overlap_for_one_side( tri.c , tri.a , cir ))\n        ){\n            return false;\n    }\n    else{\n        return true;\n    }\n\t*/\n\tif( is_overlap_for_one_side( tri.a , tri.b , cir ) == OVERLAP || \n\t\tis_overlap_for_one_side( tri.b , tri.c , cir ) == OVERLAP ||\n\t\tis_overlap_for_one_side( tri.c , tri.a , cir ) == OVERLAP) {\n\t\treturn OVERLAP;\n\t}\n\telse if( is_overlap_for_one_side( tri.a , tri.b , cir ) == NONE && \n\t\t\t is_overlap_for_one_side( tri.b , tri.c , cir ) == NONE &&\n\t\t\t is_overlap_for_one_side( tri.c , tri.a , cir ) == NONE){\n\t\treturn NONE;\n\t}\n\telse if(is_overlap_for_one_side( tri.a , tri.b , cir ) == JUST || \n\t\t\tis_overlap_for_one_side( tri.b , tri.c , cir ) == JUST ||\n\t\t\tis_overlap_for_one_side( tri.c , tri.a , cir ) == JUST){\n\t\treturn JUST;\n\t}\n\telse{\n\t\tstd::cout << \"error\" << std::endl;\n\t}\n \n}\n \nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n    if( get_distance( tri.a , cir.center ) <= cir.radius  &&\n        get_distance( tri.b , cir.center ) <= cir.radius  &&\n        get_distance( tri.c , cir.center ) <= cir.radius\n        ){\n            std::cout << \"b\" << std::endl;\n    }\n    else{\n        if( get_distance( tri.a , cir.center ) > cir.radius  &&\n            get_distance( tri.b , cir.center ) > cir.radius  &&\n            get_distance( tri.c , cir.center ) > cir.radius\n            ){\n                if( is_overlap( tri , cir ) == NONE ){\n                    if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                        SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                            std::cout << \"a\" << std::endl;\n                    }\n                    else{\n                        std::cout << \"d\" << std::endl;\n                    }\n                }\n                else if( is_overlap( tri , cir ) == JUST ){\n                   if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                       SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                            std::cout << \"a\" << std::endl;\n                    }\n                    else{\n                        std::cout << \"c\" << std::endl;\n                    }\n                }\n\t\t\t\telse if( is_overlap( tri , cir ) == OVERLAP ){\n\t\t\t\t\tstd::cout << \"c\" << std::endl;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << \"error\" << std::endl;\n\t\t\t\t}\n        }\n        else{\n            std::cout << \"c\" << std::endl;\n        }\n    }\n}\n\nstd::string output_positional_relation_of_circle_and_triangle_for_test( triangle& tri , circle& cir )\n{\n\t if( get_distance( tri.a , cir.center ) <= cir.radius  &&\n        get_distance( tri.b , cir.center ) <= cir.radius  &&\n        get_distance( tri.c , cir.center ) <= cir.radius\n        ){\n           return \"b\";\n    }\n    else{\n        if( get_distance( tri.a , cir.center ) > cir.radius  &&\n            get_distance( tri.b , cir.center ) > cir.radius  &&\n            get_distance( tri.c , cir.center ) > cir.radius\n            ){\n                if( is_overlap( tri , cir ) == NONE ){\n                    if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                        SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                            return \"a\";\n                    }\n                    else{\n                        return \"d\";\n                    }\n                }\n                else if( is_overlap( tri , cir ) == JUST ){\n                   if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                       SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                            return \"a\";\n                    }\n                    else{\n                        return \"c\";\n                    }\n                }\n\t\t\t\telse if( is_overlap( tri , cir ) == OVERLAP ){\n\t\t\t\t\treturn \"c\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << \"error\" << std::endl;\n\t\t\t\t}\n        }\n        else{\n            return \"c\";\n        }\n    }\n}\n\nstruct TEST_CASE {\n\ttriangle tri;\n\tcircle cir;\n\tstd::string ans;\n\n\tvoid SetTestCase( int ax, int ay, int bx, int by, int cx, int cy, int ox, int oy, int r, std::string ans )\n\t{\n\t\tthis->tri.a.x = ax;\n\t\tthis->tri.a.y = ay;\n\t\tthis->tri.b.x = bx;\n\t\tthis->tri.b.y = by;\n\t\tthis->tri.c.x = cx;\n\t\tthis->tri.c.y = cy;\n\t\tthis->cir.center.x = ox;\n\t\tthis->cir.center.y = oy;\n\t\tthis->cir.radius = r;\n\t\tthis->ans = ans;\n\t}\n};\n\nvoid test(void)\n{\n\tTEST_CASE testCase[100];\n\n\ttestCase[0].SetTestCase(10, 20, 1, 5, 19, 5, 10, 10, 3, \"a\");\n\ttestCase[1].SetTestCase(10, 12, 12, 9, 8, 9, 10, 10, 3, \"b\");\n\ttestCase[2].SetTestCase(10, 12, 12, 9, 7, 10, 10, 10, 3, \"b\");\n\ttestCase[3].SetTestCase(20, 5, 40, 20, 40, 5, 20, 20, 12, \"c\");\n\ttestCase[4].SetTestCase(20, 5, 41, 20, 40, 5, 20, 20, 12, \"d\");\n\ttestCase[5].SetTestCase(10, 13, 10, 16, 7, 13, 10, 10, 3, \"c\");\n\ttestCase[6].SetTestCase(2000, 500, 4000, 2000, 4000, 500, 2000, 2000, 1200, \"c\");\n\ttestCase[7].SetTestCase(2000, 500, 4001, 2000, 4000, 500, 2000, 2000, 1200, \"d\");\n\ttestCase[8].SetTestCase(2000, 500, 3999, 2000, 4000, 500, 2000, 2000, 1200, \"c\");\n\ttestCase[9].SetTestCase(1000, 2000, 100, 500, 1900, 500, 1000, 1000, 300, \"a\");\n\ttestCase[10].SetTestCase(1000, 1200, 1200, 900, 800, 900, 1000, 1000, 300, \"b\");\n\ttestCase[11].SetTestCase(1000, 1200, 1200, 900, 700, 1000, 1000, 1000, 300, \"b\");\n\ttestCase[12].SetTestCase(1000, 1300, 1000, 1600, 700, 1300, 1000, 1000, 300, \"c\");\n\ttestCase[13].SetTestCase(1, 4999, 9999, 4999, 5000, 9000, 5000, 5000, 1, \"a\");\n\ttestCase[14].SetTestCase(1, 4999, 9999, 4999, 5000, 9000, 5000, 5001, 1, \"a\");\n\ttestCase[15].SetTestCase(1, 4999, 9999, 5001, 5000, 9000, 5000, 5001, 1, \"c\");\n\n\tfor( int i = 0 ; i < 16 ; i++ )\n\t{\n\t\tstd::cout << \"testCase[\" << i << \"] : \";\n\t\tif( testCase[i].ans == output_positional_relation_of_circle_and_triangle_for_test(testCase[i].tri, testCase[i].cir) ){\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\t}\n\t\telse{\n\t\t\tstd::cout << \"NG\" << std::endl;\n\t\t}\n\t}\n}\n \nint main(void)\n{\n    triangle tri;\n    circle cir;\n \n\t// test();\n\n    while(input_data(tri, cir)){\n        output_positional_relation_of_circle_and_triangle( tri , cir );\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\nbool intersectGC(Polygon g,Circle c){\n    for(int i=0;i<g.size();i++){\n        Segment s(g[i],next(g,i));\n        if(intersectCS(c,s))return true;\n    }\n    return false;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(!contains(c,g[i]))return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        if(contains(g,c))puts(\"a\");\n        else if(contains(c,g))puts(\"b\");\n        else if(intersectGC(g,c))puts(\"c\");\n        else puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);//count common tangents\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b,const Point&c){\n\tPoint p=b-a,q=c-a;\n\treturn cross(p,q)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(p,q)<-EPS?CLOCKWISE\n\t\t:dot(p,q)<0?ONLINE_BACK\n\t\t:norm(p)<norm(q)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nmain()\n{\n\tPoint p1,p2,p3;\n\tCircle C;\n\twhile(cin>>p1,p1.x)\n\t{\n\t\tcin>>p2>>p3>>C.o>>C.r;\n\t\tif(contain(convex_full(Polygon{p1,p2,p3}),C.o)!=OUT&&distance(Segment(p1,p2),C.o)>=C.r\n\t\t\t&&distance(Segment(p2,p3),C.o)>=C.r\n\t\t\t&&distance(Segment(p3,p1),C.o)>=C.r)cout<<\"a\"<<endl;\n\t\telse if(contain(C,Segment(p1,p2))!=OUT&&contain(C,Segment(p2,p3))!=OUT&&\n\t\t\tcontain(C,Segment(p3,p1))!=OUT)cout<<\"b\"<<endl;\n\t\telse if(contain(convex_full(Polygon{p1,p2,p3}),C.o)==OUT&&distance(C.o,p1)>C.r&&distance(C.o,p2)>C.r&&distance(C.o,p3)>C.r\n\t\t\t&&distance(Segment(p1,p2),C.o)>C.r\n\t\t\t&&distance(Segment(p2,p3),C.o)>C.r\n\t\t\t&&distance(Segment(p3,p1),C.o)>C.r)cout<<\"d\"<<endl;\n\t\telse cout<<\"c\"<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-8\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double na;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    na = norm(a);\n    if (na < r2) {\n      c[i] = -1;\n    } else if (na > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0 && c[1]>=0 && c[2]>=0) {\n    return 1;\n  } else if (c[0]<=0 && c[1]<=0 && c[2]<=0) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  //double na, nb, dab, d; \n  double sd, s, t;\n  long long int ina, inb, idab, id;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    //na = norm(a);\n    //nb = norm(b);\n    //dab = dot(a,b);\n    //d = dab*dab - na*(nb-r*r);\n    ina = (int)a.real()*(int)a.real()+(int)a.imag()*(int)a.imag();\n    inb = (int)b.real()*(int)b.real()+(int)b.imag()*(int)b.imag();\n    idab = (int)a.real()*(int)b.real()+(int)a.imag()*(int)b.imag();\n    id = idab*idab - ina*(inb-(int)r*(int)r);\n    if (id < 0) {\n      continue;\n    }\n    sd = sqrt((double)id);\n    s = (idab+sd)/ina;\n    t = (idab-sd)/ina;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (!id) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nstruct L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nstruct C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& _p, double _r) : p(_p), r(_r) {} \n};\n\n// code for problem\n\nint x, y, r;\nP tr[3];\nC cc;\n\n// compute distance between 2 points\ndouble distP2P(P& p, P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(P& p, L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(P& p, L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\nbool isPinT(P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 >= 0 && d1 * d2 >= 0 && d2 * d0 >= 0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(6);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tprintf(\"%f %f %f\\n\", d[0], d[1], d[2]);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\td[3] = distP2LS(cc.p, L(tr[0], tr[1]));\n\td[4] = distP2LS(cc.p, L(tr[1], tr[2]));\n\td[5] = distP2LS(cc.p, L(tr[2], tr[0]));\n\tif(in && d[3] >= cc.r && d[4] >= cc.r && d[5] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tsort(d.begin(), d.end());\n\tif(d[0] <= cc.r) {\n\t\tprintf(\"c\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect\n\tprintf(\"d\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef complex<double> P; \ntypedef vector<P> G;\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b){\n        push_back(a);\n        push_back(b);\n    }\n    L(){}\n};\n\nstruct C{\n    P p;\n    double r;\n    C(const P &p, double r) : p(p), r(r) { }\n    C(){}\n};\n\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n#define curr(G, i) G[i]\n#define next(G, i) G[(i+1)%G.size()]\nenum { OUT, ON, IN };\nint contains(const G &g, const P &p) {\n    bool in = false;\n    for (int i = 0; i < g.size(); ++i) {\n        P a = curr(g,i) - p, b = next(g,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\nint main(){\n    int tmpx, tmpy,r;\n    while(cin >> tmpx >> tmpy){\n        if((tmpx | tmpy) == 0) break;\n        G v(3);\n        L *e = new L[3];\n        C c;\n        v[0] = P(tmpx, tmpy);\n        cin >> tmpx >> tmpy;\n        v[1] = P(tmpx, tmpy);\n        cin >> tmpx >> tmpy;\n        v[2] = P(tmpx, tmpy);\n        e[0] = L(v[0],v[1]);\n        e[1] = L(v[0],v[2]);\n        e[2] = L(v[1],v[2]);\n        cin >> tmpx >> tmpy >> r;\n        c = C(P(tmpx,tmpy), r);\n        bool isA = true;\n        for(int i=0;i<3;i++){\n            //for all edges\n            if(distanceSP(e[i], c.p) < r){\n                isA = false;\n            }\n        }\n        if(isA && contains(v, c.p) > 0){\n            cout << \"a\" << endl;\n            continue;\n        }\n        bool isB = true;\n        for(int i=0;i<3;i++){\n            //for all vertex\n            if(abs(v[i] - c.p) > r){\n                isB = false;\n            }\n        }\n        if(isB){\n            cout << \"b\" << endl;\n            continue;\n        }\n        if(!isA){\n            cout << \"c\" << endl;\n        }else{\n            cout << \"d\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconst double eps = 1e-7;\nnamespace boost {\ntemplate <class T>\nstruct integer_iterator {\n    T a;\n    bool operator != (integer_iterator const & it) const { return a != it.a; }\n    T operator * () const { return a; }\n    integer_iterator & operator ++ () { ++ a; return *this; }\n    integer_iterator operator ++ (int) { return { a ++ }; }\n};\ntemplate <class T>\nstruct integer_range {\n    T l, r;\n    typedef integer_iterator<T> iterator;\n    iterator begin() const { return { l }; }\n    iterator end  () const { return { r }; }\n};\ntemplate <class T>\ninteger_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }\ntemplate <class T>\nstruct integer_iterator_with_step {\n    T a, d, i;\n    bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }\n    T operator * () const { return a+d*i; }\n    integer_iterator_with_step & operator ++ () { ++ i; return *this; }\n    integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }\n};\ntemplate <class T>\nstruct strided_integer_range {\n    T l, r, s;\n    typedef integer_iterator_with_step<T> iterator;\n    iterator begin() const { return { l, s, 0 }; }\n    iterator end  () const { return { l, s, (r - l) / s }; }\n};\ntemplate <class T>\nstrided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }\n}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };\nttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }\nttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }\nttt point<T> operator - (pca a) { return { -a.x, -a.y }; }\nttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }\nttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }\nttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }\nttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }\nttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }\nttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }\nttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }\nttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }\nttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }\nttt double length(pca p) { return sqrt(length_squared(p)); }\nttt point<T> normalized(pca a) { return (1 / length(a)) * a; }\nttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }\nttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }\nttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }\ntemplate <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> bool operator == (circle<T> const & a, circle<T> const & b) { return a.p == b.p and a.r == b.r; }\ntemplate <typename T> bool operator != (circle<T> const & a, circle<T> const & b) { return not (a == b); }\ntemplate <typename T> struct line { point<T> a, b; };\ntemplate <typename T> struct ray { point<T> a, b; };\ntemplate <typename T> struct segment { point<T> a, b; };\ntemplate <typename T> T length_squared(segment<T> const & p) { return length_squared(p.a - p.b); }\ntemplate <typename T> double length(segment<T> const & p) { return length(p.a - p.b); }\ntemplate <typename T>    line<T> to_line(    ray<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>    line<T> to_line(segment<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(   line<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(segment<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment(line<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment( ray<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T>\nstruct arc { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT length(arc<T> const & a) { return a.r * (a.b - a.a); }\ntemplate <typename T>\nbool valid(arc<T> const & a) {\n    assert (0 <= a.r);\n    return\n        - M_PI < a.a + eps and a.a < M_PI + eps and\n        - M_PI < a.b + eps and a.b < M_PI + eps;\n}\ntemplate <typename T>\ncircle<T> to_circle(arc<T> const & a) { return { a.p, a.r }; }\n\ntemplate <typename T>\nstruct circular_sector { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT sq(T x) { return x * x; }\ntemplate <typename T>\npoint<T> rotate_90(point<T> const & a) {\n    return { - a.y, a.x };\n}\ntemplate <typename T>\npoint<T> rotate_270(point<T> const & a) {\n    return { a.y, - a.x };\n}\ntemplate <typename T>\npoint<T> rotate_180(point<T> const & a) {\n    return { - a.x, - a.y };\n}\npoint<double> rotate(point<double> const & a, double th) {\n    return {\n        a.x * cos(th) - a.y * sin(th),\n        a.x * sin(th) + a.y * cos(th) };\n}\ntemplate <>\nint ccw(point<double> const & a, point<double> const & b, point<double> const & c) {\n    double x = cross(b - a, c - a);\n    return x > eps ? 1 : x < - eps ? -1 : 0;\n}\n\ndouble distance(point<double> const & a, point<double> const & b) {\n    return length(b - a);\n}\n\ndouble distance(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return std::abs( cross(p, e) );\n}\ndouble distance(point<double> const & a, line<double> const & b) {\n    return distance(b,a);\n}\n\nbool does_include(circle<double> const & a, point<double> const & b) {\n    return length(a.p - b) < a.r + eps;\n}\nbool is_on_circumference(point<double> const & a, circle<double> const & b) {\n    return std::abs(length(b.p - a) - b.r) < eps;\n}\n// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < std::abs(a.r - b.r) + eps;\n}\n// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < a.r + b.r + eps;\n}\n// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;\n}\n// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {\n    std::vector<point<double> > result;\n    if (distance(a.p, b.p) < eps) {\n        // nop\n    } else if (not does_intersect(a,b)) {\n        // nop\n    } else if (does_include(a,b) and not does_inscribe(a,b)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(a,b) or does_circumscribe(a,b)) {\n        circle<double> x = a;\n        circle<double> y = b;\n        if (not (x.r < y.r)) std::swap(x, y);\n        result.push_back(y.r * normalized(x.p - y.p) + y.p);\n    } else {\n        //       c\n        //      /|\\\n        // a.r / | \\ b.r\n        //    /th|  \\\n        //   a-------b\n        //       l\n        double l = length(b.p - a.p);\n        double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\n        double as = sqrt( sq(a.r) - sq(ac) );\n        point<double> e = normalized(b.p - a.p);\n        result.push_back(a.p + ac*e + as*rotate_90(e));\n        result.push_back(a.p + ac*e + as*rotate_270(e));\n    }\n    for (auto p : result) {\n        assert (does_include(a, p));\n        assert (does_include(b, p));\n    }\n    return result;\n}\n\nstd::vector<line<double> > tangents(circle<double> const & a, point<double> const & b) {\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not is_on_circumference(b,a)) {\n        // truly included\n        // nop\n    } else if (is_on_circumference(b,a)) {\n        point<double> e = normalized(a.p - b);\n        result.push_back({\n                b + rotate_90(e),\n                b + rotate_270(e) });\n    } else {\n        double theta = asin(a.r / length(b - a.p));\n        result.push_back({ b, b + rotate(a.p - b, + theta) });\n        result.push_back({ b, b + rotate(a.p - b, - theta) });\n    }\n    return result;\n}\n\nstd::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {\n    point<double> p = a.p + (a.r / (a.r + b.r)) * (b.p - a.p);\n    return tangents(a,p);\n}\nstd::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {\n    if (b.r < a.r) std::swap(a,b);\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not does_inscribe(b,a)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(b,a)) {\n        point<double> e = normalized(a.p - b.p);\n        result.push_back({\n                b.p + a.r*e + rotate_90(e),\n                b.p + a.r*e + rotate_270(e) });\n    } else {\n        point<double> d = b.p - a.p;\n        double theta = asin((b.r - a.r) / length(d));\n        point<double> dp = rotate(d, + theta);\n        point<double> dm = rotate(d, - theta);\n        point<double> ep = rotate_90(normalized(dp));\n        point<double> em = rotate_270(normalized(dm));\n        result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });\n        result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });\n    }\n    return result;\n}\nstd::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {\n    std::vector<line<double> > result;\n    for (auto l : common_inner_tangents(a,b)) result.push_back(l);\n    for (auto l : common_outer_tangents(a,b)) result.push_back(l);\n    return result;\n}\n\npoint<double> nearest_point(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return a.a + dot(p, e) * e;\n}\nbool is_tangent(line<double> const & a, circle<double> const & b) {\n    return std::abs( b.r - distance(a, b.p) ) < eps;\n}\nbool does_include(segment<double> const & a, point<double> const & b) {\n    point<double> p = b - a.a;\n    point<double> e = normalized(a.b - a.a);\n    return std::abs( cross(e, p) ) < eps and - eps < dot(e, p) and dot(e, p) < length(a) + eps;\n}\nbool is_tangent(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return is_tangent(l, b) and does_include(a, nearest_point(l, b.p));\n}\nbool does_intersect(line<double> const & a, circle<double> const & b) {\n    return distance(a, b.p) < b.r + eps;\n}\nbool does_intersect(circle<double> const & a, line<double> const & b) {\n    return does_intersect(b, a);\n}\nbool does_intersect(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return does_intersect(l, b) and\n        (does_include(a, nearest_point(l, b.p)) or\n         distance(a.a, b.p) < b.r + eps or\n         distance(a.b, b.p) < b.r + eps);\n}\n\nbool does_intersect(line<double> const & a, line<double> const & b) {\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return eps < std::abs( cross(p, q) );\n}\nbool is_parallel(line<double> const & a, line<double> const & b) {\n    return not does_intersect(a, b);\n}\nbool does_intersect(segment<double> const & a, segment<double> const & b) {\n    return\n        ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) == -1 and\n        ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) == -1;\n}\npoint<double> intersection_point(line<double> const & a, line<double> const & b) {\n    assert (does_intersect(a, b));\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return a.a + ( cross(q, b.a - a.a) / cross(q, p) ) * p;\n}\n\nbool does_include(ray<double> const & a, point<double> const & b) {\n    return ccw(a.a, a.b, b) == 0 and dot(a.b - a.a, b - a.a) > - eps;\n}\nbool does_intersect(ray<double> const & a, segment<double> const & b) {\n    if (does_include(a, b.a) or does_include(a, b.b)) return true;\n    line<double> la = to_line(a);\n    line<double> lb = to_line(b);\n    if (is_parallel(la, lb)) return false;\n    point<double> p = intersection_point(la, lb);\n    return does_include(a,p) and does_include(b,p);\n}\nbool does_intersect(segment<double> const & a, ray<double> const & b) {\n    return does_intersect(b, a);\n}\n\npoint<double> projection(point<double> const & a, line<double> const & b) {\n    point<double> e = normalized(b.b - b.a);\n    return dot(e, a - b.a) * e + b.a;\n}\ndouble distance(segment<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_line(a));\n    if (does_include(a, p)) {\n        return distance(to_line(a), b);\n    } else{\n        return std::min(distance(a.a, b), distance(a.b, b));\n    }\n}\ndouble distance(point<double> const & a, segment<double> const & b) {\n    return distance(b, a);\n}\ndouble distance(segment<double> const & a, segment<double> const & b) {\n    return std::min(std::min(std::min(\n            distance(a.a, b),\n            distance(a.b, b)),\n            distance(a, b.a)),\n            distance(a, b.b));\n}\n\npoint<double> projection(point<double> const & a, circle<double> const & b) {\n    return b.r * normalized(a - b.p) + b.p;\n}\nbool does_include(arc<double> const & a, point<double> const & b) {\n    assert (valid(a));\n    point<double> e = b - a.p;\n    double r = length(e);\n    double th = atan2(e.y, e.x);\n    return std::abs(a.r - r) < eps and  a.a < th + eps and th < a.b + eps;\n}\ndouble distance(arc<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_circle(a));\n    if (does_include(a, p)) {\n        return distance(p, b);\n    } else{\n        point<double> l = a.r * (point<double>) { cos(a.a), sin(a.a) } + a.p;\n        point<double> r = a.r * (point<double>) { cos(a.b), sin(a.b) } + a.p;\n        return std::min(distance(l, b), distance(r, b));\n    }\n}\ndouble distance(point<double> const & a, arc<double> const & b) {\n    return distance(b, a);\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    if (not does_intersect(a, b)) {\n        // nop\n    } else if (is_tangent(b, a)) {\n        result.push_back(nearest_point(b, a.p));\n    } else {\n        point<double> e = normalized(b.b - b.a);\n        point<double> p = nearest_point(b, a.p);\n        double h = distance(p, a.p);\n        double w = sqrt( sq(a.r) - sq(h) );\n        result.push_back(  w * e + p);\n        result.push_back(- w * e + p);\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, circle<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), b)) {\n        if (does_include(a, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, segment<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), to_line(b))) {\n        if (does_include(a, p) and does_include(b, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(segment<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nbool does_intersect(arc<double> const & a, segment<double> const & b) {\n    return not intersection_points(a, b).empty();\n}\nbool does_intersect(segment<double> const & a, arc<double> const & b) {\n    return does_intersect(b, a);\n}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\nint main() {\n    while (true) {\n        point<double> p[3];\n        cin >> p[0];\n        if (p[0].x == 0 and p[0].y == 0) break;\n        cin >> p[1] >> p[2];\n        circle<double> c;\n        cin >> c.p >> c.r;\n        if (\n                distance(c.p, p[0]) < c.r and\n                distance(c.p, p[1]) < c.r and\n                distance(c.p, p[2]) < c.r) {\n            cout << 'b' << endl;\n        } else if (abs(\n                    ccw(p[0], p[1], c.p) +\n                    ccw(p[1], p[2], c.p) +\n                    ccw(p[2], p[0], c.p)) == 3) {\n            if (\n                    not does_intersect((segment<double>){ p[0], p[1] }, c) and\n                    not does_intersect((segment<double>){ p[1], p[2] }, c) and\n                    not does_intersect((segment<double>){ p[2], p[0] }, c)) {\n                cout << 'a' << endl;\n            } else {\n                cout << 'c' << endl;\n            }\n        } else {\n            if (\n                    not does_intersect((segment<double>){ p[0], p[1] }, c) and\n                    not does_intersect((segment<double>){ p[1], p[2] }, c) and\n                    not does_intersect((segment<double>){ p[2], p[0] }, c)) {\n                cout << 'd' << endl;\n            } else {\n                cout << 'c' << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n    \n    t=construct_edge(p,3);\n    int fg=0;\n    if(point_contain(t,C.p,3)){\n      for(int i=0;i<3;i++)\n\tif(crossCS(t[i].a,t[i].b,C))fg=1;\n      if(fg){\n\tcout <<'c'<<endl;\n\tcontinue;\n      }\n      for(int i=0;i<3;i++)\n\tif(containCS(t[i].a,t[i].b,C))fg=1;\n      if(fg)cout <<'b'<<endl;\n      else cout <<'a'<<endl;\n    }\n    else {\n      for(int i=0;i<3;i++){\n\tif(containCS(t[i].a,t[i].b,C))fg=1;\n      }\n      if(fg) cout <<'c'<<endl;\n      else cout <<'d'<< endl;\n    }\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        t=convex_hull(t);\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=min(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>EPS)return 1;\n            if(in_triangle(p,t))return 2;//c in t\n            else if(r-d<-EPS)return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n}\n\n\nusing namespace geo;\n\nint main(){\n    int x,y,r;\n    while(cin>>x>>y,x!=0||y!=0){\n        Poly t={P(x,y)};\n        REP(i,2){\n            cin>>x>>y;\n            t.pb(P(x,y));\n        }\n        cin>>x>>y>>r;\n        C c(P(x,y),r);\n        int res=is_triangle_C(t,c);\n        if(res==2)cout<<\"a\"<<endl;\n        if(res==3)cout<<\"b\"<<endl;\n        if(res==1)cout<<\"c\"<<endl;\n        if(res==0)cout<<\"d\"<<endl;\n\n    }\n   \n    \n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n/*  0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), all(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n//???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\trep(i, n) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tedge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvoid add_edge(graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(edge{ from, to, weight });\n}\n\ngraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\ngraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll2(s[i], s[j])[0]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\ngraph Circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main() {\n\t\n\twhile (1) {\n\t\tint x1, y1; cin >> x1 >> y1;\n\t\tif (!x1)break;\n\t\tint x2, y2, x3, y3, x4, y4, r; cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tPolygon tri;\n\t\ttri.push_back(Point(x1, y1));\n\t\ttri.push_back(Point(x2, y2));\n\t\ttri.push_back(Point(x3, y3));\n\t\tCircle c(Point(x4, y4), r);\n\t\tbool flag_b = true;\n\t\t{\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tif (!is_in_Circle(c, tri[i])) {\n\t\t\t\t\tflag_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag_a = false;\n\t\tbool  flag_c = false;\n\t\t{\n\t\t\tif (is_in_Polygon(tri, c.p)) {\n\t\t\t\tflag_a = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tLine l(tri[i], tri[(i + 1) % 3]);\n\t\t\t\tld aa = dist_sp(l, c.p);\n\t\t\t\t\n\t\t\t\tif (dist_sp(l, c.p) + eps<c.r) {\n\t\t\t\t\tflag_a = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tLine l(tri[i], tri[(i + 1) % 3]);\n\t\t\t\tld aa = dist_sp(l, c.p);\n\n\t\t\t\tif (dist_sp(l, c.p) - eps<c.r) {\n\t\t\t\t\tflag_c = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag_b) {\n\t\t\tcout << 'b' << endl;\n\t\t}\n\t\telse if (flag_a) {\n\t\t\tcout << 'a' << endl;\n\t\t}\n\t\telse if (flag_c) {\n\t\t\tcout << 'c' << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 'd' << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconst double eps = 1e-7;\nnamespace boost {\ntemplate <class T>\nstruct integer_iterator {\n    T a;\n    bool operator != (integer_iterator const & it) const { return a != it.a; }\n    T operator * () const { return a; }\n    integer_iterator & operator ++ () { ++ a; return *this; }\n    integer_iterator operator ++ (int) { return { a ++ }; }\n};\ntemplate <class T>\nstruct integer_range {\n    T l, r;\n    typedef integer_iterator<T> iterator;\n    iterator begin() const { return { l }; }\n    iterator end  () const { return { r }; }\n};\ntemplate <class T>\ninteger_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }\ntemplate <class T>\nstruct integer_iterator_with_step {\n    T a, d, i;\n    bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }\n    T operator * () const { return a+d*i; }\n    integer_iterator_with_step & operator ++ () { ++ i; return *this; }\n    integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }\n};\ntemplate <class T>\nstruct strided_integer_range {\n    T l, r, s;\n    typedef integer_iterator_with_step<T> iterator;\n    iterator begin() const { return { l, s, 0 }; }\n    iterator end  () const { return { l, s, (r - l) / s }; }\n};\ntemplate <class T>\nstrided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }\n}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };\nttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }\nttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }\nttt point<T> operator - (pca a) { return { -a.x, -a.y }; }\nttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }\nttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }\nttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }\nttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }\nttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }\nttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }\nttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }\nttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }\nttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }\nttt double length(pca p) { return sqrt(length_squared(p)); }\nttt point<T> normalized(pca a) { return (1 / length(a)) * a; }\nttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }\nttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }\nttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }\ntemplate <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> bool operator == (circle<T> const & a, circle<T> const & b) { return a.p == b.p and a.r == b.r; }\ntemplate <typename T> bool operator != (circle<T> const & a, circle<T> const & b) { return not (a == b); }\ntemplate <typename T> struct line { point<T> a, b; };\ntemplate <typename T> struct ray { point<T> a, b; };\ntemplate <typename T> struct segment { point<T> a, b; };\ntemplate <typename T> T length_squared(segment<T> const & p) { return length_squared(p.a - p.b); }\ntemplate <typename T> double length(segment<T> const & p) { return length(p.a - p.b); }\ntemplate <typename T>    line<T> to_line(    ray<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>    line<T> to_line(segment<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(   line<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(segment<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment(line<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment( ray<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T>\nstruct arc { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT length(arc<T> const & a) { return a.r * (a.b - a.a); }\ntemplate <typename T>\nbool valid(arc<T> const & a) {\n    assert (0 <= a.r);\n    return\n        - M_PI < a.a + eps and a.a < M_PI + eps and\n        - M_PI < a.b + eps and a.b < M_PI + eps;\n}\ntemplate <typename T>\ncircle<T> to_circle(arc<T> const & a) { return { a.p, a.r }; }\n\ntemplate <typename T>\nstruct circular_sector { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT sq(T x) { return x * x; }\ntemplate <typename T>\npoint<T> rotate_90(point<T> const & a) {\n    return { - a.y, a.x };\n}\ntemplate <typename T>\npoint<T> rotate_270(point<T> const & a) {\n    return { a.y, - a.x };\n}\ntemplate <typename T>\npoint<T> rotate_180(point<T> const & a) {\n    return { - a.x, - a.y };\n}\npoint<double> rotate(point<double> const & a, double th) {\n    return {\n        a.x * cos(th) - a.y * sin(th),\n        a.x * sin(th) + a.y * cos(th) };\n}\ntemplate <>\nint ccw(point<double> const & a, point<double> const & b, point<double> const & c) {\n    double x = cross(b - a, c - a);\n    return x > eps ? 1 : x < - eps ? -1 : 0;\n}\n\ndouble distance(point<double> const & a, point<double> const & b) {\n    return length(b - a);\n}\n\ndouble distance(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return std::abs( cross(p, e) );\n}\ndouble distance(point<double> const & a, line<double> const & b) {\n    return distance(b,a);\n}\n\nbool does_include(circle<double> const & a, point<double> const & b) {\n    return length(a.p - b) < a.r + eps;\n}\nbool is_on_circumference(point<double> const & a, circle<double> const & b) {\n    return std::abs(length(b.p - a) - b.r) < eps;\n}\n// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < std::abs(a.r - b.r) + eps;\n}\n// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < a.r + b.r + eps;\n}\n// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;\n}\n// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {\n    std::vector<point<double> > result;\n    if (distance(a.p, b.p) < eps) {\n        // nop\n    } else if (not does_intersect(a,b)) {\n        // nop\n    } else if (does_include(a,b) and not does_inscribe(a,b)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(a,b) or does_circumscribe(a,b)) {\n        circle<double> x = a;\n        circle<double> y = b;\n        if (not (x.r < y.r)) std::swap(x, y);\n        result.push_back(y.r * normalized(x.p - y.p) + y.p);\n    } else {\n        //       c\n        //      /|\\\n        // a.r / | \\ b.r\n        //    /th|  \\\n        //   a-------b\n        //       l\n        double l = length(b.p - a.p);\n        double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\n        double as = sqrt( sq(a.r) - sq(ac) );\n        point<double> e = normalized(b.p - a.p);\n        result.push_back(a.p + ac*e + as*rotate_90(e));\n        result.push_back(a.p + ac*e + as*rotate_270(e));\n    }\n    for (auto p : result) {\n        assert (does_include(a, p));\n        assert (does_include(b, p));\n    }\n    return result;\n}\n\nstd::vector<line<double> > tangents(circle<double> const & a, point<double> const & b) {\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not is_on_circumference(b,a)) {\n        // truly included\n        // nop\n    } else if (is_on_circumference(b,a)) {\n        point<double> e = normalized(a.p - b);\n        result.push_back({\n                b + rotate_90(e),\n                b + rotate_270(e) });\n    } else {\n        double theta = asin(a.r / length(b - a.p));\n        result.push_back({ b, b + rotate(a.p - b, + theta) });\n        result.push_back({ b, b + rotate(a.p - b, - theta) });\n    }\n    return result;\n}\n\nstd::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {\n    point<double> p = a.p + (a.r / (a.r + b.r)) * (b.p - a.p);\n    return tangents(a,p);\n}\nstd::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {\n    if (b.r < a.r) std::swap(a,b);\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not does_inscribe(b,a)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(b,a)) {\n        point<double> e = normalized(a.p - b.p);\n        result.push_back({\n                b.p + a.r*e + rotate_90(e),\n                b.p + a.r*e + rotate_270(e) });\n    } else {\n        point<double> d = b.p - a.p;\n        double theta = asin((b.r - a.r) / length(d));\n        point<double> dp = rotate(d, + theta);\n        point<double> dm = rotate(d, - theta);\n        point<double> ep = rotate_90(normalized(dp));\n        point<double> em = rotate_270(normalized(dm));\n        result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });\n        result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });\n    }\n    return result;\n}\nstd::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {\n    std::vector<line<double> > result;\n    for (auto l : common_inner_tangents(a,b)) result.push_back(l);\n    for (auto l : common_outer_tangents(a,b)) result.push_back(l);\n    return result;\n}\n\npoint<double> nearest_point(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return a.a + dot(p, e) * e;\n}\nbool is_tangent(line<double> const & a, circle<double> const & b) {\n    return std::abs( b.r - distance(a, b.p) ) < eps;\n}\nbool does_include(segment<double> const & a, point<double> const & b) {\n    point<double> p = b - a.a;\n    point<double> e = normalized(a.b - a.a);\n    return std::abs( cross(e, p) ) < eps and - eps < dot(e, p) and dot(e, p) < length(a) + eps;\n}\nbool is_tangent(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return is_tangent(l, b) and does_include(a, nearest_point(l, b.p));\n}\nbool does_intersect(line<double> const & a, circle<double> const & b) {\n    return distance(a, b.p) < b.r + eps;\n}\nbool does_intersect(circle<double> const & a, line<double> const & b) {\n    return does_intersect(b, a);\n}\nbool does_intersect(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return does_intersect(l, b) and\n        (does_include(a, nearest_point(l, b.p)) or\n         distance(a.a, b.p) < b.r + eps or\n         distance(a.b, b.p) < b.r + eps);\n}\n\nbool does_intersect(line<double> const & a, line<double> const & b) {\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return eps < std::abs( cross(p, q) );\n}\nbool is_parallel(line<double> const & a, line<double> const & b) {\n    return not does_intersect(a, b);\n}\nbool does_intersect(segment<double> const & a, segment<double> const & b) {\n    return\n        ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) == -1 and\n        ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) == -1;\n}\npoint<double> intersection_point(line<double> const & a, line<double> const & b) {\n    assert (does_intersect(a, b));\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return a.a + ( cross(q, b.a - a.a) / cross(q, p) ) * p;\n}\n\nbool does_include(ray<double> const & a, point<double> const & b) {\n    return ccw(a.a, a.b, b) == 0 and dot(a.b - a.a, b - a.a) > - eps;\n}\nbool does_intersect(ray<double> const & a, segment<double> const & b) {\n    if (does_include(a, b.a) or does_include(a, b.b)) return true;\n    line<double> la = to_line(a);\n    line<double> lb = to_line(b);\n    if (is_parallel(la, lb)) return false;\n    point<double> p = intersection_point(la, lb);\n    return does_include(a,p) and does_include(b,p);\n}\nbool does_intersect(segment<double> const & a, ray<double> const & b) {\n    return does_intersect(b, a);\n}\n\npoint<double> projection(point<double> const & a, line<double> const & b) {\n    point<double> e = normalized(b.b - b.a);\n    return dot(e, a - b.a) * e + b.a;\n}\ndouble distance(segment<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_line(a));\n    if (does_include(a, p)) {\n        return distance(to_line(a), b);\n    } else{\n        return std::min(distance(a.a, b), distance(a.b, b));\n    }\n}\ndouble distance(point<double> const & a, segment<double> const & b) {\n    return distance(b, a);\n}\ndouble distance(segment<double> const & a, segment<double> const & b) {\n    return std::min(std::min(std::min(\n            distance(a.a, b),\n            distance(a.b, b)),\n            distance(a, b.a)),\n            distance(a, b.b));\n}\n\npoint<double> projection(point<double> const & a, circle<double> const & b) {\n    return b.r * normalized(a - b.p) + b.p;\n}\nbool does_include(arc<double> const & a, point<double> const & b) {\n    assert (valid(a));\n    point<double> e = b - a.p;\n    double r = length(e);\n    double th = atan2(e.y, e.x);\n    return std::abs(a.r - r) < eps and  a.a < th + eps and th < a.b + eps;\n}\ndouble distance(arc<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_circle(a));\n    if (does_include(a, p)) {\n        return distance(p, b);\n    } else{\n        point<double> l = a.r * (point<double>) { cos(a.a), sin(a.a) } + a.p;\n        point<double> r = a.r * (point<double>) { cos(a.b), sin(a.b) } + a.p;\n        return std::min(distance(l, b), distance(r, b));\n    }\n}\ndouble distance(point<double> const & a, arc<double> const & b) {\n    return distance(b, a);\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    if (not does_intersect(a, b)) {\n        // nop\n    } else if (is_tangent(b, a)) {\n        result.push_back(nearest_point(b, a.p));\n    } else {\n        point<double> e = normalized(b.b - b.a);\n        point<double> p = nearest_point(b, a.p);\n        double h = distance(p, a.p);\n        double w = sqrt( sq(a.r) - sq(h) );\n        result.push_back(  w * e + p);\n        result.push_back(- w * e + p);\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, circle<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), b)) {\n        if (does_include(a, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, segment<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), to_line(b))) {\n        if (does_include(a, p) and does_include(b, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(segment<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nbool does_intersect(arc<double> const & a, segment<double> const & b) {\n    return not intersection_points(a, b).empty();\n}\nbool does_intersect(segment<double> const & a, arc<double> const & b) {\n    return does_intersect(b, a);\n}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\nint main() {\n    while (true) {\n        point<ll> p[3];\n        cin >> p[0];\n        if (p[0].x == 0 and p[0].y == 0) break;\n        cin >> p[1] >> p[2];\n        circle<ll> c;\n        cin >> c.p >> c.r;\n        if (\n                length_squared(c.p - p[0]) <= sq(c.r) and\n                length_squared(c.p - p[1]) <= sq(c.r) and\n                length_squared(c.p - p[2]) <= sq(c.r)) {\n            cout << 'b' << endl;\n        } else if (\n                ccw(p[0], p[1], c.p) == 0 or\n                ccw(p[1], p[2], c.p) == 0 or\n                ccw(p[2], p[0], c.p) == 0) {\n            cout << 'c' << endl;\n        } else {\n            ll x = sq(cross(p[1] - p[0], c.p - p[0])) - sq(c.r) * length_squared(p[1] - p[0]);\n            ll y = sq(cross(p[2] - p[1], c.p - p[1])) - sq(c.r) * length_squared(p[2] - p[1]);\n            ll z = sq(cross(p[0] - p[2], c.p - p[2])) - sq(c.r) * length_squared(p[0] - p[2]);\n            if (abs(\n                    ccw(p[0], p[1], c.p) +\n                    ccw(p[1], p[2], c.p) +\n                    ccw(p[2], p[0], c.p)) == 3) {\n                if (x < 0 or y < 0 or z < 0) {\n                    cout << 'c' << endl;\n                } else {\n                    cout << 'a' << endl;\n                }\n            } else {\n                if (x <= 0 or y <= 0 or z <= 0) {\n                    cout << 'c' << endl;\n                } else {\n                    cout << 'd' << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0&&acx*acx+acy*acy<=r*r)return true;\n\t\telse if(abx*acx+aby*acy>abx*abx+aby*aby&&bcx*bcx+bcy*bcy<=r*r)return true;\n\t\telse if(acx*acx+acy*acy-(int)((long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby))<=r*r)return true;\n\t}\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<0)ok1=false;\n\telse ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<0)ok1=false;\n\telse ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<0)ok1=false;\n\telse ok2=false;\n\treturn ok1||ok2;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<r*r&&(c-g)*(c-g)+(d-h)*(d-h)<r*r&&(e-g)*(e-g)+(f-h)*(f-h)<r*r)printf(\"b\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse if(inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\n\n// const double EPS = 1e-9;\nconst double EPS = 0.0;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\nbool EPS_less(double lhs, double rhs) {return lhs < rhs - EPS;}\nbool EPS_equal(double lhs, double rhs) {return lhs <= rhs + EPS;}\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double d) :x(d), y(d) {}\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        if(v1.dot(v2) < -EPS) return BACKWARD;\n        if(v2.distance(Point(0, 0)) - v1.distance(Point(0, 0)) > EPS) return FORWARD;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return EPS_less(center.distance(p), r);}\n    bool include(const Segment& s) const {\n        return EPS_less(center.distance(s), r) || EPS_equal(center.distance(s), r);}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n    if(EPS_less(s.start.distance(p) + s.end.distance(p), s.start.distance(s.end))) return distance(p);\n    if(EPS_equal(s.start.distance(p) + s.end.distance(p), s.start.distance(s.end))) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + v2 * t;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n    for(auto& e: edge) if(circle.include(e)) return \"c\";\n\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center) > 0) ++ccw;\n        if(e.ccw(circle.center) < 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] != 0 || y[0] != 0) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\ndouble S3( double x1, double y1, double x2,double y2, double x3, double y3 ){\n \n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);\n  sum /= 2;\n \n  return sum;\n}\n\nbool eq(double x,double y){\n  double z=x-y;\n  if(z<0.000000001)return true;\n  else return false;\n}\nint check(Point O,Point A,Point B,Point C){\n  double a = S3(A.x , A.y , B.x , B.y , O.x , O.y);\n  double b = S3(B.x , B.y , C.x , C.y , O.x , O.y);\n  double c = S3(C.x , C.y , A.x , A.y , O.x , O.y);\n\n  double d = S3(A.x,A.y,B.x,B.y,C.x,C.y);\n\n  if(eq((a+b+c),d)){\n    return 1;\n  }else{\n    return -1;\n  }\n}\n\nint main(){\n  Point a,b,c,o;\n  double r;\n  double A,B,C;\n  while(cin>>a.x>>a.y){\n    if(a.x==0.0&&a.y==0.0)break;\n    cin>>b.x>>b.y>>c.x>>c.y>>o.x>>o.y>>r;\n\n    A=getDistance(a,o);\n    B=getDistance(b,o);\n    C=getDistance(c,o);\n    if(A<=r&&B<=r&&C<=r){cout<<\"b\"<<endl;continue;}\n\n    A=getDistanceSP(Segment(a,b),o);\n    B=getDistanceSP(Segment(b,c),o);\n    C=getDistanceSP(Segment(c,a),o);\n\n    if(A>=r&&B>=r&&C>=r&&check(o,a,b,c)==1){cout<<\"a\"<<endl;continue;}\n    \n    if(A>=r&&B>=r&&C>=r&&check(o,a,b,c)==-1){cout<<\"d\"<<endl;continue;}\n    cout<<\"c\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n\ndouble dot(P& a, P& b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P& a, P& b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint sign(double x){\n  if(x > EPS) return 1;\n  if(x < -EPS) return -1;\n  return 0;\n}\n\n//a -> b, a -> c\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(sign(cross(b, c)) > 0) return 1; //反時計\n  if(sign(cross(b, c)) < 0) return -1; //時計\n  if(sign(dot(b, c)) < 0) return +2; //c-a-b\n  if(norm(b) < norm(c)) return -2; //a-b-c\n  return 0; //a-c-b\n}\nbool cross(P a, P b, P c, double r){\n  double d1 = abs(c - a);\n  double d2 = abs(c - b);\n  if(d1 > d2) swap(d1, d2);\n  if(d1 < r && r < d2) return true;\n  if(ccw(a, b, c) != 1 && ccw(a, b, c) != -1) return false;\n  b -= a; c -= a;\n  double k = dot(b, c) / norm(b);\n  if(0 < k && k < 1 && abs(c - k * b) < r && r < d2) return true;\n  else return false;\n}\n\n\nstring solve(P p[3], P c, double r){\n  double maxdist = 0;\n  REP(i, 3) maxdist = max(maxdist, abs(p[i] -  c));\n  if(maxdist < r) return \"b\";\n  bool circle_in = false;\n  int ccw_v[3];\n  REP(i, 3) ccw_v[i] = ccw(p[i], p[(i + 1) % 3], c);\n  if(ccw_v[0] == ccw_v[1] && ccw_v[1] == ccw_v[2] && (ccw_v[0] == 1 || ccw_v[0] == -1)){\n    circle_in = true;\n  }\n  bool iscross = false;\n  REP(i, 3) iscross |= cross(p[i], p[(i + 1) % 3], c, r);\n  if(circle_in && !iscross) return \"a\";\n  if(iscross) return \"c\";\n  else return \"d\";\n}\n\nint main(){\n  P p[3];\n  P c; double r;\n  while(cin>>p[0].X>>p[0].Y>>p[1].X>>p[1].Y>>p[2].X>>p[2].Y>>c.X>>c.Y>>r){\n    cout<<solve(p, c, r)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\ndouble sign(double r) { return r < -EPS ? -1.0 : r > EPS ? 1.0 : 0.0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0.0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) >= 0.0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n\n// code for problem\nint x, y, r;\nvector<P> T;\nC cc;\n\nbool isPinC() {\n\tP e0 = T[0] - cc.p;\n\tP e1 = T[1] - cc.p;\n\tP e2 = T[2] - cc.p;\n\tdouble d0 = e0.det(e1);\n\tdouble d1 = e1.det(e2);\n\tdouble d2 = e2.det(e0);\n\tif(sign(d0) == sign(d1) && sign(d1) == sign(d2)) return true;\n\treturn false;\n}\n\nvoid solve() {\n\tvector<double> d(3);\n\td[0] = (T[0] - cc.p).norm();\n\td[1] = (T[1] - cc.p).norm();\n\td[2] = (T[2] - cc.p).norm();\n\tif(sign(d[0] - cc.r) <= 0.0 && sign(d[1] - cc.r) <= 0.0 && sign(d[2] - cc.r) <= 0.0) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\tbool in = isPinC();\n\tL l0(T[0], T[1]);\n\tL l1(T[1], T[2]);\n\tL l2(T[2], T[0]);\n\td[0] = l0.dSP(cc.p);\n\td[1] = l1.dSP(cc.p);\n\td[2] = l2.dSP(cc.p);\n\tif(in && sign(d[0] - cc.r) >= 0.0 && sign(d[1] - cc.r) >= 0.0 && sign(d[2] - cc.r) >= 0.0) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(!in && sign(d[0] - cc.r) > 0.0) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\tT = vector<P>(3);\n\tfor(;;) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\tT[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}\n        "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\ndouble S3( double x1, double y1, double x2,double y2, double x3, double y3 ){\n \n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);\n  sum /= 2;\n \n  return sum;\n}\n\nbool eq(double x,double y){\n  double z=x-y;\n  if(z<0.000000001)return true;\n  else return false;\n}\n\nint check(Point O,Point A,Point B,Point C){\n  double a = S3(A.x , A.y , B.x , B.y , O.x , O.y);\n  double b = S3(B.x , B.y , C.x , C.y , O.x , O.y);\n  double c = S3(C.x , C.y , A.x , A.y , O.x , O.y);\n\n  double d = S3(A.x,A.y,B.x,B.y,C.x,C.y);\n\n  if(eq((a+b+c),d)){\n    return 1;\n  }else{\n    return -1;\n  }\n}\n\nint main(){\n  Point a,b,c,o;\n  double r;\n  double A,B,C;\n  while(cin>>a.x>>a.y){\n    if(a.x==0.0&&a.y==0.0)break;\n\n    cin>>b.x>>b.y>>c.x>>c.y>>o.x>>o.y>>r;\n\n    A=getDistance(a,o);\n    B=getDistance(b,o);\n    C=getDistance(c,o);\n    if(A<=r&&B<=r&&C<=r){cout<<\"b\"<<endl;continue;}\n\n    \n    A=getDistanceSP(Segment(a,b),o);\n    B=getDistanceSP(Segment(b,c),o);\n    C=getDistanceSP(Segment(c,a),o);\n\n    if(A>=r&&B>=r&&C>=r&&check(o,a,b,c)==1){cout<<\"a\"<<endl;continue;}\n    \n    if(A>r&&B>r&&C>r&&check(o,a,b,c)==-1){cout<<\"d\"<<endl;continue;}\n\n    cout<<\"c\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Segment&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Segment&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool on_edge(const Point&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nbool Segment::parallel(const Line& l) const {line().parallel(l);}\nbool Segment::parallel(const Segment& s) const {return line().parallel(s.line());}\nbool Segment::orthogonal(const Line& l) const {return line().orthogonal(l);}\nbool Segment::orthogonal(const Segment& s) const {return line().orthogonal(s.line());}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::parallel(const Segment& s) const {return parallel(s.line());}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nbool Line::orthogonal(const Segment& s) const {return orthogonal(s.line());}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) return l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\n\nusing namespace std;\n\nstring check(const Polygon& triangle, const Circle& circle) {\n    bool b = true;\n    for(const auto& p: triangle.vertex()) b &= circle.include(p);\n    if(b) return \"b\";\n\n    double d = circle.r() + 1.0;\n    for(const auto& e: triangle.edge()) d = min(d, circle.center().distance(e));\n    if(triangle.include(circle.center())) {\n        if(circle.r() <= d) return \"a\";\n    } else {\n        if(circle.r() < d) return \"d\";\n    }\n\n    return \"c\";\n}\n\nint main() {\n    double x, y, r;\n    while(cin >> x >> y, x != 0 || y != 0) {\n        Polygon triangle;\n        triangle.add(Point(x, y));\n        cin >> x >> y; triangle.add(Point(x, y));\n        cin >> x >> y; triangle.add(Point(x, y));\n        cin >> x >> y >> r;\n        Circle circle(x, y, r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\n\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n/*\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n*/\n// (B)\nenum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.0153\", \"r\", stdin );\n\tdouble x1, y1, x2, y2, x3, y3, x4, y4, r;\n\tpoint<double> p[3];\n\tcircle<double> c;\n\twhile (cin >> p[0].x >> p[0].y >> p[1].x >> p[1].y >> p[2].x >> p[2].y >> c.c.x >> c.c.y >> c.r && p[0].x != 0. && p[0].y != 0. ){\n\t\tint cnt = ccw (p[0], p[1], c.c ) + ccw (p[1], p[2], c.c ) + ccw (p[2], p[0], c.c );\n\t\tline<double> s1; s1.a = p[0]; s1.b = p[1]; \n\t\tline<double> s2; s2.a = p[1]; s2.b = p[2];\n\t\tline<double> s3; s3.a = p[2]; s3.b = p[0];\n\t\t// 円の中心から直線へ降ろした垂線との交点\n\t\tpoint<double> h1 = proj (c.c, s1 );\t\t\n\t\tpoint<double> h2 = proj (c.c, s2 );\n\t\tpoint<double> h3 = proj (c.c, s3 );\t\t\n\n\t\tif (cnt == 3*CCW || cnt == 3*CW ){\n\t\t\tif (  dist2 (h1, c.c ) > c.r*c.r + EPS \n\t\t\t\t&& dist2 (h2, c.c ) > c.r*c.r + EPS\n\t\t\t\t&& dist2 (h3, c.c ) > c.r*c.r + EPS ){ \t\n\t\t\t\t\tcout << 'a' << endl;\t\t// 円が三角形に含まれる\n\t\t\t\t\tcontinue;\n\t\t\t}// end if\n\t\t} // end if\n\t\tif (  dist2 (p[0], c.c ) < c.r*c.r + EPS \n\t\t\t&& dist2 (p[1], c.c ) < c.r*c.r + EPS\n\t\t\t&& dist2 (p[2], c.c ) < c.r*c.r + EPS ){\n\t\t\t\tcout << 'b' << endl;\t\t// 三角形が円に含まれる\n\t\t\t\tcontinue;\n\t\t} // end if  \n\n\t\tif (!intersect (c, s1 ) && !intersect (c, s2 ) && !intersect (c, s3 ) ){\n\t\t\tcout << 'd' << endl;\t\t\t\t// 共通部分がない場合\n\t\t\tcontinue;\n\t\t} // end if\n\t\tcout << 'c' << endl;\t\t\t\t\t// 共通部分がある場合\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> C;\n\ndouble ip(C a, C b){\n    return a.real() * b.real() + a.imag() * a.imag();\n}\n\ndouble dist_lc(C p, double a, double b, double c){\n    return abs(a * p.real() + b * p.imag() + c) / abs(p);\n}\n\nint main(){\n    C p1, p2, p3, pr;\n    double r;\n    while(true){\n        int s, t;\n        scanf(\"%d%d\", &s, &t);\n        if(s == 0 && t == 0) break;\n        p1.real(s); p1.imag(t);\n        scanf(\"%d%d\", &s, &t);\n        p2.real(s); p2.imag(t);\n        scanf(\"%d%d\", &s, &t);\n        p3.real(s); p3.imag(t);\n        scanf(\"%d%d\", &s, &t);\n        pr.real(s); pr.imag(t);\n        scanf(\" %lf\", &r);\n        if(abs(p1 - pr) <= r && abs(p2 - pr) <= r && abs(p3 - pr) <= r){\n            puts(\"b\");\n            continue;\n        }\n        double a = (p1-p2).real(), b = (p1-p2).imag();\n        double c = (p2-p3).real(), d = (p2-p3).imag();\n        double e = (p3-p1).real(), f = (p3-p1).imag();\n        bool flg1 = abs(b * pr.real() - a * pr.imag() - b * pr.real() + a * pr.imag())/abs(pr) <= r;\n        bool flg2 = abs(d * pr.real() - c * pr.imag() - d * pr.real() + c * pr.imag())/abs(pr) <= r;\n        bool flg3 = abs(f * pr.real() - e * pr.imag() - f * pr.real() + e * pr.imag())/abs(pr) <= r;\n        if(flg1 || flg2 || flg3){\n            puts(\"a\");\n            continue;\n        }\n        flg1 = abs(pr - p1) <= r;\n        flg2 = abs(pr - p2) <= r;\n        flg3 = abs(pr - p3) <= r;\n        if(flg1 || flg2 || flg3){\n            puts(\"c\");\n            continue;\n        }\n        flg1 = dist_lc(pr, b, -a, -b * p1.real() + a * p1.imag()) <= r &&\n               ip(p1-p2, pr-p2) >= 0 && ip(p2-p1, pr-p1) >= 0;\n        flg2 = dist_lc(pr, d, -c, -d * p2.real() + b * p2.imag()) <= r &&\n               ip(p2-p3, pr-p3) >= 0 && ip(p3-p2, pr-p2) >= 0;\n        flg3 = dist_lc(pr, f, -e, -f * p3.real() + f * p3.imag()) <= r &&\n               ip(p3-p1, pr-p1) >= 0 && ip(p1-p3, pr-p3) >= 0;\n        if(flg1 || flg2 || flg3){\n            puts(\"c\");\n            continue;\n        }\n        puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-b,ar=d-a;\n\tP bb=b-c,br=d-b;\n\tP cc=c-a,cr=d-c;\n\tdouble a2=cross(aa,ar),b2=cross(bb,br),c2=cross(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nbool foo2(P a,P b,P p,double r){\n\tdouble t=dot(b-a,p-a);\n\tif(a==b) return false;\n\tif(t<-EPS){\n\t\t// cout<<\"a\"<<endl;\n\t\tif(r-abs(p-a)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tif(t-abs(b-a)*abs(b-a)>EPS){\n\t\t// cout<<\"b\"<<endl;\n\t\tif(r-abs(p-b)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t// cout<<\"c\"<<endl;\n\tdouble h=abs(p-a)*abs(p-a)-t*t/abs(b-a)/abs(b-a);\n\t// printf(\"%.6lf\\n\",h);\n\tif(h-r*r>EPS){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\tint cnt=0;\n\twhile(cin>>x>>y,x||y){\n\t\tcnt++;\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tP zz[3];\n\t\trep(i,3) zz[i]=z[i];\n\t\tcin>>r;\n\t\t// cout<<\"c \"<<c<<endl;\n\t\tif(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\t\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(foo2(z[0],z[1],z[3],r)||foo2(z[1],z[2],z[3],r)||foo2(z[2],z[0],z[3],r)){\n\t\t\t\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"d\\n\";\n\t\t}\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n\t// cout<<abs(P(0,0)-P(1,1))<<endl;\n}\n\n\n\n}\nmain() try{\n\t// vector<P> d;\n\t// double r;\n\t// rep(i,3){\n\t\t// double x,y;\n\t\t// cin>>x>>y;\n\t\t// d.PB(P(x,y));\n\t// }\n\t// cin>>r;\n\t// cout<<foo2(d[0],d[1],d[2],r)<<endl;\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) {\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nint ccw(P a, P b, P c) {\n  b = vec(a,b); c = vec(a,c);\n  if(sgn(outp(b,c),0.0) > 0) return +1;\n  if(sgn(outp(b,c),0.0) < 0) return -1;\n  if(sgn(inp(b,c),0.0) < 0)  return +2;\n  if(sgn(abs(b),abs(c)) < 0) return -2;\n  return 0;\n}\nbool in_triangle(vector<P> g, P p) {\n  double a = 0.0, b = 0.0;\n  REP(i,3) {\n    a += abs(outp(g[i] - p, g[(i+1)%3] - p));\n    b += outp(g[i], g[(i+1)%3]);\n  }\n  return sgn(abs(a), abs(b)) == 0;\n}\nint iCL(C c, L l) {\n  D d = dLP(l, c.p);\n  int s = sgn(d, c.r);\n  if(s < 0) return 2;\n  if(s == 0) return 1;\n  return 0;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    // a\n    if(in_triangle(tri, cir.p) &&\n       sgn(cir.r, dLP(L(tri[0], tri[1]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[1], tri[2]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[2], tri[0]), cir.p)) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(iCL(cir, L(tri[0], tri[1])) > 0 &&\n       iCL(cir, L(tri[1], tri[2])) > 0 &&\n       iCL(cir, L(tri[2], tri[0])) > 0) {\n      cout << \"c\" << endl;\n      continue;\n    }\n    cout << \"d\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-6;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return fabs(source().distance(p) + target().distance(p) - target().distance(source())) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + (v1.dot(v2) / v2.norm()) * v2);\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.center().distance(e) - circle.r() > EPS) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) >= 0) ++ccw;\n        if(e.ccw(circle.center()) <= 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\ntypedef class Point\n{\npublic:\n\tint x, y;\n\tPoint() : x(0), y(0) {}\n\tPoint(int x, int y) : x(x), y(y) {}\n\t\n\tdouble length()\n\t{\n\t\treturn sqrt((double)(x*x + y*y));\n\t}\n\t\n\tPoint operator - (const Point& p) const\n\t{\n\t\treturn Point(x -p.x, y-p.y);\n\t}\n} P;\n\ntypedef struct Triangle\n{\n\tP p1, p2, p3;\n} T;\n\ntypedef struct Circle\n{\n\tP p;\n\tint r;\n} C;\n\nT t;\nC c;\n\ndouble cross(P p1, P p2)\n{\n\treturn (double)(p1.x * p2.y - p2.x * p1.y);\n}\n\ndouble dist(P p1, P p2)\n{\n\tint dx = p1.x - p2.x;\n\tint dy = p1.y - p2.y;\n\tdouble ans = sqrt((double)(dx*dx + dy*dy));\n\treturn ans;\n}\n\ndouble ldist(P p, P e1, P e2)\n{\n\treturn abs(cross(p-e1, e2-e1)) / (e2-e1).length();\n}\n\nbool included(P p, T t)\n{\n\tdouble c1 = cross(t.p1 - p, t.p2 - p);\n\tdouble c2 = cross(t.p2 - p, t.p3 - p);\n\tdouble c3 = cross(t.p3 - p, t.p1 - p);\n\tif(c1 > 0 && c2 > 0 && c3 > 0) return true;\n\tif(c1 < 0 && c2 < 0 && c3 < 0) return true;\n\t\n\treturn false;\n}\n\nvoid solve()\n{\n\tdouble d1 = dist(t.p1, c.p);\n\tdouble d2 = dist(t.p2, c.p);\n\tdouble d3 = dist(t.p3, c.p);\n\tdouble ld1 = ldist(c.p, t.p1, t.p2);\n\tdouble ld2 = ldist(c.p, t.p2, t.p3);\n\tdouble ld3 = ldist(c.p, t.p3, t.p1);\n\t\n\tif(d1 < c.r && d2 < c.r && d3 < c.r)\n\t{\n\t\tcout << \"b\" << endl;\n\t}\n\telse if(ld1 <= c.r || ld2 <= c.r || ld3 <= c.r)\n\t{\n\t\tcout << \"c\" << endl;\n\t}\n\telse if(included(c.p, t))\n\t{\n\t\tcout << \"a\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"d\" << endl;\n\t}\n}\n\nint main(int argc, char** argv)\n{\n\tint x, y, r;\n\t\n\twhile( 1 )\n\t{\n\t\tcin >> x >> y;\n\t\tif(!x && !y) break;\t\t\n\t\tt.p1 =P(x, y);\n\t\t\n\t\tcin >> x>> y;\n\t\tt.p2 =P(x, y);\n\t\t\n\t\tcin >> x >> y;\n\t\tt.p3 = P(x, y);\n\t\t\n\t\tcin >> x >> y >> r;\n\t\tc.p =P(x, y);\n\t\tc.r = r;\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n#define self (*this)\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\nconst R pi = acos(-1);\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) { return imag(conj(a)*b); }\nR dot(const P& a, const P& b) { return real(conj(a)*b); }\nstruct L : public vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    L(R a, R b, R c){ // ax+by+c=0\n        if(fabs(a) < eps) self = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) self = L(P(-c/a,0),P(-c/a,1));\n        else self = L(P(-c/a,0), P(0,-c/b));\n    }\n    P vec() const { return self[1] - self[0]; }\n};\n\nstruct S : public vector<P> {\n    // A to B\n    S(const P &a = P(), const P &b = P()) { push_back(a); push_back(b); }\n    L toL() const { return L(self[0], self[1]); }\n    P vec() const { return toL().vec(); }\n    R len() const { return abs(vec()); }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p = P(), R r = 0) : p(p), r(r) { }\n};\n\n// CCW\nenum { CCW = +1, CW = -1, CAB = +2, ABC = -2, SAMEPOINT = 0 };\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return CCW; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return  CW; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return CAB; // c--a--b 直線上\n    if (norm(b) < norm(c)) return ABC; // a--b--c 直線上\n    return SAMEPOINT; // 2点以上が重なっている\n}\n\n// A->C方向の角ABCの大きさを[0,2*Pi]で求める\nR arg(P a, P b, P c) {\n    R th = arg((a - b) / (c - b));\n    return th > 0 ? th : th+2*pi;\n}\n\n// 交差判定\nbool col(const L &l, const L &m) {\n    return abs(cross(l.vec(), m.vec())) > eps || abs(cross(l.vec(), m[0]-l[0])) < eps;\n}\n\nbool col(const L &l, const S &s) {\n    return cross(l.vec(), s[0]-l[0])*cross(l.vec(), s[1]-l[0]) < eps;\n}\n\nbool col(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool col(const S &s, const S &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool col(const S &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nint col(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(r1 + r2 < d) return 0; // 離れている\n    if(abs(r1 + r2 - d) < eps) return 1; // 外接\n    if(abs(d - abs(r1 - r2)) < eps) return -1; // 内接\n    if(d < r1 - r2)            return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)            return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l.vec()) / norm(l.vec());\n    return l[0] + t*(l.vec());\n}\nL proj(const L& l, const L& m) {\n    return L(proj(l,m[0]), proj(l,m[1]));\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\nL refl(const L& l, const L& m) {\n    return L(refl(l,m[0]), refl(l,m[1]));\n}\n\n// 距離\nR dist(const P &p, const P &q){\n    return abs(p - q);\n}\n\nR dist(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dist(const L &l, const L &m) {\n    return col(l, m) ? 0 : dist(l, m[0]);\n}\n\nR dist(const L &l, const S &s) {\n    if (col(l, s)) return 0;\n    return min(dist(l, s[0]), dist(l, s[1]));\n}\n\nR dist(const S &s, const P &p) {\n    const P r = proj(s.toL(), p);\n    if (col(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dist(const S &s, const S &t) {\n    if (col(s, t)) return 0;\n    return min(min(dist(s, t[0]), dist(s, t[1])),\n               min(dist(t, s[0]), dist(t, s[1])));\n}\n\nR dist(const C &c, const P &p) {\n    return max(0. , abs(c.p - p) - c.r);\n}\n\n// positive -> outside\n// zero     -> on the boundaly\n// negative -> inside\nR dist(const C& c, const L& l){\n    R d = dist(l,c.p);\n    return max(0. , d - c.r);\n}\n\n// 交点\nvector<P> hit(const L &l, const L &m) {\n    R A = cross(l.vec(), m.vec());\n    R B = cross(l.vec(), l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) return {}; // parallel\n    return {m[0] + B / A * (m.vec())};\n}\n\nvector<P> hit(const S& s, const S& t) {\n    if(col(s,t)) return hit(s,t);\n    else return {};\n}\n\nvector<P> hit(const L& l, const S& s){\n    if(col(l,s)) return hit(l,s);\n    else return {};\n}\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183\n//        : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2045\nvector<P> hit(const C& c, const L& l){\n    R d = dist(l,c.p); // 中心と直線の距離\n    if(fabs(d-c.r) < eps) return { proj(l, c.p) }; // 触れている\n    if(d > c.r) return {}; // 離れている\n    P h = proj(l, c.p);\n    P u = sqrt(c.r*c.r - d*d) * (l.vec()) / abs(l.vec());\n    return {h+u, h-u};\n}\n\nvector<P> hit(const C& c, const S& s){\n    vector<P> cs = hit(c,s.toL()), res;\n    for(const P& p : cs) {\n        if(col(s,p)) res.push_back(p);\n    }\n    return res;\n}\n\nvector<P> hit(const C& c1, const C& c2){\n    if(abs(c1.p - c2.p) < 0) return {}; // 中心が同じ\n    int i = col(c1,c2);\n    if(i==0 || abs(i)==3) return {}; // 共通部分なし || 内部\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d }; // 接する\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = 2 * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return hit(c1, L(A,B,C)); // 2つの交点を持つ\n}\n\nvector<P> hit(const C& c, const G& g){\n    vector<P> res;\n    int n = g.size();\n    rep(i,n){\n        vector<P> ps = hit(c, S(g[i],g[(i+1)%n]));\n        rep(j,ps.size()) res.push_back(ps[j]);\n    }\n    return res;\n}\n\nbool inside(C c, G t){\n    int ccw1 = ccw(t[0], t[1], c.p);\n    int ccw2 = ccw(t[1], t[2], c.p);\n    int ccw3 = ccw(t[2], t[0], c.p);\n    if ( !(ccw1 == ccw2 && ccw2 == ccw3 ) ) return false;\n    rep(i,t.size()){\n        L l(t[i], t[(i+1)%3]);\n        if(c.r > dist(l, c.p)) return false;\n    }\n    return true;\n}\n\nbool inside(G t, C c){\n    rep(i,t.size()){\n        if(c.r < dist(t[i],c.p)) return false;\n    }\n    return true;\n}\n\nbool isIntersect(C c, G t){\n    rep(i,3){\n        S s(t[i], t[(i+1)%3]);\n        auto ps = hit(c,s);\n        if(ps.size()) return true;\n    }\n    return false;\n}\n\nchar solve(C c, G t){\n    if(inside(c,t)) return 'a';\n    if(inside(t,c)) return 'b';\n    if(isIntersect(c,t)) return 'c';\n    return 'd';\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b && a){\n        G t(3);\n        t[0] = P(a,b);\n        rep(i,2){\n            int a,b;\n            cin>>a>>b;\n            t[i+1] = P(a,b);\n        }\n        int a,b,r;\n        cin>>a>>b>>r;\n        C c(P(a,b),r);\n        cout << solve(c,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n\nconst double EPS=1e-9;\nconst double INFTY=1e12;\ntypedef complex<double> Point;\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x>0?1:-1;\n}\n\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tint sign=Signum(Cross(d1,d2));\n\t\n\tif(sign)\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\n// ツ点ツづ陳シツ静シツづ個仰猟猟」\ndouble DistancePL(Point p,Line l)\n{\n\treturn abs(Cross(p-l.pos,l.dir))/abs(l.dir);\n}\n// ツ点ツづ静シツ閉ェツづ個仰猟猟」\ndouble DistancePS(Point p,Line s)\n{\n\tPoint a=p-s.pos,b=s.dir;\n\tPoint c=b*Dot(a,b)/norm(b);\n\tint pos=CCW(Point(0,0),b,c);\n\tif(pos==-2 || pos==2)\n\t\treturn min(abs(a),abs(b-a));\n\treturn abs(a-c);\n}\n\nvoid solve(Point p[],Point c,double r)\n{\n\t{\t// triangle in circle\n\t\tdouble dist=0;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=max(dist,norm(p[i]-c));\n\t\tif(dist<=r*r){\n\t\t\tputs(\"b\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t{\t// circle in triangle\n\t\tbool res=true;\n\t\tint ccw=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint temp=CCW(p[i],p[(i+1)%3],c);\n\t\t\tif(temp==-2 || temp==2)\n\t\t\t\tcontinue;\n\t\t\tres&=temp*ccw>=0;\n\t\t\tccw=temp;\n\t\t}\n\t\tif(res){\n\t\t\tdouble dist=INFTY;\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tdist=min(dist,DistancePL(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\t\tif(Signum(dist-r)>=0){\n\t\t\t\tputs(\"a\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t{\t// intersect\n\t\tdouble dist=INFTY;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=min(dist,DistancePS(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\tif(Signum(dist-r)<0){\n\t\t\tputs(\"c\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tputs(\"d\");\n}\n\nint main()\n{\n\tfor(;;){\n\t\tPoint p[3],c;\n\t\tdouble r;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tcin>>real(p[i])>>imag(p[i]);\n\t\tcin>>real(c)>>imag(c)>>r;\n\t\tif(norm(p[0])==0)\n\t\t\tbreak;\n\t\t\n\t\t//for(int i=0;i<3;i++)\n\t\t//\tprintf(\"(%.3f,%.3f) \",real(p[i]),imag(p[i]));\n\t\t//printf(\"(%.3f,%.3f,%.3f)\\n\",real(c),imag(c),r);\n\t\t\n\t\tsolve(p,c,r);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\ntypedef complex<double> P;\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nint chk(P a,P b,double r){\n\tdouble t = abs(a-b) - r;\n\tif( fabs(t) < EPS ) return 0;\n\treturn t < 0 ? -1 : 1;\n}\ndouble cross(P a,P b){\n\treturn imag(a*conj(b));\n}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\n\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nint main(){\n\tP a,b,c,d;\n\tdouble r;\n\twhile(cin >> a.real() >> a.imag() , a.real() != 0 || a.imag() != 0 ){\n\t\tcin >> b.real() >> b.imag();\n\t\tcin >> c.real() >> c.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tcin >> r;\n\t\t\n\t\tint in = 0;\n\t\tint mk = cross(a-d,b-d) <= 0 ;\n\t\tif( mk == (cross(b-d,c-d) <= 0) && mk == (cross(c-d,a-d) <= 0)){\n\t\t\tin = 1;\n\t\t}\n\t\t\n\t\tif( chk(a,d,r) <= 0 &&  chk(b,d,r) <= 0 &&  chk(c,d,r) <= 0 ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( chk(a,d,r) >= 0 &&  chk(b,d,r) >= 0 &&  chk(c,d,r) >= 0){\n\t\t\tif( distanceSP(L(a,b),d) < r - EPS || distanceSP(L(b,c),d) < r - EPS || distanceSP(L(a,c),d) < r - EPS  ){\n\t\t\t\tcout << \"c\" << endl;\n\t\t\t}else if( in ){\n\t\t\t\tcout << \"a\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"d\" << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])!=IN)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(intersectCS(c,Segment(g[i],next(g,i))))return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        if(contains(g,c))puts(\"a\");\n        else if(contains(c,g))puts(\"b\");\n        else{\n            bool x=false;\n            for(int i=0;i<g.size();i++){\n                if(intersectCS(c,Segment(g[i],next(g,i))))x=true;\n            }\n            puts(x?\"c\":\"d\");\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point& a, const Point& b) { return Point{ a.px - b.px,a.py - b.py }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dst(const Point& a, const Point& b) { return abs(Minus(b , a)); }\nlong double dst(const Line& a, const Point& b) {\n\treturn dot(Minus(a.p2, a.p1), Minus(b, a.p1)) < 0.0 ? abs(Minus(b, a.p1)) : (dot(Minus(a.p1, a.p2), Minus(b, a.p2)) < 0.0 ? abs(Minus(b, a.p2)) : abs(crs(Minus(a.p2, a.p1), Minus(b, a.p1)) / abs(Minus(a.p2, a.p1))));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\twhile (true) {\n\t\tPoint r1, r2, r3, r4; long double r;\n\t\tcin >> r1.px >> r1.py; if (fabs(r1.px) <= 1e-10 && fabs(r1.py) <= 1e-10)break;\n\t\tcin >> r2.px >> r2.py >> r3.px >> r3.py >> r4.px >> r4.py >> r;\n\t\tLine l1 = Line{ r1,r2 }, l2 = { r2,r3 }, l3 = { r3,r1 };\n\t\tlong double c1 = min(dst(l1, r4), min(dst(l2, r4), dst(l3, r4)));\n\t\tlong double c2 = max(dst(r1, r4), max(dst(r2, r4), dst(r3, r4)));\n\t\tlong double c3 = min(dst(r1, r4), min(dst(r2, r4), dst(r3, r4)));\n\t\t//cout << dst(l1, r4) << ' ' << dst(l2, r4) << ' ' << dst(l3, r4) << endl;\n\t\tint c4 = contain({ r1,r2,r3 }, r4);\n\t\tif (c1 >= r && c4 != 0) { cout << \"a\" << endl; }\n\t\telse if (c2 <= r) { cout << \"b\" << endl; }\n\t\telse if (c3 <= r) { cout << \"c\" << endl; }\n\t\telse { cout << \"d\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n \nusing namespace std;\n \n#define F first\n#define S second\n \n#define X real()\n#define Y imag()\n \n#define EPS (1e-7)\n \ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\ntypedef pair<double, Point> Circle;\n \nbool isPointInCircle(const Point& p, const Circle& c) {\n  if(abs(p-c.S) < abs(c.F) + EPS) return true;\n  return false;\n}\n \ndouble dot(const Point& a, const Point& b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n \ndouble cross(const Point& a, const Point& b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n \ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n \ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n \ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n   \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n \n \nenum struct ECont { OUT, ON, IN };\nECont contains(const Polygon& poly, const Point& p) {\n  bool in = 0;\n  for(int i=0; i<poly.size(); i++) {\n    Point a = poly[i] - p, b = poly[(i+1)%poly.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag()) {\n      if(cross(a, b) < 0) in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ECont::ON;\n  }\n   \n  return in ? ECont::IN : ECont::OUT;\n}\n \nint main() {\n   \n  while(1) {\n    Polygon points(3);\n    Circle circle;\n   \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n     \n      points[i] = Point(x, y);\n    }\n   \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n   \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n     \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3) {\n      int flg = 0;\n      for(int i=0; i<3; i++) {\n        if(contains(points, circle.S) == ECont::IN) {\n        //if(dot(points[(i+1)%3]-points[i], circle.S-points[i]) * dot(points[(i+2)%3]-points[(i+1)%3], circle.S-points[(i+1)%3]) > 0) {\n          flg ++;\n        }\n      }\n      if(flg == 3) { cout << 'a' << endl; continue; }\n    }\n \n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) <= circle.F + EPS;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\n\nconst double EPS = 1e-9;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\nbool EPS_less(double lhs, double rhs) {return lhs < rhs - EPS;}\nbool EPS_equal(double lhs, double rhs) {return lhs <= rhs + EPS;}\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double d) :x(d), y(d) {}\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        if(v1.dot(v2) < -EPS) return BACKWARD;\n        if(v2.distance(Point(0, 0)) - v1.distance(Point(0, 0)) > EPS) return FORWARD;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return EPS_less(center.distance(p), r);}\n    bool include(const Segment& s) const {\n    return EPS_less(center.distance(s), r) || EPS_equal(center.distance(s), r);}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n    if(s.ccw(p) == ON) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + v2 * t;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n    for(auto& e: edge) if(circle.include(e)) return \"c\";\n\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center) > 0) ++ccw;\n        if(e.ccw(circle.center) < 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] != 0 || y[0] != 0) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<cassert>\n\n#define SQRD(a) ((a)*(a))\n\nusing namespace std;\n\nstruct Point{ Point():x(0),y(0){}Point(double x, double y):x(x),y(y){}double x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Circle():c(),r(0){} Circle(double x, double y, int r):c(x,y),r(r){}Point c; int r; };\n\nostream & operator << (ostream &os, const Point &p){\n\tos << \"(\" << p.x << \",\" << p.y << \")\";\n\treturn os;\n}\n\ninline double dist(const Point &p1, const Point &p2){\n\treturn sqrt( SQRD(p2.x-p1.x)+SQRD(p2.y-p1.y) );\n}\ninline double dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + p.y + c ) / sqrt( SQRD(a) + 1 );\n\t}\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) >= 0;\n}\ninline bool isRight(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) <= 0;\n}\n\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( isLeft( t.a, t.b, p ) && isLeft( t.b, t.c, p ) && isLeft( t.c, t.a, p ) )\n\t\treturn true;\n\tif( isRight( t.a, t.b, p ) && isRight( t.b, t.c, p ) && isRight( t.c, t.a, p ) )\n\t\treturn true;\n\treturn false;\n}\n\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r <= dist( t.a, t.b, c.c ) &&\n\t\t\tc.r <= dist( t.b, t.c, c.c ) &&\n\t\t\tc.r <= dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) <= c.r &&\n\t  dist( t.b, c.c ) <= c.r &&\n\t  dist( t.c, c.c ) <= c.r )\n\t  return true;\n  else\n\t  return false;\n}\nbool isCross(const Point &p1, const Point &p2, const Circle &c)\n{\n\tPoint a1;\n\tPoint a2;\n\tdouble d = dist(p1,p2,c.c);\n\tdouble l = dist(p1,p2);\n\t\t\t\n\tif( d > c.r )\n\t\treturn false;\n\telse{\n\t\tif( p1.x != p2.x ){\n\t\t\tdouble a = (p2.y - p1.y) / (p2.x - p1.x);\n\t\t\tdouble b = -a * p1.x + p1.y;\n\t\t\tdouble A = 1 + SQRD(a);\n\t\t\tdouble B = a * b - c.c.x - a * c.c.y;\n\t\t\tdouble C = SQRD(c.c.x) + SQRD(c.c.y) - SQRD(c.r) + SQRD(b) - 2*b*c.c.y;\n\n\t\t\ta1.x = ( -B + sqrt( SQRD(B) - A * C ) ) / A;\n\t\t\ta2.x = ( -B - sqrt( SQRD(B) - A * C ) ) / A;\n\t\t\ta1.y = a * a1.x + b;\n\t\t\ta2.y = a * a2.x + b;\n\t\t\t\n\t\t\t//cout << a1 << ' ' << a2 << endl;\n\n\t\t\tif( dist(a1,p1) <= l && dist(a1,p2) <= l ||\n\t\t\t\tdist(a2,p1) <= l && dist(a2,p2) <= l )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}else{\n\t\t\tdouble e = sqrt( SQRD(c.r) - SQRD(d) );\n\n\t\t\ta1.x = p1.x; a1.y = c.c.y - e;\n\t\t\ta2.x = p2.x; a2.y = c.c.y + e;\n\n\t\t\t//cout << a1 << ' ' << a2 << endl;\n\n\t\t\tif( dist(a1,p1) <= l && dist(a1,p2) <= l ||\n\t\t\t\tdist(a2,p1) <= l && dist(a2,p2) <= l )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( isCross(t.a,t.b,c) || isCross(t.b,t.c,c) || isCross(t.c,t.a,c) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t,c ) )\n\t\treturn 'b';\n\tif( isCross( t,c ) )\n\t\treturn 'c';\n\telse\n\t\treturn 'd';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( cin.eof() )\n\t\t\tbreak;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-4;\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / abs(a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < Eps)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) <Eps)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(a, b, point);\n}\nbool is_in_triangle(const Point& point, const Point* triangle)\n{\n\tdouble t[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tt[i] = cross(triangle[(i+1)%3] - triangle[i], point - triangle[i]);\n\n\treturn t[0] >= 0 && t[1] >= 0 && t[2] >= 0\n\t\t|| t[0] <= 0 && t[1] <= 0 && t[2] <= 0;\n}\nbool is_in_triangle(const Point& point, const Point& a, const Point& b, const Point& c)\n{\n\tPoint t[3] = { a, b, c };\n\treturn is_in_triangle(point, t);\n}\nbool is_circle_in_triangle(const Point& center, double radius, const Point* triangle)\n{\n\tif (!is_in_triangle(center, triangle))\n\t\treturn false;\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_line_point(triangle[i], triangle[(i+1)%3], center) < radius)\n\t\t\treturn false;\n\treturn true;\n}\nbool is_triangle_in_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (abs(triangle[i]-center) > radius)\n\t\t\treturn false;\n\treturn true;\n}\nbool interect_triangle_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_linesegment_point(center, triangle[i], triangle[(i+1)%3]) < radius)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tint x[4], y[4], r;\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tscanf(\"%d %d\", x+i, y+i);\n\t\tscanf(\"%d\", &r);\n\t\tif (x[0] == 0 && y[0] == 0)\n\t\t\tbreak;\n\t\tPoint p[4];\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tp[i] = Point(x[i], y[i]);\n\n\t\tif (is_circle_in_triangle(p[3], r, p))\n\t\t\tputs(\"a\");\n\t\telse if (is_triangle_in_circle(p, p[3], r))\n\t\t\tputs(\"b\");\n\t\telse if (interect_triangle_circle(p, p[3], r))\n\t\t\tputs(\"c\");\n\t\telse\n\t\t\tputs(\"d\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(){};\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nbool PinC(const P& p, const C& c) {\n\treturn abs(p-c.p) < c.r+EPS;\n}\n\nbool PinPol(const P& p, const G& pol){\n\tif(pol.size() < 2) return false;\n\tif(intersectSP({pol[0], pol[1]}, p)) return true;\n\tbool f = cross(pol[1]-pol[0], p - pol[0]) > 0;\n\tfor(int i = 1; i < pol.size(); i++) {\n\t\tauto& now = pol[i];\n\t\tauto& nxt = pol[(i+1) % pol.size()];\n\t\tif(intersectSP({nxt, now}, p)) return true;\n\t\tif(f^(cross(nxt-now, p-now)>0)) return false;\n\t}\n\treturn true;\n}\n\n//?????¨?????????????????¢???(??????????????£??????????????£?????????)\nint pos_S_C(const L&s, const C&c){\n\tif(abs(distanceSP(s,c.p)-c.r)<EPS){\n\t\treturn 1;\t//??\\?????????\n\t}\n\tif(distanceSP(s,c.p) > c.r+EPS) {\n\t\treturn 0;\t//????????£????????????\n\t}\n\tif(PinC(s[0], c) && PinC(s[1], c)){\n\t\treturn 2;\t//????????????\n\t}\n\tif(PinC(s[0], c)||PinC(s[1], c)){\n\t\treturn 3;\t//?????´???????????????\n\t}\n\treturn 4;\t//????????????\n}\n\nint main(){\n\tdouble a, b;\n\twhile(cin>>a>>b){\n\t\tif(a == 0.0 && b == 0.0) break;\n\t\tG tri;\n\t\ttri.pb({a, b});\n\t\trep(i, 2) {\n\t\t\tcin >> a >> b;\n\t\t\ttri.pb({a, b});\n\t\t}\n\t\tC c;\n\t\tcin >> a>> b;\n\t\tc.p = {a, b};\n\t\tcin >> a;\n\t\tc.r = a;\n\t\tif(PinC(tri[0], c)&& PinC(tri[1], c) && PinC(tri[2], c)){\n\t\t\tcout<<\"b\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool in = PinPol(c.p, tri), hit = false;\n\t\trep(i, 3){\n\t\t\tL l;\n\t\t\tl.pb(tri[i]);\n\t\t\tl.pb(tri[(i+1)%3]);\n\t\t\tin &= pos_S_C(l, c) <= 1;\n\t\t\thit |= pos_S_C(l, c) > 0;\n\t\t}\n\t\tif(in) cout<<\"a\"<<endl;\n\t\telse if(hit) cout<<\"c\"<<endl;\n\t\telse cout<<\"d\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nint sgn(double d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\nstruct Point {\n  double x, y;\n  Point() {}\n  Point (const double x, const double y) : x(x), y(y) {}\n  Point& operator += (const Point& other) { x += other.x; y += other.y; return *this; }\n  Point& operator -= (const Point& other) { x -= other.x; y -= other.y; return *this; }\n  Point& operator *= (const double& factor) { x *= factor; y *= factor; return *this; }\n  Point& operator /= (const double& factor) { x /= factor; y /= factor; return *this; }\n};\nusing Vector = Point;\nusing Polygon = vector<Point>;\nPoint operator + (const Point&lhs, const Point& rhs) { return Point(lhs.x + rhs.x, lhs.y + rhs.y); }\nPoint operator - (const Point& lhs, const Point& rhs) { return Point(lhs.x - rhs.x, lhs.y - rhs.y); }\nPoint operator * (const Point& lhs, const double& factor) { return Point(lhs.x * factor, lhs.y * factor); }\nPoint operator * (const double& factor, const Point& rhs) { return Point(factor * rhs.x, factor * rhs.y); }\nPoint operator / (const Point& lhs, const double& factor) { return Point(lhs.x / factor, lhs.y / factor); }\ndouble operator * (const Point& lhs, const Point& rhs) { return lhs.x * rhs.x + lhs.y * rhs.y; }\ndouble operator ^ (const Point& lhs, const Point& rhs) { return lhs.x * rhs.y - lhs.y * rhs.x; }\nbool operator == (const Point& lhs, const Point& rhs) { return sgn(lhs.x - rhs.x) == 0 && sgn(lhs.y - rhs.y) == 0; }\nbool operator != (const Point& lhs, const Point& rhs) { return !(lhs == rhs); }\nbool operator < (const Point& lhs, const Point& rhs) { return sgn(lhs.x - rhs.x) ? lhs.x < rhs.x : lhs.y < rhs.y; }\nbool operator > (const Point& lhs, const Point& rhs) { return rhs < lhs; }\nbool operator <= (const Point& lhs, const Point& rhs) { return !(lhs > rhs); }\nbool operator >= (const Point& lhs, const Point& rhs) { return !(lhs < rhs); }\nistream& operator >> (istream& is, Point& point) { return is >> point.x >> point.y; }\nostream& operator << (ostream& os, Point& point) { return os << \"(\" << point.x << \",\" << point.y << \")\"; }\ndouble norm(const Point& point) { return point.x * point.x + point.y * point.y; }\ndouble abs(const Point& point) { return sqrt(norm(point)); }\ndouble arg(const Point& point) { return atan2(point.y, point.x); }\nPoint polar(const double& a, const double& r) { return Point(cos(r) * a, sin(r) * a); }\nbool sort_x(Point lhs, Point rhs) { return sgn(lhs.x - rhs.x) ? lhs.x < rhs.x : lhs.y < rhs.y; }\nbool sort_y(Point lhs, Point rhs) { return sgn(lhs.y - rhs.y) ? lhs.y < rhs.y : lhs.x < rhs.x; }\n\nstruct Segment {\n  Point p1, p2;\n  Segment() {}\n  Segment(const Point& p1, const Point& p2) : p1(p1), p2(p2) {}\n};\nusing Line = Segment;\nistream& operator >> (istream& is, Segment& segment) { return is >> segment.p1 >> segment.p2; }\nostream& operator << (ostream& os, Segment& segment) { return os << \"(\" << segment.p1 << \",\" << segment.p2 << \")\"; }\n\nstruct Circle {\n  Point c;\n  double r;\n  Circle() {}\n  Circle(const Point& c, const double& r) : c(c), r(r) {}\n};\nistream& operator >> (istream& is, Circle& circle) { return is >> circle.c >> circle.r; }\nostream& operator << (ostream& os, Circle& circle) { return os << \"(\" << circle.c << \",\" << circle.r << \")\"; }\n\ndouble getDistanceLP(const Line& l, const Point& p) {\n  return abs((l.p2 - l.p1) ^ (p - l.p1)) / abs(l.p2 - l.p1);\n}\ndouble getDistanceSP(const Segment& s, const Point& p) {\n  if ((s.p2 - s.p1) * (p - s.p1) < -EPS) return abs(p - s.p1);\n  if ((s.p1 - s.p2) * (p - s.p2) < -EPS) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contain(const Polygon& ps, const Point& p) {\n  int n = ps.size(), x = 0;\n  for (int i = 0; i < n; i++) {\n    Point a = ps[i] - p, b = ps[(i + 1) % n] - p;\n    if (sgn(a ^ b) == 0 && sgn(a * b) != 1) return 1;\n    if (a.y > b.y) swap(a, b);\n    if (sgn(a.y) != 1 && sgn(b.y) == 1 && sgn(a ^ b) == 1) x ^= 1;\n  }\n  return x ? 2 : 0;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  Polygon ps(3);\n  Circle c;\n  while (cin >> ps[0] >> ps[1] >> ps[2] >> c.c >> c.r) {\n    bool cir_in_tri = contain(ps, c.c);\n    for (int i = 0; i < 3; i++) {\n      Segment s(ps[i], ps[(i + 1) % 3]);\n      cir_in_tri &= (sgn(getDistanceSP(s, c.c) - c.r) >= 0);\n    }\n    if (cir_in_tri) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    bool tri_in_cir = true;\n    for (int i = 0; i < 3; i++) {\n      tri_in_cir &= (sgn(abs(ps[i] - c.c) - c.r) <= 0);\n    }\n    if (tri_in_cir) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    bool intersect = false;\n    for (int i = 0; i < 3; i++) {\n      intersect |= (sgn(getDistanceSP(Segment(ps[i], ps[(i + 1) % 3]), c.c) - c.r) <= 0);\n    }\n    if (intersect) {\n      cout << \"c\" << endl;\n      continue;\n    }\n    cout << \"d\" << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-b,ar=d-a;\n\tP bb=b-c,br=d-b;\n\tP cc=c-a,cr=d-c;\n\tdouble a2=cross(aa,ar),b2=cross(bb,br),c2=cross(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nbool foo2(P a,P b,P p,double r){\n\tdouble t=dot(b-a,p-a);\n\tif(a==b) return false;\n\tif(t<-EPS){\n\t\t// cout<<\"a\"<<endl;\n\t\tif(r-abs(p-a)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tif(t-abs(b-a)*abs(b-a)>EPS){\n\t\t// cout<<\"b\"<<endl;\n\t\tif(r-abs(p-b)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t// cout<<\"c\"<<endl;\n\tdouble h=abs(p-a)*abs(p-a)-t*t/abs(b-a)/abs(b-a);\n\t// printf(\"%.6lf\\n\",h);\n\tif(h-r*r>EPS){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\tint cnt=0;\n\twhile(cin>>x>>y,x||y){\n\t\tcnt++;\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tP zz[3];\n\t\trep(i,3) zz[i]=z[i];\n\t\tcin>>r;\n\t\tif(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(r-t>EPS){\n\t\t\t\t// cout<<\"i \"<<i<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(foo2(z[0],z[1],z[3],r)||foo2(z[1],z[2],z[3],r)||foo2(z[2],z[0],z[3],r)){\n\t\t\t\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"d\\n\";\n\t\t}\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n\t// cout<<abs(P(0,0)-P(1,1))<<endl;\n}\n\n\n\n}\nmain() try{\n\t// vector<P> d;\n\t// double r;\n\t// rep(i,3){\n\t\t// double x,y;\n\t\t// cin>>x>>y;\n\t\t// d.PB(P(x,y));\n\t// }\n\t// cin>>r;\n\t// cout<<foo2(d[0],d[1],d[2],r)<<endl;\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <vector>\n\nusing namespace std;\n \n//-------------------------------------------------------------------------\n// geometric library\n \nnamespace geometry {\n \n#define EPS 1E-10 ///< 0とみなすサイズ。適当\n \n    struct point {\n        double x;\n        double y;\n \n\t\tpoint() {}\n\t\tpoint(double x, double y) : x(x), y(y) {}\n        point& operator += (const point& rhs) { x += rhs.x; y += rhs.y; return *this; }\n        point& operator -= (const point& rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n        point& operator /= (double factor) { x /= factor; y /= factor; return *this; }\n        point& operator *= (double factor) { x *= factor; y *= factor; return *this; }\n        bool operator == (const point& rhs) const { return (std::abs(x - rhs.x) < EPS) && (std::abs(y - rhs.y) < EPS); }\n        bool operator != (const point& rhs) const { return !(*this == rhs); }\n        bool operator <= (const point& rhs) const { return x < rhs.x || (x == rhs.x && y <= rhs.y); }\n        bool operator >= (const point& rhs) const { return x > rhs.x || (x == rhs.x && y >= rhs.y); }\n        bool operator < (const point& rhs) const { return !(*this >= rhs); }\n        bool operator > (const point& rhs) const { return !(*this <= rhs); }\n\t\tdouble arg() const { return atan2(y, x); }\n        double norm() const { return sqrt(x * x + y * y); }\n\t\tpoint get_normal() const { return point(-y, x); }\n    };\n\ttypedef point vec2d;\n \n    struct circle {\n        point center;\n        double radius;\n\t\tcircle() {}\n\t\tcircle(double x, double y, double r) : center(x, y), radius(r) {}\n    };\n \n\tstruct triangle {\n\t\tpoint p[3];\n\t};\n\n    enum rotate_dir {\n        rotate_None = 0,\n        rotate_CW = 1,\n        rotate_CCW = -1\n    };\n \n    point operator + (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p += p2;\n        return p;\n    }\n \n    point operator / (const point& p1, double factor)\n    {\n        point p(p1);\n        p /= factor;\n        return p;\n    }\n  \n    point operator * (const point& p1, double factor)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator * (double factor, const point& p1)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator - (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p -= p2;\n        return p;\n    }\n \n    std::istream& operator >> (std::istream& is, point& p)\n    {\n        is >> p.x >> p.y;\n        return is;\n    }\n\n    std::istream& operator >> (std::istream& is, circle& c)\n    {\n        is >> c.center >> c.radius;\n        return is;\n    }\n\n    ///! 2点の距離\n    double get_distance(const point& p1, const point& p2)\n    {\n        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    }\n\n    double cross_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.y - p2.x * p1.y;\n    }\n \n    double inner_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n\t///! 直線s-eにpを投影した点を求める\n\tpoint get_project(const point& s, const point& e, const point& p)\n\t{\n\t\tdouble scale = inner_product(p - s, e - s) / (e - s).norm();\n\t\treturn s + scale * (e - s) / (e - s).norm();\n\t}\n \n    ///! p1-p2-p3が左右どちらの方向に折れているかを判定\n    rotate_dir direction(const point& p1, const point& p2, const point& p3)\n    {\n        point p1_p3 = p1 - p3;\n        point p2_p3 = p2 - p3;\n        double cross = cross_product(p1_p3, p2_p3);\n \n        if (std::abs(cross) < EPS) {\n            return rotate_None;\n        }\n        else if (cross > 0) {\n            return rotate_CW;\n        }\n        else {\n            return rotate_CCW;\n        }\n    }\n \n    ///! (p1s, p1e)と(p2s, p2e)の線分交差判定.EPS以下で接している場合はtrue、重なっている場合はfalse\n    bool intersect(const point& p1s, const point& p1e, const point& p2s, const point& p2e)\n    {\n        assert(p1s != p1e && p2s != p2e);\n        return\n            (direction(p1s, p1e, p2s) != direction(p1s, p1e, p2e)) &&\n            (direction(p2s, p2e, p1s) != direction(p2s, p2e, p1e));\n    }\n\n\t///! 三角形と円の交差判定。ちょうど接している場合はtrue\n\tbool intersect(const circle& c, const triangle& t)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tpoint q = get_project(t.p[i], t.p [(i + 1) % 3], c.center);\n\t\t\tif (get_distance(q, c.center) < c.radius - EPS) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} \n\n    ///! targetが三角形p1,p2,p3の内部にあるかどうか\n    bool is_inside_triangle(const point& target, const point& p1, const point& p2, const point& p3)\n    {\n        point center_of_gravity = (p1 + p2 + p3) / 3; // 重心\n \n        if (center_of_gravity == target) return true;\n \n        // 重心とtargetを結んだ線分が三角形の辺と交叉するなら、点は三角形の外部にある\n        bool intersect_any =\n            intersect(p1, p2, center_of_gravity, target) ||\n            intersect(p2, p3, center_of_gravity, target) ||\n            intersect(p3, p1, center_of_gravity, target);\n \n        return !intersect_any;\n    }\n\n    ///! targetが三角形tの内部にあるかどうか\n\tbool is_inside_triangle(const point& target, const triangle& t)\n\t{\n\t\treturn is_inside_triangle(target, t.p[0], t.p[1], t.p[2]);\n\t}\n\n    ///! 円が三角形tの内部にあるかどうか\n\tbool is_inside_triangle(const circle& c, const triangle& t)\n\t{\n\t\tif (is_inside_triangle(c.center, t) && !intersect(c, t)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t///! 三角形が円cの内部にあるかどうか\n\tbool is_inside_circle(const triangle& t, const circle& c)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (get_distance(t.p[i], c.center) > c.radius + EPS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n} // namespace geometry\n\n//-----------------------------------------------\n//\n\nusing namespace geometry;\n\nint main(void) {\n\ttriangle triangle;\n\tcircle circle;\n\n\twhile (cin >> triangle.p[0]) {\n\t\tif (triangle.p[0].x == 0 && triangle.p[0].y == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> triangle.p[1] >> triangle.p [2] >> circle;\n\n\t\tif (is_inside_triangle(circle, triangle)) {\n\t\t\tcout << \"a\" << endl;\n\t\t} else if (is_inside_circle(triangle, circle)) {\n\t\t\tcout << \"b\" << endl;\n\t\t} else if (intersect(circle, triangle)) {\n\t\t\tcout << \"c\" << endl;\n\t\t} else {\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef long double Double;\ntypedef complex<Double> P;\n#define Y imag()\n#define X real()\nconst Double EPS = (long double) 1 * 1e-12;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nDouble get(P a[3]){\n\tDouble A = abs(a[0]-a[1]);\n\tDouble B = abs(a[1]-a[2]);\n\tDouble C = abs(a[2]-a[0]);\n\tDouble s = (A+B+C) / 2.0;\n\tDouble S = sqrt( s * (s-A) * (s-B) * (s-C) );\n\treturn S;\n}\nDouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \nDouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {Double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nDouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;Double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tDouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\tbool in = abs(S) < EPS;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) < r - EPS || getPedal(L(a[1],a[2]),c) < r - EPS || getPedal(L(a[0],a[2]),c) < r - EPS;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) < r*r && nijo(a[1]-c) < r*r && nijo(a[2]-c) < r*r) cout << \"b\" << endl;\n\t\telse if(in && !hit) cout << \"a\" << endl;\n\t\telse if(hit) cout << \"c\" << endl;\n\t\telse cout << \"d\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\n\nconst double EPS = 1e-9;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\nbool EPS_less(double lhs, double rhs) {return lhs < rhs - EPS;}\nbool EPS_equal(double lhs, double rhs) {return lhs <= rhs + EPS;}\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        if(v1.dot(v2) < -EPS) return BACKWARD;\n        if(v2.distance(Point(0, 0)) - v1.distance(Point(0, 0)) > EPS) return FORWARD;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return EPS_less(center.distance(p), r);}\n    bool include(const Segment& s) const {\n        return EPS_less(center.distance(s), r) || EPS_equal(center.distance(s), r);}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n    if(s.ccw(p) == ON) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + Point(t, t) * v2;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n    for(auto& e: edge) if(circle.include(e)) return \"c\";\n\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center) > 0) ++ccw;\n        if(e.ccw(circle.center) < 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-7\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0,double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n  Point operator * (double a){ return Point(x*a, y*a); }\n  Point operator / (double a){ return Point(x/a, y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nclass Segment{\npublic:\n  Vector t,s;\n  Segment(Vector t,Vector s) : t(t),s(s) {}\n  Point projection(Point &p){\n    Vector b = s - t;\n    double d = dot(p-t,b) / b.norm();\n    return t + b*d;\n  }\n};\n\nclass Circle{\npublic:\n  double x,y,r;\n  Circle(double x = 0.0,double y = 0.0,double r = 0.0) : x(x),y(y),r(r) {}\n};\n\nPoint point[3];\nCircle ci;\n\nbool check(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return false;\n  if(cross(a,b) < -EPS) return false;\n  if(dot(a,b) < -EPS) return false;\n  if(a.norm() < b.norm()) return false;\n  return true;\n}\n\ntypedef Segment Line;\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.s-l.t,p-l.t)/(l.s-l.t).abs());\n}\n\ndouble getDistanceSP(Segment seg,Point p){\n  if(dot(seg.s-seg.t,p-seg.t) < 0.0) return (p-seg.t).abs();\n  if(dot(seg.t-seg.s,p-seg.s) < 0.0) return (p-seg.s).abs(); \n  return getDistanceLP(seg,p);\n}\n\nint getStateCS(Circle c,Segment seg){\n  Point cp = Point(c.x,c.y);\n  Point p = seg.projection(cp);\n  Point pp = p - cp;\n  Vector a = seg.t - cp;\n  Vector b = seg.s - cp;\n    \n  if(a.abs() > c.r && b.abs() > c.r){\n    if(pp.abs()+EPS > c.r && check(seg.t,seg.s,p)){\n      return 1;\n    }\n  }else if(a.abs() < c.r && b.abs() < c.r){\n    if(pp.abs()-EPS < c.r && check(seg.t,seg.s,p)){\n      return 2;\n    }\n  }\n  return 3;\n}\n\nbool isCross(){\n  Point cp = Point(ci.x,ci.y);\n  for(int i = 0 ; i < 3 ; i++){\n    Point p = point[i];\n    Point diff = p - cp;\n    if(diff.abs() == ci.r) return true;\n  }\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  \n  for(int i = 0 ; i < 3 ; i++){\n    if(getDistanceSP(seg[i],cp) < ci.r){\n      return true;\n    }\n  }\n\n  for(int i = 0 ; i < 3 ; i++){\n    Segment ns = seg[i];\n    Point p1 = ns.t, p2 = ns.s;\n    if(p1.abs() < ci.r && p2.abs() > ci.r) return true;\n    if(p1.abs() > ci.r && p2.abs() < ci.r) return true;\n  }\n\n  return false;\n}\n\nvoid judge(){\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n\n  int TinC = 0,CinT = 0;\n  for(int i = 0 ; i < 3 ; i++){\n    int N = getStateCS(ci,seg[i]);\n    if(N == 1){\n      TinC++;\n    }else if(N == 2){\n      CinT++;\n    }\n  }\n  if(TinC == 3){\n    cout << 'a' << endl;\n  }else if(CinT == 3){\n    cout << 'b' << endl;\n  }else{\n    if(isCross()){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}\n\nint main(){\n  while(true){\n    cin >> point[0].x >> point[0].y;\n    if(!point[0].x && !point[0].y) break;\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> point[i+1].x >> point[i+1].y;\n    }\n    cin >> ci.x >> ci.y >> ci.r;\n    judge();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn (((cross(a,b)>0||EQ(0,cross(a,b)))&&(cross(b,c)>=0||EQ(0,cross(b,c)))&&(cross(c,a)>=0||EQ(0,cross(a,b))))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ninline D inprd(const P &a, const P &b){ return (conj(a) * b).X; }\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\ninline D sign(D d){ return (d<0)?-1:d>0?1:0; }\n\nD distance_l_p(const P &a, const P &b, const P &c){\n    return abs(outprd(b-a, c-a)) / abs(b-a);\n}\nbool is_intriangle(const P &p1, const P &p2, const P &p3, const P &q){\n    D s1 = sign(outprd(p2-p1,q-p1)), s2 = sign(outprd(p3-p2,q-p2)), s3 = sign(outprd(p1-p3,q-p3));\n    return (s1 == s2 && s2 == s3);\n}\ninline P circum_center(const P &a, const P &b, const P &c){\n    P bc = c - b, ca = a - c, ab = b - a;\n    return (a + b - (inprd(bc, ca) / outprd(ab, bc)) * ab * P(0,1)) / 2.0;\n}\n\nstring solve(P p1, P p2, P p3, P pc, int r){\n    D dr = r;\n    if(is_intriangle(p1,p2,p3,pc)){\n        if( distance_l_p(p1,p2,pc) >= dr - EPS &&\n            distance_l_p(p2,p3,pc) >= dr - EPS &&\n            distance_l_p(p3,p1,pc) >= dr - EPS) return \"a\";\n    }\n    if(norm(p1-pc) < r*r && norm(p2-pc) < r*r && norm(p3-pc) < r*r) return \"b\";\n    if(norm(p1-pc) > r*r && norm(p2-pc) > r*r && norm(p3-pc) > r*r) return \"d\";\n    return \"c\";\n}\n\nint main(){\n    P p1,p2,p3,pc;\n    int r;\n    int x, y;\n    while(cin >> x >> y && x && y){\n        p1 = P(x,y);\n        cin >> x >> y;\n        p2 = P(x,y);\n        cin >> x >> y;\n        p3 = P(x,y);\n        cin >> x >> y >> r;\n        pc = P(x,y);\n        cout << solve(p1,p2,p3,pc,r) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r+EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r+EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b,r;\n\twhile(cin>>a>>b,a||b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\tcin>>a>>b;\n\t\tg[1]=P(a,b);\n\t\tcin>>a>>b;\n\t\tg[2]=P(a,b);\n\t\tg=convex_hull(g);\n\t\tcin>>a>>b>>r;\n\t\tC c(P(a,b),r);\n\t\tif(inconvex(g,c.c)\n\t\t\t&&distanceSP(L(g[0],g[1]),c.c)+EPS>c.r\n\t\t\t&&distanceSP(L(g[1],g[2]),c.c)+EPS>c.r\n\t\t\t&&distanceSP(L(g[2],g[0]),c.c)+EPS>c.r)cout<<\"a\"<<endl;\n\t\telse if(abs(g[0]-c.c)<EPS+c.r&&abs(g[1]-c.c)<EPS+c.r&&abs(g[2]-c.c)<EPS+c.r)cout<<\"b\"<<endl;\n\t\telse if(intersectCS(c,L(g[0],g[1]))||intersectCS(c,L(g[2],g[1]))||intersectCS(c,L(g[0],g[2])))cout<<\"c\"<<endl;\n\t\telse cout<<\"d\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-4;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) < c.r - kyuriEPS ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r + kyuriEPS){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs( (t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x) );\n\t}\n\t//std::cout << area << \" \" << tS2 << std::endl;\n\t\n\tif( fabs( fabs(area) - tS2 ) < kyuriEPS ) return 0; \t\n\t\n\treturn 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P p;double r;};    //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(L a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//??´?????¨??´????????¢??? verified AOJ CGL_2\nint rLL(L a,L b){\n    if( cross(vec(a),vec(b))==0 ) return 2; //??????\n    if( dot(vec(a),vec(b))==0 )   return 1; //?????´\n    return 0;\n}\n\n// ?????¨??????????????????\nint contains(C c, P p){\n    double d = (c.p-p).abs();\n    if(d-c.r>EPS) return OUT;\n    if(abs(d-c.r)<EPS) return ON;\n    return IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n    if( dLP(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(L s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, L l){\n    int c1 = contains(c, l.p1);\n    int c2 = contains(c, l.p2);\n    if(c1 > c2) swap(c1, c2);\n    \n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (??\\????????¨???)\n    double d = dSP(l, c.p);\n    if(d-c.r<-EPS) return true;\n    if(d-c.r>EPS) return false;\n    return true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n    int c=0;\n    rep(i,pol.size()){\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n    }\n    if( c%pol.size() )return OUT;\n    return IN;\n}\n\n//?????¨???????§???¢???????????¶???????????????\nint CPOLarea(C c ,Polygon pol){\n    vector<L> lines;\n    vector<int> res(pol.size());\n    bool POLinC=true, isFar=true;\n    \n    rep(i,pol.size()){\n        if( contains(c,pol[i])==OUT )POLinC=false;\n        res[i] = contains(c,pol[i]);\n        lines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n        if( sqDist(c.p,pol[i])<=c.r*c.r )isFar=false;\n    }\n    \n    rep(i,lines.size()) if( iCS(c,lines[i]) )           return 1;   //????§???¢??¨????????????c\n    if( isPointInsidePolygon(pol, c.p)==IN && isFar )   return 3;   //????§???¢????????¨??????a\n    if( POLinC )                                        return 2;   //????§???¢??????????????¨b\n    return 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps),cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????´???????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b&&(a||b)){\n        Polygon pol(3);\n        pol[0] = P(a,b);\n        rep(i,2)cin>>pol[i+1].x>>pol[i+1].y;\n        C c;\n        cin>>c.p.x>>c.p.y>>c.r;\n        int res =  CPOLarea(c,pol);\n        \n        cout<<(char)('a'+(3-res))<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) {\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nint ccw(P a, P b, P c) {\n  b = vec(a,b); c = vec(a,c);\n  if(sgn(outp(b,c),0.0) > 0) return +1;\n  if(sgn(outp(b,c),0.0) < 0) return -1;\n  if(sgn(inp(b,c),0.0) < 0)  return +2;\n  if(sgn(abs(b),abs(c)) < 0) return -2;\n  return 0;\n}\nint containsGP(vector<P> g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(g[i], g[(i+1)%g.size()], p) == 0) return 0;\n    P a = vec(p, g[i]);\n    P b = vec(p, g[(i+1)%g.size()]);\n    if(a.y > b.y) swap(a, b);\n    if(sgn(a.y, 0.0) <= 0 && sgn(b.y, 0.0) > 0 && sgn(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\nint iCS(C c, L s) {\n  if(sgn(abs(c.p - s.a), c.r) <= 0 && sgn(abs(c.p - s.b), c.r) <= 0)\n    return -2;\n  if(sgn(abs(c.p - s.a), c.r) <= 0 || sgn(abs(c.p - s.b), c.r) <= 0)\n    return -1;\n  if(sgn(dLP(s, c.p), c.r) < 0)\n    return +2;\n  if(sgn(dLP(s, c.p), c.r) == 0)\n    return +1;\n  return 0;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    // a\n    if(containsGP(tri, cir.p) >= 0 &&\n       sgn(cir.r, dLP(L(tri[0], tri[1]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[1], tri[2]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[2], tri[0]), cir.p)) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(iCS(cir, L(tri[0], tri[1])) == 0 &&\n       iCS(cir, L(tri[1], tri[2])) == 0 &&\n       iCS(cir, L(tri[2], tri[0])) == 0) {\n      cout << \"d\" << endl;\n      continue;\n    }\n    cout << \"c\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst double eps = 1e-8;\nint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\ndouble distDbl(double ax, double ay, double bx, double by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\nint distDbl(int ax, int ay, int bx, int by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\ndouble getPerpDistDbl(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, res;\n    if (ax == bx) {\n        res = (cx - ax) * (cx - ax);\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        res = (a * cx - cy + b) * (a * cx - cy + b) / (1 + a * a);\n    }\n    return res;\n}\n\ndouble getPerpDistSegDbl(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, x, y, res;\n    if (ax == bx) {\n        y = cy;\n        if (min(ay, by) <= y && y <= max(ay,by)) {\n            res = (cx - ax) * (cx - ax);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        x = (cx + a * (cy - b)) / (1 + a * a);\n        y = a * x + b;\n        if (min(ax, bx) <= x && x <= max(ax,bx) &&\n            min(ay, by) <= y && y <= max(ay,by)) {\n            res = distDbl(x,y,cx,cy);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    }\n    return res;\n}\n\nbool isA() {\n    int c = 0;\n    if (0 <= (x2-x1)*(y4-y1)-(y2-y1)*(x4-x1)) ++c;\n    if (0 <= (x3-x2)*(y4-y2)-(y3-y2)*(x4-x2)) ++c;\n    if (0 <= (x1-x3)*(y4-y3)-(y1-y3)*(x4-x3)) ++c;\n    if (c % 3 != 0) return false;\n    if (getPerpDistDbl(x1, y1, x2, y2, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x2, y2, x3, y3, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x3, y3, x1, y1, x4, y4) + eps < r*r) return false;\n    return true;\n}\n\nbool isB() {\n    if (distDbl(x1,y1,x4,y4) <= r*r && distDbl(x2,y2,x4,y4) <= r*r && distDbl(x3,y3,x4,y4) <= r*r) {\n        return true;\n    }\n    return false;\n}\n\nbool isC() {\n    if (getPerpDistSegDbl(x1,y1,x2,y2,x4,y4) <= r*r + eps) return true;\n    if (getPerpDistSegDbl(x2,y2,x3,y3,x4,y4) <= r*r + eps) return true;\n    if (getPerpDistSegDbl(x3,y3,x1,y1,x4,y4) <= r*r + eps) return true;\n    return false;\n}\n\nint main() {\n    while (cin >> x1 >> y1, (x1 || y1)) {\n        cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n        if (isB()) cout << \"b\" << endl;\n        else if (isA()) cout << \"a\" << endl;\n        else if (isC()) cout << \"c\" << endl;\n        else cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define EPS 1E-10\n#define SAME_SIGN( a , b ) a * b > EPS\n\nnamespace geometry{\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius + EPS ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.b , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.c , cir.center ) <= cir.radius\n\t\t){\n\t\t\tstd::cout << 'b' << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << 'a' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << 'd' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << 'c' << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << 'c' << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\npair<int, int> a;\npair<int, int> b;\npair<int, int> c;\npair<int, int> o;\nint r;\n\nint dot(pair<int, int> p1, pair<int, int> p2){\n  return p1.first * p2.first + p1.second * p2.second;\n}\n\nint cross(pair<int, int> p1, pair<int, int> p2){\n  return p1.first * p2.second - p1.second * p2.first;\n}\n\ndouble norm(pair<int, int> p){\n  return p.first * p.first + p.second * p.second;\n}\n\ndouble length(pair<int, int> p){\n  return sqrt(p.first * p.first + p.second * p.second);\n}\n\nbool is_inside(){\n  if(cross(make_pair(b.first-a.first, b.second-a.second), \n\t   make_pair(o.first-a.first, o.second-a.second)) < 0) return false;\n  if(cross(make_pair(c.first-b.first, c.second-b.second), \n\t   make_pair(o.first-b.first, o.second-b.second)) < 0) return false;\n  if(cross(make_pair(a.first-c.first, a.second-c.second), \n\t   make_pair(o.first-c.first, o.second-c.second)) < 0) return false;\n  return true;\n}\n\ndouble dist(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3){\n  pair<int, int> p4 = make_pair(p2.first - p1.first, p2.second - p1.second);\n  pair<int, int> p5 = make_pair(p3.first - p1.first, p3.second - p1.second);\n  double tmp = length(p4);\n  return abs((double)cross(p4, p5) / tmp);\n}\n\ndouble dist2(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3){\n  pair<int, int> p7 = make_pair(p2.first - p1.first, p2.second - p1.second);\n  pair<int, int> p4 = make_pair(p1.first - p2.first, p1.second - p2.second);\n  pair<int, int> p5 = make_pair(p3.first - p2.first, p3.second - p2.second);\n  pair<int, int> p6 = make_pair(p3.first - p1.first, p3.second - p1.second);\n  if(dot(p7, p6) < 0) return length(p6);\n  if(dot(p4, p5) < 0) return length(p5);\n  return dist(p1, p2, p3);\n}\n\nmain(){\n  while(cin >> a.first >> a.second && a.first && a.second){\n    cin >> b.first >> b.second;\n    cin >> c.first >> c.second;\n    cin >> o.first >> o.second;\n    cin >> r;\n    if(norm(make_pair(a.first-o.first, a.second-o.second)) < (double)r*r+EPS && \n       norm(make_pair(b.first-o.first, b.second-o.second)) < (double)r*r+EPS &&\n       norm(make_pair(c.first-o.first, c.second-o.second)) < (double)r*r+EPS){\n      cout << \"b\" << endl;\n      continue;\n    }\n    else if(is_inside()){\n      if(dist(b, c, o) > (double)r-EPS && \n\t dist(a, c, o) > (double)r-EPS && \n\t dist(a, b, o) > (double)r-EPS){\n\tcout << \"a\" << endl;\n\tcontinue;\n      }\n    }\n    if(dist2(b, c, o) < (double)r+EPS ||\n       dist2(a, c, o) < (double)r+EPS ||\n       dist2(a, b, o) < (double)r+EPS){\n      cout << \"c\" << endl;\n      continue;\n    }\n    cout << \"d\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-10\n\nusing namespace std;\n\nstruct Point \n{\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    \n\tdouble distance (const Point &o) const \n\t{\n        return sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));\n    }\n\n    Point operator+(const Point &o) const \n\t{\n        return Point(x+o.x, y+o.y);\n    }\n \n    Point operator-(const Point &o) const \n\t{\n        return Point(x-o.x, y-o.y);\n    }\n \t\n    Point operator*(const double m) const \n\t{\n   \t   return Point(x*m, y*m);\n    }\n\n    Point operator/(const double d) const \n\t{\n       return Point(x/d, y/d);\n    }\n\n    double cross(const Point &o) const \n\t{\n       return x * o.y - y * o.x;\n    }\n \n    double dot(const Point &o) const \n\t{\n        return x * o.x + y * o.y;\n    }\n \n    double atan() const \n\t{\n        return atan2(y, x);\n    }\n\n    double norm() const \n\t{\n        return sqrt(dot(*this));\n    }\n\n\tdouble area_abs(const Point &a,const Point &b) const\n\t{\n\t\tdouble t = (a.x - x) * (b.y - y);\n\t\tdouble t2 = (a.y - y) * (b.x - x);\n\t\tdouble areas = abs(t-t2);\n\t\treturn areas/2;\n\t}\n\n\t//符号付き面積\n\tdouble area(const Point &a,const Point &b)\n\t{\n\t\treturn ((a.x - x) * (b.y - y)) + ((b.x - x) * (y - a.y));\n\t}\n\t//線分abが自身の含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)\n\t\t{\n\t\t\treturn ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t\t}\n\t}\n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n\t\tif((b-a).dot(*this-a) < EPS) \n\t\t{\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS)\n\t\t{\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n\n\t//点a,b,cからなる三角形の中に自身が含まれているかどうか\n\tbool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n\t\tdouble t = (b-a).cross(*this-b);\n\t\tdouble t2 = (c-b).cross(*this-c);\n\t\tdouble t3 = (a-c).cross(*this-a);\n\t\t\n\t\tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\nint main()\n{\n\tdouble a,b;\n\twhile(cin >> a >> b)\n\t{\n\t\tif(a == 0 && b == 0) break;\n\t\t\n\t\tvector<Point> t;\n\t\tt.push_back(Point(a,b));\n\n\t\trep(i,2)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tt.push_back(Point(a,b));\n\t\t}\n\n\t\tdouble r;\n\t\tcin >> a >> b >> r;\n\t\tPoint c(a,b);\n\n\t\tint cnt = 0;\n\n\t\trep(i,3)\n\t\t{\n\t\t\tif(t[i].distance(c) > r)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tif(cnt == 0) cout << \"b\" << endl;\n\t\telse if(cnt == 1 || cnt == 2) cout << \"c\" << endl;\n\t\telse\n\t\t{\n\t\t\tbool flag = false;\n\n\t\t\tif(c.distance_seg(t[0],t[1]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[1],t[2]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[2],t[0]) < r) flag = true;\n\t\t\t\n\t\t\tif(flag) cout << \"c\" << endl;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(c.hitPolygon(t[0],t[1],t[2]))\n\t\t\t\t{\n\t\t\t\t\tcout << \"a\" << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool flag2 = false;\n\n\t\t\t\t\tif(fabs(c.distance_seg(t[0],t[1])-r) < EPS) flag2 = true;\n\t\t\t\t\tif(fabs(c.distance_seg(t[1],t[2])-r) < EPS) flag2 = true;\n\t\t\t\t\tif(fabs(c.distance_seg(t[2],t[0])-r) < EPS) flag2 = true;\n\n\t\t\t\t\tif(flag2) cout << \"c\" << endl;\n\t\t\t\t\telse cout << \"d\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P p, const P q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P p, const P q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& p_, double r_) : p(p_), r(r_) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\tif(nm == 0.0) return min(distP2P(p, l[0]), distP2P(p, l[1]));\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0.0 && d1 * d2 > 0.0 && d2 * d0 > 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(3);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] < cc.r && d[1] < cc.r && d[2] < cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL l1(tr[1], tr[2]);\n\tL l2(tr[2], tr[0]);\n\td[0] = distP2LS(cc.p, l0);\n\td[1] = distP2LS(cc.p, l1);\n\td[2] = distP2LS(cc.p, l2);\n\tif(in && d[0] > cc.r && d[1] > cc.r && d[2] > cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect ?\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tP p = P(x, y);\n\t\tcc = C(p, r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) { // ??´???l???????????????p?????????\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nint ccw(P a, P b, P c) { // ????????£???????????????????????¨???????????????????????¨????????????\n  b = vec(a,b); c = vec(a,c);\n\n  // a - b - c ????????????????????¨???\n  if(sgn(outp(b,c),0.0) > 0) return +1; // ???????¨???????\n  if(sgn(outp(b,c),0.0) < 0) return -1; // ????¨???????\n\n  // a - b - c ?????´??????????????¶??¨???\n  // sgn???????????????????£????????????£?????????\n  if(sgn(inp(b,c),0.0) < 0)  return +2; // c - a - b\n  if(sgn(abs(b),abs(c)) < 0) return -2; // a - b - c\n  return 0;                             // a - c - b\n}\n// ON = 0, IN = 1, OUT = -1\nint containsGP(vector<P> g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(g[i], g[(i+1)%g.size()], p) == 0) return 0;\n    P a = vec(p, g[i]);\n    P b = vec(p, g[(i+1)%g.size()]);\n    if(a.y > b.y) swap(a, b);\n    if(sgn(a.y, 0.0) <= 0 && sgn(b.y, 0.0) > 0 && sgn(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    // a\n    if(containsGP(tri, cir.p) == 1 &&\n       sgn(cir.r, dLP(L(tri[0], tri[1]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[1], tri[2]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[2], tri[0]), cir.p)) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) > 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) > 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) > 0) {\n      cout << \"d\" << endl;\n      continue;\n    }\n    cout << \"c\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\nif(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\nreturn a+b;\n}\n\nstruct point{\ndouble x, y;\npoint(){}\npoint(double x,double y) : x(x) , y(y){}\n\npoint operator + (point p){\nreturn point(add(x,p.x), add(y,p.y));\n}\n\npoint operator - (point p){\nreturn point(add(x,-p.x), add(y,-p.y));\n}\n\npoint operator * (double d){\nreturn point(x*d,y*d);\n}\n\npoint operator / (double d){\nreturn point(x/d,y/d);\n}\n\nbool operator == ( const point &p ) const {\nreturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n}\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\nreturn sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\nif ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\nif ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\nreturn abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\nreturn sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\nreturn cross(b-a, c-a)==0.0 &&\n(dot(b-a, c-a) > -EPS) &&\n(dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\nif(cross(a1-a2,b1-b2)==0){\nreturn is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2)\n|| is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n}\nelse {\nreturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n}\n\nint crossCS(point a, point b, circle c){\ndouble res=distance_ls_p(a,b,c.p);\ndouble ac=dist(a,c.p);\ndouble bc=dist(b,c.p);\n\nif(res>c.r || (ac else if(c.r-res=c.r)||(ac>=c.r && bc else return 2;\n}\n\nint inside(point p, vector ps, int n){\npoint a,b;\na=b=p;\nb.x=DBL_MAX;\nps.push_back(ps[0]);\ndouble ymx=-DBL_MAX,ymn=DBL_MAX;\nfor(int i=0;i ymx=max(ymx,ps[i].y);\nymn=min(ymn,ps[i].y);\n}\nif(a.y<=ymn||a.y>=ymx)return 0;\n\nfor(int i=0;i if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n}\n\nint cnt1=0;\nfor(int i=0;i if(is_point_on_line(a,b,ps[i]))cnt1++;\n\nint cnt=0;\nfor(int i=0;i if(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n\nreturn (cnt-cnt1)%2;\n}\n\nint crossCP(vector t, circle C){\n\ndouble ans=0;\nint tsz=t.size();\n\nfor(int i=0;i double tmp=dist(t[i],C.p);\nif(tmp>ans)ans=tmp;\n}\n\nif(C.r>=ans)return 2;\n\nint res1=inside(C.p,t,tsz);\ndouble res2=DBL_MAX;\n\nt.push_back(t[0]);\n\nfor(int i=0;i res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\nif(res1 && C.r<=res2)return 1;\nelse if(!res1 && C.r else return 3;\n}\n\nint main(void){\npoint p;\nvector t;\ncircle C;\nstring ans=\"zabcd\";\n\nwhile(true){\nt.clear();\nfor(int i=0;i<3;i++){\ncin >> p.x >> p.y;\nif(p.x==0 && p.y==0)return 0;\nt.push_back(p);\n}\ncin >> C.p.x >> C.p.y >> C.r;\n\nint res=crossCP(t,C);\ncout << ans[res] << endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\ntypedef complex<ll> P;\n\nint x, y, r;\nP tri[3];\npair<P,ll> circle;\n\nll cross(P e1, P e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tll d0 = cross(e0, e1);\n\tll d1 = cross(e1, e2);\n\tll d2 = cross(e2, e0);\n\tif(d0 * d1 > 0 && d1 * d2 > 0 && d2 * d0 > 0) return true;\n\treturn false;\n}\n\nll norm2(P p) {\n\treturn p.real() * p.real() + p.imag() * p.imag();\n}\n\nbool proj(P p1, P p2, P p) {\n\tP e12 = p2 - p1;\n\tP e1 = p - p1;\n\tP e2 = p2 - p;\n\tint d1 = e1.real() * e12.real() + e1.imag() * e12.imag();\n\tint d2 = e2.real() * e12.real() + e2.imag() * e12.imag();\n\tif(d1 >= 0 && d2 >= 0) return true;\n\treturn false;\n}\n\nvoid dist2(P p1, P p2, P p, ll& nm, ll& de) {\n\tif(!proj(p1, p2, p)) {\n\t\tnm = min(norm2(p1 - p) , norm2(p2 - p));\n\t\tde = 1;\n\t\treturn;\n\t}\n\n\tll a = p2.imag() - p1.imag();\n\tll b = -(p2.real() - p1.real());\n\tll c = - a * p1.real() - b * p1.imag();\n\tnm = a * p.real() + b * p.imag() + c;\n\tnm = nm * nm;\n\tde = a * a + b * b;\n\tif(de == 0) {\n\t\tnm = norm2(p1 - p);\n\t\tde = 1;\n\t}\n}\n\n\nvoid solve() {\n\tll r2 = circle.second * circle.second;\n\tvector<pll> d(6);\n\td[3].first = norm2(tri[0] - circle.first); d[3].second = 1LL;\n\td[4].first = norm2(tri[1] - circle.first); d[4].second = 1LL;\n\td[5].first = norm2(tri[2] - circle.first); d[5].second = 1LL;\n\tif(d[3].first <= r2 && d[4].first <= r2 && d[5].first <= r2) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tbool iscin = inc();\n\tdist2(tri[0], tri[1], circle.first, d[0].first, d[0].second);\n\tdist2(tri[1], tri[2], circle.first, d[1].first, d[1].second);\n\tdist2(tri[2], tri[0], circle.first, d[2].first, d[2].second);\n\tif(iscin && (d[0].first >= r2 * d[0].second) &&\n\t\t        (d[1].first >= r2 * d[1].second) &&\n\t\t        (d[2].first >= r2 * d[2].second)) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\tbool inter = false;\n\trep(i,6) {\n\t\tif(d[i].first <= r2 * d[i].second) {\n\t\t\tinter = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(inter) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tscanf(\"%d\", &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n#define tmp template<class t>\n\ntmp void chmax(t&a,t b){if(a<b)a=b;}\ntmp void chmin(t&a,t b){if(a>b)a=b;}\n\ntmp using vc=vector<t>;\ntmp using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntmp ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\ntmp void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll read(){ll i;cin>>i;return i;}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-7;\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nauto cmcmp=[](const cm&a,const cm&b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\nld tri2(cm a,cm b,cm c){\n\treturn crs(b-a,c-a);\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n\nusing ln=pair<cm,cm>;\ncm dir(ln a){return a.b-a.a;}\ncm eval(ln a,ld b){return a.a+dir(a)*b;}\ncm proj(ln a,cm b){\n\tcm c=dir(a);\n\treturn a.a+c*dot(c,b-a.a)/norm(c);\n}\ncm refl(ln a,cm b){\n\treturn ld(2)*proj(a,b)-b;\n}\n//AOJ0153\nld dsp(ln a,cm b){\n\tcm c=proj(a,b);\n\tif(abs(bet(a.a,a.b,c))<=1)return abs(b-c);\n\treturn min(abs(b-a.a),abs(b-a.b));\n}\nint ccw(ln a,cm b){return ccw(a.a,a.b,b);}\n//AOJ1157\n//0-no,1-yes(endpoint),2-yes(innner)\nint iss(ln a,ln b){\n\tint c=ccw(a.a,a.b,b.a)*ccw(a.a,a.b,b.b);\n\tint d=ccw(b.a,b.b,a.a)*ccw(b.a,b.b,a.b);\n\tint e=max(c,d);\n\tif(e)return 1-e;\n\tint f=bet(a.a,a.b,b.a),g=bet(a.a,a.b,b.b);\n\tif(max(f,g)==-2||min(f,g)==2)return 0;\n\treturn 1;\n}\n//AOJ1157\nld dss(ln a,ln b){\n\tif(iss(a,b))return 0;\n\treturn min({dsp(a,b.a),dsp(a,b.b),dsp(b,a.a),dsp(b,a.b)});\n}\n\nusing cr=pair<cm,ld>;\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cr a,cm b){\n\treturn sgn(a.b-abs(b-a.a))+1;\n}\n//AOJ0153\n//0-no,1-touch,2-cross\nint ids(cr a,ln b){\n\treturn sgn(a.b-dsp(b,a.a))+1;\n}\n//AOJ0129 (touch以外)\n//0-no(in),1-touch(in),2-cross,3-touch(out),4-no(out)\nint ics(cr a,ln b){\n\tint c=ids(a,b);\n\tif(c<=1)return 4-c;\n\treturn sgn(max(abs(b.a-a.a),abs(b.b-a.a))-a.b)+1;\n}\n//AOJ1183\nint ccl(cr a,ln b,ld&c,ld&d){\n\tcm e=dir(b);\n\tcm f=b.a-a.a;\n\treturn qeq(norm(e),2*dot(e,f),norm(f)-a.b*a.b,c,d);\n}\n//AOJ0023\n//0-apart,1-coinside,2-a<b,3-a<=b,4-a>b,5-a>=b,6-a touch b,7-a cross b\nint icc(cr a,cr b){\n\tld c=abs(a.a-b.a);\n\tif(sgn(c)==0&&sgn(a.b-b.b)==0)return 1;\n\tint d=sgn(c+a.b-b.b);\n\tif(d<=0)return d+3;\n\tint e=sgn(c+b.b-a.b);\n\tif(e<=0)return e+5;\n\tint f=sgn(a.b+b.b-c);\n\tif(f>=0)return f+6;\n\treturn 0;\n}\n//AOJ1183\n//two intersections l,r seen be a.a\n//assume two circles cross\nln ccc(cr a,cr b){\n\tld c=arg(b.a-a.a);\n\tld d=arg(a.b,abs(b.a-a.a),b.b);\n\treturn ln(a.a+polar(a.b,c+d),a.a+polar(a.b,c-d));\n}\n\n\ncm readcm(){\n\tld a,b;\n\tcin>>a>>b;\n\treturn cm(a,b);\n}\n\nld readld(){\n\tld a;\n\tcin>>a;\n\treturn a;\n}\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\twhile(1){\n\t\tcm a=readcm();\n\t\tcm b=readcm();\n\t\tcm c=readcm();\n\t\tcr d{readcm(),readld()};\n\t\tif(cin.eof())break;\n\t\tchar ans;\n\t\tif(cont(d,a)&&cont(d,b)&&cont(d,c))\n\t\t\tans='b';\n\t\telse{\n\t\t\tint e=max({ids(d,ln{a,b}),ids(d,ln{b,c}),ids(d,ln{c,a})});\n\t\t\tdmp(e);\n\t\t\tif(e==2)\n\t\t\t\tans='c';\n\t\t\telse{\n\t\t\t\tif(cont(a,b,c,d.a))\n\t\t\t\t\tans='a';\n\t\t\t\telse{\n\t\t\t\t\tif(e==1)\n\t\t\t\t\t\tans='c';\n\t\t\t\t\telse\n\t\t\t\t\t\tans='d';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n    C(){}\n};\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nP unit(const P &p){\n    return p/abs(p);\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\n\nP projection(const L& l, const P& p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) {\n    return abs(cross(l[1]-l[0], p-l[0])) /abs(l[1]-l[0]);\n}\n\nVP crosspointCL(const C &c, const L &l){\n    VP ret;\n    P mid = projection(l, c.p);\n    double d = distanceLP(l, c.p);\n    if(EQ(d, c.r)){\n        ret.push_back(mid);\n    }else if(d < c.r){\n        double len = sqrt(c.r*c.r -d*d);\n        ret.push_back(mid +len*unit(l[1]-l[0]));\n        ret.push_back(mid -len*unit(l[1]-l[0]));\n    }\n    return ret;\n}\nVP crosspointCS(const C &c, const L &s){\n    VP ret;\n    VP cp = crosspointCL(c,s);\n    for(int i=0; i<(int)cp.size(); i++){\n        if(intersectSP(s, cp[i])){\n            ret.push_back(cp[i]);\n        }\n    }\n    return ret;\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = -ret;\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int x,y;\n        VP tri(3);\n        cin >> x >> y;\n        if(x==0 && y==0) break;\n        tri[0] = P(x, y);\n        for(int i=1; i<3; i++){\n            cin >> x >> y;\n            tri[i] = P(x, y);\n        }\n        if(ccw(tri[0], tri[1], tri[2]) != 1){\n            swap(tri[1], tri[2]);\n        }\n\n        C c;\n        cin >> x >> y >> c.r;\n        c.p = P(x, y);\n        for(int i=0; i<3; i++){\n            tri[i] -= c.p;\n        }\n        c.p = P(0, 0);\n\n        if(abs(tri[0]) < c.r+EPS && abs(tri[1]) < c.r+EPS && abs(tri[2]) < c.r+EPS){\n            cout << \"b\" << endl;\n        }else if(in_poly(c.p, tri) == 1 &&\n                 distanceLP(L(tri[0], tri[1]), c.p) +EPS > c.r &&\n                 distanceLP(L(tri[1], tri[2]), c.p) +EPS > c.r &&\n                 distanceLP(L(tri[2], tri[0]), c.p) +EPS > c.r){\n            cout << \"a\" << endl;\n        }else if((crosspointCS(c, L(tri[0], tri[1]))).empty() &&\n                 (crosspointCS(c, L(tri[1], tri[2]))).empty() &&\n                 (crosspointCS(c, L(tri[2], tri[0]))).empty()){\n            cout << \"d\" << endl;\n        }else{\n            cout << \"c\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-10\n\nusing namespace std;\n\nstruct Point \n{\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    \n\tdouble distance (const Point &o) const \n\t{\n        return sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));\n    }\n\n    Point operator+(const Point &o) const \n\t{\n        return Point(x+o.x, y+o.y);\n    }\n \n    Point operator-(const Point &o) const \n\t{\n        return Point(x-o.x, y-o.y);\n    }\n \t\n    Point operator*(const double m) const \n\t{\n   \t   return Point(x*m, y*m);\n    }\n\n    Point operator/(const double d) const \n\t{\n       return Point(x/d, y/d);\n    }\n\n    double cross(const Point &o) const \n\t{\n       return x * o.y - y * o.x;\n    }\n \n    double dot(const Point &o) const \n\t{\n        return x * o.x + y * o.y;\n    }\n \n    double atan() const \n\t{\n        return atan2(y, x);\n    }\n\n    double norm() const \n\t{\n        return sqrt(dot(*this));\n    }\n\n\tdouble area_abs(const Point &a,const Point &b) const\n\t{\n\t\tdouble t = (a.x - x) * (b.y - y);\n\t\tdouble t2 = (a.y - y) * (b.x - x);\n\t\tdouble areas = abs(t-t2);\n\t\treturn areas/2;\n\t}\n\n\t//符号付き面積\n\tdouble area(const Point &a,const Point &b)\n\t{\n\t\treturn ((a.x - x) * (b.y - y)) + ((b.x - x) * (y - a.y));\n\t}\n\t//線分abが自身の含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)\n\t\t{\n\t\t\treturn ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t\t}\n\t}\n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n\t\tif((b-a).dot(*this-a) < EPS) \n\t\t{\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS)\n\t\t{\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n\n\t//点a,b,cからなる三角形の中に自身が含まれているかどうか\n\tbool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n\t\tdouble t = (b-a).cross(*this-b);\n\t\tdouble t2 = (c-b).cross(*this-c);\n\t\tdouble t3 = (a-c).cross(*this-a);\n\t\t\n\t\tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\nint main()\n{\n\tdouble a,b;\n\twhile(cin >> a >> b)\n\t{\n\t\tif(a == 0 && b == 0) break;\n\t\t\n\t\tvector<Point> t;\n\t\tt.push_back(Point(a,b));\n\n\t\trep(i,2)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tt.push_back(Point(a,b));\n\t\t}\n\n\t\tdouble r;\n\t\tcin >> a >> b >> r;\n\t\tPoint c(a,b);\n\n\t\tint cnt = 0;\n\n\t\trep(i,3)\n\t\t{\n\t\t\tif(t[i].distance(c) >= r)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tif(cnt == 0) cout << \"b\" << endl;\n\t\telse if(cnt == 1 || cnt == 2) cout << \"c\" << endl;\n\t\telse\n\t\t{\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tif(c.distance_seg(t[0],t[1]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[1],t[2]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[2],t[0]) < r) flag = true;\n\t\t\t\n\t\t\tif(flag) cout << \"c\" << endl;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(c.hitPolygon(t[0],t[1],t[2]))\n\t\t\t\t{\n\t\t\t\t\tcout << \"a\" << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool flag2 = false;\n\n\t\t\t\t\tif(fabs(c.distance_seg(t[0],t[1])-r) <= EPS) flag2 = true;\n\t\t\t\t\tif(fabs(c.distance_seg(t[1],t[2])-r) <= EPS) flag2 = true;\n\t\t\t\t\tif(fabs(c.distance_seg(t[2],t[0])-r) <= EPS) flag2 = true;\n\n\t\t\t\t\tif(flag2) cout << \"c\" << endl;\n\t\t\t\t\telse cout << \"d\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&& isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\telse if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//12\n#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint dt(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\nint main(){\n  for(;;){\n    int x,y;\n    P t[3],c;\n    int r;\n    for(int i=0;i<3;i++){\n      cin>>x>>y;\n      if((i|x|y)==0)return 0;\n      t[i]=P(x,y);\n    }\n    cin>>x>>y;\n    c=P(x,y);\n    cin>>r;\n    if(abs(t[0]-c)<=r&&abs(t[1]-c)<=r&&abs(t[2]-c)<=r){\n      cout<<'b'<<endl;\n    }else{\n      double d[3];\n      bool f[2]={};\n      for(int i=0;i<3;i++){\n\tP l=t[(i+1)%3]-t[i];\n\tif(dt(l,c-t[i])>0&&dt(-l,c-t[(i+1)%3])>0){\n\t  d[i]=fabs(cr(l,c-t[i])/abs(l));\n\t}else{\n\t  d[i]=min(abs(c-t[i]),abs(c-t[(i+1)%3]));\n\t}\n\tf[cr(l,c-t[i])<0]=true;\n      }\n      if(f[0]^f[1]&&d[0]>=r&&d[1]>=r&&d[2]>=r){\n\tcout<<'a'<<endl;\n      }else if(d[0]<=r||d[1]<=r||d[2]<=r){\n\tcout<<'c'<<endl;\n      }else{\n\tcout<<'d'<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<iomanip>\n#include<bitset>\n#include<utility>\n#include<list>\n#include<map>\n#include<set>\n#include<cstring>\n#include<sstream>\n#include<cctype>\nusing namespace std;\nconst double EPS=1e-8;\nconst double INF=1e9;\ntypedef complex<double>P;\nnamespace std{\n    bool operator<(const P& a,const P& b){\n        return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n    }\n}\n#define EQ(a,b) (fabs((a)-(b))<EPS)\n#define EQV(a,b) (EQ(real(a),real(b))&&EQ(imag(a),imag(b)))\ndouble cross(const P &a,const P &b){\n    return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n    return real(conj(a)*b);\n}\n\nstruct L:public vector<P>{\n    L(const P &a,const P &b){\n        push_back(a);push_back(b);\n    }\n    L(){}\n};\n\ntypedef vector<P>G;\n\nstruct C{\n    P p;double r;\n    C(const P &p_,double r_):p(p_),r(r_){}\n    C(){}\n};\n\nint ccw(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>0)return 1;///counter clockwise\n    if(cross(b,c)<0)return -1;///clockwise\n    if(dot(b,c)<0)return 2;///c--a--b on line\n    if(norm(b)<norm(c))return -2;///a--b--c on line\n    return 0;\n}\nbool orthogonal(P &p,P &q){\n    return EQ(dot(p,q),0.0);\n}\nbool intersectLL(const L &l,const L &m){\n    return abs(cross(l[1]-l[0],m[1]-m[0]))>EPS||///non-parallel\n        abs(cross(l[1]-l[0],m[0]-l[0]))<EPS;///same line\n}\nbool intersectLS(const L &l,const L &s){\n    return cross(l[1]-l[0],s[0]-l[0])*///s[0] is left of l\n        cross(l[1]-l[0],s[1]-l[0])<EPS;///s[1] is right of l\n}\nbool intersectLP(const L &l,const P &p){\n    return abs(cross(l[1]-p,l[0]-p))<EPS;\n}\nbool intersectSS(const L &s,const L &t){\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nbool intersectSP(const L &s,const P &p){\n    return abs(abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]))<EPS;\n    ///triangle inequality\n}\nP projection(const L &l,const P &p){\n    double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n    return l[0]+t*(l[0]-l[1]);\n}\nP reflection(const L &l,const P &p){\n    return p+(projection(l,p)-p)*2.0;\n}\ndouble distanceLP(const L &l,const P &p){\n    return abs(p-projection(l,p));\n}\ndouble distanceLL(const L &l,const L &m){\n    return intersectLL(l,m)?0:distanceLP(l,m[1]);\n}\ndouble distanceLS(const L &l,const L &s){\n    if(intersectLS(l,s))return 0;\n    return min(distanceLP(l,s[0]),distanceLP(l,s[1]));\n}\ndouble distanceSP(const L &s,const P &p){\n    const P r=projection(s,p);\n    if(intersectSP(s,r))return abs(r-p);\n    return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L &s,const L &t){\n    if(intersectSS(s,t))return 0;\n    return min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n            min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\nP crossPoint(const L &l,const L &m){\n    double A=cross(l[1]-l[0],m[1]-m[0]);\n    double B=cross(l[1]-l[0],l[1]-m[0]);\n    if(abs(A)<EPS&&abs(B)<EPS)return m[0];///same line\n    ///if(abs(A)<EPS)assert(false);\n    return m[0]+B/A*(m[1]-m[0]);\n\n}\n\nP extreme(const G &g,const L &l){\n    int k=0;\n    for(int i=1;i<g.size();i++){\n        if(dot(g[i],l[1]-l[0])>dot(g[k],l[1]-l[0]))k=i;\n    }\n    return g[k];\n}\n\nG andrewScan(G s){\n    G u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n\n    for(int i=2;i<s.size();i++){\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=-1;n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for(int i=s.size()-3;i>=0;i--){\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=-1;n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\n/*\nIN 2\nON 1\nOUT 0\n*/\nint contains(G g,P p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        P a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return (x?2:0);\n}\n\nint main(){\n    G g(3);\n    C c;\n    while(scanf(\"%lf%lf\",&g[0].real(),&g[0].imag()),g[0].real()!=0||g[0].imag()!=0){\n        for(int i=1;i<3;i++)scanf(\"%lf%lf\",&g[i].real(),&g[i].imag());\n        scanf(\"%lf%lf%lf\",&c.p.real(),&c.p.imag(),&c.r);\n\n        bool flag=true;\n\n        for(int i=0;i<3;i++){\n            flag&=(distanceSP(L(g[i],g[(i+1)%3]),c.p)+EPS>c.r);\n        }\n\n        if(flag){\n            if(contains(g,c.p)==2)puts(\"a\");\n            else puts(\"d\");\n            continue;\n        }\n        flag=true;\n        for(int i=0;i<3;i++){\n            flag&=(c.r+EPS>abs(g[i]-c.p));\n        }\n        if(flag){\n            puts(\"b\");\n            continue;\n        }\n        puts(\"c\");\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-10\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    if (norm(a) < r2) {\n      c[i] = -1;\n    } else if (norm(a) > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0. && c[1]>=0. && c[2]>=0.) {\n    return 1;\n  } else if (c[0]<=0. && c[1]<=0. && c[2]<=0.) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double na, nb, dab, d, sd, s, t;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    na = norm(a);\n    nb = norm(b);\n    dab = dot(a,b);\n    d = dab*dab - na*(nb-r*r);\n    if (d <=EPS) {\n      if (fabs(d) < EPS) {\n        contact = true;\n      }\n      continue;\n    }\n    sd = sqrt(d);\n    s = (dab+sd)/na;\n    t = (dab-sd)/na;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<=1.-EPS)) {\n      return 1;\n    }\n    if ((fabs(s)<EPS && fabs(s-1.)<EPS) || (fabs(t)<EPS && fabs(t-1.)<EPS)) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2){};\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn(s1.p1 + (s1.p2 - s1.p1) * t);\n}\n\ndouble arg(Vector p)\n{\n\treturn(atan2(p.y, p.x));\n}\n\nVector polar(double a, double r)\n{\n\treturn(Point(cos(r) * a, sin(r) * a));\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn(make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)));\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn(make_pair(pr - e * base, pr + e * base));\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tPoint p1;\n\twhile (cin >> p1.x >> p1.y, p1.x || p1.y)\n\t{\n\t\tPoint p2, p3, p4;\n\t\tint r;\n\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y >> r;\n\t\t\n\t\tif (getDistance(p4, p1) <= r && getDistance(p4, p2) <= r && getDistance(p4, p3) <= r)\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if (cross(p2 - p1, p4 - p1) * cross(p3 - p1, p4 - p1) < eps && cross(p2 - p3, p4 - p3) * cross(p1 - p3, p4 - p3) < eps && cross(p1 - p2, p4 - p2) * cross(p3 - p2, p4 - p2) < eps &&\n\t\t\t     getDistanceSP(Segment(p1, p2), p4) > r && getDistanceSP(Segment(p1, p3), p4) > r && getDistanceSP(Segment(p2, p3), p4) > r)\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse if (getDistanceSP(Segment(p1, p2), p4) > r && getDistanceSP(Segment(p1, p3), p4) > r && getDistanceSP(Segment(p2, p3), p4) > r)\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])==OUT)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(intersectCS(c,Segment(g[i],next(g,i))))return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        if(contains(g,c))puts(\"a\");\n        else if(contains(c,g))puts(\"b\");\n        else{\n            bool x=false;\n            for(int i=0;i<g.size();i++){\n                if(contains(c,g[i]))x=true;\n            }\n            puts(x?\"c\":\"d\");\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n \nstruct segment{ point a,b; };\n \nstruct circle{ point p; double r; };\n \ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n \ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n \nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n \ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n \ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n \ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n \n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n \n bool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint point_contain(point* ps, point p, int n){\n  int cnt=ccw(ps[0],ps[1],p);\n  ps[n++]=ps[0]; \n\n  for(int i=0;i<n-1;i++)\n    if(cnt!=ccw(ps[i],ps[i+1],p))return 0;\n   \n  return 1;\n}\n \nint crossCP(point* ps, circle C, int sz){\n \n  double ans=0;\n \n  for(int i=0;i<sz;i++){\n    double tmp=dist(ps[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n \n  if(C.r>=ans)return 2;\n \n  vector<point>t=convex_hull(ps,sz);\n\n  int tsz=t.size();\n  int res1=point_contain(ps,C.p,tsz);\n \n  double res2=100000000;\n   t[t.size()]=t[0];\n   tsz++;\n  for(int i=0;i<tsz-1;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n \n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n \nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n  string ans=\"zabcd\";\n \n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n \n    int res=crossCP(p,C,3);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\nconst R pi = acos(-1);\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\nR dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    // A to B\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    // ax+by+c=0\n    L(R a, R b, R c){\n        if(fabs(a) < eps) *this = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) *this = L(P(-c/a,0),P(-c/a,1));\n        else *this = L(P(-c/a,0), P(0,-c/b));\n    }\n    P vec() const {\n        return (*this)[1] - (*this)[0];\n    }\n};\n\nstruct S : public vector<P> {\n    // A to B\n    S(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    L to_L() const {\n        return L((*this)[0], (*this)[1]);\n    }\n    P vec() const {\n        return to_L().vec();\n    }\n    R len() const {\n        return abs(vec());\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p = P(), R r = 0) : p(p), r(r) { }\n};\n\n// CCW\nenum { CCW = +1, CW = -1, CAB = +2, ABC = -2, SAMEPOINT = 0 };\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return CCW; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return  CW; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return CAB; // c--a--b 直線上\n    if (norm(b) < norm(c)) return ABC; // a--b--c 直線上\n    return SAMEPOINT; // 2点以上が重なっている\n}\n\n// A->C方向の角ABCの大きさを[0,2*Pi]で求める\nR arg(P a, P b, P c) {\n    R th = arg((a - b) / (c - b));\n    return th > 0 ? th : th+2*pi;\n}\n\n// 交差判定(基本的に直接呼ぶな)\nbool col(const L &l, const L &m) {\n    return\n        abs(cross(l.vec(), m.vec())) > eps || // non-parallel\n        abs(cross(l.vec(), m[0]-l[0])) < eps;   // same line\n}\n\nbool col(const L &l, const S &s) {\n    return\n        cross(l.vec(), s[0]-l[0])*       // s[0] is left of l\n        cross(l.vec(), s[1]-l[0]) < eps; // s[1] is right of l\n}\n\nbool col(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool col(const S &s, const S &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool col(const S &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool col(const C &c, const P &p) {\n    // 境界または内部\n    return abs(c.p - p) <= c.r + eps;\n}\n\nint col(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(abs(d - r1 - r2) < eps) return  1; // 接する\n    if(d > r1 + r2)       return  0; // 共通部分を持たない\n    if(d < r1 - r2)       return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)       return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l.vec()) / norm(l.vec());\n    return l[0] + t*(l.vec());\n}\nL proj(const L& l, const L& m) {\n    return L(proj(l,m[0]), proj(l,m[1]));\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\nL refl(const L& l, const L& m) {\n    return L(refl(l,m[0]), refl(l,m[1]));\n}\n\n// 距離\nR dist(const P &p, const P &q){\n    return abs(p - q);\n}\n\nR dist(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dist(const P& p, const L& l){\n    return dist(l,p);\n}\n\nR dist(const L &l, const L &m) {\n    return col(l, m) ? 0 : dist(l, m[0]);\n}\n\nR dist(const L &l, const S &s) {\n    if (col(l, s)) return 0;\n    return min(dist(l, s[0]), dist(l, s[1]));\n}\n\nR dist(const S& s, const L& l){\n    return dist(s,l);\n}\n\nR dist(const S &s, const P &p) {\n    const P r = proj(s.to_L(), p);\n    if (col(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dist(const P& p, const S& s){\n    return dist(s,p);\n}\n\nR dist(const S &s, const S &t) {\n    if (col(s, t)) return 0;\n    return min(min(dist(s, t[0]), dist(s, t[1])),\n               min(dist(t, s[0]), dist(t, s[1])));\n}\n\nR dist(const C &c, const P &p) {\n    return max(0. , abs(c.p - p));\n}\n\nR dist(const P& p, const C& c){\n    return dist(c,p);\n}\n\n// positive -> outside\n// zero     -> on the boundaly\n// negative -> inside\nR dist(const C& c, const L& l){\n    R d = dist(l,c.p);\n    return d - c.r;\n}\n\nR dist(const L& l, const C& c){\n    return dist(c,l);\n}\n\n// 交点\nvector<P> hit(const L &l, const L &m) {\n    R A = cross(l.vec(), m.vec());\n    R B = cross(l.vec(), l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) return {}; // parallel\n    return {m[0] + B / A * (m.vec())};\n}\n\nvector<P> hit(const S& s, const S& t) {\n    if(col(s,t)) return hit(s,t);\n    else return {};\n}\n\nvector<P> hit(const L& l, const S& s){\n    if(col(l,s)) return hit(l,s);\n    else return {};\n}\n\nvector<P> hit(const S& s, const L& l){\n    return hit(l,s);\n}\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183\n//        : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2045\nvector<P> hit(const C& c, const L& l){\n    R d = dist(l,c.p); // 中心と直線の距離\n    if(fabs(d-c.r) < eps) return { proj(l, c.p) }; // 触れている\n    if(d > c.r) return {}; // 離れている\n    P h = proj(l, c.p);\n    P u = sqrt(c.r*c.r - d*d) * (l.vec()) / abs(l.vec());\n    return {h+u, h-u};\n}\n\nvector<P> hit(const L& l, const C& c){\n    return hit(l,c);\n}\n\nvector<P> hit(const C& c, const S& s){\n    vector<P> cs = hit(c,s), res;\n    for(const P& p : cs) {\n        if(col(s,p)) res.push_back(p);\n    }\n    return res;\n}\n\nvector<P> hit(const S& s, const C& c){\n    return hit(c,s);\n}\n\nvector<P> hit(const C& c1, const C& c2){\n    int i = col(c1,c2);\n    // 共通部分なし || 内部\n    if(i==0 || abs(i)==3) return {};\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    // 接する\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d };\n    // 2つの交点を持つ\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = 2 * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return hit(c1, L(A,B,C));\n}\n\nchar solve(G t, C c){\n    if(ccw(t[0],t[1],t[2])!=CCW){\n        swap(t[0],t[1]);\n    }\n    double r = c.r;\n    P p = c.p;\n    bool CinT = true;\n    double d = inf;\n    bool TinC = true;\n    rep(i,3)CinT &= ccw(t[i],t[(i+1)%3],p)==CCW;\n    rep(i,3)TinC &= dist(p,t[i]) <= r + eps;\n    rep(i,3)d = min(d, dist(p, L(t[i],t[(i+1)%3])));\n    // cout << d << \" \" << r << endl;\n    if(TinC) return 'b';\n    if(CinT && d > r) return 'a';\n    if(d < r) return 'c';\n    return 'd';\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b && a){\n        G t(3);\n        t[0] = P(a,b);\n        rep(i,2){\n            int a,b;\n            cin>>a>>b;\n            t[i+1] = P(a,b);\n        }\n        int r,a,b;\n        cin>>a>>b>>r;\n        C c(P(a,b),r);\n        cout << solve(t,c) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint a, b, c;\n\tcin >> a >> b >> c;\n\tint d;\n\tif(a>c){\n\t\td=a;\n\t\ta=c;\n\t\tc=d;\n\t}\n\tif(a>b){\n\t\td=b;\n\t\tb=a;\n\t\ta=d;\n\t}\n\tif(b>c){\n\t\td=b;\n\t\tb=c;\n\t\tc=d;\n\t}\n\tcout << a << \" \" << b << \" \" << c <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define EPS (1e-8)\n\ntypedef complex<double> P;\ntypedef P Vec;\n\nstruct Line {\n\tP p;\n\tVec v;\n\t\n\tLine() {}\n\tLine(P p, Vec v) : p(p), v(v) {}\n\t\n\tP getPoint(double t) {\n\t\treturn p + v * t;\n\t}\n};\n\nstruct Circle {\n\tP p;\n\tdouble r;\n\t\n\tCircle() {}\n\tCircle(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot(Vec a, Vec b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Vec a, Vec b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool isInCir(Circle &c, P &p) {\n\treturn norm(c.p - p) <= c.r*c.r + EPS;\n}\n\nbool isInSeg(Line &s, P &p) {\n\tVec a = s.v, b = p - s.p;\n\tdouble l1 = abs(a), l2 = abs(b);\n\t\n\treturn dot(a, b) >= l1*l2 - EPS && dot(a, b) <= l1*l2 + EPS && l1 >= l2 - EPS;\n}\n\nbool isInTri(P &a, P &b, P &c, P &d) {\n\tP p[4];\n\tp[0] = a; p[1] = b; p[2] = c; p[3] = d;\n\t\n\tint cnt = 0;\n\tREP(i, 3) {\n\t\tVec v = p[3] - p[i];\n\t\tLine s(p[i], p[(i + 1) % 3] - p[i]);\n\t\t\n\t\tif (isInSeg(s, p[3])) return true;\n\t\tif (cross(s.v, v) < -EPS) cnt++;\n\t}\n\treturn (cnt == 0 || cnt == 3);\n}\n\ndouble distanceSP(Line &s, P &p) {\n\tVec a = s.v, b = p - s.p;\n\treturn abs(cross(a, b)) / abs(a);\n}\n\nint main() {\n\tdouble x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile (cin >> x1 >> y1, x1 || y1) {\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\t\n\t\tP p[4] = {P(x1, y1), P(x2, y2), P(x3, y3), P(x4, y4)};\n\t\tLine seg[3] = {Line(p[0], p[1] - p[0]), Line(p[1], p[2] - p[1]), Line(p[2], p[0] - p[2])};\n\t\tCircle c(p[3], r);\t\t\n\t\t\n\t\tdouble m = min(distanceSP(seg[0], c.p), min(distanceSP(seg[1], c.p), distanceSP(seg[2], c.p)));\n\t\t\n\t\tif (abs(c.p - p[0]) <= c.r + EPS && abs(c.p - p[1]) <= c.r + EPS && abs(c.p - p[2]) <= c.r + EPS)\n\t\t\tputs(\"b\");\n\t\telse if (isInTri(p[0], p[1], p[2], p[3])) {\n\t\t\tif (c.r <= m + EPS) puts(\"a\");\n\t\t\telse puts(\"c\");\n\t\t}\n\t\telse if (c.r < m - EPS) puts(\"d\");\n\t\telse puts(\"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef double D;\ntypedef complex<D> P;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\ndouble x[3],y[3],xr,yr,r;\nbool dis(int p){\n  return sqrt(abs(x[p]-xr)*abs(x[p]-xr)+abs(y[p]-yr)*abs(y[p]-yr))<=r+0.01;\n}\nmain(){\n  while(cin>>x[0]>>y[0],x[0]+y[0]){\n    int sum=0;\n    r(i,2)cin>>x[i+1]>>y[i+1];\n    cin>>xr>>yr>>r;\n    r(i,3)if(dis(i))sum++;\n    if(sum==0){\n      int pp=0;\n      r(i,3){\n        pp+=ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr));\n        if(ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr))==2)exit(1);\n      }\n      if(abs(pp)==3)cout<<'a'<<endl;\n      else cout<<'d'<<endl;\n    }\n    else if(sum==3)cout<<'b'<<endl;\n    else cout<<'c'<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && vec_abs(seg[i].b-seg[j].a)<=EPS){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    double ans=0;\n    for(int i=0;i<3;i++){\n\tint tmp=dist(p[i],C.p);\n\tif(tmp>ans){\n\t  ans=tmp;\n\t}\n    }\n    if(C.r>ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n    \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=100000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0&&acx*acx+acy*acy<=r*r)return true;\n\t\telse if(abx*acx+aby*acy>abx*abx+aby*aby&&bcx*bcx+bcy*bcy<=r*r)return true;\n\t\telse if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t}\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<0)ok1=false;\n\telse ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<0)ok1=false;\n\telse ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<0)ok1=false;\n\telse ok2=false;\n\treturn ok1||ok2;\n}\nbool intersect(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy){\n\tlong long ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n\tlong long tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n\tlong long tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n\tlong long td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n\tif(ta*tb<=0LL&&tc*td<=0LL)return true;\n\telse return false;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<r*r&&(c-g)*(c-g)+(d-h)*(d-h)<r*r&&(e-g)*(e-g)+(f-h)*(f-h)<r*r)printf(\"b\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse if(inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntypedef complex<double> P;\n\nint x, y, r;\nP tri[3];\npair<P,double> circle;\n\ndouble cross(P& e1, P& e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 >= 0 && d1 * d2 >= 0 && d2 * d0 >= 0) return true;\n\treturn false;\n}\n\ndouble dist(P p1, P p2, P p) {\n\tdouble a = p2.imag() - p1.imag();\n\tdouble b = -(p2.real() - p1.real());\n\tdouble c = - a * p1.real() - b * p1.imag();\n\tdouble nm = a * p.real() + b * p.imag() + c;\n\tdouble de = a * a + b * b;\n\treturn abs(nm) / sqrt(de);\n}\n\ndouble norm(P p) {\n\treturn sqrt(p.real() * p.real() + p.imag() * p.imag());\n}\n\nvoid solve() {\n\tbool iscin = inc();\n\tdouble R = circle.second;\n\tvector<double> d(6, 0.0);\n\td[0] = dist(tri[0], tri[1], circle.first);\n\td[1] = dist(tri[1], tri[2], circle.first);\n\td[2] = dist(tri[2], tri[0], circle.first);\n\t// printf(\"%f %f %f\\n\", d[0], d[1], d[2]);\n\tif(iscin && d[0] > R && d[1] > R && d[2] > R) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\tP p0 = tri[0] - circle.first;\n\tP p1 = tri[1] - circle.first;\n\tP p2 = tri[2] - circle.first;\n\td[3] = norm(p0);\n\td[4] = norm(p1);\n\td[5] = norm(p2);\n\t// printf(\"%f %f %f\\n\", d[3], d[4], d[5]);\n\tif(d[3] < R && d[4] < R && d[5] < R) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(d[0] < R) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nP in(){\n\tdouble a,b;\n\tcin >> a >> b;\n\treturn P(a,b);\n}\ndouble dot(P a,P b){\n\treturn (conj(a)*b).real();\t\n}\ndouble cross(P a,P b){\n\treturn (conj(a)*b).imag();\n}\n\n// a-b vs c\nP pedal(P a,P b,P c){\n\tP v = b - a;\n\tP e = v / abs(v);\n\tP p = c - a;\n\treturn a + e * dot(e,p);\n}\n\n\ndouble eps = 1e-9;\nbool intersectSP(P a,P b,P c){\n\treturn fabs( abs(a-b) - (abs(a-c) + abs(b-c)) ) < eps;\n}\n\n\n\ndouble distanceSP(P a,P b,P c){\n\tP pdl = pedal(a,b,c);\n\tdouble answer = min(abs(a-c),abs(b-c));\n\tif( intersectSP(a,b,pdl) ) answer = min(answer, abs(pdl-c) );\n\treturn answer;\n}\n\n\n/*\na / a(a) * b\n \n      a\n----*------->\n .  |\n b\\ |\n   \\|\n\n*/\nint main(){\n\n\twhile(true){\n\t\tvector<P> p(3);\n\t\tfor(int i = 0 ; i < 3 ; i++) p[i] = in();\n\t\n\t\tif( abs(p[0]) < eps ) return 0; // end\n\t\tP d = in();\n\n\t\tdouble R;\n\t\tcin >> R;\n\t\tfor(int i = 0 ; i < 3 ; i++) p[i] -= d;\n\n\t\tvector<int> sgn;\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tdouble s = cross(p[i],p[(i+1)%3]);\n\t\t\tif( s < 0 ) s = -1;\n\t\t\telse if( s > 0 ) s = +1;\n\t\t\tif(s) sgn.push_back(s);\n\t\t}\n\t\tbool isin = false;\n\t\tif( sgn.size() == 0 || count(sgn.begin(),sgn.end(),sgn[0]) == 3 ) isin = true;\n\t\tdouble dist = 1e9;\n\n\t\tfor(int i = 0 ; i < 3 ; i++)\n\t\t\tdist = min(distanceSP(p[i],p[(i+1)%3],P(0,0)),dist);\n\t\tif( isin && dist > R - eps ){\n\t\t\tcout << \"a\" << endl;\n\t\t}else if( max( {abs(p[0]),abs(p[1]),abs(p[2])}) < R - eps ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( !isin && dist > R + eps ){\n\t\t\tcout << \"d\" << endl;\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t}\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> Po;\n\n\nPo p[3],o;\n\ndouble cross(Po x, Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a, Po b, Po c){return abs(cross(b-a,c-a))/2;}\n\nbool inter(Po a, Po b, Po c, Po x){\n  return (area(a,b,x)+area(b,c,x)+area(c,a,x) < area(a,b,c) + EPS);\n}\n\ndouble line_dis(Po a, Po b, Po c){return abs(cross(b-a,c-a))/abs(b-a);}\n\nint main(){\n  double x[4],y[4],r;\n\n  for(;;){\n    cin >> x[0] >> y[0];\n    if(!x[0] && !y[0])break;\n\n    for(int i=1;i<4;i++)cin >> x[i] >> y[i];\n    cin >> r;\n\n    for(int i=0;i<3;i++)p[i] = Po(x[i],y[i]);\n    o = Po(x[3],y[3]);\n\n\n    bool f[3];\n    if(inter(p[0],p[1],p[2],o)){\n      for(int i=0;i<3;i++)f[i] = (line_dis(p[i],p[(i+1)%3],o)>r+EPS);\n      if(f[0] && f[1] && f[2])cout << \"a\\n\";\n      else{\n\tfor(int i=0;i<3;i++)f[i] = (abs(r-p[i])<r+EPS);\n\tif(f[0] && f[1] && f[2])cout << \"b\\n\";\n\telse cout << \"c\\n\";\n      }\n    }else{\n      for(int i=0;i<3;i++)f[i] = (line_dis(p[i],p[(i+1)%3],o)<r+EPS);\n      if(f[0] || f[1] || f[2])cout << \"c\\n\";\n      else cout << \"d\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n\ndouble dot(P& a, P& b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P& a, P& b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint sign(double x){\n  if(x > EPS) return 1;\n  if(x < -EPS) return -1;\n  return 0;\n}\n\n//a -> b, a -> c\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(sign(cross(b, c)) > 0) return 1; //反時計\n  if(sign(cross(b, c)) < 0) return -1; //時計\n  if(sign(dot(b, c)) < 0) return +2; //c-a-b\n  if(norm(b) < norm(c)) return -2; //a-b-c\n  return 0; //a-c-b\n}\nbool cross(P a, P b, P c, double r){\n  double d1 = abs(c - a);\n  double d2 = abs(c - b);\n  if(d1 > d2) swap(d1, d2);\n  if(d1 < r && r < d2) return true;\n  if(ccw(a, b, c) == 0 && r < d2) return true;\n  if(ccw(a, b, c) != 1 && ccw(a, b, c) != -1) return false;\n  b -= a; c -= a;\n  double k = dot(b, c) / norm(b);\n  if(0 < k && k < 1 && abs(c - k * b) < r && r < d2) return true;\n  else return false;\n}\n\n\nstring solve(P p[3], P c, double r){\n  double maxdist = 0;\n  REP(i, 3) maxdist = max(maxdist, abs(p[i] -  c));\n  if(maxdist < r) return \"b\";\n  bool circle_in = false;\n  int ccw_v[3];\n  REP(i, 3) ccw_v[i] = ccw(p[i], p[(i + 1) % 3], c);\n  if(ccw_v[0] == ccw_v[1] && ccw_v[1] == ccw_v[2] && (ccw_v[0] == 1 || ccw_v[0] == -1)){\n    circle_in = true;\n  }\n  bool iscross = false;\n  REP(i, 3) iscross |= cross(p[i], p[(i + 1) % 3], c, r);\n  if(circle_in && !iscross) return \"a\";\n  if(iscross) return \"c\";\n  else return \"d\";\n}\n\nint main(){\n  P p[3];\n  P c; double r;\n  while(cin>>p[0].X>>p[0].Y>>p[1].X>>p[1].Y>>p[2].X>>p[2].Y>>c.X>>c.Y>>r){\n    cout<<solve(p, c, r)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint f(int k) { return k * k; }\nsigned main() {\n\tint x1, x2, x3, y1, y2, y3, xr, yr, r;\n\twhile (cin >> x1 >> y1, x1, y1) {\n\t\tcin >> x2 >> y2;\n\t\tcin >> x3 >> y3;\n\t\tcin >> xr >> yr >> r;\n\t\tint i1 = f(x1 - xr) + f(y1 - yr) <= f(r);\n\t\tint i2 = f(x2 - xr) + f(y2 - yr) <= f(r);\n\t\tint i3 = f(x3 - xr) + f(y3 - yr) <= f(r);\n\t\tint tc = (\n\t\t\t((y1 - y2) * xr - (x1 - x2) * yr + x1 * y2 - x2 * y1) * ((y1 - y2) * x3 - (x1 - x2) * y3 + x1 * y2 - x2 * y1) >= 0 &&\n\t\t\t((y2 - y3) * xr - (x2 - x3) * yr + x2 * y3 - x3 * y2) * ((y2 - y3) * x1 - (x2 - x3) * y1 + x2 * y3 - x3 * y2) >= 0 &&\n\t\t\t((y3 - y1) * xr - (x3 - x1) * yr + x3 * y1 - x1 * y3) * ((y3 - y1) * x2 - (x3 - x1) * y2 + x3 * y1 - x1 * y3) >= 0);\n\n\t\tint p12 = (f((y1 - y2) * xr - (x1 - x2) * yr + x1 * y2 - x2 * y1) < f(r) * (f(y1 - y2) + f(x1 - x2)) && ((x1 - x2) * (xr - x1) + (y1 - y2) * (yr - y1)) * ((x1 - x2) * (xr - x2) + (y1 - y2) * (yr - y2)) <= 0);\n\t\tint p23 = (f((y2 - y3) * xr - (x2 - x3) * yr + x2 * y3 - x3 * y2) < f(r) * (f(y2 - y3) + f(x2 - x3)) && ((x2 - x3) * (xr - x2) + (y2 - y3) * (yr - y2)) * ((x2 - x3) * (xr - x3) + (y2 - y3) * (yr - y3)) <= 0);\n\t\tint p31 = (f((y3 - y1) * xr - (x3 - x1) * yr + x3 * y1 - x1 * y3) < f(r) * (f(y3 - y1) + f(x3 - x1)) && ((x3 - x1) * (xr - x3) + (y3 - y1) * (yr - y3)) * ((x3 - x1) * (xr - x1) + (y3 - y1) * (yr - y1)) <= 0);\n\t\tint ps12 = (f((y1 - y2) * xr - (x1 - x2) * yr + x1 * y2 - x2 * y1) <= f(r) * (f(y1 - y2) + f(x1 - x2)) && ((x1 - x2) * (xr - x1) + (y1 - y2) * (yr - y1)) * ((x1 - x2) * (xr - x2) + (y1 - y2) * (yr - y2)) <= 0);\n\t\tint ps23 = (f((y2 - y3) * xr - (x2 - x3) * yr + x2 * y3 - x3 * y2) <= f(r) * (f(y2 - y3) + f(x2 - x3)) && ((x2 - x3) * (xr - x2) + (y2 - y3) * (yr - y2)) * ((x2 - x3) * (xr - x3) + (y2 - y3) * (yr - y3)) <= 0);\n\t\tint ps31 = (f((y3 - y1) * xr - (x3 - x1) * yr + x3 * y1 - x1 * y3) <= f(r) * (f(y3 - y1) + f(x3 - x1)) && ((x3 - x1) * (xr - x3) + (y3 - y1) * (yr - y3)) * ((x3 - x1) * (xr - x1) + (y3 - y1) * (yr - y1)) <= 0);\n\t\t/*cout << \"i1: \" << i1 << endl;\n\t\tcout << \"i2: \" << i2 << endl;\n\t\tcout << \"i3: \" << i3 << endl;\n\t\tcout << \"tc: \" << tc << endl;\n\t\tcout << \"p12: \" << p12 << endl;\n\t\tcout << \"p23: \" << p23 << endl;\n\t\tcout << \"p31: \" << p31 << endl;*/\n\t\tif (i1 + i2 + i3 == 3)printf(\"b\\n\");\n\t\telse if (i1 + i2 + i3 > 0)printf(\"c\\n\");\n\t\telse if (p12 + p23 + p31 > 0)printf(\"c\\n\");\n\t\telse if (tc)printf(\"a\\n\");\n\t\telse if (ps12 + ps23 + ps31 > 0)printf(\"c\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst double eps = 1e-8;\nint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\nint distDbl(int ax, int ay, int bx, int by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\ndouble getPerpDistDbl(int ax, int ay, int bx, int by, int cx, int cy) {\n    double a = (double)(by - ay) / (bx - ax);\n    double b = ay - a * ax;\n    double res = (a * cx - cy + b) * (a * cx - cy + b) / (1 + a * a);\n    return res;\n}\n\ndouble getPerpDistSegDbl(int ax, int ay, int bx, int by, int cx, int cy) {\n    double a = (double)(by - ay) / (bx - ax);\n    double b = ay - a * ax;\n    double x = (ax + a * (ay - b)) / (1 + a * a);\n    double y = a * x + b;\n    double res;\n    if (min(ax, bx) <= x && x <= max(ax,bx) &&\n        min(ay, by) <= y && y <= max(ay,by)) {\n        res = (a * cx - cy + b) * (a * cx - cy + b) / (1 + a * a);\n    } else {\n        res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n    }\n    return res;\n}\n\nbool isA() {\n    int c = 0;\n    if (0 <= (x2-x1)*(y4-y1)-(y2-y1)*(x4-x1)) ++c;\n    if (0 <= (x3-x2)*(y4-y2)-(y3-y2)*(x4-x2)) ++c;\n    if (0 <= (x1-x3)*(y4-y3)-(y1-y3)*(x4-x3)) ++c;\n    if (c % 3 != 0) return false;\n    if (getPerpDistDbl(x1, y1, x2, y2, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x2, y2, x3, y3, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x3, y3, x1, y1, x4, y4) + eps < r*r) return false;\n    return true;\n}\n\nbool isB() {\n    if (distDbl(x1,y1,x4,y4) <= r*r && distDbl(x2,y2,x4,y4) <= r*r && distDbl(x3,y3,x4,y4) <= r*r) {\n        return true;\n    }\n    return false;\n}\n\nbool isC() {\n    if (getPerpDistSegDbl(x1,y1,x2,y2,x4,y4) + eps < r*r) return true;\n    if (getPerpDistSegDbl(x2,y2,x3,y3,x4,y4) + eps < r*r) return true;\n    if (getPerpDistSegDbl(x3,y3,x1,y1,x4,y4) + eps < r*r) return true;\n    return false;\n}\n\nint main() {\n    while (cin >> x1 >> y1, (x1 || y1)) {\n        cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n        if (isB()) cout << \"b\" << endl;\n        else if (isA()) cout << \"a\" << endl;\n        else if (isC()) cout << \"c\" << endl;\n        else cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return center.distance(p) < r;}\n    bool include(const Segment& s) const {return center.distance(s) < r;}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n    if(s.ccw(p) == ON) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x - y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + Point(t, t) * v2;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n//     for(auto& e: edge) if(circle.include(e)) return \"c\";\n    double minimum = 1e10;\n    for(auto& e: edge) minimum = min(minimum, circle.center.distance(e));\n\n    bool centerInTriangle = true;\n    POSITION ccw = (*edge.begin()).ccw(circle.center);\n    for(auto& e: edge) if(ccw != e.ccw(circle.center)) centerInTriangle = false;\n\n    if(centerInTriangle && minimum >= circle.r) return \"a\";\n    if(!centerInTriangle && minimum > circle.r) return \"d\";\n    return \"c\";\n\n//     if(cw == 3 || ccw == 3) return \"a\";//     for(auto& e: edge) {\n//         if(e.ccw(circle.center) > 0) ++ccw;\n//         if(e.ccw(circle.center) < 0) ++cw;\n//     }\n//     if(cw == 3 || ccw == 3) return \"a\";\n// \n//     return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\ntypedef struct circle{\n\tpoint p;\n\tdouble r;\n} circle;\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\ncircle make(point p,double r){ circle c;\n\tc.p = p ;\n\tc.r = r;\n\treturn c;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// circle_versino\nint ccw(circle c0,circle c1){\n\tdouble  d = abs(c0.p-c1.p);\n\tdouble r0 = c0.r,r1 = c1.r;\n\t\n\t//c0in c1\n\tif(d<r1-r0)return -2;\n\t//c1 in c0\n\tif(d<r0-r1)return 2;\n\t//c0 cross c1\n\tif(abs(r0-r1)<=d&&d<=r0+r1)return 1;\n\t//c0 not cross c1\n\treturn 0;\n\n}\n\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nint main(){\n\twhile(1){\n\tvector<point> tri(3);\n\ttri[0] = make();\n\tif(tri[0].x==0&&tri[0].y==0)break;\n\ttri[1] = make();\n\ttri[2] = make();\n\tvector<line> l(3);\n\tl[0] = make(tri[0],tri[1]);\n\tl[1] = make(tri[1],tri[2]);\n\tl[2] = make(tri[2],tri[0]);\n\n\tpoint p = make();\n\tdouble r ; cin>>r;\n\tcircle c = make(p,r);\n\t// circle in triangle\n\tif(r<=distance(l[0],p)&&r<=distance(l[1],p)&&\n\t\t\tr<=distance(l[2],p)&&contains(tri,p) ){\n\tcout<<'a'<<endl;\n\tcontinue;\n\t}\n\t// triangle in circle \n\tif(r>=distance(tri[0],p)&&r>=distance(tri[1],p)&&r>=distance(tri[2],p)){\n\tcout<<'b'<<endl;\n\tcontinue;\n\t}\n\t//cross\n\t\n\tif(r>=distance(l[0],p)|| r>=distance(l[1],p)|| r>=distance(l[2],p)){\n\tcout<<'c'<<endl;\n\tcontinue;\n\t}\n\t\n\tcout<<'d'<<endl;\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\nconst double EPS = 1e-12;\n\ndouble cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\nxy_t projection(const line &l, const xy_t &p){\n  double t = dot(l.second - l.first, p - l.first) / norm(l.second - l.first);\n  return l.first + t * (l.second - l.first);\n}\n\nbool intersectSP(const line &l, const xy_t &p){\n  return abs(p - l.first) + abs(p - l.second) < abs(l.first - l.second) + EPS;\n}\n\ndouble distanceSP(const line &l, const xy_t &p){\n  xy_t r = projection(l, p);\n  if(intersectSP(l, r)) return abs(r - p);\n  else return min(abs(l.first - p), abs(l.second - p));\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return 1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n \nxy_t p[3];\nline l[3];\nxy_t c;\ndouble r;\n\n\nint main(){\n  int x, y;\n  int c1, c2;\n  while(cin >> x>> y && (x || y)){\n    p[0] = xy_t(x, y);\n    for(int i = 1; i < 3; i++) {\n      cin >> x >> y;\n      p[i] = xy_t(x, y);\n    }\n    cin >> x >> y;\n    cin >> r;\n    c = xy_t(x, y);\n    \n    rep(i, 3) l[i] = line(p[i], p[(i+1)%3]);\n    c1 = 0, c2 = 0;\n    int cnt = 0;\n\n    rep(i, 3){\n      int d = ccw(p[i], p[(i+1)%3], c);\n      if(d > 0) c1++;\n      if(d < 0) c2++;\n    }\n    bool circle_in[3];\n    rep(i, 3){\n      if(distanceSP(l[i], c) > r - EPS){\n\tcircle_in[i] = true;\n      }else{\n\tcircle_in[i] = false;\n\tcnt++;\n      }\n    }\n    \n    bool t_in[3];\n    rep(i, 3){\n      if(abs(c - p[i]) < r + EPS){\n\tt_in[i] = true;\n\tcnt++;\n      }else{\n\tt_in[i] = false;\n      }\n    }\n    if(circle_in[0] && circle_in[1] && circle_in[2] && max(c1, c2) == 3){\n      cout << 'a' << endl;\n    }else if(t_in[0] && t_in[1] && t_in[2]) {\n      cout << 'b' << endl;\n    }else if(cnt > 0){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\ntypedef complex<double> P;\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nint chk(P a,P b,double r){\n\tdouble t = abs(a-b) - r;\n\tif( fabs(t) < EPS ) return 0;\n\treturn t < 0 ? -1 : 1;\n}\ndouble cross(P a,P b){\n\treturn imag(a*conj(b));\n}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\n\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nint main(){\n\tP a,b,c,d;\n\tdouble r;\n\twhile(cin >> a.real() >> a.imag() , a.real() != 0 || a.imag() != 0 ){\n\t\tcin >> b.real() >> b.imag();\n\t\tcin >> c.real() >> c.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tcin >> r;\n\t\t\n\t\tint in = 0;\n\t\tint mk = cross(a-d,b-d) <= 0 ;\n\t\tif( mk == (cross(b-d,c-d) <= 0) && mk == (cross(c-d,a-d) <= 0)){\n\t\t\tin = 1;\n\t\t}\n\t\t\n\t\tif( chk(a,d,r) <= 0 &&  chk(b,d,r) <= 0 &&  chk(c,d,r) <= 0 ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( chk(a,d,r) >= 0 &&  chk(b,d,r) >= 0 &&  chk(c,d,r) >= 0){\n\t\t\tif( in ){\n\t\t\t\tcout << \"a\" << endl;\n\t\t\t}else if( distanceSP(L(a,b),d) < r - EPS || distanceSP(L(b,c),d) < r - EPS || distanceSP(L(a,c),d) < r - EPS  ){\n\t\t\t\tcout << \"c\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"d\" << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-c,ar=d-a;\n\tP bb=b-a,br=d-b;\n\tP cc=c-b,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tcin>>r;\n\t\t// cout<<r<<endl;\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(t<r){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(r>abs(z[0]-z[3])&&r>abs(z[1]-z[3])&&r>abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t}\n\t\telse if(r>abs(z[0]-z[3])||r>abs(z[1]-z[3])||r>abs(z[2]-z[3])){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse cout<<\"d\\n\";\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n      getline(cin, str);\n\n      if(i == 0 && str == \"0 0\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\") break;\n\n\n    if(distance(&d->p[0], &c->p) < c->radius&& distance(&d->p[1], &c->p) < c->radius&& distance(&d->p[2], &c->p) < c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) > c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) > c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) > c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) < distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) < distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) < distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else if(dist_line(&d->p[0], &d->p[1], &d->p[2]) < distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) < distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) < distance(&d->p[2], &c->p))\n            cout << 'a' << endl;\n        else\n          cout << 'c' << endl;\n    }\n    else{\n      cout << 'c' << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L() {}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ntypedef  vector<P> polygon;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& Po, const P& p) {\n  bool in = false;\n  for (int i = 0; i < Po.size(); ++i) {\n    P a = curr(Po,i) - p, b = next(Po,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nint main() {\n  while(1) {\n    P p[3];\n    bool f=0;\n    REP(i,3) {\n      int x, y;\n      cin >> x >> y;\n      if (x==0&&y==0){ f=1;break;}\n      p[i] = P(x,y);\n    }\n    if (f) break;\n    P c;\n    int x, y;\n    cin >> x >> y;\n    c = P(x,y);\n    double r;\n    cin >> r;\n\n    polygon Po;\n    REP(i,3) {\n      Po.push_back(p[i]);\n    }\n    L l[3];\n    REP(i,3)\n      l[i] = L(p[i], p[(i+1)%3]);\n    double d[3];\n    REP(i,3) {\n      d[i] = distanceSP(l[i], c);\n    }\n    if (abs(p[0]-c) < r+EPS && abs(p[1]-c) < r+EPS && abs(p[2]-c) < r+EPS) {\n      cout << \"b\" << endl;\n    } else if (contains(Po, c) == IN && d[0] > r-EPS && d[1] > r-EPS && d[2] > r-EPS) {\n      cout << \"a\" << endl;\n    } else if (d[0] < r+EPS || d[1] < r+EPS || d[2] < r+EPS) {\n      cout << \"c\" << endl;\n    } else\n      cout << \"d\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3, p; long double r; Segment l1, l2, l3;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> p.px >> p.py >> r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, p) <= r && dst(p2, p) <= r && dst(p3, p) <= r) printf(\"b\\n\");\n\t\telse if(dst(l1, p) > r && dst(l2, p) > r && dst(l3, p) > r) printf(contain({p1, p2, p3}, p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Point{ int x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Point c; int r; };\n\ninline double dist(const Point &p1, const Point &p2)\n{\n\treturn sqrt( pow(p2.x-p1.x,2.0)+pow(p2.y-p1.y,2.0) );\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) > 0;\n}\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( !isLeft( t.a, t.b, p ) )\n\t\treturn false;\n\tif( !isLeft( t.b, t.c, p ) )\n\t\treturn false;\n\tif( !isLeft( t.c, t.a, p ) )\n\t\treturn false;\n\n\treturn true;\n}\ndouble dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble b = 1;\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + b * p.y + c ) / sqrt( pow(a,2.0)+pow(b,2.0) );\n\t}\n}\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r <= dist( t.a, t.b, c.c ) &&\n\t\t\tc.r <= dist( t.b, t.c, c.c ) &&\n\t\t\tc.r <= dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) <= c.r &&\n\t  dist( t.b, c.c ) <= c.r &&\n\t  dist( t.c, c.c ) <= c.r )\n\t  return true;\n  else\n\t  return false;\n}\nbool isCross(const Point &p1, const Point &p2, const Circle &c)\n{\n\tif( dist( p1, p2, c.c ) > c.r )\n\t\treturn false;\n\telse{\n\t\tdouble l = dist( p1, p2 );\n\t\tif( ( dist(p1, c.c)>c.r && dist(p2,c.c)>c.r+l ) ||\n\t\t\t( dist(p2, c.c)>c.r && dist(p1,c.c)>c.r+l ) )\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( !isCross(t.a,t.b,c) && !isCross(t.b,t.c,c) && !isCross(t.c,t.a,c) )\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t, c ) )\n\t\treturn 'b';\n\tif( false == isCross( t,c ) )\n\t\treturn 'd';\n\telse\n\t\treturn 'c';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<double,double> pdd;\nstatic const double EPS = 1e-9;\n\ntemplate<class T>\nT sqr(T obj0) {\n\treturn obj0 * obj0;\n}\n\nint is_cross(pdd l0, pdd l1, pdd p, double r) {\n\tpdd a,b,c;\n\n\ta.x = l0.x - p.x; a.y = l0.y - p.y;\n\tb.x = l1.x - p.x; b.y = l1.y - p.y;\n\tc.x = a.x - b.x; c.y = a.y - b.y;\n\n\tdouble d0, d1, d2, dist;\n\tdouble h;\n\n\th = abs(a.x * b.y - a.y * b.x) / abs(sqrt(c.x * c.x + c.y * c.y));\n\n\td0 = sqrt(sqr(c.x) + sqr(c.y));\n\td1 = sqrt(sqr(a.x) + sqr(a.y) - sqr(h));\n\td2 = sqrt(sqr(b.x) + sqr(b.y) - sqr(h));\n\n\tif(fabs(d0 - (d1 + d2)) < EPS)\n\t\tdist = h;\n\telse\n\t\tdist = min(sqrt(sqr(a.x) + sqr(a.y)), sqrt(sqr(b.x) + sqr(b.y)));\n\n\tif(fabs(dist - r) < EPS && dist <= r && r <= max(sqrt(sqr(a.x) + sqr(a.y)), sqrt(sqr(b.x) + sqr(b.y))))\n\t\treturn 2;\n\tif(dist <= r && r <= max(sqrt(sqr(a.x) + sqr(a.y)), sqrt(sqr(b.x) + sqr(b.y))))\n\t\treturn 1;\n\treturn 0;\n}\n\nbool in_triangle(vector<pdd> tri, pdd p) {\n\tdouble s, t;\n\tpdd a, b, c;\n\n\ta.x = tri[1].x - tri[0].x; a.y = tri[1].y - tri[0].y;\n\tb.x = tri[2].x - tri[0].x; b.y = tri[2].y - tri[0].y;\n\tc.x = p.x - tri[0].x; c.y = p.y - tri[0].y;\n\n\ts = (c.x * b.y - c.y * b.x) / (a.x * b.y - a.y * b.x);\n\tt = (c.y * a.x - c.x * a.y) / (a.x * b.y - a.y * b.x);\n\n\tif(0 <= s + t && s + t <= 1 && 0 <= s && 0 <= t)\n\t\treturn true;\n\treturn false;\n}\n\n/*\nbool in_circle(vector<pdd> t, pdd p, double r) {\n\tbool flg = true;\n\tfor(int i = 0; i < 3; i++) {\n\t\tdouble tmp;\n\t\ttmp = sqr(t[i].x - p.x) + sqr(t[i].y - p.y);\n\t\tflg &= tmp <= r;\n\t}\n\n\treturn flg;\n}\n*/\n\nint main() {\n\twhile(true) {\n\t\tvector<pdd> tri;\n\t\tpdd c;\n\t\tdouble r;\n\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tdouble tmpx, tmpy;\n\t\t\tcin >> tmpx >> tmpy;\n\t\t\ttri.push_back(pdd(tmpx, tmpy));\n\t\t\tif(i == 0 && tri[0].x == 0 && tri[0].y == 0)\n\t\t\t\tgoto label;\n\t\t}\n\t\tcin >> c.x >> c.y >> r;\n\n\t\tbool flg0, flg1, flg2;\n\t\tflg0 = true;\n\t\tflg1 = false;\n\t\tflg2 = false;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tflg0 &= ((sqr(c.x - tri[i].x) + sqr(c.y - tri[i].y)) <= r * r);\n\t\t}\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tint tmp;\n\t\t\ttmp = is_cross(tri[i % 3], tri[(i + 1) % 3], c, r);\n\t\t\tflg1 |= tmp;\n\t\t\tif(tmp == 2)\n\t\t\t\tflg2 = true;\n\t\t}\n\n//\t\tcout << boolalpha << flg0 << \" \" << flg1 << endl;\n\n\t\tif(flg0)\n\t\t\tcout << \"b\" << endl;\n\t\telse if((!flg1 || flg2)&& in_triangle(tri, c))\n\t\t\tcout << \"a\" << endl;\n\t\telse if(flg1)\n\t\t\tcout << \"c\" << endl;\n\t\telse\n\t\t\tcout << \"d\" << endl;\n\t}\nlabel:;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-6\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    if (norm(a) < r2) {\n      c[i] = -1;\n    } else if (norm(a) > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0. && c[1]>=0. && c[2]>=0.) {\n    return 1;\n  } else if (c[0]<=0. && c[1]<=0. && c[2]<=0.) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double na, nb, dab, d, sd, s, t;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    na = norm(a);\n    nb = norm(b);\n    dab = dot(a,b);\n    d = dab*dab - na*(nb-r*r);\n    if (d < -EPS) {\n      continue;\n    } else if (fabs(d) < EPS) {\n      d = 0.;\n    }\n    sd = sqrt(d);\n    s = (dab+sd)/na;\n    t = (dab-sd)/na;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (fabs(d) < EPS) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD dis(P a,P b){\n\treturn sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\ndouble x1,x2,x3,y4,y2,y3,x,y,r;\nmain(){\n\twhile(cin>>x1>>y4,x1||y4){\n\t\tcin>>x2>>y2>>x3>>y3>>x>>y>>r;\n\t\tif(dis(P(x1,y4),P(x,y))<r&&dis(P(x2,y2),P(x,y))<r&&dis(P(x3,y3),P(x,y))<r)cout<<'b'<<endl;\n\t\telse if(distSP(P(x1,y4),P(x2,y2),P(x,y))<=r||distSP(P(x3,y3),P(x2,y2),P(x,y))<=r||distSP(P(x1,y4),P(x3,y3),P(x,y))<=r)cout<<'c'<<endl;\n\t\telse if(ccw(P(x1,y4),P(x2,y2),P(x,y))==ccw(P(x2,y2),P(x3,y3),P(x,y))==ccw(P(x3,y3),P(x1,y4),P(x,y)))cout<<'a'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])==OUT)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[i])==IN)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0]))break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        if(contains(g,c))puts(\"a\");\n        else if(contains(c,g))puts(\"b\");\n        else{\n            bool x=false;\n            for(int i=0;i<g.size();i++){\n                if(intersectCS(c,Segment(g[i],next(g,i))))x=true;\n            }\n            puts(x?\"c\":\"d\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\twhile (true) {\n\t\tbool fin = false;\n\t\tvector<int> x(3), y(3);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tif (i == 0 && x[i] == 0 && y[i] == 0) {\n\t\t\t\tfin = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (fin) break;\n\t\tint xc, yc, r;\n\t\tcin >> xc >> yc >> r;\n\t\tvector<int> crs(3);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint vx = xc - x[i], vy = yc - y[i];\n\t\t\tint wx = x[(i + 1) % 3] - x[i], wy = y[(i + 1) % 3] - y[i];\n\t\t\tcrs[i] = vx * wy - wx * vy;\n\t\t}\n\t\tbool inner = true;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (1LL * crs[i] * crs[(i + 1) % 3] < 0) {\n\t\t\t\tinner = false;\n\t\t\t}\n\t\t}\n\t\tint contain = 0;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint dx = x[i] - xc, dy = y[i] - yc;\n\t\t\tif (dx * dx + dy * dy <= r * r) {\n\t\t\t\t++contain;\n\t\t\t}\n\t\t}\n\t\tint intersect = 0, border = 0;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint dx = x[(i + 1) % 3] - x[i], dy = y[(i + 1) % 3] - y[i];\n\t\t\tint px = x[i] - xc, py = y[i] - yc;\n\t\t\tint qx = x[(i + 1) % 3] - xc, qy = y[(i + 1) % 3] - yc;\n\t\t\tif (px * px + py * py <= r * r || qx * qx + qy * qy <= r * r) {\n\t\t\t\t++intersect;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint pdot = dx * px + dy * py;\n\t\t\t\tint qdot = dx * qx + dy * qy;\n\t\t\t\tif (pdot <= 0 && qdot >= 0) {\n\t\t\t\t\tlong long ca = 1LL * crs[i] * crs[i];\n\t\t\t\t\tlong long cb = 1LL * (dx * dx + dy * dy) * (r * r);\n\t\t\t\t\tif (ca <= cb) {\n\t\t\t\t\t\t++intersect;\n\t\t\t\t\t}\n\t\t\t\t\tif (ca == cb) ++border;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inner) {\n\t\t\tif (contain == 3) {\n\t\t\t\tcout << \"b\" << endl;\n\t\t\t}\n\t\t\telse if (intersect - border == 0) {\n\t\t\t\tcout << \"a\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"c\" << endl;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (contain == 3) {\n\t\t\t\tcout << \"b\" << endl;\n\t\t\t}\n\t\t\telse if (intersect == 0) {\n\t\t\t\tcout << \"d\" << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"c\" << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\n\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-9;\nconst double INF = 1e8;\n\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\nint main(){\n  G p;\n  L l[3];\n  C c;\n  p.resize(3);\n  while(cin >> p[0].real() >> p[0].imag(), p[0].real()||p[0].imag()){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> p[i].real() >> p[i].imag();\n    }\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      l[i] = L( p[i], p[(i+1)%3]);\n    }\n\n    bool flag = true;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(distance( l[i], c.p ) < c.r) flag = false;\n    }\n    if(flag && contains( p, c.p)){\n      cout << 'a' << endl;\n      continue;\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(!contains( c, p[i])) flag = true;\n    }\n    if(!flag){\n      cout << 'b' << endl;\n      continue;\n    }\n\n    flag = false;\n    for(int i = 0 ; i < 3 ; i++ ){\n      flag |= !!intersect( c, l[i]);\n    }\n    if(flag){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point>& ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  int x[4];\n  int y[4];\n  while(~scanf(\"%d %d\",&x[0],&y[0])){\n    if(x[0] == 0 && y[0] == 0) break;\n\n    for(int i=1;i<4;i++){\n      scanf(\"%d %d\",&x[i],&y[i]);\n    }\n    int r;\n    scanf(\"%d\",&r);\n\n    vector<Line> lines;\n    vector<Point> points;\n\n    for(int i=0;i<4;i++){\n      points.push_back(Point(x[i],y[i]));\n    }\n\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        lines.push_back(Line(Point(x[i],y[i]),Point(x[j],y[j])));\n      }\n    }\n\n    vector<Point> convex_hull = compute_convex_hull(points);\n\n    if(convex_hull.size() == 3){\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n      }\n\n      if(r <= dist + EPS){\n        //a\n        printf(\"a\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n        }\n        if(r > dist){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n\n      }\n    }\n\n    else if(convex_hull.size() == 4){\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n      }\n\n      if(dist > r){\n        //d\n        printf(\"d\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n        }\n        \n        if(r <= dist + EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n      }\n    }\n\n    else{\n      assert(0);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define EPS 1E-10\n#define SAME_SIGN( a , b ) a * b > EPS\n\nnamespace geometry{\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) <= cir.radius  &&\n\t\tget_distance( tri.b , cir.center ) <= cir.radius  &&\n\t\tget_distance( tri.c , cir.center ) <= cir.radius\n\t\t){\n\t\t\tstd::cout << \"b\" << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius  &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius  &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << \"a\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << \"d\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << \"c\" << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << \"c\" << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    double ans=0;\n    for(int i=0;i<3;i++){\n\tint tmp=dist(p[i],C.p);\n\tif(tmp>ans){\n\t  ans=tmp;\n\t}\n    }\n    if(C.r>ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n    \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=1000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntypedef complex<double> P;\n\nint x, y, r;\nP tri[3];\npair<P,double> circle;\n\ndouble cross(P& e1, P& e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 >= 0 && d1 * d2 >= 0 && d2 * d0 >= 0) return true;\n\treturn false;\n}\n\ndouble norm(P p) {\n\treturn sqrt(p.real() * p.real() + p.imag() * p.imag());\n}\n\ndouble dist(P p1, P p2, P p) {\n\tdouble a = p2.imag() - p1.imag();\n\tdouble b = -(p2.real() - p1.real());\n\tdouble c = - a * p1.real() - b * p1.imag();\n\tdouble nm = a * p.real() + b * p.imag() + c;\n\tdouble de = a * a + b * b;\n\tif(de == 0.0) {\n\t\treturn norm(p1 - p);\n\t}\n\treturn abs(nm) / sqrt(de);\n}\n\n\nvoid solve() {\n\tbool iscin = inc();\n\tdouble R = circle.second;\n\tvector<double> d(6, 0.0);\n\td[0] = dist(tri[0], tri[1], circle.first);\n\td[1] = dist(tri[1], tri[2], circle.first);\n\td[2] = dist(tri[2], tri[0], circle.first);\n\t// printf(\"%f %f %f\\n\", d[0], d[1], d[2]);\n\tif(iscin && d[0] > R && d[1] > R && d[2] > R) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\td[3] = norm(tri[0] - circle.first);\n\td[4] = norm(tri[1] - circle.first);\n\td[5] = norm(tri[2] - circle.first);\n\t// printf(\"%f %f %f\\n\", d[3], d[4], d[5]);\n\tif(d[3] < R && d[4] < R && d[5] < R) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(d[0] < R) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\nclass Circle {\npublic:\n\tPoint p; long double r;\n\tCircle() : p(Point()), r(0.0L) {};\n\tCircle(Point p_) : p(p_), r(0.0L) {};\n\tCircle(Point p_, long double r_) : p(p_), r(r_) {};\n\tCircle(long double x_, long double y_) : p(Point(x_, y_)), r(0.0L) {};\n\tCircle(long double x_, long double y_, long double r_) : p(Point(x_, y_)), r(r_) {};\n\tfriend bool operator==(const Circle& c1, const Circle& c2) { return c1.p == c2.p && c1.r == c2.r; }\n\tfriend bool operator!=(const Circle& c1, const Circle& c2) { return !(c1 == c2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nlong double dst(const Segment& a, const Segment& b) {\n\tif (its(a, b)) return 0;\n\treturn min( { dst(a, b.p1), dst(a, b.p2), dst(b, a.p1), dst(b, a.p2) });\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3; Segment l1, l2, l3; Circle c;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> c.p.px >> c.p.py >> c.r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, c.p) <= c.r && dst(p2, c.p) <= c.r && dst(p3, c.p) <= c.r) printf(\"b\\n\");\n\t\telse if(dst(l1, c.p) >= c.r && dst(l2, c.p) >= c.r && dst(l3, c.p) >= c.r) printf(contain({p1, p2, p3}, c.p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline int less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tP dir()const {return SELF[1] - SELF[0];}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tbool online(const P &p)const {return !sig(outp(p-SELF[0], dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - SELF[0])) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tbool online(const P &p){\n\t\t\tif(!sig(abs(p - SELF[0])) || !sig(abs(p - SELF[1]))) return BORDER;\n\t\t\treturn !sig(abs(SELF[0]-p) + abs(SELF[1] - p) - abs(SELF[0] - SELF[1]));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-SELF[0],  dir()) < EPS) return abs(p - SELF[0]);\n\t\t\tif(inp(p-SELF[1], -dir()) < EPS) return abs(p - SELF[1]);\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tbool inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t\tfriend inline bool cc_intersect(const C &a, const C &b){\n\t\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\t\treturn abs(a-b)<a.r+b.r+EPS && abs(a-b)>abs(a.r - b.r)-EPS;\n\t\t}\n\t\tfriend inline bool cl_intersect(const C &c, const L &l){\n\t\t\treturn less(l.distance(c), c.r);\n\t\t}\n\t\tfriend inline bool cs_intersect(const C &c, const S &s){\n\t\t\treturn (!c.inside(s[0]) | !c.inside(s[1])) & less(s.distance(c), c.r);\n\t\t}\n\t};\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tbool contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(L(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\t\n\t\tbool contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return false;\n\t\t\tR sum = .0;\n\t\t\tint res = 1;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || cs_intersect(c, edge(i)) == TRUE) return false;\n\t\t\t\telse res |= c.inside(at(i)) | cs_intersect(c, edge(i));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t};\n#undef SELF\n#undef at\n};\nusing namespace geom;\n\nint n;\n\nchar check(const C& c, const G &g){\n\tif(g.contains(c)) return 'a';\n\tint f = 1;\n\tREP(i, 3) if(!c.inside(g[i])) f = 0;\n\tif(f) return 'b';\n\tREP(i, 3) if(cs_intersect(c, g.edge(i))) return 'c';\n\treturn 'd';\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tG g;\n\t\tC c;\n\t\tREP(i, 3){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\tif(p.X == 0) return 0;\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcin >> c;\n\t\tcout << check(c, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\nPolygon ConvexHull(vector<Point> ps){\n\tint n=ps.size();\n\tsort(ps.begin(),ps.end());\n\n\tvector<Point> ch_u(n);\n\tint n_u=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tch_u[n_u++]=ps[i];\n\t\twhile(n_u>=3 && ccw(ch_u[n_u-3],ch_u[n_u-2],ch_u[n_u-1])!=CCW){\n\t\t\tch_u[n_u-2]=ch_u[n_u-1];\n\t\t\tn_u--;\n\t\t}\n\t}\n\n\tvector<Point> ch_l(n);\n\tint n_l=0;\n\tfor(int i=0;i<n;i++){\n\t\tch_l[n_l++]=ps[i];\n\t\twhile(n_l>=3 && ccw(ch_l[n_l-3],ch_l[n_l-2],ch_l[n_l-1])!=CCW){\n\t\t\tch_l[n_l-2]=ch_l[n_l-1];\n\t\t\tn_l--;\n\t\t}\n\t}\n\n\tPolygon ch;\n\tfor(int i=0;i<n_u-1;i++)\tch.pb(ch_u[i]);\n\tfor(int i=0;i<n_l-1;i++)\tch.pb(ch_l[i]);\n\treturn ch;\n}\n/*\nbool parallel(const Line &l,const Line &m){\n\treturn abs(cross(l[1]-l[0],m[1]-m[0]))<EPS;\n}\n\nbool orthogonal(const Line &l,const Line &m){\n\treturn abs(dot(l[1]-l[0],m[1]-m[0]))<EPS;\n}\n*/\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nPoint perp_foot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\treturn p-(a*p.x+b*p.y+c)/(a*a+b*b)*Point(a,b);\n}\n\nLine perp_bisector(const Point &a,const Point &b){\n\treturn Line(Point((a.x+a.y+b.x-b.y)/2,(b.x+b.y-a.x+a.y)/2),\n\t\t\t\tPoint((b.x+b.y+a.x-a.y)/2,(a.x+a.y-b.x+b.y)/2));\n}\n\nbool intersect(const Line &l,const Line &m,Point *p=NULL){\n\t// this routine also returns true in case \"M is on L\", etc,.\n\tif(abs(cross(l[1]-l[0],m[1]-m[0]))>EPS\n\t|| abs(cross(l[1]-l[0],m[0]-l[0]))<EPS){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(l,a1,b1,c1);\n\t\t\tcalc_abc(m,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS)\t*p=l[0];\t// l == m\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(s[0].x,s[1].x)<min(t[0].x,t[1].x)\n\t|| max(t[0].x,t[1].x)<min(s[0].x,s[1].x)\n\t|| max(s[0].y,s[1].y)<min(t[0].y,t[1].y)\n\t|| max(t[0].y,t[1].y)<min(s[0].y,s[1].y))\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp->x=(b1*c2-b2*c1)/det;\n\t\t\t\tp->y=(a2*c1-a1*c2)/det;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint intersect(const Circle &c,const Line &l,Point *p=NULL,Point *q=NULL){\n\tPoint m=perp_foot(c.c,l);\n\tdouble d2=norm2(c.c-m);\n\tif(c.r*c.r+EPS<d2)\treturn 0;\n\telse if(abs(c.r*c.r-d2)<EPS){\n\t\tif(p&&q)\t*p=*q=m;\n\t\treturn 1;\n\t}\n\telse{\n\t\tif(p&&q){\n\t\t\tPoint v;\n\t\t\tdouble n0=norm2(l[0]-m),n1=norm2(l[1]-m);\n\t\t\tif(n0<n1)\tv=l[1]-m,n0=n1;\n\t\t\telse\t\tv=l[0]-m;\n\t\t\tv*=sqrt((c.r*c.r-d2)/n0);\n\t\t\t*p=m+v,*q=m-v;\n\t\t}\n\t\treturn 2;\n\t}\n}\n\nint intersect(const Circle &c,const Segment &s,Point *p=NULL,Point *q=NULL){\n\tPoint pp,qq;\n\tint n=intersect(c,Line(s[0],s[1]),&pp,&qq);\n\tif(n==0)\treturn 0;\n\telse if(n==1){\n\t\tif(dot(pp-s[0],pp-s[1])<EPS){\n\t\t\tif(p&&q)\t*p=*q=pp;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\telse{\n\t\tbool bp=(dot(pp-s[0],pp-s[1])<EPS);\n\t\tbool bq=(dot(qq-s[0],qq-s[1])<EPS);\n\t\tif(bp&&bq){\n\t\t\tif(p&&q)\t*p=pp,*q=qq;\n\t\t\treturn 2;\n\t\t}\n\t\tif(bp||bq){\n\t\t\tif(p&&q)\t*p=(bp?pp:qq);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nint intersect(const Circle &c1,const Circle &c2,Point *p=NULL,Point *q=NULL){\n\tdouble d2=norm2(c1.c-c2.c);\n\tif(d2<EPS && abs(c1.r-c2.r)<EPS)\treturn -1;\t// c1==c2\n\telse if((c1.r+c2.r)*(c1.r+c2.r)+EPS<d2 || d2+EPS<(c1.r-c2.r)*(c1.r-c2.r))\treturn 0;\n\telse if(abs(c1.r+c2.r-d2)<EPS){\n\t\tif(p&&q)\tintersect(c1,Segment(c1.c,c2.c),p,q);\n\t\treturn 1;\n\t}\n\telse{\n\t\tif(p&&q){\n\t\t\tdouble d=sqrt(d2);\n\t\t\tdouble a=(c1.r*c1.r-c2.r*c2.r+d2)/(2*d);\n\t\t\tdouble h=sqrt(c1.r*c1.r-a*a);\n\t\t\tPoint m=c1.c+a/d*(c2.c-c1.c);\n\t\t\t*p=*q=c2.c;\n\t\t\tp->x+=h*(c2.c.y-c1.c.y)/d;\n\t\t\tp->y-=h*(c2.c.x-c1.c.x)/d;\n\t\t\tq->x-=h*(c2.c.y-c1.c.y)/d;\n\t\t\tq->y+=h*(c2.c.x-c1.c.x)/d;\n\t\t}\n\t\treturn 2;\n\t}\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(Point p,q,r;scanf(\"%lf%lf%lf%lf%lf%lf\",&p.x,&p.y,&q.x,&q.y,&r.x,&r.y),p.x||p.y;){\n\t\tCircle c;\tscanf(\"%lf%lf%lf\",&c.c.x,&c.c.y,&c.r);\n\n\t\tint cnt=ccw(p,q,c.c)+ccw(q,r,c.c)+ccw(r,p,c.c);\n\t\tPoint s=perp_foot(c.c,Line(p,q));\n\t\tPoint t=perp_foot(c.c,Line(q,r));\n\t\tPoint u=perp_foot(c.c,Line(r,p));\n\t\tif((cnt==3*CCW || cnt==3*CW)\n\t\t&& c.r*c.r<norm2(s-c.c)+EPS\n\t\t&& c.r*c.r<norm2(t-c.c)+EPS\n\t\t&& c.r*c.r<norm2(t-c.c)+EPS){\n\t\t\tputs(\"a\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(norm2(p-c.c)<c.r*c.r+EPS\n\t\t&& norm2(q-c.c)<c.r*c.r+EPS\n\t\t&& norm2(r-c.c)<c.r*c.r+EPS){\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(intersect(c,Segment(p,q))==0\n\t\t&& intersect(c,Segment(q,r))==0\n\t\t&& intersect(c,Segment(r,p))==0){\n\t\t\tputs(\"d\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tputs(\"c\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntypedef complex<int> P;\n\nint x, y, r;\nP tri[3];\npair<P,int> circle;\n\nint cross(P e1, P e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tint d0 = cross(e0, e1);\n\tint d1 = cross(e1, e2);\n\tint d2 = cross(e2, e0);\n\tif(d0 * d1 >= 0 && d1 * d2 >= 0 && d2 * d0 >= 0) return true;\n\treturn false;\n}\n\nint norm2(P p) {\n\treturn p.real() * p.real() + p.imag() * p.imag();\n}\n\nvoid dist2(P p1, P p2, P p, int& nm, int& de) {\n\tint a = p2.imag() - p1.imag();\n\tint b = -(p2.real() - p1.real());\n\tint c = - a * p1.real() - b * p1.imag();\n\tnm = a * p.real() + b * p.imag() + c;\n\tnm = nm * nm;\n\tde = a * a + b * b;\n\tif(de == 0) {\n\t\tnm = norm2(p1 - p);\n\t\tde = 1;\n\t}\n}\n\n\nvoid solve() {\n\tbool iscin = inc();\n\tint r2 = circle.second * circle.second;\n\tvector<pii> d(6);\n\tdist2(tri[0], tri[1], circle.first, d[0].first, d[0].second);\n\tdist2(tri[1], tri[2], circle.first, d[1].first, d[1].second);\n\tdist2(tri[2], tri[0], circle.first, d[2].first, d[2].second);\n\tif(iscin && (d[0].first >= r2 * d[0].second) &&\n\t\t        (d[1].first >= r2 * d[1].second) &&\n\t\t        (d[2].first >= r2 * d[2].second)) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\td[3].first = norm2(tri[0] - circle.first); d[3].second = 1;\n\td[4].first = norm2(tri[1] - circle.first); d[4].second = 1;\n\td[5].first = norm2(tri[2] - circle.first); d[5].second = 1;\n\tif(d[3].first <= r2 && d[4].first <= r2 && d[5].first <= r2) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tbool inter = false;\n\trep(i,6) {\n\t\tif(d[i].first <= r2 * d[i].second) {\n\t\t\tinter = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(inter) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n\nconst double EPS=1e-6;\nconst double INFTY=1e12;\ntypedef complex<double> Point;\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x>0?1:-1;\n}\n\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tint sign=Signum(Cross(d1,d2));\n\t\n\tif(sign)\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\n// ツ点ツづ陳シツ静シツづ個仰猟猟」\ndouble DistancePL(Point p,Line l)\n{\n\treturn abs(Cross(p-l.pos,l.dir))/abs(l.dir);\n}\n// ツ点ツづ静シツ閉ェツづ個仰猟猟」\ndouble DistancePS(Point p,Line s)\n{\n\tPoint a=p-s.pos,b=s.dir;\n\tPoint c=b*Dot(a,b)/norm(b);\n\tint pos=CCW(Point(0,0),b,c);\n\tif(pos==-2 || pos==2)\n\t\treturn min(abs(a),abs(b-a));\n\treturn abs(a-c);\n}\n\nvoid solve(Point p[],Point c,double r)\n{\n\t{\t// triangle in circle\n\t\tdouble dist=0;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=max(dist,norm(p[i]-c));\n\t\tif(dist<=r*r){\n\t\t\tputs(\"b\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t{\t// circle in triangle\n\t\tbool res=true;\n\t\tint ccw=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint temp=CCW(p[i],p[(i+1)%3],c);\n\t\t\tif(temp==-2 || temp==2)\n\t\t\t\tcontinue;\n\t\t\tres&=temp*ccw>=0;\n\t\t\tccw=temp;\n\t\t}\n\t\tif(res){\n\t\t\tdouble dist=INFTY;\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tdist=min(dist,DistancePL(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\t\tif(Signum(dist-r)>=0){\n\t\t\t\tputs(\"a\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t{\t// intersect\n\t\tdouble dist=INFTY;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=min(dist,DistancePS(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\tif(Signum(dist-r)<=0){\n\t\t\tputs(\"c\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tputs(\"d\");\n}\n\nint main()\n{\n\tfor(;;){\n\t\tPoint p[3],c;\n\t\tdouble r;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tcin>>real(p[i])>>imag(p[i]);\n\t\tcin>>real(c)>>imag(c)>>r;\n\t\tif(norm(p[0])==0)\n\t\t\tbreak;\n\t\t\n\t\tsolve(p,c,r);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define EPS 1E-7\n#define SAME_SIGN( a , b ) ( a * b > EPS ? true : false )\n\nnamespace geometry{\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) < cir.radius + EPS ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) < cir.radius + EPS  &&\n\t\tget_distance( tri.b , cir.center ) < cir.radius + EPS  &&\n\t\tget_distance( tri.c , cir.center ) < cir.radius + EPS\n\t\t){\n\t\t\tstd::cout << \"b\" << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius - EPS  &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius - EPS  &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius - EPS\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << \"a\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << \"d\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << \"c\" << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << \"c\" << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 0;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nD dis(P a,P b){\n\treturn sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\ndouble x1,x2,x3,y4,y2,y3,x,y,r;\nmain(){\n\twhile(cin>>x1>>y4,x1||y4){\n\t\tcin>>x2>>y2>>x3>>y3>>x>>y>>r;\n\t\tvector<P>v;\n\t\tv.push_back(P(x1,y4));\n\t\tv.push_back(P(x2,y2));\n\t\tv.push_back(P(x3,y3));\n\t\tif(inConvex(P(x,y),v)&&dis(P(x1,y4),P(x,y))>r&&dis(P(x2,y2),P(x,y))>r&&dis(P(x3,y3),P(x,y))>r)cout<<'a'<<endl;\n\t\telse if(dis(P(x1,y4),P(x,y))<r&&dis(P(x2,y2),P(x,y))<r&&dis(P(x3,y3),P(x,y))<r)cout<<'b'<<endl;\n\t\telse if(distSP(P(x1,y4),P(x2,y2),P(x,y))<=r||distSP(P(x3,y3),P(x2,y2),P(x,y))<=r||distSP(P(x1,y4),P(x3,y3),P(x,y))<=r)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-6;\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / abs(a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < Eps)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) <Eps)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(a, b, point);\n}\nbool is_in_triangle(const Point& point, const Point* triangle)\n{\n\tdouble t[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tt[i] = cross(triangle[(i+1)%3] - triangle[i], point - triangle[i]);\n\n\treturn t[0] >= 0 && t[1] >= 0 && t[2] >= 0\n\t\t|| t[0] <= 0 && t[1] <= 0 && t[2] <= 0;\n}\nbool is_in_triangle(const Point& point, const Point& a, const Point& b, const Point& c)\n{\n\tPoint t[3] = { a, b, c };\n\treturn is_in_triangle(point, t);\n}\nbool is_circle_in_triangle(const Point& center, double radius, const Point* triangle)\n{\n\tif (!is_in_triangle(center, triangle))\n\t\treturn false;\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_line_point(triangle[i], triangle[(i+1)%3], center) < radius + Eps)\n\t\t\treturn false;\n\treturn true;\n}\nbool is_triangle_in_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (abs(triangle[i]-center) > radius + Eps)\n\t\t\treturn false;\n\treturn true;\n}\nbool interect_triangle_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_linesegment_point(center, triangle[i], triangle[(i+1)%3]) < radius + Eps)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tint x[4], y[4], r;\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tscanf(\"%d %d\", x+i, y+i);\n\t\tscanf(\"%d\", &r);\n\t\tif (x[0] == 0 && y[0] == 0)\n\t\t\tbreak;\n\t\tPoint p[4];\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tp[i] = Point(x[i], y[i]);\n\n\t\tif (is_circle_in_triangle(p[3], r, p))\n\t\t\tputs(\"a\");\n\t\telse if (is_triangle_in_circle(p, p[3], r))\n\t\t\tputs(\"b\");\n\t\telse if (interect_triangle_circle(p, p[3], r))\n\t\t\tputs(\"c\");\n\t\telse\n\t\t\tputs(\"d\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> C;\n\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nbool tri_in_check() {\n  bool c[3];\n  C a;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    if (norm(a) < r2) {\n      c[i] = true;\n    } else {\n      c[i] = false;\n    }\n  }\n  return (c[0] && c[1] && c[2]);\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nbool intersect() {\n  C a, b;\n  double na, nb, dab, d, sd, s, t;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    na = norm(a);\n    nb = norm(b);\n    dab = dot(a,b);\n    d = dab*dab - na*(nb-r*r);\n    if (d < 0.) continue;\n    sd = sqrt(d);\n    s = (dab+sd)/na;\n    t = (dab-sd)/na;\n    if ((s>= 0.&&s<=1.) || (t>=0.&&t<=1.)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check()) {\n      cout << \"b\" << endl;\n    } else {\n      if (intersect()) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 0.0;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return fabs(source().distance(p) + target().distance(p) - target().distance(source())) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + (v1.dot(v2) / v2.norm()) * v2);\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n//     int edgesOutOfCircle = 0;\n//     for(auto& e: edge) {\n//         if(circle.center().distance(e) - circle.r() > EPS) ++edgesOutOfCircle;\n//     }\n//     if(edgesOutOfCircle != 3) return \"c\";\n    for(auto& e: edge) if(circle.center().distance(e) - circle.r() <= EPS) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) >= 0) ++ccw;\n        if(e.ccw(circle.center()) <= 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-4;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) < c.r - kyuriEPS ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r + kyuriEPS){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n    double tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n     \n    // a.pos[i] on B\n    double area = 0;\n    for(int j = 0 ; j < 3 ; j++){\n        area += fabs((t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x));\n    }\n    if( fabs( fabs(area) - tS2 ) < kyuriEPS ) return 0;  \n    else return 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-6\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    if (norm(a) < r2) {\n      c[i] = -1;\n    } else if (norm(a) > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0. && c[1]>=0. && c[2]>=0.) {\n    return 1;\n  } else if (c[0]<=0. && c[1]<=0. && c[2]<=0.) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double na, nb, dab, d, sd, s, t;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    na = norm(a);\n    nb = norm(b);\n    dab = dot(a,b);\n    d = dab*dab - na*(nb-r*r);\n    if (d < -EPS) {\n      continue;\n    }\n    sd = sqrt(d);\n    s = (dab+sd)/na;\n    t = (dab-sd)/na;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (fabs(d) < EPS) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    bool f=true;\n    for(int i=0;i<g.size();i++){\n        if(!contains(c,g[i]))f=false;\n    }\n    return f?IN:OUT;\n\n    for(int i=0;i<g.size();i++){\n        if(!contains(c,g[0]))return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        bool f=true;\n\n        if(contains(c,g)){\n            puts(\"b\");\n            continue;\n        }\n\n        f=true;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(distanceCS(c,s)<-EPS)f=false;\n        }\n        if(f&&contains(g,c.p)){\n            puts(\"a\");\n            continue;\n        }\n\n        f=false;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(intersectCS(c,s)){\n                f=true;\n            }\n        }\n\n        if(f){\n            puts(\"c\");\n        }\n        else puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r&&!EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r&&!EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r&&!EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n/*  0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), all(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n//???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\trep(i, n) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tedge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvoid add_edge(graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(edge{ from, to, weight });\n}\n\ngraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\ngraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll2(s[i], s[j])[0]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\ngraph Circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main() {\n\t\n\twhile (1) {\n\t\tint x1, y1; cin >> x1 >> y1;\n\t\tif (!x1)break;\n\t\tint x2, y2, x3, y3, x4, y4, r; cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tPolygon tri;\n\t\ttri.push_back(Point(x1, y1));\n\t\ttri.push_back(Point(x2, y2));\n\t\ttri.push_back(Point(x3, y3));\n\t\tCircle c(Point(x4, y4), r);\n\t\tbool flag_b = true;\n\t\t{\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tif (!is_in_Circle(c, tri[i])) {\n\t\t\t\t\tflag_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag_a = false;\n\t\tbool  flag_c = false;\n\t\t{\n\t\t\tif (is_in_Polygon(tri, c.p)) {\n\t\t\t\tflag_a = true;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tLine l(tri[i], tri[(i + 1) % 3]);\n\t\t\t\tld aa = dist_sp(l, c.p);\n\t\t\t\tif (dist_sp(l, c.p) - eps<c.r) {\n\t\t\t\t\tflag_a = false;\n\t\t\t\t\tflag_c = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag_b) {\n\t\t\tcout << 'b' << endl;\n\t\t}\n\t\telse if (flag_a) {\n\t\t\tcout << 'a' << endl;\n\t\t}\n\t\telse if (flag_c) {\n\t\t\tcout << 'c' << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 'd' << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\ntypedef struct circle{\n\tpoint p;\n\tdouble r;\n} circle;\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\ncircle make(point p,double r){ circle c;\n\tc.p = p ;\n\tc.r = r;\n\treturn c;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// circle_versino\nint ccw(circle c0,circle c1){\n\tdouble  d = abs(c0.p-c1.p);\n\tdouble r0 = c0.r,r1 = c1.r;\n\t\n\t//c0in c1\n\tif(d<r1-r0)return -2;\n\t//c1 in c0\n\tif(d<r0-r1)return 2;\n\t//c0 cross c1\n\tif(abs(r0-r1)<=d&&d<=r0+r1)return 1;\n\t//c0 not cross c1\n\treturn 0;\n\n}\n\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nint main(){\n\twhile(1){\n\tvector<point> tri(3);\n\ttri[0] = make();\n\tif(tri[0].x==0&&tri[0].y==0)break;\n\ttri[1] = make();\n\ttri[2] = make();\n\tvector<line> l(3);\n\tl[0] = make(tri[0],tri[1]);\n\tl[1] = make(tri[1],tri[2]);\n\tl[2] = make(tri[2],tri[0]);\n\n\tpoint p = make();\n\tdouble r ; cin>>r;\n\tcircle c = make(p,r);\n\t// circle in triangle\n\tif(r<=distance(l[0],p)&&r<=distance(l[1],p)&&\n\t\t\tr<=distance(l[2],p)&&contains(tri,p) ){\n\tcout<<'a'<<endl;\n\tcontinue;\n\t}\n\t// triangle in circle \n\tif(r>=distance(tri[0],p)&&r>=distance(tri[1],p)&&r>=distance(tri[2],p)){\n\tcout<<'b'<<endl;\n\tcontinue;\n\t}\n\t//cross\n\t\n\tif(r>=distance(tri[0],p)||r>=distance(tri[1],p)||r>=distance(tri[2],p)){\n\tcout<<'c'<<endl;\n\tcontinue;\n\t}\n\t\n\tcout<<'d'<<endl;\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> Po;\n\n\nPo p[3],o;\n\ndouble dot(Po x, Po y){return x.real()*y.real()+x.imag()*y.imag();}\n\ndouble cross(Po x, Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a, Po b, Po c){return abs(cross(b-a,c-a))/2;}\n\nbool inter(Po a, Po b, Po c, Po x){\n  return (fabs(area(a,b,x)+area(b,c,x)+area(c,a,x)-area(a,b,c)) < EPS);\n}\n\ndouble seg_dis(Po a, Po b, Po c){\n  if(dot(b-a,c-a)<EPS)return abs(c-a);\n  if(dot(a-b,c-b)<EPS)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nint main(){\n  double x[4],y[4],r;\n\n  for(;;){\n    cin >> x[0] >> y[0];\n    if(!x[0] && !y[0])break;\n\n    for(int i=1;i<4;i++)cin >> x[i] >> y[i];\n    cin >> r;\n\n    for(int i=0;i<3;i++)p[i] = Po(x[i],y[i]);\n    o = Po(x[3],y[3]);\n\n\n    bool f[3];\n    for(int i=0;i<3;i++)f[i] = (abs(o-p[i])<r+EPS);\n    if(f[0] && f[1] && f[2])cout << \"b\\n\";\n    else{\n      if(inter(p[0],p[1],p[2],o)){\n\tfor(int i=0;i<3;i++)f[i] = (seg_dis(p[i],p[(i+1)%3],o)>r+EPS);\n\tif(f[0] && f[1] && f[2])cout << \"a\\n\";\n\telse cout << \"c\\n\";\n      }else{\n\tfor(int i=0;i<3;i++)f[i] = (seg_dis(p[i],p[(i+1)%3],o)<r+EPS);\n\tif(f[0] || f[1] || f[2])cout << \"c\\n\";\n\telse cout << \"d\\n\";\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2){};\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn(s1.p1 + (s1.p2 - s1.p1) * t);\n}\n\ndouble arg(Vector p)\n{\n\treturn(atan2(p.y, p.x));\n}\n\nVector polar(double a, double r)\n{\n\treturn(Point(cos(r) * a, sin(r) * a));\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn(make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)));\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn(make_pair(pr - e * base, pr + e * base));\n}\n\nbool inc(Point p1, Point p2, Point p3, Point p4)\n{\n\tPoint e0 = p1 - p4;\n\tPoint e1 = p2 - p4;\n\tPoint e2 = p3 - p4;\n\tlong double d0 = cross(e0, e1);\n\tlong double d1 = cross(e1, e2);\n\tlong double d2 = cross(e2, e0);\n\tif (d0 * d1 > 0 && d1 * d2 > 0 && d2 * d0 > 0)\n\t{\n\t\treturn(true);\n\t}\n\treturn(false);\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tPoint p1;\n\twhile (cin >> p1.x >> p1.y, p1.x || p1.y)\n\t{\n\t\tPoint p2, p3, p4;\n\t\tint r;\n\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y >> r;\n\t\t\n\t\tif (r - getDistance(p4, p1) >= 0 && r - getDistance(p4, p2) >= 0 && r - getDistance(p4, p3) >= 0)\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if (inc(p1, p2, p3, p4) && getDistanceSP(Segment(p1, p2), p4) - r >= 0 && getDistanceSP(Segment(p1, p3), p4) - r >= 0 && getDistanceSP(Segment(p2, p3), p4) - r >= 0)\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse if (inc(p1, p2, p3, p4) == false && getDistanceSP(Segment(p1, p2), p4) - r > 0 && getDistanceSP(Segment(p1, p3), p4) - r > 0 && getDistanceSP(Segment(p2, p3), p4) - r > 0)\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tP dir()const {return SELF[1] - SELF[0];}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-SELF[0], dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - SELF[0])) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tBOOL online(const P &p){\n\t\t\tif(!sig(abs(p - SELF[0])) || !sig(abs(p - SELF[1]))) return BORDER;\n\t\t\treturn !sig(abs(SELF[0]-p) + abs(SELF[1] - p) - abs(SELF[0] - SELF[1]));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-SELF[0],  dir()) < EPS) return abs(p - SELF[0]);\n\t\t\tif(inp(p-SELF[1], -dir()) < EPS) return abs(p - SELF[1]);\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t\tfriend inline BOOL cc_intersect(const C &a, const C &b){\n\t\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t\t}\n\t\tfriend inline int cl_intersect(const C &c, const L &l){\n\t\t\treturn less(l.distance(c), c.r);\n\t\t}\n\t\tfriend inline int cs_intersect(const C &c, const S &s){\n\t\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]);\n\t\t\treturn less(s.distance(c), c.r);\n\t\t}\n\t};\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\t\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || less(edge(i).distance(c), c.r) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | less(edge(i).distance(c), c.r);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t};\n#undef SELF\n#undef at\n};\nusing namespace geom;\n\nint n;\n\nchar check(const C& c, const G &g){\n\tif(g.contains(c)) return 'a';\n\tint f = 1;\n\tREP(i, 3) if(!c.inside(g[i])) f = 0;\n\tif(f) return 'b';\n\tREP(i, 3) if(cs_intersect(c, g.edge(i))) return 'c';\n\treturn 'd';\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tG g;\n\t\tC c;\n\t\tREP(i, 3){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\tif(p.X == 0) return 0;\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcin >> c;\n\t\tcout << check(c, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return fabs(source().distance(p) + target().distance(p) - target().distance(source())) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + (v1.dot(v2) / v2.norm()) * v2);\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) >= 0) ++ccw;\n        if(e.ccw(circle.center()) <= 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Point{ int x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Point c; int r; };\n\ninline double dist(const Point &p1, const Point &p2){\n\treturn sqrt( pow(p2.x-p1.x,2.0)+pow(p2.y-p1.y,2.0) );\n}\ndouble dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble b = 1;\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + b * p.y + c ) / sqrt( pow(a,2.0)+pow(b,2.0) );\n\t}\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) > 0;\n}\n\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( !isLeft( t.a, t.b, p ) )\n\t\treturn false;\n\tif( !isLeft( t.b, t.c, p ) )\n\t\treturn false;\n\tif( !isLeft( t.c, t.a, p ) )\n\t\treturn false;\n\n\treturn true;\n}\n\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r < dist( t.a, t.b, c.c ) &&\n\t\t\tc.r < dist( t.b, t.c, c.c ) &&\n\t\t\tc.r < dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) < c.r &&\n\t  dist( t.b, c.c ) < c.r &&\n\t  dist( t.c, c.c ) < c.r )\n\t  return true;\n  else\n\t  return false;\n}\nbool isCross(const Point &tp1, const Point &tp2, const Circle &c)\n{\n\tPoint p1 = tp1;\n\tPoint p2 = tp2;\n\tif( p2.x < p1.x )\n\t\tswap( p1, p2 );\n\n\tif( dist( p1, p2, c.c ) > c.r )\n\t\treturn false;\n\telse{\n\t\tif( p1.x != p2.x ){\n\t\t\tdouble x1, x2;\n\t\t\tdouble a = (p2.y - p1.y) / (p2.x - p1.x);\n\t\t\tdouble b = -a * p1.x + p1.y;\n\t\t\tdouble A = 1 + pow(a,2.0);\n\t\t\tdouble B = -( c.c.x - a * c.c.x + a * c.c.y );\n\t\t\tdouble C = pow( c.c.x, 2.0 ) + pow( b, 2.0 ) - 2*b*c.c.y + pow( c.c.y, 2.0 ) - pow( c.r,2.0 );\n\n\t\t\tx1 = ( -B + sqrt( pow(B,2.0) - A * C ) ) / A;\n\t\t\tx2 = ( -B - sqrt( pow(B,2.0) - A * C ) ) / A;\n\n\t\t\tif( p1.x <= x1 && x1 <= p2.x || p1.x <= x2 && x2 <= p2.x )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}else{\n\t\t\tif( p2.y < p1.y )\n\t\t\t\tswap( p1, p2 );\n\n\t\t\tdouble d = dist( p1, p2, c.c );\n\t\t\tdouble l = sqrt( pow(c.r,2.0) - pow(d,2.0) );\n\n\t\t\tdouble y1 = c.c.y - l;\n\t\t\tdouble y2 = c.c.y + l;\n\n\t\t\tif( p1.y <= y1 && y1 <= p2.y || p1.y <= y2 && y2 <= p2.y )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( !isCross(t.a,t.b,c) && !isCross(t.b,t.c,c) && !isCross(t.c,t.a,c) )\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t, c ) )\n\t\treturn 'b';\n\tif( !isCross( t,c ) )\n\t\treturn 'd';\n\telse\n\t\treturn 'c';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n// ½ÊãÌ_ExNg\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// OÏ\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\n// àÏ\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\n// ¼ü\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n// ½p`\ntypedef vector<P> G;\n\n// ~\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0)   return +1; // ½vñè\n\tif(cross(b, c) < 0)   return -1; // vñè\n\tif(dot(b, c) < 0)     return +2; // c--a--b\n\tif(norm(b) < norm(c)) return -2; // a--b--c\n\treturn 0;\n}\n\n// üªÆ_Ìð·»è\nbool intersectSP(const L& s, const P& p){\n\treturn abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;\n}\n\n// ¼üãÌ_ÌËe\nP projection(const L& l, const P& p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\n// üªÆ_Ì£\ndouble distanceSP(const L& s, const P& p){\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nchar detect(const G& tri, const C& c)\n{\n\tbool inner[3];\n\trep(i, 3){\n\t\tinner[i] = abs(tri[i] - c.p) - EPS <= c.r;\n\t}\n\tif(inner[0] && inner[1] && inner[2])\n\t\treturn 'b';\n\tif(inner[0] || inner[1] || inner[2])\n\t\treturn 'c';\n\t\n\trep(i, 3){\n\t\tL l(tri[i], tri[(i+1)%3]);\n\t\tif(distanceSP(l, c.p) - EPS <= c.r)\n\t\t\treturn 'c';\n\t}\n\t\n\tint v = 0;\n\trep(i, 3){\n\t\tint now = ccw(tri[i], tri[(i+1)%3], c.p);\n\t\tif(now * v < 0)\n\t\t\treturn 'd';\n\t\tv = now;\n\t}\n\t\n\treturn 'a';\n}\n\nint main()\n{\n\tfor(;;){\n\t\tG tri(3);\n\t\trep(i, 3){\n\t\t\tscanf(\"%lf%lf\", &tri[i].real(), &tri[i].imag());\n\t\t\tif(tri[i].real() == 0.0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(fabs(tri[0].real()) < EPS)\n\t\t\tbreak;\n\t\t\n\t\tP p;\n\t\tdouble r;\n\t\tscanf(\"%lf%lf%lf\", &p.real(), &p.imag(), &r);\n\t\tprintf(\"%c\\n\", detect(tri, C(p, r)));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std; \n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    double length2() const{\n        return y * y + x * x;\n    }\n    double dist2(const Point& p) const{\n        return (y - p.y) * (y - p.y) + (x - p.x) * (x - p.x);\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nint segmentCircleCollide(const Point& a1, const Point& a2, const Point& c, int r)\n{\n    int num = 0;\n    if(a1.dist2(c) < r * r)\n        ++ num;\n    if(a2.dist2(c) < r * r)\n        ++ num;\n    if(num == 2)\n        return -1;\n    if(num == 1)\n        return 1;\n    if((a2 - a1).dot(c - a1) > 0 && (a1 - a2).dot(c - a2) > 0){\n        int s = (a2 - a1).cross(c - a1);\n        int t = r * r * (a2 - a1).length2();\n        if(s * s == t)\n            return 1;\n        if(s * s < t)\n            return 2;\n    }\n    return 0;\n}\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        int a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < 0)\n            ret1 = false;\n        if(a > 0)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nint main()\n{\n    for(;;){\n        vector<Point> p(3);\n        for(int i=0; i<3; ++i){\n            cin >> p[i].x >> p[i].y;\n            if(p[i].x == 0)\n                return 0;\n        }\n\n        Point c;\n        int r;\n        cin >> c.x >> c.y >> r;\n\n        char ret = 'd';\n        int num = 0;\n        for(int i=0; i<3; ++i){\n            if(p[i].dist2(c) <= r * r)\n                ++ num;\n        }\n        if(num == 3)\n            ret = 'b';\n        else if(num > 0)\n            ret = 'c';\n\n        if(ret == 'd'){\n            if(convexContain(p, c))\n                ret = 'a';\n            for(int i=0; i<3; ++i){\n                int tmp = segmentCircleCollide(p[i], p[(i+1)%3], c, r);\n                if(ret == 'd' && tmp > 0)\n                    ret = 'c';\n                if(ret == 'a' && tmp == 2)\n                    ret = 'c';\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n/*  0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), all(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n//???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\trep(i, n) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tedge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvoid add_edge(graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(edge{ from, to, weight });\n}\n\ngraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\ngraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll2(s[i], s[j])[0]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\ngraph Circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main() {\n\t\n\twhile (1) {\n\t\tint x1, y1; cin >> x1 >> y1;\n\t\tif (!x1)break;\n\t\tint x2, y2, x3, y3, x4, y4, r; cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tPolygon tri;\n\t\ttri.push_back(Point(x1, y1));\n\t\ttri.push_back(Point(x2, y2));\n\t\ttri.push_back(Point(x3, y3));\n\t\tCircle c(Point(x4, y4), r);\n\t\tbool flag_b = true;\n\t\t{\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tif (!is_in_Circle(c, tri[i])) {\n\t\t\t\t\tflag_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag_a = false;\n\t\tbool  flag_c = false;\n\t\t{\n\t\t\tif (is_in_Polygon(tri, c.p)) {\n\t\t\t\tflag_a = true;\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tLine l(tri[i], tri[(i + 1) % 3]);\n\t\t\t\t\tif (dist_sp(l, c.p)<c.r) {\n\t\t\t\t\t\tflag_a = false;\n\t\t\t\t\t\tflag_c = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tif (is_in_Circle(c, tri[i])) {\n\t\t\t\t\tflag_c = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tLine l(tri[i], tri[(i + 1) % 3]);\n\t\t\t\tif (dist_sp(l, c.p)<c.r) {\n\t\t\t\t\tflag_c = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag_b) {\n\t\t\tcout << 'b' << endl;\n\t\t}\n\t\telse if (flag_a) {\n\t\t\tcout << 'a' << endl;\n\t\t}\n\t\telse if (flag_c) {\n\t\t\tcout << 'c' << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 'd' << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ninline D inprd(const P &a, const P &b){ return (conj(a) * b).X; }\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\ninline D sign(D d){ return (d<0)?-1:d>0?1:0; }\n\nbool is_intriangle(const P &p1, const P &p2, const P &p3, const P &q){\n    D s1 = sign(outprd(p2-p1,q-p1)), s2 = sign(outprd(p3-p2,q-p2)), s3 = sign(outprd(p1-p3,q-p3));\n    return (s1 == s2 && s2 == s3);\n}\ninline P circum_center(const P &a, const P &b, const P &c){\n    P bc = c - b, ca = a - c, ab = b - a;\n    return (a + b - (inprd(bc, ca) / outprd(ab, bc)) * ab * P(0,1)) / 2.0;\n}\nD distance_ls_p(const P &a, const P &b, const P &c){\n    if(inprd(b-a, c-a) < EPS) return abs(c-a);\n    if(inprd(a-b, c-b) < EPS) return abs(c-b);\n    return abs(outprd(b-a, c-a)) / abs(b-a);\n}\n\nstring solve(P p1, P p2, P p3, P pc, int r){\n    D dr = r;\n    if( distance_ls_p(p1,p2,pc) >= dr - EPS &&\n        distance_ls_p(p2,p3,pc) >= dr - EPS &&\n        distance_ls_p(p3,p1,pc) >= dr - EPS)\n    {\n        if(is_intriangle(p1,p2,p3,pc)) return \"a\";\n        else return \"d\";\n    }\n    if(norm(p1-pc) <= r*r && norm(p2-pc) <= r*r && norm(p3-pc) <= r*r) return \"b\";\n    return \"c\";\n}\n\nint main(){\n    P p1,p2,p3,pc;\n    int r;\n    int x, y;\n    while(cin >> x >> y && x && y){\n        p1 = P(x,y);\n        cin >> x >> y;\n        p2 = P(x,y);\n        cin >> x >> y;\n        p3 = P(x,y);\n        cin >> x >> y >> r;\n        pc = P(x,y);\n        cout << solve(p1,p2,p3,pc,r) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(!contains(c,g[0]))return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        bool f=true;\n\n        if(contains(c,g)){\n            puts(\"b\");\n            continue;\n        }\n\n        f=true;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(distanceCS(c,s)<-EPS)f=false;\n        }\n        if(f&&contains(g,c.p)){\n            puts(\"a\");\n            continue;\n        }\n\n        f=false;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(intersectCS(c,s)){\n                f=true;\n            }\n        }\n\n        if(f){\n            puts(\"c\");\n        }\n        else puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{ point a,b; };\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && vec_abs(seg[i].b-seg[j].a)<=EPS){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    double ans=0;\n    for(int i=0;i<3;i++){\n\tint tmp=dist(p[i],C.p);\n\tif(tmp>ans)ans=tmp;\n    }\n    if(C.r>=ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n    \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=100000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n// ½ÊãÌ_ExNg\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// OÏ\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\n// àÏ\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\n// ¼ü\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n// ½p`\ntypedef vector<P> G;\n\n// ~\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0)   return +1; // ½vñè\n\tif(cross(b, c) < 0)   return -1; // vñè\n\tif(dot(b, c) < 0)     return +2; // c--a--b\n\tif(norm(b) < norm(c)) return -2; // a--b--c\n\treturn 0;\n}\n\n// üªÆ_Ìð·»è\nbool intersectSP(const L& s, const P& p){\n\treturn abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;\n}\n\n// ¼üãÌ_ÌËe\nP projection(const L& l, const P& p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\n// üªÆ_Ì£\ndouble distanceSP(const L& s, const P& p){\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nchar detect(const G& tri, const C& c)\n{\n\tbool inner[3];\n\trep(i, 3){\n\t\tinner[i] = abs(tri[i] - c.p) - EPS <= c.r;\n\t}\n\tif(inner[0] && inner[1] && inner[2])\n\t\treturn 'b';\n\tif(inner[0] || inner[1] || inner[2])\n\t\treturn 'c';\n\t\n\trep(i, 3){\n\t\tL l(tri[i], tri[(i+1)%3]);\n\t\tif(distanceSP(l, c.p) + EPS < c.r)\n\t\t\treturn 'c';\n\t}\n\t\n\tint v = 0;\n\trep(i, 3){\n\t\tint now = ccw(tri[i], tri[(i+1)%3], c.p);\n\t\tif(now * v < 0)\n\t\t\treturn 'd';\n\t\tv = now;\n\t}\n\t\n\treturn 'a';\n}\n\nint main()\n{\n\tfor(;;){\n\t\tG tri(3);\n\t\trep(i, 3){\n\t\t\tscanf(\"%lf%lf\", &tri[i].real(), &tri[i].imag());\n\t\t\tif(tri[i].real() == 0.0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(fabs(tri[0].real()) < EPS)\n\t\t\tbreak;\n\t\t\n\t\tP p;\n\t\tdouble r;\n\t\tscanf(\"%lf%lf%lf\", &p.real(), &p.imag(), &r);\n\t\tprintf(\"%c\\n\", detect(tri, C(p, r)));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n\ndouble dot(P a,P b){\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a,P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble distance_ls_p(P a,P b,P c){\n\tif(dot(b-a,c-a) < EPS) return abs(c-a);\n\tif(dot(a-b,c-b) < EPS) return abs(c-b);\n\treturn abs(cross(b-a,c-a)) / abs(b-a);\n}\n\nbool pol_contains_cir(vector<P> p,P o,double r){\n\tint n = p.size();\n\tint cr = 0, cl = 0;\n\tfor(int i=0;i<n;i++){\n\t\tP a = p[i];\n\t\tP b = p[(i+1)%n];\n\t\tif(EPS > cross(b-a,o-a)) cr++;\n\t\tif(0 < cross(b-a,o-a) + EPS) cl++;\n\t\tif(distance_ls_p(a,b,o) < r) return false;\n\t}\n\tif(cr != n && cl != n) return false;\n\n\treturn true;\n}\n\nbool cir_contains_pol(vector<P> p,P o,double r){\n\tfor(int i=0;i<p.size();i++){\n\t\tif(r < abs(p[i]-o)) return false;\n\t}\n\treturn true;\n}\n\nbool is_intersected_ls_cir(P a,P b,P o,double r){\n\tdouble ao = abs(a-o);\n\tdouble bo = abs(b-o);\n\n\treturn ((ao < r + EPS && r < bo + EPS || r < ao + EPS && bo < r + EPS) ||\n\t\t\t\t\t(r < ao + EPS && r < bo + EPS && distance_ls_p(a,b,o) < r + EPS));\n}\n\nbool is_intersected_pol_cir(vector<P> p,P o,double r){\n\tint n = p.size();\n\n\tfor(int i=0;i<n;i++){\n\t\tif(is_intersected_ls_cir(p[i],p[(i+1)%n],o,r)) return true;\n\t}\n\n\treturn false;\n}\n\nint main(void){\n\t/*\n\tP a = P(0,0);\n\tP b = P(0,2);\n\tP c = P(-0.1,1);\n\n\tcout << cross(b-a,c-a) << endl;\n\t*/\n\n\twhile(1){\n\t\tvector<P> p;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tP tmp;\n\t\t\tcin>>tmp.real()>>tmp.imag();\n\t\t\tif(tmp.real()==0 && tmp.imag()==0) return 0;\n\t\t\tp.push_back(tmp);\n\t\t}\n\n\t\tP o;\n\t\tdouble r;\n\n\t\tcin>>o.real()>>o.imag()>>r;\n\n\t\tif(pol_contains_cir(p,o,r))\n\t\t\tcout<<\"a\\n\";\n\t\telse if(cir_contains_pol(p,o,r)){\n\t\t\tcout<<\"b\\n\";\n\t\t}\n\t\telse if(is_intersected_pol_cir(p,o,r)){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"d\\n\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-8\ntypedef long long int lli;\ntypedef complex<lli> C;\n\nC v[4];\nlli r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  lli ina;\n  lli ir2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    ina = norm(a);\n    if (ina < ir2) {\n      c[i] = -1;\n    } else if (ina > ir2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0 && c[1]>=0 && c[2]>=0) {\n    return 1;\n  } else if (c[0]<=0 && c[1]<=0 && c[2]<=0) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double sd, s, t;\n  long long int ina, inb, idab, id;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    ina = norm(a);\n    inb = norm(b);\n    idab = dot(a,b);\n    id = idab*idab - ina*(inb-r*r);\n    if (id < 0) {\n      continue;\n    }\n    sd = sqrt((double)id);\n    s = (idab+sd)/ina;\n    t = (idab-sd)/ina;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (!id) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntypedef complex<double> P;\n\nint x, y, r;\nP tri[3];\npair<P,double> circle;\n\ndouble cross(P& e1, P& e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 >= 0 && d1 * d2 >= 0 && d2 * d0 >= 0) return true;\n\treturn false;\n}\n\ndouble dist(P p1, P p2, P p) {\n\tdouble a = p2.imag() - p1.imag();\n\tdouble b = -(p2.real() - p1.real());\n\tdouble c = - a * p1.real() - b * p1.imag();\n\tdouble nm = a * p.real() + b * p.imag() + c;\n\tdouble de = a * a + b * b;\n\treturn abs(nm) / sqrt(de);\n}\n\ndouble norm(P p) {\n\treturn sqrt(p.real() * p.real() + p.imag() * p.imag());\n}\n\nvoid solve() {\n\tbool iscin = inc();\n\tdouble R = circle.second;\n\tvector<double> d(6, 0.0);\n\td[0] = dist(tri[0], tri[1], circle.first);\n\td[1] = dist(tri[1], tri[2], circle.first);\n\td[2] = dist(tri[2], tri[0], circle.first);\n\t// printf(\"%f %f %f\\n\", d[0], d[1], d[2]);\n\tif(iscin && d[0] >= R && d[1] >= R && d[2] >= R) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\tP p0 = tri[0] - circle.first;\n\tP p1 = tri[1] - circle.first;\n\tP p2 = tri[2] - circle.first;\n\td[3] = norm(p0);\n\td[4] = norm(p1);\n\td[5] = norm(p2);\n\t// printf(\"%f %f %f\\n\", d[3], d[4], d[5]);\n\tif(d[3] <= R && d[4] <= R && d[5] <= R) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(d[0] < R) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3, p; long double r; Segment l1, l2, l3;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> p.px >> p.py >> r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, p) < r && dst(p2, p) < r && dst(p3, p) < r) printf(\"b\\n\");\n\t\telse if(dst(l1, p) >= r && dst(l2, p) >= r && dst(l3, p) >= r) printf(contain({p1, p2, p3}, p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n \nusing namespace std;\n \n#define F first\n#define S second\n \n#define X real()\n#define Y imag()\n \n#define EPS (1e-7)\n \ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\ntypedef pair<double, Point> Circle;\n \nbool isPointInCircle(const Point& p, const Circle& c) {\n  if(abs(p-c.S) < abs(c.F) + EPS) return true;\n  return false;\n}\n \ndouble dot(const Point& a, const Point& b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n \ndouble cross(const Point& a, const Point& b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n \ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n \ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n \ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n   \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n \n \nenum struct ECont { OUT, ON, IN };\nECont contains(const Polygon& poly, const Point& p) {\n  bool in = 0;\n  for(int i=0; i<poly.size(); i++) {\n    Point a = poly[i] - p, b = poly[(i+1)%poly.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag()) {\n      if(cross(a, b) < 0) in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ECont::ON;\n  }\n   \n  return in ? ECont::IN : ECont::OUT;\n}\n \nint main() {\n   \n  while(1) {\n    Polygon points(3);\n    Circle circle;\n   \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n     \n      points[i] = Point(x, y);\n    }\n   \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n   \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n     \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3 && contains(points, circle.S) == ECont::IN) {cout << 'a' << endl; continue;}\n \n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) <= circle.F + EPS;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-1;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) <= c.r + kyuriEPS ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n\tif( ctt >= 1 ) return 2;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r + kyuriEPS ){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs( (t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x) );\n\t}\n\t//std::cout << area << \" \" << tS2 << std::endl;\n\t\n\tif( fabs( fabs(area) - tS2 ) == 0 ) return 0; \t\n\t\n\treturn 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntypedef complex<int> P;\n\nint x, y, r;\nP tri[3];\npair<P,int> circle;\n\nint cross(P e1, P e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tint d0 = cross(e0, e1);\n\tint d1 = cross(e1, e2);\n\tint d2 = cross(e2, e0);\n\tif(d0 * d1 > 0 && d1 * d2 > 0 && d2 * d0 > 0) return true;\n\treturn false;\n}\n\nint norm2(P p) {\n\treturn p.real() * p.real() + p.imag() * p.imag();\n}\n\nvoid dist2(P p1, P p2, P p, int& nm, int& de) {\n\tint a = p2.imag() - p1.imag();\n\tint b = -(p2.real() - p1.real());\n\tint c = - a * p1.real() - b * p1.imag();\n\tnm = a * p.real() + b * p.imag() + c;\n\tnm = nm * nm;\n\tde = a * a + b * b;\n\tif(de == 0) {\n\t\tnm = norm2(p1 - p);\n\t\tde = 1;\n\t}\n}\n\n\nvoid solve() {\n\tbool iscin = inc();\n\tint r2 = circle.second * circle.second;\n\tvector<pii> d(6);\n\tdist2(tri[0], tri[1], circle.first, d[0].first, d[0].second);\n\tdist2(tri[1], tri[2], circle.first, d[1].first, d[1].second);\n\tdist2(tri[2], tri[0], circle.first, d[2].first, d[2].second);\n\tif(iscin && (d[0].first > r2 * d[0].second) &&\n\t\t        (d[1].first > r2 * d[1].second) &&\n\t\t        (d[2].first > r2 * d[2].second)) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\td[3].first = norm2(tri[0] - circle.first); d[3].second = 1;\n\td[4].first = norm2(tri[1] - circle.first); d[4].second = 1;\n\td[5].first = norm2(tri[2] - circle.first); d[5].second = 1;\n\tif(d[3].first < r2 && d[4].first < r2 && d[5].first < r2) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tbool inter = false;\n\trep(i,6) {\n\t\tif(d[i].first <= r2 * d[i].second) {\n\t\t\tinter = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(inter) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])==OUT)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        bool f=true;\n\n        if(contains(c,g)){\n            puts(\"b\");\n            continue;\n        }\n\n        f=true;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(distanceCS(c,s)<-EPS)f=false;\n        }\n        if(f&&contains(g,c.p)){\n            puts(\"a\");\n            continue;\n        }\n\n        f=false;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(intersectCS(c,s)){\n                f=true;\n            }\n        }\n\n        if(f){\n            puts(\"c\");\n        }\n        else puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct P{\n    P(){}\n    P(ll _r, ll _i):r(_r), i(_i){}\n    void real(const ll& v){r = v;}\n    void imag(const ll& v){i = v;}\n    ll r, i;\n};\n\nll real(const P& p){return p.r;}\nll imag(const P& p){return p.i;}\nll norm(const P& p){ll r = real(p), i = imag(p); return r * r + i * i;}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\nll cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\nll dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\nll distance(const P& a, const P& b, const P& p){\n    ll c = cross(p-a, b-a);\n    return c * c;\n}\n\nP ps[3], cc;\nll radius;\n\nbool doesLineAcrossCircle(const P& a, const P& b){\n    if(cross(a-cc, b-cc) == 0){\n        return dot(a-cc, b-cc) < 0 && norm(a) >= radius * radius && norm(b) >= radius * radius;\n    }\n    if(distance(a, b, cc) > radius * radius * norm(b-a)){return false;}\n    if(dot(cc-a, b-a) * dot(cc-b, b-a) <= 0){return true;}\n    //printf(\"%s\\n\", (norm(cc-a) <= radius * radius) || (norm(cc-b) <= radius * radius) ? \"safe\" : \"death2\");\n    return norm(cc-a) <= radius * radius || norm(cc-b) <= radius * radius;\n}\n\nbool isCircleInTriangle(){\n    REP(i, 3){\n        if(distance(ps[i], ps[(i+1)%3], cc) < radius * radius * norm(ps[i]-ps[(i+1)%3])){return false;}\n    }\n\n    int count_n = 0, count_p = 0;\n    REP(i, 3){\n        ll c = cross(cc-ps[i], ps[(i+1)%3]-ps[i]);\n        if(c < 0){\n            count_n += 1;\n        }else if(c == 0){\n            count_n += 1; count_p += 1;\n        }else{\n            count_p += 1;\n        }\n    }\n\n    if(count_n % 3 == 0 || count_p % 3 == 0){return true;}\n    return false;\n}\n\nbool isTriangleInCircle(){\n    REP(i, 3){\n        if(norm(ps[i]-cc) > radius * radius){return false;}\n    }\n    return true;\n}\n\nbool isIntersected(){\n    REP(i, 3){\n        if(doesLineAcrossCircle(ps[i], ps[(i+1)%3])){return true;}\n    }\n    return false;\n}\n\nint main(){\n    ll re, im;\n    while(std::cin >> re >> im, re || im){\n        ps[0].real(re); ps[0].imag(im);\n        \n        FOR(i, 1, 3){\n            ll re, im;\n            std::cin >> re >> im;\n        \n            ps[i].real(re); ps[i].imag(im);\n        }\n        \n        {\n            ll re, im;\n            std::cin >> re >> im;\n            \n            cc.real(re); cc.imag(im);\n        }\n        \n        std::cin >> radius;\n        \n        if(isCircleInTriangle()){puts(\"a\");}\n        else if(isTriangleInCircle()){puts(\"b\");}\n        else if(isIntersected()){puts(\"c\");}\n        else{puts(\"d\");}\n    }   \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst ld eps = 1e-9;\n\nstruct Point { // ポイントクラス兼ベクトルクラス\n    ld x, y;\n    Point() {}\n    Point(ld x, ld y) : x(x), y(y) {}\n    Point operator+(const Point &o) const {\n        return Point(x + o.x, y + o.y);\n    }\n    Point operator-(const Point &o) const {\n        return Point(x - o.x, y - o.y);\n    }\n    Point operator*(ld a) const {\n        return Point(a*x, a*y);\n    }\n    Point operator/(ld a) const {\n        return Point(x/a, y/a);\n    }\n    ld norm() const {\n        return sqrt(x*x + y*y);\n    }\n    Point unit() const { // 単位ベクトル\n        return (*this)/norm();\n    }\n};\nld dot(const Point &a, const Point &b) {\n    return a.x * b.x + a.y * b.y;\n}\nld cross(const Point &a, const Point &b) {\n   return a.x * b.y - a.y * b.x;\n}\n#define CCW 1\n#define CW -1\n#define CAB 2\n#define ABC -2\n#define ACB 0\nint ccw(Point a, Point b, Point c) {\n    // aを基準とする位置ベクトルを考える\n\tb = b - a; c = c - a;\n\tif (cross(b, c) > eps) return CCW; // 反時計周り\n\tif (cross(b, c) < -eps) return CW;// 時計周り\n\tif (dot(b, c) < 0) return CAB;     // c--a--bがこの順番に一直線上\n\tif (b.norm() < c.norm()) return ABC; // a--b--cがこの順番に一直線上\n\treturn ACB;                         // a--c--bが一直線上\n}\ntypedef Point Vector;\n\nstruct Segment {\n    Point from, to;\n    Segment() {}\n    Segment(Point from, Point to) : from(from), to(to) {}\n    bool intersects(const Segment &o) const {\n        return (ccw(from, to, o.from) != ccw(from, to, o.to)) &&\n                    (ccw(o.from, o.to, from) != ccw(o.from, o.to, to));\n    }\n    ld length() const {\n        return (to-from).norm();\n    }\n    bool contains(const Point &p) const {\n        return ccw(from, to, p) == ACB;\n    }\n};\n\nstruct Line : public Segment {\n    Line() {}\n    Line(Segment s) : Segment(s) {}\n    Line(Point from, Point to) : Segment(from, to) {}\n    ld distance(const Point &p) const {\n        Vector v1 = p - from;\n        Vector v2 = to - from;\n        ld S = abs(cross(v1, v2));   // v1,v2が張る平行四辺形の面積\n        return S / length();         // それを線分の長さで割る\n    }\n    Point projection(const Point &p) const {\n        Vector v1 = p - from, v2 = to - from;\n        ld l = dot(v1, v2) / v2.norm();\n        return from + (v2.unit()) * l;\n    }\n};\n\nstruct Circle {\n    Point o;\n    ld r;\n    Circle() {}\n    Circle(Point o, ld r) : o(o), r(r) {}\n    Circle(ld x, ld y, ld r) : o(Point(x, y)), r(r) {}\n    bool intersects(const Segment& s) const { \n        if (contains(s.from) && contains(s.to)) return false;\n        Line l(s);\n        if (l.distance(o) >= r - eps) return false;\n        if (contains(s.from) != contains(s.to)) return true;\n        return s.contains(l.projection(o));\n    }\n    bool contains(const Point& p) const {\n        ld dx = o.x - p.x;\n        ld dy = o.y - p.y;\n        return r*r + eps >= dx*dx + dy*dy;\n    }\n};\n\nPoint p[3];\nCircle C;\n\nbool b() {\n    for (int i = 0; i < 3; i++) \n        if (!C.contains(p[i]))\n            return false;\n    return true;\n}\n\nbool c() {\n    for (int i = 0; i < 3; i++) {\n        Segment s(p[i%3], p[(i+1)%3]);\n        if (C.intersects(s)) \n            return true;\n    }\n    return false;\n}\n\nbool a() {\n    Point g = (p[0] + p[1] + p[2]) / 3.0;\n    Segment s(C.o, g);\n    for (int i = 0; i < 3; i++) {\n        Segment edge(p[i%3], p[(i+1)%3]);\n        if (s.intersects(edge)) return false;\n    }\n    return true;\n}\n\nint main() {\n    while (cin >> p[0].x >> p[0].y, p[0].x || p[0].y) {\n        cin >> p[1].x >> p[1].y;\n        cin >> p[2].x >> p[2].y;\n        cin >> C.o.x >> C.o.y;\n        cin >> C.r;\n        if (b()) {\n            cout << \"b\" << endl;\n        } else if (c()) {\n            cout << \"c\" << endl;\n        } else if (a()) {\n            cout << \"a\" << endl;\n        } else {\n            cout << \"d\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nstruct C {\n  P p;\n  double r;\n  C() : p(P(0,0)), r(0) {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2-s1,p-s1))/abs(s2-s1);\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2-s1, p-s1) < 0.0) return abs(p-s1);\n  if(dot(s1-s2, p-s2) < 0.0) return abs(p-s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nbool involve(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    double dist = getDistanceLP(a,b,c.p);\n    if(cross(b-a, c.p-a) > eps && dist - c.r > -eps) {\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool involve(const C &c, const vector<P> &g) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    double dist = max(abs(c.p - a), abs(c.p - b));\n    if(c.r - dist > -eps) {\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool isIntersect(const P &s1, const P &s2, const C &c) {\n  double dist = getDistanceSP(s1, s2, c.p);\n  return c.r - dist > eps;\n}\n\nbool isIntersect(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(isIntersect(a,b,c)) return true;\n  }\n  return false;\n}\n\nint main() {\n  vector<P> g(3);\n  C c;\n  while(1) {\n    for(int i = 0; i < g.size(); ++i) {\n      cin >> g[i].real() >> g[i].imag();\n      if(g[0].real() == 0 && g[0].imag() == 0) return 0;\n    }\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n    if(involve(g,c)) cout << \"a\" << endl;\n    else if(involve(c,g)) cout << \"b\" << endl;\n    else if(isIntersect(g,c)) cout << \"c\" << endl;\n    else cout << \"d\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r)\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r)\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r)\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r)\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r)\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r)\n\t\t\t&& isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\telse if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef long double Double;\ntypedef complex<Double> P;\n#define Y imag()\n#define X real()\nconst Double EPS = (long double) 1 * 1e-12;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nDouble get(P b[3]){\n\tP a[3];\n\tfor(int i = 0 ; i < 3 ; i++) a[i] = b[i];\n\ta[0] -= a[2];\n\ta[1] -= a[2];\n\treturn 0.5 * abs( a[0].X * a[1].Y - a[1].X * a[0].Y );\n}\n\n\nDouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \nDouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {Double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\n\nDouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;Double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tDouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\t//cout << S << endl;\n\t\tbool in = S == 0;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) < r || getPedal(L(a[1],a[2]),c) < r || getPedal(L(a[0],a[2]),c) < r;\n\t\tbool hit2 = getPedal(L(a[0],a[1]),c) <= r || getPedal(L(a[1],a[2]),c) <= r || getPedal(L(a[0],a[2]),c) <= r;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) <= r*r && nijo(a[1]-c) <= r*r && nijo(a[2]-c) <= r*r) cout << \"b\" << endl;\n\t\telse if(in){\n\t\t\tif(hit2) cout << \"c\" << endl;\n\t\t\telse cout << \"a\" << endl;\n\t\t}else{\n\t\t\tif(hit) cout << \"c\" << endl;\n\t\t\telse cout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\ntypedef struct circle{\n\tpoint p;\n\tdouble r;\n} circle;\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\ncircle make(point p,double r){ circle c;\n\tc.p = p ;\n\tc.r = r;\n\treturn c;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// circle_versino\nint ccw(circle c0,circle c1){\n\tdouble  d = abs(c0.p-c1.p);\n\tdouble r0 = c0.r,r1 = c1.r;\n\t\n\t//c0in c1\n\tif(d<r1-r0)return -2;\n\t//c1 in c0\n\tif(d<r0-r1)return 2;\n\t//c0 cross c1\n\tif(abs(r0-r1)<=d&&d<=r0+r1)return 1;\n\t//c0 not cross c1\n\treturn 0;\n\n}\n\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nint main(){\n\twhile(1){\n\tvector<point> tri(3);\n\ttri[0] = make();\n\tif(tri[0].x==0&&tri[0].y==0)break;\n\ttri[1] = make();\n\ttri[2] = make();\n\tvector<line> l(3);\n\tl[0] = make(tri[0],tri[1]);\n\tl[1] = make(tri[1],tri[2]);\n\tl[2] = make(tri[2],tri[0]);\n\n\tpoint p = make();\n\tdouble r ; cin>>r;\n\tcircle c = make(p,r);\n\t// circle in triangle\n\tif(r<distance(l[0],p)&&r<distance(l[1],p)&&\n\t\t\tr<distance(l[2],p)&&contains(tri,p) ){\n\tcout<<'a'<<endl;\n\tcontinue;\n\t}\n\t// triangle in circle \n\tif(r>distance(tri[0],p)&&r>distance(tri[1],p)&&r>distance(tri[2],p)){\n\tcout<<'b'<<endl;\n\tcontinue;\n\t}\n\t//cross\n\t\n\tif(r>distance(tri[0],p)||r>distance(tri[1],p)||r>distance(tri[2],p)){\n\tcout<<'c'<<endl;\n\tcontinue;\n\t}\n\tcout<<'d'<<endl;\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P p, const P q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P p, const P q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& p_, double r_) : p(p_), r(r_) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0.0 && d1 * d2 > 0.0 && d2 * d0 > 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(3);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL r0(tr[1], tr[0]);\n\tL l1(tr[1], tr[2]);\n\tL r1(tr[2], tr[1]);\n\tL l2(tr[2], tr[0]);\n\tL r2(tr[0], tr[2]);\n\td[0] = max(distP2LS(cc.p, l0), distP2LS(cc.p, r0));\n\td[1] = max(distP2LS(cc.p, l1), distP2LS(cc.p, r1));\n\td[2] = max(distP2LS(cc.p, l2), distP2LS(cc.p, r2));\n\tif(in && d[0] >= cc.r && d[1] >= cc.r && d[2] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect ?\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n#define Y imag()\n#define X real()\nconst double EPS = 1e-8;\n \nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n \ndouble get(P a[3]){\n    double A = abs(a[0]-a[1]);\n    double B = abs(a[1]-a[2]);\n    double C = abs(a[2]-a[0]);\n    double s = (A+B+C) / 2.0;\n    double S = sqrt( s * (s-A) * (s-B) * (s-C) );\n    return S;\n}\ndouble nijo(P a){\n    return a.X * a.X + a.Y * a.Y;\n}\n  \ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n \ndouble getPedal(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n \nint main(){\n    P a[3],c;double r;\n    while(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n        for(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n        cin >> c.X >> c.Y >> r;\n        double S = get(a);\n        for(int i = 0 ; i < 3 ; i++){\n            P b[3];\n            b[0] = a[i];\n            b[1] = a[(i+1)%3];\n            b[2] = c;\n            S -= fabs(get(b));\n        }\n        bool in = fabs(S) < EPS;\n        bool hit = getPedal(L(a[0],a[1]),c) < r - EPS || getPedal(L(a[1],a[2]),c) < r - EPS || getPedal(L(a[0],a[2]),c) < r - EPS;\n        //cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n        if(  nijo(a[0]-c) < r*r && nijo(a[1]-c) < r*r && nijo(a[2]-c) < r*r) cout << \"b\" << endl;\n        else if(in && !hit) cout << \"a\" << endl;\n        else if(hit) cout << \"c\" << endl;\n        else cout << \"d\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define SAME_SIGN( a , b ) a * b > 0\n\nnamespace geometry{\n\n\t#define EPS 1E-10\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.b , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.c , cir.center ) <= cir.radius\n\t\t){\n\t\t\tstd::cout << 'b' << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << 'a' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << 'd' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << 'c' << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << 'c' << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{ point a,b; };\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point t,point* p,int N){\n  int i,count=0,j=0;\n  segment lt,lp;\n\n  p[N]=p[0];\n  p[N+1]=p[1];\n\n  lt.a=lt.b=t;\n  lt.b.x=INT_MAX;\n\n  for(i=1;i<=N;i++){\n    lp.a=lp.b=p[i];\n\n    if(!is_intersected_ls(lp.a,lp.b,lt.a,lt.b)){\n      if(i==j+1){\n\tlp.b=p[j];\n\tif(is_intersected_ls(lp.a,lp.b,lt.a,lt.b))count++;\n      }\n      else if(ccw(lt.a,lt.b,p[i])*ccw(lt.a,lt.b,p[j])<0)count++;\n      j=i;\n    }\n  }\n  return count & 1;\n}\n\nint crossCP(point* ps, circle C, int sz){\n\n  double ans=0;\n\n  for(int i=0;i<sz;i++){\n    double tmp=dist(ps[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,ps,sz);\n\n  double res2=100000000;\n  ps[3]=ps[0];\n  for(int i=0;i<sz;i++)\n    res2=min(res2,distance_ls_p(ps[i],ps[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p[6];\n  vector<segment> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(p,C,3);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\n\nconst double EPS = 1e-9;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\nbool EPS_less(double lhs, double rhs) {return lhs < rhs - EPS;}\nbool EPS_equal(double lhs, double rhs) {return lhs <= rhs + EPS;}\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return EPS_less(center.distance(p), r);}\n    bool include(const Segment& s) const {return EPS_less(center.distance(s), r) || EPS_equal(center.distance(s), r);}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n//     if(s.ccw(p) == ON) return distance(p);\n    if(EPS_less(s.start.distance(p) + s.end.distance(p), s.start.distance(s.end))) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x - y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + Point(t, t) * v2;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n    for(auto& e: edge) if(circle.include(e)) return \"c\";\n\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center) > 0) ++ccw;\n        if(e.ccw(circle.center) < 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n            ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\n  point a,b;\n  a=b=p;\n  b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n  \n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n    \n  return (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\n  double ans=0;\n  int tsz=t.size();\n\n  for(int i=0;i<tsz;i++){\n    double tmp=dist(t[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,t,tsz);\n  double res2=DBL_MAX;\n\n  t.push_back(t[0]);\n\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p;\n  vector<point> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    t.clear();\n    for(int i=0;i<3;i++){\n      cin >> p.x >> p.y;\n      if(p.x==0 && p.y==0)return 0;\n      t.push_back(p);\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(t,C);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-7\n \nclass Point {\n  public:\n    double x,y;\n    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n    Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n    Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n    Point operator * (double a) { return Point(x*a, y*a); }\n    Point operator / (double a) { return Point(x/a, y/a); }\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n};\n \ndouble dot(Point a, Point b)\n{\n    return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a, Point b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n \nclass Segment {\n  public:\n    Point t, s;\n    Segment(Point t, Point s) : t(t), s(s) {}\n};\n \nclass Circle {\n  public:\n    double x, y, r;\n    Circle(double x = 0.0, double y = 0.0, double r = 0.0) : x(x), y(y), r(r) {}\n};\n \nPoint point[3];\nCircle ci;\n \nint ccw(Point p0, Point p1, Point p2)\n{\n    Point a = p1 - p0;\n    Point b = p2 - p0;\n    if (cross(a, b) > EPS) return 1;\n    if (cross(a, b) < -EPS) return -1;\n    if (dot(a, b) < -EPS) return 2;\n    if (a.norm() < b.norm()) return -2;\n    return 0;\n}\n \nbool check()\n{\n    Point cp = Point(ci.x, ci.y);\n    int c1 = ccw(point[0], point[1], cp);\n    int c2 = ccw(point[1], point[2], cp);\n    int c3 = ccw(point[2], point[0], cp);\n    return (c1 == c2 && c2 == c3);\n}\n \ntypedef Segment Line;\n\ndouble getDistanceLP(Line l, Point p)\n{\n    return abs(cross(l.s-l.t, p-l.t) / (l.s-l.t).abs());\n}\n \ndouble getDistanceSP(Segment seg, Point p)\n{\n    if (dot(seg.s-seg.t, p-seg.t) < 0.0) return (p-seg.t).abs();\n    if (dot(seg.t-seg.s, p-seg.s) < 0.0) return (p-seg.s).abs(); \n    return getDistanceLP(seg, p);\n}\n \nint getStateCS(Circle c, Segment seg)\n{\n    Point cp = Point(c.x, c.y);\n    if (getDistanceSP(seg, cp) >= c.r) {\n\treturn 1;\n    }\n    return 3;\n}\n \nbool isCross()\n{\n    Point cp = Point(ci.x, ci.y);\n \n    Segment seg[3] = {\n\tSegment(point[0], point[1]),\n\tSegment(point[1], point[2]),\n\tSegment(point[2], point[0])\n    };\n    int cnt = 0;\n    for (int i = 0; i < 3; i++) {\n\tif (getDistanceSP(seg[i], cp) > ci.r) {\n\t    cnt++;\n\t}\n    }\n \n    if (cnt == 3 && !check()) return false;\n    return true;\n}\n \nvoid judge()\n{\n    Segment seg[3] = {\n\tSegment(point[0], point[1]),\n\tSegment(point[1], point[2]),\n\tSegment(point[2], point[0])\n    };\n    Point cp = Point(ci.x, ci.y);\n    int TinC = 0;\n    for (int i = 0; i < 3; i++, TinC++) {\n\tif ((point[i]-cp).abs() > ci.r) {\n\t    break;\n\t}\n    }\n \n    if (TinC == 3) { \n\tcout << 'b' << endl;\n\treturn;\n    }\n \n    int CinT = 0;\n    for (int i = 0; i < 3; i++) {\n\tif (getStateCS(ci, seg[i]) == 1) {\n\t    CinT++;\n\t}\n    }\n    if (CinT == 3 && check()) {\n\tcout << 'a' << endl;\n    } else {\n\tif (isCross()) {\n\t    cout << 'c' << endl;\n\t} else {\n\t    cout << 'd' << endl;\n\t}\n    }\n}\n \nint main()\n{\n    while (1) {\n\tcin >> point[0].x >> point[0].y;\n\tif (!point[0].x && !point[0].y) break;\n\tfor (int i = 0; i < 2; i++) {\n\t    cin >> point[i+1].x >> point[i+1].y;\n\t}\n\tcin >> ci.x >> ci.y >> ci.r;\n\tjudge();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])!=IN)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(intersectCS(c,Segment(g[i],next(g,i))))return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        if(contains(g,c))puts(\"a\");\n        else if(contains(c,g))puts(\"b\");\n        else{\n            bool x=false;\n            for(int i=0;i<g.size();i++){\n                if(contains(c,g[i]))x=true;\n            }\n            puts(x?\"c\":\"d\");\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return fabs(source().distance(p) + target().distance(p) - target().distance(source())) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + (v1.dot(v2) / v2.norm()) * v2);\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.center().distance(e) - circle.r() > EPS) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) >= 0) ++ccw;\n        if(e.ccw(circle.center()) <= 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + P(2,0) * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n#define curr(P, i) Pt[i]\n#define next(P, i) Pt[(i+1)%Pt.size()]\nenum { OUT, ON, IN };\nint contains(const G& Pt, const P& p) {\n  bool in = false;\n  for (int i = 0; i < Pt.size(); ++i) {\n    P a = curr(P,i) - p, b = next(P,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nint main(){\n\tdouble x1,y1,x2,y2,x3,y3,cx,cy,r;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3>>cx>>cy>>r,x1||y1){\n\t\tP pA(x1,y1),pB(x2,y2),pC(x3,y3),pO(cx,cy);\n\t\tL c(pA,pB),a(pB,pC),b(pC,pA);\n\t\tC Circle(pO,r);\n\t\tG ABC; ABC.push_back(pA),ABC.push_back(pB),ABC.push_back(pC);\n\t\t\n\t\tif(r*r+EPS>max(max(norm(pA-pO),norm(pB-pO)),norm(pC-pO))){\n\t\t\tcout<<\"b\"; goto NEXT;\n\t\t}\n\t\t\n\t\tif(!ccw(pA,pB,pC))swap(ABC[0],ABC[2]);\n\t\tbool ct=contains(ABC,pO);\n\t\tif(ct&&min(min(distanceSP(a,pO),distanceSP(b,pO)),distanceSP(c,pO))>r-EPS){\n\t\t\tcout<<\"a\"; goto NEXT;\n\t\t}\n\t\t\n\t\tif(distanceSP(a,pO)<r+EPS||distanceSP(b,pO)<r+EPS||distanceSP(c,pO)<r+EPS){\n\t\t\tcout<<\"c\"; goto NEXT;\n\t\t}\n\t\t\n\t\tcout<<\"d\";\n\t\t\n\t\tNEXT:\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=max(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>EPS)return 1; //intersect\n            if(in_triangle(p,t))return 2;//c in t\n            else return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n}\n\n\nusing namespace geo;\n\nint main(){\n    int x,y,r;\n    while(cin>>x>>y,x!=0||y!=0){\n        Poly t={P(x,y)};\n        REP(i,2){\n            cin>>x>>y;\n            t.pb(P(x,y));\n        }\n        cin>>x>>y>>r;\n        C c(P(x,y),r);\n        int res=is_triangle_C(t,c);\n        if(res==2)cout<<\"a\"<<endl;\n        if(res==3)cout<<\"b\"<<endl;\n        if(res==1)cout<<\"c\"<<endl;\n        if(res==0)cout<<\"d\"<<endl;\n\n    }\n   \n    \n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n    if(rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS * len) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\n//多角形の面積\ntemplate<class T>\nT area(const vector<point<T> >& v){\n\tT ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S,const point<T> &p){ return sqrt(dist2(S,p)); }\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ntemplate<class T>\ndouble geodist(point<T> a,point<T> b,const circle<T> &C){\n\tdouble r=C.r;\n\tsegment<T> s(a,b);\n\tif(dist(s,C.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=C.c;\n\tb-=C.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntemplate<class T>\nstd::istream& operator>>(std::istream& is, point<T>& point){return ( is >> point.x >> point.y );}\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n\n//円の接点\nvector<P> GetContact(const P& p,const P& q,const double r){\n\tP a = p-q;\n\tdouble s = SQ(a.x) + SQ(a.y);\n\tdouble D = sqrt(s - SQ(r));\n\tdouble dx = r * D * a.y / s;\n\tdouble dy = r * D * a.x / s;\n\tdouble bx = SQ(r) * a.x / s;\n\tdouble by = SQ(r) * a.y / s;\n\tvector<P> ans(2);\n\tans[0].x = bx + dx;\n\tans[0].y = by - dy;\n\tans[1].x = bx - dx;\n\tans[1].y = by + dy;\n\n\tans[0] += q;\n\tans[1] += q;\n\n\treturn ans;\n}\n\n//todo : verifyしてないので、そのうち。\n// 円が交差しているか 「=」は問によって変更する\ntemplate<class T>\nint CircleCross(const circle<T> &c1,const circle<T> &c2){\n\tdouble l = abs(c1.c - c2.c);\n\tif(l >= c1.r + c2.r) return 3; //外部にある\n\tif(l + c1.r <= c2.r) return 2; //c1 ⊃ c2\n\tif(l + c2.r <= c1.r) return 1; //c1 ⊂ c2\n\treturn 0; //交差している\n}\n\n\ntypedef pair<P,P> PD;\n//円同士の交点\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\n\n//三角形の中にあるか\nbool InTri(const P p[3],const P& o){\n\treturn \n\t\t(ccw(p[0],p[1],p[2]) * ccw(p[0],p[1],o) != -1) &&\n\t\t(ccw(p[1],p[2],p[0]) * ccw(p[1],p[2],o) != -1) &&\n\t\t(ccw(p[2],p[0],p[1]) * ccw(p[2],p[0],o) != -1);\n}\n\n\nint main(){\n\tP p[3];\n\tC c;\n\twhile(cin>>p[0],p[0].x != 0 || p[0].y != 0){\n\t\tcin>>p[1]>>p[2];\n\t\tcin>>c.c>>c.r;\n\n\t\tbool ok = true;\n\t\tFOR(i,3){\n\t\t\tif(abs(p[i]-c.c) + EPS > c.r) ok = false;\n\t\t}\n\n\t\t//in-circle\n\t\tif(ok){ puts(\"b\"); continue; }\n\n\t\tok = false;\n\n\t\tFOR(i,3){\n\t\t\tdouble l = dist2(S(p[i],p[(i+1)%3]),c.c);\n\t\t\tif(l < c.r * c.r) ok = true;\n\t\t}\n\n\t\t//intersect\n\t\tif(ok){ puts(\"c\"); continue; }\n\n\t\tif(InTri(p,c.c))\n\t\t\tputs(\"a\"); //in-triangle\n\t\telse\n\t\t\tputs(\"d\"); //otherwise\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\ndouble dist(double x1,double y1,double x2,double y2){\n  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nint main()\n{\n  char flag;\n  int f;\n  double x1,y1,x2,y2,x3,y3,x4,y4,r;\n  double x,y;\n  while(cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4>>r){\n    f=0;\n    f += (dist(x1,y1,x4,y4)<r) + (dist(x2,y2,x4,y4)<r) + (dist(x3,y3,x4,y4)<r);\n    x=(x1+x2+x3)/3.0;\n    y=(y1+y2+y3)/3.0;\n    if(f==3)flag='b';\n    else if(f)flag='c';\n    else if(dist(x,y,x4,y4)<dist(x1,y1,x4,y4))flag='a';\n    else flag='d';\n    cout<<flag<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Vector2\n{\npublic:\n\tdouble length() const\n\t{\n\t\treturn sqrt( static_cast<double>( x * x + y * y ) );\n\t}\n\tint clossProduct( const Vector2& v ) const\n\t{\n\t\treturn this->x * v.y - this->y * v.x;\n\t}\n\tVector2 operator-( const Vector2& v ) const\n\t{\n\t\tVector2 ret;\n\t\tret.x = this->x - v.x;\n\t\tret.y = this->y - v.y;\n\t\treturn ret;\n\t}\n\n\tint x, y;\n};\n\nint main()\n{\n\tVector2 tri[ 3 ];\n\tVector2 cir;\n\tint cirR;\n\n\twhile( cin >> tri[ 0 ].x >> tri[ 0 ].y && !( !tri[ 0 ].x && !tri[ 0 ].y ) ){\n\t\tfor( int i = 1; i < 3; ++i ){\n\t\t\tcin >> tri[ i ].x >> tri[ i ].y;\n\t\t}\n\t\tcin >> cir.x >> cir.y;\n\t\tcin >> cirR;\n\n\t\tint flags = 0;\n\t\tint tangency = false;\n\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\tVector2 ao = cir - tri[ i ];\n\t\t\tVector2 ab = tri[ ( i + 1 ) % 3 ] - tri[ i ];\n\t\t\tdouble distance = abs( ab.clossProduct( ao ) ) / ab.length();\n\t\t\tif( distance >= cirR ){\n\t\t\t\tflags |= ( 1 << i );\n\t\t\t}\n\t\t\tif( distance == cirR ){\n\t\t\t\ttangency = true;\n\t\t\t}\n\t\t}\n\n\t\tchar result;\n\t\tif( flags == 7 ){\n\t\t\tint dir = 0;\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tVector2 oa = tri[ i ] - cir;\n\t\t\t\tVector2 ob = tri[ ( i + 1 ) % 3 ] - cir;\n\t\t\t\tif( oa.x * ob.y > oa.y * ob.x ){\n\t\t\t\t\tdir |= ( 1 << i );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dir % 7 == 0 ){\n\t\t\t\tresult = 'a';\n\t\t\t}else{\n\t\t\t\tif( tangency ){\n\t\t\t\t\tresult = 'c';\n\t\t\t\t}else{\n\t\t\t\t\tresult = 'd';\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( flags == 0 ){\n\t\t\tint dir = 0;\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tVector2 oa = tri[ i ] - cir;\n\t\t\t\tif( oa.length() <= cirR ){\n\t\t\t\t\tdir |= ( 1 << i );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dir == 7 ){\n\t\t\t\tresult = 'b';\n\t\t\t}else{\n\t\t\t\tresult = 'c';\n\t\t\t}\n\t\t}else{\n\t\t\tresult = 'c';\n\t\t}\n\n\t\tcout << result << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define EPS 1E-10\n#define SAME_SIGN( a , b ) ( a * b > EPS ? true : false )\n\nnamespace geometry{\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) < cir.radius + EPS ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) < cir.radius + EPS  &&\n\t\tget_distance( tri.b , cir.center ) < cir.radius + EPS  &&\n\t\tget_distance( tri.c , cir.center ) < cir.radius + EPS\n\t\t){\n\t\t\tstd::cout << \"b\" << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius - EPS  &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius - EPS  &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius - EPS\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << \"a\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << \"d\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << \"c\" << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << \"c\" << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define SAME_SIGN( a , b ) a * b > 0\n\nnamespace geometry{\n\n\t#define EPS 1E-10\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius + EPS ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.b , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.c , cir.center ) <= cir.radius\n\t\t){\n\t\t\tstd::cout << 'b' << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << 'a' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << 'd' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << 'c' << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << 'c' << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) {\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nint ccw(P a, P b, P c) {\n  b = vec(a,b); c = vec(a,c);\n  if(sgn(outp(b,c),0.0) > 0) return +1;\n  if(sgn(outp(b,c),0.0) < 0) return -1;\n  if(sgn(inp(b,c),0.0) < 0)  return +2;\n  if(sgn(abs(b),abs(c)) < 0) return -2;\n  return 0;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nbool iSP(L s, P p) {\n    return ccw(s.a, s.b, p) == 0;\n}\nD dSP(L s, P p) {\n  P r = proj(s, p);\n  if(iSP(s, r)) return abs(p - r); // 写像がs上にある\n  return min(abs(p - s.a), abs(p - s.b)); // 写像がs上にない\n}\nint containsGP(vector<P> g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(g[i], g[(i+1)%g.size()], p) == 0) return 0;\n    P a = vec(p, g[i]);\n    P b = vec(p, g[(i+1)%g.size()]);\n    if(a.y > b.y) swap(a, b);\n    if(sgn(a.y, 0.0) <= 0 && sgn(b.y, 0.0) > 0 && sgn(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\nint iCS(C c, L s) {\n  if(sgn(abs(c.p - s.a), c.r) <= 0 && sgn(abs(c.p - s.b), c.r) <= 0)\n    return -2;\n  if(sgn(abs(c.p - s.a), c.r) <= 0 || sgn(abs(c.p - s.b), c.r) <= 0)\n    return -1;\n  if(sgn(dSP(s, c.p), c.r) < 0)\n    return +2;\n  if(sgn(dSP(s, c.p), c.r) == 0)\n    return +1;\n  return 0;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    double R = min({dSP(L(tri[0], tri[1]), cir.p), dSP(L(tri[1], tri[2]), cir.p), dSP(L(tri[2], tri[0]), cir.p)});\n    // a\n    if(containsGP(tri, cir.p) >= 0 &&\n       sgn(cir.r, R) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(iCS(cir, L(tri[0], tri[1])) == 0 &&\n       iCS(cir, L(tri[1], tri[2])) == 0 &&\n       iCS(cir, L(tri[2], tri[0])) == 0) {\n      cout << \"d\" << endl;\n      continue;\n    }\n    cout << \"c\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-6;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n    b-=a, c-=a;\n    if( cross(b,c) >  EPS ) return CCW; // CCW : 反時計回り\n    if( cross(b,c) < -EPS ) return CW;  // CW : 時計回り\n    if(dot(b, c) < -EPS )   return +2;  // c--a--b on line\n    if(dot(b, b) + EPS < dot(c, c) ) return -2; // a--b--c on line ???\n    return ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 点 a から 点 b への角度を返す [0,2π]\ndouble dir(P a, P b) {\n\tP p = a - b;\n\tdouble angle = atan2( p.Y , p.X );\n\tif( p.X < 0 ) angle += PI;\n\tif( angle < 0 ) angle += 2.0 * PI;\n\treturn angle;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n    bool is_intersection(const Segment& s){\n        return ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n                 ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n    }\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n    double distance(Segment s) {\n        if( is_intersection(s) ) return 0.0;\n        return min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n    }\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n// Segment の順序を定義 (x座標の小さい端点で比較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の直交判定\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 点 p が直線上に乗っているか\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// 直線と点 p の距離\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 点 (*this)[0] から 点 (*this)[1] への角度を返す [0,2π]\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\tdouble angle = atan2( p.Y , p.X );\n\t\tif( p.X < 0 ) angle += PI;\n\t\tif( angle < 0 ) angle += 2.0 * PI;\n\t\treturn angle;\n\t}\n};\n\n// 円の表現\nstruct Circle{\n\t// 円の中心\n\tP p;\n\t// 円の半径\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// 円の面積\n\tdouble get_area() { return r * r * PI; }\n\t// 円周\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t// 直線と円の距離 (円の中心の点と直線の距離 - 円の半径)\n\tdouble distance(Line l){\n\t\treturn l.distance( p ) - r;\n\t}\n\t// 2つの円の位置関係\n\t// 2 つの円が離れている => 0\n\t// 2 つの円が外接する   => 1\n\t// 2 つの円が交わる     => 2\n\t// 2 つの円が内接する    => 3 (2つの円が等しいときは内接)\n\t// 円が含まれている       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // 離れている\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // 外接する\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // 内接する\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // 含まれる\n\t\t\treturn 4;\n\t\t}else { // 交わる\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// 円と直線の交わる点を返す\n\tpair<P,P> intersection(Line l) {\n\t\tpair<P,P> pp;\n\t\tif( this->distance(l) > EPS ) { // 円と直線の交点がないとき\t\n\t\t\tpp.first = pp.second = INF_P;\n\t\t}else { // 円と直線の交点があるとき\n\t\t\tdouble d = l.distance( p );\n\t\t\tdouble angle = -l.get_dir();\n\t\t\t// 点 l[0] を軸に点 l[1] と円の中心を回転\n\t\t\tP lp = rot2( l[0] , l[1] , angle );\n\t\t\tP cp = rot2( l[0] , p    , angle );\n\t\t\tdouble x1 = cp.X - sqrt( sq(r) - sq(d) );\n\t\t\tdouble x2 = cp.X + sqrt( sq(r) - sq(d) );\n\t\t\tP p1(x1,l[0].Y);\n\t\t\tP p2(x2,l[0].Y);\n\t\t\t// 回転して元に戻す\n\t\t\tp1 = rot2( l[0] , p1 , -angle );\n\t\t\tp2 = rot2( l[0] , p2 , -angle );\n\t\t\tpp.first = p1;\n\t\t\tpp.second = p2;\n\t\t}\n\t\treturn pp;\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.X, p.Y, r ); }\n};\n\n\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\tSegment AB(a,b), BC(b,c), CA(c,a);\n\t\treturn (AB.contain( p ) || BC.contain( p ) || CA.contain( p ) );\n\t}\n\t// 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\t// 点 p が三角形の辺上 or 頂点上 にあるときは誤差で正しい結果が返ってこないので注意!!!\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n\t// 三角形の内接円を返す\n\tCircle inscribed_circle() {\n\t\t// 三角形の外周の長さ\n\t\tdouble ABC = edgeA + edgeB + edgeC;\n\t\t\n\t\tdouble cx = (a.X * edgeA + b.X * edgeB + c.X * edgeC) / ABC;\n\t\tdouble cy = (a.Y * edgeA + b.Y * edgeB + c.Y * edgeC) / ABC;\n\t\tdouble r  = (2.0 * get_area()) / ABC ;\n\t\tCircle cir( P(cx,cy) , r );\n\t\treturn cir;\n\t}\n};\n\n\nint main(){\n\tint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile( cin >> x1 >> y1 , x1 || y1 ){\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tP p1(x1,y1), p2(x2,y2), p3(x3,y3), p4(x4,y4);\n\t\tSegment s1(p1,p2), s2(p2,p3), s3(p3,p1);\n\t\tLine    l1(p1,p2), l2(p2,p3), l3(p3,p1);\n\t\tCircle c( P(x4,y4), r );\n\t\tTriangle t( p1 , p2 , p3 );\n\t\t\n\t\t// 円の中に三角形\n\t\tif( dist(p4,p1) <= r && dist(p4,p2) <= r && dist(p4,p3) <= r ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else{\n\t\t\t// 円の中心が三角形の内部にあるかどうか\n\t\t\tif( t.is_inside(p4) ){\n\t\t\t\tpair<P,P> pp = c.intersection( l1 );\n\t\t\t\tbool flag = false;\n\t\t\t\tif( pp.first != INF_P && s1.contain(pp.first) || s1.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tpp = c.intersection( l2 );\n\t\t\t\tif( pp.first != INF_P && s2.contain(pp.first) || s2.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tpp = c.intersection( l3 );\n\t\t\t\tif( pp.first != INF_P && s3.contain(pp.first) || s3.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\t// 円と三角形の辺が交差するとき\n\t\t\t\tif( flag ){\n\t\t\t\t\tcout << \"c\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"a\" << endl;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tpair<P,P> pp = c.intersection( l1 );\n\t\t\t\tbool flag = false;\n\t\t\t\tif( pp.first != INF_P && s1.contain(pp.first) || s1.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tpp = c.intersection( l2 );\n\t\t\t\tif( pp.first != INF_P && s2.contain(pp.first) || s2.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\tpp = c.intersection( l3 );\n\t\t\t\tif( pp.first != INF_P && s3.contain(pp.first) || s3.contain(pp.second) ){\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t\t// 円と三角形の辺が交差するとき\n\t\t\t\tif( flag ){\n\t\t\t\t\tcout << \"c\" << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"d\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=min(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>-EPS)return 1; //intersect\n            if(in_triangle(p,t))return 2;//c in t\n            else return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n}\n\n\nusing namespace geo;\n\nint main(){\n    int x,y,r;\n    while(cin>>x>>y,x!=0||y!=0){\n        Poly t={P(x,y)};\n        REP(i,2){\n            cin>>x>>y;\n            t.pb(P(x,y));\n        }\n        cin>>x>>y>>r;\n        C c(P(x,y),r);\n        int res=is_triangle_C(t,c);\n        if(res==2)cout<<\"a\"<<endl;\n        if(res==3)cout<<\"b\"<<endl;\n        if(res==1)cout<<\"c\"<<endl;\n        if(res==0)cout<<\"d\"<<endl;\n\n    }\n   \n    \n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconst double eps = 1e-7;\nnamespace boost {\ntemplate <class T>\nstruct integer_iterator {\n    T a;\n    bool operator != (integer_iterator const & it) const { return a != it.a; }\n    T operator * () const { return a; }\n    integer_iterator & operator ++ () { ++ a; return *this; }\n    integer_iterator operator ++ (int) { return { a ++ }; }\n};\ntemplate <class T>\nstruct integer_range {\n    T l, r;\n    typedef integer_iterator<T> iterator;\n    iterator begin() const { return { l }; }\n    iterator end  () const { return { r }; }\n};\ntemplate <class T>\ninteger_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }\ntemplate <class T>\nstruct integer_iterator_with_step {\n    T a, d, i;\n    bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }\n    T operator * () const { return a+d*i; }\n    integer_iterator_with_step & operator ++ () { ++ i; return *this; }\n    integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }\n};\ntemplate <class T>\nstruct strided_integer_range {\n    T l, r, s;\n    typedef integer_iterator_with_step<T> iterator;\n    iterator begin() const { return { l, s, 0 }; }\n    iterator end  () const { return { l, s, (r - l) / s }; }\n};\ntemplate <class T>\nstrided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }\n}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };\nttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }\nttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }\nttt point<T> operator - (pca a) { return { -a.x, -a.y }; }\nttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }\nttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }\nttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }\nttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }\nttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }\nttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }\nttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }\nttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }\nttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }\nttt double length(pca p) { return sqrt(length_squared(p)); }\nttt point<T> normalized(pca a) { return (1 / length(a)) * a; }\nttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }\nttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }\nttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }\ntemplate <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> bool operator == (circle<T> const & a, circle<T> const & b) { return a.p == b.p and a.r == b.r; }\ntemplate <typename T> bool operator != (circle<T> const & a, circle<T> const & b) { return not (a == b); }\ntemplate <typename T> struct line { point<T> a, b; };\ntemplate <typename T> struct ray { point<T> a, b; };\ntemplate <typename T> struct segment { point<T> a, b; };\ntemplate <typename T> T length_squared(segment<T> const & p) { return length_squared(p.a - p.b); }\ntemplate <typename T> double length(segment<T> const & p) { return length(p.a - p.b); }\ntemplate <typename T>    line<T> to_line(    ray<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>    line<T> to_line(segment<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(   line<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(segment<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment(line<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment( ray<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T>\nstruct arc { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT length(arc<T> const & a) { return a.r * (a.b - a.a); }\ntemplate <typename T>\nbool valid(arc<T> const & a) {\n    assert (0 <= a.r);\n    return\n        - M_PI < a.a + eps and a.a < M_PI + eps and\n        - M_PI < a.b + eps and a.b < M_PI + eps;\n}\ntemplate <typename T>\ncircle<T> to_circle(arc<T> const & a) { return { a.p, a.r }; }\n\ntemplate <typename T>\nstruct circular_sector { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT sq(T x) { return x * x; }\ntemplate <typename T>\npoint<T> rotate_90(point<T> const & a) {\n    return { - a.y, a.x };\n}\ntemplate <typename T>\npoint<T> rotate_270(point<T> const & a) {\n    return { a.y, - a.x };\n}\ntemplate <typename T>\npoint<T> rotate_180(point<T> const & a) {\n    return { - a.x, - a.y };\n}\npoint<double> rotate(point<double> const & a, double th) {\n    return {\n        a.x * cos(th) - a.y * sin(th),\n        a.x * sin(th) + a.y * cos(th) };\n}\ntemplate <>\nint ccw(point<double> const & a, point<double> const & b, point<double> const & c) {\n    double x = cross(b - a, c - a);\n    return x > eps ? 1 : x < - eps ? -1 : 0;\n}\n\ndouble distance(point<double> const & a, point<double> const & b) {\n    return length(b - a);\n}\n\ndouble distance(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return std::abs( cross(p, e) );\n}\ndouble distance(point<double> const & a, line<double> const & b) {\n    return distance(b,a);\n}\n\nbool does_include(circle<double> const & a, point<double> const & b) {\n    return length(a.p - b) < a.r + eps;\n}\nbool is_on_circumference(point<double> const & a, circle<double> const & b) {\n    return std::abs(length(b.p - a) - b.r) < eps;\n}\n// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < std::abs(a.r - b.r) + eps;\n}\n// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < a.r + b.r + eps;\n}\n// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;\n}\n// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {\n    std::vector<point<double> > result;\n    if (distance(a.p, b.p) < eps) {\n        // nop\n    } else if (not does_intersect(a,b)) {\n        // nop\n    } else if (does_include(a,b) and not does_inscribe(a,b)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(a,b) or does_circumscribe(a,b)) {\n        circle<double> x = a;\n        circle<double> y = b;\n        if (not (x.r < y.r)) std::swap(x, y);\n        result.push_back(y.r * normalized(x.p - y.p) + y.p);\n    } else {\n        //       c\n        //      /|\\\n        // a.r / | \\ b.r\n        //    /th|  \\\n        //   a-------b\n        //       l\n        double l = length(b.p - a.p);\n        double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\n        double as = sqrt( sq(a.r) - sq(ac) );\n        point<double> e = normalized(b.p - a.p);\n        result.push_back(a.p + ac*e + as*rotate_90(e));\n        result.push_back(a.p + ac*e + as*rotate_270(e));\n    }\n    for (auto p : result) {\n        assert (does_include(a, p));\n        assert (does_include(b, p));\n    }\n    return result;\n}\n\nstd::vector<line<double> > tangents(circle<double> const & a, point<double> const & b) {\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not is_on_circumference(b,a)) {\n        // truly included\n        // nop\n    } else if (is_on_circumference(b,a)) {\n        point<double> e = normalized(a.p - b);\n        result.push_back({\n                b + rotate_90(e),\n                b + rotate_270(e) });\n    } else {\n        double theta = asin(a.r / length(b - a.p));\n        result.push_back({ b, b + rotate(a.p - b, + theta) });\n        result.push_back({ b, b + rotate(a.p - b, - theta) });\n    }\n    return result;\n}\n\nstd::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {\n    point<double> p = a.p + (a.r / (a.r + b.r)) * (b.p - a.p);\n    return tangents(a,p);\n}\nstd::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {\n    if (b.r < a.r) std::swap(a,b);\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not does_inscribe(b,a)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(b,a)) {\n        point<double> e = normalized(a.p - b.p);\n        result.push_back({\n                b.p + a.r*e + rotate_90(e),\n                b.p + a.r*e + rotate_270(e) });\n    } else {\n        point<double> d = b.p - a.p;\n        double theta = asin((b.r - a.r) / length(d));\n        point<double> dp = rotate(d, + theta);\n        point<double> dm = rotate(d, - theta);\n        point<double> ep = rotate_90(normalized(dp));\n        point<double> em = rotate_270(normalized(dm));\n        result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });\n        result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });\n    }\n    return result;\n}\nstd::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {\n    std::vector<line<double> > result;\n    for (auto l : common_inner_tangents(a,b)) result.push_back(l);\n    for (auto l : common_outer_tangents(a,b)) result.push_back(l);\n    return result;\n}\n\npoint<double> nearest_point(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return a.a + dot(p, e) * e;\n}\nbool is_tangent(line<double> const & a, circle<double> const & b) {\n    return std::abs( b.r - distance(a, b.p) ) < eps;\n}\nbool does_include(segment<double> const & a, point<double> const & b) {\n    point<double> p = b - a.a;\n    point<double> e = normalized(a.b - a.a);\n    return std::abs( cross(e, p) ) < eps and - eps < dot(e, p) and dot(e, p) < length(a) + eps;\n}\nbool is_tangent(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return is_tangent(l, b) and does_include(a, nearest_point(l, b.p));\n}\nbool does_intersect(line<double> const & a, circle<double> const & b) {\n    return distance(a, b.p) < b.r + eps;\n}\nbool does_intersect(circle<double> const & a, line<double> const & b) {\n    return does_intersect(b, a);\n}\nbool does_intersect(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return does_intersect(l, b) and\n        (does_include(a, nearest_point(l, b.p)) or\n         distance(a.a, b.p) < b.r + eps or\n         distance(a.b, b.p) < b.r + eps);\n}\n\nbool does_intersect(line<double> const & a, line<double> const & b) {\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return eps < std::abs( cross(p, q) );\n}\nbool is_parallel(line<double> const & a, line<double> const & b) {\n    return not does_intersect(a, b);\n}\nbool does_intersect(segment<double> const & a, segment<double> const & b) {\n    return\n        ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) == -1 and\n        ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) == -1;\n}\npoint<double> intersection_point(line<double> const & a, line<double> const & b) {\n    assert (does_intersect(a, b));\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return a.a + ( cross(q, b.a - a.a) / cross(q, p) ) * p;\n}\n\nbool does_include(ray<double> const & a, point<double> const & b) {\n    return ccw(a.a, a.b, b) == 0 and dot(a.b - a.a, b - a.a) > - eps;\n}\nbool does_intersect(ray<double> const & a, segment<double> const & b) {\n    if (does_include(a, b.a) or does_include(a, b.b)) return true;\n    line<double> la = to_line(a);\n    line<double> lb = to_line(b);\n    if (is_parallel(la, lb)) return false;\n    point<double> p = intersection_point(la, lb);\n    return does_include(a,p) and does_include(b,p);\n}\nbool does_intersect(segment<double> const & a, ray<double> const & b) {\n    return does_intersect(b, a);\n}\n\npoint<double> projection(point<double> const & a, line<double> const & b) {\n    point<double> e = normalized(b.b - b.a);\n    return dot(e, a - b.a) * e + b.a;\n}\ndouble distance(segment<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_line(a));\n    if (does_include(a, p)) {\n        return distance(to_line(a), b);\n    } else{\n        return std::min(distance(a.a, b), distance(a.b, b));\n    }\n}\ndouble distance(point<double> const & a, segment<double> const & b) {\n    return distance(b, a);\n}\ndouble distance(segment<double> const & a, segment<double> const & b) {\n    return std::min(std::min(std::min(\n            distance(a.a, b),\n            distance(a.b, b)),\n            distance(a, b.a)),\n            distance(a, b.b));\n}\n\npoint<double> projection(point<double> const & a, circle<double> const & b) {\n    return b.r * normalized(a - b.p) + b.p;\n}\nbool does_include(arc<double> const & a, point<double> const & b) {\n    assert (valid(a));\n    point<double> e = b - a.p;\n    double r = length(e);\n    double th = atan2(e.y, e.x);\n    return std::abs(a.r - r) < eps and  a.a < th + eps and th < a.b + eps;\n}\ndouble distance(arc<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_circle(a));\n    if (does_include(a, p)) {\n        return distance(p, b);\n    } else{\n        point<double> l = a.r * (point<double>) { cos(a.a), sin(a.a) } + a.p;\n        point<double> r = a.r * (point<double>) { cos(a.b), sin(a.b) } + a.p;\n        return std::min(distance(l, b), distance(r, b));\n    }\n}\ndouble distance(point<double> const & a, arc<double> const & b) {\n    return distance(b, a);\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    if (not does_intersect(a, b)) {\n        // nop\n    } else if (is_tangent(b, a)) {\n        result.push_back(nearest_point(b, a.p));\n    } else {\n        point<double> e = normalized(b.b - b.a);\n        point<double> p = nearest_point(b, a.p);\n        double h = distance(p, a.p);\n        double w = sqrt( sq(a.r) - sq(h) );\n        result.push_back(  w * e + p);\n        result.push_back(- w * e + p);\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, circle<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), b)) {\n        if (does_include(a, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, segment<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), to_line(b))) {\n        if (does_include(a, p) and does_include(b, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(segment<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nbool does_intersect(arc<double> const & a, segment<double> const & b) {\n    return not intersection_points(a, b).empty();\n}\nbool does_intersect(segment<double> const & a, arc<double> const & b) {\n    return does_intersect(b, a);\n}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\nint main() {\n    while (true) {\n        point<double> p[3];\n        cin >> p[0];\n        if (p[0].x == 0 and p[0].y == 0) break;\n        cin >> p[1] >> p[2];\n        circle<double> c;\n        cin >> c.p >> c.r;\n        if (abs(\n                    ccw(p[0], p[1], c.p) +\n                    ccw(p[1], p[2], c.p) +\n                    ccw(p[2], p[0], c.p)) == 3) {\n            if (\n                    not does_intersect((segment<double>){ p[0], p[1] }, c) and\n                    not does_intersect((segment<double>){ p[1], p[2] }, c) and\n                    not does_intersect((segment<double>){ p[2], p[0] }, c)) {\n                cout << 'a' << endl;\n            } else {\n                cout << 'c' << endl;\n            }\n        } else {\n            if (\n                    not does_intersect((segment<double>){ p[0], p[1] }, c) and\n                    not does_intersect((segment<double>){ p[1], p[2] }, c) and\n                    not does_intersect((segment<double>){ p[2], p[0] }, c)) {\n                cout << 'd' << endl;\n            } else if (\n                    distance(c.p, p[0]) < c.r and\n                    distance(c.p, p[1]) < c.r and\n                    distance(c.p, p[2]) < c.r) {\n                cout << 'b' << endl;\n            } else {\n                cout << 'c' << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct P{\n    P(){}\n    P(ll _r, ll _i):r(_r), i(_i){}\n    void real(const ll& v){r = v;}\n    void imag(const ll& v){i = v;}\n    ll r, i;\n};\n\nll real(const P& p){return p.r;}\nll imag(const P& p){return p.i;}\nll norm(const P& p){ll r = real(p), i = imag(p); return r * r + i * i;}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\nll cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\nll dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\nll distance(const P& a, const P& b, const P& p){\n    ll c = cross(p-a, b-a);\n    return c * c;\n}\n\nP ps[3], cc;\nll radius;\n\nbool doesLineAcrossCircle(const P& a, const P& b){\n    // if(cross(a-cc, b-cc) == 0){\n    //     return dot(a-cc, b-cc) < 0 && norm(a) >= radius * radius && norm(b) >= radius * radius;\n    // }\n    if(distance(a, b, cc) > radius * radius * norm(b-a)){return false;}\n    if(dot(cc-a, b-a) * dot(cc-b, b-a) <= 0){return true;}\n    return norm(cc-a) <= radius * radius || norm(cc-b) <= radius * radius;\n}\n\nbool isCircleInTriangle(){\n    REP(i, 3){\n        if(distance(ps[i], ps[(i+1)%3], cc) < radius * radius * norm(ps[i]-ps[(i+1)%3])){return false;}\n    }\n\n    int count_n = 0, count_p = 0;\n    REP(i, 3){\n        ll c = cross(cc-ps[i], ps[(i+1)%3]-ps[i]);\n        if(c < 0){\n            count_n += 1;\n        }else if(c == 0){\n            count_n += 1; count_p += 1;\n        }else{\n            count_p += 1;\n        }\n    }\n\n    if(count_n % 3 == 0 || count_p % 3 == 0){return true;}\n    return false;\n}\n\nbool isTriangleInCircle(){\n    REP(i, 3){\n        if(norm(ps[i]-cc) > radius * radius){return false;}\n    }\n    return true;\n}\n\nbool isIntersected(){\n    REP(i, 3){\n        if(doesLineAcrossCircle(ps[i], ps[(i+1)%3])){return true;}\n    }\n    return false;\n}\n\nint main(){\n    ll re, im;\n    while(std::cin >> re >> im, re || im){\n        ps[0].real(re); ps[0].imag(im);\n        \n        FOR(i, 1, 3){\n            ll re, im;\n            std::cin >> re >> im;\n        \n            ps[i].real(re); ps[i].imag(im);\n        }\n        \n        {\n            ll re, im;\n            std::cin >> re >> im;\n            \n            cc.real(re); cc.imag(im);\n        }\n        \n        std::cin >> radius;\n        \n        if(isCircleInTriangle()){puts(\"a\");}\n        else if(isTriangleInCircle()){puts(\"b\");}\n        else if(isIntersected()){puts(\"c\");}\n        else{puts(\"d\");}\n    }   \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS (1e-10)\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble distance_l_p(P a, P b, P c){\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2){\n\treturn (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS) &&\n\t\t(cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS);\n}\n\nint point_in_polygon(int n, P p[], P q){\n\tint i,flg;\n\tP o = P(0,0);\n\n\tfor(i=0;i<n;o+=p[i],i++);\n\to /= n;\n\tflg = is_intersected_ls(p[n-1],p[0],q,o);\n\tfor(i=0;i<n-1;i++){\n\t\tflg = flg || is_intersected_ls(p[i],p[i+1],q,o);\n\t}\n\treturn !flg;\n}\n\nint main(void){\n\tint i,flg1,flg2;\n\tdouble r;\n\tP p[3],o;\n\n\twhile(1){\n\t\tfor(i=0;i<3;i++){\n\t\t\tcin>>p[i].real()>>p[i].imag();\n\t\t\tif(!p[i].real() && !p[i].imag()) return 0;\n\t\t}\n\t\tcin>>o.real()>>o.imag()>>r;\n\n\t\tflg1 = distance_l_p(p[0],p[1],o) > r;\n\t\tflg1 += distance_l_p(p[1],p[2],o) > r;\n\t\tflg1 += distance_l_p(p[2],p[0],o) > r;\n\n\t\tflg2 = abs(p[0]-o) < r;\n\t\tflg2 += abs(p[1]-o) < r;\n\t\tflg2 += abs(p[2]-o) < r;\n\n\t\tif(flg1==3){\n\t\t\tif(point_in_polygon(3,p,o)) cout<<\"a\\n\";\n\t\t\telse if(!flg2) cout<<\"d\\n\";\n\t\t}\n\t\telse if(flg2==3) cout<<\"b\\n\";\n\t\telse cout<<\"c\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{ point a,b; };\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\n  segment t;\n  t.a=t.b=p;\n  t.b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(t.a.y<=ymn||t.a.y>=ymx)return 0;\n\n  \n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n  \n\n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(t.a,t.b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],t.a,t.b))cnt++;\n\n  return (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\n  double ans=0;\n  int tsz=t.size();\n\n  for(int i=0;i<tsz;i++){\n    double tmp=dist(t[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,t,tsz);\n  double res2=DBL_MAX;\n\n  t.push_back(t[0]);\n\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n  \n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p;\n  vector<point> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    t.clear();\n    for(int i=0;i<3;i++){\n      cin >> p.x >> p.y;\n      if(p.x==0 && p.y==0)return 0;\n      t.push_back(p);\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(t,C);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n    \n    t=construct_edge(p,3);\n    int res=point_contain(t,C.p,3);\n\n    if(res){\n      int fg=0;\n      for(int i=0;i<3;i++){\n\tif(crossCS(t[i].a,t[i].b,C)>0){\n\t  cout <<'c'<< endl;\n\t  fg=1;\n\t  break;\n\t}\n      }\n      if(fg)continue;\n      if(containCS(t[0].a,t[0].b,C))cout <<'b'<<endl;\n      else cout <<'a'<<endl;\n    }\n    else {\n      for(int i=0;i<3;i++){\n\tif(crossCS(t[i].a,t[i].b,C)>0){\n\t  cout <<'c'<< endl;\n\t  continue;\n\t}\n      }\n      cout <<'d'<< endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n};\n \nstruct segment{\n  point a,b;\n};\n \nstruct circle{\n  point p;\n  double r;\n};\n \ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n \ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n \ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n \ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n \ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n \n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n \nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n    temp.a=p[i];\n    temp.b=p[j];\n    seg.push_back(temp);\n      }\n    }\n  }\n \n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && vec_abs(seg[i].b-seg[j].a)<=EPS){\n    if(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n      fg=1;\n      break;\n    }\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n \nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n \n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n   \n  return 1;\n}\n \nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n \n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n \n    double ans=0;\n    for(int i=0;i<3;i++){\n    int tmp=dist(p[i],C.p);\n    if(tmp>ans)ans=tmp;\n    }\n    if(C.r>=ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n     \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=100000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n \n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n     \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\ntypedef complex<double> P;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//-1 ???????????????\n//0 ??\\??????\n//1 ???????????§????????????\n//2 ???????????§????????????\nint intersectSC(const L &s, const C &c) {\n  int ins = 0;\n  for(int i = 0; i < 2; i++ ) {\n    if (abs(s[i]-c.p)<c.r) ins++;\n    else if (EQ(abs(s[i]-c.p), c.r)) return 0;\n  }\n  if (ins == 2) return -1;\n  if (ins == 1) return 1;\n  double d = distanceLP(s, c.p);\n  if (d-c.r > EPS) return -1;\n  P nor=(s[0]-s[1]) * P(0, 1);\n  if (ccw(c.p, c.p+nor, s[0]) * ccw(c.p, c.p+nor, s[1]) < 0) return 2;\n  return -1;\n}\n\nenum { OUT, ON, IN };\nint contains(const vector<P> &g, const P &p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool inputP(P &p){\n  int x, y; cin >>x >>y;\n  if(x == 0 && y == 0) return false;\n  p = P(x, y);\n  return true;\n}\n\nchar solve(vector<P> &t, P c, int r){\n    double d[3];\n    REP(i, 3) d[i] = abs(c - t[i]);\n    if(d[0] > r && d[1] > r && d[2] > r && contains(t, c) == IN) return 'a';\n    if(d[0] < r && d[1] < r && d[2] < r) return 'b';\n    REP(i, 3) if(intersectSC(L(t[i], next(t, i)), C(c, r)) > -1) return 'c';\n    return 'd';\n}\n\nint main(){\n  vector<P> t(3);\n  P c;\n  int r;\n  while(inputP(t[0])){\n    FOR(i, 1, 3) inputP(t[i]);\n    inputP(c); cin >>r;\n    cout <<solve(t, c, r) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n\ndouble dot(P a,P b){\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\ndouble cross(P a,P b){\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble distance_ls_p(P a,P b,P c){\n\tif(dot(b-a,c-a) < EPS) return abs(c-a);\n\tif(dot(a-b,c-b) < EPS) return abs(c-b);\n\treturn abs(cross(b-a,c-a)) / abs(b-a);\n}\n\nbool pol_contains_cir(vector<P> p,P o,double r){\n\tint n = p.size();\n\tint cr = 0, cl = 0;\n\tfor(int i=0;i<n;i++){\n\t\tP a = p[i];\n\t\tP b = p[(i+1)%n];\n\t\tif(0 > cross(b-a,o-a)) cr++;\n\t\tif(0 < cross(b-a,o-a)) cl++;\n\t\tif(distance_ls_p(a,b,o) < r + EPS) return false;\n\t}\n\tif(cr != n && cl != n) return false;\n\n\treturn true;\n}\n\nbool cir_contains_pol(vector<P> p,P o,double r){\n\tfor(int i=0;i<p.size();i++){\n\t\tif(r < abs(p[i]-o) + EPS) return false;\n\t}\n\treturn true;\n}\n\nbool is_intersected_ls_cir(P a,P b,P o,double r){\n\tdouble ao = abs(a-o);\n\tdouble bo = abs(b-o);\n\n\treturn ((ao < r + EPS && r < bo + EPS || r < ao + EPS && bo < r + EPS) ||\n\t\t\t\t\t(r < ao + EPS && r < bo + EPS && distance_ls_p(a,b,o) < r + EPS));\n}\n\nbool is_intersected_pol_cir(vector<P> p,P o,double r){\n\tint n = p.size();\n\n\tfor(int i=0;i<n;i++){\n\t\tif(is_intersected_ls_cir(p[i],p[(i+1)%n],o,r)) return true;\n\t}\n\n\treturn false;\n}\n\nint main(void){\n\t/*\n\tP a = P(0,0);\n\tP b = P(0,2);\n\tP c = P(-0.1,1);\n\n\tcout << cross(b-a,c-a) << endl;\n\t*/\n\n\twhile(1){\n\t\tvector<P> p;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tP tmp;\n\t\t\tcin>>tmp.real()>>tmp.imag();\n\t\t\tif(tmp.real()==0 && tmp.imag()==0) return 0;\n\t\t\tp.push_back(tmp);\n\t\t}\n\n\t\tP o;\n\t\tdouble r;\n\n\t\tcin>>o.real()>>o.imag()>>r;\n\n\t\tif(pol_contains_cir(p,o,r))\n\t\t\tcout<<\"a\\n\";\n\t\telse if(cir_contains_pol(p,o,r)){\n\t\t\tcout<<\"b\\n\";\n\t\t}\n\t\telse if(is_intersected_pol_cir(p,o,r)){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"d\\n\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ninline D inprd(const P &a, const P &b){ return (conj(a) * b).X; }\ninline D outprd(const P &a, const P &b){ return (conj(a) * b).Y; }\ninline D sign(D d){ return (d<0)?-1:d>0?1:0; }\n\nbool is_intriangle(const P &p1, const P &p2, const P &p3, const P &q){\n    D s1 = sign(outprd(p2-p1,q-p1)), s2 = sign(outprd(p3-p2,q-p2)), s3 = sign(outprd(p1-p3,q-p3));\n    return (s1 == s2 && s2 == s3);\n}\ninline P circum_center(const P &a, const P &b, const P &c){\n    P bc = c - b, ca = a - c, ab = b - a;\n    return (a + b - (inprd(bc, ca) / outprd(ab, bc)) * ab * P(0,1)) / 2.0;\n}\nD distance_ls_p(const P &a, const P &b, const P &c){\n    if(inprd(b-a, c-a) < EPS) return abs(c-a);\n    if(inprd(a-b, c-b) < EPS) return abs(c-b);\n    return abs(outprd(b-a, c-a)) / abs(b-a);\n}\n\nstring solve(P p1, P p2, P p3, P pc, int r){\n    D dr = r;\n    if( distance_ls_p(p1,p2,pc) >= dr - EPS &&\n        distance_ls_p(p2,p3,pc) >= dr - EPS &&\n        distance_ls_p(p3,p1,pc) >= dr - EPS)\n    {\n        if(is_intriangle(p1,p2,p3,pc)) return \"a\";\n        else return \"d\";\n    }\n    if(norm(p1-pc) < r*r && norm(p2-pc) < r*r && norm(p3-pc) < r*r) return \"b\";\n    return \"c\";\n}\n\nint main(){\n    P p1,p2,p3,pc;\n    int r;\n    int x, y;\n    while(cin >> x >> y && x && y){\n        p1 = P(x,y);\n        cin >> x >> y;\n        p2 = P(x,y);\n        cin >> x >> y;\n        p3 = P(x,y);\n        cin >> x >> y >> r;\n        pc = P(x,y);\n        cout << solve(p1,p2,p3,pc,r) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n// const double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = p - a;\n        Point v2 = b - p;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return center.distance(p) < r;}\n    bool include(const Segment& s) const {return center.distance(s) < r;}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n    if(s.ccw(p) == ON) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x - y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + Point(t, t) * v2;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n    for(auto& e: edge) if(circle.include(e)) return \"c\";\n\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center) >= 0) ++ccw;\n        if(e.ccw(circle.center) <= 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-10\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    if (norm(a) < r2) {\n      c[i] = -1;\n    } else if (norm(a) > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0. && c[1]>=0. && c[2]>=0.) {\n    return 1;\n  } else if (c[0]<=0. && c[1]<=0. && c[2]<=0.) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nbool intersect() {\n  C a, b;\n  double na, nb, dab, d, sd, s, t;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    na = norm(a);\n    nb = norm(b);\n    dab = dot(a,b);\n    d = dab*dab - na*(nb-r*r);\n    if (d <= EPS) {\n      continue;\n    }\n    sd = sqrt(d);\n    s = (dab+sd)/na;\n    t = (dab-sd)/na;\n    if ((s>0.&&s<1.) || (t>0.&&t<1.)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      if (intersect()) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-10\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double na;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    na = norm(a);\n    if (na < r2) {\n      c[i] = -1;\n    } else if (na > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0 && c[1]>=0 && c[2]>=0) {\n    return 1;\n  } else if (c[0]<=0 && c[1]<=0 && c[2]<=0) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  //double na, nb, dab, d; \n  double sd, s, t;\n  long long int ina, inb, idab, id;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    //na = norm(a);\n    //nb = norm(b);\n    //dab = dot(a,b);\n    //d = dab*dab - na*(nb-r*r);\n    ina = (int)a.real()*(int)a.real()+(int)a.imag()*(int)a.imag();\n    inb = (int)b.real()*(int)b.real()+(int)b.imag()*(int)b.imag();\n    idab = (int)a.real()*(int)b.real()+(int)a.imag()*(int)b.imag();\n    id = idab*idab - ina*(inb-(int)r*(int)r);\n    if (id < 0) {\n      continue;\n    }\n    sd = sqrt((double)id);\n    s = (idab+sd)/ina;\n    t = (idab-sd)/ina;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (!id) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble dist(const P& a, const P& b)\n{\n\treturn sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nbool isIntoC(const P& p, const C& c)\n{\n\treturn dist(p, c.p) < c.r;\n}\n\nbool isIntoC(const L& l, const C& c)\n{\n\treturn dist(l[0], c.p)+EPS < c.r && dist(l[1], c.p)+EPS < c.r;\n}\n\nbool intersectSC(const L& l, const C& c)\n{\n\tif(isIntoC(l, c)) return false;\n\t\n\tdouble vc=dot(l[1]-l[0], c.p-l[0]);\n\tif(vc+EPS<0)\n\t{\n\t\treturn dist(l[0], c.p)<c.r+EPS;\n\t}\n\t\n\tdouble vv=dot(l[1]-l[0], l[1]-l[0]);\n\t\n\tif(vc > vv)\n\t{\n\t\tdouble d=dist(l[1], c.p);\n\t\t\n\t\treturn d*d<c.r*c.r+EPS;\n\t}\n\t\n\tdouble cc=dot(c.p-l[0], c.p-l[0]);\n\t\n\treturn cc-(vc/vv)*vc < c.r*c.r+EPS;\n}\n\nint main()\n{\n\tint x,y,r;\n\twhile(scanf(\"%d%d\", &x, &y), (x||y))\n\t{\n\t\tvector<P> tri;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\ttri.push_back(P(x,y));\n\t\t\tif(i==2) break;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t}\n\t\n\t\tscanf(\"%d%d%d\", &x,&y,&r);\n\t\tC c(P(x,y), r);\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\tif(!isIntoC(tri[i], c))\n\t\t\t{\n\t\t\t\tg=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(g) \n\t\t{\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tg=false;\n\t\tfor(int i=0; i<tri.size(); i++)\n\t\tfor(int j=i+1; j<tri.size(); j++)\n\t\t{\n\t\t\tif(intersectSC(L(tri[i], tri[j]), c))\n\t\t\t{\n\t\t\t\tg=true;\n\t\t\t}\n\t\t}\n\t\tif(g)\n\t\t{\n\t\t\tputs(\"c\");\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\tint cnt=0, cr[3];\n\t\tcr[0]=cross(tri[0]-tri[1], tri[0]-c.p);\n\t\tcr[1]=cross(tri[1]-tri[2], tri[1]-c.p);\n\t\tcr[2]=cross(tri[2]-tri[0], tri[2]-c.p);\n\t\t\n\t\tif(cr[0]<0&&cr[1]<0&&cr[2]<0||cr[0]>0&&cr[1]>0&&cr[2]>0) puts(\"a\");\n\t\telse puts(\"d\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& _p, double _r) : p(_p), r(_r) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0.0 && d1 * d2 > 0.0 && d2 * d0 > 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(3);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL l1(tr[1], tr[2]);\n\tL l2(tr[2], tr[0]);\n\td[0] = distP2LS(cc.p, l0);\n\td[1] = distP2LS(cc.p, l1);\n\td[2] = distP2LS(cc.p, l2);\n\tif(in && d[0] >= cc.r && d[1] >= cc.r && d[2] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect ?\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\n\t// intersects each other ?\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n// ½ÊãÌ_ExNg\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// OÏ\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\n// àÏ\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\n// ¼ü\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n// ½p`\ntypedef vector<P> G;\n\n// ~\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0)   return +1; // ½vñè\n\tif(cross(b, c) < 0)   return -1; // vñè\n\tif(dot(b, c) < 0)     return +2; // c--a--b\n\tif(norm(b) < norm(c)) return -2; // a--b--c\n\treturn 0;\n}\n\n// üªÆ_Ìð·»è\nbool intersectSP(const L& s, const P& p){\n\treturn abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;\n}\n\n// ¼üãÌ_ÌËe\nP projection(const L& l, const P& p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\n// üªÆ_Ì£\ndouble distanceSP(const L& s, const P& p){\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nchar detect(const G& tri, const C& c)\n{\n\tbool inner[3];\n\trep(i, 3){\n\t\tinner[i] = abs(tri[i] - c.p) - EPS <= c.r;\n\t}\n\tif(inner[0] && inner[1] && inner[2])\n\t\treturn 'b';\n\tif(inner[0] || inner[1] || inner[2])\n\t\treturn 'c';\n\t\n\tbool tangent = false;\n\trep(i, 3){\n\t\tL l(tri[i], tri[(i+1)%3]);\n\t\tdouble dist = distanceSP(l, c.p);\n\t\t\n\t\tif(fabs(dist - c.r) < EPS)\n\t\t\ttangent = true;\n\t\telse if(dist < c.r)\n\t\t\treturn 'c';\n\t}\n\t\n\tint v = 0;\n\trep(i, 3){\n\t\tint now = ccw(tri[i], tri[(i+1)%3], c.p);\n\t\tif(abs(now) == 2 || now * v < 0)\n\t\t\treturn tangent ? 'c' : 'd';\n\t\tv = now;\n\t}\n\t\n\treturn 'a';\n}\n\nint main()\n{\n\tfor(;;){\n\t\tG tri(3);\n\t\trep(i, 3){\n\t\t\tscanf(\"%lf%lf\", &tri[i].real(), &tri[i].imag());\n\t\t\tif(fabs(tri[i].real()) < EPS)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(fabs(tri[0].real()) < EPS)\n\t\t\tbreak;\n\t\t\n\t\tP p;\n\t\tdouble r;\n\t\tscanf(\"%lf%lf%lf\", &p.real(), &p.imag(), &r);\n\t\tprintf(\"%c\\n\", detect(tri, C(p, r)));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2){};\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn(s1.p1 + (s1.p2 - s1.p1) * t);\n}\n\ndouble arg(Vector p)\n{\n\treturn(atan2(p.y, p.x));\n}\n\nVector polar(double a, double r)\n{\n\treturn(Point(cos(r) * a, sin(r) * a));\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn(make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)));\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn(make_pair(pr - e * base, pr + e * base));\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tPoint p1;\n\twhile (cin >> p1.x >> p1.y, p1.x || p1.y)\n\t{\n\t\tPoint p2, p3, p4;\n\t\tint r;\n\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y >> r;\n\t\t\n\t\tif (r - getDistance(p4, p1) > 0 && r - getDistance(p4, p2) > 0 && r - getDistance(p4, p3) > 0)\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if (cross(p1 - p4, p2 - p4) * cross(p2 - p4, p3 - p4) > 0 && cross(p2 - p4, p3 - p4) * cross(p3 - p4, p1 - p4) > 0 && cross(p3 - p4, p1 - p4) * cross(p1 - p4, p2 - p4) > 0 &&\n\t\t\t     getDistanceSP(Segment(p1, p2), p4) - r > 0 && getDistanceSP(Segment(p1, p3), p4) - r > 0 && getDistanceSP(Segment(p2, p3), p4) - r > 0)\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse if (getDistanceSP(Segment(p1, p2), p4) - r > 0 && getDistanceSP(Segment(p1, p3), p4) - r > 0 && getDistanceSP(Segment(p2, p3), p4) - r > 0 )\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef complex<ld> Point;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_Point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// ccw\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ????????¨???????????????\nvector<Point> is_ss2(const Line &s, const Line& t) {\n\tvector<Point> kouho(is_ll2(s, t));\n\tvector<Point>ans;\n\tfor (auto p : kouho) {\n\t\tif (isis_sp(s, p) && isis_sp(t, p))ans.emplace_back(p);\n\t}\n\treturn ans;\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n//??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n/*  0 => out\n1 => on\n2 => in*/\nint is_in_Circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint Circle_in_Circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), all(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_Circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n//????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n/*0 => out\n1 => on\n2 => in*/\nint is_in_Polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\trep(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { out, on, in };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n//???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n//????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon q;\n\tPolygon r;\n\trep(i, n) {\n\t\tPoint a = ps[i], b = ps[(i + 1) % n];\n\t\tLine m = Line(a, b);\n\t\tif (ccw(l.a, l.b, a) != -1) q.push_back(a);\n\t\tif (ccw(l.a, l.b, a) != 1) r.push_back(a);\n\t\tif (ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0 && isis_ll(l, m)) {\n\t\t\tq.push_back(is_ll(l, m));\n\t\t\tr.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ q,r };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_Point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tedge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nvoid add_edge(graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(edge{ from, to, weight });\n}\n\ngraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\ngraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll2(s[i], s[j])[0]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\ngraph Circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tgraph g(n);\n\trep(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\trep(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(all(vec));\n\t\trep(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main() {\n\t\n\twhile (1) {\n\t\tint x1, y1; cin >> x1 >> y1;\n\t\tif (!x1)break;\n\t\tint x2, y2, x3, y3, x4, y4, r; cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tPolygon tri;\n\t\ttri.push_back(Point(x1, y1));\n\t\ttri.push_back(Point(x2, y2));\n\t\ttri.push_back(Point(x3, y3));\n\t\tCircle c(Point(x4, y4), r);\n\t\tbool flag_b = true;\n\t\t{\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tif (!is_in_Circle(c, tri[i])) {\n\t\t\t\t\tflag_b = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag_a = false;\n\t\tbool  flag_c = false;\n\t\t{\n\t\t\tif (convex_contains(tri, c.p)) {\n\t\t\t\tflag_a = true;\n\t\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\t\tLine l(tri[i], tri[(i + 1) % 3]);\n\t\t\t\t\tif (dist_sp(l, c.p)<c.r) {\n\t\t\t\t\t\tflag_a = false;\n\t\t\t\t\t\tflag_c = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tif (is_in_Circle(c, tri[i])) {\n\t\t\t\t\tflag_c = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag_b) {\n\t\t\tcout << 'b' << endl;\n\t\t}\n\t\telse if (flag_a) {\n\t\t\tcout << 'a' << endl;\n\t\t}\n\t\telse if (flag_c) {\n\t\t\tcout << 'c' << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << 'd' << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef double D;\ntypedef complex<D> P;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\ndouble x[3],y[3],xr,yr,r;\nbool dis(int p){\n  return sqrt(abs(x[p]-xr)*abs(x[p]-xr)+abs(y[p]-yr)*abs(y[p]-yr))<=r+0.01;\n}\nmain(){\n  while(cin>>x[0]>>y[0],x[0]+y[0]){\n    int sum=0;\n    r(i,2)cin>>x[i+1]>>y[i+1];\n    cin>>xr>>yr>>r;\n    r(i,3)if(dis(i))sum++;\n    if(sum==0){\n      int pp=0;\n      r(i,3){\n        pp+=ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr));\n        if(ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr))==-2)exit(1);\n      }\n      if(abs(pp)==3)cout<<'a'<<endl;\n      else cout<<'d'<<endl;\n    }\n    else if(sum==3)cout<<'b'<<endl;\n    else cout<<'c'<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])==OUT)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[i])==IN)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        if(contains(g,c))puts(\"a\");\n        else if(contains(c,g))puts(\"b\");\n        else{\n            bool x=false;\n            for(int i=0;i<g.size();i++){\n                if(contains(c,g[i]))x=true;\n            }\n            puts(x?\"c\":\"d\");\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>=0&&cross(b,c)>=0&&cross(c,a)>=0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))){\n\t\t\tif(isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t\t}\n\t\t\t// ~ÌSªOp`ÌÉ¶ÝµÈ¢ê\n\t\t\telse{\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t\t}\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\nconst double EPS = 1e-12;\n\ndouble cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\nxy_t projection(const line &l, const xy_t &p){\n  double t = dot(l.second - l.first, p - l.first) / norm(l.second - l.first);\n  return l.first + t * (l.second - l.first);\n}\n\nbool intersectSP(const line &l, const xy_t &p){\n  return abs(p - l.first) + abs(p - l.second) < abs(l.first - l.second) + EPS;\n}\n\ndouble distanceSP(const line &l, const xy_t &p){\n  xy_t r = projection(l, p);\n  if(intersectSP(l, r)) return abs(r - p);\n  else return min(abs(l.first - p), abs(l.second - p));\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return 1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n \nxy_t p[3];\nline l[3];\nxy_t c;\ndouble r;\n\n\nint main(){\n  int x, y;\n  int c1, c2;\n  while(cin >> x>> y && (x || y)){\n    p[0] = xy_t(x, y);\n    for(int i = 1; i < 3; i++) {\n      cin >> x >> y;\n      p[i] = xy_t(x, y);\n    }\n    cin >> x >> y;\n    cin >> r;\n    c = xy_t(x, y);\n    \n    rep(i, 3) l[i] = line(p[i], p[(i+1)%3]);\n    c1 = 0, c2 = 0;\n    int cnt = 0;\n\n    rep(i, 3){\n      int d = ccw(p[i], p[(i+1)%3], c);\n      if(d > 0) c1++;\n      if(d < 0) c2++;\n    }\n    bool circle_in[3];\n    rep(i, 3){\n      if(distanceSP(l[i], c) < r + EPS) cnt++;\n      if(distanceSP(l[i], c) > r - EPS){\n\tcircle_in[i] = true;\n      }else{\n\tcircle_in[i] = false;\n      }\n    }\n    \n    bool t_in[3];\n    rep(i, 3){\n      if(abs(c - p[i]) < r + EPS){\n\tt_in[i] = true;\n\tcnt++;\n      }else{\n\tt_in[i] = false;\n      }\n    }\n    if(circle_in[0] && circle_in[1] && circle_in[2] && max(c1, c2) == 3){\n      cout << 'a' << endl;\n    }else if(t_in[0] && t_in[1] && t_in[2]) {\n      cout << 'b' << endl;\n    }else if(cnt > 0){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nD dis(P a,P b){\n\treturn sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\ndouble x1,x2,x3,y4,y2,y3,x,y,r;\nmain(){\n\twhile(cin>>x1>>y4,x1||y4){\n\t\tcin>>x2>>y2>>x3>>y3>>x>>y>>r;\n\t\tvector<P>v;\n\t\tv.push_back(P(x1,y4));\n\t\tv.push_back(P(x2,y2));\n\t\tv.push_back(P(x3,y3));\n\t\tif(inConvex(P(x,y),v)&&dis(P(x1,y4),P(x,y))>r&&dis(P(x2,y2),P(x,y))>r&&dis(P(x3,y3),P(x,y))>r)cout<<'a'<<endl;\n\t\telse if(dis(P(x1,y4),P(x,y))<r&&dis(P(x2,y2),P(x,y))<r&&dis(P(x3,y3),P(x,y))<r)cout<<'b'<<endl;\n\t\telse if(distSP(P(x1,y4),P(x2,y2),P(x,y))<=r||distSP(P(x3,y3),P(x2,y2),P(x,y))<=r||distSP(P(x1,y4),P(x3,y3),P(x,y))<=r)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-7\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0,double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n  Point operator * (double a){ return Point(x*a, y*a); }\n  Point operator / (double a){ return Point(x/a, y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nclass Segment{\npublic:\n  Vector t,s;\n  Segment(Vector t,Vector s) : t(t),s(s) {}\n};\n\nclass Circle{\npublic:\n  double x,y,r;\n  Circle(double x = 0.0,double y = 0.0,double r = 0.0) : x(x),y(y),r(r) {}\n};\n\nPoint point[3];\nCircle ci;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nbool check(){\n  Point cp = Point(ci.x,ci.y);\n  int c1 = ccw(point[0],point[1],cp);\n  int c2 = ccw(point[1],point[2],cp);\n  int c3 = ccw(point[2],point[0],cp);\n  return (c1 == c2 && c2 == c3);\n}\n\ntypedef Segment Line;\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.s-l.t,p-l.t)/(l.s-l.t).abs());\n}\n\ndouble getDistanceSP(Segment seg,Point p){\n  if(dot(seg.s-seg.t,p-seg.t) < 0.0) return (p-seg.t).abs();\n  if(dot(seg.t-seg.s,p-seg.s) < 0.0) return (p-seg.s).abs(); \n  return getDistanceLP(seg,p);\n}\n\nint getStateCS(Circle c,Segment seg){\n  Point cp = Point(c.x,c.y);\n  if(getDistanceSP(seg,cp) >= c.r){\n    return 1;\n  }\n  return 3;\n}\n\nbool isCross(){\n  Point cp = Point(ci.x,ci.y);\n  for(int i = 0 ; i < 3 ; i++){\n    Point p = point[i];\n    Point diff = p - cp;\n    if(diff.abs() == ci.r) return true;\n  }\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  \n  for(int i = 0 ; i < 3 ; i++){\n    if(getDistanceSP(seg[i],cp) < ci.r){\n      return true;\n    }\n  }\n\n  for(int i = 0 ; i < 3 ; i++){\n    Segment ns = seg[i];\n    Point p1 = ns.t, p2 = ns.s;\n    if(p1.abs() < ci.r && p2.abs() > ci.r) return true;\n    if(p1.abs() > ci.r && p2.abs() < ci.r) return true;\n  }\n\n  return false;\n}\n\nvoid judge(){\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  Point cp = Point(ci.x,ci.y);\n  int TinC = 0;\n  for(int i = 0 ; i < 3 ; i++,TinC++){\n    if((point[i]-cp).abs() > ci.r){\n      break;\n    }\n  }\n\n  if(TinC == 3){\n    cout << 'b' << endl;\n    return;\n  }\n\n  int CinT = 0;\n  for(int i = 0 ; i < 3 ; i++){\n    int N = getStateCS(ci,seg[i]);\n    if(N == 1){\n      CinT++;\n    }\n  }\n\n  if(CinT == 3 && check()){\n    cout << 'a' << endl;\n  }else{\n    if(isCross()){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}\n\nint main(){\n  while(true){\n    cin >> point[0].x >> point[0].y;\n    if(!point[0].x && !point[0].y) break;\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> point[i+1].x >> point[i+1].y;\n    }\n    cin >> ci.x >> ci.y >> ci.r;\n    judge();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& _p, double _r) : p(_p), r(_r) {} \n};\n\n// code for problem\n\nint x, y, r;\nP tr[3];\nC cc;\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 >= 0 && d1 * d2 >= 0 && d2 * d0 >= 0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(6);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tprintf(\"%f %f %f\\n\", d[0], d[1], d[2]);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\td[3] = distP2LS(cc.p, L(tr[0], tr[1]));\n\td[4] = distP2LS(cc.p, L(tr[1], tr[2]));\n\td[5] = distP2LS(cc.p, L(tr[2], tr[0]));\n\tif(in && d[3] >= cc.r && d[4] >= cc.r && d[5] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tsort(d.begin(), d.end());\n\tif(d[0] <= cc.r) {\n\t\tprintf(\"c\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect\n\tprintf(\"d\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst double eps = 1e-8;\nint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\ndouble distDbl(double ax, double ay, double bx, double by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\nint distDbl(int ax, int ay, int bx, int by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\ndouble getPerpDistDbl(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, res;\n    if (ax == bx) {\n        res = (cx - ax) * (cx - ax);\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        res = (a * cx - cy + b) * (a * cx - cy + b) / (1 + a * a);\n    }\n    return res;\n}\n\ndouble getPerpDistSegDbl(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, x, y, res;\n    if (ax == bx) {\n        y = cy;\n        if (min(ay, by) <= y && y <= max(ay,by)) {\n            res = (cx - ax) * (cx - ax);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        x = (ax + a * (ay - b)) / (1 + a * a);\n        y = a * x + b;\n        if (min(ax, bx) <= x && x <= max(ax,bx) &&\n            min(ay, by) <= y && y <= max(ay,by)) {\n            res = distDbl(x,y,cx,cy);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    }\n    return res;\n}\n\nbool isA() {\n    int c = 0;\n    if (0 <= (x2-x1)*(y4-y1)-(y2-y1)*(x4-x1)) ++c;\n    if (0 <= (x3-x2)*(y4-y2)-(y3-y2)*(x4-x2)) ++c;\n    if (0 <= (x1-x3)*(y4-y3)-(y1-y3)*(x4-x3)) ++c;\n    if (c % 3 != 0) return false;\n    if (getPerpDistDbl(x1, y1, x2, y2, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x2, y2, x3, y3, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x3, y3, x1, y1, x4, y4) + eps < r*r) return false;\n    return true;\n}\n\nbool isB() {\n    if (distDbl(x1,y1,x4,y4) <= r*r && distDbl(x2,y2,x4,y4) <= r*r && distDbl(x3,y3,x4,y4) <= r*r) {\n        return true;\n    }\n    return false;\n}\n\nbool isC() {\n    if (getPerpDistSegDbl(x1,y1,x2,y2,x4,y4) + eps < r*r) return true;\n    if (getPerpDistSegDbl(x2,y2,x3,y3,x4,y4) + eps < r*r) return true;\n    if (getPerpDistSegDbl(x3,y3,x1,y1,x4,y4) + eps < r*r) return true;\n    return false;\n}\n\nint main() {\n    while (cin >> x1 >> y1, (x1 || y1)) {\n        cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n        if (isB()) cout << \"b\" << endl;\n        else if (isA()) cout << \"a\" << endl;\n        else if (isC()) cout << \"c\" << endl;\n        else cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> Po;\n\n\nPo p[3],o;\n\ndouble dot(Po x, Po y){return x.real()*y.real()+x.imag()*y.imag();}\n\ndouble cross(Po x, Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a, Po b, Po c){return abs(cross(b-a,c-a))/2;}\n\nbool inter(Po a, Po b, Po c, Po x){\n  return (fabs(area(a,b,x)+area(b,c,x)+area(c,a,x)-area(a,b,c)) < EPS);\n}\n\ndouble seg_dis(Po a, Po b, Po c){\n  if(dot(b-a,c-a)<EPS)return abs(c-a);\n  if(dot(a-b,c-b)<EPS)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nint main(){\n  double x[4],y[4],r;\n\n  for(;;){\n    cin >> x[0] >> y[0];\n    if(!x[0] && !y[0])break;\n\n    for(int i=1;i<4;i++)cin >> x[i] >> y[i];\n    cin >> r;\n\n    for(int i=0;i<3;i++)p[i] = Po(x[i],y[i]);\n    o = Po(x[3],y[3]);\n\n\n    bool f[3];\n    for(int i=0;i<3;i++)f[i] = !(abs(o-p[i])>r);\n    if(f[0] && f[1] && f[2])cout << \"b\\n\";\n    else{\n      if(inter(p[0],p[1],p[2],o)){\n\tfor(int i=0;i<3;i++)f[i] = !(seg_dis(p[i],p[(i+1)%3],o)<r);\n\tif(f[0] && f[1] && f[2])cout << \"a\\n\";\n\telse cout << \"c\\n\";\n      }else{\n\tfor(int i=0;i<3;i++)f[i] = !(seg_dis(p[i],p[(i+1)%3],o)>r);\n\tif(f[0] || f[1] || f[2])cout << \"c\\n\";\n\telse cout << \"d\\n\";\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define EPS (1e-10)\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(0,0),double r=0):p(p),r(r){}\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistancePP(Point p1,Point p2)\n{\n  return sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));\n}\n\nbool isTriangleInCircle(vector<Point> &p,Circle c)\n{\n  double d1,d2,d3;\n  d1 = getDistancePP(p[0],c.p);\n  d2 = getDistancePP(p[1],c.p);\n  d3 = getDistancePP(p[2],c.p);\n  return d1 <= c.r && d2 <= c.r && d3 <= c.r;\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isPointInCircle(vector<Point> &p,Circle c)\n{\n  return (ccw(p[0],p[1],c.p) == CLOCKWISE && ccw(p[1],p[2],c.p) == CLOCKWISE && ccw(p[2],p[0],c.p) == CLOCKWISE) || (ccw(p[0],p[1],c.p) == COUNTER_CLOCKWISE && ccw(p[1],p[2],c.p) == COUNTER_CLOCKWISE && ccw(p[2],p[0],c.p) == COUNTER_CLOCKWISE);\n}\n\nbool isCircleInPoint(vector<Point> &p,Circle c)\n{\n  double dist[3];\n  dist[0] = getDistanceSP(Segment(p[0],p[1]),c.p);\n  dist[1] = getDistanceSP(Segment(p[1],p[2]),c.p);\n  dist[2] = getDistanceSP(Segment(p[2],p[0]),c.p);  \n  return isPointInCircle(p,c) && dist[0] >= c.r && dist[1] >= c.r && dist[2] >= c.r; \n}\n\nvoid printP(Point p)\n{\n  cout << p.x << \" x \" << p.y << endl; \n}\n\nint main()\n{\n  vector<Point> T(3);\n  while(cin >> T[0].x >> T[0].y,(int)T[0].x|(int)T[0].y)\n    {\n      for(int i=1;i<=2;i++)\n\tcin >> T[i].x >> T[i].y;     \n      Circle c;\n      cin >> c.p.x >> c.p.y;\n      cin >> c.r;\n\n      double dist[3];\n      dist[0] = getDistanceSP(Segment(T[0],T[1]),c.p);\n      dist[1] = getDistanceSP(Segment(T[1],T[2]),c.p);\n      dist[2] = getDistanceSP(Segment(T[2],T[0]),c.p);  \n\n      if(isTriangleInCircle(T,c))\n\tcout << 'b' << endl;\n      else if(isCircleInPoint(T,c))\n\tcout << 'a' << endl;\n      else if(dist[0] <= c.r || dist[1] <= c.r || dist[2] <= c.r)\n\tcout << 'c' << endl;\n      else \n\tcout << 'd' << endl;      \n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#define PI 3.141592653589\nusing namespace std;\n \ndouble x[3],y[3],rx,ry,r;\n \nint trgin() {\n    int i,k;\n    double a,b,c,d=0;\n    for (i=0; i<3; i++) {\n     k=(i+1) % 3;\n     a=sqrt((x[i]-x[k])*(x[i]-x[k])+(y[i]-y[k])*(y[i]-y[k]));\n     b=sqrt((x[i]-rx)*(x[i]-rx)+(y[i]-ry)*(y[i]-ry));\n     c=sqrt((x[k]-rx)*(x[k]-rx)+(y[k]-ry)*(y[k]-ry));\n     d=d+acos((b*b+c*c-a*a)/(2*b*c));\n    }\n    if ((d-PI*2)<0.000001 && (d-PI*2)>-0.000001) return 1;\n    return 0;\n}\nint line(double x1,double y1,double x2,double y2) {\n    double x,y,m,d;\n    if (y1==y2) { x=rx;y=y1;} else if (x1==x2) { x=x1;y=ry;}\n    else {\n    m=(y2-y1)/(x2-x1);\n    x=(ry-y1+m*x1+rx/m)/(m+1/m);\n    y=y1+m*(x-x1);\n    }\n    if (((x>=x1 && x<=x2) || (x>=x2 && x<=x1)) && ((y>=y1 && y<=y2) || (y>=y2 && y<=y1))){\n    d=(rx-x)*(rx-x)+(ry-y)*(ry-y);\n    if (d==r*r) return 1; else if (d<r*r) return 2;\n    }\n    return 0;\n}\nint main() {\n    int i,j,k,f;\n    while(true) {\n        for (i=0;i<3;i++) {\n        cin >> x[i] >> y[i];\n        if (x[i]==0) break;\n    }\n    if (i!=3) break;\n    cin >> rx >> ry >> r;\n    for (i=0,f=0;i<3;i++) if ((x[i]-rx)*(x[i]-rx)+(y[i]-ry)*(y[i]-ry)<=r*r) f++;\n    if (f==3) { cout << 'b' << endl; continue;} else if (f>0) { cout << 'c' << endl; continue;} \n    for (i=0,f=0,k=0;i<3;i++) {\n        j=line(x[i],y[i],x[(i+1) % 3],y[(i+1) % 3]); k+=j;\n        if (j>1) break;\n    }\n    if (i==3) if (trgin()==1) { cout << 'a' << endl; continue;} else if (k==0) {cout << 'd' << endl; continue;}\n    cout << 'c' << endl;\n    }\nreturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\t// require complex func\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n// deq notes ½Êô½É¨¯éxNgZ http://www.deqnotes.net/acmicpc/2d_geometry/\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// àÏ (dot product) : a&#8901;b = |a||b|cosÆ\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ (cross product) : a~b = |a||b|sinÆ\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\nstruct T{\n\tP tp[3];\n};\nstruct C{\n\tP cp;\n\tdouble r;\n};\n\n// ~ÌSªOp`ÉÜÜêé\nbool is_cpint (T t, C c )\n{\n\tvector <double> res (3, 0.0 );\n\trep (i, 3 ){\n\t\tP A = t.tp[i], B = t.tp[(i+1) % 3], C = c.cp;\n\t\tres[i] = cross (B-A, C-A );\n\t} // end rep\n\tint plus = 0;\n\trep (i, 3 ){\n\t\tif (res[i] > 0. || abs (res[i] ) < EPS ){\n \t\t\tplus++;\n\t\t} // end if\n\t} // end rep\n\n\treturn (plus == 3 || plus == 0 );\n}\n\n// ~ªOp`ÉÜÜêé\nint is_cint (T t, C c )\n{\n\tif (!is_cpint (t, c ) )\n\t\treturn 0;\n\n\tint res = 0;\n\trep (i, 3 ){\n\t\tP A = t.tp[i], B = t.tp[(i+1) % 3], C = c.cp;\n\t\tdouble d = distance_ls_p (A, B, C );\n\t\tif ( d > c.r || abs (d - c.r ) < EPS )\n\t\t\tres++;\n\t} // end rep\n\n\treturn res;\n}\n\n// Op`ª~ÉÜÜêéê\nint is_tinc (T t, C c )\n{\n\tint res = 0;\n\trep (i, 3 ){\n\t\tdouble d = abs (t.tp[i] - c.cp );\n\t\tif ( d < c.r || abs (d - c.r ) < EPS )\n\t\t\tres++;\n\t} // end rep\n\t\n\treturn res;\n}\n\n// ~ªüªÆð··é\nbool is_intersect (T t, C c )\n{\n\trep (i, 3 ){\n\t\tP A = t.tp[i], B = t.tp[(i+1) % 3], C = c.cp;\n\t\tdouble d = distance_ls_p (A, B, C );\n\t\tif ( d < c.r || abs (d - c.r ) < EPS )\n\t\t\treturn true;\n\t} // end rep\n\n\treturn false;\t\n}\n\nint main()\n{\n\tT t;\n\tC c;\n\twhile (cin >> t.tp[0].real() >> t.tp[0].imag() && t.tp[0].real() != 0.0 && t.tp[0].imag() != 0.0 ){\n\t\tfor (int i = 1; i < 3; i++ )\n\t\t\tcin >> t.tp[i].real() >> t.tp[i].imag();\n\t\tcin >> c.cp.real() >> c.cp.imag() >> c.r;\n\n\t\tint cint = is_cint (t, c );\n\t\tint tinc = is_tinc (t, c );\n\t\tif (cint == 3 ){\t// ~ªOp`ÉÜÜêé\t\n\t\t\tcout << 'a' << endl;\n\t\t}else \t\n\t\tif (tinc == 3 ){\t// Op`ª~ÉÜÜêé\n\t\t\tcout << 'b' << endl;\n\t\t}else if (cint > 0 || tinc > 0 || is_intersect (t, c ) ){\n\t\t\tcout << 'c' << endl;\n\t\t}else{\n\t\t\tcout << 'd' << endl;\n\t\t} // end if\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef complex<double> P; \ntypedef vector<P> G;\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b){\n        push_back(a);\n        push_back(b);\n    }\n    L(){}\n};\n\nstruct C{\n    P p;\n    double r;\n    C(const P &p, double r) : p(p), r(r) { }\n    C(){}\n};\n\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n#define curr(G, i) G[i]\n#define next(G, i) G[(i+1)%G.size()]\nenum { OUT, ON, IN };\nint contains(const G &g, const P &p) {\n    bool in = false;\n    for (int i = 0; i < g.size(); ++i) {\n        P a = curr(g,i) - p, b = next(g,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\nint main(){\n    int tmpx, tmpy,r;\n    while(cin >> tmpx >> tmpy){\n        if((tmpx | tmpy) == 0) break;\n        G v(3);\n        L *e = new L[3];\n        C c;\n        v[0] = P(tmpx, tmpy);\n        cin >> tmpx >> tmpy;\n        v[1] = P(tmpx, tmpy);\n        cin >> tmpx >> tmpy;\n        v[2] = P(tmpx, tmpy);\n        e[0] = L(v[0],v[1]);\n        e[1] = L(v[0],v[2]);\n        e[2] = L(v[1],v[2]);\n        cin >> tmpx >> tmpy >> r;\n        c = C(P(tmpx,tmpy), r);\n        //a:T contains C\n        bool isA = true;\n        for(int i=0;i<3;i++){\n            //for all edges\n            if(distanceSP(e[i], c.p) < r){\n                isA = false;\n            }\n        }\n        if(isA && contains(v, c.p) == IN){\n            cout << \"a\" << endl;\n            continue;\n        }\n        //b:C contains T\n        bool isB = true;\n        for(int i=0;i<3;i++){\n            //for all vertex\n            if(abs(v[i] - c.p) > r){\n                isB = false;\n            }\n        }\n        if(isB){\n            cout << \"b\" << endl;\n            continue;\n        }\n        bool isC = false;\n        for(int i=0;i<3;i++){\n            if(distanceSP(e[i]. c.p) <= r){\n                isC = true;\n            }\n        }\n        if(isC){\n            cout << \"c\" << endl;\n        }else{\n            cout << \"d\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\ntypedef complex<double> P;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//-1 ???????????????\n//0 ??\\??????\n//1 ???????????§????????????\n//2 ???????????§????????????\nint intersectSC(const L &s, const C &c) {\n  int ins = 0;\n  for(int i = 0; i < 2; i++ ) {\n    if (abs(s[i]-c.p)<c.r) ins++;\n    else if (EQ(abs(s[i]-c.p), c.r)) return 0;\n  }\n  if (ins == 2) return -1;\n  if (ins == 1) return 1;\n  double d = distanceLP(s, c.p);\n  if (d-c.r > EPS) return -1;\n  P nor=(s[0]-s[1]) * P(0, 1);\n  if (ccw(c.p, c.p+nor, s[0]) * ccw(c.p, c.p+nor, s[1]) < 0) return 2;\n  return -1;\n}\n\nenum { OUT, ON, IN };\nint contains(const vector<P> &g, const P &p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool inputP(P &p){\n  int x, y; cin >>x >>y;\n  p = P(x, y);\n  if(x == 0 && y == 0) return false;\n  return true;\n}\n\nchar solve(vector<P> &t, P c, int r){\n    double d[3];\n    REP(i, 3) d[i] = abs(c - t[i]);\n    if(d[0] >= r && d[1] >= r && d[2] >= r && contains(t, c) == IN) return 'a';\n    if(d[0] <= r && d[1] <= r && d[2] <= r) return 'b';\n    REP(i, 3) if(intersectSC(L(t[i], next(t, i)), C(c, r)) > -1) return 'c';\n    return 'd';\n}\n\nint main(){\n  vector<P> t(3);\n  P c;\n  int r;\n  while(inputP(t[0])){\n    FOR(i, 1, 3) inputP(t[i]);\n    inputP(c); cin >>r;\n    cout <<solve(t, c, r) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3, p; long double r; Segment l1, l2, l3;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> p.px >> p.py >> r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, p) <= r && dst(p2, p) <= r && dst(p3, p) <= r) printf(\"b\\n\");\n\t\telse if(dst(l1, p) >= r && dst(l2, p) >= r && dst(l3, p) >= r) printf(contain({p1, p2, p3}, p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\nusing namespace std;\nusing D = double;\nusing P = complex<D>;\nusing L = pair<P,P>;\nusing Poly = vector<P>;\n\nconst D EPS = 1e-8;\n\n#define X real()\n#define Y imag()\n\nD dot(const P &A, const P &B){ return A.X*B.X + A.Y*B.Y; }\nD cross(const P &A, const P &B){ return A.X*B.Y - A.Y*B.X; }\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b,c) > EPS) return +1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)-EPS) return -2;\n  return 0;\n}\n\nD ps_dist(P a, L s){\n  P sf = s.first, ss = s.second;\n  if(dot(ss-sf,a-sf) >= 0 and dot(sf-ss,a-ss) >= 0)\n    return abs(cross(sf-ss,a-ss))/abs(sf-ss);\n  return min(abs(a-sf),abs(a-ss));\n}\n\n\nint in_poly(P a, const Poly &p){\n  int n = p.size(), c = 0;\n  for(int i = 0; i< n; ++i){\n    P s = p[i] -a, t = p[(i+1)%n] - a;\n    if(!ccw(s,t,P(0,0))) return 1;\n    if(s.Y > t.Y+EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if (c%2) return 2;\n  return 0;\n}\n\n\nint main(){\n  int x, y;\n  while(cin >> x >> y){\n    if(x == 0 and y == 0) break;\n    vector<P> V;\n    V.emplace_back(x,y);\n    for(int i =0 ; i < 2; ++i){\n      cin >> x >> y;\n      V.emplace_back(x,y);\n    }\n    cin >> x >> y;\n    P c(x,y);\n    D r;\n    cin >> r;\n    int a = 0, b = 0, e = 0;\n    for(int i = 0; i < 3; ++i){\n      if(abs(c-V[i]) < r + EPS) ++a;\n      if(ps_dist(c,L(V[i],V[(i+1)%3])) < r + EPS) ++b;\n      if(ps_dist(c,L(V[i],V[(i+1)%3])) < r - EPS) ++e;\n    }\n    if(a == 3){\n      puts(\"b\");\n      continue;\n    }\n    int k = in_poly(c,V);\n    if(!k){\n      if(a > 0 or b > 0) puts(\"c\");\n      else puts(\"d\");\n      continue;\n    }\n    if(a > 0 or e > 0) puts(\"c\");\n    else puts(\"a\");\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tP dir()const {return SELF[1] - SELF[0];}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-SELF[0], dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - SELF[0])) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tBOOL online(const P &p){\n\t\t\tif(!sig(abs(p - SELF[0])) || !sig(abs(p - SELF[1]))) return BORDER;\n\t\t\treturn !sig(abs(SELF[0]-p) + abs(SELF[1] - p) - abs(SELF[0] - SELF[1]));\n\t\t}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-SELF[0],  dir()) < EPS) return abs(p - SELF[0]);\n\t\t\tif(inp(p-SELF[1], -dir()) < EPS) return abs(p - SELF[1]);\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tBOOL inside(const P& p)const { return !sig(abs(p-SELF) - r) ? BORDER : abs(p-SELF) < r - EPS;}\n\t\tfriend inline BOOL cc_intersect(const C &a, const C &b){\n\t\t\tif(!sig(abs(a-b) - (a.r+b.r) || !sig(abs(a-b) - abs(a.r - b.r)))) return BORDER;\n\t\t\treturn abs(a-b)<a.r+b.r && abs(a-b)>abs(a.r - b.r);\n\t\t}\n\t\tfriend inline int cl_intersect(const C &c, const L &l){\n\t\t\treturn less(l.distance(c), c.r);\n\t\t}\n\t\tfriend inline int cs_intersect(const C &c, const S &s){\n\t\t\tif(c.inside(s[0]) != FALSE && c.inside(s[1]) != FALSE) return c.inside(s[0]) | c.inside(s[1]);\n\t\t\treturn less(s.distance(c), c.r);\n\t\t}\n\t};\n\t\n\tstruct G : public vector<P>{\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\t\n\t\tBOOL contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return FALSE;\n\t\t\tR sum = .0;\n\t\t\tint res = TRUE;\n\t\t\tREP(i, size()){\n\t\t\t\tif(c.inside(at(i)) == TRUE || cs_intersect(c, edge(i)) == TRUE) return FALSE;\n\t\t\t\telse res |= c.inside(at(i)) | cs_intersect(c, edge(i));\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t};\n#undef SELF\n#undef at\n};\nusing namespace geom;\n\nint n;\n\nchar check(const C& c, const G &g){\n\tif(g.contains(c)) return 'a';\n\tint f = 1;\n\tREP(i, 3) if(!c.inside(g[i])) f = 0;\n\tif(f) return 'b';\n\tREP(i, 3) if(cs_intersect(c, g.edge(i))) return 'c';\n\treturn 'd';\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tG g;\n\t\tC c;\n\t\tREP(i, 3){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\tif(p.X == 0) return 0;\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcin >> c;\n\t\tcout << check(c, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nbool contain(const polygon& p, const point& a) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(abs(p[i] - a) < EPS)\n\t\t\treturn true;\n\n\tvector<point> points;\n\tpoints.push_back(a);\n\n\tconst segment seg(point(0, a.y), point(10001, a.y));\n\tfor(int i = 0; i < p.size(); ++i) {\n\t\tsegment edge(p[i], p[(i + 1 + p.size()) % p.size()]);\n\t\tif(intersect(seg, edge))\n\t\t\tpoints.push_back(crosspoint(seg, edge));\n\t}\n\n\tif(points.size() < 3)\n\t\treturn false;\n\n\tsort(points.begin(), points.end());\n\n\treturn points[1] == a;\n}\n\nbool contain(const circle& c, const polygon& p) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(c.c, p[i]) > c.r + EPS)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool contain(const polygon& p, const circle& c) {\n\tif(!contain(p, c.c))\n\t\treturn false;\n\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(segment(p[i], p[(i + 1 + p.size()) % p.size()]), c.c) < c.r - EPS)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool intersect(const polygon& p, const circle& c) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(segment(p[i], p[(i + 1 + p.size()) % p.size()]), c.c) < c.r - EPS)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y; cin >> x >> y, x;) {\n\t\tpolygon triangle;\n\t\ttriangle.push_back(point(x, y));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y;\n\t\t\ttriangle.push_back(point(x, y));\n\t\t}\n\n\t\tint r;\n\t\tcin >> x >> y >> r;\n\t\tcircle c(point(x, y), r);\n\n\t\tif(contain(c, triangle))\n\t\t\tcout << 'b' << endl;\n\n\t\telse if(contain(triangle, c))\n\t\t\tcout << 'a' << endl;\n\n\t\telse if(intersect(triangle, c))\n\t\t\tcout << 'c' << endl;\n\n\t\telse\n\t\t\tcout << 'd' << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef long double Double;\ntypedef complex<Double> P;\n#define Y imag()\n#define X real()\nconst Double EPS = (long double) 1 * 1e-12;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nDouble get(P a[3]){\n\tDouble A = abs(a[0]-a[1]);\n\tDouble B = abs(a[1]-a[2]);\n\tDouble C = abs(a[2]-a[0]);\n\tDouble s = (A+B+C) / 2.0;\n\tDouble S = sqrt( s * (s-A) * (s-B) * (s-C) );\n\treturn S;\n}\nDouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \nDouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {Double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nDouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;Double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tDouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\tbool in = abs(S) < EPS;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) <= r || getPedal(L(a[1],a[2]),c) <= r || getPedal(L(a[0],a[2]),c) <= r;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) < r*r && nijo(a[1]-c) < r*r && nijo(a[2]-c) < r*r) cout << \"b\" << endl;\n\t\telse if(in && !hit) cout << \"a\" << endl;\n\t\telse if(hit) cout << \"c\" << endl;\n\t\telse cout << \"d\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\n\nint main(){\n\tdouble x,y;\n\twhile(cin>>x>>y,x+y){\n\t\tG q(3);\n\t\tq[0]=P(x,y);\n\t\tPIN(&q[1],2);\n\t\tG p=convex_hull(q);\n\t\tC c=CIN();\n\t\tbool h=true;\n\t\trep(i,3)if(c.r<EPS+abs(p[i]-c.c))h=false;\n\t\tif(h){cout<<\"b\"<<endl;continue;}\n\t\th=false;\n\t\trep(i,3)if(intersectCL(c,L(p[i],p[(i+1)%3])))h=true;\n\t\tif(h){cout<<\"c\"<<endl;continue;}\n\t\th=true;\n\t\trep(i,3)if(ccw(p[i],p[(i+1)%3],c.c)==-1)h=false;\n\t\tif(h)cout<<\"a\"<<endl;\n\t\telse cout<<\"d\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 0.0;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source().ccw(s.target(), source()) * s.source().ccw(s.target(), target()) <= EPS;\n    bool b = source().ccw(target(), s.source()) * source().ccw(target(), s.target()) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点がすべての円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) == ABOVE) ++ccw;\n        if(e.ccw(circle.center()) == UNDER) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n\nstruct Pos{\n\tdouble x,y;\n\tPos(double x,double y) : x(x) , y(y) {}\n\tPos(){}\n};\n\nstruct Triangle{\n\tPos pos[3];\n};\nstruct Circle{\n\tPos pos;\n\tdouble r;\n};\n\nstatic const double kyuriEPS = 1e-9;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n\tmyL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n\nbool intersectSP(const myL &s, const myPoint &p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const myL &s, const myPoint &p) {\n\tconst myPoint r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n\tint counter = 0 , ctt = 0;\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tif( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) < c.r - kyuriEPS ){\n\t\t\tctt++;\n\t\t}\n\t}\n\tif( ctt == 3 ) return 1;\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tdouble dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n\t\tif( dist <= c.r + kyuriEPS){\n\t\t\tcounter++;\n\t\t}\n\t}\n\tif( counter >= 1 ) return 2;\n\t\n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs((t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x));\n\t}\n\tif( fabs( fabs(area) - tS2 ) < kyuriEPS ) return 0;  \n\telse return 3;\n}\n\nint main(){\n\tTriangle t;\n\tCircle c;\n\twhile(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n\t\tfor(int i = 1 ; i < 3 ; i++)\n\t\t\tcin >> t.pos[i].x >> t.pos[i].y;\n\t\tcin >> c.pos.x >> c.pos.y >> c.r;\n\t\tcout << (char)('a'+judgeHit(c,t)) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-6\ntypedef complex<double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble dist(const P& a, const P& b)\n{\n\treturn sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nbool isIntoC(const P& p, const C& c)\n{\n\treturn dist(p, c.p) < c.r+EPS;\n}\n\nbool isIntoC(const L& l, const C& c)\n{\n\treturn dist(l[0], c.p) < c.r+EPS && dist(l[1], c.p) < c.r+EPS;\n}\n\nint CrossPtNum(const C& c, const L& l)\n{\n\tP LV=l[0]-l[1];\n\tdouble A=(LV.real()*LV.real())+(LV.imag()*LV.imag());\n\tdouble B=(LV.real()*l[0].real())-(LV.real()*c.p.real())+(LV.imag()*l[0].imag())-(LV.imag()*c.p.imag());\n\tdouble C=(l[0].real()-c.p.real())*(l[0].real()-c.p.real())+(l[0].imag()-c.p.imag())*(l[0].imag()-c.p.imag())-(c.r*c.r);\n\n\tif(fabs(B*B-A*C) < EPS) return 1;\n\tif(B*B-A*C  > 0) return 2;\n\t\n\treturn 0;\n}\n\nbool intersectSC(const L& l, const C& c)\n{\n\tif(isIntoC(l, c)) return false;\n\t\n\tdouble vc=dot(l[1]-l[0], c.p-l[0]);\n\tif(vc<0)\n\t{\n\t\tdouble dif=c.r-dist(l[0], c.p);\n\t\treturn dif+EPS > 0;\n\t}\n\t\n\tdouble vv=dot(l[1]-l[0], l[1]-l[0]);\n\t\n\tif(vc > vv)\n\t{\n\t\tdouble d=dist(l[1], c.p);\n\t\tdouble dif=c.r*c.r-d*d;\n\t\t\n\t\treturn dif+EPS > 0;\n\t}\n\t\n\tdouble cc=dot(c.p-l[0], c.p-l[0]);\n\tdouble dif=c.r*c.r-(cc-(vc/vv)*vc);\n\t\n\treturn dif+EPS > 0;\n}\n\nint main()\n{\n\tint x,y,r;\n\twhile(scanf(\"%d%d\", &x, &y), (x||y))\n\t{\n\t\tvector<P> tri;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\ttri.push_back(P(x,y));\n\t\t\tif(i==2) break;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t}\n\t\n\t\tscanf(\"%d%d%d\", &x,&y,&r);\n\t\tC c(P(x,y), r);\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\tif(!isIntoC(tri[i], c))\n\t\t\t{\n\t\t\t\tg=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(g) \n\t\t{\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\t\tint cr[3];\n\t\tcr[0]=cross(tri[0]-tri[1], tri[0]-c.p);\n\t\tcr[1]=cross(tri[1]-tri[2], tri[1]-c.p);\n\t\tcr[2]=cross(tri[2]-tri[0], tri[2]-c.p);\n\t\t\n\t\tg=true;\n\t\tif(cr[0]<EPS&&cr[1]<EPS&&cr[2]<EPS||cr[0]+EPS>0&&cr[1]+EPS>0&&cr[2]+EPS>0)\n\t\t{\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t{\n\t\t\t\tif(CrossPtNum(c, L(tri[i], tri[(i+1)%3])) == 2) g=false;\n\t\t\t}\n\t\t\tif(g) \n\t\t\t{\n\t\t\t\tputs(\"a\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int i=0; i<tri.size(); i++)\n\t\tfor(int j=i+1; j<tri.size(); j++)\n\t\t{\n\t\t\tif(intersectSC(L(tri[i], tri[j]), c))\tg=true;\n\t\t}\n\t\tif(g)\n\t\t{\n\t\t\tputs(\"c\");\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\t\n\t\tputs(\"d\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P p, const P q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P p, const P q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& p_, double r_) : p(p_), r(r_) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\tif(nm == 0.0) return min(distP2P(p, l[0]), distP2P(p, l[1]));\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0.0 && d1 * d2 > 0.0 && d2 * d0 > 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(3);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL l1(tr[1], tr[2]);\n\tL l2(tr[2], tr[0]);\n\td[0] = distP2LS(cc.p, l0);\n\td[1] = distP2LS(cc.p, l1);\n\td[2] = distP2LS(cc.p, l2);\n\tif(in && d[0] >= cc.r && d[1] >= cc.r && d[2] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect ?\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tP p = P(x, y);\n\t\tcc = C(p, r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return fabs(source().distance(p) + target().distance(p) - target().distance(source())) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + (v1.dot(v2) / v2.norm()) * v2);\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n//     int edgesOutOfCircle = 0;\n//     for(auto& e: edge) {\n//         if(circle.center().distance(e) - circle.r() > EPS) ++edgesOutOfCircle;\n//     }\n//     if(edgesOutOfCircle != 3) return \"c\";\n    for(auto& e: edge) if(circle.center().distance(e) - circle.r() <= EPS) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) >= 0) ++ccw;\n        if(e.ccw(circle.center()) <= 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& p_, double r_) : p(p_), r(r_) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0.0 && d1 * d2 > 0.0 && d2 * d0 > 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(3);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL r0(tr[1], tr[0]);\n\tL l1(tr[1], tr[2]);\n\tL r1(tr[2], tr[1]);\n\tL l2(tr[2], tr[0]);\n\tL r2(tr[0], tr[2]);\n\td[0] = max(distP2LS(cc.p, l0), distP2LS(cc.p, r0));\n\td[1] = max(distP2LS(cc.p, l1), distP2LS(cc.p, r1));\n\td[2] = max(distP2LS(cc.p, l2), distP2LS(cc.p, r2));\n\tif(in && d[0] >= cc.r && d[1] >= cc.r && d[2] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect ?\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 0;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nD dis(P a,P b){\n\treturn sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\ndouble x1,x2,x3,y4,y2,y3,x,y,r;\nmain(){\n\twhile(cin>>x1>>y4,x1||y4){\n\t\tcin>>x2>>y2>>x3>>y3>>x>>y>>r;\n\t\tvector<P>v;\n\t\tv.push_back(P(x1,y4));\n\t\tv.push_back(P(x2,y2));\n\t\tv.push_back(P(x3,y3));\n\t\tsort(v.begin(),v.end());\n\t\tif(inConvex(P(x,y),v)&&dis(P(x1,y4),P(x,y))>r&&dis(P(x2,y2),P(x,y))>r&&dis(P(x3,y3),P(x,y))>r)cout<<'a'<<endl;\n\t\telse if(dis(P(x1,y4),P(x,y))<r&&dis(P(x2,y2),P(x,y))<r&&dis(P(x3,y3),P(x,y))<r)cout<<'b'<<endl;\n\t\telse if(distSP(P(x1,y4),P(x2,y2),P(x,y))<=r||distSP(P(x3,y3),P(x2,y2),P(x,y))<=r||distSP(P(x1,y4),P(x3,y3),P(x,y))<=r)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-c,ar=d-a;\n\tP bb=b-a,br=d-b;\n\tP cc=c-b,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tcin>>r;\n\t\t// cout<<r<<endl;\n\t\tif(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(t<r){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(r>=abs(z[0]-z[3])||r>=abs(z[1]-z[3])||r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse cout<<\"d\\n\";\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define EPS 1e-10\n\nusing namespace std;\n\nstruct Point \n{\n    double x, y;\n    Point(double x=0, double y=0) : x(x), y(y) {}\n    \n\tdouble distance (const Point &o) const \n\t{\n        return sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));\n    }\n\n    Point operator+(const Point &o) const \n\t{\n        return Point(x+o.x, y+o.y);\n    }\n \n    Point operator-(const Point &o) const \n\t{\n        return Point(x-o.x, y-o.y);\n    }\n \t\n    Point operator*(const double m) const \n\t{\n   \t   return Point(x*m, y*m);\n    }\n\n    Point operator/(const double d) const \n\t{\n       return Point(x/d, y/d);\n    }\n\n    double cross(const Point &o) const \n\t{\n       return x * o.y - y * o.x;\n    }\n \n    double dot(const Point &o) const \n\t{\n        return x * o.x + y * o.y;\n    }\n \n    double atan() const \n\t{\n        return atan2(y, x);\n    }\n\n    double norm() const \n\t{\n        return sqrt(dot(*this));\n    }\n\n\tdouble area_abs(const Point &a,const Point &b) const\n\t{\n\t\tdouble t = (a.x - x) * (b.y - y);\n\t\tdouble t2 = (a.y - y) * (b.x - x);\n\t\tdouble areas = abs(t-t2);\n\t\treturn areas/2;\n\t}\n\n\t//符号付き面積\n\tdouble area(const Point &a,const Point &b)\n\t{\n\t\treturn ((a.x - x) * (b.y - y)) + ((b.x - x) * (y - a.y));\n\t}\n\t//線分abが自身の含まれているのかどうか判断する\n\tint between(const Point &a,const Point &b)\n\t{\n\t\tif(area(a,b) != 0) return 0;\n\n\t\tif(a.x != b.x)\n\t\t{\n\t\t\treturn ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));\n\t\t}\n\t}\n\n\tdouble distance_seg(const Point& a,const Point& b)\n\t{\n\t\tif((b-a).dot(*this-a) < EPS) \n\t\t{\n\t\t\treturn (*this-a).norm();\n\t\t}\n\t\tif((a-b).dot(*this-b) < EPS)\n\t\t{\n\t\t\treturn (*this-b).norm();\n\t\t}\n\t\treturn abs((b-a).cross(*this-a)) / (b-a).norm();\n\t}\n\n\t//点a,b,cからなる三角形の中に自身が含まれているかどうか\n\tbool hitPolygon(const Point& a,const Point& b,const Point& c)\n\t{\n\t\tdouble t = (b-a).cross(*this-b);\n\t\tdouble t2 = (c-b).cross(*this-c);\n\t\tdouble t3 = (a-c).cross(*this-a);\n\t\t\n\t\tif((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n};\n\nint main()\n{\n\tdouble a,b;\n\twhile(cin >> a >> b)\n\t{\n\t\tif(a == 0 && b == 0) break;\n\t\t\n\t\tvector<Point> t;\n\t\tt.push_back(Point(a,b));\n\n\t\trep(i,2)\n\t\t{\n\t\t\tcin >> a >> b;\n\t\t\tt.push_back(Point(a,b));\n\t\t}\n\n\t\tdouble r;\n\t\tcin >> a >> b >> r;\n\t\tPoint c(a,b);\n\n\t\tint cnt = 0;\n\n\t\trep(i,3)\n\t\t{\n\t\t\tif(t[i].distance(c) >= r)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tif(cnt == 0) cout << \"b\" << endl;\n\t\telse if(cnt == 1 || cnt == 2) cout << \"c\" << endl;\n\t\telse\n\t\t{\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tif(c.distance_seg(t[0],t[1]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[1],t[2]) < r) flag = true;\n\t\t\tif(c.distance_seg(t[2],t[0]) < r) flag = true;\n\t\t\t\n\t\t\tif(flag) cout << \"c\" << endl;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(c.hitPolygon(t[0],t[1],t[2]))\n\t\t\t\t{\n\t\t\t\t\tcout << \"a\" << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbool flag2 = false;\n\n\t\t\t\t\tif(c.distance_seg(t[0],t[1]) == r) flag2 = true;\n\t\t\t\t\tif(c.distance_seg(t[1],t[2]) == r) flag2 = true;\n\t\t\t\t\tif(c.distance_seg(t[2],t[0]) == r) flag2 = true;\n\n\t\t\t\t\tif(flag2) cout << \"c\" << endl;\n\t\t\t\t\telse cout << \"d\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\ntypedef complex<double> P;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//-1 ???????????????\n//0 ??\\??????\n//1 ???????????§????????????\n//2 ???????????§????????????\nint intersectSC(const L &s, const C &c) {\n  int ins = 0;\n  for(int i = 0; i < 2; i++ ) {\n    if (abs(s[i]-c.p)<c.r) ins++;\n    else if (EQ(abs(s[i]-c.p), c.r)) return 0;\n  }\n  if (ins == 2) return -1;\n  if (ins == 1) return 1;\n  double d = distanceLP(s, c.p);\n  if (d-c.r > EPS) return -1;\n  P nor=(s[0]-s[1]) * P(0, 1);\n  if (ccw(c.p, c.p+nor, s[0]) * ccw(c.p, c.p+nor, s[1]) < 0) return 2;\n  return -1;\n}\n\nenum { OUT, ON, IN };\nint contains(const vector<P> &g, const P &p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool inputP(P &p){\n  int x, y; cin >>x >>y;\n  p = P(x, y);\n  if(x == 0 && y == 0) return false;\n  return true;\n}\n\nchar solve(vector<P> &t, P c, int r){\n    double d[3];\n    REP(i, 3) d[i] = abs(c - t[i]);\n    if(d[0] >= r && d[1] >= r && d[2] >= r && contains(t, c) == IN && intersectSC(L(t[0], t[1]), C(c, r)) < 1 && intersectSC(L(t[1], t[2]), C(c, r)) < 1 && intersectSC(L(t[2], t[0]), C(c, r)) < 1) return 'a';\n    if(d[0] <= r && d[1] <= r && d[2] <= r) return 'b';\n    REP(i, 3) if(intersectSC(L(t[i], next(t, i)), C(c, r)) > -1) return 'c';\n    return 'd';\n}\n\nint main(){\n  vector<P> t(3);\n  P c;\n  int r;\n  while(inputP(t[0])){\n    FOR(i, 1, 3) inputP(t[i]);\n    inputP(c); cin >>r;\n    cout <<solve(t, c, r) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\n\n// 誤差を加味した符号判定\nint sign(double a){\n  if(a > EPS) return +1;\n  if(a < -EPS) return -1;\n  return 0;\n}\n\n// 誤差を加味した同一判定\nbool equal(double a, double b){ \n  return abs(b - a) < EPS;\n}\nbool operator==(const Point& a, const Point& b){\n  return equal(a.real(), b.real()) && equal(a.imag(), b.imag());\n}\n\n// 比較演算子\nnamespace std{\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n// 内積・外積\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\n// 点の回転\nPoint rotate(Point a, double b){\n  return a * polar(1.0, b);\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上(またはb == c)\n}\n\ntypedef vector<Point> Polygon;\n\n// Polygonの要素へのアクセス\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n// 点が多角形のどこにあるのか判定する\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p){\n  // 点pから半直線をひき、辺と交差する回数を数える\n  bool in = false;\n  REP(i, P.size()){\n    Point a = curr(P, i) - p;\n    Point b = next(P, i) - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    // aからbの直線がy=0と交わり、その交点は原点の右側である\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0){ \n      in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// 多角形の面積\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\nstruct Circle : Point {\n  double r;\n  Circle() {}\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\n\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  // 円の中心と点の距離が、円の半径以下である\n  return sign(abs(c - p) - c.r) <= 0;\n}\n\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n  double e = abs(c - d);\n  return sign(e - (c.r + d.r)) <= 0 && sign(e - abs(c.r - d.r)) >= 0;\n}\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\n\n// 注意: 端点で交わったり重なったりする場合も交差していると判定する(?)\n\n// 二直線の平行判定\nbool paralell(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n// 直線と線分の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n  // 直線lについて、線分sの端点が異なる側にある\n  return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  // 直線lとl[0]からpへの直線が平行\n  return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + 2.0 * (projection(l, p) - p);\n}\n\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  // pからlに下ろした垂線の長さ\n  return abs(p - projection(l, p));\n}\n\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  // 平行でないときは0, 平行のときは垂線の長さ\n  return paralell(l, m) ? distanceLP(l, m[0]) : 0;\n}\n\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return abs(r - p); // 垂線が線分に交わるとき\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double A = cross(l.vector(), m.vector());\n  double B = cross(l.vector(), l[1] - m[0]);\n  if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n  if(sign(A) == 0) assert(false); // 直線が交わらない\n  return m[0] + m.vector() * B / A;\n}\n\nstring solve(Polygon t, Circle C){\n  bool is_b = true;\n  REP(i, 3) if(!intersectCP(C, t[i])) is_b = false;\n  if(is_b) return \"b\";\n\n  REP(i, 3) if(sign(distanceSP(Line(t[i], t[(i + 1) % 3]), C) - C.r) <= 0) return \"c\";\n\n  if(contains(t, C) == IN)  return \"a\";\n  else return \"d\";\n}\nint main(){\n  while(true){\n    Polygon t;\n    REP(i, 3) {\n      double x, y; cin >> x >> y;\n      t.push_back(Point(x, y));\n    }\n    Circle C;\n    cin >> C.real() >> C.imag() >> C.r;\n    if(cin.eof()) break;\n    cout << solve(t, C) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ONLINE_JUDGE\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n#define repf(i, f, l) for(int i = f; i < (int)l; ++i)\n\n#ifdef ONLINE_JUDGE\n#define DEBUG false\n#else\n#define DEBUG true\n#endif\n\n#define pb emplace_back\n#define lb lower_bound\n#define ul unsigned long\n#define ull unsigned long long\n#define ll long long\n#define INF 1000000007\n#define MOD 1000000007\n#define fs first\n#define sd second\n\n#define ALL(c) (c).begin(),(c).end()\n\n#define DBG0(x)    {if(DEBUG){ cout << #x << \": \" << x << \"\\t\"; }}\n#define DBG(x)     {if(DEBUG){DBG0(x); cout << endl;}}\n#define DBG2(x, y) {if(DEBUG){DBG0(x); DBG(y);}}\n#define DBG3(x, y, z) {if(DEBUG){DBG0(x); DBG2(y, z);}}\n#define DBG4(w, x, y, z) {if(DEBUG){DBG0(w); DBG3(x, y, z);}}\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> xs){ for(T x: xs) os << x << ' '; return os; }\ntemplate <class S, class T>\nostream& operator<<(ostream& os, pair<S,T> st){ os << \"(\" << st.first << \",\" << st.second <<\")\"; return os; }\n\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<ul> vul;\ntypedef vector<ull> vull;\ntypedef vector<bool> vbl;\ntypedef pair<int, int> pii;\n\n/* Library starts here */\nconst double EPS = 1.0e-14;\ntypedef complex<double> Point;\n/* Line is represented as (a, b, c) of ax + by + c = 0 */\ntypedef tuple<double, double, double> Line;\n/* Circle is represented as ((a, b), r) of (x - a)^2 + (y - b)^2 = r^2 */\ntypedef tuple<Point, double> Circle;\n/* Line segment is represented as (P1, P2) */\ntypedef tuple<Point, Point> Line_segment;\n\nconst Point O(0.0,0.0);\n\nistream& operator>>(istream& is, Point &pt){\n    double a, b;\n    is >> a >> b;\n    pt.real(a); pt.imag(b);\n    return is;\n}\n\nostream& operator<<(ostream& os, const Point &pt){\n    os << make_pair(pt.real(), pt.imag());\n    return os;\n}\n\nostream& operator<<(ostream& os, const Line &l){\n    os << \"(\" << get<0>(l) << \",\" << get<1>(l) << \",\" << get<2>(l) << \")\";\n    return os;\n}\n\ninline double cross(const Point &a, const Point &b){\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\ninline double myarg(Point &a){\n    double ret = arg(a);\n    return (ret >= 0 ? ret : ret + 2*M_PI);\n}\n\ninline double signed_area(const Point &a, const Point &b, const Point &c){\n    Point ab = b - a;\n    Point ac = c - a;\n    return cross(ab, ac) / 2.0;\n}\n\ninline bool intersect(const Point &a1, const Point &a2, const Point &b1, const Point &b2) {\n  return ((cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS) &&\n          (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS));\n}\n\nvoid sort_by_arg(vector<Point> &pts){\n    sort(pts.begin(), pts.end(), [](Point a, Point b){ return (myarg(a) < myarg(b)); });\n}\n\n/* bad */\ndouble area(vector<Point> &vs){\n    int n = vs.size();\n    vector<Point> pts(n - 1);\n    rep(i, n - 1) pts[i] = vs[i + 1] - vs[0];\n    sort_by_arg(pts);\n    double ans = 0.0;\n    rep(i, n - 1) ans += cross(vs[i], vs[i + 1]);\n    return ans / 2.0;\n}\n\ninline Line make_line(const Point &a, const Point &b){\n    return make_tuple(a.imag() - b.imag() , b.real() - a.real(), -(a.imag() * b.real() - a.real() * b.imag()));\n}\n\ninline Line orthogonal_line(const Point &p, const Line &l){\n    return make_tuple(get<1>(l), -get<0>(l), get<0>(l) * p.imag() - get<1>(l) * p.real());\n}\n\ninline bool is_parallel(const Line &l0, const Line &l1){\n    return ((get<0>(l0)*get<1>(l1) - get<1>(l0)*get<0>(l1)) == 0.0);\n}\n\ninline Point intersection_point(const Line &l0, const Line &l1){\n    const double A = get<0>(l0);\n    const double B = get<1>(l0);\n    const double C = get<0>(l1);\n    const double D = get<1>(l1);\n    const double U = get<2>(l0);\n    const double V = get<2>(l1);\n    const double det = A*D - B*C;\n    return Point((-D*U + B*V) / det,\n                 ( U*C - A*V) / det);\n}\n\ninline Point rotate(const Point &p, const double theta){\n    double ct = cos(theta);\n    double st = sin(theta);\n    return Point(ct * p.real() - st*p.imag(), st*p.real() + ct*p.imag());\n}\n\n/* whether polygon is_included p. It is considered true if p is on the edge. */\n/* this function has not been validated */\nbool is_included(const Point &p, const vector<Point> &polygon){\n    int n = polygon.size();\n    int zero = 0;\n    int plus = 0;\n    rep(i, n){\n        const int di = (i + 1 == n ? 0 : i + 1);\n        double tmp = cross(polygon[di] - polygon[i], p - polygon[i]);\n        if(abs(tmp) <= 1e-14) zero++;\n        else if(tmp > 0.0) plus++;\n    }\n    if(zero || plus == 0 || plus == n) return true;\n    return false;\n}\n\ninline bool is_included(const Point &P, const Line &L){\n    return (P.real() * get<0>(L) + P.imag() * get<1>(L) + get<2>(L) == 0.0);\n}\n\nbool is_included(const Point &P, const Line_segment &AB){\n    Line LAB = make_line(get<0>(AB), get<1>(AB));\n    if(!is_included(P, LAB)) return false;\n    Point VAB = (get<1>(AB) - get<0>(AB));\n    Point VAP = (get<1>(AB) - P);\n    if(abs(VAP) == 0.0) return true;\n    if(VAB / abs(VAB) != VAP / abs(VAP)) return false;\n    return (abs(VAP) <= abs(VAB));\n}\n\n/* this function has not been validated */\ninline bool is_included(const Point &p, const Circle &cir){\n    return (abs(p - get<0>(cir)) <= get<1>(cir));\n}\n\n/* this function has not been validated */\ndouble distance(const Point &P, const Line &L){\n    return abs(P.real()*get<0>(L) + P.imag()*get<1>(L) + get<2>(L)) / abs(P);\n}\n\n/* distance between a point P and line segment AB */\ndouble distance(const Point &P, const Line_segment &AB){\n    Line LAB = make_line(get<0>(AB), get<1>(AB));\n    Line orth = orthogonal_line(P, LAB);\n    Point S = intersection_point(orth, LAB);\n    if(is_included(P, AB)) return abs(P - S);\n    return min(abs(P - get<0>(AB)), abs(P - get<1>(AB)));\n}\n\n/* End of the Library */\nint main(void){\n    while(true){\n        Point A, B, C, P;\n        double R;\n        cin >> A;\n        if(A.real() == 0 && A.imag() == 0) return 0;\n        cin >> B >> C >> P >> R;\n        Circle V(P, R);\n        DBG3(A, B, C);\n        DBG2(P, R);\n\n        double P_AB, P_BC, P_CA;\n        P_AB = distance(P, Line_segment(A, B));\n        P_BC = distance(P, Line_segment(B, C));\n        P_CA = distance(P, Line_segment(C, A));\n        double mn = min({P_AB, P_BC, P_CA});\n        DBG3(P_AB, P_BC, P_CA);\n\n        { /* Whether the circle is included by the triangle */\n            bool flg = true;\n            vector<Point> poly;\n            poly.pb(A); poly.pb(B); poly.pb(C);\n            flg &= is_included(P, poly);\n            flg &= (R <= mn);\n            if(flg){\n                cout << 'a' << endl;\n                continue;\n            }\n        }\n\n        { /* Whether the triangle is included by the circle */\n            bool flg = true;\n            flg &= is_included(A, V);\n            flg &= is_included(B, V);\n            flg &= is_included(C, V);\n            if(flg){\n                cout << 'b' << endl;\n                continue;\n            }\n        }\n\n        { /* They have no intersection */\n            if(R <= mn){\n                cout << 'd' << endl;\n                continue;\n            }\n        }\n        cout << 'c' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n    if(rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS * len) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\n//多角形の面積\ntemplate<class T>\nT area(const vector<point<T> >& v){\n\tT ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S,const point<T> &p){ return sqrt(dist2(S,p)); }\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ntemplate<class T>\ndouble geodist(point<T> a,point<T> b,const circle<T> &C){\n\tdouble r=C.r;\n\tsegment<T> s(a,b);\n\tif(dist(s,C.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=C.c;\n\tb-=C.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntemplate<class T>\nstd::istream& operator>>(std::istream& is, point<T>& point){return ( is >> point.x >> point.y );}\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n\n//円の接点\nvector<P> GetContact(const P& p,const P& q,const double r){\n\tP a = p-q;\n\tdouble s = SQ(a.x) + SQ(a.y);\n\tdouble D = sqrt(s - SQ(r));\n\tdouble dx = r * D * a.y / s;\n\tdouble dy = r * D * a.x / s;\n\tdouble bx = SQ(r) * a.x / s;\n\tdouble by = SQ(r) * a.y / s;\n\tvector<P> ans(2);\n\tans[0].x = bx + dx;\n\tans[0].y = by - dy;\n\tans[1].x = bx - dx;\n\tans[1].y = by + dy;\n\n\tans[0] += q;\n\tans[1] += q;\n\n\treturn ans;\n}\n\n//todo : verifyしてないので、そのうち。\n// 円が交差しているか 「=」は問によって変更する\ntemplate<class T>\nint CircleCross(const circle<T> &c1,const circle<T> &c2){\n\tdouble l = abs(c1.c - c2.c);\n\tif(l >= c1.r + c2.r) return 3; //外部にある\n\tif(l + c1.r <= c2.r) return 2; //c1 ⊃ c2\n\tif(l + c2.r <= c1.r) return 1; //c1 ⊂ c2\n\treturn 0; //交差している\n}\n\n\ntypedef pair<P,P> PD;\n//円同士の交点\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\n\n//三角形の中にあるか\nbool InTri(const P p[3],const P& o){\n\treturn \n\t\t(ccw(p[0],p[1],p[2]) == ccw(p[0],p[1],o)) &&\n\t\t(ccw(p[1],p[2],p[0]) == ccw(p[1],p[2],o)) &&\n\t\t(ccw(p[2],p[0],p[1]) == ccw(p[2],p[0],o));\n}\n\n\nint main(){\n\tP p[3];\n\tC c;\n\twhile(cin>>p[0],p[0].x != 0 || p[0].y != 0){\n\t\tcin>>p[1]>>p[2];\n\t\tcin>>c.c>>c.r;\n\n\t\tbool ok = true;\n\t\tFOR(i,3){\n\t\t\tif(abs(p[i]-c.c) + EPS > c.r) ok = false;\n\t\t}\n\n\t\t//in-circle\n\t\tif(ok){ puts(\"b\"); continue; }\n\n\t\tok = true;\n\n\t\tFOR(i,3){\n\t\t\tdouble l = dist2(S(p[i],p[(i+1)%3]),c.c);\n\t\t\tif(l < c.r * c.r) ok = true;\n\t\t}\n\n\t\t//intersect\n\t\tif(ok){ puts(\"c\"); continue; }\n\n\t\tif(InTri(p,c.c))\n\t\t\tputs(\"a\"); //in-triangle\n\t\telse\n\t\t\tputs(\"d\"); //otherwise\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n#include <complex>\ntypedef complex<double> Point;\n\n// 誤差を加味した符号判定\nint sign(double a){\n  if(a > EPS) return +1;\n  if(a < -EPS) return -1;\n  return 0;\n}\n\n// 誤差を加味した同一判定\nbool equal(double a, double b){ \n  return abs(b - a) < EPS;\n}\nbool operator==(const Point& a, const Point& b){\n  return equal(a.real(), b.real()) && equal(a.imag(), b.imag());\n}\n\n// 比較演算子\nnamespace std{\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\n// 内積・外積\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\n// 点の回転\nPoint rotate(Point a, double b){\n  return a * polar(1.0, b);\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (norm(b) < norm(c)) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上(またはb == c)\n}\n\ntypedef vector<Point> Polygon;\n\n// Polygonの要素へのアクセス\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n// 点が多角形のどこにあるのか判定する\nenum { OUT, ON, IN };\nint contains(const Polygon& P, const Point& p){\n  // 点pから半直線をひき、辺と交差する回数を数える\n  bool in = false;\n  REP(i, P.size()){\n    Point a = curr(P, i) - p;\n    Point b = next(P, i) - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    // aからbの直線がy=0と交わり、その交点は原点の右側である\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0){ \n      in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n// 多角形の面積\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\nstruct Circle : Point {\n  double r;\n  Circle() {}\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\n\n// 円と点の交差判定(EPS注意)\nbool containCP(const Circle& c, const Point& p){\n  // 円の中心と点の距離が、円の半径以下である\n  return sign(abs(c - p) - c.r) <= 0;\n}\n\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  // 円の中心同士の距離が、半径の和以下であり、半径の差以上である\n  double e = abs(c - d);\n  return sign(e - (c.r + d.r)) <= 0 && sign(e - abs(c.r - d.r)) >= 0;\n}\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\n\n// 注意: 端点で交わったり重なったりする場合も交差していると判定する(?)\n\n// 二直線の平行判定\nbool paralell(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m.vector())) == 0;\n}\n\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  return sign(cross(l.vector(), m[0] - l[0])) == 0;\n}\n\n// 直線と線分の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n  // 直線lについて、線分sの端点が異なる側にある\n  return sign(cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0])) <= 0;\n}\n\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  // 直線lとl[0]からpへの直線が平行\n  return sign(cross(l.vector(), p - l[0])) == 0;\n}\n\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / norm(l.vector());\n  return l[0] + t * l.vector();\n}\n\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + 2.0 * (projection(l, p) - p);\n}\n\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  // pからlに下ろした垂線の長さ\n  return abs(p - projection(l, p));\n}\n\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  // 平行でないときは0, 平行のときは垂線の長さ\n  return paralell(l, m) ? distanceLP(l, m[0]) : 0;\n}\n\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return abs(r - p); // 垂線が線分に交わるとき\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double A = cross(l.vector(), m.vector());\n  double B = cross(l.vector(), l[1] - m[0]);\n  if(sign(A) == 0 && sign(B) == 0) return m[0]; // 二直線が重なっている\n  if(sign(A) == 0) assert(false); // 直線が交わらない\n  return m[0] + m.vector() * B / A;\n}\n\nstring solve(Polygon t, Circle C){\n  bool is_b = true;\n  REP(i, 3) if(!containCP(C, t[i])) is_b = false;\n  if(is_b) return \"b\";\n\n  if(contains(t, C) == IN){\n    REP(i, 3) if(sign(distanceSP(Line(t[i], t[(i + 1) % 3]), C) - C.r) < 0) return \"c\";\n    return \"a\";\n  }else{\n    REP(i, 3) if(sign(distanceSP(Line(t[i], t[(i + 1) % 3]), C) - C.r) <= 0) return \"c\";\n    return \"d\";\n  }\n}\nint main(){\n  while(true){\n    Polygon t;\n    REP(i, 3) {\n      double x, y; cin >> x >> y;\n      t.push_back(Point(x, y));\n    }\n    Circle C;\n    cin >> C.real() >> C.imag() >> C.r;\n    if(cin.eof()) break;\n    cout << solve(t, C) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P p;double r;};    //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)       {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n// ?????¨??????????????????\nint contains(C c, P p){ //verified QUPC-G\n    double d = (c.p-p).abs();\n    if(d-c.r>EPS) return OUT;\n    if(abs(d-c.r)<EPS) return ON;\n    return IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n    if( dLP(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(L s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, L l){\n    int c1 = contains(c, l.p1);\n    int c2 = contains(c, l.p2);\n    if(c1 > c2) swap(c1, c2);\n    \n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (??\\????????¨???)\n    double d = dSP(l, c.p);\n    if(d-c.r<-EPS) return true;\n    if(d-c.r>EPS) return false;\n    return true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nbool isPointInsidePolygon(vector<P> pol,P p){\n    int c=0;\n    rep(i,pol.size()){\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n    }\n    return !(c%pol.size());\n}\n\n//?????¨???????§???¢???????????¶??????????????? verified AOJ0153\nint CPOLarea(C c ,Polygon pol){\n    vector<L> lines;\n    vector<int> res(pol.size());\n    bool POLinC=true, isFar=true;\n    \n    rep(i,pol.size()){\n        res[i] = contains(c,pol[i]);\n        if(sqDist(c.p,pol[i])-c.r*c.r<-EPS)isFar=false;\n        lines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n    }\n    rep(i,res.size()) if( res[i]==OUT )POLinC=false;\n    \n    if( POLinC )                                    return 2;   //????§???¢??????????????¨\n    rep(i,lines.size()) if( iCS(c,lines[i]) )       return 1;   //????§???¢??¨????????????\n    if( isPointInsidePolygon(pol, c.p) && isFar )   return 3;   //????§???¢????????¨??????\n    return 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps),cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????????????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int tx,ty;\n    while(cin>>tx>>ty&&(tx||ty)){\n        Polygon pol(3);\n        C c;\n        pol[0] = P(tx,ty);\n        rep(i,2)cin>>pol[i+1].x>>pol[i+1].y;\n        cin>>c.p.x>>c.p.y>>c.r;\n        \n        int res = CPOLarea(c,pol);\n        cout<<(char)('a'+(3-res))<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-3;\nconst double PI = acos(-1.0);\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\n// 点クラス\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// 加算, 減算, スカラー倍\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// 比較演算子\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n// 原点からの距離(絶対値)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// ノルム\ndouble norm(const P& z){\n\treturn z.x * z.x + z.y * z.y;\n}\n\ndouble x[4], y[4], r;\n\ndouble D(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\n// 直線クラス\nstruct Line : public vector<P> {\n\tLine(){}\n\tLine(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\n\n// 線分 s 上に点 p があるかどうか\nbool intersectSP(const Line& s, const P& p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\nP projection(const Line& l, const P& p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[0] - l[1]) * t;\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const P& p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n\tdouble law_of_cos(double a, double b, double c) {\n\t\treturn acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n\t}\n\t// 点 a , b を端点とする線分に点 c が含まれているかどうか\n\tbool contain(P a, P b, P c) {\n\t\treturn abs(a - c) + abs(b - c) - abs(b - a) < EPS;\n\t}\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n\t// 3 つの辺の長さ\n\tdouble edgeA, edgeB, edgeC;\n\t// 3 つの角の角度 (ラジアン)\n\tdouble angleA,angleB,angleC;\n\t// コンストラクタで初期化\n\tTriangle(P p1, P p2, P p3) {\n\t\ta = p1; b = p2; c = p3;\n\t\tedgeB = abs(c-a);\n\t\tedgeA = abs(b-c);\n\t\tedgeC = abs(a-b);\n\t\tangleA = law_of_cos( edgeA, edgeB, edgeC );\n\t\tangleB = law_of_cos( edgeB, edgeC, edgeA );\n\t\tangleC = law_of_cos( edgeC, edgeA, edgeB );\n\t}\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\treturn contain(a, b, p) || contain(b, c, p) || contain(c, a, p);\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0 * PI );\n\t}\n};\n\nbool in_circle(){\n\tbool res = true;\n\tfor(int i = 0 ; i <= 2 ; i++ ){\n\t\tres &= (D(x[i], y[i], x[3], y[3]) < r + EPS);\n\t}\n\treturn res;\n}\n\nbool in_triangle(){\n\tTriangle t(P(x[0], y[0]), P(x[1], y[1]), P(x[2], y[2]));\n\treturn t.is_inside(P(x[3], y[3]));\n}\n\nbool intersect(){\n\tLine s1(P(x[0], y[0]), P(x[1], y[1]));\n\tLine s2(P(x[1], y[1]), P(x[2], y[2]));\n\tLine s3(P(x[2], y[2]), P(x[0], y[0]));\n\tP p(x[3], y[3]);\n\t\n\tif( distanceSP(s1, p) < r + EPS ) return true;\n\tif( distanceSP(s2, p) < r + EPS ) return true;\n\tif( distanceSP(s3, p) < r + EPS ) return true;\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> x[0] >> y[0], x[0] || y[0] ){\n\t\tcin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n\t\t\n\t\tif( in_circle() ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( intersect() ){\n\t\t\tcout << \"c\" << endl;\n\t\t}else if( in_triangle() ){\n\t\t\tcout << \"a\" << endl;\n\t\t}else{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint x[3], y[3], xc, yc, r, d[4];\nconst double INF = 10000000;\n\nbool in() {\n\tbool f[3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tint j = (i + 1) % 3, k = (i + 2) % 3;\n\t\tf[i] = ((x[i] - x[j]) * (yc - y[i]) - (y[i] - y[j]) * (xc - x[i])) * ((x[i] - x[j]) * (y[k] - y[i]) - (y[i] - y[j]) * (x[k] - x[i])) >= 0;\n\t}\n\n\treturn f[0] && f[1] && f[2];\n}\n\ndouble minds() {\n\tdouble g[3];\n\tfor (int i = 0; i < 3; i++) {\n\t\tint j = (i + 1) % 3;\n\n\t\tif ((x[j] - x[i]) * (xc - x[i]) + (y[j] - y[i]) * (yc - y[i]) >= 0\n\t\t\t&& (x[i] - x[j]) * (xc - x[j]) + (y[i] - y[j]) * (yc - y[j]) >= 0)\n\t\t\tg[i] = pow((y[j] - y[i]) * xc - (x[j] - x[i]) * yc - x[i] * y[j] + y[i] * x[j], 2) / (pow(y[j] - y[i], 2) + pow(x[j] - x[i], 2));\n\t\telse\n\t\t\tg[i] = INF;\n\t}\n\t\treturn min({ g[0], g[1], g[2] });\n}\n\nint main()\n{\n\tcin >> x[0] >> y[0];\n\n\twhile (x[0] != 0 || y[0] != 0) {\n\t\tfor (int i = 1; i < 3; i++)\n\t\t\tcin >> x[i] >> y[i];\n\n\t\tcin >> xc >> yc >> r;\n\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\td[i] = (int)(pow(x[i] - xc, 2) + pow(y[i] - yc, 2));\n\t\t\n\t\tint rs = r * r;\n\n\t\tif (rs >= d[0] && rs >= d[1] && rs >= d[2])\n\t\t\tcout << \"b\" << endl;\n\t\telse if (in() && minds() >= rs)\n\t\t\tcout << \"a\" << endl;\n\t\telse if (!in() && rs < d[0] && rs < d[1] && rs < d[2] && minds() > rs)\n\t\t\tcout << \"d\" << endl;\n\t\telse\n\t\t\tcout << \"c\" << endl;\n\n\t\tcin >> x[0] >> y[0];\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#define dis(p,q) ((p)*(p)+(q)*(q))\nusing namespace std;\nint lc(double bx,double by,double ex,double ey,double cx,double cy,double cr){\n  int p,q;\n  if(0){\n  }else if(dis(cx-bx,cy-by)>cr*cr){\n    p=1;\n  }else if(dis(cx-bx,cy-by)<cr*cr){\n    p=0;\n  }else{\n    p=2;\n  }\n  if(0){\n  }else if(dis(cx-ex,cy-ey)>cr*cr){\n    q=1;\n  }else if(dis(cx-ex,cy-ey)<cr*cr){\n    q=0;\n  }else{\n    q=2;\n  }\n  if(0){\n  }else if(p==0&&q==0){\n    return 1;\n  }else if((p==0&&p==1)||(p==1&&q==0)){\n    return 4;\n  }else if(p==2||q==2){\n    if(p==1||q==1)\n      return 2;\n    else\n      return 3;\n  }\n  double vx,vy,px,py,qx,qy,rx,ry,ds;\n  ds=sqrt(dis(bx-ex,by-ey));\n  vx=(ex-bx)/ds;\n  vy=(ey-by)/ds;\n  ds=((ey-by)*cx+(bx-ex)*cy+(by-ey)*bx+(ex-bx)*by)/((ey-by)*vy-(bx-ex)*vx);\n  px=cx-vy*ds;\n  py=cy+vx*ds;\n  if(0){\n  }else if(cr>ds){\n    ds=sqrt(cr*cr-ds*ds);\n    qx=px+vx*ds;\n    qy=py+vy*ds;\n    rx=px-vx*ds;\n    ry=py-vy*ds;\n    if(bx==ex){\n      if(min(by,ey)<=min(qy,ry)&&max(qy,ry)<=max(by,ey))\n\treturn 4;\n      else\n\treturn 0;\n    }else{\n      if(min(bx,ex)<=min(qx,rx)&&max(qx,rx)<=max(bx,ex))\n\treturn 4;\n      else\n\treturn 0;\n    }\n  }else if(cr==ds){\n    if(bx==ex){\n      if(min(by,ey)<=py&&py<=max(by,ey))\n\treturn 2;\n      else\n\treturn 0;\n    }else{\n      if(min(bx,ex)<=px&&px<=max(bx,ex))\n\treturn 2;\n      else\n\treturn 0;\n    }\n  }\n  return 0;\n}\nint pt(double px,double py,double qx,double qy,double rx,double ry,double sx,double sy){\n  if(((rx-qx)*(py-qy)-(px-qx)*(ry-qy)<=0&&(sx-rx)*(py-ry)-(px-rx)*(sy-ry)<=0&&(qx-sx)*(py-sy)-(px-sx)*(qy-sy)<=0)||\n     ((rx-qx)*(py-qy)-(px-qx)*(ry-qy)>=0&&(sx-rx)*(py-ry)-(px-rx)*(sy-ry)>=0&&(qx-sx)*(py-sy)-(px-sx)*(qy-sy)>=0))\n    return 1;\n  return 0;\n}\nint main(){\n  int i;\n  int x[4],y[4],r;\n  while(cin>>x[0]>>y[0]&&(x[0]||y[0])){\n    for(i=1;i<4;i++)\n      cin>>x[i]>>y[i];\n    cin>>r;\n    for(i=0;i<3;i++){\n      if(lc(x[i],y[i],x[(i+1)%3],y[(i+1)%3],x[3],y[3],r)==4)\n\tbreak;\n    }\n    if(i==3){\n      for(i=0;i<3;i++){\n\tif(dis(x[i]-x[3],y[i]-y[3])>r*r)\n\t  break;\n      }\n      if(i==3){\n\tcout<<\"b\"<<endl;\n      }else{\n\tif(pt(x[3],y[3],x[0],y[0],x[1],y[1],x[2],y[2])){\n\t  cout<<\"a\"<<endl;\n\t}else{\n\t  for(i=0;i<3;i++){\n\t    if((lc(x[i],y[i],x[(i+1)%3],y[(i+1)%3],x[3],y[3],r)&2)!=0)\n\t      break;\n\t  }\n\t  if(i==3)\n\t    cout<<\"d\"<<endl;\n\t  else\n\t    cout<<\"c\"<<endl;\n\t}\n      }\n    }else{\n      cout<<\"c\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//12\n#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real()+.5;\n}\n\nint dt(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag()+.5;\n}\n\nint main(){\n  for(;;){\n    int x,y;\n    P t[3],c;\n    int r;\n    for(int i=0;i<3;i++){\n      cin>>x>>y;\n      if((i|x|y)==0)return 0;\n      t[i]=P(x,y);\n    }\n    cin>>x>>y;\n    c=P(x,y);\n    cin>>r;\n    if(abs(t[0]-c)<=r&&abs(t[1]-c)<=r&&abs(t[2]-c)<=r){\n      cout<<'b'<<endl;\n    }else{\n      double d[3];\n      bool f[2]={};\n      for(int i=0;i<3;i++){\n\tP l=t[(i+1)%3]-t[i];\n\tif(dt(l,c-t[i])>0&&dt(-l,c-t[(i+1)%3])>0){\n\t  d[i]=fabs(cr(l,c-t[i])/abs(l));\n\t}else{\n\t  d[i]=min(abs(c-t[i]),abs(c-t[(i+1)%3]));\n\t}\n\tf[cr(l,c-t[i])<0]=true;\n      }\n      if(f[0]^f[1]&&d[0]>=r&&d[1]>=r&&d[2]>=r){\n\tcout<<'a'<<endl;\n      }else if(d[0]<=r||d[1]<=r||d[2]<=r){\n\tcout<<'c'<<endl;\n      }else{\n\tcout<<'d'<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n\tbool operator<(const Pt &a) const { return (x != a.x) ? (x < a.x) : (y < a.y); }\n\tbool operator==(const Pt &a) const { return (sig(x - a.x) == 0 && sig(y - a.y) == 0); }\n};\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\ndouble tri(Pt a, Pt b, Pt c) { return (b - a).det(c - a); }\n\nPt proj(Pt a, Pt b) { return a * a.dot(b) / a.abs2(); }\n\nPt perp(Pt a, Pt b, Pt c) { return a + proj(b - a, c - a); }\n\nPt refl(Pt a, Pt b, Pt c) { return perp(a, b, c) * 2 - c; }\n\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\n\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\n\nbool iLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) <= 0);\n}\n\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\n\nbool iSSstrict(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) < 0 && sig(tri(c, d, a)) * sig(tri(c, d, b)) < 0);\n}\n\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c;\n\treturn a + b * (c - a).det(d) / b.det(d);\n}\n\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\n\ndouble dSP(Pt a, Pt b, Pt c) {\n\tif (sig((b - a).dot(c - a)) <= 0) return (c - a).abs();\n\tif (sig((a - b).dot(c - b)) <= 0) return (c - b).abs();\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\n\ndouble dLL(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLL(a, b, c, d) ? 0 : dLP(a, b, c);\n}\n\ndouble dLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLS(a, b, c, d) ? 0 : min(dLP(a, b, c), dLP(a, b, d));\n}\n\ndouble dSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iSS(a, b, c, d) ? 0 : min(min(dSP(a, b, c), dSP(a, b, d)), min(dSP(c, d, a), dSP(c, d, b)));\n}\n\nint iCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tif (sig(d) == 0 && sig(r - s) == 0) return -1; // correspond\n\tif (sig(r - s - d) > 0) return +2; // r > s\n\tif (sig(s - r - d) > 0) return -2; // s > r\n\treturn (sig(r + s - d) >= 0) ? 1 : 0;\n}\n\nbool iCS(Pt a, double r, Pt b, Pt c) {\n\treturn (sig(r - dSP(b, c, a)) >= 0 && sig(r - max((b - a).abs(), (c - a).abs())) <= 0);\n}\n\npair<Pt,Pt> pCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tPt e = (b - a) / d, w = e * Pt(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\treturn MP(a + e * x - w, a + e * x + w);\n}\n\npair<Pt,Pt> pCL(Pt a, double r, Pt b, Pt c) {\n\tPt h = perp(b, c, a);\n\tdouble d = (h - a).abs();\n\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\tPt e = (c - b) / (c - b).abs();\n\treturn MP(h - e * y, h + e * y);\n}\n/*\npair<Pt,Pt> tCP(Pt a, double r, Pt b) {\n\tdouble d2 = (b - a).norm();\n\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\tPt h = a + (b - a) * (r * r / d2);\n\tPt w = (b - a) * Pt(0, 1) * (x * r / d2);\n\treturn MP(h - w, h + w);\n}\n*/\ndouble aCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (a - b).abs();\n\tif (sig(r - s - d) >= 0) return s * s * PI;\n\tif (sig(s - r - d) >= 0) return r * r * PI;\n\tif (sig(r + s - d) <= 0) return 0;\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tdouble h = sqrt(r * r - x * x);\n\treturn r * r * atan2(h, x) + s * s * atan2(h, d - x) - d * h;\n}\n\nint convexhull(int n, Pt p[], Pt q[]) {\n\tint m = 0, i, r;\n\tsort(p, p + n);\n\tfor (i = 0; i < n; q[m++] = p[i++]) for (; m > 1 && sig(tri(q[m - 2], q[m - 1], p[i])) <= 0; --m);\n\tfor (i = n - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(tri(q[m - 2], q[m - 1], p[i])) <= 0; --m);\n\treturn m - 1;\n}\n\nint convexcut(int n, Pt p[], Pt a, Pt b, Pt q[]) {\n\tint m = 0, i;\n\tp[n] = p[0];\n\tfor (i = 0; i < n; ++i) {\n\t\tif (sig(tri(a, b, p[i])) >= 0) q[m++] = p[i];\n\t\tif (sig(tri(a, b, p[i])) * sig(tri(a, b, p[i + 1])) < 0) q[m++] = pLL(a, b, p[i], p[i + 1]);\n\t}\n\tq[m] = q[0];\n\treturn m;\n}\n\nint sGP(int n, Pt p[], Pt a) {\n\tint side = -1, i;\n\tp[n] = p[0];\n\tfor (i = 0; i < n; ++i) {\n\t\tPt p0 = p[i] - a, p1 = p[i + 1] - a;\n\t\tif (sig(p0.det(p1)) == 0 && sig(p0.dot(p1)) <= 0) return 0;\n\t\tif (p0.y > p1.y) swap(p0, p1);\n\t\tif (sig(p0.y) <= 0 && 0 < sig(p1.y) && sig(p0.det(p1)) > 0) side = -side;\n\t}\n\treturn side;\n}\n\nint sVP(int n, Pt p[], Pt a) {\n\tPt o = (p[0] + p[n / 2]) / 2;\n\tint lo = 0, ho = n, fl = sig(tri(o, p[lo], a));\n\tp[n] = p[0];\n\tfor (; lo + 1 < ho; ) {\n\t\tint mo = (lo + ho) / 2, fm = sig(tri(o, p[mo], a));\n\t\t(fl - fm - sig(tri(o, p[lo], p[mo])) < 0) ? (lo = mo, fl = fm) : ho = mo;\n\t}\n\treturn sig(tri(p[lo], p[ho], a));\n}\n\nint sAP(Pt a, Pt b, Pt c) {\n\treturn sig(a.det(c)) - sig(b.det(c)) - sig(a.det(b));\n}\n\nconst int s_size = 1000;\nint s_a[s_size], s_b[s_size], s_ab[s_size];\n\tbool iGSstrict(int n, Pt p[], Pt a, Pt b) {\n\tint i;\n\tp[n] = p[0];\n\tp[n + 1] = p[1];\n\tif (sGP(n, p, a) > 0 || sGP(n, p, b) > 0) return 1;\n\tfor (i = 0; i <= n; ++i) {\n\t\ts_a[i] = sig(tri(p[i], p[i + 1], a));\n\t\ts_b[i] = sig(tri(p[i], p[i + 1], b));\n\t\ts_ab[i] = sig(tri(a, b, p[i]));\n\t}\n\tfor (i = 0; i < n; ++i) {\n\t\tif (s_a[i] * s_b[i] < 0 && s_ab[i] * s_ab[i + 1] < 0) return 1;\n\t}\n\tfor (i = 0; i < n; ++i) {\n\t\tif (s_a[i] == 0 && s_b[i] > 0 && sig((a - p[i]).dot(a - p[i + 1])) < 0) return 1;\n\t\tif (s_b[i] == 0 && s_a[i] > 0 && sig((b - p[i]).dot(b - p[i + 1])) < 0) return 1;\n\t}\n\tfor (i = 0; i < n; ++i) if (s_ab[i + 1] == 0 && sig((p[i + 1] - a).dot(p[i + 1] - b)) <= 0) {\n\t\tif (!(p[i + 1] == a) && sAP(p[i + 2] - p[i + 1], p[i] - p[i + 1], a - p[i + 1]) > 0) return 1;\n\t\tif (!(p[i + 1] == b) && sAP(p[i + 2] - p[i + 1], p[i] - p[i + 1], b - p[i + 1]) > 0) return 1;\n\t}\n\treturn 0;\n}\n\ndouble quartercut(double r, double x, double y) {\n\tif (x * x + y * y >= r * r) return 0;\n\tdouble xx = sqrt(r * r - y * y), yy = sqrt(r * r - x * x);\n\treturn (r * r * (atan2(yy, x) - atan2(y, xx)) - (xx - x) * y - x * (yy - y)) / 2;\n}\n\nPt circumcenter(Pt a, Pt b, Pt c) {\n\tPt bc = c - b, ca = a - c, ab = b - a;\n\treturn (b + c - bc * Pt(0, 1) * ca.dot(ab) / ca.det(ab)) / 2;\n}\n\nint main() {\n\tPt a,b,c,d;\n\tint r;\n\tIL{\n\t\tcin>>a.x>>a.y;\n\t\tif(a.x==0&&a.y==0)break;\n\t\tcin>>b.x>>b.y;\n\t\tcin>>c.x>>c.y;\n\t\tcin>>d.x>>d.y;\n\t\ta=a-d;\n\t\tb=b-d;\n\t\tc=c-d;\n\t\td.x=0;d.y=0;\n\t\tcin>>r;\n\t\tif(perp(a,b,d).abs()>=r&&perp(a,c,d).abs()>=r&&perp(b,c,d).abs()>=r&&iSP(a,b,d)==iSP(a,b,c)&&iSP(b,c,d)==iSP(b,c,a)&&iSP(c,a,d)==iSP(c,a,b)){\n\t\t\tcout<<\"a\\n\";\n\t\t}else if(a.abs()<=r&&b.abs()<=r&&c.abs()<=r){\n\t\t\tcout<<\"b\\n\";\n\t\t}else if(perp(a,b,d).abs()<=r&&perp(a,c,d).abs()<=r&&perp(b,c,d).abs()<=r){\n\t\t\tcout<<\"c\\n\";\n\t\t}else{\n\t\t\tcout<<\"d\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double EPS = 1e-6;\n\ntypedef complex<double> C;\n\ndouble ip(C a, C b){\n    return a.real() * b.real() + a.imag() * a.imag();\n}\n\ndouble op(C a, C b){\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dist_lc(C p, double a, double b, double c){\n    return abs(a * p.real() + b * p.imag() + c) / abs(p);\n}\n\nint main(){\n    C p1, p2, p3, pr;\n    double r;\n    bool flg1, flg2, flg3, flg4;\n    while(true){\n        int s, t;\n        double x1, y1, x2, y2, x3, y3, xr, yr;\n        scanf(\"%d%d\", &s, &t);\n        if(s == 0 && t == 0) break;\n        p1.real(s); p1.imag(t);\n        x1 = p1.real(); y1 = p1.imag();\n        scanf(\"%d%d\", &s, &t);\n        p2.real(s); p2.imag(t);\n        x2 = p2.real(); y2 = p2.imag();\n        scanf(\"%d%d\", &s, &t);\n        p3.real(s); p3.imag(t);\n        x3 = p3.real(); y3 = p3.imag();\n        scanf(\"%d%d\", &s, &t);\n        pr.real(s); pr.imag(t);\n        xr = s; yr = t;\n        scanf(\" %lf\", &r);\n        if(abs(p1 - pr) <= r && abs(p2 - pr) <= r && abs(p3 - pr) <= r){\n            puts(\"b\");\n            continue;\n        }\n        double a = x1 - x2, b = y1 - y2;\n        double c = x2 - x3, d = y2 - y3;\n        double e = x3 - x1, f = y3 - y1;\n        flg1 = abs(b * xr - a * yr - b * x1 + a * y1)/abs(p1-p2) >= r;\n        flg2 = abs(d * xr - c * yr - d * x2 + c * y2)/abs(p2-p3) >= r;\n        flg3 = abs(f * xr - e * yr - f * x3 + e * y3)/abs(p3-p1) >= r;\n        flg4 = op(p1-pr, p2-pr) + op(p2-pr, p3-pr) + op(p3-pr, p1-pr) > EPS;\n        if(flg1 && flg2 && flg3 && flg4){\n            puts(\"a\");\n            continue;\n        }\n        flg1 = abs(pr - p1) <= r;\n        flg2 = abs(pr - p2) <= r;\n        flg3 = abs(pr - p3) <= r;\n        if(flg1 || flg2 || flg3){\n            puts(\"c\");\n            continue;\n        }\n        flg1 = dist_lc(pr, b, -a, -b * p1.real() + a * p1.imag()) <= r &&\n               ip(p1-p2, pr-p2) >= 0 && ip(p2-p1, pr-p1) >= 0;\n        flg2 = dist_lc(pr, d, -c, -d * p2.real() + b * p2.imag()) <= r &&\n               ip(p2-p3, pr-p3) >= 0 && ip(p3-p2, pr-p2) >= 0;\n        flg3 = dist_lc(pr, f, -e, -f * p3.real() + f * p3.imag()) <= r &&\n               ip(p3-p1, pr-p1) >= 0 && ip(p1-p3, pr-p3) >= 0;\n        if(flg1 || flg2 || flg3){\n            puts(\"c\");\n            continue;\n        }\n        puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nbool contain(const polygon& p, const point& a) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(p[i] == a)\n\t\t\treturn true;\n\n\tvector<point> points;\n\tpoints.push_back(a);\n\n\tconst segment seg(point(0, a.y), point(10001, a.y));\n\tfor(int i = 0; i < p.size(); ++i) {\n\t\tconst segment edge(p[i], p[(i + 1) % p.size()]);\n\t\tif(intersect(seg, edge))\n\t\t\tpoints.push_back(crosspoint(seg, edge));\n\t}\n\n\tif(points.size() < 3)\n\t\treturn false;\n\n\tsort(points.begin(), points.end());\n\n\treturn points[1] == a;\n}\n\nbool contain(const circle& c, const polygon& p) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(c.c, p[i]) > c.r)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool contain(const polygon& p, const circle& c) {\n\tif(!contain(p, c.c))\n\t\treturn false;\n\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(segment(p[i], p[(i + 1) % p.size()]), c.c) < c.r)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool intersect(const polygon& p, const circle& c) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(segment(p[i], p[(i + 1) % p.size()]), c.c) <= c.r)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y; cin >> x >> y, x;) {\n\t\tpolygon triangle;\n\t\ttriangle.push_back(point(x, y));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y;\n\t\t\ttriangle.push_back(point(x, y));\n\t\t}\n\n\t\tint r;\n\t\tcin >> x >> y >> r;\n\t\tcircle c(point(x, y), r);\n\n\t\tif(contain(c, triangle))\n\t\t\tcout << 'b' << endl;\n\n\t\telse if(contain(triangle, c))\n\t\t\tcout << 'a' << endl;\n\n\t\telse if(intersect(triangle, c))\n\t\t\tcout << 'c' << endl;\n\n\t\telse\n\t\t\tcout << 'd' << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<sstream>\n#include<functional>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define REP(i,s,e) for(int i=int(s);i<int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nusing namespace std;\n\nbool f(double x,double y,double x0,double y0,double x4,double y4,double r){\ndouble p=(x0-x)*(y0-y4)-(x0-x4)*(y0-y);\ndouble q=(y0-y)*(y0-y)+(x0-x)*(x0-x);\nif(x-x0!=0 && y-y0!=0){\nif(abs(p)/sqrt(q)<=r && (-p*(y0-y)/q)>=min(x,x0) && (-p*(y0-y)/q)<=max(x,x0))\nreturn true;\nelse return false;\n}\nif(x-x0==0 && abs(x0)<=r && sqrt(r*r-x0*x0)<=max(y,y0) && -sqrt(r*r-x0*x0)>=min(y,y0))\nreturn true;\nelse return false;\nif(y-y0==0 && abs(y0)<=r && sqrt(r*r-y0*y0)<=max(x,x0) && -sqrt(r*r-y0*y0)>=min(x,x0))\nreturn true;\nelse return false;\n}\n\nbool g(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4,double r){\ndouble p=(y1-y4)/(x1-x4);\ndouble q=(y2-y3)/(x2-x3);\ndouble u=((y3-y4)-q*(x3-x4))/(p-q)-x1+x4;\ndouble v=(p*(y3-y4)-p*q*(x3-x4))/(p-q)-y1+y4;\nif((x1-x4)!=0 && (x2-x3)!=0 && (p-q)!=0 && sqrt(u*u+v*v)>sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4))+r)\nreturn true;\nelse return false;\nif((x1-x4)==0 && (x2-x3)!=0 && abs(y1-y4)+r<abs(y1-y3+q*(x3-x4)))\nreturn true;\nelse return false;\nif((x2-x3)==0 && (x1-x4)!=0 && sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4))+r<sqrt((x2-x1)*(x2-x1)+(p*x2-p*x4-y1+y4)*(p*x2-p*x4-y1+y4)))\nreturn true;\nelse return false;\n\n}\n\nint main(){\n\ndouble x1,y1,x2,y2,x3,y3,x4,y4,r;\n\nwhile(true){\n\ncin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\nif(x1==0 && y1==0) break;\n\n\ndouble a,b,c;\na=(x1-x4)*(x1-x4)+(y1-y4)*(y1-y4);\nb=(x2-x4)*(x2-x4)+(y2-y4)*(y2-y4);\nc=(x3-x4)*(x3-x4)+(y3-y4)*(y3-y4);\n\nif(a<r*r && b<r*r && c<r*r)\ncout << \"b\" << endl;\n\nif(!(a<r*r && b<r*r && c<r*r) && !(a>r*r && b>r*r && c>r*r))\ncout << \"c\" << endl;\n\n\nif(a>r*r && b>r*r && c>r*r){\n\nif(f(x1,y1,x2,y2,x4,y4,r) || f(x2,y2,x3,y3,x4,y4,r) || f(x1,y1,x3,y3,x4,y4,r))\ncout << \"c\" << endl;\n\nelse if(g(x1,y1,x2,y2,x3,y3,x4,y4,r) && g(x2,y2,x1,y1,x3,y3,x4,y4,r) && g(x3,y3,x2,y2,x1,y1,x4,y4,r))\ncout << \"a\" << endl;\n\nelse cout << \"d\" << endl;\n\n}\n\n\n}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-10;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * \nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 点座標のデバッグ出力\nvoid print(P p) {\n\tcout << \"point\" << p << \";\" << endl;\n}\n\n// * 2乗する\ndouble sq(double x) {\n\treturn x * x;\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n// * 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b) {\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a) {\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a) {\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a) {\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n// ラジアンから度数へ変換して返す\ndouble to_deg(double rad) {\n\treturn rad * 180.0 / PI;\n}\n\n// 度数からラジアンに変換して返す\ndouble to_rad(double deg) {\n\treturn deg * PI / 180.0;\n}\n\n// 原点を軸に点 p を角度 a (ラジアン)だけ回転させた点を返す\nP rot(P p, double a){\n\tdouble x = p.X * cos(a) - p.Y * sin(a);\n\tdouble y = p.X * sin(a) + p.Y * cos(a);\n\treturn P(x,y);\n}\n\n// 点 a を軸に点 b を角度 a (ラジアン)だけ回転させた点を返す\nP rot2(P a, P b, double angle){\n\tP p = b - a;\n\treturn rot( p , angle ) + a;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分の交差判定\n\tbool is_intersection(const Segment& s) {\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) &&\n\t\t\t   ( cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) < EPS );\n\t}\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( this->is_intersection( s ) ) { // 交差するとき\t\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) || this->contain(s.b) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}else if( s.contain( a ) || s.contain( b ) ) {\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\t\tdouble A = this->distance(s.a);\n\t\tdouble B = this->distance(s.b);\n\t\tdouble C = s.distance( (*this).a );\n\t\tdouble D = s.distance( (*this).b );\n\t\treturn min( min(A,B) , min(C,D) );\n\t}\n\t// 点 p を軸に 線分 を 角度 angle だけ回転移動 (角度はラジアン)\n\tSegment rot(P p, double angle) {\n\t\tP a_ = rot2( p , a , angle );\n\t\tP b_ = rot2( p , b , angle );\n\t\treturn Segment( a_ , b_ );\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n// Segment の順序を定義 (x座標の小さい端点で比較)\nbool operator < (const Segment& s1, const Segment& s2) { return s1.a < s2.a; }\n\n// 直線の表現 ((*this)[0]) と ((*this)[1]) を通る直線\nstruct Line : public vector<P> {\n\tLine(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tLine(vector<P> v){\n\t\tpush_back(v[0]); push_back(v[1]);\n\t}\n\tLine(){}\n\t// 2直線の直交判定\n\tbool orthogonal(const Line& l) {\n\t\treturn equal( dot( (*this)[0] - (*this)[1] , l[0] - l[1] ) , 0.0 );\n\t}\n\t// 2直線の平行判定\n\tbool parallel(const Line& l) {\n\t\treturn equal( cross( (*this)[0] - (*this)[1] , l[0] - l[1] ), 0.0 );\n\t}\n\t// 点 p が直線上に乗っているか\n\tbool contain(P p) {\n\t\treturn equal( cross( (*this)[1] - (*this)[0] , p - (*this)[0] ) , 0.0 );\n\t}\n\t// 直線と点 p の距離\n\tdouble distance(P a) {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\treturn abs( cross( p2 - p1 , a - p1) ) / abs(p2 - p1);\n\t}\n\t// 直線の交差判定\n\tbool is_intersection(const Line& l) {\n\t\treturn !equal( cross( (*this)[0] - (*this)[1], l[0] - l[1] ) , 0.0 );\n\t}\n\t// 直線の交差判定と交点計算\n\tbool intersection(Line l, P& p) {\n\t\tbool result = this->is_intersection( l );\n\t\tif( result ) {\n\t\t\tP a = (*this)[1] - (*this)[0];\n\t\t\tP b = l[1] - l[0];\n\t\t\tp = (*this)[0] + a * cross(b, l[0] - (*this)[0]) / cross(b, a);\n\t\t}else {\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 角度を返す [-π,π]\n\tdouble get_dir() {\n\t\tP p = (*this)[0] - (*this)[1];\n\t\treturn atan2( p.Y , p.X );\n\t}\n\t// 双対変換\n\tP dual(const Line &l) {\n\t\tconst P p = l[0], q = l[1];\n\t\treturn P( imag(p - q) / real(p - q), cross(p, q) / real(q - p) );\n\t}\n\t// 点を線対称に移動させる\n\tP symmetry(P a) {\n\t\tdouble x,y;\n\t\tdouble x1 = (*this)[0].X;\n\t\tdouble x2 = (*this)[1].X;\n\t\tdouble y1 = (*this)[0].Y;\n\t\tdouble y2 = (*this)[1].Y;\n\t\tdouble xq = a.X;\n\t\tdouble yq = a.Y;\n\t\tif( x2 == x1 ) {\n\t\t\tx = -xq;\n\t\t\ty = yq;\n\t\t}else{\n\t\t\tdouble m = (y2 - y1) / (x2 - x1);\n\t\t\tdouble c = y2 - m * x2;\n\t\t\tx = (2 * m * yq - xq * (m * m - 1) - 2 * m * c) / (m * m + 1);\n\t\t    y = (2 * m * xq + yq * (m * m - 1) + 2 * c) / (m * m + 1);\n\t\t}\n\t\treturn P(x,y);\n\t}\n\t// 点 p を軸に 直線 を 角度 angle だけ回転移動 (角度はラジアン)\n\tLine rot(P p, double angle) {\n\t\tP a = rot2( p , (*this)[0] , angle );\n\t\tP b = rot2( p , (*this)[1] , angle );\n\t\treturn Line( a , b );\n\t}\n\t// デバッグ出力\n\tvoid print() {\n\t\tP p1 = (*this)[0];\n\t\tP p2 = (*this)[1];\n\t\tdouble dx = p1.X - p2.X;\n\t\tdouble dy = p1.Y - p2.Y;\n\t\t::print( p1 );\n\t\t::print( p2 );\n\t\tp1.X += 100 * dx;\n\t\tp1.Y += 100 * dy;\n\t\tp2.X -= 100 * dx;\n\t\tp2.Y -= 100 * dy;\n\t\tSegment s( p1 , p2 );\n\t\ts.print();\n\t}\n};\n\n// 円の表現\nstruct Circle{\n\t// 円の中心\n\tP p;\n\t// 円の半径\n\tdouble r;\n\t// コンストラクタで初期化\n\tCircle(P p_, double r_) { p = p_; r = r_; }\n\t// 円の面積\n\tdouble get_area() { return r * r * PI; }\n\t// 円周\n\tdouble circumference() { return 2.0 * r * PI; }\n\t// 点 a が円の内部にあるかどうか\n\tbool is_inside(P a) { return ( dist(a,p) <= r ); }\n\t// 点 a が円周上にあるかどうか\n\tbool on_boundary(P a) { return equal( dist(a,p) , r ); }\n\t// 角度 [a,b] の弧の長さを返す (a,bはラジアン)\n\tdouble arc(double a, double b) {\n\t\twhile( a > b ) b += 2.0 * PI;\n\t\treturn r * (b - a);\n\t}\n\t// 角度 [a,b] の扇形の面積を返す (a,bはラジアン)\n\tdouble sector(double a, double b) {\n\t\twhile( a > b ) b += 2.0 * PI;\n\t\treturn 0.5 * r * r * (b - a);\n\t}\n\t// 直線と円の距離 (円の中心の点と直線の距離 - 円の半径)\n\tdouble distance(Line l){\n\t\treturn l.distance( p ) - r;\n\t}\n\t// 点 a を通る接線を返す.\n\tpair<Line,Line> tangent(P a) {\n\t\tpair<Line,Line> pl;\n\t\tif( this->on_boundary( a ) ) { // 点 a が円周上にあるとき\n\t\t\tLine l( normal(a - p) ); // 法線ベクトル\n\t\t\tl[0] += a;\n\t\t\tl[1] += a;\n\t\t\tpl.first = pl.second = l ;\n\t\t\treturn pl;\n\t\t}else if( !this->is_inside(a) ) { // 点 a が円の外側にあるとき\n\t\t\tdouble xp = a.X - p.X;\n\t\t\tdouble yp = a.Y - p.Y;\n\t\t\tdouble A = sqrt( sq(xp) + sq(yp) - sq(r) );\n\t\t\tdouble B = sq(xp) + sq(yp);\n\t\t\tP p1( r * (xp * r + yp * A) / B , r * (yp * r - xp * A) / B );\n\t\t\tP p2( r * (xp * r - yp * A) / B , r * (yp * r + xp * A) / B );\n\t\t\tpl.first = Line( a , p1+p );\n\t\t\tpl.second = Line( a , p2+p );\n\t\t}else{ // 点 a が円の内側にあるとき\n\t\t\tpl.first = pl.second = Line(INF_P,INF_P);\n\t\t}\n\t\treturn pl;\n\t}\n\t// 等しいかどうか\n\tbool operator==(const Circle& c) { return (p == c.p && r == c.r) ; };\n\t// 2つの円の位置関係\n\t// 2 つの円が離れている => 0\n\t// 2 つの円が外接する   => 1\n\t// 2 つの円が交わる     => 2\n\t// 2 つの円が内接する    => 3 (2つの円が等しいときは内接)\n\t// 円が含まれている       => 4\n\tint is_pos(const Circle& c) {\n\t\tdouble d = abs(p - c.p);\n\t\tif( r + c.r + EPS < d ) { // 離れている\n\t\t\treturn 0;\n\t\t}else if( equal( r + c.r , d ) ) { // 外接する\n\t\t\treturn 1;\n\t\t}else if( equal( fabs(r-c.r) , d ) ) { // 内接する\n\t\t\treturn 3;\n\t\t}else if( d < fabs(r-c.r) ) { // 含まれる\n\t\t\treturn 4;\n\t\t}else { // 交わる\t\n\t\t\treturn 2;\n\t\t}\n\t}\n\t// 円と直線の交わる点を返す\n\tpair<P,P> intersection(Line l) {\n\t\tpair<P,P> pp;\n\t\tif( this->distance(l) > EPS ) { // 円と直線の交点がないとき\t\n\t\t\tpp.first = pp.second = INF_P;\n\t\t}else { // 円と直線の交点があるとき\n\t\t\tdouble d = l.distance( p );\n\t\t\tdouble angle = -l.get_dir();\n\t\t\t// 点 l[0] を軸に点 l[1] と円の中心を回転\n\t\t\tP lp = rot2( l[0] , l[1] , angle );\n\t\t\tP cp = rot2( l[0] , p    , angle );\n\t\t\tdouble x1 = cp.X - sqrt( sq(r) - sq(d) );\n\t\t\tdouble x2 = cp.X + sqrt( sq(r) - sq(d) );\n\t\t\tP p1(x1,l[0].Y);\n\t\t\tP p2(x2,l[0].Y);\n\t\t\t// 回転して元に戻す\n\t\t\tp1 = rot2( l[0] , p1 , -angle );\n\t\t\tp2 = rot2( l[0] , p2 , -angle );\n\t\t\tpp.first = p1;\n\t\t\tpp.second = p2;\n\t\t}\n\t\treturn pp;\n\t}\n\t// 2 つの円の交わる点を返す\n\t// 2 つの円が離れている・内包する => 交点は 0 個, (INF_P,INF_P) を返す.\n\t// 2 つの円が外接 or 内接する   => 交点は 1 個, (firstとsecondに同じ値が入る)\n\t// 2 つの円が交わる            => 交点は 2 個.\n\t// 2 つの円は等しい            => 交点は 無限 個, (INF_P,INF_P) を返す.\n\tpair<P,P> intersection(const Circle& c) {\n\t\tif( this->is_pos( c ) == 0 || this->is_pos( c ) == 4 || (*this) == c ) {\n\t\t\treturn pair<P,P>(INF_P,INF_P);\n\t\t}\n\t\tdouble d = abs( p - c.p );\n\t\tdouble rc = ( d*d + r*r - c.r*c.r ) / (2.0*d);\n\t\tdouble rs = sqrt( r*r - rc*rc );\n\t\tP diff = (c.p - p) / d;\n\t\treturn pair<P,P> ( p + diff * P(rc, rs) , p + diff * P(rc, -rs) );\n\t}\n\t// 2つの円の共通接線の計算に使用\n\t// (flag == true のとき内側の接線, falseのとき外側の接線)\n\tpair<P,P> common_tangent1(const Circle& c, bool flag) {\n\t\tdouble xp = c.p.X - p.X;\n\t\tdouble yp = c.p.Y - p.Y;\n\t\tdouble R = (flag)? r + c.r : r - c.r ;\n\t\tdouble A = sqrt( sq(xp) + sq(yp) - sq(R) );\n\t\tdouble B = sq(xp) + sq(yp);\n\t\tP p1( r * (xp * R + yp * A) / B , r * (yp * R - xp * A) / B );\n\t\tP p2( r * (xp * R - yp * A) / B , r * (yp * R + xp * A) / B );\n\t\tp1 += p;\n\t\tp2 += p;\n\t\treturn pair<P,P> (p1,p2);\n\t}\n\t// 2つの円の共通接線を返す\n\t// 2 つの円が離れている => 4本\n\t// 2 つの円が外接する   => 3本 (共通内接線が1つ)\n\t// 2 つの円が交わる     => 2本　(共通内接線がない)\n\t// 2 つの円が内接する    => 1本 (共通外接線が1つ)\n\t// 円が含まれている       => 0本\n\tvector<Line> common_tangent(Circle c) {\n\t\tvector<Line> vl;\n\t\tint pos = this->is_pos( c );\n\t\t// 2つの共通内接線を求める\n\t\tpair<P,P> pp1 = this->common_tangent1( c , true );\n\t\tpair<P,P> pp2 = c.common_tangent1( (*this) , true );\n\t\tif( pos == 0 ) { // 2つの円が離れているとき\n\t\t\tvl.push_back( Line( pp1.first , pp2.first ) );\n\t\t\tvl.push_back( Line( pp1.second , pp2.second ) );\n\t\t}else if( pos == 1 ) { // 外接するとき\n\t\t\tvl.push_back( this->tangent( pp1.first ).first );\n\t\t}\n\t\t// 2つの共通外接線を求める\n\t\tpp1 = this->common_tangent1( c , false );\n\t\tpp2 = c.common_tangent1( (*this) , false );\n\t\tif( pos <= 2 ) { // 2つの円が交わるとき\n\t\t\tvl.push_back( Line( pp1.first , pp2.second ) );\n\t\t\tvl.push_back( Line( pp1.second , pp2.first ) );\n\t\t}else if( pos == 3 ) { // 2つの円が内接するとき\n\t\t\tvl.push_back( this->tangent( pp1.first ).first );\n\t\t}\n\t\treturn vl;\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"circle(%f,%f,%f); \\n\", p.X, p.Y, r ); }\n};\n\n// 三角形の表現\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n    double law_of_cos(double a, double b, double c) {\n        return acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n    }\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n    // 3 つの辺の長さ\n    double edgeA, edgeB, edgeC;\n    // 3 つの角の角度 (ラジアン)\n    double angleA,angleB,angleC;\n    \n    // コンストラクタで初期化\n    Triangle(P p1, P p2, P p3) {\n        a = p1;\n        b = p2;\n        c = p3;\n        edgeB = abs(c-a);\n        edgeA = abs(b-c);\n        edgeC = abs(a-b);\n        angleA = law_of_cos( edgeA, edgeB, edgeC );\n        angleB = law_of_cos( edgeB, edgeC, edgeA );\n        angleC = law_of_cos( edgeC, edgeA, edgeB );\n    }\n    // 三角形の面積を返す (ヘロンの公式)\n\tdouble get_area() {\n\t\tdouble s = 0.5 * (edgeA + edgeB + edgeC);\n\t\treturn sqrt( s * (s - edgeA) * (s - edgeB) * (s - edgeC) );\n\t}\n    // 三角形の外接円を返す (AOJ 0010 で検証済み)\n    Circle circumscribed_circle() {\n\t\tdouble r = ( edgeA / sin(angleA) / 2.0 );\n\t\tdouble A = sin( 2.0 * angleA );\n\t\tdouble B = sin( 2.0 * angleB );\n\t\tdouble C = sin( 2.0 * angleC );\n\t\tdouble cx = ( (a.X * A + b.X * B + c.X * C) / (A+B+C) );\n\t\tdouble cy = ( (a.Y * A + b.Y * B + c.Y * C) / (A+B+C) );\n\t\tCircle cir( P(cx,cy) , r );\n\t\treturn cir;\n\t}\n\t// 三角形の内接円を返す\n\tCircle inscribed_circle() {\n\t\t// 三角形の外周の長さ\n\t\tdouble ABC = edgeA + edgeB + edgeC;\n\t\t\n\t\tdouble cx = (a.X * edgeA + b.X * edgeB + c.X * edgeC) / ABC;\n\t\tdouble cy = (a.Y * edgeA + b.Y * edgeB + c.Y * edgeC) / ABC;\n\t\tdouble r  = (2.0 * get_area()) / ABC ;\n\t\tCircle cir( P(cx,cy) , r );\n\t\treturn cir;\n\t}\n\t// 三角形の重心を返す\n\tP gravity() {\n\t\treturn P( (a.X + b.X + c.X) / 3.0 , (a.Y + b.Y + c.Y) / 3.0 );\n\t}\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\tSegment AB(a,b), BC(b,c), CA(c,a);\n\t\treturn (AB.contain( p ) || BC.contain( p ) || CA.contain( p ) );\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\t// 点 p が三角形の辺上 or 頂点上 にあるときは誤差で正しい結果が返ってこないので注意!!!\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0*PI );\n\t}\n\t// 点 p を軸に 三角形 を 角度 angle だけ回転移動 (角度はラジアン)\n\tTriangle rot(P p, double angle) {\n\t\tP a_ = rot2( p , a , angle );\n\t\tP b_ = rot2( p , b , angle );\n\t\tP c_ = rot2( p , c , angle );\n\t\treturn Triangle( a_ , b_ , c_ );\n\t}\n\t// デバッグ出力\n\tvoid print() {\n\t\tSegment AB(a,b);\n\t\tSegment BC(b,c);\n\t\tSegment CA(c,a);\n\t\tAB.print();\n\t\tBC.print();\n\t\tCA.print();\n\t}\n};\n\n\nint main(){\n\tint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile( cin >> x1 >> y1 , x1 || y1 ){\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\tTriangle t( P(x1,y1) , P(x2,y2) , P(x3,y3) );\n\t\tCircle c( P(x4,y4) , r );\n\t\t// 外接円\n\t\tCircle c1 = t.circumscribed_circle();\n\t\t// 内接円\n\t\tCircle c2 = t.inscribed_circle();\n\t\t// 交差するかどうか\n\t\tbool flag = false;\n\t\tLine l1( t.a , t.b );\n\t\tSegment s1( t.a , t.b );\n\t\tLine l2( t.b , t.c );\n\t\tSegment s2( t.b , t.c );\n\t\tLine l3( t.c , t.a );\n\t\tSegment s3( t.c , t.a );\n\t\tpair<P,P> pp = c.intersection( l1 );\n\t\tif( pp.first != INF_P && pp.first != pp.second ){\n\t\t\tP p1 = pp.first;\n\t\t\tP p2 = pp.second;\n\t\t\tif( s1.contain(p1) || s1.contain(p2) ){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tpp = c.intersection( l2 );\n\t\tif( pp.first != INF_P && pp.first != pp.second ){\n\t\t\tP p1 = pp.first;\n\t\t\tP p2 = pp.second;\n\t\t\tif( s2.contain(p1) || s2.contain(p2) ){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tpp = c.intersection( l3 );\n\t\tif( pp.first != INF_P && pp.first != pp.second ){\n\t\t\tP p1 = pp.first;\n\t\t\tP p2 = pp.second;\n\t\t\tif( s3.contain(p1) || s3.contain(p2) ){\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tif( c.is_pos(c1) >= 3 ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( c2.is_pos(c) >= 3 ){\n\t\t\tcout << \"a\" << endl;\n\t\t}else if( flag ){\n\t\t\tcout << \"c\" << endl;\n\t\t}else{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-6;\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / abs(a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < Eps)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) <Eps)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(a, b, point);\n}\nbool is_in_triangle(const Point& point, const Point* triangle)\n{\n\tdouble t[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tt[i] = cross(triangle[(i+1)%3] - triangle[i], point - triangle[i]);\n\n\treturn t[0] >= 0 && t[1] >= 0 && t[2] >= 0\n\t\t|| t[0] <= 0 && t[1] <= 0 && t[2] <= 0;\n}\nbool is_in_triangle(const Point& point, const Point& a, const Point& b, const Point& c)\n{\n\tPoint t[3] = { a, b, c };\n\treturn is_in_triangle(point, t);\n}\nbool is_circle_in_triangle(const Point& center, double radius, const Point* triangle)\n{\n\tif (!is_in_triangle(center, triangle))\n\t\treturn false;\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_line_point(triangle[i], triangle[(i+1)%3], center) < radius)\n\t\t\treturn false;\n\treturn true;\n}\nbool is_triangle_in_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (abs(triangle[i]-center) > radius)\n\t\t\treturn false;\n\treturn true;\n}\nbool interect_triangle_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_linesegment_point(center, triangle[i], triangle[(i+1)%3]) < radius - Eps)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tint x[4], y[4], r;\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tscanf(\"%d %d\", x+i, y+i);\n\t\tscanf(\"%d\", &r);\n\t\tif (x[0] == 0 && y[0] == 0)\n\t\t\tbreak;\n\t\tPoint p[4];\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tp[i] = Point(x[i], y[i]);\n\n\t\tif (is_circle_in_triangle(p[3], r, p))\n\t\t\tputs(\"a\");\n\t\telse if (is_triangle_in_circle(p, p[3], r))\n\t\t\tputs(\"b\");\n\t\telse if (interect_triangle_circle(p, p[3], r))\n\t\t\tputs(\"c\");\n\t\telse\n\t\t\tputs(\"d\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto& e:c)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); ++it)\n\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\nconst R pi = acos(-1);\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\nR dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    // A to B\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    // ax+by+c=0\n    L(R a, R b, R c){\n        if(fabs(a) < eps) *this = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) *this = L(P(-c/a,0),P(-c/a,1));\n        else *this = L(P(-c/a,0), P(0,-c/b));\n    }\n    P vec() const {\n        return (*this)[1] - (*this)[0];\n    }\n};\n\nstruct S : public vector<P> {\n    // A to B\n    S(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    L to_L() const {\n        return L((*this)[0], (*this)[1]);\n    }\n    P vec() const {\n        return to_L().vec();\n    }\n    R len() const {\n        return abs(vec());\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p = P(), R r = 0) : p(p), r(r) { }\n};\n\n// CCW\nenum { CCW = +1, CW = -1, CAB = +2, ABC = -2, SAMEPOINT = 0 };\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return CCW; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return  CW; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return CAB; // c--a--b 直線上\n    if (norm(b) < norm(c)) return ABC; // a--b--c 直線上\n    return SAMEPOINT; // 2点以上が重なっている\n}\n\n// A->C方向の角ABCの大きさを[0,2*Pi]で求める\nR arg(P a, P b, P c) {\n    R th = arg((a - b) / (c - b));\n    return th > 0 ? th : th+2*pi;\n}\n\n// 交差判定(基本的に直接呼ぶな)\nbool col(const L &l, const L &m) {\n    return\n        abs(cross(l.vec(), m.vec())) > eps || // non-parallel\n        abs(cross(l.vec(), m[0]-l[0])) < eps;   // same line\n}\n\nbool col(const L &l, const S &s) {\n    return\n        cross(l.vec(), s[0]-l[0])*       // s[0] is left of l\n        cross(l.vec(), s[1]-l[0]) < eps; // s[1] is right of l\n}\n\nbool col(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool col(const S &s, const S &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool col(const S &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nbool col(const C &c, const P &p) {\n    // 境界または内部\n    return abs(c.p - p) <= c.r + eps;\n}\n\nint col(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(abs(d - r1 - r2) < eps) return  1; // 接する\n    if(d > r1 + r2)       return  0; // 共通部分を持たない\n    if(d < r1 - r2)       return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)       return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l.vec()) / norm(l.vec());\n    return l[0] + t*(l.vec());\n}\nL proj(const L& l, const L& m) {\n    return L(proj(l,m[0]), proj(l,m[1]));\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\nL refl(const L& l, const L& m) {\n    return L(refl(l,m[0]), refl(l,m[1]));\n}\n\n// 距離\nR dist(const P &p, const P &q){\n    return abs(p - q);\n}\n\nR dist(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dist(const P& p, const L& l){\n    return dist(l,p);\n}\n\nR dist(const L &l, const L &m) {\n    return col(l, m) ? 0 : dist(l, m[0]);\n}\n\nR dist(const L &l, const S &s) {\n    if (col(l, s)) return 0;\n    return min(dist(l, s[0]), dist(l, s[1]));\n}\n\nR dist(const S& s, const L& l){\n    return dist(s,l);\n}\n\nR dist(const S &s, const P &p) {\n    const P r = proj(s.to_L(), p);\n    if (col(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dist(const P& p, const S& s){\n    return dist(s,p);\n}\n\nR dist(const S &s, const S &t) {\n    if (col(s, t)) return 0;\n    return min(min(dist(s, t[0]), dist(s, t[1])),\n               min(dist(t, s[0]), dist(t, s[1])));\n}\n\nR dist(const C &c, const P &p) {\n    return max(0. , abs(c.p - p));\n}\n\nR dist(const P& p, const C& c){\n    return dist(c,p);\n}\n\n// positive -> outside\n// zero     -> on the boundaly\n// negative -> inside\nR dist(const C& c, const L& l){\n    R d = dist(l,c.p);\n    return d - c.r;\n}\n\nR dist(const L& l, const C& c){\n    return dist(c,l);\n}\n\n// 交点\nvector<P> hit(const L &l, const L &m) {\n    R A = cross(l.vec(), m.vec());\n    R B = cross(l.vec(), l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) return {}; // parallel\n    return {m[0] + B / A * (m.vec())};\n}\n\nvector<P> hit(const S& s, const S& t) {\n    if(col(s,t)) return hit(s,t);\n    else return {};\n}\n\nvector<P> hit(const L& l, const S& s){\n    if(col(l,s)) return hit(l,s);\n    else return {};\n}\n\nvector<P> hit(const S& s, const L& l){\n    return hit(l,s);\n}\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183\n//        : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2045\nvector<P> hit(const C& c, const L& l){\n    R d = dist(l,c.p); // 中心と直線の距離\n    if(fabs(d-c.r) < eps) return { proj(l, c.p) }; // 触れている\n    if(d > c.r) return {}; // 離れている\n    P h = proj(l, c.p);\n    P u = sqrt(c.r*c.r - d*d) * (l.vec()) / abs(l.vec());\n    return {h+u, h-u};\n}\n\nvector<P> hit(const L& l, const C& c){\n    return hit(l,c);\n}\n\nvector<P> hit(const C& c, const S& s){\n    vector<P> cs = hit(c,s), res;\n    for(const P& p : cs) {\n        if(col(s,p)) res.push_back(p);\n    }\n    return res;\n}\n\nvector<P> hit(const S& s, const C& c){\n    return hit(c,s);\n}\n\nvector<P> hit(const C& c1, const C& c2){\n    int i = col(c1,c2);\n    // 共通部分なし || 内部\n    if(i==0 || abs(i)==3) return {};\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    // 接する\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d };\n    // 2つの交点を持つ\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = 2 * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return hit(c1, L(A,B,C));\n}\n\nchar solve(G t, C c){\n    if(ccw(t[0],t[1],t[2])!=CCW){\n        swap(t[0],t[1]);\n    }\n    double r = c.r;\n    P p = c.p;\n    bool CinT = true;\n    double d = inf;\n    bool TinC = true;\n    rep(i,3)CinT &= ccw(t[i],t[(i+1)%3],p)==CCW;\n    rep(i,3)TinC &= dist(p,t[i]) <= r + eps;\n    rep(i,3)d = min(d, dist(p, L(t[i],t[(i+1)%3])));\n    // cout << d << \" \" << r << endl;\n    if(TinC) return 'b';\n    if(CinT && d > r + eps) return 'a';\n    if(d < r + eps) return 'c';\n    return 'd';\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b && a){\n        G t(3);\n        t[0] = P(a,b);\n        rep(i,2){\n            int a,b;\n            cin>>a>>b;\n            t[i+1] = P(a,b);\n        }\n        int r,a,b;\n        cin>>a>>b>>r;\n        C c(P(a,b),r);\n        cout << solve(t,c) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\ntypedef complex<ll> P;\n\nint x, y, r;\nP tri[3];\npair<P,ll> circle;\n\nll cross(P e1, P e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tll d0 = cross(e0, e1);\n\tll d1 = cross(e1, e2);\n\tll d2 = cross(e2, e0);\n\tif(d0 * d1 >= 0 && d1 * d2 >= 0 && d2 * d0 >= 0) return true;\n\treturn false;\n}\n\nll norm2(P p) {\n\treturn p.real() * p.real() + p.imag() * p.imag();\n}\n\nvoid dist2(P p1, P p2, P p, ll& nm, ll& de) {\n\tll a = p2.imag() - p1.imag();\n\tll b = -(p2.real() - p1.real());\n\tll c = - a * p1.real() - b * p1.imag();\n\tnm = a * p.real() + b * p.imag() + c;\n\tnm = nm * nm;\n\tde = a * a + b * b;\n\tif(de == 0) {\n\t\tnm = norm2(p1 - p);\n\t\tde = 1;\n\t}\n}\n\n\nvoid solve() {\n\tbool iscin = inc();\n\tll r2 = circle.second * circle.second;\n\tvector<pll> d(6);\n\tdist2(tri[0], tri[1], circle.first, d[0].first, d[0].second);\n\tdist2(tri[1], tri[2], circle.first, d[1].first, d[1].second);\n\tdist2(tri[2], tri[0], circle.first, d[2].first, d[2].second);\n\tif(iscin && (d[0].first >= r2 * d[0].second) &&\n\t\t        (d[1].first >= r2 * d[1].second) &&\n\t\t        (d[2].first >= r2 * d[2].second)) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\td[3].first = norm2(tri[0] - circle.first); d[3].second = 1;\n\td[4].first = norm2(tri[1] - circle.first); d[4].second = 1;\n\td[5].first = norm2(tri[2] - circle.first); d[5].second = 1;\n\tif(d[3].first <= r2 && d[4].first <= r2 && d[5].first <= r2) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tbool inter = false;\n\trep(i,6) {\n\t\tif(d[i].first <= r2 * d[i].second) {\n\t\t\tinter = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(inter) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass Point{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  Point p[3];\n};\n\nclass Circle{\npublic:\n  Point p;\n  int radius;\n};\n\ndouble distance(Point p1, Point p2){\n  return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n\ndouble dist_line(Point pl1, Point pl2, Point p){\n  int a = pl1.x - pl2.x;\n  int b = pl2.y - pl1.y;\n  int c = pl1.y * pl2.x - pl1.x * pl2.y;\n  double ans = b * p.x + a * p.y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n//      getline(ifs, str);\n        cin >> str;\n\n      if(str == \"0 0\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\") break;\n\n\n    if(distance(d->p[0], c->p) <= c->radius&& distance(d->p[1], c->p) <= c->radius&& distance(d->p[2], c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(d->p[0], d->p[1], c->p) >= c->radius&& dist_line(d->p[0], d->p[2], c->p) >= c->radius&& dist_line(d->p[1], d->p[2], c->p) >= c->radius){\n        if (dist_line(d->p[0], d->p[1], d->p[2]) <= distance(d->p[0], c->p) && dist_line(d->p[1], d->p[2], d->p[0]) <= distance(d->p[1], c->p) && dist_line(d->p[2], d->p[0], d->p[1]) <= distance(d->p[2], c->p))\n            cout << 'd' << endl;\n        else\n            cout << 'a' << endl;\n    }\n    else if(dist_line(d->p[0], d->p[1], c->p) <= c->radius|| dist_line(d->p[0], d->p[2], c->p) <= c->radius|| dist_line(d->p[1], d->p[2], c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <sstream> \n#include <iomanip> \n#include <algorithm> \n#include <cmath> \n#include <string> \n#include <vector> \n#include <list> \n#include <queue> \n#include <stack> \n#include <set> \n#include <map> \n#include <bitset> \n#include <numeric> \n#include <climits> \n#include <cfloat> \nusing namespace std; \n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    double length2() const{\n        return y * y + x * x;\n    }\n    double dist2(const Point& p) const{\n        return (y - p.y) * (y - p.y) + (x - p.x) * (x - p.x);\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosÆ\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinÆ\n    }\n};\n\nint segmentCircleCollide(const Point& a1, const Point& a2, const Point& c, int r)\n{\n    int num = 0;\n    if(a1.dist2(c) < r * r)\n        ++ num;\n    if(a2.dist2(c) < r * r)\n        ++ num;\n    if(num == 2)\n        return -1;\n    if(num == 1)\n        return 1;\n    if((a2 - a1).dot(c - a1) > 0 && (a1 - a2).dot(c - a2) > 0){\n        int s = (a2 - a1).cross(c - a1);\n        int t = r * r * (a2 - a1).length2();\n        if(s * s == t)\n            return 1;\n        if(s * s < t)\n            return 2;\n    }\n    return 0;\n}\n\nbool convexContain(const vector<Point>& cp, const Point& p)\n{\n    int n = cp.size();\n    bool ret1 = true;\n    bool ret2 = true;\n    for(int i=0; i<n; ++i){\n        int a = (cp[(i+1)%n] - cp[i]).cross(p - cp[i]);\n        if(a < 0)\n            ret1 = false;\n        if(a > 0)\n            ret2 = false;\n    }\n    return ret1 || ret2;\n}\n\nint main()\n{\n    for(;;){\n        vector<Point> p(3);\n        for(int i=0; i<3; ++i){\n            cin >> p[i].x >> p[i].y;\n            if(p[i].x == 0)\n                return 0;\n        }\n\n        Point c;\n        int r;\n        cin >> c.x >> c.y >> r;\n\n        char ret = 'b';\n        for(int i=0; i<3; ++i){\n            int tmp = segmentCircleCollide(p[i], p[(i+1)%3], c, r);\n            if(tmp > 0){\n                ret = 'c';\n                break;\n            }\n            if(tmp == 0)\n                ret = 'd';\n        }\n\n        if(ret == 'd' && convexContain(p, c))\n            ret = 'a';\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Vector2\n{\npublic:\n\tdouble length() const\n\t{\n\t\treturn sqrt( static_cast<double>( x * x + y * y ) );\n\t}\n\tint clossProduct( const Vector2& v ) const\n\t{\n\t\treturn this->x * v.y - this->y * v.x;\n\t}\n\tVector2 operator-( const Vector2& v ) const\n\t{\n\t\tVector2 ret;\n\t\tret.x = this->x - v.x;\n\t\tret.y = this->y - v.y;\n\t\treturn ret;\n\t}\n\n\tint x, y;\n};\n\nint main()\n{\n\tVector2 tri[ 3 ];\n\tVector2 cir;\n\tint cirR;\n\n\twhile( cin >> tri[ 0 ].x >> tri[ 0 ].y && !( !tri[ 0 ].x && !tri[ 0 ].y ) ){\n\t\tfor( int i = 1; i < 3; ++i ){\n\t\t\tcin >> tri[ i ].x >> tri[ i ].y;\n\t\t}\n\t\tcin >> cir.x >> cir.y;\n\t\tcin >> cirR;\n\n\t\tint flags = 0;\n\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\tVector2 ao = cir - tri[ i ];\n\t\t\tVector2 ab = tri[ ( i + 1 ) % 3 ] - tri[ i ];\n\t\t\tdouble distance = abs( ab.clossProduct( ao ) ) / ab.length();\n\t\t\tif( distance >= cirR ){\n\t\t\t\tflags |= ( 1 << i );\n\t\t\t}\n\t\t}\n\n\t\tchar result;\n\t\tif( flags == 7 ){\n\t\t\tint dir = 0;\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tVector2 oa = tri[ i ] - cir;\n\t\t\t\tVector2 ob = tri[ ( i + 1 ) % 3 ] - cir;\n\t\t\t\tif( oa.x * ob.y > oa.y * ob.x ){\n\t\t\t\t\tdir |= ( 1 << i );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dir % 7 == 0 ){\n\t\t\t\tresult = 'a';\n\t\t\t}else{\n\t\t\t\tresult = 'd';\n\t\t\t}\n\t\t}else if( flags == 0 ){\n\t\t\tint dir = 0;\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tVector2 oa = tri[ i ] - cir;\n\t\t\t\tif( oa.length() <= cirR ){\n\t\t\t\t\tdir |= ( 1 << i );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dir == 7 ){\n\t\t\t\tresult = 'b';\n\t\t\t}else{\n\t\t\t\tresult = 'c';\n\t\t\t}\n\t\t}else{\n\t\t\tresult = 'c';\n\t\t}\n\n\t\tcout << result << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e6;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source().ccw(s.target(), source()) * s.source().ccw(s.target(), target()) <= EPS;\n    bool b = source().ccw(target(), s.source()) * source().ccw(target(), s.target()) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n\n    // 円の中心が三角形の内部\n    bool centerInTriangle = true;\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) == ABOVE) ++ccw;\n        if(e.ccw(circle.center()) == UNDER) ++cw;\n    }\n    centerInTriangle = (cw == 3) || (ccw == 3);\n\n    if(centerInTriangle && (edgesOutOfCircle == 3)) return \"a\";\n    if(!centerInTriangle && (edgesOutOfCircle == 3)) return \"d\";\n    return \"c\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-6;\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / abs(a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < Eps)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) <Eps)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(a, b, point);\n}\nbool is_in_triangle(const Point& point, const Point* triangle)\n{\n\tdouble t[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tt[i] = cross(triangle[(i+1)%3] - triangle[i], point - triangle[i]);\n\n\treturn t[0] >= 0 && t[1] >= 0 && t[2] >= 0\n\t\t|| t[0] <= 0 && t[1] <= 0 && t[2] <= 0;\n}\nbool is_in_triangle(const Point& point, const Point& a, const Point& b, const Point& c)\n{\n\tPoint t[3] = { a, b, c };\n\treturn is_in_triangle(point, t);\n}\nbool is_circle_in_triangle(const Point& center, double radius, const Point* triangle)\n{\n\tif (!is_in_triangle(center, triangle))\n\t\treturn false;\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_line_point(triangle[i], triangle[(i+1)%3], center) < radius)\n\t\t\treturn false;\n\treturn true;\n}\nbool is_triangle_in_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (abs(triangle[i]-center) > radius)\n\t\t\treturn false;\n\treturn true;\n}\nbool interect_triangle_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_linesegment_point(center, triangle[i], triangle[(i+1)%3]) < radius)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tint x[4], y[4], r;\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tscanf(\"%d %d\", x+i, y+i);\n\t\tscanf(\"%d\", &r);\n\t\tif (x[0] == 0 && y[0] == 0)\n\t\t\tbreak;\n\t\tPoint p[4];\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tp[i] = Point(x[i], y[i]);\n\n\t\tif (is_circle_in_triangle(p[3], r, p))\n\t\t\tputs(\"a\");\n\t\telse if (is_triangle_in_circle(p, p[3], r))\n\t\t\tputs(\"b\");\n\t\telse if (interect_triangle_circle(p, p[3], r))\n\t\t\tputs(\"c\");\n\t\telse\n\t\t\tputs(\"d\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-b,ar=d-a;\n\tP bb=b-c,br=d-b;\n\tP cc=c-a,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nbool foo2(P a,P b,P p,double r){\n\tdouble t=dot(b-a,p-a);\n\tif(t<-EPS){\n\t\t// cout<<\"a\"<<endl;\n\t\tif(r-abs(p-a)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tif(t-abs(b-a)*abs(b-a)>EPS){\n\t\t// cout<<\"b\"<<endl;\n\t\tif(r-abs(p-b)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t// cout<<\"c\"<<endl;\n\tdouble h=abs(p-a)*abs(p-a)-t*t/abs(b-a)/abs(b-a);\n\t// printf(\"%.6lf\\n\",h);\n\tif(h-r*r>EPS){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tP zz[3];\n\t\trep(i,3) zz[i]=z[i];\n\t\tcin>>r;\n\t\t// char c=solve(zz,z[3],r)[0];\n\t\t// cout<<\"c \"<<c<<endl;\n\t\tif(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\t// if(c!='b') cout<<\"error\\n\";\n\t\t\tcout<<\"b\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(r-t>-EPS){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\t// if(c!='a') cout<<\"error\\n\";\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(foo2(z[0],z[1],z[3],r)||foo2(z[1],z[2],z[3],r)||foo2(z[2],z[0],z[3],r)){\n\t\t\t// if(c!='c') cout<<\"error\\n\";\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse{\n\t\t\t// if(c!='d') cout<<\"error\\n\";\n\t\t\tcout<<\"d\\n\";\n\t\t}\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n\t// cout<<abs(P(0,0)-P(1,1))<<endl;\n}\n\n\n\n}\nmain() try{\n\t// vector<P> d;\n\t// double r;\n\t// rep(i,3){\n\t\t// double x,y;\n\t\t// cin>>x>>y;\n\t\t// d.PB(P(x,y));\n\t// }\n\t// cin>>r;\n\t// cout<<foo2(d[0],d[1],d[2],r)<<endl;\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) {\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nint ccw(P a, P b, P c) {\n  b = vec(a,b); c = vec(a,c);\n  if(sgn(outp(b,c),0.0) > 0) return +1;\n  if(sgn(outp(b,c),0.0) < 0) return -1;\n  if(sgn(inp(b,c),0.0) < 0)  return +2;\n  if(sgn(abs(b),abs(c)) < 0) return -2;\n  return 0;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nbool iSP(L s, P p) {\n    return ccw(s.a, s.b, p) == 0;\n}\nD dSP(L s, P p) {\n  P r = proj(s, p);\n  if(iSP(s, r)) return abs(p - r); // 写像がs上にある\n  return min(abs(p - s.a), abs(p - s.b)); // 写像がs上にない\n}\nint containsGP(vector<P> g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(g[i], g[(i+1)%g.size()], p) == 0) return 0;\n    P a = vec(p, g[i]);\n    P b = vec(p, g[(i+1)%g.size()]);\n    if(a.y > b.y) swap(a, b);\n    if(sgn(a.y, 0.0) <= 0 && sgn(b.y, 0.0) > 0 && sgn(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\nint iCS(C c, L s) {\n  if(sgn(abs(c.p - s.a), c.r) <= 0 && sgn(abs(c.p - s.b), c.r) <= 0)\n    return -2;\n  if(sgn(abs(c.p - s.a), c.r) <= 0 || sgn(abs(c.p - s.b), c.r) <= 0)\n    return -1;\n  if(sgn(dLP(s, c.p), c.r) < 0)\n    return +2;\n  if(sgn(dLP(s, c.p), c.r) == 0)\n    return +1;\n  return 0;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    double R = min({dSP(L(tri[0], tri[1]), cir.p), dSP(L(tri[1], tri[2]), cir.p), dSP(L(tri[2], tri[0]), cir.p)});\n    // a\n    if(containsGP(tri, cir.p) >= 0 &&\n       sgn(cir.r, R) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(containsGP(tri, cir.p) == -1 &&\n       sgn(cir.r, R) < 0) {\n      cout << \"d\" << endl;\n      continue;\n    }\n    cout << \"c\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0){\n\t\t\tif(acx*acx+acy*acy<=r*r)return true;\n\t\t}else{\n\t\t\tif(abx*acx+aby*acy>abx*abx+aby*aby){\n\t\t\t\tif(bcx*bcx+bcy*bcy<=r*r)return true;\n\t\t\t}else if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<0)ok1=false;\n\telse ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<0)ok1=false;\n\telse ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<0)ok1=false;\n\telse ok2=false;\n\treturn ok1||ok2;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<r*r&&(c-g)*(c-g)+(d-h)*(d-h)<r*r&&(e-g)*(e-g)+(f-h)*(f-h)<r*r)printf(\"b\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse if(inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define F first\n#define S second\n\n#define X real()\n#define Y imag()\n\n#define EPS (1e-7)\n\ntypedef complex<double> Point;\ntypedef pair<double, Point> Circle;\n\nbool isPointInCircle(Point p, Circle c) {\n  if(abs(p-c.S) < abs(c.F)) return true;\n  return false;\n}\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n\ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n  \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n\nint main() {\n  \n  while(1) {\n    Point points[3];\n    Circle circle;\n  \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n    \n      points[i] = Point(x, y);\n    }\n  \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n  \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n    \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3) {\n      int flg = 0;\n      for(int i=0; i<3; i++) {\n        if(dot(points[(i+1)%3]-points[i], circle.S-points[i]) * dot(points[(i+2)%3]-points[(i+1)%3], circle.S-points[(i+1)%3]) > 0) {\n          flg ++;\n        }\n      }\n      if(flg == 3) { cout << 'a' << endl; continue; }\n    }\n\n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) < circle.F + EPS;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-6;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    return ccw(s.source()) * ccw(s.target()) <= 0 && s.ccw(source()) * s.ccw(target()) <= 0;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) == ABOVE) ++ccw;\n        if(e.ccw(circle.center()) == UNDER) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nclass CPoint;\ntypedef CPoint CVector2D;\nclass CSegment;\ntypedef vector <CSegment> CSegments;\ndouble GetSquare( double );\nbool Equal( double, double );\nbool LessthanEqual( double, double );\ndouble GetCrossProduct( double, double, double, double );\ndouble GetCrossProduct( CPoint, CPoint );\ndouble GetDotProduct( double, double, double, double );\ndouble GetDotProduct( CPoint, CPoint );\ndouble GetGradientFromTwoPoints( CPoint, CPoint );\nint CheckCounterClockWise( CPoint, CPoint, CPoint );\nbool Intersect( CPoint, CPoint, CPoint, CPoint );\nbool Intersect( CSegment, CSegment );\nCPoint GetCrossPoint( CSegment, CSegment );\ndouble GetLength( CPoint, CPoint );\ndouble GetDistance( CPoint, CPoint );\ndouble GetDistance( CSegment, CPoint );\nCPoint GetLowestY( CPoint, CPoint );\nclass CPoint {\npublic:\n    double x, y;\n    CPoint( double x, double y ): x(x), y(y) {}\n    CPoint(): x(0), y(0) {};\n    double getNorm() {\n        return x * x + y * y;\n    }\n    double getAbs() {\n        return sqrt( getNorm() );\n    }\n    CPoint operator + ( CPoint p ) {\n        return CPoint( x + p.x, y + p.y );\n    }\n    CPoint operator - ( CPoint p ) {\n        return CPoint( x - p.x, y - p.y );\n    }\n    CPoint operator * ( double k ) {\n        return CPoint( x * k, y * k );\n    }\n    bool operator < ( const CPoint& p ) const {\n        if ( x < p.x ) return true;\n        return x == p.x ? y < p.y : false;\n    }\n};\nCPoint operator * ( double k, CPoint p ) {\n    return CPoint( p.x * k, p.y * k );\n}\nostream& operator << ( ostream& os, CPoint p0 ) {\n    os << \"(\" << p0.x << \", \" << p0.y << \")\";\n    return os;\n}\nclass CSegment {\npublic:\n    CPoint a, b;\n    CSegment( int x1, int y1, int x2, int y2 ): a(CPoint( x1, y1 )), b(CPoint( x2, y2 )) {}\n    CSegment( CPoint a, CPoint b ): a(a), b(b) {}\n    CSegment() {}\n    double getGradient() {\n        return GetGradientFromTwoPoints( a, b );\n    }\n    double getLength() {\n        return GetLength( a, b );\n    }\n    double getMinX() {\n        return min( a.x, b.x );\n    }\n    double getMinY() {\n        return min( a.y, b.y );\n    }\n    double getMaxX() {\n        return max( a.x, b.x );\n    }\n    double getMaxY() {\n        return max( a.y, b.y );\n    }\n    bool operator < ( const CSegment& s ) const {\n        return b.y > s.b.y;\n    }\n    \n};\nostream& operator << ( ostream& os, CSegment s0 ) {\n    os << \"(\" << s0.a << \" - \" << s0.b << \")\";\n    return os;\n}\nclass CCircle {\npublic:\n    CPoint p;\n    int r;\n    CCircle(): p( 0, 0 ), r(0) {}\n    CCircle( int x, int y, int r ): p(x, y), r(r) {}\n    CCircle( CPoint p, int r ): p(p), r(r) {}\n};\nostream& operator << ( ostream& os, CCircle c0 ) {\n    os << \"{(\" << c0.p.x << \", \" << c0.p.y << \"), r = \" << c0.r << \")\";\n    return os;\n}\nclass CTriangle {\npublic:\n    CPoint a;\n    CPoint b;\n    CPoint c;\n    CTriangle( int x1, int y1, int x2, int y2, int x3, int y3 ):\n        a(CPoint(x1,y1)), b(CPoint(x2,y2)), c(CPoint(x3,y3)) {}\n    CTriangle( CPoint a, CPoint b, CPoint c ):\n        a(a), b(b), c(c) {}\n    double getArea() {\n        CSegment AB( a, b );\n        CSegment BC( b, c );\n        CSegment CA( c, a );\n        double aa = AB.getLength();\n        double bb = BC.getLength();\n        double cc = CA.getLength();\n        double s = ( aa + bb + cc ) / 2.0;\n        return sqrt( s * ( s - aa ) * ( s - bb ) * ( s - cc ) );\n    }\n};\nostream& operator << ( ostream& os, CTriangle t0 ) {\n    os << \"{\" << t0.a << \", \" << t0.b << \", \" << t0.c << \"}\";\n    return os;\n}\nconst double EPS = 1e-9;\ndouble GetSquare( double x ) {\n    return x * x;\n}\nbool Equal( double a, double b ) {\n    return fabs( b - a ) < EPS;\n}\nbool LessthanEqual( double a, double b ) {\n    return a < b ? true : ( fabs( b - a ) < EPS );\n}\ndouble GetCrossProduct( double x1, double y1, double x2, double y2 ) {\n    return x1 * y2 - y1 * x2;\n}\ndouble GetCrossProduct( CPoint a, CPoint b ) {\n    return GetCrossProduct( a.x, a.y, b.x, b.y );\n}\ndouble GetDotProduct( double x1, double y1, double x2, double y2 ) {\n    return x1 * x2 + y1 * y2;\n}\ndouble GetDotProduct( CPoint a, CPoint b ) {\n    return GetDotProduct( a.x, a.y, b.x, b.y );\n}\nbool Intersect( CPoint p1, CPoint p2, CPoint p3, CPoint p4 ) {\n    bool f1 = CheckCounterClockWise( p1, p2, p3 ) * CheckCounterClockWise( p1, p2, p4 ) <= 0;\n    bool f2 = CheckCounterClockWise( p3, p4, p1 ) * CheckCounterClockWise( p3, p4, p2 ) <= 0;\n    return f1 && f2;\n}\nbool Intersect( CSegment s1, CSegment s2 ) {\n    return Intersect( s1.a, s1.b, s2.a, s2.b );\n}\nbool Contain( CTriangle a, CPoint p ) {\n    CVector2D AP = p - a.a;\n    CVector2D BP = p - a.b;\n    CVector2D CP = p - a.c;\n    CVector2D AB = a.b - a.a;\n    CVector2D BC = a.c - a.b;\n    CVector2D CA = a.a - a.c;\n    if ( GetCrossProduct( AP, AB ) < 0.0\n         && GetCrossProduct( BP, BC ) < 0.0\n         && GetCrossProduct( CP, CA ) < 0.0 ) return true;\n    if ( GetCrossProduct( AP, AB ) > 0.0\n         && GetCrossProduct( BP, BC ) > 0.0\n         && GetCrossProduct( CP, CA ) > 0.0 ) return true;\n    return false;\n}\nbool Contain( CCircle cir, CTriangle tri ) {\n    double maxd = 0.0;\n    maxd = max( maxd, GetDistance( tri.a, cir.p ) );\n    maxd = max( maxd, GetDistance( tri.b, cir.p ) );\n    maxd = max( maxd, GetDistance( tri.c, cir.p ) );\n    return LessthanEqual( maxd, cir.r );\n}\nbool Contain( CTriangle tri, CCircle cir ) {\n    double mind = GetDistance(CSegment(tri.a, tri.b), cir.p);\n    mind = min( mind, GetDistance(CSegment(tri.b, tri.c), cir.p) );\n    mind = min( mind, GetDistance(CSegment(tri.c, tri.a), cir.p) );\n    return LessthanEqual( cir.r, mind );\n}\ndouble GetGradientFromTwoPoints( CPoint a, CPoint b ) {\n    return ( b.y - a.y ) / ( b.x - a.x );\n}\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\nint CheckCounterClockWise( CPoint p0, CPoint p1, CPoint p2 ) {\n    CVector2D a = p1 - p0;\n    CVector2D b = p2 - p0;\n    if ( GetCrossProduct( a, b ) > EPS ) return COUNTER_CLOCKWISE;\n    if ( GetCrossProduct( a, b ) < EPS ) return CLOCKWISE;\n    if ( GetDotProduct( a, b ) < -EPS ) return ONLINE_BACK;\n    if ( a.getNorm() < b.getNorm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nCPoint GetCrossPoint( CSegment s1, CSegment s2 ) {\n    CVector2D base = s2.b - s2.a;\n    double d1 = abs( GetCrossProduct( base, s1.a - s2.a ) );\n    double d2 = abs( GetCrossProduct( base, s1.b - s2.a ) );\n    double t = d1 / ( d1 + d2 );\n    return s1.a + ( s1.b - s1.a ) * t;\n}\ndouble GetLength( CPoint a, CPoint b ) {\n    return sqrt( GetSquare( a.x - b.x ) + GetSquare( a.y - b.y ) );\n}\ndouble GetDistance( CPoint a, CPoint b ) {\n    return GetLength( a, b );\n}\nCPoint GetLowestY( CPoint a, CPoint b ) {\n    if ( a.y == b.y ) return a.x < b.x ? a : b;\n    return a.y < b.y ? a : b;\n}\ndouble GetDistance( CSegment seg, CPoint p ) {\n    if ( GetDotProduct( seg.b - seg.a, p - seg.a ) < EPS ) return (p - seg.a).getAbs();\n    if ( GetDotProduct( seg.a - seg.b, p - seg.b ) < EPS ) return (p - seg.b).getAbs();\n    return fabs( GetCrossProduct( seg.b - seg.a, p - seg.a ) ) / ( seg.b - seg.a ).getAbs();\n}\nbool CheckIntersect( CSegment seg, CCircle c ) {\n    bool f1 = LessthanEqual( ( c.p - seg.a ).getAbs(), c.r );\n    bool f2 = LessthanEqual( ( c.p - seg.b ).getAbs(), c.r );\n    if ( f1 ^ f2 ) return true;\n    return LessthanEqual( GetDistance( seg, c.p ), c.r ) && ( ! f1 && ! f2 );\n}\nbool CheckIntersect( CTriangle tri, CCircle cir ) {\n    return CheckIntersect( CSegment( tri.a, tri.b ), cir )\n        || CheckIntersect( CSegment( tri.b, tri.c ), cir )\n        || CheckIntersect( CSegment( tri.c, tri.a ), cir );\n}\n\n\n\nstring solve( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int r ) {\n    CTriangle tri( x1, y1, x2, y2, x3, y3 );\n    CCircle cir( x4, y4, r );\n    if ( Contain( tri, cir.p ) && Contain( tri, cir ) ) return \"a\";\n    if ( Contain( cir, tri ) ) return \"b\";\n    if ( CheckIntersect( tri, cir ) ) return \"c\";\n    return \"d\";\n}\n\nint main() {\n    int x1, y1, x2, y2, x3, y3, x4, y4, r;\n    while ( cin >> x1 >> y1 ) {\n        if ( x1 == 0 && y1 == 0 ) break;\n        cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n        cout << solve( x1, y1, x2, y2, x3, y3, x4, y4, r ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\n\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-9;\nconst double INF = 1e8;\n\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\nint main(){\n  G p;\n  L l[3];\n  C c;\n  p.resize(3);\n  while(cin >> p[0].real() >> p[0].imag(), p[0].real()||p[0].imag()){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> p[i].real() >> p[i].imag();\n    }\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      l[i] = L( p[i], p[(i+1)%3]);\n    }\n\n    bool flag = true;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(distance( l[i], c.p ) < c.r) flag = false;\n    }\n    if(flag && contains( p, c.p)){\n      cout << 'a' << endl;\n      continue;\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(!contains( c, p[i])) flag = true;\n    }\n    if(!flag){\n      cout << 'b' << endl;\n      continue;\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(intersect( c, l[i]) == 0) flag = false;\n    }\n    if(flag){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<sstream>\n#include<functional>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define REP(i,s,e) for(int i=int(s);i<int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nusing namespace std;\n\nbool f(double x,double y,double x0,double y0,double x4,double y4,double r){\ndouble p=(x0-x)*(y0-y4)-(x0-x4)*(y0-y);\ndouble q=(y0-y)*(y0-y)+(x0-x)*(x0-x);\nif(x-x0!=0 && y-y0!=0){\nif(abs(p)/sqrt(q)<=r && (-p*(y0-y)/q)>min(x,x0) && (-p*(y0-y)/q)<max(x,x0))\nreturn true;\nelse return false;\n}\nif(x-x0==0 && abs(x0)<=r && sqrt(r*r-x0*x0)<max(y,y0) && -sqrt(r*r-x0*x0)>min(y,y0))\nreturn true;\nelse return false;\nif(y-y0==0 && abs(y0)<=r && sqrt(r*r-y0*y0)<max(x,x0) && -sqrt(r*r-y0*y0)>min(x,x0))\nreturn true;\nelse return false;\n}\n\nbool g(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){\ndouble p=(y1-y4)/(x1-x4);\ndouble q=(y2-y3)/(x2-x3);\ndouble u=((y3-y4)-q*(x3-x4))/(p-q)-x1+x4;\ndouble v=(p*(y3-y4)-p*q*(x3-x4))/(p-q)-y1+y4;\nif((x1-x4)!=0 && (x2-x3)!=0 && (p-q)!=0 && (u*u+v*v)>((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4)))\nreturn true;\nelse return false;\nif((x1-x4)==0 && (x2-x3)!=0 && abs(y1-y4)<abs(y1-y3+q*(x3-x4)))\nreturn true;\nelse return false;\nif((x2-x3)==0 && (x1-x4)!=0 && ((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4))<((x2-x1)*(x2-x1)+(p*x2-p*x4-y1+y4)*(p*x2-p*x4-y1+y4)))\nreturn true;\nelse return false;\n\n}\n\nint main(){\n\ndouble x1,y1,x2,y2,x3,y3,x4,y4,r;\n\nwhile(true){\n\ncin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\nif(x1==0 && y1==0) break;\n\n\ndouble a,b,c;\na=(x1-x4)*(x1-x4)+(y1-y4)*(y1-y4);\nb=(x2-x4)*(x2-x4)+(y2-y4)*(y2-y4);\nc=(x3-x4)*(x3-x4)+(y3-y4)*(y3-y4);\n\nif(a<r*r && b<r*r && c<r*r)\ncout << \"b\" << endl;\n\nif(!(a<r*r && b<r*r && c<r*r) && !(a>r*r && b>r*r && c>r*r))\ncout << \"c\" << endl;\n\n\nif(a>r*r && b>r*r && c>r*r){\n\nif(f(x1,y1,x2,y2,x4,y4,r) || f(x2,y2,x3,y3,x4,y4,r) || f(x1,y1,x3,y3,x4,y4,r))\ncout << \"c\" << endl;\n\nelse if(g(x1,y1,x2,y2,x3,y3,x4,y4) && g(x2,y2,x1,y1,x3,y3,x4,y4) && g(x3,y3,x2,y2,x1,y1,x4,y4))\ncout << \"a\" << endl;\n\nelse cout << \"d\" << endl;\n\n}\n\n\n}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{ point a,b; };\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\nbool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && vec_abs(seg[i].b-seg[j].a)<=EPS){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1 || ccw(seg[i].a,seg[i].b,seg[j].b)==0){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\nint crossCP(point* ps, circle C, int sz){\n\n  double ans=0;\n\n  for(int i=0;i<sz;i++){\n    double tmp=dist(ps[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  vector<segment>t=construct_edge(ps,sz);\n\n  int tsz=t.size();\n  int res1=point_contain(t,C.p,tsz);\n\n\n  double res2=100000000;\n  ps[3]=ps[0];\n  for(int i=0;i<sz;i++)\n    res2=min(res2,distance_ls_p(ps[i],ps[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p[6];\n  vector<segment> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(p,C,3);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<sstream>\n#include<functional>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define REP(i,s,e) for(int i=int(s);i<int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nusing namespace std;\n\nbool f(double x,double y,double x0,double y0,double x4,double y4,double r){\ndouble p=(x0-x)*(y0-y4)-(x0-x4)*(y0-y);\ndouble q=(y0-y)*(y0-y)+(x0-x)*(x0-x);\nif(x-x0!=0 && y-y0!=0){\nif(abs(p)/sqrt(q)<=r && (-p*(y0-y)/q)>=min(x,x0) && (-p*(y0-y)/q)<=max(x,x0))\nreturn true;\nelse return false;\n}\nif(x-x0==0 && abs(x0)<=r && sqrt(r*r-x0*x0)<=max(y,y0) && -sqrt(r*r-x0*x0)>=min(y,y0))\nreturn true;\nelse return false;\nif(y-y0==0 && abs(y0)<=r && sqrt(r*r-y0*y0)<=max(x,x0) && -sqrt(r*r-y0*y0)>=min(x,x0))\nreturn true;\nelse return false;\n}\n\nbool g(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4,double r){\ndouble p=(y1-y4)/(x1-x4);\ndouble q=(y2-y3)/(x2-x3);\ndouble u=((y3-y4)-q*(x3-x4))/(p-q)-x1+x4;\ndouble v=(p*(y3-y4)-p*q*(x3-x4))/(p-q)-y1+y4;\nif((x1-x4)!=0 && (x2-x3)!=0 && (p-q)!=0 && sqrt(u*u+v*v)>sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4))+r && !f(x3-x4,y3-y4,x2-x4,y2-y4,x4,y4,r))\nreturn true;\nelse return false;\nif((x1-x4)==0 && (x2-x3)!=0 && abs(y1-y4)+r<abs(y1-y3+q*(x3-x4)) && !f(x3-x4,y3-y4,x2-x4,y2-y4,x4,y4,r))\nreturn true;\nelse return false;\nif((x2-x3)==0 && (x1-x4)!=0 && sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4))+r<sqrt((x2-x1)*(x2-x1)+(p*x2-p*x4-y1+y4)*(p*x2-p*x4-y1+y4)) && !f(x3-x4,y3-y4,x2-x4,y2-y4,x4,y4,r))\nreturn true;\nelse return false;\n\n}\n\nint main(){\n\ndouble x1,y1,x2,y2,x3,y3,x4,y4,r;\n\nwhile(true){\n\ncin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\nif(x1==0 && y1==0) break;\n\n\ndouble a,b,c;\na=(x1-x4)*(x1-x4)+(y1-y4)*(y1-y4);\nb=(x2-x4)*(x2-x4)+(y2-y4)*(y2-y4);\nc=(x3-x4)*(x3-x4)+(y3-y4)*(y3-y4);\n\nif(a<r*r && b<r*r && c<r*r)\ncout << \"b\" << endl;\n\nif(!(a<r*r && b<r*r && c<r*r) && !(a>r*r && b>r*r && c>r*r))\ncout << \"c\" << endl;\n\n\nif(a>r*r && b>r*r && c>r*r){\n\nif(f(x1,y1,x2,y2,x4,y4,r) || f(x2,y2,x3,y3,x4,y4,r) || f(x1,y1,x3,y3,x4,y4,r))\ncout << \"c\" << endl;\n\nelse if(g(x1,y1,x2,y2,x3,y3,x4,y4,r) && g(x2,y2,x1,y1,x3,y3,x4,y4,r) && g(x3,y3,x2,y2,x1,y1,x4,y4,r))\ncout << \"a\" << endl;\n\nelse cout << \"d\" << endl;\n\n}\n\n\n}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define F first\n#define S second\n\n#define X real()\n#define Y imag()\n\n#define EPS (1e-7)\n\ntypedef complex<double> Point;\ntypedef pair<double, Point> Circle;\n\nbool isPointInCircle(Point p, Circle c) {\n  if(abs(p-c.S) < abs(c.F) + EPS) return true;\n  return false;\n}\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n\ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n  \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n\nint main() {\n  \n  while(1) {\n    Point points[3];\n    Circle circle;\n  \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n    \n      points[i] = Point(x, y);\n    }\n  \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n  \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n    \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3) {\n      int flg = 0;\n      for(int i=0; i<3; i++) {\n        if(dot(points[(i+1)%3]-points[i], circle.S-points[i]) * dot(points[(i+2)%3]-points[(i+1)%3], circle.S-points[(i+1)%3]) > 0) {\n          flg ++;\n        }\n      }\n      if(flg == 3) { cout << 'a' << endl; continue; }\n    }\n\n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) < circle.F + EPS;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define EPS 1E-5\n#define SAME_SIGN( a , b ) a * b > EPS\n\nnamespace geometry{\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius + EPS ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) <= cir.radius + EPS &&\n\t\tget_distance( tri.b , cir.center ) <= cir.radius + EPS &&\n\t\tget_distance( tri.c , cir.center ) <= cir.radius + EPS\n\t\t){\n\t\t\tstd::cout << 'b' << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius + EPS &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius + EPS &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius + EPS\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << 'a' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << 'd' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << 'c' << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << 'c' << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#define PI 3.141592653589\nusing namespace std;\n\ndouble x[3],y[3],rx,ry,r;\n\nint trgin() {\n\tint i,k;\n\tdouble a,b,c,d=0;\n\tfor (i=0; i<3; i++) {\n\t k=(i+1) % 3;\n\t a=sqrt((x[i]-x[k])*(x[i]-x[k])+(y[i]-y[k])*(y[i]-y[k]));\n\t b=sqrt((x[i]-rx)*(x[i]-rx)+(y[i]-ry)*(y[i]-ry));\n\t c=sqrt((x[k]-rx)*(x[k]-rx)+(y[k]-ry)*(y[k]-ry));\n     d=d+acos((b*b+c*c-a*a)/(2*b*c));\n\t}\n\tif ((d-PI*2)<0.000001 && (d-PI*2)>-0.000001) return 1;\n\treturn 0;\n}\nint line(double x1,double y1,double x2,double y2) {\n    double x,y,m,d;\n\tif (y1==y2) { x=rx;y=y1;} else if (x1==x2) { x=x1;y=ry;}\n\telse {\n    m=(y2-y1)/(x2-x1);\n\tx=(ry-y1+m*x1+rx/m)/(m+1/m);\n\ty=y1+m*(x-x1);\n\t}\n\tif (((x>=x1 && x<=x2) || (x>=x2 && x<=x1)) && ((y>=y1 && y<=y2) || (y>=y2 && y<=y1))){\n\td=(rx-x)*(rx-x)+(ry-y)*(ry-y);\n    if (d==r*r) return 1; else if (d<r*r) return 2;\n\t}\n\treturn 0;\n}\nint main() {\n\tint i,j,k,f;\n\twhile(true) {\n\t\tfor (i=0;i<3;i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tif (x[i]==0) break;\n\t}\n    if (i!=3) break;\n\tcin >> rx >> ry >> r;\n\tfor (i=0,f=0;i<3;i++) if ((x[i]-rx)*(x[i]-rx)+(y[i]-ry)*(y[i]-ry)<=r*r) f++;\n\tif (f==3) { cout << 'b' << endl; continue;} else if (f>0) { cout << 'c' << endl; continue;} \n\tfor (i=0,f=0,k=0;i<3;i++) {\n\t\tj=line(x[i],y[i],x[(i+1) % 3],y[(i+1) % 3]); k+=j;\n\t\tif (j>1) break;\n\t}\n\tif (i==3) if (trgin()==1) { cout << 'a' << endl; continue;} else if (k==0) {cout << 'd' << endl; continue;}\n\tcout << 'c' << endl;\n\t}\nreturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=min(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>-EPS)return 1; //intersect"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef double D;\ntypedef complex<D> P;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\ndouble x[3],y[3],xr,yr,r;\nbool dis(int p){\n  return sqrt(abs(x[p]-xr)*abs(x[p]-xr)+abs(y[p]-yr)*abs(y[p]-yr))<=r+0.01;\n}\nmain(){\n  while(cin>>x[0]>>y[0],x[0]+y[0]){\n    int sum=0;\n    r(i,2)cin>>x[i+1]>>y[i+1];\n    cin>>xr>>yr>>r;\n    r(i,3)if(dis(i))sum++;\n    if(sum==0){\n      int pp=0,f=0;\n      r(i,3){\n        pp+=ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr));\n        if(ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr))==2)f++;\n        if(ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr))==-2)f++;\n        if(ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr))==0)f++;\n      }\n      if(f)cout<<'c'<<endl;\n      else if(abs(pp)==3)cout<<'a'<<endl;\n      else cout<<'d'<<endl;\n    }\n    else if(sum==3)cout<<'b'<<endl;\n    else cout<<'c'<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n// ½ÊãÌ_ExNg\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// OÏ\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\n// àÏ\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\n// ¼ü\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n// ½p`\ntypedef vector<P> G;\n\n// ~\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0)   return +1; // ½vñè\n\tif(cross(b, c) < 0)   return -1; // vñè\n\tif(dot(b, c) < 0)     return +2; // c--a--b\n\tif(norm(b) < norm(c)) return -2; // a--b--c\n\treturn 0;\n}\n\n// üªÆ_Ìð·»è\nbool intersectSP(const L& s, const P& p){\n\treturn abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;\n}\n\n// ¼üãÌ_ÌËe\nP projection(const L& l, const P& p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\n// üªÆ_Ì£\ndouble distanceSP(const L& s, const P& p){\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nchar detect(const G& tri, const C& c)\n{\n\tbool inner[3];\n\trep(i, 3){\n\t\tinner[i] = abs(tri[i] - c.p) - EPS <= c.r;\n\t}\n\tif(inner[0] && inner[1] && inner[2])\n\t\treturn 'b';\n\tif(inner[0] || inner[1] || inner[2])\n\t\treturn 'c';\n\t\n\trep(i, 3){\n\t\tL l(tri[i], tri[(i+1)%3]);\n\t\tif(distanceSP(l, c.p) + EPS < c.r)\n\t\t\treturn 'c';\n\t}\n\t\n\tint v = 0;\n\trep(i, 3){\n\t\tint now = ccw(tri[i], tri[(i+1)%3], c.p);\n\t\tif(abs(now) == 2 || now * v < 0)\n\t\t\treturn 'd';\n\t\tv = now;\n\t}\n\t\n\treturn 'a';\n}\n\nint main()\n{\n\tfor(;;){\n\t\tG tri(3);\n\t\trep(i, 3){\n\t\t\tscanf(\"%lf%lf\", &tri[i].real(), &tri[i].imag());\n\t\t\tif(fabs(tri[i].real()) < EPS)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(fabs(tri[0].real()) < EPS)\n\t\t\tbreak;\n\t\t\n\t\tP p;\n\t\tdouble r;\n\t\tscanf(\"%lf%lf%lf\", &p.real(), &p.imag(), &r);\n\t\tprintf(\"%c\\n\", detect(tri, C(p, r)));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a+b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\trep(i,2)g[i+1]=pin();\n\t\tP p=pin();double r;cin>>r;\n\t\tC c(p,r);\n\t\tbool h=true;\n\t\tif(inconvex(g,c.c)!=2)h=false;\n\t\trep(i,3)if(distanceSP(L(g[i],g[(i+1)%3]),c.c)<EPS+c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'a'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\th=true;\n\t\trep(i,3)if(abs(g[i]-c.c)+EPS>c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'b'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,3)if(intersectCS(c,L(g[i],g[(i+1)%3])))h=true;\n\t\tif(h)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a+b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\trep(i,2)g[i+1]=pin();\n\t\tP p=pin();double r;cin>>r;\n\t\tC c(p,r);\n\t\tbool h=true;\n\t\tif(inconvex(g,c.c)!=2)h=false;\n\t\trep(i,3)if(distanceSP(L(g[i],g[(i+1)%3]),c.c)<c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'a'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\th=true;\n\t\trep(i,3)if(abs(g[i]-c.c)>c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'b'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,3)if(intersectCS(c,L(g[i],g[(i+1)%3])))h=true;\n\t\tif(h)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a+b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\trep(i,2)g[i+1]=pin();\n\t\tP p=pin();double r;cin>>r;\n\t\tC c(p,r);\n\t\tbool h=true;\n\t\trep(i,3)if(!(abs(g[i]-c.c)<c.r+EPS))h=false;\n\t\tif(h){\n\t\t\tcout<<'b'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\th=true;\n\t\tif(inconvex(g,c.c)==0)h=false;\n\t\trep(i,3)if(distanceSP(L(g[i],g[(i+1)%3]),c.c)+EPS<c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'a'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,3)if(intersectCS(c,L(g[i],g[(i+1)%3])))h=true;\n\t\tif(h)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\nconst double EPS = 1e-10;\n\ndouble cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\nxy_t projection(const line &l, const xy_t &p){\n  double t = dot(l.second - l.first, p - l.first) / norm(l.second - l.first);\n  return l.first + t * (l.second - l.first);\n}\n\nbool intersectSP(const line &l, const xy_t &p){\n  return abs(p - l.first) + abs(p - l.second) < abs(l.first - l.second) + EPS;\n}\n\ndouble distanceSP(const line &l, const xy_t &p){\n  xy_t r = projection(l, p);\n  if(intersectSP(l, r)) return abs(r - p);\n  else return min(abs(l.first - p), abs(l.second - p));\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return 1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n \nxy_t p[3];\nline l[3];\nxy_t c;\ndouble r;\n\n\nint main(){\n  int x, y;\n  int c1, c2;\n  while(cin >> x>> y && (x || y)){\n    p[0] = xy_t(x, y);\n    for(int i = 1; i < 3; i++) {\n      cin >> x >> y;\n      p[i] = xy_t(x, y);\n    }\n    cin >> x >> y;\n    cin >> r;\n    c = xy_t(x, y);\n    \n    rep(i, 3) l[i] = line(p[i], p[(i+1)%3]);\n    c1 = 0, c2 = 0;\n    int cnt = 0;\n\n    rep(i, 3){\n      int d = ccw(p[i], p[(i+1)%3], c);\n      if(d > 0) c1++;\n      if(d < 0) c2++;\n    }\n    bool circle_in[3];\n    rep(i, 3){\n      if(distanceSP(l[i], c) > r - EPS){\n\tcircle_in[i] = true;\n      }else{\n\tcircle_in[i] = false;\n\tcnt++;\n      }\n    }\n    \n    bool t_in[3];\n    rep(i, 3){\n      if(abs(c - p[i]) < r + EPS){\n\tt_in[i] = true;\n\tcnt++;\n      }else{\n\tt_in[i] = false;\n      }\n    }\n    if(circle_in[0] && circle_in[1] && circle_in[2] && max(c1, c2) == 3){\n      cout << 'a' << endl;\n    }else if(t_in[0] && t_in[1] && t_in[2]) {\n      cout << 'b' << endl;\n    }else if(cnt > 0){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))){\n\t\t\tif(isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t\t}\n\t\t\t//\n\t\t\telse{\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t\t}\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + P(2,0) * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n#define curr(P, i) Pt[i]\n#define next(P, i) Pt[(i+1)%Pt.size()]\nenum { OUT, ON, IN };\nint contains(const G& Pt, const P& p) {\n  bool in = false;\n  for (int i = 0; i < Pt.size(); ++i) {\n    P a = curr(P,i) - p, b = next(P,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\nint main(){\n\tdouble x1,y1,x2,y2,x3,y3,cx,cy,r;\n\twhile(cin>>x1>>y1>>x2>>y2>>x3>>y3>>cx>>cy>>r,x1||y1){\n\t\tP pA(x1,y1),pB(x2,y2),pC(x3,y3),pO(cx,cy);\n\t\tL c(pA,pB),a(pB,pC),b(pC,pA);\n\t\tC Circle(pO,r);\n\t\tG ABC; ABC.push_back(pA),ABC.push_back(pB),ABC.push_back(pC);\n\t\t\n\t\tif(!ccw(pA,pB,pC))swap(ABC[0],ABC[2]);\n\t\tbool ct=contains(ABC,pO);\n\t\t\n\t\t\n\t\tif(r*r+EPS>max(max(norm(pA-pO),norm(pB-pO)),norm(pC-pO))){\n\t\t\tcout<<\"b\"; goto NEXT;\n\t\t}\n\t\tif(ct&&min(min(distanceSP(a,pO),distanceSP(b,pO)),distanceSP(c,pO))>r-EPS){\n\t\t\tcout<<\"a\"; goto NEXT;\n\t\t}\n\t\tif(distanceSP(a,pO)<r+EPS||distanceSP(b,pO)<r+EPS||distanceSP(c,pO)<r+EPS){\n\t\t\tcout<<\"c\"; goto NEXT;\n\t\t}\n\t\tcout<<\"d\";\n\t\t\n\t\tNEXT:\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nconst double EPS = 1e-8;\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\ntypedef complex<double> P;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) { return abs(p - projection(l, p)); }\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//-1 ???????????????\n//0 ??\\??????\n//1 ???????????§????????????\n//2 ???????????§????????????\nint intersectSC(const L &s, const C &c) {\n  int ins = 0;\n  for(int i = 0; i < 2; i++ ) {\n    if (abs(s[i]-c.p)<c.r) ins++;\n    else if (EQ(abs(s[i]-c.p), c.r)) return 0;\n  }\n  if (ins == 2) return -1;\n  if (ins == 1) return 1;\n  double d = distanceLP(s, c.p);\n  if (d-c.r > EPS) return -1;\n  P nor=(s[0]-s[1]) * P(0, 1);\n  if (ccw(c.p, c.p+nor, s[0]) * ccw(c.p, c.p+nor, s[1]) < 0) return 2;\n  return -1;\n}\n\nenum { OUT, ON, IN };\nint contains(const vector<P> &g, const P &p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool inputP(P &p){\n  int x, y; cin >>x >>y;\n  if(x == 0 && y == 0) return false;\n  p = P(x, y);\n  return true;\n}\n\nchar solve(vector<P> &t, P c, int r){\n    double d[3];\n    REP(i, 3) d[i] = abs(c - t[i]);\n    if(d[0] >= r && d[1] >= r && d[2] >= r && contains(t, c) == IN) return 'a';\n    if(d[0] <= r && d[1] <= r && d[2] <= r) return 'b';\n    REP(i, 3) if(intersectSC(L(t[i], next(t, i)), C(c, r)) > -1) return 'c';\n    return 'd';\n}\n\nint main(){\n  vector<P> t(3);\n  P c;\n  int r;\n  while(inputP(t[0])){\n    FOR(i, 1, 3) inputP(t[i]);\n    inputP(c); cin >>r;\n    cout <<solve(t, c, r) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <complex>\n#include <algorithm>\n#define Point complex<long double>\n#define px real()\n#define py imag()\nusing namespace std;\n// ------ Classes ------ //\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tLine(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Line& s1, const Line& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Line& s1, const Line& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return - 2;\n\treturn 0;\n}\nbool its(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool its(Segment s1, Segment s2) {\n\treturn its(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Line& a, const Point& b) {\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nlong double dst(const Segment& a, const Segment& b) {\n\tif (its(a, b)) return 0;\n\treturn min( { dst(a, b.p1), dst(a, b.p2), dst(b, a.p1), dst(b, a.p2) });\n}\nint xa, ya, xb, yb, xc, yc, xd, yd, r;\nint main() {\n\twhile(true) {\n\t\tscanf(\"%d%d\", &xa, &ya);\n\t\tif(xa == 0 && ya == 0) break;\n\t\tscanf(\"%d%d%d%d%d%d%d\", &xb, &yb, &xc, &yc, &xd, &yd, &r);\n\t\tPoint p1(xa, ya), p2(xb, yb), p3(xc, yc), p4(xd, yd);\n\t\tSegment s1(p1, p2), s2(p2, p3), s3(p3, p1);\n\t\tif(dst(s1, p4) <= r && dst(s2, p4) <= r && dst(s3, p4) <= r) printf(\"a\\n\");\n\t\telse if(dst(p1, p4) <= r && dst(p2, p4) <= r && dst(p3, p4) <= r) printf(\"b\\n\");\n\t\telse if(dst(p1, p4) <= r || dst(p2, p4) <= r || dst(p3, p4) <= r) printf(\"c\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nusing R = long double;\nconstexpr R pi = acos((R)-1), eps = 1e-8;\n\nint sgn(R a) { return (a > eps) - (a < -eps); }\nint sgn(R a, R b) { return sgn(a - b); }\nusing P = complex<R>;\nistream& operator>>(istream& i, P& p) { R x, y; i >> x >> y; p = P(x, y); return i; }\nostream& operator<<(ostream& o, P p) { return o << fixed << setprecision(15) << real(p) << ' ' << imag(p); }\nbool cmp(P p, P q) { return 2 * sgn(real(p), real(q)) + sgn(imag(p), imag(q)) < 0; }\nbool eql(P p, P q) { return !cmp(p, q) and !cmp(q, p); }\nR dot(P p, P q) { return real(conj(p) * q); }\nR crs(P p, P q) { return imag(conj(p) * q); }\n// -2: back, -1: cw, 0: on, 1: ccw, 2: front\nint ccw(P p, P q) {\n  int s = sgn(crs(p, q));\n  if (s) return s;\n  if (dot(p, q) < 0) return -2;\n  if (dot(p, q - p) > 0) return 2;\n  return 0;\n}\nint ccw(P o, P p, P q) { return ccw(p - o, q - o); }\nstruct L {\n  P s, t;\n  P vec() const { return t - s; }\n  R abs() const { return std::abs(vec()); }\n  R arg() const { return std::arg(vec()); }\n};\nint ccw(L s, P p) { return ccw(s.s, s.t, p); }\n\nP proj(P p, L l) {\n  P e = l.vec() / l.abs();\n  return l.s + dot(p - l.s, e) * e;\n}\nP refl(P p, L l) { return (R)2 * proj(p, l) - p; }\nR distPP(P p, P q) { return abs(q - p); }\nR distPL(P p, L l) { return distPP(p, proj(p, l)); }\nR distPS(P p, L s) {\n  P q = proj(p, s);\n  if (!ccw(s, q)) return distPP(p, q);\n  return min(distPP(p, s.s), distPP(p, s.t));\n}\nR distLL(L l, L m) {\n  if (sgn(crs(l.vec(), m.vec()))) return 0;\n  return distPL(l.s, m);\n}\nR distLS(L l, L s) {\n  if (ccw(l, s.s) * ccw(l, s.t) != 1) return 0;\n  return min(distPL(s.s, l), distPL(s.t, l));\n}\nR distSS(L s, L t) {\n  if (ccw(s, t.s) * ccw(s, t.t) <= 0 and ccw(t, s.s) * ccw(t, s.t) <= 0) return 0;\n  return min({distPS(s.s, t), distPS(s.t, t), distPS(t.s, s), distPS(t.t, s)});\n}\nP intxn(L l, L m) {\n  assert(sgn(crs(l.vec(), m.vec())));\n  return l.s + crs(m.s - l.s, m.vec()) / crs(l.vec(), m.vec()) * l.vec();\n}\n\nusing G = V<P>;\nR area(const G& g) {\n  if (g.size() < 3) return 0;\n  R res = 0;\n  P a = g.back();\n  for (P b : g) {\n    res += crs(a, b) / 2;\n    a = b;\n  }\n  return res;\n}\n// -1: in, 0: on, 1: out\nint contains(const G& g, P p) {\n  assert(g.size() >= 3);\n  int c = 0;\n  P q = p + P(123 * pi, 456), a = g.back();\n  for (P b : g) {\n    if (!ccw(a, b, p)) return 0;\n    if (!sgn(distLS({p, q}, {a, b}))) {\n      c += ccw(p, q, intxn({p, q}, {a, b})) >= 0;\n    }\n    a = b;\n  }\n  return c & 1 ? -1 : 1;\n}\nG half_convex_hull(const V<P>& ps, bool strict) {\n  G g;\n  for (P p : ps) {\n    while (g.size() >= 2) {\n      int c = ccw(g[g.size() - 2], g.back(), p);\n      if (c == 1 or !strict and c == 2) break;\n      g.pop_back();\n    }\n    g.push_back(p);\n  }\n  g.pop_back();\n  return g;\n}\nG convex_hull(V<P> ps, bool strict = true) {\n  sort(begin(ps), end(ps), cmp);\n  ps.erase(unique(begin(ps), end(ps), eql), end(ps));\n  if (ps.size() < 3) return ps;\n  G g = half_convex_hull(ps, strict);\n  reverse(begin(ps), end(ps));\n  G h = half_convex_hull(ps, strict);\n  g.insert(end(g), begin(h), end(h));\n  return g;\n}\nR diameter(const G& g) {\n  auto e = minmax_element(begin(g), end(g), cmp);\n  int n = g.size(), i = e.first - begin(g), j = e.second - begin(g);\n  R res = 0;\n  for (int _ = 0; _ < n; ++_) { // n: 半周, 2n: 一周\n    res = max(res, distPP(g[i], g[j]));\n    int ni = (i + 1) % n, nj = (j + 1) % n;\n    if (sgn(crs(g[ni] - g[i], g[nj] - g[j])) < 0) i = ni;\n    else j = nj;\n  }\n  return res;\n}\n\nstruct C { P o; R r; };\nV<P> intxnCL(C c, L l) {\n  int s = sgn(distPL(c.o, l), c.r);\n  if (s > 0) return {};\n  P p = proj(c.o, l);\n  if (!s) return {p};\n  P q = sqrt(c.r * c.r - norm(p - c.o)) * l.vec() / l.abs();\n  return {p - q, p + q};\n}\nV<P> intxnCC(C c, C d) {\n  R a = distPP(c.o, d.o);\n  if (!sgn(a)) {\n    assert(sgn(c.r, d.r));\n    return {};\n  }\n  P p = polar(c.r / a, acos((a * a + c.r * c.r - d.r * d.r) / (2 * a * c.r)));\n  return {c.o + conj(p) * (d.o - c.o), c.o + p * (d.o - c.o)};\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    P p; cin >> p;\n    if (eql(p, {0, 0})) break;\n    P q, r; cin >> q >> r;\n    C c; cin >> c.o >> c.r;\n    R pq = distPS(c.o, {p, q});\n    R pr = distPS(c.o, {p, r});\n    R qr = distPS(c.o, {q, r});\n    if (sgn(max({distPP(c.o, p), distPP(c.o, q), distPP(c.o, r)}), c.r) <= 0) cout << 'b' << '\\n';\n    else if (contains({p, q, r}, c.o) <= 0 and sgn(c.r, min({pq, pr, qr})) <= 0) cout << 'a' << '\\n';\n    else if (contains({p, q, r}, c.o) == 1 and sgn(c.r, min({pq, pr, qr})) < 0) cout << 'd' << '\\n';\n    else cout << 'c' << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1 + (a2 - a1) * (cross(b2 - b1,b1 - a1) / cross(b2 - b1,a2 - a1));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    point r=intersection_l(a1,a2,b1,b2);\n    return is_point_on_line(a1,a2,r) && is_point_on_line(b1,b2,r);\n  }\n\n}\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\n  point a,b;\n  a=b=p;\n  b.x=100001;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n  \n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n    \n  return (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\n  double ans=0;\n  int tsz=t.size();\n\n  for(int i=0;i<tsz;i++){\n    double tmp=dist(t[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,t,tsz);\n  double res2=DBL_MAX;\n\n  t.push_back(t[0]);\n\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p;\n  vector<point> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    t.clear();\n    for(int i=0;i<3;i++){\n      cin >> p.x >> p.y;\n      if(p.x==0 && p.y==0)return 0;\n      t.push_back(p);\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(t,C);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n            ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\n  point a,b;\n  a=b=p;\n  b.x=100000;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n  \n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n    \n  return (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\n  double ans=0;\n  int tsz=t.size();\n\n  for(int i=0;i<tsz;i++){\n    double tmp=dist(t[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,t,tsz);\n  double res2=DBL_MAX;\n\n  t.push_back(t[0]);\n\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p;\n  vector<point> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    t.clear();\n    for(int i=0;i<3;i++){\n      cin >> p.x >> p.y;\n      if(p.x==0 && p.y==0)return 0;\n      t.push_back(p);\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(t,C);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\nconst double EPS = 1e-10;\n\ndouble cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\nxy_t projection(const line &l, const xy_t &p){\n  double t = dot(l.second - l.first, p - l.first) / norm(l.second - l.first);\n  return l.first + t * (l.second - l.first);\n}\n\nbool intersectSP(const line &l, const xy_t &p){\n  if(abs(p - l.first) + abs(p - l.second) < abs(l.first - l.second) + EPS) return true;\n  else return false;\n}\n\ndouble distanceSP(const line &l, const xy_t &p){\n  xy_t r = projection(l, p);\n  if(intersectSP(l, r)) return abs(r - p);\n  else return min(abs(l.first - p), abs(l.second - p));\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return 1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n \nxy_t p[3];\nline l[3];\nxy_t c;\ndouble r;\n\n\nint main(){\n  int x, y;\n  int c1, c2;\n  while(cin >> x>> y && (x || y)){\n    p[0] = xy_t(x, y);\n    for(int i = 1; i < 3; i++) {\n      cin >> x >> y;\n      p[i] = xy_t(x, y);\n    }\n    cin >> x >> y;\n    cin >> r;\n    c = xy_t(x, y);\n    \n    rep(i, 3) l[i] = line(p[i], p[(i+1)%3]);\n    c1 = 0, c2 = 0;\n    int cnt = 0;\n\n    rep(i, 3){\n      int d = ccw(p[i], p[(i+1)%3], c);\n      if(d >= 0) c1++;\n      if(d <= 0) c2++;\n    }\n    bool circle_in[3];\n    rep(i, 3){\n      if(distanceSP(l[i], c) > r - EPS){\n\tcircle_in[i] = true;\n      }else{\n\tcircle_in[i] = false;\n      }\n    }\n    \n    bool t_in[3];\n    rep(i, 3){\n      if(abs(c - p[i]) < r + EPS){\n\tt_in[i] = true;\n\tcnt++;\n      }else{\n\tt_in[i] = false;\n      }\n    }\n    if(circle_in[0] && circle_in[1] && circle_in[2] && max(c1, c2) == 3){\n      cout << 'a' << endl;\n    }else if(t_in[0] && t_in[1] && t_in[2]) {\n      cout << 'b' << endl;\n    }else if(cnt > 0){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-b,ar=d-a;\n\tP bb=b-c,br=d-b;\n\tP cc=c-a,cr=d-c;\n\tdouble a2=cross(aa,ar),b2=cross(bb,br),c2=cross(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nbool foo2(P a,P b,P p,double r){\n\tdouble t=dot(b-a,p-a);\n\tif(t<-EPS){\n\t\t// cout<<\"a\"<<endl;\n\t\tif(r-abs(p-a)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tif(t-abs(b-a)*abs(b-a)>EPS){\n\t\t// cout<<\"b\"<<endl;\n\t\tif(r-abs(p-b)>-EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t// cout<<\"c\"<<endl;\n\tdouble h=abs(p-a)*abs(p-a)-t*t/abs(b-a)/abs(b-a);\n\t// printf(\"%.6lf\\n\",h);\n\tif(h-r*r>EPS){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tP zz[3];\n\t\trep(i,3) zz[i]=z[i];\n\t\tcin>>r;\n\t\tif(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(r-t>-EPS){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(foo2(z[0],z[1],z[3],r)||foo2(z[1],z[2],z[3],r)||foo2(z[2],z[0],z[3],r)){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout<<\"d\\n\";\n\t\t}\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n\t// cout<<abs(P(0,0)-P(1,1))<<endl;\n}\n\n\n\n}\nmain() try{\n\t// vector<P> d;\n\t// double r;\n\t// rep(i,3){\n\t\t// double x,y;\n\t\t// cin>>x>>y;\n\t\t// d.PB(P(x,y));\n\t// }\n\t// cin>>r;\n\t// cout<<foo2(d[0],d[1],d[2],r)<<endl;\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef long double Double;\ntypedef complex<Double> P;\n#define Y imag()\n#define X real()\nconst Double EPS = (long double) 1 * 1e-12;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nDouble get(P a[3]){\n\tDouble A = abs(a[0]-a[1]);\n\tDouble B = abs(a[1]-a[2]);\n\tDouble C = abs(a[2]-a[0]);\n\tDouble s = (A+B+C) / 2.0;\n\tDouble S = sqrt( s * (s-A) * (s-B) * (s-C) );\n\treturn S;\n}\nDouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \nDouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {Double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nDouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;Double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tDouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\tbool in = abs(S) < EPS;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) < r || getPedal(L(a[1],a[2]),c) < r || getPedal(L(a[0],a[2]),c) < r;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) < r*r && nijo(a[1]-c) < r*r && nijo(a[2]-c) < r*r) cout << \"b\" << endl;\n\t\telse if(in && !hit) cout << \"a\" << endl;\n\t\telse if(hit) cout << \"c\" << endl;\n\t\telse cout << \"d\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-1;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) <= c.r ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n\tif( ctt >= 1 ) return 2;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r + kyuriEPS ){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs( (t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x) );\n\t}\n\t//std::cout << area << \" \" << tS2 << std::endl;\n\t\n\tif( fabs( fabs(area) - tS2 ) == 0 ) return 0; \t\n\t\n\treturn 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& _p, double _r) : p(_p), r(_r) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0 && d1 * d2 > 0 && d2 * d0 > 0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(6);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL l1(tr[1], tr[2]);\n\tL l2(tr[2], tr[0]);\n\td[3] = distP2LS(cc.p, l0);\n\td[4] = distP2LS(cc.p, l1);\n\td[5] = distP2LS(cc.p, l2);\n\tif(in && d[3] >= cc.r && d[4] >= cc.r && d[5] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tsort(d.begin(), d.end());\n\tif(d[0] <= cc.r) {\n\t\tprintf(\"c\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect\n\tprintf(\"d\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool is_inner(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  return (dot(b,c) <= 0);\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool onLine(const Line &l, const Point &p) {\n  Point pj = projection(l,p);\n  // cout << pj.real() << \" \"<< pj.imag() << endl;\n  // cout << \"ccw \" << ccw(l[0],l[1],pj) << endl;\n  return is_inner(pj,l[0],l[1]);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point> ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool is_convex_hull(vector<Point>& ps,const Point& c){\n  for(int i=0;i<ps.size();i++){\n    if(is_equal(ps[i],c)) return true;\n  }\n  return false;\n}\n\nint main(){\n  double x[4];\n  double y[4];\n  while(~scanf(\"%lf %lf\",&x[0],&y[0])){\n    if(is_equal(Point(x[0],y[0]),Point(0.0,0.0))) break;\n\n    for(int i=1;i<4;i++){\n      scanf(\"%lf %lf\",&x[i],&y[i]);\n    }\n    double r;\n    scanf(\"%lf\",&r);\n\n    vector<Line> lines;\n    vector<Point> points;\n\n    for(int i=0;i<4;i++){\n      points.push_back(Point(x[i],y[i]));\n    }\n\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        lines.push_back(Line(Point(x[i],y[i]),Point(x[j],y[j])));\n      }\n    }\n\n    vector<Point> convex_hull = compute_convex_hull(points);\n\n    if(!is_convex_hull(convex_hull,points[3])){\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n      }\n      \n      if(r <= dist + EPS){\n        //a\n        printf(\"a\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n        }\n        if(r >= dist - EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n      }\n    }\n    else {\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        if(onLine(lines[i],Point(x[3],y[3]))){\n          dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n          // cout << dist << endl;\n        }\n      }\n      for(int i=0;i<3;i++){\n        dist = min(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n      }\n      \n      if(dist > r){\n        //d\n        // cout << dist << endl;\n        printf(\"d\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n          // cout << points[i].imag() << \" \" << points[i].real() << endl;\n          // cout << points[3].imag() << \" \" << points[3].real() << endl;\n          // cout << dist << endl;\n        }\n        \n        if(r >= dist - EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          // cout << dist << endl;\n          printf(\"c\\n\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-c,ar=d-a;\n\tP bb=b-a,br=d-b;\n\tP cc=c-b,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nvoid mainmain(){\n\tint r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tcin>>r;\n\t\t// cout<<r<<endl;\n\t\tbool f=false;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(t>r){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=true;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\telse if(r>abs(z[0]-z[3])&&r>abs(z[1]-z[3])&&r>abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t}\n\t\telse if(r>abs(z[0]-z[3])||r>abs(z[1]-z[3])||r>abs(z[2]-z[3])){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse cout<<\"d\\n\";\t\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef long double Double;\ntypedef complex<Double> P;\n#define Y imag()\n#define X real()\nconst Double EPS = (long double) 1 * 1e-12;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nDouble get(P b[3]){\n\tP a[3];\n\tfor(int i = 0 ; i < 3 ; i++) a[i] = b[i];\n\ta[0] -= a[2];\n\ta[1] -= a[2];\n\treturn 0.5 * abs( a[0].X * a[1].Y - a[1].X * a[0].Y );\n}\n\n\nDouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \nDouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {Double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\n\nDouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;Double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tDouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\t//cout << S << endl;\n\t\tbool in = S == 0;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) < r || getPedal(L(a[1],a[2]),c) < r || getPedal(L(a[0],a[2]),c) < r;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) <= r*r && nijo(a[1]-c) <= r*r && nijo(a[2]-c) <= r*r) cout << \"b\" << endl;\n\t\telse if(in && !hit) cout << \"a\" << endl;\n\t\telse if(hit) cout << \"c\" << endl;\n\t\telse cout << \"d\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint sig(double r) { return r < -EPS ? -1 : r > EPS ? 1 : 0; }\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {}\n\tP operator+(const P &a) const { return P(x + a.x, y + a.y); }\n\tP operator-(const P &a) const { return P(x - a.x, y - a.y); }\n\tP operator*(const P &a) const { return P(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(const double &k) const { return P(x * k, y * k); }\n\tP operator/(const double &k) const { return P(x / k, y / k); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble abs() const { return sqrt(abs2()); }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const P &a) const { return x * a.x + y * a.y; }\n\tdouble det(const P &a) const { return x * a.y - y * a.x; }\n\tP proj(const P &a) const { double k = dot(a) / abs2(); return P(x * k, y * k); }\n\tbool operator<(const P &a) const { return x != a.x ? x < a.x : y < a.y; }\n\tbool operator==(const P &a) const { return sig(x - a.x) == 0 && sig(y - a.y) == 0; }\n};\n\nostream &operator<<(ostream&os, const P&a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\n\nstruct L {\n\tP a, b;\n\tL() {}\n\tL(P a, P b) : a(a), b(b) {}\n\tP vec() const { return b - a; }\n\tP proj(const P &p) const { return a + vec().proj(p - a); }\n\tP refl(const P &p) const { return proj(p) * 2 - p; }\n\tint iSP(const P &p) const {\n\t\tint s = sig(vec().det(p - a));\n\t\tif (s != 0) return s;\n\t\tif (sig(vec().dot(p - a)) < 0) return -2;\n\t\tif (sig(vec().dot(p - b)) < 0) return 2;\n\t\treturn 0;\n\t}\n\tint iLL(const L &l) const {\n\t\tif (sig(vec().det(l.vec()))) return 1;\n\t\tif (sig(vec().det(l.a - a))) return 0;\n\t\treturn -1;\n\t}\n\tbool iLS(const L &l) const { return sig(tri(a, b, l.a)) * sig(tri(a, b, l.b)) <= 0; }\n\tbool iSS(const L &l) const { return iLS(l) && l.iLS(*this); }\n\tP pLL(const L &l) const { return a + vec() * (l.a - a).det(l.vec()) / b.det(l.vec()); }\n\tdouble dLP(const P &p) const { return abs(tri(a, b, p)) / vec().abs(); }\n\tdouble dSP(const P &p) const {\n\t\tif (sig(vec().dot(p - a)) <= 0) return (p - a).abs();\n\t\tif (sig(vec().dot(p - b)) >= 0) return (p - b).abs();\n\t\treturn dLP(p);\n\t}\n\tdouble dLL(const L &l) const { return iLL(l) ? 0 : dLP(l.a); }\n\tdouble dLS(const L &l) const { return iLS(l) ? 0 : min(dLP(l.a), dLP(l.b)); }\n\tdouble dSS(const L &l) const { return iSS(l) ? 0 : min(min(dSP(l.a), dSP(l.b)), min(l.dSP(a), l.dSP(b))); }\n};\n\nstruct C {\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p, double r) : p(p), r(r) {}\n\tint iCC(C c) {\n\t\tdouble d = (c.p - p).abs();\n\t\tif (sig(d) == 0 && sig(r - c.r) == 0) return -1;\n\t\tif (sig(r - c.r - d) > 0) return 2;\n\t\tif (sig(c.r - r - d) > 0) return -2;\n\t\treturn (sig(r + c.r - d) >= 0) ? 1 : 0;\n\t}\n\tbool iCS(L l) {\n\t\treturn (sig(r - l.dSP(p)) >= 0&& sig(r - max((l.a - p).abs(), (l.b - p).abs())) <= 0);\n\t}\n\tpair<P,P> pCC(C c) {\n\t\tdouble d = (c.p - p).abs();\n\t\tdouble x = (d * d + r * r - c.r * c.r) / (d * 2);\n\t\tP e = (c.p - p) / d, w = e * P(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\t\treturn make_pair(p + e * x - w, p + e * x + w);\n\t}\n\tpair<P,P> pCL(L l) {\n\t\tP h = l.proj(p);\n\t\tdouble d = (h - p).abs();\n\t\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\t\tP e = (l.b - l.a) / (l.b - l.a).abs();\n\t\treturn make_pair(h - e * y, h + e * y);\n\t}\n\tpair<P,P> tCP(P p) {\n\t\tdouble d2 = (p - this->p).abs2();\n\t\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\t\tP h = this->p + (p - this->p) * (r * r / d2);\n\t\tP w = (p - this->p) * P(0, 1) * (x * r / d2);\n\t\treturn make_pair(h - w, h + w);\n\t}\n\tdouble aCC(C c) {\n\t\tdouble d = (p - c.p).abs();\n\t\tif (sig(r - c.r - d) >= 0) return c.r * c.r * PI;\n\t\tif (sig(c.r - r - d) >= 0) return r * r * PI;\n\t\tif (sig(r + c.r - d) <= 0) return 0;\n\t\tdouble x = (d * d + r * r - c.r * c.r) / (d * 2);\n\t\tdouble h = sqrt(r * r - x * x);\n\t\treturn r * r * atan2(h, x) + c.r * c.r * atan2(h, d - x) - d * h; \n\t}\n};\n\n\nint main() {\n\tint x[3], y[3];\n\tint xx, yy, r;\n\tP p[3],g;\n\tL s[3];\n\tC c;\n\tIL {\n\t\tcin >> x[0] >> y[0];\n\t\tif (x[0] == 0 && y[0] == 0) break;\n\t\tcin >> x[1] >> y[1];\n\t\tcin >> x[2] >> y[2];\n\t\tcin >> xx >> yy;\n\t\tcin >> r;\n\t\trep(i, 3) p[i] = P(x[i], y[i]);\n\t\tg = (p[0] + p[1] + p[2]) / 3;\n\t\trep(i, 3) s[i] = L(p[i], p[(i+1)%3]);\n\t\tc = C(P(xx, yy), r);\n\t\tif (!(L(g, c.p)).iSS(s[0]) && !(L(g, c.p)).iSS(s[1]) && !(L(g, c.p)).iSS(s[2]) && sig(s[0].dSP(c.p) - c.r) > 0 && sig(s[1].dSP(c.p) - c.r) > 0 && sig(s[2].dSP(c.p) - c.r) > 0) {\n\t\t\tcout << \"a\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sig((c.p - p[0]).abs() - r) < 0 && sig((c.p - p[1]).abs() - r) < 0 && sig((c.p - p[2]).abs() - r) < 0) {\n\t\t\tcout << \"b\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sig(s[0].dSP(c.p) - c.r) <= 0 || sig(s[1].dSP(c.p) - c.r) <= 0 || sig(s[2].dSP(c.p) - c.r) <= 0) {\n\t\t\tcout << \"c\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"d\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n      getline(cin, str);\n\n      if(i == 0 && str == \"0 0\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\") break;\n\n\n    if(distance(&d->p[0], &c->p) < c->radius&& distance(&d->p[1], &c->p) < c->radius&& distance(&d->p[2], &c->p) < c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) > c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) > c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) > c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) < distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) < distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) < distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else if(dist_line(&d->p[0], &d->p[1], &d->p[2]) > distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) > distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) > distance(&d->p[2], &c->p))\n            cout << 'a' << endl;\n        else\n          cout << 'c' << endl;\n    }\n    else{\n      cout << 'c' << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define EPS (1e-8)\n\ntypedef complex<double> P;\ntypedef P Vec;\n\nstruct Line {\n\tP p;\n\tVec v;\n\t\n\tLine() {}\n\tLine(P p, Vec v) : p(p), v(v) {}\n\t\n\tP getPoint(double t) {\n\t\treturn p + v * t;\n\t}\n};\n\nstruct Circle {\n\tP p;\n\tdouble r;\n\t\n\tCircle() {}\n\tCircle(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot(Vec a, Vec b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Vec a, Vec b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool isInCir(Circle &c, P &p) {\n\treturn norm(c.p - p) <= c.r*c.r + EPS;\n}\n\nbool isInSeg(Line &s, P &p) {\n\tVec a = s.v, b = p - s.p;\n\tdouble l1 = abs(a), l2 = abs(b);\n\t\n\treturn dot(a, b) >= l1*l2 - EPS && dot(a, b) <= l1*l2 + EPS && l1 >= l2 - EPS;\n}\n\nbool isInTri(P &a, P &b, P &c, P &d) {\n\tP p[4];\n\tp[0] = a; p[1] = b; p[2] = c; p[3] = d;\n\t\n\tint cnt = 0;\n\tREP(i, 3) {\n\t\tVec v = p[3] - p[i];\n\t\tLine s(p[i], p[(i + 1) % 3] - p[i]);\n\t\t\n\t\tif (isInSeg(s, p[3])) return true;\n\t\tif (cross(s.v, v) < -EPS) cnt++;\n\t}\n\treturn (cnt == 0 || cnt == 3);\n}\n\ndouble distanceSP(Line &s, P &p) {\n\tVec a = s.v, b = p - s.p;\n\treturn abs(cross(a, b)) / abs(a);\n}\n\nint main() {\n\tdouble x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile (cin >> x1 >> y1, x1 || y1) {\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\t\n\t\tP p[4] = {P(x1, y1), P(x2, y2), P(x3, y3), P(x4, y4)};\n\t\tLine segment[3] = {Line(p[0], p[1] - p[0]), Line(p[1], p[2] - p[1]), Line(p[2], p[0] - p[2])};\n\t\tCircle c(p[3], r);\n\t\t\n\t\tif ( isInTri(p[0], p[1], p[2], p[3]) &&\n\t\t\t distanceSP(segment[0], c.p) >= c.r - EPS &&\n\t\t\t distanceSP(segment[1], c.p) >= c.r - EPS &&\n\t\t\t distanceSP(segment[2], c.p) >= c.r - EPS )\n\t\t\tputs(\"a\");\n\t\telse if ( isInCir(c, p[0]) && isInCir(c, p[1]) && isInCir(c, p[2]) )\n\t\t\tputs(\"b\");\n\t\telse if ( isInCir(c, p[0]) || isInCir(c, p[1]) || isInCir(c, p[2]) )\n\t\t\tputs(\"c\");\n\t\telse\n\t\t\tputs(\"d\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r+EPS)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    double ans=0;\n    for(int i=0;i<3;i++){\n\tint tmp=dist(p[i],C.p);\n\tif(tmp>ans){\n\t  ans=tmp;\n\t}\n    }\n    if(C.r>ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n    \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=100000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P p, const P q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P p, const P q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& p_, double r_) : p(p_), r(r_) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\tif(nm == 0.0) return min(distP2P(p, l[0]), distP2P(p, l[1]));\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0.0 && d1 * d2 > 0.0 && d2 * d0 > 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(3);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL r0(tr[1], tr[0]);\n\tL l1(tr[1], tr[2]);\n\tL r1(tr[2], tr[1]);\n\tL l2(tr[2], tr[0]);\n\tL r2(tr[0], tr[2]);\n\td[0] = max(distP2LS(cc.p, l0), distP2LS(cc.p, r0));\n\td[1] = max(distP2LS(cc.p, l1), distP2LS(cc.p, r1));\n\td[2] = max(distP2LS(cc.p, l2), distP2LS(cc.p, r2));\n\tif(in && d[0] >= cc.r && d[1] >= cc.r && d[2] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect ?\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\nif(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\nreturn a+b;\n}\n\nstruct point{\ndouble x, y;\npoint(){}\npoint(double x,double y) : x(x) , y(y){}\n\npoint operator + (point p){\nreturn point(add(x,p.x), add(y,p.y));\n}\n\npoint operator - (point p){\nreturn point(add(x,-p.x), add(y,-p.y));\n}\n\npoint operator * (double d){\nreturn point(x*d,y*d);\n}\n\npoint operator / (double d){\nreturn point(x/d,y/d);\n}\n\nbool operator == ( const point &p ) const {\nreturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n}\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\nreturn sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\nif ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\nif ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\nreturn abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\nreturn sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\nreturn cross(b-a, c-a)==0.0 &&\n(dot(b-a, c-a) > -EPS) &&\n(dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\nif(cross(a1-a2,b1-b2)==0){\nreturn is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2)\n|| is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n}\nelse {\nreturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n}\n\nint crossCS(point a, point b, circle c){\ndouble res=distance_ls_p(a,b,c.p);\ndouble ac=dist(a,c.p);\ndouble bc=dist(b,c.p);\n\nif(res>c.r || (ac<c.r && bc<c.r))return 0;\nelse if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\nelse return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\npoint a,b;\na=b=p;\nb.x=DBL_MAX;\nps.push_back(ps[0]);\ndouble ymx=-DBL_MAX,ymn=DBL_MAX;\nfor(int i=0;i ymx=max(ymx,ps[i].y);\nymn=min(ymn,ps[i].y);\n}\nif(a.y<=ymn||a.y>=ymx)return 0;\n\nfor(int i=0;i<n;i++){\nif(is_point_on_line(ps[i],ps[i+1],p))return 1;\n}\n\nint cnt1=0;\nfor(int i=0;i<n;i++)\nif(is_point_on_line(a,b,ps[i]))cnt1++;\n\nint cnt=0;\nfor(int i=0;i<n;i++)\nif(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n\nreturn (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\ndouble ans=0;\nint tsz=t.size();\n\nfor(int i=0;i<tsz;i++){\ndouble tmp=dist(t[i],C.p);\nif(tmp>ans)ans=tmp;\n}\n\nif(C.r>=ans)return 2;\n\nint res1=inside(C.p,t,tsz);\ndouble res2=DBL_MAX;\n\nt.push_back(t[0]);\n\nfor(int i=0;i<tsz;i++)\nres2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\nif(res1 && C.r<=res2)return 1;\nelse if(!res1 && C.r else return 3;\n}\n\nint main(void){\npoint p;\nvector t;\ncircle C;\nstring ans=\"zabcd\";\n\nwhile(true){\nt.clear();\nfor(int i=0;i<3;i++){\ncin >> p.x >> p.y;\nif(p.x==0 && p.y==0)return 0;\nt.push_back(p);\n}\ncin >> C.p.x >> C.p.y >> C.r;\n\nint res=crossCP(t,C);\ncout << ans[res] << endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-8\ntypedef long long int lli;\ntypedef complex<lli> C;\n\nC v[4];\nlli r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble zcross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nbool tri_in_check() {\n  C a;\n  lli ina;\n  lli ir2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    ina = norm(a);\n    if (ina > ir2) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool center_in_check() {\n  C a, b;\n  lli cab;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    cab = zcross(a,b);\n    f[i] = (cab > 0);\n    if (cab*cab < norm(a)*r*r) {\n      return false;\n    }\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double sd, s, t;\n  long long int ina, inb, idab, id;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    ina = norm(a);\n    inb = norm(b);\n    idab = dot(a,b);\n    id = idab*idab - ina*(inb-r*r);\n    if (id < 0) {\n      continue;\n    }\n    sd = sqrt((double)id);\n    s = (idab+sd)/ina;\n    t = (idab-sd)/ina;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      if (!id) {\n        contact = true;\n      } else {\n        return 1;\n      }\n    }\n    if (fabs(s)<EPS || fabs(s-1.)<EPS || fabs(t)<EPS || fabs(t-1.)<EPS) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check()) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (t == 0) {\n        if (center_in_check()) {\n          cout << \"a\" << endl;\n        } else {\n          cout << \"c\" << endl;\n        }\n      } else {\n        if (center_in_check()) {\n          cout << \"a\" << endl;\n        } else {\n          cout << \"d\" << endl;\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\n\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n/*\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n*/\n// (B)\nenum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.0153\", \"r\", stdin );\n\tpoint<double> p[3];\n\tcircle<double> c;\n\twhile (cin >> p[0].x >> p[0].y >> p[1].x >> p[1].y >> p[2].x >> p[2].y >> c.c.x >> c.c.y >> c.r && p[0].x != 0. && p[0].y != 0. ){\n\t\tint cnt = ccw (p[0], p[1], c.c ) + ccw (p[1], p[2], c.c ) + ccw (p[2], p[0], c.c );\n\t\tline<double> l1; l1.a = p[0]; l1.b = p[1]; \n\t\tline<double> l2; l2.a = p[1]; l2.b = p[2];\n\t\tline<double> l3; l3.a = p[2]; l3.b = p[0];\n\n\t\t// 円の中心から直線へ降ろした垂線との交点\n\t\tpoint<double> h1 = proj (c.c, l1 );\t\t\n\t\tpoint<double> h2 = proj (c.c, l2 );\n\t\tpoint<double> h3 = proj (c.c, l3 );\t\t\n\t\tif (cnt == 3*CCW || cnt == 3*CW ){\n\t\t\tif (  c.r*c.r < dist2 (h1, c.c ) + EPS \n\t\t\t\t&& c.r*c.r < dist2 (h2, c.c ) + EPS\n\t\t\t\t&& c.r*c.r < dist2 (h3, c.c ) + EPS ){ \t\n\t\t\t\t\tcout << 'a' << endl;\t\t// 円が三角形に含まれる\n\t\t\t\t\tcontinue;\n\t\t\t}// end if\n\t\t} // end if\n\t\tif (  dist2 (p[0], c.c ) < c.r*c.r + EPS \n\t\t\t&& dist2 (p[1], c.c ) < c.r*c.r + EPS\n\t\t\t&& dist2 (p[2], c.c ) < c.r*c.r + EPS ){\n\t\t\t\tcout << 'b' << endl;\t\t// 三角形が円に含まれる\n\t\t\t\tcontinue;\n\t\t} // end if  \n\t\tsegment<double> s1; s1.a = p[0]; s1.b = p[1]; \n\t\tsegment<double> s2; s2.a = p[1]; s2.b = p[2];\n\t\tsegment<double> s3; s3.a = p[2]; s3.b = p[0];\n\t\tif (!intersect (c, s1 ) && !intersect (c, s2 ) && !intersect (c, s3 ) ){\n\t\t\tcout << 'd' << endl;\t\t\t\t// 共通部分がない場合\n\t\t\tcontinue;\n\t\t} // end if\n\t\tcout << 'c' << endl;\t\t\t\t\t// 共通部分がある場合\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\ntypedef struct circle{\n\tpoint p;\n\tdouble r;\n} circle;\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\ncircle make(point p,double r){ circle c;\n\tc.p = p ;\n\tc.r = r;\n\treturn c;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// circle_versino\nint ccw(circle c0,circle c1){\n\tdouble  d = abs(c0.p-c1.p);\n\tdouble r0 = c0.r,r1 = c1.r;\n\t\n\t//c0in c1\n\tif(d<r1-r0)return -2;\n\t//c1 in c0\n\tif(d<r0-r1)return 2;\n\t//c0 cross c1\n\tif(abs(r0-r1)<=d&&d<=r0+r1)return 1;\n\t//c0 not cross c1\n\treturn 0;\n\n}\n\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nint main(){\n\twhile(1){\n\tvector<point> tri(3);\n\ttri[0] = make();\n\tif(tri[0].x==0&&tri[0].y==0)break;\n\ttri[1] = make();\n\ttri[2] = make();\n\tvector<line> l(3);\n\tl[0] = make(tri[0],tri[1]);\n\tl[1] = make(tri[1],tri[2]);\n\tl[2] = make(tri[2],tri[0]);\n\n\tpoint p = make();\n\tdouble r ; cin>>r;\n\tcircle c = make(p,r);\n\t// circle in triangle\n\tif(r<distance(l[0],p)&&r<distance(l[1],p)&&\n\t\t\tr<distance(l[2],p)&&contains(tri,p) ){\n\tcout<<'a'<<endl;\n\tcontinue;\n\t}\n\t// triangle in circle \n\tif(r>distance(tri[0],p)&&r>distance(tri[1],p)&&r>distance(tri[2],p)){\n\tcout<<'b'<<endl;\n\tcontinue;\n\t}\n\t//cross\n\t\n\tif(r>distance(tri[0],p)||r>distance(tri[1],p)||r>distance(tri[2],p)){\n\tcout<<'c'<<endl;\n\tcontinue;\n\t}\n\tcout<<'d'<<endl;\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<double,double> pdd;\nstatic const double EPS = 1e-9;\n\ntemplate<class T>\nT sqr(T obj0) {\n\treturn obj0 * obj0;\n}\n\nbool is_cross(pdd l0, pdd l1, pdd p, double r) {\n\tpdd a,b,c;\n\n\ta.x = l0.x - p.x; a.y = l0.y - p.y;\n\tb.x = l1.x - p.x; b.y = l1.y - p.y;\n\tc.x = a.x - b.x; c.y = a.y - b.y;\n\n\tdouble d0, d1, d2, dist;\n\tdouble h;\n\n\th = abs(a.x * b.y - a.y * b.x) / abs(sqrt(c.x * c.x + c.y * c.y));\n\n\td0 = sqrt(sqr(c.x) + sqr(c.y));\n\td1 = sqrt(sqr(a.x) + sqr(a.y) - sqr(h));\n\td2 = sqrt(sqr(b.x) + sqr(b.y) - sqr(h));\n\n\tif(fabs(d0 - (d1 + d2)) < EPS)\n\t\tdist = h;\n\telse\n\t\tdist = min(sqrt(sqr(a.x) + sqr(a.y)), sqrt(sqr(b.x) + sqr(b.y)));\n\n\tif(dist <= r && r <= max(sqrt(sqr(a.x) + sqr(a.y)), sqrt(sqr(b.x) + sqr(b.y))))\n\t\treturn true;\n\treturn false;\n}\n\nbool in_triangle(vector<pdd> tri, pdd p) {\n\tdouble s, t;\n\tpdd a, b, c;\n\n\ta.x = tri[1].x - tri[0].x; a.y = tri[1].y - tri[0].y;\n\tb.x = tri[2].x - tri[0].x; b.y = tri[2].y - tri[0].y;\n\tc.x = p.x - tri[0].x; c.y = p.y - tri[0].y;\n\n\ts = (c.x * b.y - c.y * b.x) / (a.x * b.y - a.y * b.x);\n\tt = (c.y * a.x - c.x * a.y) / (a.x * b.y - a.y * b.x);\n\n\tif(0 <= s + t && s + t <= 1 && 0 <= s && 0 <= t)\n\t\treturn true;\n\treturn false;\n}\n\n/*\nbool in_circle(vector<pdd> t, pdd p, double r) {\n\tbool flg = true;\n\tfor(int i = 0; i < 3; i++) {\n\t\tdouble tmp;\n\t\ttmp = sqr(t[i].x - p.x) + sqr(t[i].y - p.y);\n\t\tflg &= tmp <= r;\n\t}\n\n\treturn flg;\n}\n*/\n\nint main() {\n\twhile(true) {\n\t\tvector<pdd> tri;\n\t\tpdd c;\n\t\tdouble r;\n\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tdouble tmpx, tmpy;\n\t\t\tcin >> tmpx >> tmpy;\n\t\t\ttri.push_back(pdd(tmpx, tmpy));\n\t\t\tif(i == 0 && tri[0].x == 0 && tri[0].y == 0)\n\t\t\t\tgoto label;\n\t\t}\n\t\tcin >> c.x >> c.y >> r;\n\n\t\tbool flg0, flg1, flg2;\n\t\tflg0 = true;\n\t\tflg1 = false;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tflg0 &= ((sqr(c.x - tri[i].x) + sqr(c.y - tri[i].y)) <= r * r);\n\t\t}\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tflg1 |= is_cross(tri[i % 3], tri[(i + 1) % 3], c, r);\n\t\t}\n\n//\t\tcout << boolalpha << flg0 << \" \" << flg1 << endl;\n\n\t\tif(flg0)\n\t\t\tcout << \"b\" << endl;\n\t\telse if(!flg1 && in_triangle(tri, c))\n\t\t\tcout << \"a\" << endl;\n\t\telse if(flg1)\n\t\t\tcout << \"c\" << endl;\n\t\telse\n\t\t\tcout << \"d\" << endl;\n\t}\nlabel:;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n \n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n \n// ??´?????¨??????\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n \n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n \n// ????????¨???\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n \n \n/* ?????¢????????´?????????????????????????????????????????? */\n \n// ???p?????´???a???????°???±????????????\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n \n// ???p?????´???a??????????°?????????????\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n \nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n \nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n \nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n \nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n \nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n \n// 2??´????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n \n \n/* ??? */\n \nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n \nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // ?????????????????????????????¨????????¢0???????????????OR????????????\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n \nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n \n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n \nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n \n// 2????????????\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n \n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n \n// ???p?????????a????????\\????????\\???\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ????????§NaN???????????????\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n \n// 2????????±?????\\???????????????????????´????????????????????????????????¨?????\\?????¨??????\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // ??????????????\\?????????????????????????????????????????????????????????\n    }\n  }\n  return ls;\n}\n \n// ????§???¢???????????????a,b,c???????????????????????£??????????????????\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n \n// ???a??¨???b?????????????????????r????????????????????????\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // ???????????? !LE(d,r) ??¨?????????1??????????????´????????????\n  D dN = sqrt(r*r - d*d);          // ???????????? max(r*r - d*d, 0) ??¨??????\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n \n// ???a??¨???b??????????????´???l?????\\??????????????????\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n \n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n \n// ??????????????????????°????????????????\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n \n \n/* ????§???¢ */\n \n// ??????????????????sort???max_element????????????\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n \n// ??????\nVP convexHull(VP ps) {  // ????????????????????????????????????????????????VP&???\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // ????¨?????????????????????? == -1 ??¨??????\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \n// ???????????????????????????????????????ccw???????????¨?????? != 1 ??¨??????\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n \n// ???????§???¢????????¨?????????O(n)\n// ?????????????????¨??????1????¢?????????????2????????¨??????0?????????\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 0;  // ?????????????????¨\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\nD dis(P a,P b){\n\treturn sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));\n}\ndouble x1,x2,x3,y4,y2,y3,x,y,r;\nmain(){\n\twhile(cin>>x1>>y4,x1||y4){\n\t\tcin>>x2>>y2>>x3>>y3>>x>>y>>r;\n\t\tvector<P>v;\n\t\tv.push_back(P(x1,y4));\n\t\tv.push_back(P(x2,y2));\n\t\tv.push_back(P(x3,y3));\n\t\tsort(v.begin(),v.end());\n\t\tif(inConvex(P(x,y),v)&&dis(P(x1,y4),P(x,y))+EPS>r&&dis(P(x2,y2),P(x,y))+EPS>r&&dis(P(x3,y3),P(x,y))+EPS>r)cout<<'a'<<endl;\n\t\telse if(dis(P(x1,y4),P(x,y))<r+EPS&&dis(P(x2,y2),P(x,y))<r+EPS&&dis(P(x3,y3),P(x,y))<r+EPS)cout<<'b'<<endl;\n\t\telse if(distSP(P(x1,y4),P(x2,y2),P(x,y))<=r||distSP(P(x3,y3),P(x2,y2),P(x,y))<=r||distSP(P(x1,y4),P(x3,y3),P(x,y))<=r)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nstruct Circle;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l); // 誤差の検証をしていない\nbool intersect(Circle c1, Circle c2); // 誤差の検証をしていない\n\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point,Point> getCrossPoints(Circle c, Line l);\npair<Point,Point> getCrossPoints(Circle c1, Circle c2); // 誤差の検証をしていない\npair<Point,Point> getContactPoints(Circle c, Point p); // 接点 点は円の外部\n\ndouble area(Polygon g); // convexでなくてもよい. absを消せば符号付き面積\nbool isConvex(Polygon g); // O(n^2) 線形時間アルゴリズムが存在するらしい\nint contains(Polygon g, Point p);\n\ndouble arg(Vector p);   // 偏角\nVector polar(double a, double r); // 極座標系->ベクトル\n\nPolygon andrewScan(Polygon g); // 凸包の辺上の点も含めたければ!=CLOCKWISEを==COUNTER_CLOCKWISEに\ndouble convexDiameter(Polygon g); // gはconvex \n\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l){\n    return getDistanceLP(l, c.c) < c.r+EPS;\n}\nbool intersect(Circle c1, Circle c2){\n    return abs(c1.r-c2.r) <= getDistance(c1.c, c2.c) && getDistance(c1.c, c2.c) < c1.r+c2.r+EPS;\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1-s2.p1));\n    double d2 = abs(cross(base, s1.p2-s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point,Point> getCrossPoints(Circle c, Line l){\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n    assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos( (c1.r*c1.r + d*d - c2.r*c2.r)/(2*c1.r*d) );\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\npair<Point,Point> getContactPoints(Circle c, Point p){\n    assert(c.r < getDistance(c.c, p));\n    double d = getDistance(c.c, p);\n    return getCrossPoints(c, Circle(p, sqrt(d*d-c.r*c.r)));\n}\n\ndouble area(Polygon g){\n    if(g.size() < 3)    return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for(int i = 0; i < n; i++)  s += cross(g[i]-o, g[(i+1)%n]-o);\n    return abs(s) / 2.0;\n}\n\nbool isConvex(Polygon g){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            if(cross(g[i]-g[(i+n-1)%n], g[j]-g[(i+n-1)%n]) < -EPS || cross(g[(i+1)%n]-g[i], g[j]-g[i]) < -EPS){\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i+1)%n] - p;\n        if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)   return ON;\n        if(a.y > b.y)   swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return x ? IN : OUT;\n}\n\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(a * cos(r), a * sin(r));\n}\n\n\nPolygon andrewScan(Polygon g){\n    Polygon u, l;\n    if(g.size() < 3)    return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size()-1]);\n    l.push_back(g[g.size()-2]);\n\n    // upper\n    for(int i = 2; i < g.size(); i++){\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], g[i]) != CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for(int i = g.size()-3; i >= 0; i--){\n        for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], g[i]) != CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size()-2; i >= 1; i--)    l.push_back(u[i]);\n\n    return l;\n}\n\ndouble convexDiameter(Polygon g){\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n        if(g[i].y > g[is].y)    is = i;\n        if(g[i].y < g[js].y)    js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        if(cross(g[(i+1)%n]-g[i], g[(j+1)%n]-g[j]) >= 0.0)  j = (j+1)%n;\n        else    i = (i+1)%n;\n        if(getDistance(g[i], g[j]) > d){\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    }while(i != is || j != js);\n\n    return d; // farthest pair is (maxi, maxj).\n}\n\n\nbool f(Polygon g, Circle c){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        ret &= getDistanceSP(Segment(g[i], g[(i+1)%n]), c.c) >= c.r;\n    }\n    return ret;\n}\n\nbool h(Polygon g, Circle c){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        ret &= getDistance(c.c, g[i]) <= c.r;\n    }\n    return ret;\n}\n\nbool e(Polygon g, Circle c){\n    bool ret = false;\n    int n = g.size(); \n    for(int i = 0; i < n; i++){\n        ret |= getDistanceSP(Segment(g[i], g[(i+1)%n]), c.c) <= c.r;\n    }\n    return ret;\n}\n\nint main(){\n    double x, y, r;\n    while(cin >> x >> y, x+y != 0.0){\n        Polygon g;\n        g.push_back(Point(x,y));\n        cin >> x >> y;\n        g.push_back(Point(x,y));\n        cin >> x >> y;\n        g.push_back(Point(x,y));\n        cin >> x >> y >> r;\n        Circle c(Point(x,y), r);\n        if(contains(g, c.c)==2 && f(g, c))  cout << \"a\" << endl;\n        else if(h(g, c))                    cout << \"b\" << endl;\n        else if(e(g, c))                    cout << \"c\" << endl;\n        else                                cout << \"d\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\nbool CircleInTriangle(P p[3], P c, double r)\n{\n\tdouble S = abs(cross(p[0] - p[2], p[1] - p[2]));\n\t\n\trep(i, 3) S -= abs(cross(p[(i + 1) % 3] - p[i], c - p[i]));\n\t\n\treturn abs(S) < EPS;\n}\n\nbool TriangleInCircle(P p[3], P c, double r)\n{\n\trep(i, 3) if(r <= abs(p[i] - c)) return false;\n\t\n\treturn true;\n}\n\nbool TriangleCrossCircle(P p[3], P c, double r)\n{\n\trep(i, 3) if(abs(p[i] - c) < r) return true;\n\t\n\treturn false;\n}\n\nint main()\n{\n    P p[3], c;\n\tdouble r;\n\t\n\twhile(cin >> p[0].real() >> p[0].imag() && (p[0].real() || p[0].imag()))\n\t{\n\t\trep(i, 2) cin >> p[i + 1].real() >> p[i + 1].imag();\n\t\t\n\t\tcin >> c.real() >> c.imag() >> r;\n\t\t\n\t\tif(TriangleInCircle(p, c, r))\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if(TriangleCrossCircle(p, c, r))\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\telse if(CircleInTriangle(p, c, r))\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cmath>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\n\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\nstatic const int CIRCLE_NON = 0;\nstatic const int CIRCLE_OUT = 1;\nstatic const int CIRCLE_IN = 2;\nstatic const int CIRCLE_CROSS = 3;\n\nclass Circle{\n    public:\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0): c(c), r(r){}\n};\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\ndouble getDistanceLP(Line s, Point p){ \n    return abs(cross(s.p2 - s.p1, p - s.p1)/abs(s.p2 - s.p1));\n}\n\nbool isIntersect( Circle c1, Line l ){\n    double d = getDistanceLP(l, c1.c);\n    return ( equals(d, c1.r) || d < c1.r );\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Line l ){\n    double d = getDistanceLP(l, c1.c);\n    Point v = l.p2 - l.p1;\n    if ( ccw(l.p1, l.p2, c1.c) == COUNTER_CLOCKWISE ){\n\tv = polar(abs(v), arg(v)-acos(-1)/2);\n    } else {\n\tv = polar(abs(v), arg(v)+acos(-1)/2);\n    }\n    double th = acos(d/c1.r);\n    Point v1 = polar(c1.r, arg(v) + th );\n    Point v2 = polar(c1.r, arg(v) - th );\n    return make_pair(c1.c+v1, c1.c+v2);\n}\n\nbool circleIsInTriangle(Circle c, Point t[3] ){\n    int ccw1 = ccw(t[0], t[1], c.c);\n    int ccw2 = ccw(t[1], t[2], c.c);\n    int ccw3 = ccw(t[2], t[0], c.c);\n    if ( !(ccw1 == ccw2 && ccw2 == ccw3 ) ) return false;\n    for ( int i = 0; i < 3; i++ ){\n\tLine l =  Line(t[i], t[(i+1)%3]);\n\tif ( c.r > getDistanceLP(l, c.c) ) return false;\n    }\n    return true;\n}\n\nbool triangleIsInCircle(Circle c, Point t[3] ){\n    for ( int i = 0; i < 3; i++ ){\n\tif ( c.r < getDistance(t[i], c.c) ) return false;\n    }\n    return true;\n}\n\nbool isIntersect(Circle c, Point t[3]){\n    for ( int i = 0; i < 3; i++ ){\n\tLine l =  Line(t[i], t[(i+1)%3]);\n\tif ( !isIntersect(c, l) ) continue;\n\tpair<Point, Point> pp = getCrossPoints(c, l);\n\tif ( ccw(l.p1, l.p2, pp.first) == ON_SEGMENT ) return true; \n\tif ( ccw(l.p1, l.p2, pp.second) == ON_SEGMENT ) return true;\n    }\n    return false;\n}\n\nint main(){\n    double x, y, r;\n    Circle c;\n    Point T[3];\n    while(1){\n\tcin >> x >> y;\n\tif ( x == 0 && y == 0 ) break;\n\tT[0] = Point(x, y);\n\tcin >> x >> y;\n\tT[1] = Point(x, y);\n\tcin >> x >> y;\n\tT[2] = Point(x, y);\n\tcin >> x >> y >> r;\n\tc = Circle(Point(x, y), r);\n\tif ( circleIsInTriangle(c, T) ) cout << \"a\" << endl;\n\telse if ( triangleIsInCircle(c, T) ) cout << \"b\" << endl;\n\telse if ( isIntersect(c, T) ) cout << \"c\" << endl;\n\telse cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef long double Double;\ntypedef complex<Double> P;\n#define Y imag()\n#define X real()\nconst Double EPS = (long double) 1 * 1e-12;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nDouble get(P b[3]){\n\tP a[3];\n\tfor(int i = 0 ; i < 3 ; i++) a[i] = b[i];\n\ta[0] -= a[2];\n\ta[1] -= a[2];\n\treturn 0.5 * abs( a[0].X * a[1].Y - a[1].X * a[0].Y );\n}\n\n\nDouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \nDouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {Double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\n\nDouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;Double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tDouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\t//cout << S << endl;\n\t\tbool in = S == 0;\n\t\tbool hit2 = getPedal(L(a[0],a[1]),c) <= r || getPedal(L(a[1],a[2]),c) <= r || getPedal(L(a[0],a[2]),c) <= r;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) < r || getPedal(L(a[1],a[2]),c) < r || getPedal(L(a[0],a[2]),c) < r;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) <= r*r && nijo(a[1]-c) <= r*r && nijo(a[2]-c) <= r*r) cout << \"b\" << endl;\n\t\telse if(in){\n\t\t\tif(hit) cout << \"c\" << endl;\n\t\t\telse cout << \"a\" << endl;\n\t\t}else{\n\t\t\tif(hit2) cout << \"c\" << endl;\n\t\t\telse cout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0&&acx*acx+acy*acy<=r*r)return true;\n\t\telse if(abx*acx+aby*acy>abx*abx+aby*aby&&bcx*bcx+bcy*bcy<=r*r)return true;\n\t\telse if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t}\n\treturn false;\n}\nbool intersect(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy){\n\tlong long ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n\tlong long tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n\tlong long tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n\tlong long td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n\tif(ta*tb<=0LL&&tc*td<=0LL)return true;\n\telse return false;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<r*r&&(c-g)*(c-g)+(d-h)*(d-h)<r*r&&(e-g)*(e-g)+(f-h)*(f-h)<r*r)printf(\"b\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse if(intersect(g,h,a,b,c,d,e,f)||intersect(g,h,c,d,a,b,e,f)||intersect(g,h,e,f,a,b,c,d))printf(\"d\\n\");\n\t\telse printf(\"a\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<sstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<climits>\n#include<utility>\n#include<cctype>\nusing namespace std;\n\n#define ull unsigned long long\n#define stt(it,order) sort(it.begin(),it.end(),order)\n#define STT(it,n,order) sort(it,it+n,order)\n#define st(it) sort(it.begin(),it.end())\n#define ST(it,n) sort(it,it+n)\n#define ll long long\n#define rep(i,j) for(int i=0;i<j;++i)\n#define loop(i,a,j) for(int i=a;i<j;++i)\n#define mpi(it,table,T,E) for(map<T,E>::iterator it = table.begin();it!=table.end();++it)\n#define PI 3.141592654\n#define pb(v,e) v.push_back(e)\n#define ms(a,v) memset(a,v,sizeof(a))\n#define cp(a,b,n) rep(i,n)a[i] = b[i]\n#define pi(a) printf(\"%d\\n\",a)\n#define ps(a) printf(\"%s\\n\",a)\n#define si(a) scanf(\"%d\",&a)\n#define print_int_matrix(mat,n) rep(i,n-1){printf(\"%d \",mat[i]);}printf(\"%d\\n\",mat[n-1]);\n#define print_string_matrix(mat,n) rep(i,n-1){printf(\"%s \",mat[i]);}printf(\"%s\\n\",mat[n-1]);\n#define mkp(a,b) make_pair(a,b)\n#define fnd(table,e) (find(table.begin(),table.end(),e) != table.end())\n\n//TYPOS DE DATOS PERSONALES\ntypedef unsigned int _set;\ntypedef unsigned long _lset;\ntypedef pair<int,int> pii;\n\nstring sint(int i){\n   stringstream buf;\n   buf<<i;\n   return buf.str();\n}\n\n/*\nifstream fin(\"input.txt\");\nofstream fout(\"output.txt\");\n#define cin fin\n#define cout fout\n*/\n\nint dx[] = {-1,0,0,1};\nint dy[] = {0,-1,1,0};\nint dx8[] = {-1,-1,-1,0,0,1,1,1};\nint dy8[] = {-1,0,1,-1,1,-1,0,1};\n\n#define EPS (1e-10)\n\ninline int cmp(const double& x, const double& y = 0, double tol = EPS){\n     return (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;\n}\n\ndouble dis(pii vex,int a,int b){\n   return sqrt( pow(vex.first-a,2) + pow(vex.second - b,2));\n}\n\ndouble dis(double x,double y,double u,double v){\n   return sqrt( pow(x-u,2) + pow(y-v,2));\n}\n\nbool insd(double x,double a,double b){\n   return min(a,b) <= x && x <= max(a,b);\n}\n\nbool inter(pii Pa, pii Pb, int x,int y,int r){\n\n   int A = Pb.second - Pa.second;\n   int B = Pa.first - Pb.first;\n   int C = A*Pa.first + B*Pa.second;\n\n   if( B == 0)return false;\n\n   double neta = 2*A*B*y - 2*A*C - 2*B*B*x;\n   double theta = B*B + A*A;\n   double betha = B*B*x*x - r*r*B*B + y*y*B*B + C*C - 2*B*C*y;\n\n   return neta*neta >= 4*theta*betha ;\n}\n\nbool perp(pii Pa,pii Pb,int x,int y,int r){\n   int A = Pb.second - Pa.second;\n   int B = Pa.first - Pb.first;\n   int C = A*Pa.first + B*Pa.second;\n\n   int D = -B;\n   int E = A;\n   int F = D*x + E*y;\n\n   double det = A*E - B*D;\n   double sx = (C*E-B*F)/det;\n   double sy = (A*F-D*C)/det;\n\n   return insd(sx,Pa.first,Pb.first) && insd(sy,Pa.second,Pb.second);\n\n}\n\nint main(){\n   int a,b;\n   while( scanf(\"%d %d\",&a,&b) != EOF , a || b ){\n      vector<pii> tri;\n      pb(tri,mkp(a,b));\n\n      scanf(\"%d %d\",&a,&b);\n      pb(tri,mkp(a,b));\n\n      scanf(\"%d %d\",&a,&b);\n      pb(tri,mkp(a,b));\n\n      scanf(\"%d %d\",&a,&b);\n      int r;\n      si(r);\n\n      int t = 0;\n\n      rep(i,3){\n         double d = dis(tri[i],a,b);\n         if( cmp(d,r) <= 0){\n            t++;\n         }\n\n      }\n\n      if( t == 3){\n         printf(\"b\\n\");\n      }else{\n         bool find = false;\n         rep(i,3){\n            find = find || inter(tri[i],tri[(i+1)%3],a,b,r);\n         }\n         if( find ){\n            printf(\"c\\n\");\n         }else{\n            find = true;\n            rep(i,3){\n               find = find && perp(tri[i],tri[(i+1)%3],a,b,r);\n            }\n\n            if( find){\n               printf(\"a\\n\");\n            }else{\n               printf(\"d\\n\");\n            }\n\n         }\n      }\n\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-1;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) <= c.r ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r - kyuriEPS ){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs( (t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x) );\n\t}\n\t//std::cout << area << \" \" << tS2 << std::endl;\n\t\n\tif( fabs( fabs(area) - tS2 ) == 0 ) return 0; \t\n\t\n\treturn 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r+EPS)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n    \n    t=construct_edge(p,3);\n    int res=point_contain(t,C.p,3);\n\n    if(res){\n      int fg=0;\n      for(int i=0;i<3;i++){\n\tif(crossCS(t[i].a,t[i].b,C)>0){\n\t  cout <<'c'<< endl;\n\t  fg=1;\n\t  break;\n\t}\n      }\n      if(fg)continue;\n      if(containCS(t[0].a,t[0].b,C))cout <<'b'<<endl;\n      else cout <<'a'<<endl;\n    }\n    else {\n      for(int i=0;i<3;i++){\n\tif(crossCS(t[i].a,t[i].b,C)>0){\n\t  cout <<'c'<< endl;\n\t  continue;\n\t}\n      }\n      cout <<'d'<< endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2){};\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn(s1.p1 + (s1.p2 - s1.p1) * t);\n}\n\ndouble arg(Vector p)\n{\n\treturn(atan2(p.y, p.x));\n}\n\nVector polar(double a, double r)\n{\n\treturn(Point(cos(r) * a, sin(r) * a));\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn(make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)));\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn(make_pair(pr - e * base, pr + e * base));\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tPoint p1;\n\twhile (cin >> p1.x >> p1.y, p1.x || p1.y)\n\t{\n\t\tPoint p2, p3, p4;\n\t\tint r;\n\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y >> r;\n\t\t\n\t\tif (r - getDistance(p4, p1) > 0 && r - getDistance(p4, p2) > 0 && r - getDistance(p4, p3) > 0)\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if (cross(p2 - p1, p4 - p1) * cross(p3 - p1, p4 - p1) < 0 && cross(p2 - p3, p4 - p3) * cross(p1 - p3, p4 - p3) < 0 && cross(p1 - p2, p4 - p2) * cross(p3 - p2, p4 - p2) < 0 &&\n\t\t\t     getDistanceSP(Segment(p1, p2), p4) - r > 0 && getDistanceSP(Segment(p1, p3), p4) - r > 0 && getDistanceSP(Segment(p2, p3), p4) - r > 0)\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse if (getDistanceSP(Segment(p1, p2), p4) - r > 0 && getDistanceSP(Segment(p1, p3), p4) - r > 0 && getDistanceSP(Segment(p2, p3), p4) - r > 0 )\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r&&!EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r&&!EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r&&!EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nstruct C {\n  P p;\n  double r;\n  C() : p(P(0,0)), r(0) {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2-s1,p-s1))/abs(s2-s1);\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2-s1, p-s1) < 0.0) return abs(p-s1);\n  if(dot(s1-s2, p-s2) < 0.0) return abs(p-s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nbool involve(const C &c, const P &s1, const P &s2) {\n  double dist = max(abs(c.p - s1), abs(c.p - s2));\n  return c.r - dist > -eps;\n}\n\nbool involve(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    double dist = getDistanceLP(a,b,c.p);\n    if(cross(b-a, c.p-a) > eps && dist - c.r > -eps) {\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool involve(const C &c, const vector<P> &g) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(!involve(c, a, b)) return false;\n  }\n  return true;\n}\n\nbool isIntersect(const P &s1, const P &s2, const C &c) {\n  if(involve(c, s1, s2)) return false;\n  double dist = getDistanceSP(s1, s2, c.p);\n  return c.r - dist > eps;\n}\n\nbool isIntersect(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(isIntersect(a,b,c)) return true;\n  }\n  return false;\n}\n\nint main() {\n  vector<P> g(3);\n  C c;\n  while(1) {\n    for(int i = 0; i < g.size(); ++i) {\n      cin >> g[i].real() >> g[i].imag();\n      if(g[0].real() == 0 && g[0].imag() == 0) return 0;\n    }\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n    if(involve(g,c)) cout << \"a\" << endl;\n    else if(involve(c,g)) cout << \"b\" << endl;\n    else if(isIntersect(g,c)) cout << \"c\" << endl;\n    else cout << \"d\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Point{ int x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Point c; int r; };\n\ninline double dist(const Point &p1, const Point &p2){\n\treturn sqrt( pow(p2.x-p1.x,2.0)+pow(p2.y-p1.y,2.0) );\n}\ninline double dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble b = 1;\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + b * p.y + c ) / sqrt( pow(a,2.0)+pow(b,2.0) );\n\t}\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) > 0;\n}\n\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( isLeft( t.a, t.b, p ) && isLeft( t.b, t.c, p ) && isLeft( t.c, t.a, p ) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r < dist( t.a, t.b, c.c ) &&\n\t\t\tc.r < dist( t.b, t.c, c.c ) &&\n\t\t\tc.r < dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) < c.r &&\n\t  dist( t.b, c.c ) < c.r &&\n\t  dist( t.c, c.c ) < c.r )\n\t  return true;\n  else\n\t  return false;\n}\nbool isCross(const Point &tp1, const Point &tp2, const Circle &c)\n{\n\tPoint p1 = tp1;\n\tPoint p2 = tp2;\n\tif( p2.x < p1.x )\n\t\tswap( p1, p2 );\n\n\tif( dist( p1, p2, c.c ) > c.r )\n\t\treturn false;\n\telse{\n\t\tif( p1.x != p2.x ){\n\t\t\tdouble x1, x2;\n\t\t\tdouble a = (p2.y - p1.y) / (p2.x - p1.x);\n\t\t\tdouble b = -a * p1.x + p1.y;\n\t\t\tdouble A = 1 + pow(a,2.0);\n\t\t\tdouble B = -( c.c.x - a * b + a * c.c.y );\n\t\t\tdouble C = pow( c.c.x, 2.0 ) + pow( b, 2.0 ) - 2*b*c.c.y + pow( c.c.y, 2.0 ) - pow( c.r, 2.0 );\n\n\t\t\tx1 = ( -B + sqrt( pow(B,2.0) - A * C ) ) / A;\n\t\t\tx2 = ( -B - sqrt( pow(B,2.0) - A * C ) ) / A;\n\n\t\t\tif( p1.x <= x1 && x1 <= p2.x || p1.x <= x2 && x2 <= p2.x )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}else{\n\t\t\tif( p2.y < p1.y )\n\t\t\t\tswap( p1, p2 );\n\n\t\t\tdouble d = dist( p1, p2, c.c );\n\t\t\tdouble l = sqrt( pow(c.r,2.0) - pow(d,2.0) );\n\n\t\t\tdouble y1 = c.c.y - l;\n\t\t\tdouble y2 = c.c.y + l;\n\n\t\t\tif( p1.y <= y1 && y1 <= p2.y || p1.y <= y2 && y2 <= p2.y )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( isCross(t.a,t.b,c) || isCross(t.b,t.c,c) || isCross(t.c,t.a,c) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t,c ) )\n\t\treturn 'b';\n\tif( isCross( t,c ) )\n\t\treturn 'c';\n\telse\n\t\treturn 'd';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( cin.eof() )\n\t\t\tbreak;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst double eps = 1e-8;\ndouble x[4], y[4], r;\n\ndouble distSq(double x1, double y1, double x2, double y2) {\n\treturn (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n}\n\ndouble perpDist(double x1, double y1, double x2, double y2, double cx, double cy) {\n\tdouble a, b, x, y;\n\tdouble res = min(distSq(x1, y1, cx, cy), distSq(x2, y2, cx, cy));\n\tif (x1 == x2) {\n\t\tif (min(y1, y2) <= cy && cy <= max(y1, y2)) {\n\t\t\tres = (cx - x1) * (cx - x1);\n\t\t}\n\t} else {\n\t\ta = (y2 - y1) / (x2 - x1);\n\t\tb = y1 - a * x1;\n\t\tx = (cx + a * (cy - b)) / (1 + a * a);\n\t\ty = a * x + b;\n\t\tif (min(x1, x2) <= x && x <= max(x1, x2) && min(y1, y2) <= y && y <= max(y1, y2)) {\n\t\t\tres = distSq(x, y, cx, cy);\n\t\t}\n\t}\n\treturn res;\n}\n\nbool A() {\n\tint c = 0;\n\tfor (int i=0; i<3; ++i) {\n\t\tif (0 <= (x[(i+1)%3] - x[i]) * (y[3] - y[i]) - (y[(i+1)%3] - y[i]) * (x[3] - x[i])) {\n\t\t\t++ c;\n\t\t}\n\t}\n\tif (c % 3 != 0) return false;\n\tfor (int i=0; i<3; ++i) {\n\t\tif (perpDist(x[i], y[i], x[(i+1)%3], y[(i+1)%3], x[3], y[3]) + eps < r * r) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool B() {\n\tfor (int i=0; i<3; ++i) {\n\t\tif (r * r < distSq(x[i], y[i], x[3], y[3])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool C() {\n\tfor (int i=0; i<3; ++i) {\n\t\tif (perpDist(x[i], y[i], x[(i+1)%3], y[(i+1)%3], x[3], y[3]) <= r * r + eps) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> x[0] >> y[0], (x[0] || y[0])) {\n\t\tfor (int i=1; i<4; ++i) cin >> x[i] >> y[i];\n\t\tcin >> r;\n\t\tif (B()) {\n\t\t\tcout << \"b\" << endl;\n\t\t} else if (A()) {\n\t\t\tcout << \"a\" << endl;\n\t\t} else if (C()) {\n\t\t\tcout << \"c\" << endl;\n\t\t} else {\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 0;\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / abs(a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < Eps)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) <Eps)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(a, b, point);\n}\nbool is_in_triangle(const Point& point, const Point* triangle)\n{\n\tdouble t[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tt[i] = cross(triangle[(i+1)%3] - triangle[i], point - triangle[i]);\n\n\treturn t[0] >= 0 && t[1] >= 0 && t[2] >= 0\n\t\t|| t[0] <= 0 && t[1] <= 0 && t[2] <= 0;\n}\nbool is_in_triangle(const Point& point, const Point& a, const Point& b, const Point& c)\n{\n\tPoint t[3] = { a, b, c };\n\treturn is_in_triangle(point, t);\n}\nbool is_circle_in_triangle(const Point& center, double radius, const Point* triangle)\n{\n\tif (!is_in_triangle(center, triangle))\n\t\treturn false;\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_line_point(triangle[i], triangle[(i+1)%3], center) < radius)\n\t\t\treturn false;\n\treturn true;\n}\nbool is_triangle_in_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (abs(triangle[i]-center) > radius)\n\t\t\treturn false;\n\treturn true;\n}\nbool interect_triangle_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_linesegment_point(center, triangle[i], triangle[(i+1)%3]) < radius)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tint x[4], y[4], r;\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tscanf(\"%d %d\", x+i, y+i);\n\t\tscanf(\"%d\", &r);\n\t\tif (x[0] == 0 && y[0] == 0)\n\t\t\tbreak;\n\t\tPoint p[4];\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tp[i] = Point(x[i], y[i]);\n\n\t\tif (is_circle_in_triangle(p[3], r, p))\n\t\t\tputs(\"a\");\n\t\telse if (is_triangle_in_circle(p, p[3], r))\n\t\t\tputs(\"b\");\n\t\telse if (interect_triangle_circle(p, p[3], r))\n\t\t\tputs(\"c\");\n\t\telse\n\t\t\tputs(\"d\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef double D;\ntypedef complex<D> P;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\ndouble x[3],y[3],xr,yr,r;\nbool dis(int p){\n  return sqrt(abs(x[p]-xr)*abs(x[p]-xr)+abs(y[p]-yr)*abs(y[p]-yr))<=r;\n}\nmain(){\n  while(cin>>x[0]>>y[0],x[0]+y[0]){\n    int sum=0;\n    r(i,2)cin>>x[i+1]>>y[i+1];\n    cin>>xr>>yr>>r;\n    r(i,3)if(dis(i))sum++;\n    if(sum==0){\n      int pp=0;\n      r(i,3)pp+=ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr));\n      if(abs(pp)==3)cout<<'a'<<endl;\n      else cout<<'d'<<endl;\n    }\n    else if(sum==3)cout<<'b'<<endl;\n    else cout<<'c'<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point& a, const Point& b) { return Point{ a.px - b.px,a.py - b.py }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dst(const Point& a, const Point& b) { return abs(Minus(b , a)); }\nlong double dst(const Line& a, const Point& b) {\n\tlong double E = dot(Minus(a.p2, a.p1), Minus(b, a.p1));\n\tlong double F = dot(Minus(a.p1, a.p2), Minus(b, a.p2));\n\tif (E < -1e-7)return abs(Minus(b, a.p1));\n\tif (F < -1e-7)return abs(Minus(b, a.p2));\n\treturn abs(crs(Minus(a.p2, a.p1), Minus(b, a.p1)) / abs(Minus(a.p2, a.p1)));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 1e-7 && 1e-7 < b.py)\n\t\t\tif (crs(a, b) < -1e-7) in = !in;\n\t\tif (fabs(crs(a, b)) <= 1e-7 && dot(a, b) <= 1e-7) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\twhile (true) {\n\t\tPoint r1, r2, r3, r4; long double r;\n\t\tcin >> r1.px >> r1.py; if (fabs(r1.px) <= 1e-7 && fabs(r1.py) <= 1e-7)break;\n\t\tcin >> r2.px >> r2.py >> r3.px >> r3.py >> r4.px >> r4.py >> r;\n\t\tLine l1 = Line{ r1,r2 }, l2 = { r2,r3 }, l3 = { r3,r1 };\n\t\tlong double c1 = min(dst(l1, r4), min(dst(l2, r4), dst(l3, r4)));\n\t\tlong double c2 = max(dst(r1, r4), max(dst(r2, r4), dst(r3, r4)));\n\t\t//cout << dst(l1, r4) << ' ' << dst(l2, r4) << ' ' << dst(l3, r4) << endl;\n\t\tint c4 = contain({ r1,r2,r3 }, r4);\n\t\tif (c1 >= r - 1e-7 && c4 != 0) { cout << \"a\" << endl; }\n\t\telse if (c2 <= r + 1e-7) { cout << \"b\" << endl; }\n\t\telse if (c1 <= r + 1e-7) { cout << \"c\" << endl; }\n\t\telse { cout << \"d\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n \nstruct segment{ point a,b; };\n \nstruct circle{ point p; double r; };\n \ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n \ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n \nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n \ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n \ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n \ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n \n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n \n bool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint point_contain(point* ps, point p, int n){\n  int cnt=ccw(ps[0],ps[1],p);\n  ps[n++]=ps[0]; \n\n  for(int i=0;i<n-1;i++)\n    if(cnt!=ccw(ps[i],ps[i+1],p))return 0;\n   \n  return 1;\n}\n \nint crossCP(point* ps, circle C, int sz){\n \n  double ans=0;\n \n  for(int i=0;i<sz;i++){\n    double tmp=dist(ps[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n \n  if(C.r>=ans)return 2;\n \n  vector<point>t=convex_hull(ps,sz);\n\n  int tsz=t.size();\n  int res1=point_contain(ps,C.p,tsz);\n \n  double res2=100000000;\n   t[t.size()]=t[0];\n   tsz++;\n  for(int i=0;i<tsz-1;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n \n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n \nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n  string ans=\"zabcd\";\n \n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n \n    int res=crossCP(p,C,3);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <vector>\n\nusing namespace std;\n\n//-------------------------------------------------------------------------\n// geometric library\n \nnamespace geometry {\n \n#define EPS 1E-10 ///< 0とみなすサイズ。適当\n \n    struct point {\n        double x;\n        double y;\n \n\t\tpoint() {}\n\t\tpoint(double x, double y) : x(x), y(y) {}\n        point& operator += (const point& rhs) { x += rhs.x; y += rhs.y; return *this; }\n        point& operator -= (const point& rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n        point& operator /= (double factor) { x /= factor; y /= factor; return *this; }\n        point& operator *= (double factor) { x *= factor; y *= factor; return *this; }\n        bool operator == (const point& rhs) const { return (std::abs(x - rhs.x) < EPS) && (std::abs(y - rhs.y) < EPS); }\n        bool operator != (const point& rhs) const { return !(*this == rhs); }\n        bool operator <= (const point& rhs) const { return x < rhs.x || (x == rhs.x && y <= rhs.y); }\n        bool operator >= (const point& rhs) const { return x > rhs.x || (x == rhs.x && y >= rhs.y); }\n        bool operator < (const point& rhs) const { return !(*this >= rhs); }\n        bool operator > (const point& rhs) const { return !(*this <= rhs); }\n\t\tdouble arg() const { return atan2(y, x); }\n        double norm() const { return sqrt(x * x + y * y); }\n\t\tpoint get_normal() const { return point(-y, x); }\n    };\n\ttypedef point vec2d;\n \n    struct circle {\n        point center;\n        double radius;\n\t\tcircle() {}\n\t\tcircle(double x, double y, double r) : center(x, y), radius(r) {}\n    };\n \n\tstruct triangle {\n\t\tpoint p[3];\n\t};\n \n    enum rotate_dir {\n        rotate_None = 0,\n        rotate_CW = 1,\n        rotate_CCW = -1\n    };\n \n    point operator + (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p += p2;\n        return p;\n    }\n \n    point operator / (const point& p1, double factor)\n    {\n        point p(p1);\n        p /= factor;\n        return p;\n    }\n  \n    point operator * (const point& p1, double factor)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator * (double factor, const point& p1)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator - (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p -= p2;\n        return p;\n    }\n \n    std::istream& operator >> (std::istream& is, point& p)\n    {\n        is >> p.x >> p.y;\n        return is;\n    }\n\n    std::istream& operator >> (std::istream& is, circle& c)\n    {\n        is >> c.center >> c.radius;\n        return is;\n    }\n\n    ///! 2点の距離\n    double get_distance(const point& p1, const point& p2)\n    {\n        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    }\n \n    double cross_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.y - p2.x * p1.y;\n    }\n \n    double inner_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n\t///! 直線s-eにpを投影した点を求める\n\tpoint get_project(const point& s, const point& e, const point& p)\n\t{\n\t\tdouble scale = inner_product(p - s, e - s) / (e - s).norm();\n\t\treturn s + scale * (e - s) / (e - s).norm();\n\t}\n\n     ///! pがs-e間(s,e上含む)にあればtrue\n    bool is_inter_point(const point& s, const point& e, const point& p) {\n        double d = get_distance(s, p) + get_distance(p, e) - get_distance(s, e);\n        return abs(d) < EPS;\n    }\n \n    ///! p1-p2-p3が左右どちらの方向に折れているかを判定\n    rotate_dir direction(const point& p1, const point& p2, const point& p3)\n    {\n        point p1_p3 = p1 - p3;\n        point p2_p3 = p2 - p3;\n        double cross = cross_product(p1_p3, p2_p3);\n \n        if (std::abs(cross) < EPS) {\n            return rotate_None;\n        }\n        else if (cross > 0) {\n            return rotate_CW;\n        }\n        else {\n            return rotate_CCW;\n        }\n    }\n\n\tbool is_inside_circle(const point& p, const circle& c)\n\t{\n\t\treturn get_distance(p, c.center) <= c.radius + EPS;\n\t}\n\n\tbool is_inside_circle(const triangle& t, const circle& c)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (!is_inside_circle(t.p[i], c)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n \n    // (p1s, p1e)と(p2s, p2e)の線分交差判定.EPS以下で接している場合はtrue、重なっている場合はfalse\n    bool intersect(const point& p1s, const point& p1e, const point& p2s, const point& p2e)\n    {\n        assert(p1s != p1e && p2s != p2e);\n        return\n            (direction(p1s, p1e, p2s) != direction(p1s, p1e, p2e)) &&\n            (direction(p2s, p2e, p1s) != direction(p2s, p2e, p1e));\n    }\n\n\t// 円と三角形が交差するかどうか\n\tbool intersect(const circle& c, const triangle& t)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tpoint ps = t.p[i], pe = t.p [(i + 1) % 3];\n\n\t\t\tif (is_inside_circle(ps, c) != is_inside_circle(pe, c)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (is_inside_circle(ps, c) && is_inside_circle(pe, c)) {\n\t\t\t\tcontinue; // この辺は交差しない\n\t\t\t}\n\t\t\tpoint m = get_project(ps, pe, c.center);\n\n\t\t\tif (get_distance(m, c.center) <= c.radius + EPS && is_inter_point(ps, pe, m)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} \n\n    // targetが三角形p1,p2,p3の内部にあるかどうか\n    bool is_inside_triangle(const point& target, const point& p1, const point& p2, const point& p3)\n    {\n        point center_of_gravity = (p1 + p2 + p3) / 3; // 重心\n \n        if (center_of_gravity == target) return true;\n \n        // 重心とtargetを結んだ線分が三角形の辺と交叉するなら、点は三角形の外部にある\n        bool intersect_any =\n            intersect(p1, p2, center_of_gravity, target) ||\n            intersect(p2, p3, center_of_gravity, target) ||\n            intersect(p3, p1, center_of_gravity, target);\n \n        return !intersect_any;\n    }\n\n\tbool is_inside_triangle(const point& target, const triangle& t)\n\t{\n\t\treturn is_inside_triangle(target, t.p[0], t.p[1], t.p[2]);\n\t}\n \n\tbool is_inside_triangle(const circle& c, const triangle& t)\n\t{\n\t\tif (is_inside_triangle(c.center, t) && !intersect(c, t) && !is_inside_circle(t, c)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n \n} // namespace geometry\n\n\n//-----------------------------------------------\n//\n\nusing namespace geometry;\n\nchar solve(const triangle& triangle, const circle& circle) {\n\tif (is_inside_triangle(circle, triangle)) {\n\t\treturn 'a';\n\t} else if (is_inside_circle(triangle, circle)) {\n\t\treturn 'b';\n\t} else if (intersect(circle, triangle)) {\n\t\treturn 'c';\n\t} else {\n\t\treturn 'd';\n\t}\n}\n\nint main(void) {\n\t//test();\n\n\ttriangle triangle;\n\tcircle circle;\n\tint n = 1;\n\n\twhile (cin >> triangle.p[0]) {\n\t\tif (triangle.p[0].x == 0 && triangle.p[0].y == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> triangle.p[1] >> triangle.p [2] >> circle;\n\n\t\tcout << solve(triangle, circle) << endl;\n\t\tn++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\n\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-10;\nconst double INF = 1e8;\n\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\nint main(){\n  G p;\n  L l[3];\n  C c;\n  p.resize(3);\n  while(cin >> p[0].real() >> p[0].imag(), p[0].real()||p[0].imag()){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> p[i].real() >> p[i].imag();\n    }\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      l[i] = L( p[i], p[(i+1)%3]);\n    }\n\n    bool flag = true;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(distance(l[i], c.p) + EPS < c.r) flag = false;\n    }\n    if(flag && contains( p, c.p)){\n      cout << 'a' << endl;\n      continue;\n    }\n    flag = false;\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(!contains( c, p[i])) flag = true;\n    }\n    if(!flag){\n      cout << 'b' << endl;\n      continue;\n    }\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(intersect( c, l[i]) > 0) flag = false;\n    }\n    if(!flag){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = s.source().ccw(s.target(), source()) * s.source().ccw(s.target(), target()) <= EPS;\n    bool b = source().ccw(target(), s.source()) * source().ccw(target(), s.target()) <= EPS;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点がすべての円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) == ABOVE) ++ccw;\n        if(e.ccw(circle.center()) == UNDER) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define EPS 1E-5\n#define SAME_SIGN( a , b ) a * b > EPS\n\nnamespace geometry{\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius + EPS ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) <= cir.radius + EPS &&\n\t\tget_distance( tri.b , cir.center ) <= cir.radius + EPS &&\n\t\tget_distance( tri.c , cir.center ) <= cir.radius + EPS\n\t\t){\n\t\t\tstd::cout << \"b\" << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius + EPS &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius + EPS &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius + EPS\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << \"a\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << \"d\" << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << \"c\" << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << \"c\" << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\ntypedef complex<double> P;\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nint chk(P a,P b,double r){\n\tdouble t = abs(a-b) - r;\n\tif( fabs(t) < EPS ) return 0;\n\treturn t < 0 ? -1 : 1;\n}\ndouble cross(P a,P b){\n\treturn imag(a*conj(b));\n}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\n\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nint main(){\n\tP a,b,c,d;\n\tdouble r;\n\twhile(cin >> a.real() >> a.imag() , a.real() != 0 || a.imag() != 0 ){\n\t\tcin >> b.real() >> b.imag();\n\t\tcin >> c.real() >> c.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tcin >> r;\n\t\t\n\t\tint in = 0;\n\t\tint mk = cross(a-d,b-d) <= 0 ;\n\t\tif( mk == (cross(b-d,c-d) <= 0) && mk == (cross(c-d,a-d) <= 0)){\n\t\t\tin = 1;\n\t\t}\n\t\t\n\t\tif( chk(a,d,r) <= 0 &&  chk(b,d,r) <= 0 &&  chk(c,d,r) <= 0 ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( chk(a,d,r) >= 0 &&  chk(b,d,r) >= 0 &&  chk(c,d,r) >= 0){\n\t\t\tif( distanceSP(L(a,b),d) < r - EPS || distanceSP(L(b,c),d) < r - EPS || distanceSP(L(a,c),d) < r - EPS  ){\n\t\t\t\tcout << \"c\" << endl;\n\t\t\t}else if( in ){\n\t\t\t\tcout << \"a\" << endl;\n\t\t\t}else if( distanceSP(L(a,b),d) > r + EPS || distanceSP(L(b,c),d) > r + EPS || distanceSP(L(a,c),d) > r + EPS )\n\t\t\t\tcout << \"d\" << endl;\n\t\t\t}\n\t\t\tcout << \"c\" << endl;\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//12\n#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real()+.5;\n}\n\nint dt(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag()+.5;\n}\n\nint main(){\n  for(;;){\n    int x,y;\n    P t[3],c;\n    int r;\n    for(int i=0;i<3;i++){\n      cin>>x>>y;\n      if((i|x|y)==0)return 0;\n      t[i]=P(x,y);\n    }\n    cin>>x>>y;\n    c=P(x,y);\n    cin>>r;\n    if(abs(t[0]-c)<=r&&abs(t[1]-c)<=r&&abs(t[2]-c)<=r){\n      cout<<'b'<<endl;\n    }else{\n      double d[3];\n      bool f[2]={};\n      for(int i=0;i<3;i++){\n\tP l=t[(i+1)%3]-t[i];\n\tif(dt(l,c-t[i])>0&&dt(-l,c-t[(i+1)%3])){\n\t  d[i]=fabs(cr(l,c-t[i])/abs(l));\n\t}else{\n\t  d[i]=min(abs(c-t[0]),abs(c-t[1]));\n\t}\n\tf[cr(l,c-t[i])<0]=true;\n      }\n      if(f[0]^f[1]&&d[0]>=r&&d[1]>=r&&d[2]>=r){\n\tcout<<'a'<<endl;\n      }else if(d[0]<=r||d[1]<=r||d[2]<=r){\n\tcout<<'c'<<endl;\n      }else{\n\tcout<<'d'<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconst double eps = 1e-7;\nnamespace boost {\ntemplate <class T>\nstruct integer_iterator {\n    T a;\n    bool operator != (integer_iterator const & it) const { return a != it.a; }\n    T operator * () const { return a; }\n    integer_iterator & operator ++ () { ++ a; return *this; }\n    integer_iterator operator ++ (int) { return { a ++ }; }\n};\ntemplate <class T>\nstruct integer_range {\n    T l, r;\n    typedef integer_iterator<T> iterator;\n    iterator begin() const { return { l }; }\n    iterator end  () const { return { r }; }\n};\ntemplate <class T>\ninteger_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }\ntemplate <class T>\nstruct integer_iterator_with_step {\n    T a, d, i;\n    bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }\n    T operator * () const { return a+d*i; }\n    integer_iterator_with_step & operator ++ () { ++ i; return *this; }\n    integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }\n};\ntemplate <class T>\nstruct strided_integer_range {\n    T l, r, s;\n    typedef integer_iterator_with_step<T> iterator;\n    iterator begin() const { return { l, s, 0 }; }\n    iterator end  () const { return { l, s, (r - l) / s }; }\n};\ntemplate <class T>\nstrided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }\n}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };\nttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }\nttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }\nttt point<T> operator - (pca a) { return { -a.x, -a.y }; }\nttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }\nttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }\nttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }\nttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }\nttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }\nttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }\nttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }\nttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }\nttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }\nttt double length(pca p) { return sqrt(length_squared(p)); }\nttt point<T> normalized(pca a) { return (1 / length(a)) * a; }\nttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }\nttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }\nttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }\ntemplate <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> bool operator == (circle<T> const & a, circle<T> const & b) { return a.p == b.p and a.r == b.r; }\ntemplate <typename T> bool operator != (circle<T> const & a, circle<T> const & b) { return not (a == b); }\ntemplate <typename T> struct line { point<T> a, b; };\ntemplate <typename T> struct ray { point<T> a, b; };\ntemplate <typename T> struct segment { point<T> a, b; };\ntemplate <typename T> T length_squared(segment<T> const & p) { return length_squared(p.a - p.b); }\ntemplate <typename T> double length(segment<T> const & p) { return length(p.a - p.b); }\ntemplate <typename T>    line<T> to_line(    ray<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>    line<T> to_line(segment<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(   line<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(segment<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment(line<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment( ray<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T>\nstruct arc { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT length(arc<T> const & a) { return a.r * (a.b - a.a); }\ntemplate <typename T>\nbool valid(arc<T> const & a) {\n    assert (0 <= a.r);\n    return\n        - M_PI < a.a + eps and a.a < M_PI + eps and\n        - M_PI < a.b + eps and a.b < M_PI + eps;\n}\ntemplate <typename T>\ncircle<T> to_circle(arc<T> const & a) { return { a.p, a.r }; }\n\ntemplate <typename T>\nstruct circular_sector { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT sq(T x) { return x * x; }\ntemplate <typename T>\npoint<T> rotate_90(point<T> const & a) {\n    return { - a.y, a.x };\n}\ntemplate <typename T>\npoint<T> rotate_270(point<T> const & a) {\n    return { a.y, - a.x };\n}\ntemplate <typename T>\npoint<T> rotate_180(point<T> const & a) {\n    return { - a.x, - a.y };\n}\npoint<double> rotate(point<double> const & a, double th) {\n    return {\n        a.x * cos(th) - a.y * sin(th),\n        a.x * sin(th) + a.y * cos(th) };\n}\ntemplate <>\nint ccw(point<double> const & a, point<double> const & b, point<double> const & c) {\n    double x = cross(b - a, c - a);\n    return x > eps ? 1 : x < - eps ? -1 : 0;\n}\n\ndouble distance(point<double> const & a, point<double> const & b) {\n    return length(b - a);\n}\n\ndouble distance(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return std::abs( cross(p, e) );\n}\ndouble distance(point<double> const & a, line<double> const & b) {\n    return distance(b,a);\n}\n\nbool does_include(circle<double> const & a, point<double> const & b) {\n    return length(a.p - b) < a.r + eps;\n}\nbool is_on_circumference(point<double> const & a, circle<double> const & b) {\n    return std::abs(length(b.p - a) - b.r) < eps;\n}\n// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < std::abs(a.r - b.r) + eps;\n}\n// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < a.r + b.r + eps;\n}\n// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;\n}\n// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {\n    std::vector<point<double> > result;\n    if (distance(a.p, b.p) < eps) {\n        // nop\n    } else if (not does_intersect(a,b)) {\n        // nop\n    } else if (does_include(a,b) and not does_inscribe(a,b)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(a,b) or does_circumscribe(a,b)) {\n        circle<double> x = a;\n        circle<double> y = b;\n        if (not (x.r < y.r)) std::swap(x, y);\n        result.push_back(y.r * normalized(x.p - y.p) + y.p);\n    } else {\n        //       c\n        //      /|\\\n        // a.r / | \\ b.r\n        //    /th|  \\\n        //   a-------b\n        //       l\n        double l = length(b.p - a.p);\n        double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\n        double as = sqrt( sq(a.r) - sq(ac) );\n        point<double> e = normalized(b.p - a.p);\n        result.push_back(a.p + ac*e + as*rotate_90(e));\n        result.push_back(a.p + ac*e + as*rotate_270(e));\n    }\n    for (auto p : result) {\n        assert (does_include(a, p));\n        assert (does_include(b, p));\n    }\n    return result;\n}\n\nstd::vector<line<double> > tangents(circle<double> const & a, point<double> const & b) {\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not is_on_circumference(b,a)) {\n        // truly included\n        // nop\n    } else if (is_on_circumference(b,a)) {\n        point<double> e = normalized(a.p - b);\n        result.push_back({\n                b + rotate_90(e),\n                b + rotate_270(e) });\n    } else {\n        double theta = asin(a.r / length(b - a.p));\n        result.push_back({ b, b + rotate(a.p - b, + theta) });\n        result.push_back({ b, b + rotate(a.p - b, - theta) });\n    }\n    return result;\n}\n\nstd::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {\n    point<double> p = a.p + (a.r / (a.r + b.r)) * (b.p - a.p);\n    return tangents(a,p);\n}\nstd::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {\n    if (b.r < a.r) std::swap(a,b);\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not does_inscribe(b,a)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(b,a)) {\n        point<double> e = normalized(a.p - b.p);\n        result.push_back({\n                b.p + a.r*e + rotate_90(e),\n                b.p + a.r*e + rotate_270(e) });\n    } else {\n        point<double> d = b.p - a.p;\n        double theta = asin((b.r - a.r) / length(d));\n        point<double> dp = rotate(d, + theta);\n        point<double> dm = rotate(d, - theta);\n        point<double> ep = rotate_90(normalized(dp));\n        point<double> em = rotate_270(normalized(dm));\n        result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });\n        result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });\n    }\n    return result;\n}\nstd::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {\n    std::vector<line<double> > result;\n    for (auto l : common_inner_tangents(a,b)) result.push_back(l);\n    for (auto l : common_outer_tangents(a,b)) result.push_back(l);\n    return result;\n}\n\npoint<double> nearest_point(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return a.a + dot(p, e) * e;\n}\nbool is_tangent(line<double> const & a, circle<double> const & b) {\n    return std::abs( b.r - distance(a, b.p) ) < eps;\n}\nbool does_include(segment<double> const & a, point<double> const & b) {\n    point<double> p = b - a.a;\n    point<double> e = normalized(a.b - a.a);\n    return std::abs( cross(e, p) ) < eps and - eps < dot(e, p) and dot(e, p) < length(a) + eps;\n}\nbool is_tangent(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return is_tangent(l, b) and does_include(a, nearest_point(l, b.p));\n}\nbool does_intersect(line<double> const & a, circle<double> const & b) {\n    return distance(a, b.p) < b.r + eps;\n}\nbool does_intersect(circle<double> const & a, line<double> const & b) {\n    return does_intersect(b, a);\n}\nbool does_intersect(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return does_intersect(l, b) and\n        (does_include(a, nearest_point(l, b.p)) or\n         distance(a.a, b.p) < b.r + eps or\n         distance(a.b, b.p) < b.r + eps);\n}\n\nbool does_intersect(line<double> const & a, line<double> const & b) {\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return eps < std::abs( cross(p, q) );\n}\nbool is_parallel(line<double> const & a, line<double> const & b) {\n    return not does_intersect(a, b);\n}\nbool does_intersect(segment<double> const & a, segment<double> const & b) {\n    return\n        ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) == -1 and\n        ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) == -1;\n}\npoint<double> intersection_point(line<double> const & a, line<double> const & b) {\n    assert (does_intersect(a, b));\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return a.a + ( cross(q, b.a - a.a) / cross(q, p) ) * p;\n}\n\nbool does_include(ray<double> const & a, point<double> const & b) {\n    return ccw(a.a, a.b, b) == 0 and dot(a.b - a.a, b - a.a) > - eps;\n}\nbool does_intersect(ray<double> const & a, segment<double> const & b) {\n    if (does_include(a, b.a) or does_include(a, b.b)) return true;\n    line<double> la = to_line(a);\n    line<double> lb = to_line(b);\n    if (is_parallel(la, lb)) return false;\n    point<double> p = intersection_point(la, lb);\n    return does_include(a,p) and does_include(b,p);\n}\nbool does_intersect(segment<double> const & a, ray<double> const & b) {\n    return does_intersect(b, a);\n}\n\npoint<double> projection(point<double> const & a, line<double> const & b) {\n    point<double> e = normalized(b.b - b.a);\n    return dot(e, a - b.a) * e + b.a;\n}\ndouble distance(segment<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_line(a));\n    if (does_include(a, p)) {\n        return distance(to_line(a), b);\n    } else{\n        return std::min(distance(a.a, b), distance(a.b, b));\n    }\n}\ndouble distance(point<double> const & a, segment<double> const & b) {\n    return distance(b, a);\n}\ndouble distance(segment<double> const & a, segment<double> const & b) {\n    return std::min(std::min(std::min(\n            distance(a.a, b),\n            distance(a.b, b)),\n            distance(a, b.a)),\n            distance(a, b.b));\n}\n\npoint<double> projection(point<double> const & a, circle<double> const & b) {\n    return b.r * normalized(a - b.p) + b.p;\n}\nbool does_include(arc<double> const & a, point<double> const & b) {\n    assert (valid(a));\n    point<double> e = b - a.p;\n    double r = length(e);\n    double th = atan2(e.y, e.x);\n    return std::abs(a.r - r) < eps and  a.a < th + eps and th < a.b + eps;\n}\ndouble distance(arc<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_circle(a));\n    if (does_include(a, p)) {\n        return distance(p, b);\n    } else{\n        point<double> l = a.r * (point<double>) { cos(a.a), sin(a.a) } + a.p;\n        point<double> r = a.r * (point<double>) { cos(a.b), sin(a.b) } + a.p;\n        return std::min(distance(l, b), distance(r, b));\n    }\n}\ndouble distance(point<double> const & a, arc<double> const & b) {\n    return distance(b, a);\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    if (not does_intersect(a, b)) {\n        // nop\n    } else if (is_tangent(b, a)) {\n        result.push_back(nearest_point(b, a.p));\n    } else {\n        point<double> e = normalized(b.b - b.a);\n        point<double> p = nearest_point(b, a.p);\n        double h = distance(p, a.p);\n        double w = sqrt( sq(a.r) - sq(h) );\n        result.push_back(  w * e + p);\n        result.push_back(- w * e + p);\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, circle<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), b)) {\n        if (does_include(a, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, segment<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), to_line(b))) {\n        if (does_include(a, p) and does_include(b, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(segment<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nbool does_intersect(arc<double> const & a, segment<double> const & b) {\n    return not intersection_points(a, b).empty();\n}\nbool does_intersect(segment<double> const & a, arc<double> const & b) {\n    return does_intersect(b, a);\n}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\nint main() {\n    while (true) {\n        point<ll> p[3];\n        cin >> p[0];\n        if (p[0].x == 0 and p[0].y == 0) break;\n        cin >> p[1] >> p[2];\n        circle<ll> c;\n        cin >> c.p >> c.r;\n        if (\n                length_squared(c.p - p[0]) <= sq(c.r) and\n                length_squared(c.p - p[1]) <= sq(c.r) and\n                length_squared(c.p - p[2]) <= sq(c.r)) {\n            cout << 'b' << endl;\n        } else if (\n                ccw(p[0], p[1], c.p) == 0 or\n                ccw(p[1], p[2], c.p) == 0 or\n                ccw(p[2], p[0], c.p) == 0) {\n            cout << 'c' << endl;\n        } else {\n            ll x = sq(cross(p[1] - p[0], c.p - p[0])) - sq(c.r) * length_squared(p[1] - p[0]);\n            ll y = sq(cross(p[2] - p[1], c.p - p[1])) - sq(c.r) * length_squared(p[2] - p[1]);\n            ll z = sq(cross(p[0] - p[2], c.p - p[2])) - sq(c.r) * length_squared(p[0] - p[2]);\n            if (abs(\n                    ccw(p[0], p[1], c.p) +\n                    ccw(p[1], p[2], c.p) +\n                    ccw(p[2], p[0], c.p)) == 3) {\n                if (x <= 0 or y <= 0 or z <= 0) {\n                    cout << 'c' << endl;\n                } else {\n                    cout << 'a' << endl;\n                }\n            } else {\n                if (x < 0 or y < 0 or z < 0) {\n                    cout << 'c' << endl;\n                } else {\n                    cout << 'd' << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P p;double r;};    //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)       {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n// ?????¨??????????????????\nint contains(C c, P p){ //verified QUPC-G\n    double d = (c.p-p).abs();\n    if(d-c.r>EPS) return OUT;\n    if(abs(d-c.r)<EPS) return ON;\n    return IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n    if( dLP(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(L s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, L l){\n    int c1 = contains(c, l.p1);\n    int c2 = contains(c, l.p2);\n    if(c1 > c2) swap(c1, c2);\n    \n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (??\\????????¨???)\n    double d = dSP(l, c.p);\n    if(d-c.r<-EPS) return true;\n    if(d-c.r>EPS) return false;\n    return true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nbool isPointInsidePolygon(vector<P> pol,P p){\n    int c=0;\n    rep(i,pol.size()){\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n    }\n    return !(c%pol.size());\n}\n\n//?????¨???????§???¢???????????¶??????????????? verified AOJ0153\nint CPOLarea(C c ,Polygon pol){\n    vector<L> lines;\n    vector<int> res(pol.size());\n    bool POLinC=true, isFar=true;\n    \n    rep(i,pol.size()){\n        res[i] = contains(c,pol[i]);\n        if(sqDist(c.p,pol[i])-c.r*c.r<-EPS)isFar=false;\n        lines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n    }\n    rep(i,res.size()) if( res[i]==OUT )POLinC=false;\n    \n    rep(i,lines.size()) if( iCS(c,lines[i]) )       return 1;   //????§???¢??¨????????????\n    if( POLinC )                                    return 2;   //????§???¢??????????????¨\n    if( isPointInsidePolygon(pol, c.p) && isFar )   return 3;   //????§???¢????????¨??????\n    return 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps),cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????????????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int tx,ty;\n    while(cin>>tx>>ty&&(tx||ty)){\n        Polygon pol(3);\n        C c;\n        pol[0] = P(tx,ty);\n        rep(i,2)cin>>pol[i+1].x>>pol[i+1].y;\n        cin>>c.p.x>>c.p.y>>c.r;\n        \n        int res = CPOLarea(c,pol);\n        cout<<(char)('a'+(3-res))<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-4;\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& a, const Point& b)\n{\n\treturn a.real()*b.real() + a.imag()*b.imag();\n}\ndouble cross(const Point& a, const Point& b)\n{\n\treturn a.real()*b.imag() - a.imag()*b.real();\n}\ndouble distance_line_point(const Point& point, const Point& a, const Point& b)\n{\n\treturn abs(cross(a-b, point-b) / (a-b));\n}\ndouble distance_linesegment_point(const Point& point, const Point& a, const Point& b)\n{\n\tif (dot(b-a, point-a) < 0)\n\t\treturn abs(a-point);\n\telse if (dot(a-b, point-b) < 0)\n\t\treturn abs(b-point);\n\telse\n\t\treturn distance_line_point(point, a, b);\n}\nbool is_in_triangle(const Point& point, const Point* triangle)\n{\n\tdouble t[3];\n\tfor (int i = 0; i < 3; ++i)\n\t\tt[i] = cross(triangle[(i+1)%3] - triangle[i], point - triangle[i]);\n\treturn t[0] >= 0 && t[1] >= 0 && t[2] >= 0\n\t\t|| t[0] <= 0 && t[1] <= 0 && t[2] <= 0;\n}\nbool is_in_triangle(const Point& point, const Point& a, const Point& b, const Point& c)\n{\n\tPoint t[3] = { a, b, c };\n\treturn is_in_triangle(point, t);\n}\nbool is_circle_in_triangle(const Point& center, double radius, const Point* triangle)\n{\n\tif (!is_in_triangle(center, triangle))\n\t\treturn false;\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_line_point(center, triangle[i], triangle[(i+1)%3]) < radius - Eps)\n\t\t\treturn false;\n\treturn true;\n}\nbool is_triangle_in_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (abs(triangle[i]-center) > radius + Eps)\n\t\t\treturn false;\n\treturn true;\n}\nbool interect_triangle_circle(const Point* triangle, const Point& center, double radius)\n{\n\tfor (int i = 0; i < 3; ++i)\n\t\tif (distance_linesegment_point(center, triangle[i], triangle[(i+1)%3]) < radius + Eps)\n\t\t\treturn true;\n\treturn false;\n}\n\nint main()\n{\n\tint x[4], y[4], r;\n\twhile (true)\n\t{\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tscanf(\"%d %d\", x+i, y+i);\n\t\tscanf(\"%d\", &r);\n\t\tif (x[0] == 0 && y[0] == 0)\n\t\t\tbreak;\n\t\tPoint p[4];\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t\tp[i] = Point(x[i], y[i]);\n\n\t\tif (is_circle_in_triangle(p[3], r, p))\n\t\t\tputs(\"a\");\n\t\telse if (is_triangle_in_circle(p, p[3], r))\n\t\t\tputs(\"b\");\n\t\telse if (interect_triangle_circle(p, p[3], r))\n\t\t\tputs(\"c\");\n\t\telse\n\t\t\tputs(\"d\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define EPS (1e-8)\n\ntypedef complex<double> P;\ntypedef P Vec;\n\nstruct Line {\n\tP p;\n\tVec v;\n\t\n\tLine() {}\n\tLine(P p, Vec v) : p(p), v(v) {}\n\t\n\tP getPoint(double t) {\n\t\treturn p + v * t;\n\t}\n};\n\nstruct Circle {\n\tP p;\n\tdouble r;\n\t\n\tCircle() {}\n\tCircle(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot(Vec a, Vec b) { return a.real() * b.real() + a.imag() * b.imag(); }\ndouble cross(Vec a, Vec b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\nbool isInCir(Circle &c, P &p) { return norm(c.p - p) <= c.r*c.r + EPS; }\n\nbool isInSeg(Line &s, P &p) {\n\tVec a = s.v, b = p - s.p;\n\tdouble l1 = abs(a), l2 = abs(b);\n\t\n\treturn dot(a, b) >= l1*l2 - EPS && dot(a, b) <= l1*l2 + EPS && l1 >= l2 - EPS;\n}\n\nbool isInTri(P &a, P &b, P &c, P &d) {\n\tP p[4];\n\tp[0] = a; p[1] = b; p[2] = c; p[3] = d;\n\t\n\tint cnt = 0;\n\tREP(i, 3) {\n\t\tVec v = p[3] - p[i];\n\t\tLine s(p[i], p[(i + 1) % 3] - p[i]);\n\t\t\n\t\tif (isInSeg(s, p[3])) return true;\n\t\tif (cross(s.v, v) < -EPS) cnt++;\n\t}\n\treturn (cnt == 0 || cnt == 3);\n}\n\ndouble distanceSP(Line &s, P &p) {\n\tVec a = p - s.p, b = p - s.getPoint(1.0);\n\t\n\tif (dot(s.v, a) < -EPS) return abs(a);\n\tif (dot(s.v, a) > dot(s.v, s.v) + EPS) return abs(b);\n\treturn abs(cross(s.v, a)) / abs(s.v);\n}\n\nint main() {\n\tdouble x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile (cin >> x1 >> y1, x1 || y1) {\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\t\n\t\tP p[4] = {P(x1, y1), P(x2, y2), P(x3, y3), P(x4, y4)};\n\t\tLine seg[3] = {Line(p[0], p[1] - p[0]), Line(p[1], p[2] - p[1]), Line(p[2], p[0] - p[2])};\n\t\tCircle c(p[3], r);\t\t\n\t\t\n\t\tdouble m = min(distanceSP(seg[0], c.p), min(distanceSP(seg[1], c.p), distanceSP(seg[2], c.p)));\n\t\t\n\t\tif (isInCir(c, p[0]) && isInCir(c, p[1]) && isInCir(c, p[2]))\n\t\t\tputs(\"b\");\n\t\telse if (isInTri(p[0], p[1], p[2], p[3])) {\n\t\t\tif (c.r <= m + EPS) puts(\"a\");\n\t\t\telse puts(\"c\");\n\t\t}\n\t\telse if (c.r < m - EPS) puts(\"d\");\n\t\telse puts(\"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{ point a,b; };\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point t,point* p,int N){\n  int i,count=0,j=0;\n  segment lt,lp;\n\n  p[N]=p[0];\n  p[N+1]=p[1];\n\n  lt.a=lt.b=t;\n  lt.b.x=INT_MAX;\n\n  for(i=1;i<=N;i++){\n    lp.a=lp.b=p[i];\n\n    if(!is_intersected_ls(lp.a,lp.b,lt.a,lt.b)){\n      if(i==j+1){\n\tlp.b=p[j];\n\tif(is_intersected_ls(lp.a,lp.b,lt.a,lt.b))count++;\n      }\n      else if(ccw(lt.a,lt.b,p[i])*ccw(lt.a,lt.b,p[j])<0)count++;\n      j=i;\n    }\n  }\n  return count & 1;\n}\n\nint crossCP(point* ps, circle C, int sz){\n\n  double ans=0;\n\n  for(int i=0;i<sz;i++){\n    double tmp=dist(ps[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,ps,sz);\n\n  double res2=100000000;\n  ps[3]=ps[0];\n  for(int i=0;i<sz;i++)\n    res2=min(res2,distance_ls_p(ps[i],ps[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p[6];\n  vector<segment> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(p,C,3);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) { // ??´???l???????????????p?????????\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nint ccw(P a, P b, P c) { // ????????£???????????????????????¨???????????????????????¨????????????\n  b = vec(a,b); c = vec(a,c);\n\n  // a - b - c ????????????????????¨???\n  if(sgn(outp(b,c),0.0) > 0) return +1; // ???????¨???????\n  if(sgn(outp(b,c),0.0) < 0) return -1; // ????¨???????\n\n  // a - b - c ?????´??????????????¶??¨???\n  // sgn???????????????????£????????????£?????????\n  if(sgn(inp(b,c),0.0) < 0)  return +2; // c - a - b\n  if(sgn(abs(b),abs(c)) < 0) return -2; // a - b - c\n  return 0;                             // a - c - b\n}\n// ON = 0, IN = 1, OUT = -1\nint containsGP(vector<P> g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(g[i], g[(i+1)%g.size()], p) == 0) return 0;\n    P a = vec(p, g[i]);\n    P b = vec(p, g[(i+1)%g.size()]);\n    if(a.y > b.y) swap(a, b);\n    if(sgn(a.y, 0.0) <= 0 && sgn(b.y, 0.0) > 0 && sgn(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    // a\n    if(containsGP(tri, cir.p) == 1 &&\n       sgn(cir.r, dLP(L(tri[0], tri[1]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[1], tri[2]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[2], tri[0]), cir.p)) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) > 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) > 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) > 0) {\n      cout << \"d\" << endl;\n      continue;\n    }\n    cout << \"c\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> Po;\nPo p[3],o;\n\ndouble dot(Po x, Po y){return x.real()*y.real()+x.imag()*y.imag();}\n\ndouble cross(Po x, Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a, Po b, Po c){return abs(cross(b-a,c-a))/2;}\n\nbool inter(Po a, Po b, Po c, Po x){\n  return (fabs(area(a,b,x)+area(b,c,x)+area(c,a,x)-area(a,b,c)) < EPS);\n}\n\ndouble seg_dis(Po a, Po b, Po c){\n  if(dot(b-a,c-a)<EPS)return abs(c-a);\n  if(dot(a-b,c-b)<EPS)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nint main(){\n  double x[4],y[4],r;\n  int i;\n\n  for(;;){\n    cin >> x[0] >> y[0];\n    if(!x[0] && !y[0])break;\n\n    for(i=1;i<4;i++)cin >> x[i] >> y[i];\n    cin >> r;\n\n    for(i=0;i<3;i++)p[i] = Po(x[i],y[i]);\n    o = Po(x[3],y[3]);\n\n\n    bool f = true;;\n    for(i=0;i<3;i++)f &= !(abs(o-p[i])>r);\n    if(f)cout << \"b\\n\";\n    else if(inter(p[0],p[1],p[2],o)){\n      f = true;\n      for(i=0;i<3;i++)f &= !(seg_dis(p[i],p[(i+1)%3],o)<r);\n      if(f)cout << \"a\\n\";\n      else cout << \"c\\n\";\n    }else{\n      for(i=0;i<3;i++)f |= !(seg_dis(p[i],p[(i+1)%3],o)>r);\n      if(f)cout << \"c\\n\";\n      else cout << \"d\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef double D;\ntypedef complex<D> P;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\ndouble x[3],y[3],xr,yr,r;\nbool dis(int p){\n  return sqrt(abs(x[p]-xr)*abs(x[p]-xr)+abs(y[p]-yr)*abs(y[p]-yr))<=r+0.01;\n}\nmain(){\n  while(cin>>x[0]>>y[0],x[0]+y[0]){\n    int sum=0;\n    r(i,2)cin>>x[i+1]>>y[i+1];\n    cin>>xr>>yr>>r;\n    r(i,3)if(dis(i))sum++;\n    if(sum==0){\n      int pp=0;\n      r(i,3)pp+=ccw(P(x[i],y[i]),P(x[(i+1)%3],y[(i+1)%3]),P(xr,yr));\n      if(abs(pp)==3)cout<<'a'<<endl;\n      else cout<<'d'<<endl;\n    }\n    else if(sum==3)cout<<'b'<<endl;\n    else cout<<'c'<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P p;double r;};    //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)       {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n// ?????¨??????????????????\nint contains(C c, P p){ //verified QUPC-G\n    double d = (c.p-p).abs();\n    if(d-c.r>EPS) return OUT;\n    if(abs(d-c.r)<EPS) return ON;\n    return IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n    if( dLP(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(L s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, L l){\n    int c1 = contains(c, l.p1);\n    int c2 = contains(c, l.p2);\n    if(c1 > c2) swap(c1, c2);\n    \n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (??\\????????¨???)\n    double d = dSP(l, c.p);\n    if(d-c.r<-EPS) return true;\n    if(d-c.r>EPS) return false;\n    return true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nbool isPointInsidePolygon(vector<P> pol,P p){\n    int c=0;\n    rep(i,pol.size()){\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n    }\n    return !(c%pol.size());\n}\n\n//?????¨???????§???¢???????????¶??????????????? verified AOJ0153\nint CPOLarea(C c ,Polygon pol){\n    vector<L> lines;\n    vector<int> res(pol.size());\n    bool POLinC=true, isFar=true;\n    \n    rep(i,pol.size()){\n        res[i] = contains(c,pol[i]);\n        if(sqDist(c.p,pol[i])-c.r*c.r<-EPS)isFar=false;\n        lines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n    }\n    rep(i,res.size()) if( res[i]==OUT )POLinC=false;\n    \n    if( POLinC )                                    return 2;   //????§???¢??????????????¨\n    if( isPointInsidePolygon(pol, c.p) && isFar )   return 3;   //????§???¢????????¨??????\n    rep(i,lines.size()) if( iCS(c,lines[i]) )       return 1;   //????§???¢??¨????????????\n    return 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps),cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????????????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int tx,ty;\n    while(cin>>tx>>ty&&(tx||ty)){\n        Polygon pol(3);\n        C c;\n        pol[0] = P(tx,ty);\n        rep(i,2)cin>>pol[i+1].x>>pol[i+1].y;\n        cin>>c.p.x>>c.p.y>>c.r;\n        \n        int res = CPOLarea(c,pol);\n        cout<<(char)('a'+(3-res))<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\nclass Circle {\npublic:\n\tPoint p; long double r;\n\tCircle() : p(Point()), r(0.0L) {};\n\tCircle(Point p_) : p(p_), r(0.0L) {};\n\tCircle(Point p_, long double r_) : p(p_), r(r_) {};\n\tCircle(long double x_, long double y_) : p(Point(x_, y_)), r(0.0L) {};\n\tCircle(long double x_, long double y_, long double r_) : p(Point(x_, y_)), r(r_) {};\n\tfriend bool operator==(const Circle& c1, const Circle& c2) { return c1.p == c2.p && c1.r == c2.r; }\n\tfriend bool operator!=(const Circle& c1, const Circle& c2) { return !(c1 == c2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nPoint prj(const Segment& a, const Point& b) { return a.p1 + (a.p2 - a.p1) * dot(b - a.p1, a.p2 - a.p1) / norm(a.p2 - a.p1); }\nPoint prj(const Line& a, const Point& b) { return a.p1 + (a.p2 - a.p1) * dot(b - a.p1, a.p2 - a.p1) / norm(a.p2 - a.p1); }\nPoint rfl(const Segment& a, const Point& b) { return b + (prj(a, b) - b) * 2.0L; }\nPoint rfl(const Line& a, const Point& b) { return b + (prj(a, b) - b) * 2.0L; }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Line& a, const Point& b) {\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nlong double dst(const Segment& a, const Segment& b) {\n\tif (its(a, b)) return 0;\n\treturn min( { dst(a, b.p1), dst(a, b.p2), dst(b, a.p1), dst(b, a.p2) });\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3; Segment l1, l2, l3; Circle c;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> c.p.px >> c.p.py >> c.r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, c.p) <= c.r && dst(p2, c.p) <= c.r && dst(p3, c.p) <= c.r) printf(\"b\\n\");\n\t\telse if(dst(l1, c.p) >= c.r && dst(l2, c.p) >= c.r && dst(l3, c.p) >= c.r) printf(contain({p1, p2, p3}, c.p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\ndouble sign(double r) { return r < -EPS ? -1.0 : r > EPS ? 1.0 : 0.0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0.0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) <= 0.0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n\n// code for problem\nint x, y, r;\nvector<P> T;\nC cc;\n\nbool isPinC() {\n\tP e0 = T[0] - cc.p;\n\tP e1 = T[1] - cc.p;\n\tP e2 = T[2] - cc.p;\n\tdouble d0 = e0.det(e1);\n\tdouble d1 = e1.det(e2);\n\tdouble d2 = e2.det(e0);\n\tif(sign(d0) == sign(d1) && sign(d0) == sign(d2)) return true;\n\treturn false;\n}\n\nvoid solve() {\n\tvector<double> d(3);\n\td[0] = (T[0] - cc.p).norm();\n\td[1] = (T[1] - cc.p).norm();\n\td[2] = (T[2] - cc.p).norm();\n\tif(sign(d[0] - cc.r) <= 0.0 && sign(d[1] - cc.r) <= 0.0 && sign(d[2] - cc.r) <= 0.0) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\tbool in = isPinC();\n\tL l0(T[0], T[1]);\n\tL l1(T[1], T[2]);\n\tL l2(T[2], T[0]);\n\td[0] = l0.dSP(cc.p);\n\td[1] = l1.dSP(cc.p);\n\td[2] = l2.dSP(cc.p);\n\tif(in && sign(d[0] - cc.r) >= 0.0 && sign(d[1] - cc.r) >= 0.0 && sign(d[2] - cc.r) >= 0.0) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(!in && sign(d[0] - cc.r) > 0.0) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\tT = vector<P>(3);\n\tfor(;;) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\tT[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst double eps = 1e-8;\nint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\ndouble distDbl(double ax, double ay, double bx, double by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\ndouble getPerpDistDbl(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, res;\n    if (ax == bx) {\n        res = (cx - ax) * (cx - ax);\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        res = (a * cx - cy + b) * (a * cx - cy + b) / (1 + a * a);\n    }\n    return res;\n}\n\ndouble getPerpDistSegDbl(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, x, y, res;\n    if (ax == bx) {\n        y = cy;\n        if (min(ay, by) <= y && y <= max(ay,by)) {\n            res = (cx - ax) * (cx - ax);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        x = (cx + a * (cy - b)) / (1 + a * a);\n        y = a * x + b;\n        if (min(ax, bx) <= x && x <= max(ax,bx) &&\n            min(ay, by) <= y && y <= max(ay,by)) {\n            res = distDbl(x,y,cx,cy);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    }\n    return res;\n}\n\nbool isA() {\n    int c = 0;\n    if (0 <= (x2-x1)*(y4-y1)-(y2-y1)*(x4-x1)) ++c;\n    if (0 <= (x3-x2)*(y4-y2)-(y3-y2)*(x4-x2)) ++c;\n    if (0 <= (x1-x3)*(y4-y3)-(y1-y3)*(x4-x3)) ++c;\n    if (c % 3 != 0) return false;\n    if (getPerpDistDbl(x1, y1, x2, y2, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x2, y2, x3, y3, x4, y4) + eps < r*r) return false;\n    if (getPerpDistDbl(x3, y3, x1, y1, x4, y4) + eps < r*r) return false;\n    return true;\n}\n\nbool isB() {\n    if (distDbl(x1,y1,x4,y4) <= r*r && distDbl(x2,y2,x4,y4) <= r*r && distDbl(x3,y3,x4,y4) <= r*r) {\n        return true;\n    }\n    return false;\n}\n\nbool isC() {\n    if (getPerpDistSegDbl(x1,y1,x2,y2,x4,y4) <= r*r + eps) return true;\n    if (getPerpDistSegDbl(x2,y2,x3,y3,x4,y4) <= r*r + eps) return true;\n    if (getPerpDistSegDbl(x3,y3,x1,y1,x4,y4) <= r*r + eps) return true;\n    return false;\n}\n\nint main() {\n    while (cin >> x1 >> y1, (x1 || y1)) {\n        cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n        if (isB()) cout << \"b\" << endl;\n        else if (isA()) cout << \"a\" << endl;\n        else if (isC()) cout << \"c\" << endl;\n        else cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n \nusing namespace std;\n \n#define F first\n#define S second\n \n#define X real()\n#define Y imag()\n \n#define EPS (1e-7)\n \ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\ntypedef pair<double, Point> Circle;\n \nbool isPointInCircle(const Point& p, const Circle& c) {\n  if(abs(p-c.S) < abs(c.F) + EPS) return true;\n  return false;\n}\n \ndouble dot(const Point& a, const Point& b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n \ndouble cross(const Point& a, const Point& b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n \ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n \ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n \ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n   \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n \n \nenum struct ECont { OUT, ON, IN };\nECont contains(const Polygon& poly, const Point& p) {\n  bool in = 0;\n  for(int i=0; i<poly.size(); i++) {\n    Point a = poly[i] - p, b = poly[(i+1)%poly.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag()) {\n      if(cross(a, b) < 0) in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ECont::ON;\n  }\n   \n  return in ? ECont::IN : ECont::OUT;\n}\n \nint main() {\n   \n  while(1) {\n    Polygon points(3);\n    Circle circle;\n   \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n     \n      points[i] = Point(x, y);\n    }\n   \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n   \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n     \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3) {\n      int flg = 0;\n      for(int i=0; i<3; i++) {\n        if(contains(points, circle.S) == ECont::IN) {\n        //if(dot(points[(i+1)%3]-points[i], circle.S-points[i]) * dot(points[(i+2)%3]-points[(i+1)%3], circle.S-points[(i+1)%3]) > 0) {\n          flg ++;\n        }\n      }\n      if(flg == 3) { cout << 'a' << endl; continue; }\n    }\n \n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) <= circle.F + EPS;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconst double eps = 1e-7;\nnamespace boost {\ntemplate <class T>\nstruct integer_iterator {\n    T a;\n    bool operator != (integer_iterator const & it) const { return a != it.a; }\n    T operator * () const { return a; }\n    integer_iterator & operator ++ () { ++ a; return *this; }\n    integer_iterator operator ++ (int) { return { a ++ }; }\n};\ntemplate <class T>\nstruct integer_range {\n    T l, r;\n    typedef integer_iterator<T> iterator;\n    iterator begin() const { return { l }; }\n    iterator end  () const { return { r }; }\n};\ntemplate <class T>\ninteger_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }\ntemplate <class T>\nstruct integer_iterator_with_step {\n    T a, d, i;\n    bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }\n    T operator * () const { return a+d*i; }\n    integer_iterator_with_step & operator ++ () { ++ i; return *this; }\n    integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }\n};\ntemplate <class T>\nstruct strided_integer_range {\n    T l, r, s;\n    typedef integer_iterator_with_step<T> iterator;\n    iterator begin() const { return { l, s, 0 }; }\n    iterator end  () const { return { l, s, (r - l) / s }; }\n};\ntemplate <class T>\nstrided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }\n}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };\nttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }\nttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }\nttt point<T> operator - (pca a) { return { -a.x, -a.y }; }\nttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }\nttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }\nttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }\nttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }\nttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }\nttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }\nttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }\nttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }\nttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }\nttt double length(pca p) { return sqrt(length_squared(p)); }\nttt point<T> normalized(pca a) { return (1 / length(a)) * a; }\nttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }\nttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }\nttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }\ntemplate <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> bool operator == (circle<T> const & a, circle<T> const & b) { return a.p == b.p and a.r == b.r; }\ntemplate <typename T> bool operator != (circle<T> const & a, circle<T> const & b) { return not (a == b); }\ntemplate <typename T> struct line { point<T> a, b; };\ntemplate <typename T> struct ray { point<T> a, b; };\ntemplate <typename T> struct segment { point<T> a, b; };\ntemplate <typename T> T length_squared(segment<T> const & p) { return length_squared(p.a - p.b); }\ntemplate <typename T> double length(segment<T> const & p) { return length(p.a - p.b); }\ntemplate <typename T>    line<T> to_line(    ray<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>    line<T> to_line(segment<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(   line<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(segment<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment(line<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment( ray<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T>\nstruct arc { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT length(arc<T> const & a) { return a.r * (a.b - a.a); }\ntemplate <typename T>\nbool valid(arc<T> const & a) {\n    assert (0 <= a.r);\n    return\n        - M_PI < a.a + eps and a.a < M_PI + eps and\n        - M_PI < a.b + eps and a.b < M_PI + eps;\n}\ntemplate <typename T>\ncircle<T> to_circle(arc<T> const & a) { return { a.p, a.r }; }\n\ntemplate <typename T>\nstruct circular_sector { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT sq(T x) { return x * x; }\ntemplate <typename T>\npoint<T> rotate_90(point<T> const & a) {\n    return { - a.y, a.x };\n}\ntemplate <typename T>\npoint<T> rotate_270(point<T> const & a) {\n    return { a.y, - a.x };\n}\ntemplate <typename T>\npoint<T> rotate_180(point<T> const & a) {\n    return { - a.x, - a.y };\n}\npoint<double> rotate(point<double> const & a, double th) {\n    return {\n        a.x * cos(th) - a.y * sin(th),\n        a.x * sin(th) + a.y * cos(th) };\n}\ntemplate <>\nint ccw(point<double> const & a, point<double> const & b, point<double> const & c) {\n    double x = cross(b - a, c - a);\n    return x > eps ? 1 : x < - eps ? -1 : 0;\n}\n\ndouble distance(point<double> const & a, point<double> const & b) {\n    return length(b - a);\n}\n\ndouble distance(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return std::abs( cross(p, e) );\n}\ndouble distance(point<double> const & a, line<double> const & b) {\n    return distance(b,a);\n}\n\nbool does_include(circle<double> const & a, point<double> const & b) {\n    return length(a.p - b) < a.r + eps;\n}\nbool is_on_circumference(point<double> const & a, circle<double> const & b) {\n    return std::abs(length(b.p - a) - b.r) < eps;\n}\n// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < std::abs(a.r - b.r) + eps;\n}\n// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < a.r + b.r + eps;\n}\n// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;\n}\n// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {\n    std::vector<point<double> > result;\n    if (distance(a.p, b.p) < eps) {\n        // nop\n    } else if (not does_intersect(a,b)) {\n        // nop\n    } else if (does_include(a,b) and not does_inscribe(a,b)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(a,b) or does_circumscribe(a,b)) {\n        circle<double> x = a;\n        circle<double> y = b;\n        if (not (x.r < y.r)) std::swap(x, y);\n        result.push_back(y.r * normalized(x.p - y.p) + y.p);\n    } else {\n        //       c\n        //      /|\\\n        // a.r / | \\ b.r\n        //    /th|  \\\n        //   a-------b\n        //       l\n        double l = length(b.p - a.p);\n        double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\n        double as = sqrt( sq(a.r) - sq(ac) );\n        point<double> e = normalized(b.p - a.p);\n        result.push_back(a.p + ac*e + as*rotate_90(e));\n        result.push_back(a.p + ac*e + as*rotate_270(e));\n    }\n    for (auto p : result) {\n        assert (does_include(a, p));\n        assert (does_include(b, p));\n    }\n    return result;\n}\n\nstd::vector<line<double> > tangents(circle<double> const & a, point<double> const & b) {\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not is_on_circumference(b,a)) {\n        // truly included\n        // nop\n    } else if (is_on_circumference(b,a)) {\n        point<double> e = normalized(a.p - b);\n        result.push_back({\n                b + rotate_90(e),\n                b + rotate_270(e) });\n    } else {\n        double theta = asin(a.r / length(b - a.p));\n        result.push_back({ b, b + rotate(a.p - b, + theta) });\n        result.push_back({ b, b + rotate(a.p - b, - theta) });\n    }\n    return result;\n}\n\nstd::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {\n    point<double> p = a.p + (a.r / (a.r + b.r)) * (b.p - a.p);\n    return tangents(a,p);\n}\nstd::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {\n    if (b.r < a.r) std::swap(a,b);\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not does_inscribe(b,a)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(b,a)) {\n        point<double> e = normalized(a.p - b.p);\n        result.push_back({\n                b.p + a.r*e + rotate_90(e),\n                b.p + a.r*e + rotate_270(e) });\n    } else {\n        point<double> d = b.p - a.p;\n        double theta = asin((b.r - a.r) / length(d));\n        point<double> dp = rotate(d, + theta);\n        point<double> dm = rotate(d, - theta);\n        point<double> ep = rotate_90(normalized(dp));\n        point<double> em = rotate_270(normalized(dm));\n        result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });\n        result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });\n    }\n    return result;\n}\nstd::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {\n    std::vector<line<double> > result;\n    for (auto l : common_inner_tangents(a,b)) result.push_back(l);\n    for (auto l : common_outer_tangents(a,b)) result.push_back(l);\n    return result;\n}\n\npoint<double> nearest_point(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return a.a + dot(p, e) * e;\n}\nbool is_tangent(line<double> const & a, circle<double> const & b) {\n    return std::abs( b.r - distance(a, b.p) ) < eps;\n}\nbool does_include(segment<double> const & a, point<double> const & b) {\n    point<double> p = b - a.a;\n    point<double> e = normalized(a.b - a.a);\n    return std::abs( cross(e, p) ) < eps and - eps < dot(e, p) and dot(e, p) < length(a) + eps;\n}\nbool is_tangent(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return is_tangent(l, b) and does_include(a, nearest_point(l, b.p));\n}\nbool does_intersect(line<double> const & a, circle<double> const & b) {\n    return distance(a, b.p) < b.r + eps;\n}\nbool does_intersect(circle<double> const & a, line<double> const & b) {\n    return does_intersect(b, a);\n}\nbool does_intersect(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return does_intersect(l, b) and\n        (does_include(a, nearest_point(l, b.p)) or\n         distance(a.a, b.p) < b.r + eps or\n         distance(a.b, b.p) < b.r + eps);\n}\n\nbool does_intersect(line<double> const & a, line<double> const & b) {\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return eps < std::abs( cross(p, q) );\n}\nbool is_parallel(line<double> const & a, line<double> const & b) {\n    return not does_intersect(a, b);\n}\nbool does_intersect(segment<double> const & a, segment<double> const & b) {\n    return\n        ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) == -1 and\n        ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) == -1;\n}\npoint<double> intersection_point(line<double> const & a, line<double> const & b) {\n    assert (does_intersect(a, b));\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return a.a + ( cross(q, b.a - a.a) / cross(q, p) ) * p;\n}\n\nbool does_include(ray<double> const & a, point<double> const & b) {\n    return ccw(a.a, a.b, b) == 0 and dot(a.b - a.a, b - a.a) > - eps;\n}\nbool does_intersect(ray<double> const & a, segment<double> const & b) {\n    if (does_include(a, b.a) or does_include(a, b.b)) return true;\n    line<double> la = to_line(a);\n    line<double> lb = to_line(b);\n    if (is_parallel(la, lb)) return false;\n    point<double> p = intersection_point(la, lb);\n    return does_include(a,p) and does_include(b,p);\n}\nbool does_intersect(segment<double> const & a, ray<double> const & b) {\n    return does_intersect(b, a);\n}\n\npoint<double> projection(point<double> const & a, line<double> const & b) {\n    point<double> e = normalized(b.b - b.a);\n    return dot(e, a - b.a) * e + b.a;\n}\ndouble distance(segment<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_line(a));\n    if (does_include(a, p)) {\n        return distance(to_line(a), b);\n    } else{\n        return std::min(distance(a.a, b), distance(a.b, b));\n    }\n}\ndouble distance(point<double> const & a, segment<double> const & b) {\n    return distance(b, a);\n}\ndouble distance(segment<double> const & a, segment<double> const & b) {\n    return std::min(std::min(std::min(\n            distance(a.a, b),\n            distance(a.b, b)),\n            distance(a, b.a)),\n            distance(a, b.b));\n}\n\npoint<double> projection(point<double> const & a, circle<double> const & b) {\n    return b.r * normalized(a - b.p) + b.p;\n}\nbool does_include(arc<double> const & a, point<double> const & b) {\n    assert (valid(a));\n    point<double> e = b - a.p;\n    double r = length(e);\n    double th = atan2(e.y, e.x);\n    return std::abs(a.r - r) < eps and  a.a < th + eps and th < a.b + eps;\n}\ndouble distance(arc<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_circle(a));\n    if (does_include(a, p)) {\n        return distance(p, b);\n    } else{\n        point<double> l = a.r * (point<double>) { cos(a.a), sin(a.a) } + a.p;\n        point<double> r = a.r * (point<double>) { cos(a.b), sin(a.b) } + a.p;\n        return std::min(distance(l, b), distance(r, b));\n    }\n}\ndouble distance(point<double> const & a, arc<double> const & b) {\n    return distance(b, a);\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    if (not does_intersect(a, b)) {\n        // nop\n    } else if (is_tangent(b, a)) {\n        result.push_back(nearest_point(b, a.p));\n    } else {\n        point<double> e = normalized(b.b - b.a);\n        point<double> p = nearest_point(b, a.p);\n        double h = distance(p, a.p);\n        double w = sqrt( sq(a.r) - sq(h) );\n        result.push_back(  w * e + p);\n        result.push_back(- w * e + p);\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, circle<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), b)) {\n        if (does_include(a, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, segment<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), to_line(b))) {\n        if (does_include(a, p) and does_include(b, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(segment<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nbool does_intersect(arc<double> const & a, segment<double> const & b) {\n    return not intersection_points(a, b).empty();\n}\nbool does_intersect(segment<double> const & a, arc<double> const & b) {\n    return does_intersect(b, a);\n}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\nint main() {\n    while (true) {\n        point<double> p[3];\n        cin >> p[0];\n        if (p[0].x == 0 and p[0].y == 0) break;\n        cin >> p[1] >> p[2];\n        circle<double> c;\n        cin >> c.p >> c.r;\n        if (\n                length_squared(c.p - p[0]) <= sq(c.r) and\n                length_squared(c.p - p[1]) <= sq(c.r) and\n                length_squared(c.p - p[2]) <= sq(c.r)) {\n            cout << 'b' << endl;\n        } else if (\n                ccw(p[0], p[1], c.p) == 0 or\n                ccw(p[1], p[2], c.p) == 0 or\n                ccw(p[2], p[0], c.p) == 0) {\n            cout << 'c' << endl;\n        } else if (abs(\n                    ccw(p[0], p[1], c.p) +\n                    ccw(p[1], p[2], c.p) +\n                    ccw(p[2], p[0], c.p)) == 3) {\n            if (\n                    does_intersect((segment<double>){ p[0], p[1] }, c) or\n                    does_intersect((segment<double>){ p[1], p[2] }, c) or\n                    does_intersect((segment<double>){ p[2], p[0] }, c)) {\n                cout << 'c' << endl;\n            } else {\n                cout << 'a' << endl;\n            }\n        } else {\n            if (\n                    does_intersect((segment<double>){ p[0], p[1] }, c) or\n                    does_intersect((segment<double>){ p[1], p[2] }, c) or\n                    does_intersect((segment<double>){ p[2], p[0] }, c)) {\n                cout << 'c' << endl;\n            } else {\n                cout << 'd' << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return center.distance(p) < r;}\n    bool include(const Segment& s) const {return center.distance(s) < r;}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n//     if(s.ccw(p) == ON) return distance(p);\n    if(s.start.distance(p) + s.end.distance(p) - s.start.distance(s.end) < EPS) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x - y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + Point(t, t) * v2;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n//     for(auto& e: edge) if(circle.include(e)) return \"c\";\n    double minimum = DBL_MAX;\n    for(auto& e: edge) minimum = min(minimum, circle.center.distance(e));\n\n    bool centerInTriangle = true;\n    POSITION ccw = (*edge.begin()).ccw(circle.center);\n    for(auto& e: edge) if(ccw != e.ccw(circle.center)) centerInTriangle = false;\n\n    if(centerInTriangle && minimum >= circle.r) return \"a\";\n    if(!centerInTriangle && minimum > circle.r) return \"d\";\n    return \"c\";\n\n//     if(cw == 3 || ccw == 3) return \"a\";//     for(auto& e: edge) {\n//         if(e.ccw(circle.center) > 0) ++ccw;\n//         if(e.ccw(circle.center) < 0) ++cw;\n//     }\n//     if(cw == 3 || ccw == 3) return \"a\";\n// \n//     return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst double eps = 1e-8;\nint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\ndouble distDbl(double ax, double ay, double bx, double by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\ndouble getPerpDist(double ax, double ay, double bx, double by, double cx, double cy) {\n    double a, b, x, y, res;\n    if (ax == bx) {\n        y = cy;\n        if (min(ay, by) <= y && y <= max(ay,by)) {\n            res = (cx - ax) * (cx - ax);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    } else {\n        a = (by - ay) / (bx - ax);\n        b = ay - a * ax;\n        x = (cx + a * (cy - b)) / (1 + a * a);\n        y = a * x + b;\n        if (min(ax, bx) <= x && x <= max(ax,bx) &&\n            min(ay, by) <= y && y <= max(ay,by)) {\n            res = distDbl(x,y,cx,cy);\n        } else {\n            res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n        }\n    }\n    return res;\n}\n\nbool isA() {\n    int c = 0;\n    if (0 <= (x2-x1)*(y4-y1)-(y2-y1)*(x4-x1)) ++c;\n    if (0 <= (x3-x2)*(y4-y2)-(y3-y2)*(x4-x2)) ++c;\n    if (0 <= (x1-x3)*(y4-y3)-(y1-y3)*(x4-x3)) ++c;\n    if (c % 3 != 0) return false;\n    if (getPerpDist(x1, y1, x2, y2, x4, y4) + eps < r*r) return false;\n    if (getPerpDist(x2, y2, x3, y3, x4, y4) + eps < r*r) return false;\n    if (getPerpDist(x3, y3, x1, y1, x4, y4) + eps < r*r) return false;\n    return true;\n}\n\nbool isB() {\n    if (distDbl(x1,y1,x4,y4) <= r*r && distDbl(x2,y2,x4,y4) <= r*r && distDbl(x3,y3,x4,y4) <= r*r) {\n        return true;\n    }\n    return false;\n}\n\nbool isC() {\n    if (getPerpDist(x1,y1,x2,y2,x4,y4) <= r*r + eps) return true;\n    if (getPerpDist(x2,y2,x3,y3,x4,y4) <= r*r + eps) return true;\n    if (getPerpDist(x3,y3,x1,y1,x4,y4) <= r*r + eps) return true;\n    return false;\n}\n\nint main() {\n    while (cin >> x1 >> y1, (x1 || y1)) {\n        cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n        if (isB()) cout << \"b\" << endl;\n        else if (isA()) cout << \"a\" << endl;\n        else if (isC()) cout << \"c\" << endl;\n        else cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-c,ar=d-a;\n\tP bb=b-a,br=d-b;\n\tP cc=c-b,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nbool foo2(P a,P b,P p,double r){\n\tdouble t=dot(b-a,p-a);\n\tif(t<-EPS){\n\t\tif(r-abs(p-a)>EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tif(t-abs(b-a)*abs(b-a)>EPS){\n\t\tif(r-abs(p-b)>EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\tdouble h=abs(p-a)*abs(p-a)-t*t/abs(b-a)/abs(b-a);\n\tif(r*r-h>EPS){\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tcin>>r;\n\t\t// cout<<r<<endl;\n\t\tif(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(t<r){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(foo2(z[0],z[1],z[3],r)||foo2(z[1],z[2],z[3],r)||foo2(z[2],z[0],z[3],r)){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse cout<<\"d\\n\";\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n//      getline(ifs, str);\n        cin >> str;\n\n      if(str == \"0 0\\n\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n        str[str.size()-1] = '\\0';\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\\n\") break;\n\n\n    if(distance(&d->p[0], &c->p) <= c->radius&& distance(&d->p[1], &c->p) <= c->radius&& distance(&d->p[2], &c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) >= c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) >= c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) >= c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) <= distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) <= distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) <= distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else\n            cout << 'a' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) <= c->radius|| dist_line(&d->p[0], &d->p[2], &c->p) <= c->radius|| dist_line(&d->p[1], &d->p[2], &c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=max(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>-EPS)return 1; //intersect\n            if(in_triangle(p,t))return 2;//c in t\n            else return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n}\n\n\nusing namespace geo;\n\nint main(){\n    int x,y,r;\n    while(cin>>x>>y,x!=0||y!=0){\n        Poly t={P(x,y)};\n        REP(i,2){\n            cin>>x>>y;\n            t.pb(P(x,y));\n        }\n        cin>>x>>y>>r;\n        C c(P(x,y),r);\n        int res=is_triangle_C(t,c);\n        if(res==2)cout<<\"a\"<<endl;\n        if(res==3)cout<<\"b\"<<endl;\n        if(res==1)cout<<\"c\"<<endl;\n        if(res==0)cout<<\"d\"<<endl;\n\n    }\n   \n    \n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n    L(){;}\n};\nstruct C {\n    P c;double r;\n    C(const P &c,double r):c(c),r(r){}\n    C(){;}\n};\n\nnamespace std{//演算子の定義\n    bool operator < (const P& a,const P& b) {\n        return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n        //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n    }\n    bool operator == (const P& a,const P& b) {\n        return a.real()==b.real() && a.imag()==b.imag();\n    }\n}\n\n\nvoid printP(const P &p){\n    cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n    for(int i = 0; i < g.size(); i++){\n        cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n    }\n}\n\n\n\ndouble dot(P a,P b) {\n    return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n    return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n    P p = a-b;\n    P q(-p.imag(), p.real());\n    return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n    double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n    return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n    return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n    return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n    return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n    return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\nbool intersectSL(const L &s, const L &l){ //直線と線分の交差判定\n    return cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//線分と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble distanceGL(const G &g, const L &l){//凸多角形と直線の距離\n    double ret = LINF;\n    int n = g.size();\n    rep(i,n){\n        L l2(g[i],g[(i+1)%n]);\n        ret = min(ret, distanceSS(l2,l));\n    }\n    return ret;\n}\n\nbool intersectCS(const C &c, const L &l){ //円と線分の交差判定\n    double close = distanceSP(l,c.c);\n    double far = max(distancePP(l[0],c.c),distancePP(l[1],c.c));\n    if(close <= c.r && far >= c.r)return true; //重なっていても良い\n    //完全に交差している場合のみだと、イコールを外す\n    return false;\n}\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\n    double t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n    double t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n    return b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n    double d = distancePP(c.c,p);\n    double r = sqrt(d*d - c.r * c.r);\n    C cc(p,r);\n    return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S = 0;\n    for(int i = 0; i < g.size(); i++){\n        S += (cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n    for(int i = 0; i < n; i++){\n        if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n    }\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n    int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n    const int n = pt.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(pt[i]) > imag(pt[is])) is = i;\n        if (imag(pt[i]) < imag(pt[js])) js = i;\n    }\n    double maxd = norm(pt[is] - pt[js]);\n\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n        if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (norm(pt[i] - pt[j]) > maxd) {\n            maxd = norm(pt[i] - pt[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n    G Q;\n    for (int i = 0; i < g.size(); ++i) {\n        P a = g[i], b = g[(i+1)%g.size()];\n        if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n        if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n        Q.push_back(crosspointLL(L(a,b), l));\n    }\n    return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n    P p = l[0];\n    P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n    L t(q, orth(p,q));\n    return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n    L l1(g[0],g[1]);\n    L l2(g[1],g[2]);\n    L m1 = PerpendicularBisector(l1);\n    L m2 = PerpendicularBisector(l2);\n    return crosspointLL(m1, m2);\n}\n\nvector<L> getLine(G g){\n    int n = g.size();\n    vector<L> ret(n);\n    rep(i,n)ret[i] = L(g[i],g[(i+1)%n]);\n    return ret;\n}\n\n\n\nP inP(){\n    double x,y;\n    //scanf(\"%lf,%lf\", &x, &y);\n    cin >> x >> y;\n    P p(x,y);\n    return p;\n}\n\n\nL inL(){\n    P p1 = inP();\n    P p2 = inP();\n    L l(p1,p2);\n    return l;\n}\n\nC inC(){\n    P p = inP();\n    double r;\n    cin >> r;\n    C c(p,r);\n    return c;\n}\n\n\nG inG(int n){\n    G g(n);\n    for(int i = 0; i < n; i++){\n        g[i] = inP();\n    }\n    return g;\n}\n\n\nsigned main(void) {\n    while(1){\n        G g(3);\n        g[0] = inP();\n        if(g[0].real() == 0 && g[0].imag() == 0)break;\n        g[1] = inP();\n        g[2] = inP();\n        C c = inC();\n        vector<L> l = getLine(g);\n        if(distancePP(c.c, g[0]) <= c.r &&\n            distancePP(c.c, g[1]) <= c.r &&\n            distancePP(c.c, g[2]) <= c.r){\n                cout << \"b\" << endl;\n        }else if(inconvex(g, c.c) &&\n            distanceSP(l[0],c.c) >= c.r &&\n            distanceSP(l[1],c.c) >= c.r &&\n            distanceSP(l[2],c.c) >= c.r){\n                cout << \"a\" << endl;\n        }else if(intersectCS(c, l[0]) ||\n                intersectCS(c, l[1]) ||\n                intersectCS(c, l[2])){\n                cout << \"c\" << endl;\n        }else{\n            cout << \"d\" << endl;\n        }\n\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ONLINE_JUDGE\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\n#define repf(i, f, l) for(int i = f; i < (int)l; ++i)\n\n#ifdef ONLINE_JUDGE\n#define DEBUG false\n#else\n#define DEBUG true\n#endif\n\n#define pb emplace_back\n#define lb lower_bound\n#define ul unsigned long\n#define ull unsigned long long\n#define ll long long\n#define INF 1000000007\n#define MOD 1000000007\n#define fs first\n#define sd second\n\n#define ALL(c) (c).begin(),(c).end()\n\n#define DBG0(x)    {if(DEBUG){ cout << #x << \": \" << x << \"\\t\"; }}\n#define DBG(x)     {if(DEBUG){DBG0(x); cout << endl;}}\n#define DBG2(x, y) {if(DEBUG){DBG0(x); DBG(y);}}\n#define DBG3(x, y, z) {if(DEBUG){DBG0(x); DBG2(y, z);}}\n#define DBG4(w, x, y, z) {if(DEBUG){DBG0(w); DBG3(x, y, z);}}\n\ntemplate <class T>\nostream& operator<<(ostream& os, vector<T> xs){ for(T x: xs) os << x << ' '; return os; }\ntemplate <class S, class T>\nostream& operator<<(ostream& os, pair<S,T> st){ os << \"(\" << st.first << \",\" << st.second <<\")\"; return os; }\n\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<ul> vul;\ntypedef vector<ull> vull;\ntypedef vector<bool> vbl;\ntypedef pair<int, int> pii;\n\n/* Library starts here */\nconst double EPS = 1.0e-14;\ntypedef complex<double> Point;\n/* Line is represented as (a, b, c) of ax + by + c = 0 */\ntypedef tuple<double, double, double> Line;\n/* Circle is represented as ((a, b), r) of (x - a)^2 + (y - b)^2 = r^2 */\ntypedef tuple<Point, double> Circle;\n/* Line segment is represented as (P1, P2) */\ntypedef tuple<Point, Point> Line_segment;\n\nconst Point O(0.0,0.0);\n\nistream& operator>>(istream& is, Point &pt){\n    double a, b;\n    is >> a >> b;\n    pt.real(a); pt.imag(b);\n    return is;\n}\n\nostream& operator<<(ostream& os, const Point &pt){\n    os << make_pair(pt.real(), pt.imag());\n    return os;\n}\n\nostream& operator<<(ostream& os, const Line &l){\n    os << \"(\" << get<0>(l) << \",\" << get<1>(l) << \",\" << get<2>(l) << \")\";\n    return os;\n}\n\ninline double cross(const Point &a, const Point &b){\n    return (a.real()*b.imag() - a.imag()*b.real());\n}\n\ninline double myarg(Point &a){\n    double ret = arg(a);\n    return (ret >= 0 ? ret : ret + 2*M_PI);\n}\n\ninline double signed_area(const Point &a, const Point &b, const Point &c){\n    Point ab = b - a;\n    Point ac = c - a;\n    return cross(ab, ac) / 2.0;\n}\n\ninline bool intersect(const Point &a1, const Point &a2, const Point &b1, const Point &b2) {\n  return ((cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS) &&\n          (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS));\n}\n\nvoid sort_by_arg(vector<Point> &pts){\n    sort(pts.begin(), pts.end(), [](Point a, Point b){ return (myarg(a) < myarg(b)); });\n}\n\n/* bad */\ndouble area(vector<Point> &vs){\n    int n = vs.size();\n    vector<Point> pts(n - 1);\n    rep(i, n - 1) pts[i] = vs[i + 1] - vs[0];\n    sort_by_arg(pts);\n    double ans = 0.0;\n    rep(i, n - 1) ans += cross(vs[i], vs[i + 1]);\n    return ans / 2.0;\n}\n\ninline Line make_line(const Point &a, const Point &b){\n    return make_tuple(a.imag() - b.imag() , b.real() - a.real(), -(a.imag() * b.real() - a.real() * b.imag()));\n}\n\ninline Line orthogonal_line(const Point &p, const Line &l){\n    return make_tuple(get<1>(l), -get<0>(l), get<0>(l) * p.imag() - get<1>(l) * p.real());\n}\n\ninline bool is_parallel(const Line &l0, const Line &l1){\n    return ((get<0>(l0)*get<1>(l1) - get<1>(l0)*get<0>(l1)) == 0.0);\n}\n\ninline Point intersection_point(const Line &l0, const Line &l1){\n    const double A = get<0>(l0);\n    const double B = get<1>(l0);\n    const double C = get<0>(l1);\n    const double D = get<1>(l1);\n    const double U = get<2>(l0);\n    const double V = get<2>(l1);\n    const double det = A*D - B*C;\n    return Point((-D*U + B*V) / det,\n                 ( U*C - A*V) / det);\n}\n\ninline Point rotate(const Point &p, const double theta){\n    double ct = cos(theta);\n    double st = sin(theta);\n    return Point(ct * p.real() - st*p.imag(), st*p.real() + ct*p.imag());\n}\n\n/* whether polygon is_included p. It is considered true if p is on the edge. */\n/* this function has not been validated */\nbool is_included(const Point &p, const vector<Point> &polygon){\n    int n = polygon.size();\n    int zero = 0;\n    int plus = 0;\n    rep(i, n){\n        const int di = (i + 1 == n ? 0 : i + 1);\n        double tmp = cross(polygon[di] - polygon[i], p - polygon[i]);\n        if(abs(tmp) <= 1e-14) zero++;\n        else if(tmp > 0.0) plus++;\n    }\n    if(zero || plus == 0 || plus == n) return true;\n    return false;\n}\n\ninline bool is_included(const Point &P, const Line &L){\n    return (P.real() * get<0>(L) + P.imag() * get<1>(L) + get<2>(L) == 0.0);\n}\n\nbool is_included(const Point &P, const Line_segment &AB){\n    Line LAB = make_line(get<0>(AB), get<1>(AB));\n    if(!is_included(P, LAB)) return false;\n    Point VAB = (get<1>(AB) - get<0>(AB));\n    Point VAP = (get<1>(AB) - P);\n    if(abs(VAP) == 0.0) return true;\n    if(VAB / abs(VAB) != VAP / abs(VAP)) return false;\n    return (abs(VAP) <= abs(VAB));\n}\n\n/* this function has not been validated */\ninline bool is_included(const Point &p, const Circle &cir){\n    return (abs(p - get<0>(cir)) <= get<1>(cir));\n}\n\n/* this function has not been validated */\ndouble distance(const Point &P, const Line &L){\n    return abs(P.real()*get<0>(L) + P.imag()*get<1>(L) + get<2>(L)) / abs(P);\n}\n\n/* distance between a point P and line segment AB */\ndouble distance(const Point &P, const Line_segment &AB){\n    Line LAB = make_line(get<0>(AB), get<1>(AB));\n    Line orth = orthogonal_line(P, LAB);\n    Point S = intersection_point(orth, LAB);\n    if(is_included(P, AB)) return abs(P - S);\n    return min(abs(P - get<0>(AB)), abs(P - get<1>(AB)));\n}\n\n/* End of the Library */\nint main(void){\n    while(true){\n        Point A, B, C, P;\n        double R;\n        cin >> A;\n        if(A.real() == 0 && A.imag() == 0) return 0;\n        cin >> B >> C >> P >> R;\n        Circle V(P, R);\n        DBG3(A, B, C);\n        DBG2(P, R);\n\n        double P_AB, P_BC, P_CA;\n        P_AB = distance(P, Line_segment(A, B));\n        P_BC = distance(P, Line_segment(B, C));\n        P_CA = distance(P, Line_segment(C, A));\n        double mn = min({P_AB, P_BC, P_CA});\n        DBG3(P_AB, P_BC, P_CA);\n\n        { /* Whether the circle is included by the triangle */\n            bool flg = true;\n            vector<Point> poly;\n            poly.pb(A); poly.pb(B); poly.pb(C);\n            flg &= is_included(P, poly);\n            flg &= (R <= mn);\n            if(flg){\n                cout << 'a' << endl;\n                continue;\n            }\n        }\n\n        { /* Whether the triangle is included by the circle */\n            bool flg = true;\n            flg &= is_included(A, V);\n            flg &= is_included(B, V);\n            flg &= is_included(C, V);\n            if(flg){\n                cout << 'b' << endl;\n                continue;\n            }\n        }\n\n        { /* They have no intersection */\n            if(R <= mn){\n                cout << 'd' << endl;\n                continue;\n            }\n        }\n        cout << 'c' << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n#define self (*this)\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\nconst R pi = acos(-1);\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) { return imag(conj(a)*b); }\nR dot(const P& a, const P& b) { return real(conj(a)*b); }\nstruct L : public vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    L(R a, R b, R c){ // ax+by+c=0\n        if(fabs(a) < eps) self = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) self = L(P(-c/a,0),P(-c/a,1));\n        else self = L(P(-c/a,0), P(0,-c/b));\n    }\n    P vec() const { return self[1] - self[0]; }\n};\n\nstruct S : public vector<P> {\n    // A to B\n    S(const P &a = P(), const P &b = P()) { push_back(a); push_back(b); }\n    L toL() const { return L(self[0], self[1]); }\n    P vec() const { return toL().vec(); }\n    R len() const { return abs(vec()); }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p = P(), R r = 0) : p(p), r(r) { }\n};\n\n// CCW\nenum { CCW = +1, CW = -1, CAB = +2, ABC = -2, SAMEPOINT = 0 };\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return CCW; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return  CW; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return CAB; // c--a--b 直線上\n    if (norm(b) < norm(c)) return ABC; // a--b--c 直線上\n    return SAMEPOINT; // 2点以上が重なっている\n}\n\n// A->C方向の角ABCの大きさを[0,2*Pi]で求める\nR arg(P a, P b, P c) {\n    R th = arg((a - b) / (c - b));\n    return th > 0 ? th : th+2*pi;\n}\n\n// 交差判定\nbool col(const L &l, const L &m) {\n    return abs(cross(l.vec(), m.vec())) > eps || abs(cross(l.vec(), m[0]-l[0])) < eps;\n}\n\nbool col(const L &l, const S &s) {\n    return cross(l.vec(), s[0]-l[0])*cross(l.vec(), s[1]-l[0]) < eps;\n}\n\nbool col(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool col(const S &s, const S &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool col(const S &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nint col(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(r1 + r2 < d) return 0; // 離れている\n    if(abs(r1 + r2 - d) < eps) return 1; // 外接\n    if(abs(d - abs(r1 - r2)) < eps) return -1; // 内接\n    if(d < r1 - r2)            return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)            return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l.vec()) / norm(l.vec());\n    return l[0] + t*(l.vec());\n}\nL proj(const L& l, const L& m) {\n    return L(proj(l,m[0]), proj(l,m[1]));\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\nL refl(const L& l, const L& m) {\n    return L(refl(l,m[0]), refl(l,m[1]));\n}\n\n// 距離\nR dist(const P &p, const P &q){\n    return abs(p - q);\n}\n\nR dist(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dist(const L &l, const L &m) {\n    return col(l, m) ? 0 : dist(l, m[0]);\n}\n\nR dist(const L &l, const S &s) {\n    if (col(l, s)) return 0;\n    return min(dist(l, s[0]), dist(l, s[1]));\n}\n\nR dist(const S &s, const P &p) {\n    const P r = proj(s.toL(), p);\n    if (col(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dist(const S &s, const S &t) {\n    if (col(s, t)) return 0;\n    return min(min(dist(s, t[0]), dist(s, t[1])),\n               min(dist(t, s[0]), dist(t, s[1])));\n}\n\nR dist(const C &c, const P &p) {\n    return max(0. , abs(c.p - p) - c.r);\n}\n\n// positive -> outside\n// zero     -> on the boundaly\n// negative -> inside\nR dist(const C& c, const L& l){\n    R d = dist(l,c.p);\n    return max(0. , d - c.r);\n}\n\n// 交点\nvector<P> hit(const L &l, const L &m) {\n    R A = cross(l.vec(), m.vec());\n    R B = cross(l.vec(), l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) return {}; // parallel\n    return {m[0] + B / A * (m.vec())};\n}\n\nvector<P> hit(const S& s, const S& t) {\n    if(col(s,t)) return hit(s,t);\n    else return {};\n}\n\nvector<P> hit(const L& l, const S& s){\n    if(col(l,s)) return hit(l,s);\n    else return {};\n}\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183\n//        : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2045\nvector<P> hit(const C& c, const L& l){\n    R d = dist(l,c.p); // 中心と直線の距離\n    if(fabs(d-c.r) < eps) return { proj(l, c.p) }; // 触れている\n    if(d > c.r) return {}; // 離れている\n    P h = proj(l, c.p);\n    P u = sqrt(c.r*c.r - d*d) * (l.vec()) / abs(l.vec());\n    return {h+u, h-u};\n}\n\nvector<P> hit(const C& c, const S& s){\n    vector<P> cs = hit(c,s.toL()), res;\n    for(const P& p : cs) {\n        if(col(s,p)) res.push_back(p);\n    }\n    return res;\n}\n\nvector<P> hit(const C& c1, const C& c2){\n    if(abs(c1.p - c2.p) < 0) return {}; // 中心が同じ\n    int i = col(c1,c2);\n    if(i==0 || abs(i)==3) return {}; // 共通部分なし || 内部\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d }; // 接する\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = 2 * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return hit(c1, L(A,B,C)); // 2つの交点を持つ\n}\n\nvector<P> hit(const C& c, const G& g){\n    vector<P> res;\n    int n = g.size();\n    rep(i,n){\n        vector<P> ps = hit(c, S(g[i],g[(i+1)%n]));\n        rep(j,ps.size()) res.push_back(ps[j]);\n    }\n    return res;\n}\n\nbool inside(C c, G t){\n    int ccw1 = ccw(t[0], t[1], c.p);\n    int ccw2 = ccw(t[1], t[2], c.p);\n    int ccw3 = ccw(t[2], t[0], c.p);\n    if ( !(ccw1 == ccw2 && ccw2 == ccw3 ) ) return false;\n    rep(i,t.size()){\n        L l(t[i], t[(i+1)%3]);\n        if(c.r > dist(l, c.p)) return false;\n    }\n    return true;\n}\n\nbool inside(G t, C c){\n    rep(i,t.size()){\n        if(c.r < dist(t[i],c.p)) return false;\n    }\n    return true;\n}\n\nchar solve(C c, G t){\n    if(inside(c,t)) return 'a';\n    if(inside(t,c)) return 'b';\n    if(hit(c,t).size()) return 'c';\n    return 'd';\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b && a){\n        G t(3);\n        t[0] = P(a,b);\n        rep(i,2){\n            int a,b;\n            cin>>a>>b;\n            t[i+1] = P(a,b);\n        }\n        int a,b,r;\n        cin>>a>>b>>r;\n        C c(P(a,b),r);\n        cout << solve(c,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\nconst double EPS = 1e-10;\n\ndouble cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\nxy_t projection(const line &l, const xy_t &p){\n  double t = dot(l.second - l.first, p - l.first) / norm(l.second - l.first);\n  return l.first + t * (l.second - l.first);\n}\n\nbool intersectSP(const line &l, const xy_t &p){\n  if(abs(p - l.first) + abs(p - l.second) < abs(l.first - l.second) + EPS) return true;\n  else return false;\n}\n\ndouble distanceSP(const line &l, const xy_t &p){\n  xy_t r = projection(l, p);\n  if(intersectSP(l, r)) return abs(r - p);\n  else return min(abs(l.first - p), abs(l.second - p));\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n  b -= a, c -= a;\n  if(cross(b, c) > 0) return 1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n \nxy_t p[3];\nline l[3];\nxy_t c;\ndouble r;\n\n\nint main(){\n  int x, y;\n  int c1, c2;\n  while(cin >> x>> y && (x || y)){\n    p[0] = xy_t(x, y);\n    for(int i = 1; i < 3; i++) {\n      cin >> x >> y;\n      p[i] = xy_t(x, y);\n    }\n    cin >> x >> y;\n    cin >> r;\n    c = xy_t(x, y);\n    \n    rep(i, 3) l[i] = line(p[i], p[(i+1)%3]);\n    c1 = 0, c2 = 0;\n    int cnt = 0;\n\n    rep(i, 3){\n      int d = ccw(p[i], p[(i+1)%3], c);\n      if(d >= 0) c1++;\n      if(d <= 0) c2++;\n    }\n    bool circle_in[3];\n    rep(i, 3){\n      if(distanceSP(l[i], c) > r - EPS){\n\tcircle_in[i] = true;\n      }else{\n\tcircle_in[i] = false;\n\tcnt++;\n      }\n    }\n    \n    bool t_in[3];\n    rep(i, 3){\n      if(abs(c - p[i]) < r + EPS){\n\tt_in[i] = true;\n\tcnt++;\n      }else{\n\tt_in[i] = false;\n      }\n    }\n    if(circle_in[0] && circle_in[1] && circle_in[2] && max(c1, c2) == 3){\n      cout << 'a' << endl;\n    }else if(t_in[0] && t_in[1] && t_in[2]) {\n      cout << 'b' << endl;\n    }else if(cnt > 0){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n\nstruct Pos{\n\tdouble x,y;\n\tPos(double x,double y) : x(x) , y(y) {}\n\tPos(){}\n};\n\nstruct Triangle{\n\tPos pos[3];\n};\nstruct Circle{\n\tPos pos;\n\tdouble r;\n};\n\nstatic const double kyuriEPS = 1e-9;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n\tmyL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n\nbool intersectSP(const myL &s, const myPoint &p) {\n\treturn abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const myL &s, const myPoint &p) {\n\tconst myPoint r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n\tint counter = 0 , ctt = 0;\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tif( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) <= c.r ){\n\t\t\tctt++;\n\t\t}\n\t}\n\tif( ctt == 3 ) return 1;\n\tfor(int i = 0 ; i < 3 ; i++){\n\t\tdouble dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n\t\tif( dist <= c.r ){\n\t\t\tcounter++;\n\t\t}\n\t}\n\tif( counter >= 1 ) return 2;\n\t\n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs((t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x));\n\t}\n\tif( fabs( fabs(area) - tS2 ) < kyuriEPS ) return 0;  \n\telse return 3;\n}\n\nint main(){\n\tTriangle t;\n\tCircle c;\n\twhile(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n\t\tfor(int i = 1 ; i < 3 ; i++)\n\t\t\tcin >> t.pos[i].x >> t.pos[i].y;\n\t\tcin >> c.pos.x >> c.pos.y >> c.r;\n\t\tcout << (char)('a'+judgeHit(c,t)) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Triangle and Circle\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool on_edge(const Point&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Segment& s) const {return center().distance(s) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\n\nusing namespace std;\n\nstring solve(const Polygon& triangle, const Circle& circle) {\n    bool triangleInCircle = true;\n    for(const auto& p: triangle.vertex()) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    for(const auto& e: triangle.edge()) if(circle.include(e)) return \"c\";\n\n    if(triangle.include(circle.center())) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x, y, r;\n    while(cin >> x >> y, x != 0 || y != 0) {\n        Polygon triangle;\n        for(int i = 1; i < 4; ++i) {\n            triangle.add(Point(x, y));\n            cin >> x >> y;\n        }\n        cin >> r;\n        Circle circle(x, y, r);\n        cout << solve(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a+b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\trep(i,2)g[i+1]=pin();\n\t\tP p=pin();double r;cin>>r;\n\t\tC c(p,r);\n\t\tbool h=true;\n\t\tif(inconvex(g,c.c)!=2)h=false;\n\t\trep(i,3)if(distanceSP(L(g[i],g[(i+1)%3]),c.c)+EPS<c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'a'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\th=true;\n\t\trep(i,3)if(abs(g[i]-c.c)>c.r+EPS)h=false;\n\t\tif(h){\n\t\t\tcout<<'b'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,3)if(intersectCS(c,L(g[i],g[(i+1)%3])))h=true;\n\t\tif(h)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n\ndouble dot(P& a, P& b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P& a, P& b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint sign(double x){\n  if(x > EPS) return 1;\n  if(x < -EPS) return -1;\n  return 0;\n}\n\n//a -> b, a -> c\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(sign(cross(b, c)) > 0) return 1; //反時計\n  if(sign(cross(b, c)) < 0) return -1; //時計\n  if(sign(dot(b, c)) < 0) return +2; //c-a-b\n  if(norm(b) < norm(c)) return -2; //a-b-c\n  return 0; //a-c-b\n}\n\ndouble min_d(P a, P b, P c){\n  double d1 = abs(c - a);\n  double d2 = abs(c - b);\n  b -= a; c -= a;\n  double k = dot(b, c) / norm(b);\n  if(0 < k && k < 1) return abs(c - k * b);\n  else return min(d1, d2);\n}\n\nstring solve(P p[3], P c, double r){\n  if(ccw(p[0], p[1], p[2]) == -1) swap(p[1], p[2]);\n  double maxdist = 0, mindist = 1e18;\n  int ccw_v[3];\n  REP(i, 3){\n    maxdist = max(maxdist, abs(p[i] - c));\n    mindist = min(mindist, min_d(p[i], p[(i + 1) % 3], c));\n    ccw_v[i] = ccw(p[i], p[(i + 1) % 3], c);\n  }\n  if(sign(maxdist - r) <= 0) return \"b\";\n  if(ccw_v[0] == ccw_v[1] && ccw_v[1] == ccw_v[2] && ccw_v[0] == 1){\n    if(sign(mindist - r) >= 0) return \"a\";\n    else return \"c\";\n  }else{\n    if(sign(mindist - r) > 0) return \"d\";\n    else return \"c\";\n  }\n}\n\nint main(){\n  P p[3];\n  P c; double r;\n  while(cin>>p[0].X>>p[0].Y>>p[1].X>>p[1].Y>>p[2].X>>p[2].Y>>c.X>>c.Y>>r){\n    cout<<solve(p, c, r)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Triangle and Circle\n\n// 平面幾何\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 1e-10;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return fabs(source().distance(p) + target().distance(p) - target().distance(source())) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + (v1.dot(v2) / v2.norm()) * v2);\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n    Point a = triangle[0] - circle.center();\n    Point b = triangle[1] - circle.center();\n    Point c = triangle[2] - circle.center();\n//     bool inCircle = a.norm() * b.cross(c) + b.norm() * c.cross(a) + c.norm() * a.cross(b) >= 0;\n//     if(inCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.r() < circle.center().distance(e)) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    bool inTriangle = a.cross(b) >= 0 && b.cross(c) >= 0 && c.cross(a) >= 0;\n    if(inTriangle) return \"a\";\n\n//     int cw = 0, ccw = 0;\n//     for(auto& e: edge) {\n//         if(e.ccw(circle.center()) >= 0) ++ccw;\n//         if(e.ccw(circle.center()) <= 0) ++cw;\n//     }\n//     if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(!contains(c,g[i]))return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        bool f=true;\n\n        if(contains(c,g)){\n            puts(\"b\");\n            continue;\n        }\n        if(contains(g,c)){\n            puts(\"a\");\n            continue;\n        }\n\n        f=false;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(intersectCS(c,s)){\n                f=true;\n            }\n        }\n\n        if(f){\n            puts(\"c\");\n        }\n        else puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n \nusing namespace std;\n \n#define F first\n#define S second\n \n#define X real()\n#define Y imag()\n \n#define EPS (1e-7)\n \ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\ntypedef pair<double, Point> Circle;\n \nbool isPointInCircle(const Point& p, const Circle& c) {\n  if(abs(p-c.S) < abs(c.F) + EPS) return true;\n  return false;\n}\n \ndouble dot(const Point& a, const Point& b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n \ndouble cross(const Point& a, const Point& b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n \ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n \ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n \ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n   \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n \n \nenum struct ECont { OUT, ON, IN };\nECont contains(const Polygon& poly, const Point& p) {\n  bool in = 0;\n  for(int i=0; i<poly.size(); i++) {\n    Point a = poly[i] - p, b = poly[(i+1)%poly.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag()) {\n      if(cross(a, b) < 0) in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ECont::ON;\n  }\n   \n  return in ? ECont::IN : ECont::OUT;\n}\n \nint main() {\n   \n  while(1) {\n    Polygon points(3);\n    Circle circle;\n   \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n     \n      points[i] = Point(x, y);\n    }\n   \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n   \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n     \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3 && contains(points, circle.S) == ECont::IN) {cout << 'a' << endl; continue;}\n \n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) <= circle.F + EPS;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n// ½ÊãÌ_ExNg\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// OÏ\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\n// àÏ\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\n// ¼ü\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n// ½p`\ntypedef vector<P> G;\n\n// ~\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0)   return +1; // ½vñè\n\tif(cross(b, c) < 0)   return -1; // vñè\n\tif(dot(b, c) < 0)     return +2; // c--a--b\n\tif(norm(b) < norm(c)) return -2; // a--b--c\n\treturn 0;\n}\n\n// üªÆ_Ìð·»è\nbool intersectSP(const L& s, const P& p){\n\treturn abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;\n}\n\n// ¼üãÌ_ÌËe\nP projection(const L& l, const P& p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\n// üªÆ_Ì£\ndouble distanceSP(const L& s, const P& p){\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nchar detect(const G& tri, const C& c)\n{\n\tbool inner[3];\n\trep(i, 3){\n\t\tinner[i] = abs(tri[i] - c.p) - EPS <= c.r;\n\t}\n\tif(inner[0] && inner[1] && inner[2])\n\t\treturn 'b';\n\tif(inner[0] || inner[1] || inner[2])\n\t\treturn 'c';\n\t\n\trep(i, 3){\n\t\tL l(tri[i], tri[(i+1)%3]);\n\t\tif(distanceSP(l, c.p) - EPS <= c.r)\n\t\t\treturn 'c';\n\t}\n\t\n\tint v = 0;\n\trep(i, 3){\n\t\tint now = ccw(tri[i], tri[(i+1)%3], c.p);\n\t\tif(abs(now) == 2 || now * v < 0)\n\t\t\treturn 'd';\n\t\tv = now;\n\t}\n\t\n\treturn 'a';\n}\n\nint main()\n{\n\tfor(;;){\n\t\tG tri(3);\n\t\trep(i, 3){\n\t\t\tscanf(\"%lf%lf\", &tri[i].real(), &tri[i].imag());\n\t\t\tif(tri[i].real() == 0.0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(fabs(tri[0].real()) < EPS)\n\t\t\tbreak;\n\t\t\n\t\tP p;\n\t\tdouble r;\n\t\tscanf(\"%lf%lf%lf\", &p.real(), &p.imag(), &r);\n\t\tprintf(\"%c\\n\", detect(tri, C(p, r)));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-1;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) <= c.r ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n\tif( ctt >= 1 ) return 2;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r ){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs( (t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x) );\n\t}\n\t//std::cout << area << \" \" << tS2 << std::endl;\n\t\n\tif( fabs( fabs(area) - tS2 ) == 0 ) return 0; \t\n\t\n\treturn 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef long long ll;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b,r;\n\twhile(cin>>a>>b,a||b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\tcin>>a>>b;\n\t\tg[1]=P(a,b);\n\t\tcin>>a>>b;\n\t\tg[2]=P(a,b);\n\t\tg=convex_hull(g);\n\t\tcin>>a>>b>>r;\n\t\tC c(P(a,b),r);\n\t\tif(inconvex(g,c.c)\n\t\t\t&&distanceSP(L(g[0],g[1]),c.c)+EPS>c.r\n\t\t\t&&distanceSP(L(g[1],g[2]),c.c)+EPS>c.r\n\t\t\t&&distanceSP(L(g[2],g[0]),c.c)+EPS>c.r)cout<<\"a\"<<endl;\n\t\telse if(abs(g[0]-c.c)<EPS+c.r&&abs(g[1]-c.c)<EPS+c.r&&abs(g[2]-c.c)<EPS+c.r)cout<<\"b\"<<endl;\n\t\telse if(intersectCS(c,L(g[0],g[1]))||intersectCS(c,L(g[2],g[1]))||intersectCS(c,L(g[0],g[2])))cout<<\"c\"<<endl;\n\t\telse cout<<\"d\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(double& v,double& w,double& x,double& y,int& n,int bx,int by,int ex,int ey,int cx,int cy,int cr){\n  double vx,vy,px,py,ds;\n  ds=sqrt((ex-bx)*(ex-bx)+(ey-by)*(ey-by));\n  vx=(ex-bx)/ds;\n  vy=(ey-by)/ds;\n  ds=((ey-by)*cx+(bx-ex)*cy+(by-ey)*bx+(ex-bx)*by)/((ey-by)*vy-(bx-ex)*vx);\n  px=cx-vy*ds;\n  py=cy+vx*ds;\n  if(0){\n  }else if(cr>ds){\n    n=2;\n    ds=sqrt(cr*cr-ds*ds);\n    v=px+vx*ds;\n    w=py+vy*ds;\n    x=px-vx*ds;\n    y=py-vy*ds;\n  }else if(cr<ds){\n    n=0;\n  }else{\n    n=1;\n    v=px;\n    w=py;\n  }\n  return;\n}\nint g(int bx,int by,int ex,int ey,int cx,int cy,int cr){\n  int n;\n  double v,w,x,y;\n  f(v,w,x,y,n,bx,by,ex,ey,cx,cy,cr);\n  if(0){\n  }else if(n==0){\n    return 0;\n  }else if(n==1){\n    if(bx==ex)\n      return (min(by,ey)<w&&w<max(by,ey))*2;\n    else\n      return (min(bx,ex)<v&&v<max(bx,ex))*2;\n  }else{\n    if(bx==ex)\n      return min(by,ey)<min(w,y)&&max(w,y)<max(by,ey);\n    else\n      return min(bx,ex)<min(v,x)&&min(v,x)<max(bx,ex);\n  }\n}\nint range(double p,double q,double r){\n  return (q<r?q:r)<p&&p<(q<r?r:q);\n}\nint rangea(double p,double q,double r){\n  if(q*r<0&&fabs(q)+fabs(r)>M_PI){\n    p+=2*M_PI*(p<0);\n    q+=2*M_PI*(q<0);\n    r+=2*M_PI*(r<0);\n  }\n  return range(p,q,r);\n}\nint pit(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n  if(rangea(atan2(ay-py,ax-px),atan2(ay-by,ax-bx),atan2(ay-cy,ax-cx))){\n    if(rangea(atan2(by-py,bx-px),atan2(by-ay,bx-ax),atan2(by-cy,bx-cx))){\n      return 1;\n    }\n  }\n  return 0;\n}\nint main(){\n  int i;\n  int ac[3],ax[3],ay[3],cx,cy,cr;\n  while(cin>>ax[0]>>ay[0]&&ax[0]&&ay[0]){\n    for(i=1;i<3;i++)\n      cin>>ax[i]>>ay[i];\n    cin>>cx>>cy>>cr;\n    for(i=0;i<3;i++)\n      ac[i]=(ax[i]-cx)*(ax[i]-cx)+(ay[i]-cy)*(ay[i]-cy)>cr*cr;\n    if(0){\n    }else if(ac[0]&ac[1]&ac[2]){\n      for(i=0;i<3;i++)\n\tac[i]=g(ax[i],ay[i],ax[(i+1)%3],ay[(i+1)%3],cx,cy,cr);\n      if(0){\n      }else if(ac[0]==0&&ac[1]==0&&ac[2]==0){\n\tif(pit(ax[0],ay[0],ax[1],ay[1],ax[2],ay[2],cx,cy))\n\t  cout<<\"a\"<<endl;\n\telse\n\t  cout<<\"d\"<<endl;\n      }else if(ac[0]==1||ac[1]==1||ac[2]==1){\n\tcout<<\"c\"<<endl;\n      }else{\n\tif(pit(ax[0],ay[0],ax[1],ay[1],ax[2],ay[2],cx,cy))\n\t  cout<<\"a\"<<endl;\n\telse\n\t  cout<<\"c\"<<endl;\n      }\n    }else if(ac[0]|ac[1]|ac[2]){\n      cout<<\"c\"<<endl;\n    }else{\n      cout<<\"b\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n \nusing namespace std;\n \ndouble EPS = 1e-10;\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n \nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n \nstruct segment{ point a,b; };\n \nstruct circle{ point p; double r; };\n \ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n \ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n \nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n \ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n \ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n \ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n \nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n \n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n \n bool cmp_x(const point& p, const point& q){\n  if(p.x != q.x)return p.x<q.x;\n  return p.y < q.y;\n}\n\nvector<point>convex_hull(point* ps, int n){\n  sort(ps,ps+n,cmp_x);\n  int k=0;\n  vector<point>qs(n*2);\n \n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n \n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint point_contain(point* ps, point p, int n){\n  int cnt=ccw(ps[0],ps[1],p);\n  ps[n++]=ps[0]; \n\n  for(int i=0;i<n-1;i++)\n    if(cnt!=ccw(ps[i],ps[i+1],p))return 0;\n   \n  return 1;\n}\n \nint crossCP(point* ps, circle C, int sz){\n \n  double ans=0;\n \n  for(int i=0;i<sz;i++){\n    double tmp=dist(ps[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n \n  if(C.r>=ans)return 2;\n \n  vector<point>t=convex_hull(ps,sz);\n\n  int tsz=t.size();\n  int res1=point_contain(ps,C.p,tsz);\n \n  double res2=100000000;\n   t[t.size()]=t[0];\n   tsz++;\n  for(int i=0;i<tsz-1;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n \n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n \nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n  string ans=\"zabcd\";\n \n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n \n    int res=crossCP(p,C,3);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef long double Double;\ntypedef complex<Double> P;\n#define Y imag()\n#define X real()\nconst Double EPS = (long double) 1 * 1e-12;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nDouble get(P a[3]){\n\tDouble A = abs(a[0]-a[1]);\n\tDouble B = abs(a[1]-a[2]);\n\tDouble C = abs(a[2]-a[0]);\n\tDouble s = (A+B+C) / 2.0;\n\tDouble S = sqrt( s * (s-A) * (s-B) * (s-C) );\n\treturn S;\n}\nDouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \nDouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {Double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nDouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;Double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tDouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\tbool in = abs(S) < EPS;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) <= r+EPS || getPedal(L(a[1],a[2]),c) <= r+EPS || getPedal(L(a[0],a[2]),c) <= r+EPS;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) < r*r && nijo(a[1]-c) < r*r && nijo(a[2]-c) < r*r) cout << \"b\" << endl;\n\t\telse if(in && !hit) cout << \"a\" << endl;\n\t\telse if(hit) cout << \"c\" << endl;\n\t\telse cout << \"d\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define F first\n#define S second\n\n#define X real()\n#define Y imag()\n\n#define EPS (1e-7)\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\ntypedef pair<double, Point> Circle;\n\nbool isPointInCircle(const Point& p, const Circle& c) {\n  if(abs(p-c.S) < abs(c.F) + EPS) return true;\n  return false;\n}\n\ndouble dot(const Point& a, const Point& b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n\ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n  \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n\n\nenum struct ECont { OUT, ON, IN };\nECont contains(const Polygon& poly, const Point& p) {\n  bool in = 0;\n  for(int i=0; i<poly.size(); i++) {\n    Point a = poly[i] - p, b = poly[(i+1)%poly.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag()) {\n      if(cross(a, b) < 0) in = !in;\n    }\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ECont::ON;\n  }\n  \n  return in ? ECont::IN : ECont::OUT;\n}\n\nint main() {\n  \n  while(1) {\n    Polygon points(3);\n    Circle circle;\n  \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n    \n      points[i] = Point(x, y);\n    }\n  \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n  \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n    \n    int uncross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      uncross += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(uncross == 3) {\n      int flg = 0;\n      for(int i=0; i<3; i++) {\n        if(contains(points, circle.S) == ECont::IN) {\n        //if(dot(points[(i+1)%3]-points[i], circle.S-points[i]) * dot(points[(i+2)%3]-points[(i+1)%3], circle.S-points[(i+1)%3]) > 0) {\n          flg ++;\n        }\n      }\n      if(flg == 3) { cout << 'a' << endl; continue; }\n    }\n\n    int cross = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      cross += distanceSP(seg, circle.S) <= circle.F + EPS;\n    }\n    if(cross > 0) cout << 'c' << endl;\n    else cout << 'd' << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n\nconst double EPS=1e-9;\nconst double INFTY=1e12;\ntypedef complex<double> Point;\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n};\n\nint Signum(double x)\n{\n\treturn abs(x)<EPS?0:x>0?1:-1;\n}\n\ndouble Dot(Point a,Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble Cross(Point a,Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint CCW(Point a,Point b,Point c)\n{\n\tPoint d1=b-a,d2=c-a;\n\tint sign=Signum(Cross(d1,d2));\n\t\n\tif(sign)\n\t\treturn sign;\t// 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2;\t\t// c-a-b\n\tif(norm(d1)<norm(d2)-EPS)\n\t\treturn 2;\t\t// a-b-c\n\treturn 0;\t\t\t// a-c-b\n}\n\n// ツ点ツづ陳シツ静シツづ個仰猟猟」\ndouble DistancePL(Point p,Line l)\n{\n\treturn abs(Cross(p-l.pos,l.dir))/abs(l.dir);\n}\n// ツ点ツづ静シツ閉ェツづ個仰猟猟」\ndouble DistancePS(Point p,Line s)\n{\n\tPoint a=p-s.pos,b=s.dir;\n\tPoint c=b*Dot(a,b)/norm(b);\n\tdouble pos=abs(c)/abs(b);\n\tif(-EPS<pos && pos<1+EPS)\n\t\treturn abs(a-c);\n\telse\n\t\treturn min(abs(a),abs(b-a));\n}\n\nvoid solve(Point p[],Point c,int r)\n{\n\t{\t// triangle in circle\n\t\tdouble dist=0;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=max(dist,norm(p[i]-c));\n\t\tif(dist<=r*r){\n\t\t\tputs(\"b\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t{\t// circle in triangle\n\t\tbool res=true;\n\t\tint ccw=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint temp=CCW(p[i],p[(i+1)%3],c);\n\t\t\tif(abs(temp)==2)\n\t\t\t\tcontinue;\n\t\t\tres&=temp*ccw>=0;\n\t\t\tccw=temp;\n\t\t}\n\t\tif(res){\n\t\t\tdouble dist=INFTY;\n\t\t\tfor(int i=0;i<3;i++)\n\t\t\t\tdist=min(dist,DistancePL(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\t\tif(Signum(dist-r)>=0){\n\t\t\t\tputs(\"a\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t{\t// intersect\n\t\tdouble dist=INFTY;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tdist=min(dist,DistancePS(c,Line(p[i],p[(i+1)%3]-p[i])));\n\t\tif(Signum(dist-r)<=0){\n\t\t\tputs(\"c\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tputs(\"d\");\n}\n\nint main()\n{\n\tfor(;;){\n\t\tPoint p[3],c;\n\t\tdouble r;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tcin>>real(p[i])>>imag(p[i]);\n\t\tcin>>real(c)>>imag(c)>>r;\n\t\tif(norm(p[0])==0)\n\t\t\tbreak;\n\t\t\n\t\t//for(int i=0;i<3;i++)\n\t\t//\tprintf(\"(%.3f,%.3f) \",real(p[i]),imag(p[i]));\n\t\t//printf(\"(%.3f,%.3f,%.3f)\\n\",real(c),imag(c),r);\n\t\t\n\t\tsolve(p,c,r);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> Po;\n\n\nPo p[3],o;\n\ndouble cross(Po x, Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a, Po b, Po c){return abs(cross(b-a,c-a))/2;}\n\nbool inter(Po a, Po b, Po c, Po x){\n  return (abs(area(a,b,x)+area(b,c,x)+area(c,a,x)-area(a,b,c)) < EPS);\n}\n\ndouble line_dis(Po a, Po b, Po c){return abs(cross(b-a,c-a))/abs(b-a);}\n\nint main(){\n  double x[4],y[4],r;\n\n  for(;;){\n    cin >> x[0] >> y[0];\n    if(!x[0] && !y[0])break;\n\n    for(int i=1;i<4;i++)cin >> x[i] >> y[i];\n    cin >> r;\n\n    for(int i=0;i<3;i++)p[i] = Po(x[i],y[i]);\n    o = Po(x[3],y[3]);\n\n\n    bool f[3];\n    if(inter(p[0],p[1],p[2],o)){\n      for(int i=0;i<3;i++)f[i] = (line_dis(p[i],p[(i+1)%3],o)>r+EPS);\n      if(f[0] && f[1] && f[2])cout << \"a\\n\";\n      else{\n\tfor(int i=0;i<3;i++)f[i] = (abs(o-p[i])<r+EPS);\n\tif(f[0] && f[1] && f[2])cout << \"b\\n\";\n\telse cout << \"c\\n\";\n      }\n    }else{\n      for(int i=0;i<3;i++)f[i] = (line_dis(p[i],p[(i+1)%3],o)<r+EPS);\n      if(f[0] || f[1] || f[2])cout << \"c\\n\";\n      else cout << \"d\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tP dir()const {return SELF[1] - SELF[0];}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tbool online(const P &p)const {return !sig(outp(p-SELF[0], dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - SELF[0])) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tbool online(const P &p){return !sig(abs(SELF[0]-p) + abs(SELF[1] - p) - abs(SELF[0] - SELF[1]));}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-SELF[0],  dir()) < EPS) return abs(p - SELF[0]);\n\t\t\tif(inp(p-SELF[1], -dir()) < EPS) return abs(p - SELF[1]);\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tbool inside(const P& p)const { return abs(p-SELF) < r + EPS;}\n\t\tfriend inline bool cc_intersect(const C &a, const C &b){return abs(a-b)<a.r+b.r+EPS && abs(a-b)>abs(a.r - b.r)-EPS;}\n\t\tfriend inline bool cl_intersect(const C &c, const L &l){return l.distance(c) < c.r + EPS;}\n\t\tfriend inline bool cs_intersect(const C &c, const S &s){return (!c.inside(s[0]) || !c.inside(s[1])) && s.distance(c) < c.r + EPS;}\n\t};\n\t\n\tstruct G : public vector<P>{\n\t\tenum {OUT, IN, ON};\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tbool contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(L(at(i), at((i+1)%size())).online(p)) return ON;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn sig(sum) ? IN : OUT;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t};\n#undef SELF\n#undef at\n};\nusing namespace geom;\n\nint n;\n\nchar check(const C& c, const G &g){\n\tREP(i, 3) if(cs_intersect(c, g.edge(i))) return 'c';\n\tint f = 1;\n\tREP(i, 3) if(!c.inside(g[i])) f = 0;\n\tif(f) return 'b';\n\tif(g.contains((P)c)) return 'a';\n\treturn 'd';\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tG g;\n\t\tC c;\n\t\tREP(i, 3){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\tif(p.X == 0) return 0;\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcin >> c;\n\t\tcout << check(c, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS = 1e-10;\n\nPoint a, b, c, o;\ndouble r;\n\nbool equals(double a, double b){\n  return abs(a-b) < EPS;\n}\n\ndouble dot(Point a, Point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(Point a, Point b){\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\ndouble getDistance(Point a, Point b){\n  return abs(a - b);\n}\n\ndouble getDistanceLP(Point a, Point b, Point p){\n  return abs(cross(b - a, p - a) / abs(b - a));\n}\n\ndouble getDistanceSP(Point a, Point b, Point p){\n  if(dot(b - a, p - a) < 0.0) return abs(p - a);\n  if(dot(a - b, p - b) < 0.0) return abs(p - b);  \n  return getDistanceLP(a, b, p);\n}\n\nbool TinC(){\n  if(ccw(a, b, o) != 1) return false;\n  if(ccw(b, c, o) != 1) return false;\n  if(ccw(c, a, o) != 1) return false;\n  if(getDistanceSP(a, b, o) < r) return false;\n  if(getDistanceSP(b, c, o) < r) return false;\n  if(getDistanceSP(c, a, o) < r) return false;\n  return true;\n}\n\nbool CinT(){\n  if(getDistance(a, o) > r) return false;\n  if(getDistance(b, o) > r) return false;\n  if(getDistance(c, o) > r) return false;\n  return true;\n}\n\nbool CrossT(){\n  if(getDistanceSP(a, b, o) < r + EPS) return true;\n  if(getDistanceSP(b, c, o) < r + EPS) return true;\n  if(getDistanceSP(c, a, o) < r + EPS) return true;\n  return false;\n}\n\nchar solve(){\n  if(ccw(a, b, c) == -1){\n    swap(a, b);\n  }\n  if(TinC()) return 'a';\n  if(CinT()) return 'b';\n  if(CrossT()) return 'c';\n  else return 'd';\n}\n\nmain(){\n  while(cin >> a.real() >> a.imag() && (a.real() || a.imag())){\n    cin >> b.real() >> b.imag();\n    cin >> c.real() >> c.imag();\n    cin >> o.real() >> o.imag();\n    cin >> r;\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-3;\nconst double PI = acos(-1.0);\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn fabs(a - b) < EPS;\n}\n\n// 点クラス\nstruct P {\n\tdouble x, y;\n\tP(double x_, double y_) { x = x_; y = y_; }\n\tP(){}\n\t// 加算, 減算, スカラー倍\n\tP operator+(const P& a) const {\n\t\treturn P(x + a.x, y + a.y);\n\t}\n\tP operator-(const P& a) const {\n\t\treturn P(x - a.x, y - a.y);\n\t}\n\tP operator*(const P& a) const {\n\t\treturn P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP operator*(double c) const {\n\t\treturn P(x * c, y * c);\n\t}\n\tP operator/(const P& a) const {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\treturn P(x_, y_);\n\t}\n\tP operator/(double c) const {\n\t\treturn P(x / c, y / c);\n\t}\n\tP& operator+=(const P& a) {\n\t\tx += a.x; y += a.y;\n\t}\n\tP& operator-=(const P& a) {\n\t\tx -= a.x; y -= a.y;\n\t}\n\tP& operator*=(const P& a) {\n\t\t*this = P(x * a.x - y * a.y, x * a.y + y * a.y);\n\t}\n\tP& operator*=(double c) {\n\t\t*this = P(x * c, y * c);\n\t}\n\tP& operator/=(const P& a) {\n\t\tdouble norm = a.x * a.x + a.y * a.y;\n\t\tdouble x_ = (x * a.x + y * a.y) / norm;\n\t\tdouble y_ = (y * a.x - x * a.y) / norm;\n\t\t*this = P(x_, y_);\n\t}\n\tP& operator/=(double c) {\n\t\t*this = P(x / c, y / c);\n\t}\n};\nP operator*(double c, P a){\n\treturn P(a.x * c, a.y * c);\n}\n// 比較演算子\nbool operator==(const P& a, const P& b) {\n\treturn equal(a.x, b.x) && equal(a.y, b.y);\n}\nbool operator!=(const P& a, const P& b) {\n\treturn !(a == b);\n}\nbool operator<(const P& a, const P& b) {\n\treturn (a.x != b.x)? a.x < b.x : a.y < b.y;\n}\n// 原点からの距離(絶対値)\ndouble abs(P a) {\n\treturn sqrt(a.x * a.x + a.y * a.y);\n}\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n// ノルム\ndouble norm(const P& z){\n\treturn z.x * z.x + z.y * z.y;\n}\n\ndouble x[4], y[4], r;\n\ndouble D(double x1, double y1, double x2, double y2){\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\n// 直線クラス\nstruct Line : public vector<P> {\n\tLine(){}\n\tLine(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\n\n// 線分 s 上に点 p があるかどうか\nbool intersectSP(const Line& s, const P& p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\nP projection(const Line& l, const P& p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + (l[0] - l[1]) * t;\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const P& p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nstruct Triangle{\nprivate:\n\t// 余弦定理から 3 つの角の角度を求める (内部の関数で使用)\n\tdouble law_of_cos(double a, double b, double c) {\n\t\treturn acos( (b*b + c*c - a*a) / (2.0 * b * c) );\n\t}\n\t// 点 a , b を端点とする線分に点 c が含まれているかどうか\n\tbool contain(P a, P b, P c) {\n\t\treturn abs(a - c) + abs(b - c) - abs(b - a) < EPS;\n\t}\npublic:\n\t// 3 つの頂点\n\tP a, b, c;\n\t// 3 つの辺の長さ\n\tdouble edgeA, edgeB, edgeC;\n\t// 3 つの角の角度 (ラジアン)\n\tdouble angleA,angleB,angleC;\n\t// コンストラクタで初期化\n\tTriangle(P p1, P p2, P p3) {\n\t\ta = p1; b = p2; c = p3;\n\t\tedgeB = abs(c-a);\n\t\tedgeA = abs(b-c);\n\t\tedgeC = abs(a-b);\n\t\tangleA = law_of_cos( edgeA, edgeB, edgeC );\n\t\tangleB = law_of_cos( edgeB, edgeC, edgeA );\n\t\tangleC = law_of_cos( edgeC, edgeA, edgeB );\n\t}\n\t// 点 p が三角形の辺上にあるかどうか\n\tbool on_boundary(P p) {\n\t\treturn contain(a, b, p) || contain(b, c, p) || contain(c, a, p);\n\t}\n\t// 点 p が三角形の内部にあるかどうか ( AOJ 0012 で検証済み )\n\tbool is_inside(P p) {\n\t\t// 辺上にあるとき\n\t\tif( this->on_boundary(p) ) return true;\n\t\t\n\t\tTriangle t1( a , b , p );\n\t\tTriangle t2( b , c , p );\n\t\tTriangle t3( c , a , p );\n\t\t// 角APB + 角BPB + 角CPA が 360度なら 点 p は三角形の内部にある\n\t\treturn equal( t1.angleC + t2.angleC + t3.angleC , 2.0 * PI );\n\t}\n};\n\nbool in_circle(){\n\tfor(int i = 0 ; i <= 2 ; i++ ){\n\t\tint d = (x[i] - x[3]) * (x[i] - x[3]) + (y[i] - y[3]) * (y[i] - y[3]);\n\t\tif( !(d <= r * r) ) return false;\n\t}\n\treturn true;\n}\n\nbool in_triangle(){\n\tTriangle t(P(x[0], y[0]), P(x[1], y[1]), P(x[2], y[2]));\n\treturn t.is_inside(P(x[3], y[3]));\n}\n\nbool intersect(){\n\tLine s1(P(x[0], y[0]), P(x[1], y[1]));\n\tLine s2(P(x[1], y[1]), P(x[2], y[2]));\n\tLine s3(P(x[2], y[2]), P(x[0], y[0]));\n\tLine s4(P(x[1], y[1]), P(x[0], y[0]));\n\tLine s5(P(x[2], y[2]), P(x[1], y[1]));\n\tLine s6(P(x[0], y[0]), P(x[2], y[2]));\n\tP p(x[3], y[3]);\n\t\n\tif( distanceSP(s1, p) < r + EPS ) return true;\n\tif( distanceSP(s2, p) < r + EPS ) return true;\n\tif( distanceSP(s3, p) < r + EPS ) return true;\n\tif( distanceSP(s4, p) < r + EPS ) return true;\n\tif( distanceSP(s5, p) < r + EPS ) return true;\n\tif( distanceSP(s6, p) < r + EPS ) return true;\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> x[0] >> y[0], x[0] || y[0] ){\n\t\tcin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n\t\t\n\t\tif( in_circle() ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( intersect() ){\n\t\t\tcout << \"c\" << endl;\n\t\t}else if( in_triangle() ){\n\t\t\tcout << \"a\" << endl;\n\t\t}else{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\ndouble S3( double x1, double y1, double x2,double y2, double x3, double y3 ){\n \n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);\n  sum /= 2;\n \n  return sum;\n}\nbool eq(double x,double y){\n  double z=x-y;\n  if(z<0.000000001)return true;\n  else return false;\n}\nint check(Point O,Point A,Point B,Point C){\n  double a = S3(A.x , A.y , B.x , B.y , O.x , O.y);\n  double b = S3(B.x , B.y , C.x , C.y , O.x , O.y);\n  double c = S3(C.x , C.y , A.x , A.y , O.x , O.y);\n\n  double d = S3(A.x,A.y,B.x,B.y,C.x,C.y);\n\n  if(eq((a+b+c),d)){\n    return 1;\n  }else{\n    return -1;\n  }\n}\n\nint main(){\n  Point a,b,c,o;\n  double r;\n  double A,B,C;\n  while(cin>>a.x>>a.y){\n    if(a.x==0.0&&a.y==0.0)break;\n    cin>>b.x>>b.y>>c.x>>c.y>>o.x>>o.y>>r;\n\n    A=getDistance(a,o);\n    B=getDistance(b,o);\n    C=getDistance(c,o);\n    if(A<r&&B<r&&C<r){cout<<\"b\"<<endl;continue;}\n\n    A=getDistanceSP(Segment(a,b),o);\n    B=getDistanceSP(Segment(b,c),o);\n    C=getDistanceSP(Segment(c,a),o);\n\n    if(A>r&&B>r&&C>r&&check(o,a,b,c)==1){cout<<\"a\"<<endl;continue;}\n    \n    if(A>=r&&B>=r&&C>=r&&check(o,a,b,c)==-1){cout<<\"d\"<<endl;continue;}\n    cout<<\"c\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-6\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    if (norm(a) < r2) {\n      c[i] = -1;\n    } else if (norm(a) > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0. && c[1]>=0. && c[2]>=0.) {\n    return 1;\n  } else if (c[0]<=0. && c[1]<=0. && c[2]<=0.) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double na, nb, dab, d, sd, s, t;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    na = norm(a);\n    nb = norm(b);\n    dab = dot(a,b);\n    d = dab*dab - na*(nb-r*r);\n    if (d <=EPS) {\n      if (fabs(d) < EPS) {\n        contact = true;\n      }\n      continue;\n    }\n    sd = sqrt(d);\n    s = (dab+sd)/na;\n    t = (dab-sd)/na;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      return 1;\n    }\n    if ((fabs(s)<EPS && fabs(s-1.)<EPS) || (fabs(t)<EPS && fabs(t-1.)<EPS)) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define EPS (1e-10)\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(0,0),double r=0):p(p),r(r){}\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistancePP(Point p1,Point p2)\n{\n  return sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));\n}\n\nbool isTriangleInCircle(vector<Point> &p,Circle c)\n{\n  double d1,d2,d3;\n  d1 = getDistancePP(p[0],c.p);\n  d2 = getDistancePP(p[1],c.p);\n  d3 = getDistancePP(p[2],c.p);\n  return d1 <= c.r && d2 <= c.r && d3 <= c.r;\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nbool isPointInTriangle(vector<Point> &p,Point c)\n{\n  int res1 = ccw(p[0],p[1],c);\n  int res2 = ccw(p[1],p[2],c);\n  int res3 = ccw(p[2],p[0],c);\n  return (res1 == CLOCKWISE && res2 == CLOCKWISE && res3 == CLOCKWISE) || (res1 == COUNTER_CLOCKWISE && res2 == COUNTER_CLOCKWISE && res3 == COUNTER_CLOCKWISE);\n}\n\nbool isCircleInTriangle(vector<Point> &p,Circle c)\n{\n  double dist[3];\n  dist[0] = getDistanceSP(Segment(p[0],p[1]),c.p);\n  dist[1] = getDistanceSP(Segment(p[1],p[2]),c.p);\n  dist[2] = getDistanceSP(Segment(p[2],p[0]),c.p);  \n  return isPointInTriangle(p,c.p) && dist[0] >= c.r && dist[1] >= c.r && dist[2] >= c.r;\n}\n\n\n\n\nint main()\n{\n  vector<Point> T(3);\n  while(cin >> T[0].x >> T[0].y,(int)T[0].x|(int)T[0].y)\n    {\n      for(int i=1;i<=2;i++)\n\tcin >> T[i].x >> T[i].y;     \n      Circle c;\n      cin >> c.p.x >> c.p.y;\n      cin >> c.r;\n\n      double dist[3];\n      dist[0] = getDistanceSP(Segment(T[0],T[1]),c.p);\n      dist[1] = getDistanceSP(Segment(T[1],T[2]),c.p);\n      dist[2] = getDistanceSP(Segment(T[2],T[0]),c.p);  \n\ncout << 'a' << endl;\ncontinue;\n      if(isTriangleInCircle(T,c))\n\tcout << 'b' << endl;\n      else if(isCircleInTriangle(T,c))\n\tcout << 'a' << endl;\n      else if(dist[0] <= c.r || dist[1] <= c.r || dist[2] <= c.r)\n\tcout << 'c' << endl;\n      else \n\tcout << 'd' << endl;      \n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconst double eps = 1e-7;\nnamespace boost {\ntemplate <class T>\nstruct integer_iterator {\n    T a;\n    bool operator != (integer_iterator const & it) const { return a != it.a; }\n    T operator * () const { return a; }\n    integer_iterator & operator ++ () { ++ a; return *this; }\n    integer_iterator operator ++ (int) { return { a ++ }; }\n};\ntemplate <class T>\nstruct integer_range {\n    T l, r;\n    typedef integer_iterator<T> iterator;\n    iterator begin() const { return { l }; }\n    iterator end  () const { return { r }; }\n};\ntemplate <class T>\ninteger_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }\ntemplate <class T>\nstruct integer_iterator_with_step {\n    T a, d, i;\n    bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }\n    T operator * () const { return a+d*i; }\n    integer_iterator_with_step & operator ++ () { ++ i; return *this; }\n    integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }\n};\ntemplate <class T>\nstruct strided_integer_range {\n    T l, r, s;\n    typedef integer_iterator_with_step<T> iterator;\n    iterator begin() const { return { l, s, 0 }; }\n    iterator end  () const { return { l, s, (r - l) / s }; }\n};\ntemplate <class T>\nstrided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }\n}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };\nttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }\nttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }\nttt point<T> operator - (pca a) { return { -a.x, -a.y }; }\nttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }\nttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }\nttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }\nttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }\nttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }\nttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }\nttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }\nttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }\nttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }\nttt double length(pca p) { return sqrt(length_squared(p)); }\nttt point<T> normalized(pca a) { return (1 / length(a)) * a; }\nttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }\nttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }\nttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }\ntemplate <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> bool operator == (circle<T> const & a, circle<T> const & b) { return a.p == b.p and a.r == b.r; }\ntemplate <typename T> bool operator != (circle<T> const & a, circle<T> const & b) { return not (a == b); }\ntemplate <typename T> struct line { point<T> a, b; };\ntemplate <typename T> struct ray { point<T> a, b; };\ntemplate <typename T> struct segment { point<T> a, b; };\ntemplate <typename T> T length_squared(segment<T> const & p) { return length_squared(p.a - p.b); }\ntemplate <typename T> double length(segment<T> const & p) { return length(p.a - p.b); }\ntemplate <typename T>    line<T> to_line(    ray<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>    line<T> to_line(segment<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(   line<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(segment<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment(line<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment( ray<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T>\nstruct arc { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT length(arc<T> const & a) { return a.r * (a.b - a.a); }\ntemplate <typename T>\nbool valid(arc<T> const & a) {\n    assert (0 <= a.r);\n    return\n        - M_PI < a.a + eps and a.a < M_PI + eps and\n        - M_PI < a.b + eps and a.b < M_PI + eps;\n}\ntemplate <typename T>\ncircle<T> to_circle(arc<T> const & a) { return { a.p, a.r }; }\n\ntemplate <typename T>\nstruct circular_sector { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT sq(T x) { return x * x; }\ntemplate <typename T>\npoint<T> rotate_90(point<T> const & a) {\n    return { - a.y, a.x };\n}\ntemplate <typename T>\npoint<T> rotate_270(point<T> const & a) {\n    return { a.y, - a.x };\n}\ntemplate <typename T>\npoint<T> rotate_180(point<T> const & a) {\n    return { - a.x, - a.y };\n}\npoint<double> rotate(point<double> const & a, double th) {\n    return {\n        a.x * cos(th) - a.y * sin(th),\n        a.x * sin(th) + a.y * cos(th) };\n}\ntemplate <>\nint ccw(point<double> const & a, point<double> const & b, point<double> const & c) {\n    double x = cross(b - a, c - a);\n    return x > eps ? 1 : x < - eps ? -1 : 0;\n}\n\ndouble distance(point<double> const & a, point<double> const & b) {\n    return length(b - a);\n}\n\ndouble distance(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return std::abs( cross(p, e) );\n}\ndouble distance(point<double> const & a, line<double> const & b) {\n    return distance(b,a);\n}\n\nbool does_include(circle<double> const & a, point<double> const & b) {\n    return length(a.p - b) < a.r + eps;\n}\nbool is_on_circumference(point<double> const & a, circle<double> const & b) {\n    return std::abs(length(b.p - a) - b.r) < eps;\n}\n// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < std::abs(a.r - b.r) + eps;\n}\n// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < a.r + b.r + eps;\n}\n// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;\n}\n// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {\n    std::vector<point<double> > result;\n    if (distance(a.p, b.p) < eps) {\n        // nop\n    } else if (not does_intersect(a,b)) {\n        // nop\n    } else if (does_include(a,b) and not does_inscribe(a,b)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(a,b) or does_circumscribe(a,b)) {\n        circle<double> x = a;\n        circle<double> y = b;\n        if (not (x.r < y.r)) std::swap(x, y);\n        result.push_back(y.r * normalized(x.p - y.p) + y.p);\n    } else {\n        //       c\n        //      /|\\\n        // a.r / | \\ b.r\n        //    /th|  \\\n        //   a-------b\n        //       l\n        double l = length(b.p - a.p);\n        double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\n        double as = sqrt( sq(a.r) - sq(ac) );\n        point<double> e = normalized(b.p - a.p);\n        result.push_back(a.p + ac*e + as*rotate_90(e));\n        result.push_back(a.p + ac*e + as*rotate_270(e));\n    }\n    for (auto p : result) {\n        assert (does_include(a, p));\n        assert (does_include(b, p));\n    }\n    return result;\n}\n\nstd::vector<line<double> > tangents(circle<double> const & a, point<double> const & b) {\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not is_on_circumference(b,a)) {\n        // truly included\n        // nop\n    } else if (is_on_circumference(b,a)) {\n        point<double> e = normalized(a.p - b);\n        result.push_back({\n                b + rotate_90(e),\n                b + rotate_270(e) });\n    } else {\n        double theta = asin(a.r / length(b - a.p));\n        result.push_back({ b, b + rotate(a.p - b, + theta) });\n        result.push_back({ b, b + rotate(a.p - b, - theta) });\n    }\n    return result;\n}\n\nstd::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {\n    point<double> p = a.p + (a.r / (a.r + b.r)) * (b.p - a.p);\n    return tangents(a,p);\n}\nstd::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {\n    if (b.r < a.r) std::swap(a,b);\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not does_inscribe(b,a)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(b,a)) {\n        point<double> e = normalized(a.p - b.p);\n        result.push_back({\n                b.p + a.r*e + rotate_90(e),\n                b.p + a.r*e + rotate_270(e) });\n    } else {\n        point<double> d = b.p - a.p;\n        double theta = asin((b.r - a.r) / length(d));\n        point<double> dp = rotate(d, + theta);\n        point<double> dm = rotate(d, - theta);\n        point<double> ep = rotate_90(normalized(dp));\n        point<double> em = rotate_270(normalized(dm));\n        result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });\n        result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });\n    }\n    return result;\n}\nstd::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {\n    std::vector<line<double> > result;\n    for (auto l : common_inner_tangents(a,b)) result.push_back(l);\n    for (auto l : common_outer_tangents(a,b)) result.push_back(l);\n    return result;\n}\n\npoint<double> nearest_point(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return a.a + dot(p, e) * e;\n}\nbool is_tangent(line<double> const & a, circle<double> const & b) {\n    return std::abs( b.r - distance(a, b.p) ) < eps;\n}\nbool does_include(segment<double> const & a, point<double> const & b) {\n    point<double> p = b - a.a;\n    point<double> e = normalized(a.b - a.a);\n    return std::abs( cross(e, p) ) < eps and - eps < dot(e, p) and dot(e, p) < length(a) + eps;\n}\nbool is_tangent(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return is_tangent(l, b) and does_include(a, nearest_point(l, b.p));\n}\nbool does_intersect(line<double> const & a, circle<double> const & b) {\n    return distance(a, b.p) < b.r + eps;\n}\nbool does_intersect(circle<double> const & a, line<double> const & b) {\n    return does_intersect(b, a);\n}\nbool does_intersect(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return does_intersect(l, b) and\n        (does_include(a, nearest_point(l, b.p)) or\n         distance(a.a, b.p) < b.r + eps or\n         distance(a.b, b.p) < b.r + eps);\n}\n\nbool does_intersect(line<double> const & a, line<double> const & b) {\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return eps < std::abs( cross(p, q) );\n}\nbool is_parallel(line<double> const & a, line<double> const & b) {\n    return not does_intersect(a, b);\n}\nbool does_intersect(segment<double> const & a, segment<double> const & b) {\n    return\n        ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) == -1 and\n        ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) == -1;\n}\npoint<double> intersection_point(line<double> const & a, line<double> const & b) {\n    assert (does_intersect(a, b));\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return a.a + ( cross(q, b.a - a.a) / cross(q, p) ) * p;\n}\n\nbool does_include(ray<double> const & a, point<double> const & b) {\n    return ccw(a.a, a.b, b) == 0 and dot(a.b - a.a, b - a.a) > - eps;\n}\nbool does_intersect(ray<double> const & a, segment<double> const & b) {\n    if (does_include(a, b.a) or does_include(a, b.b)) return true;\n    line<double> la = to_line(a);\n    line<double> lb = to_line(b);\n    if (is_parallel(la, lb)) return false;\n    point<double> p = intersection_point(la, lb);\n    return does_include(a,p) and does_include(b,p);\n}\nbool does_intersect(segment<double> const & a, ray<double> const & b) {\n    return does_intersect(b, a);\n}\n\npoint<double> projection(point<double> const & a, line<double> const & b) {\n    point<double> e = normalized(b.b - b.a);\n    return dot(e, a - b.a) * e + b.a;\n}\ndouble distance(segment<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_line(a));\n    if (does_include(a, p)) {\n        return distance(to_line(a), b);\n    } else{\n        return std::min(distance(a.a, b), distance(a.b, b));\n    }\n}\ndouble distance(point<double> const & a, segment<double> const & b) {\n    return distance(b, a);\n}\ndouble distance(segment<double> const & a, segment<double> const & b) {\n    return std::min(std::min(std::min(\n            distance(a.a, b),\n            distance(a.b, b)),\n            distance(a, b.a)),\n            distance(a, b.b));\n}\n\npoint<double> projection(point<double> const & a, circle<double> const & b) {\n    return b.r * normalized(a - b.p) + b.p;\n}\nbool does_include(arc<double> const & a, point<double> const & b) {\n    assert (valid(a));\n    point<double> e = b - a.p;\n    double r = length(e);\n    double th = atan2(e.y, e.x);\n    return std::abs(a.r - r) < eps and  a.a < th + eps and th < a.b + eps;\n}\ndouble distance(arc<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_circle(a));\n    if (does_include(a, p)) {\n        return distance(p, b);\n    } else{\n        point<double> l = a.r * (point<double>) { cos(a.a), sin(a.a) } + a.p;\n        point<double> r = a.r * (point<double>) { cos(a.b), sin(a.b) } + a.p;\n        return std::min(distance(l, b), distance(r, b));\n    }\n}\ndouble distance(point<double> const & a, arc<double> const & b) {\n    return distance(b, a);\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    if (not does_intersect(a, b)) {\n        // nop\n    } else if (is_tangent(b, a)) {\n        result.push_back(nearest_point(b, a.p));\n    } else {\n        point<double> e = normalized(b.b - b.a);\n        point<double> p = nearest_point(b, a.p);\n        double h = distance(p, a.p);\n        double w = sqrt( sq(a.r) - sq(h) );\n        result.push_back(  w * e + p);\n        result.push_back(- w * e + p);\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, circle<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), b)) {\n        if (does_include(a, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, segment<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), to_line(b))) {\n        if (does_include(a, p) and does_include(b, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(segment<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nbool does_intersect(arc<double> const & a, segment<double> const & b) {\n    return not intersection_points(a, b).empty();\n}\nbool does_intersect(segment<double> const & a, arc<double> const & b) {\n    return does_intersect(b, a);\n}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\nint main() {\n    while (true) {\n        point<ll> p[3];\n        cin >> p[0];\n        if (p[0].x == 0 and p[0].y == 0) break;\n        cin >> p[1] >> p[2];\n        circle<ll> c;\n        cin >> c.p >> c.r;\n        if (\n                length_squared(c.p - p[0]) <= sq(c.r) and\n                length_squared(c.p - p[1]) <= sq(c.r) and\n                length_squared(c.p - p[2]) <= sq(c.r)) {\n            cout << 'b' << endl;\n        } else if (\n                ccw(p[0], p[1], c.p) == 0 or\n                ccw(p[1], p[2], c.p) == 0 or\n                ccw(p[2], p[0], c.p) == 0) {\n            cout << 'c' << endl;\n        } else {\n            ll x = sq(cross(p[1] - p[0], c.p - p[0])) - sq(c.r) * length_squared(p[1] - p[0]);\n            ll y = sq(cross(p[2] - p[1], c.p - p[1])) - sq(c.r) * length_squared(p[2] - p[1]);\n            ll z = sq(cross(p[0] - p[2], c.p - p[2])) - sq(c.r) * length_squared(p[0] - p[2]);\n            if (abs(\n                    ccw(p[0], p[1], c.p) +\n                    ccw(p[1], p[2], c.p) +\n                    ccw(p[2], p[0], c.p)) == 3) {\n                if (x <= 0 or y <= 0 or z <= 0) {\n                    cout << 'c' << endl;\n                } else {\n                    cout << 'a' << endl;\n                }\n            } else {\n                if (x <= 0 or y <= 0 or z <= 0) {\n                    cout << 'c' << endl;\n                } else {\n                    cout << 'd' << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\ntypedef complex<double> P;\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nint chk(P a,P b,double r){\n\tdouble t = abs(a-b) - r;\n\tif( fabs(t) < EPS ) return 0;\n\treturn t < 0 ? -1 : 1;\n}\ndouble cross(P a,P b){\n\treturn imag(a*conj(b));\n}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\n\n\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\nint main(){\n\tP a,b,c,d;\n\tdouble r;\n\twhile(cin >> a.real() >> a.imag() , a.real() != 0 || a.imag() != 0 ){\n\t\tcin >> b.real() >> b.imag();\n\t\tcin >> c.real() >> c.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tcin >> r;\n\t\t\n\t\tint in = 0;\n\t\tint mk = cross(a-d,b-d) <= 0 ;\n\t\tif( mk == (cross(b-d,c-d) <= 0) && mk == (cross(c-d,a-d) <= 0)){\n\t\t\tin = 1;\n\t\t}\n\t\t\n\t\tif( chk(a,d,r) <= 0 &&  chk(b,d,r) <= 0 &&  chk(c,d,r) <= 0 ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( chk(a,d,r) >= 0 &&  chk(b,d,r) >= 0 &&  chk(c,d,r) >= 0){\n\t\t\tif( distanceSP(L(a,b),d) < r - EPS || distanceSP(L(b,c),d) < r - EPS || distanceSP(L(a,c),d) < r - EPS  ){\n\t\t\t\tcout << \"c\" << endl;\n\t\t\t}else if( in ){\n\t\t\t\tcout << \"a\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"d\" << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n//      getline(ifs, str);\n        cin >> str;\n\n      if(str == \"0 0\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\") break;\n\n\n    if(distance(&d->p[0], &c->p) <= c->radius&& distance(&d->p[1], &c->p) <= c->radius&& distance(&d->p[2], &c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) >= c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) >= c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) >= c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) <= distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) <= distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) <= distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else\n            cout << 'a' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) <= c->radius|| dist_line(&d->p[0], &d->p[2], &c->p) <= c->radius|| dist_line(&d->p[1], &d->p[2], &c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1 + (a2 - a1) * (cross(b2 - b1,b1 - a1) / cross(b2 - b1,a2 - a1));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    point r=intersection_l(a1,a2,b1,b2);\n    return is_point_on_line(a1,a2,r) && is_point_on_line(b1,b2,r);\n  }\n\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\n  point a,b;\n  a=b=p;\n  b.x=100000;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n  \n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n    \n  return (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\n  double ans=0;\n  int tsz=t.size();\n\n  for(int i=0;i<tsz;i++){\n    double tmp=dist(t[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,t,tsz);\n  double res2=DBL_MAX;\n\n  t.push_back(t[0]);\n\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p;\n  vector<point> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    t.clear();\n    for(int i=0;i<3;i++){\n      cin >> p.x >> p.y;\n      if(p.x==0 && p.y==0)return 0;\n      t.push_back(p);\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(t,C);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r&&!EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r&&!EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r&&!EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 0;//1e-8;\n\nstruct C {\n  P p;\n  double r;\n  C() : p(P(0,0)), r(0) {}\n  C(P p, double r) : p(p), r(r) {}\n};\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return abs(cross(s2-s1,p-s1))/abs(s2-s1);\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2-s1, p-s1) < 0.0) return abs(p-s1);\n  if(dot(s1-s2, p-s2) < 0.0) return abs(p-s2);\n  return getDistanceLP(s1, s2, p);\n}\n\nbool involve(const C &c, const P &s1, const P &s2) {\n  double dist = max(abs(c.p - s1), abs(c.p - s2));\n  return c.r - dist > -eps;\n}\n\nbool involve(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    double dist = getDistanceLP(a,b,c.p);\n    if(cross(b-a, c.p-a) > eps && dist - c.r > -eps) {\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool involve(const C &c, const vector<P> &g) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(!involve(c, a, b)) return false;\n  }\n  return true;\n}\n\nbool isIntersect(const P &s1, const P &s2, const C &c) {\n  if(involve(c, s1, s2)) return false;\n  double dist = getDistanceSP(s1, s2, c.p);\n  return c.r - dist > eps;\n}\n\nbool isIntersect(const vector<P> &g, const C &c) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    P a = g[i], b = g[(i+1)%n];\n    if(isIntersect(a,b,c)) return true;\n  }\n  return false;\n}\n\nint main() {\n  vector<P> g(3);\n  C c;\n  while(1) {\n    for(int i = 0; i < g.size(); ++i) {\n      cin >> g[i].real() >> g[i].imag();\n      if(g[0].real() == 0 && g[0].imag() == 0) return 0;\n    }\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n    if(involve(g,c)) cout << \"a\" << endl;\n    else if(involve(c,g)) cout << \"b\" << endl;\n    else if(isIntersect(g,c)) cout << \"c\" << endl;\n    else cout << \"d\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(!contains(c,g[0]))return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        bool f=true;\n        for(int i=0;i<g.size();i++){\n            if(!contains(c,g[i]))f=false;\n        }\n        if(f){\n            puts(\"b\");\n            continue;\n        }\n        \n        f=true;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(distanceCS(c,s)<-EPS)f=false;\n        }\n        if(f&&contains(g,c.p)){\n            puts(\"a\");\n            continue;\n        }\n\n        f=false;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(intersectCS(c,s)){\n                f=true;\n            }\n        }\n\n        if(f){\n            puts(\"c\");\n        }\n        else puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r)\n\t\tif(abx*acx+aby*acy<0)\n\t\t\tif(acx*acx+acy*acy<=r*r)return true;\n\t\telse if(abx*acx+aby*acy>abx*abx+aby*aby)\n\t\t\tif(bcx*bcx+bcy*bcy<=r*r)return true;\n\t\telse if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<0)ok1=false;\n\telse ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<0)ok1=false;\n\telse ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<0)ok1=false;\n\telse ok2=false;\n\treturn ok1||ok2;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<r*r&&(c-g)*(c-g)+(d-h)*(d-h)<r*r&&(e-g)*(e-g)+(f-h)*(f-h)<r*r)printf(\"b\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse if(inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\ndouble sign(double r) { return r < -EPS ? -1.0 : r > EPS ? 1.0 : 0.0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0.0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) >= 0.0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n\n// code for problem\nint x, y, r;\nvector<P> T;\nC cc;\n\nbool isPinC() {\n\tP e0 = T[0] - cc.p;\n\tP e1 = T[1] - cc.p;\n\tP e2 = T[2] - cc.p;\n\tdouble d0 = e0.det(e1);\n\tdouble d1 = e1.det(e2);\n\tdouble d2 = e2.det(e0);\n\tif(sign(d0 * d1) >= 0.0 && sign(d1 * d2) >= 0.0 && sign(d2 * d0) >= 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\tvector<double> d(3);\n\td[0] = (T[0] - cc.p).norm();\n\td[1] = (T[1] - cc.p).norm();\n\td[2] = (T[2] - cc.p).norm();\n\tif(sign(d[0] - cc.r) <= 0.0 && sign(d[1] - cc.r) <= 0.0 && sign(d[2] - cc.r) <= 0.0) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\tbool in = isPinC();\n\tL l0(T[0], T[1]);\n\tL l1(T[1], T[2]);\n\tL l2(T[2], T[0]);\n\td[0] = l0.dSP(cc.p);\n\td[1] = l1.dSP(cc.p);\n\td[2] = l2.dSP(cc.p);\n\tif(in && sign(d[0] - cc.r) >= 0.0 && sign(d[1] - cc.r) >= 0.0 && sign(d[2] - cc.r) >= 0.0) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(!in && sign(d[0] - cc.r) > 0.0) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\tT = vector<P>(3);\n\tfor(;;) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\tT[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}\n        "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point& a, const Point& b) { return Point{ a.px - b.px,a.py - b.py }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dst(const Point& a, const Point& b) { return abs(Minus(b , a)); }\nlong double dst(const Line& a, const Point& b) {\n\treturn dot(Minus(a.p2, a.p1), Minus(b, a.p1)) < 0.0 ? abs(Minus(b, a.p1)) : (dot(Minus(a.p1, a.p2), Minus(b, a.p2)) < 0.0 ? abs(Minus(b, a.p2)) : abs(crs(Minus(a.p2, a.p1), Minus(b, a.p1)) / abs(Minus(a.p2, a.p1))));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\twhile (true) {\n\t\tPoint r1, r2, r3, r4; long double r;\n\t\tcin >> r1.px >> r1.py; if (fabs(r1.px) <= 1e-10 && fabs(r1.py) <= 1e-10)break;\n\t\tcin >> r2.px >> r2.py >> r3.px >> r3.py >> r4.px >> r4.py >> r;\n\t\tLine l1 = Line{ r1,r2 }, l2 = { r2,r3 }, l3 = { r3,r1 };\n\t\tlong double c1 = min(dst(l1, r4), min(dst(l2, r4), dst(l3, r4)));\n\t\tlong double c2 = max(dst(r1, r4), max(dst(r2, r4), dst(r3, r4)));\n\t\tlong double c3 = min(dst(r1, r4), min(dst(r2, r4), dst(r3, r4)));\n\t\t//cout << dst(l1, r4) << ' ' << dst(l2, r4) << ' ' << dst(l3, r4) << endl;\n\t\tint c4 = contain({ r1,r2,r3 }, r4);\n\t\tif (c1 >= r && c4 != 0) { cout << \"a\" << endl; }\n\t\telse if (c2 <= r) { cout << \"b\" << endl; }\n\t\telse if (c3 <= r) { cout << \"c\" << endl; }\n\t\telse { cout << \"d\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool is_inner(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  return (dot(b,c) <= 0);\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool is_projection_on_line(const Line &l, const Point &p) {\n  Point pj = projection(l,p);\n  return is_inner(pj,l[0],l[1]);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point> ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool is_convex_hull(vector<Point>& ps,const Point& c){\n  for(int i=0;i<ps.size();i++){\n    if(is_equal(ps[i],c)) return true;\n  }\n  return false;\n}\n\nint main(){\n  double x[4];\n  double y[4];\n  while(~scanf(\"%lf %lf\",&x[0],&y[0])){\n    if(is_equal(Point(x[0],y[0]),Point(0.0,0.0))) break;\n\n    for(int i=1;i<4;i++){\n      scanf(\"%lf %lf\",&x[i],&y[i]);\n    }\n    double r;\n    scanf(\"%lf\",&r);\n\n    vector<Line> lines;\n    vector<Point> points;\n\n    for(int i=0;i<4;i++){\n      points.push_back(Point(x[i],y[i]));\n    }\n\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        lines.push_back(Line(Point(x[i],y[i]),Point(x[j],y[j])));\n      }\n    }\n\n    vector<Point> convex_hull = compute_convex_hull(points);\n\n    if(!is_convex_hull(convex_hull,points[3])){\n      double dist2line = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist2line = min(distanceLP(lines[i],Point(x[3],y[3])),dist2line);\n      }\n      \n      if(r <= dist2line + EPS){\n        //a\n        printf(\"a\\n\");\n      }\n      else{\n        double dist2point = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist2point = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist2point);\n        }\n        if(r >= dist2point - EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n      }\n    }\n    else {\n      double dist2LP = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        if(is_projection_on_line(lines[i],Point(x[3],y[3]))){\n          dist2LP = min(distanceLP(lines[i],Point(x[3],y[3])),dist2LP);\n        }\n      }\n      for(int i=0;i<3;i++){\n        dist2LP = min(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist2LP);\n      }\n      \n      if(dist2LP > r){\n        //d\n        printf(\"d\\n\");\n      }\n      else{\n        double dist2point = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist2point = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist2point);\n        }\n        \n        if(r >= dist2point - EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])==OUT)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        bool f=true;\n        for(int i=0;i<g.size();i++){\n            if(!contains(c,g[i]))f=false;\n        }\n        if(f){\n            puts(\"b\");\n            continue;\n        }\n\n        f=true;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(distanceCS(c,s)<-EPS)f=false;\n        }\n        if(f&&contains(g,c.p)){\n            puts(\"a\");\n            continue;\n        }\n\n        f=false;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(intersectCS(c,s)){\n                f=true;\n            }\n        }\n\n        if(f){\n            puts(\"c\");\n        }\n        else puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n            ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\n  point a,b;\n  a=b=p;\n  b.x=DBL_MAX;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n  \n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n    \n  return (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\n  double ans=0;\n  int tsz=t.size();\n\n  for(int i=0;i<tsz;i++){\n    double tmp=dist(t[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,t,tsz);\n  double res2=DBL_MAX;\n\n  t.push_back(t[0]);\n\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p;\n  vector<point> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    t.clear();\n    for(int i=0;i<3;i++){\n      cin >> p.x >> p.y;\n      if(p.x==0 && p.y==0)return 0;\n      t.push_back(p);\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(t,C);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0&&acx*acx+acy*acy<=r*r)return true;\n\t\telse if(abx*acx+aby*acy>abx*abx+aby*aby&&bcx*bcx+bcy*bcy<=r*r)return true;\n\t\telse if(acx*acx+acy*acy-(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t}\n\treturn false;\n}\nbool intersect(int ax,int ay,int bx,int by,int cx,int cy,int dx,int dy){\n\tlong long ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n\tlong long tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n\tlong long tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n\tlong long td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n\tif(ta*tb<=0LL&&tc*td<=0LL)return true;\n\telse return false;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<r*r&&(c-g)*(c-g)+(d-h)*(d-h)<r*r&&(e-g)*(e-g)+(f-h)*(f-h)<r*r)printf(\"b\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse if(intersect(g,h,a,b,c,d,e,f)||intersect(g,h,c,d,a,b,e,f)||intersect(g,h,e,f,a,b,c,d))printf(\"d\\n\");\n\t\telse printf(\"a\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1e-10;\n\npair<int, int> a;\npair<int, int> b;\npair<int, int> c;\npair<int, int> o;\nint r;\n\nint dot(pair<int, int> p1, pair<int, int> p2){\n  return p1.first * p2.first + p1.second * p2.second;\n}\n\nint cross(pair<int, int> p1, pair<int, int> p2){\n  return p1.first * p2.second - p1.second * p2.first;\n}\n\ndouble length(pair<int, int> p){\n  return sqrt(p.first * p.first + p.second * p.second);\n}\n\nbool is_inside(){\n  if(cross(make_pair(b.first-a.first, b.second-a.second), \n\t   make_pair(o.first-a.first, o.second-a.second)) < 0) return false;\n  if(cross(make_pair(c.first-b.first, c.second-b.second), \n\t   make_pair(o.first-b.first, o.second-b.second)) < 0) return false;\n  if(cross(make_pair(a.first-c.first, a.second-c.second), \n\t   make_pair(o.first-c.first, o.second-c.second)) < 0) return false;\n  return true;\n}\n\ndouble dist(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3){\n  pair<int, int> p4 = make_pair(p2.first - p1.first, p2.second - p1.second);\n  pair<int, int> p5 = make_pair(p3.first - p1.first, p3.second - p1.second);\n  double tmp = length(p4);\n  return abs((double)cross(p4, p5) / tmp);\n}\n\ndouble dist2(pair<int, int> p1, pair<int, int> p2, pair<int, int> p3){\n  pair<int, int> p7 = make_pair(p2.first - p1.first, p2.second - p1.second);\n  pair<int, int> p4 = make_pair(p1.first - p2.first, p1.second - p2.second);\n  pair<int, int> p5 = make_pair(p3.first - p2.first, p3.second - p2.second);\n  pair<int, int> p6 = make_pair(p3.first - p1.first, p3.second - p1.second);\n  if(dot(p7, p6) < 0) return length(p6)*length(p6);\n  if(dot(p4, p5) < 0) return length(p5)*length(p5);\n  return dist(p1, p2, p3);\n}\n\nmain(){\n  while(cin >> a.first >> a.second && a.first && a.second){\n    cin >> b.first >> b.second;\n    cin >> c.first >> c.second;\n    cin >> o.first >> o.second;\n    cin >> r;\n    if(length(make_pair(a.first-o.first, a.second-o.second)) < (double)r+EPS && \n       length(make_pair(b.first-o.first, b.second-o.second)) < (double)r+EPS &&\n       length(make_pair(c.first-o.first, c.second-o.second)) < (double)r+EPS){\n      cout << \"b\" << endl;\n      continue;\n    }\n    else if(is_inside()){\n      if(dist(b, c, o) > (double)r-EPS && \n\t dist(a, c, o) > (double)r-EPS && \n\t dist(a, b, o) > (double)r-EPS){\n\tcout << \"a\" << endl;\n\tcontinue;\n      }\n    }\n    if(dist2(b, c, o) < (double)r+EPS ||\n       dist2(a, c, o) < (double)r+EPS ||\n       dist2(a, b, o) < (double)r+EPS){\n      cout << \"c\" << endl;\n      continue;\n    }\n    cout << \"d\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n      if(i!=j && seg[i].b.x==seg[j].a.x && seg[i].b.y==seg[j].a.y){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r-EPS)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    double ans=0;\n    for(int i=0;i<3;i++){\n\tint tmp=dist(p[i],C.p);\n\tif(tmp>ans){\n\t  ans=tmp;\n\t}\n    }\n    if(C.r>ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n    \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=100000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define EPS (1e-8)\n\ntypedef complex<double> P;\ntypedef P Vec;\n\nstruct Line {\n\tP p;\n\tVec v;\n\t\n\tLine() {}\n\tLine(P p, Vec v) : p(p), v(v) {}\n\t\n\tP getPoint(double t) {\n\t\treturn p + v * t;\n\t}\n};\n\nstruct Circle {\n\tP p;\n\tdouble r;\n\t\n\tCircle() {}\n\tCircle(P p, double r) : p(p), r(r) {}\n};\n\ndouble dot(Vec a, Vec b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(Vec a, Vec b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool isInCircle(P &p, Circle &c) {\n\treturn norm(c.p - p) <= c.r*c.r + EPS;\n}\n\nbool isInTri(P a, P b, P c, P d) {\n\tP p[4];\n\tp[0] = a; p[1] = b; p[2] = c; p[3] = d;\n\t\n\tint cnt = 0;\n\tREP(i, 3) {\n\t\tVec v[2];\n\t\tv[0] = p[(i + 1) % 3] - p[i];\n\t\tv[1] = p[3] - p[i];\n\t\tif (cross(v[0], v[1]) < -EPS) cnt++;\n\t}\n\treturn (cnt == 0 || cnt == 3);\n}\n\ndouble distanceSP(Line &s, P &p) {\n\tVec a = s.v, b = p - s.p;\n\treturn abs(cross(a, b)) / abs(a);\n}\n\nint main() {\n\tdouble x1, y1, x2, y2, x3, y3, x4, y4, r;\n\twhile (cin >> x1 >> y1, x1 || y1) {\n\t\tcin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\t\t\n\t\tP p[4] = {P(x1, y1), P(x2, y2), P(x3, y3), P(x4, y4)};\n\t\tLine segment[3] = {Line(p[0], p[1] - p[0]), Line(p[1], p[2] - p[1]), Line(p[2], p[0] - p[2])};\n\t\tCircle c(p[3], r);\n\t\t\n\t\tif ( isInTri(p[0], p[1], p[2], p[3]) &&\n\t\t\t distanceSP(segment[0], c.p) >= c.r - EPS &&\n\t\t\t distanceSP(segment[1], c.p) >= c.r - EPS &&\n\t\t\t distanceSP(segment[2], c.p) >= c.r - EPS )\n\t\t\tputs(\"a\");\n\t\telse if ( isInCircle(p[0], c) && isInCircle(p[1], c) && isInCircle(p[2], c) )\n\t\t\tputs(\"b\");\n\t\telse if ( isInCircle(p[0], c) || isInCircle(p[1], c) || isInCircle(p[2], c) )\n\t\t\tputs(\"c\");\n\t\telse\n\t\t\tputs(\"d\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a+b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\trep(i,2)g[i+1]=pin();\n\t\tP p=pin();double r;cin>>r;\n\t\tC c(p,r);\n\t\tbool h=true;\n\t\trep(i,3)if(!(abs(g[i]-c.c)<c.r+EPS))h=false;\n\t\tif(h){\n\t\t\tcout<<'b'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\th=true;\n\t\tif(inconvex(g,c.c)!=2)h=false;\n\t\trep(i,3)if(distanceSP(L(g[i],g[(i+1)%3]),c.c)+EPS<c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'a'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,3)if(intersectCS(c,L(g[i],g[(i+1)%3])))h=true;\n\t\tif(h)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n#include<string>\n \n#define EPS 1E-10\n#define SAME_SIGN( a , b ) ( a * b > EPS ? true : false )\n \nnamespace geometry{\n \n    struct point{\n        double x;\n        double y;\n        point(){}\n        point( double x , double y ):x(x),y(y){}\n        point& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n        point& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n        point& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n        point& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n        bool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n        bool operator != ( const point& p ) const { return !(*this == p); }\n        double norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n    };\n \n    typedef point vector2d;\n \n    struct circle{\n        point center;\n        double radius;\n    };\n \n    struct triangle{\n        point a;\n        point b;\n        point c;\n    };\n \n    point operator + ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p += p2;\n            return p;\n        }\n        point operator - ( const point& p1 , const point& p2 ){\n            point p(p1);\n            p -= p2;\n            return p;\n        }\n        point operator * ( const point& p1 , double factor ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator * ( double factor , const point& p1 ){\n            point p(p1);\n            p *= factor;\n            return p;\n        }\n        point operator / ( const point& p1 , double factor ){\n            point p(p1);\n            p /= factor;\n            return p;\n        }\n \n    std::istream& operator >> ( std::istream& s , point& p )\n    {\n        return s >> p.x >> p.y;\n    }\n \n    double get_distance( const point& p1 , const point& p2 )\n    {\n\t\tdouble testDis = sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) ); // テスト用\n        return sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n    }\n \n    double get_dot_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.x + oa.y * ob.y;\n    }\n \n    double get_cross_product( const point& a , const point& b , const point& o )\n    {\n        vector2d oa = a - o;\n        vector2d ob = b - o;\n        return oa.x * ob.y - oa.y * ob.x;\n    }\n \n    point get_project( const point& s , const point& e , const point& p ){\n        double scale = get_dot_product( p , e , s ) / ( e - s ).norm();\n        return s + scale * ( e - s ) / ( e - s ).norm();\n    }\n \n    bool is_inter_point( const point& s , const point& e , const point& p ){\n        return std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n    }\n}\n \nusing namespace geometry;\n \nbool input_data( triangle& tri , circle& cir )\n{\n    std::cin >> tri.a;\n    if( tri.a.x == 0 && tri.a.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.b;\n    if( tri.b.x == 0 && tri.b.y == 0 ){\n        return false;\n    }\n    std::cin >> tri.c;\n    if( tri.c.x == 0 && tri.c.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.center;\n    if( cir.center.x == 0 && cir.center.y == 0 ){\n        return false;\n    }\n    std::cin >> cir.radius;\n    return true;\n}\n \nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n    if( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n        if( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius + EPS ){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    else{\n        return false;\n    }\n}\n \nbool is_overlap( triangle& tri , circle& cir )\n{\n    // オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n    if( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n        !(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n        !(is_overlap_for_one_side( tri.c , tri.a , cir ))\n        ){\n            return false;\n    }\n    else{\n        return true;\n    }\n \n}\n \nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n    if( get_distance( tri.a , cir.center ) < cir.radius  &&\n        get_distance( tri.b , cir.center ) < cir.radius  &&\n        get_distance( tri.c , cir.center ) < cir.radius\n        ){\n            std::cout << \"b\" << std::endl;\n    }\n    else{\n        if( get_distance( tri.a , cir.center ) > cir.radius  &&\n            get_distance( tri.b , cir.center ) > cir.radius  &&\n            get_distance( tri.c , cir.center ) > cir.radius\n            ){\n                if( !(is_overlap( tri , cir )) ){\n                    if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                        SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                            std::cout << \"a\" << std::endl;\n                    }\n                    else{\n                        std::cout << \"d\" << std::endl;\n                    }\n                }\n                else{\n                    std::cout << \"c\" << std::endl;\n                }\n        }\n        else{\n            std::cout << \"c\" << std::endl;\n        }\n    }\n}\n\nstd::string output_positional_relation_of_circle_and_triangle_for_test( triangle& tri , circle& cir )\n{\n    if( get_distance( tri.a , cir.center ) < cir.radius  &&\n        get_distance( tri.b , cir.center ) < cir.radius  &&\n        get_distance( tri.c , cir.center ) < cir.radius\n        ){\n           return \"b\";\n    }\n    else{\n        if( get_distance( tri.a , cir.center ) > cir.radius  &&\n            get_distance( tri.b , cir.center ) > cir.radius  &&\n            get_distance( tri.c , cir.center ) > cir.radius\n            ){\n                if( !(is_overlap( tri , cir )) ){\n                    if( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n                        SAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n                        ){\n                           return \"a\";\n                    }\n                    else{\n                        return \"d\";\n                    }\n                }\n                else{\n                    return \"c\";\n                }\n        }\n        else{\n            return \"c\";\n        }\n    }\n}\n\nstruct TEST_CASE {\n\ttriangle tri;\n\tcircle cir;\n\tstd::string ans;\n\n\tvoid SetTestCase( int ax, int ay, int bx, int by, int cx, int cy, int ox, int oy, int r, std::string ans )\n\t{\n\t\tthis->tri.a.x = ax;\n\t\tthis->tri.a.y = ay;\n\t\tthis->tri.b.x = bx;\n\t\tthis->tri.b.y = by;\n\t\tthis->tri.c.x = cx;\n\t\tthis->tri.c.y = cy;\n\t\tthis->cir.center.x = ox;\n\t\tthis->cir.center.y = oy;\n\t\tthis->cir.radius = r;\n\t\tthis->ans = ans;\n\t}\n};\n\nvoid test(void)\n{\n\tTEST_CASE testCase[100];\n\n\ttestCase[0].SetTestCase(10, 20, 1, 5, 19, 5, 10, 10, 3, \"a\");\n\ttestCase[1].SetTestCase(10, 12, 12, 9, 8, 9, 10, 10, 3, \"b\");\n\ttestCase[2].SetTestCase(10, 12, 12, 9, 7, 10, 10, 10, 3, \"c\");\n\ttestCase[3].SetTestCase(20, 5, 40, 20, 40, 5, 20, 20, 12, \"c\");\n\n\tfor( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tstd::cout << \"testCase[\" << i << \"] : \";\n\t\tif( testCase[i].ans == output_positional_relation_of_circle_and_triangle_for_test(testCase[i].tri, testCase[i].cir) ){\n\t\t\tstd::cout << \"OK\" << std::endl;\n\t\t}\n\t\telse{\n\t\t\tstd::cout << \"NG\" << std::endl;\n\t\t}\n\t}\n}\n \nint main(void)\n{\n    triangle tri;\n    circle cir;\n \n\ttest();\n\n    while(input_data(tri, cir)){\n        output_positional_relation_of_circle_and_triangle( tri , cir );\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define EPS (1e-10)\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(0,0),double r=0):p(p),r(r){}\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistancePP(Point p1,Point p2)\n{\n  return sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));\n}\n\nbool isTriangleInCircle(vector<Point> &p,Circle c)\n{\n  double d1,d2,d3;\n  d1 = getDistancePP(p[0],c.p);\n  d2 = getDistancePP(p[1],c.p);\n  d3 = getDistancePP(p[2],c.p);\n  return d1 <= c.r && d2 <= c.r && d3 <= c.r;\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isPointInTriangle(vector<Point> &p,Point c)\n{\n  return (ccw(p[0],p[1],c) == CLOCKWISE && ccw(p[1],p[2],c) == CLOCKWISE && ccw(p[2],p[0],c) == CLOCKWISE) || (ccw(p[0],p[1],c) == COUNTER_CLOCKWISE && ccw(p[1],p[2],c) == COUNTER_CLOCKWISE && ccw(p[2],p[0],c) == COUNTER_CLOCKWISE);\n}\n\nbool isCircleInTriangle(vector<Point> &p,Circle c)\n{\n  double dist[3];\n  dist[0] = getDistanceSP(Segment(p[0],p[1]),c.p);\n  dist[1] = getDistanceSP(Segment(p[1],p[2]),c.p);\n  dist[2] = getDistanceSP(Segment(p[2],p[0]),c.p);  \n  return isPointInTriangle(p,c.p) && dist[0] >= c.r && dist[1] >= c.r && dist[2] >= c.r; \n}\n\nvoid printP(Point p)\n{\n  cout << p.x << \" x \" << p.y << endl; \n}\n\nint main()\n{\n  vector<Point> T(3);\n  while(cin >> T[0].x >> T[0].y,(int)T[0].x|(int)T[0].y)\n    {\n      for(int i=1;i<=2;i++)\n\tcin >> T[i].x >> T[i].y;     \n      Circle c;\n      cin >> c.p.x >> c.p.y;\n      cin >> c.r;\n\n      double dist[3];\n      dist[0] = getDistanceSP(Segment(T[0],T[1]),c.p);\n      dist[1] = getDistanceSP(Segment(T[1],T[2]),c.p);\n      dist[2] = getDistanceSP(Segment(T[2],T[0]),c.p);  \n\n      if(isTriangleInCircle(T,c))\n\tcout << 'b' << endl;\n      else if(isCircleInTriangle(T,c))\n\tcout << 'a' << endl;\n      else if(dist[0] <= c.r || dist[1] <= c.r || dist[2] <= c.r)\n\tcout << 'c' << endl;\n      else \n\tcout << 'd' << endl;      \n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<sstream>\n#include<functional>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define REP(i,s,e) for(int i=int(s);i<int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nusing namespace std;\n\ndouble x4,y4,r;\n\nbool f(double x,double y,double x0,double y0){\ndouble p=(x0-x)*(y0-y4)-(x0-x4)*(y0-y);\ndouble q=(y0-y)*(y0-y)+(x0-x)*(x0-x);\nif(x-x0!=0 && y-y0!=0){\nif(abs(p)/sqrt(q)<=r && (-p*(y0-y)/q)>=min(x,x0) && (-p*(y0-y)/q)<=max(x,x0))\nreturn true;\nelse return false;\n}\nif(x-x0==0 && abs(x)<=r && y*y0<0)\nreturn true;\nelse return false;\nif(y-y0==0 && abs(y)<=r && x*x0<0)\nreturn true;\nelse return false;\n}\n\nbool g(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){\ndouble p=(y1-y4)/(x1-x4);\ndouble q=(y2-y3)/(x2-x3);\ndouble u=((y3-y4)-q*(x3-x4))/(p-q)-x1+x4;\ndouble v=(p*(y3-y4)-p*q*(x3-x4))/(p-q)-y1+y4;\nif((x1-x4)!=0 && (x2-x3)!=0 && (p-q)!=0 && (u*u+v*v)>((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4)))\nreturn true;\nelse return false;\nif((x1-x4)==0 && abs(y1-y4)<abs(y1-y3+q*(x3-x4)))\nreturn true;\nelse return false;\nif((x2-x3)==0 && (x1-x4)!=0 && ((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4))<((x2-x1)*(x2-x1)+(p*x2-p*x4-y1+y4)*(p*x2-p*x4-y1+y4)))\nreturn true;\nelse return false;\n\n}\n\nint main(){\n\ndouble x1,y1,x2,y2,x3,y3;\n\nwhile(true){\n\ncin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\nif(x1==0 && y1==0) break;\n\n\ndouble a,b,c;\na=(x1-x4)*(x1-x4)+(y1-y4)*(y1-y4);\nb=(x2-x4)*(x2-x4)+(y2-y4)*(y2-y4);\nc=(x3-x4)*(x3-x4)+(y3-y4)*(y3-y4);\n\nif(a<r*r && b<r*r && c<r*r)\ncout << \"b\" << endl;\n\nif(!(a<r*r && b<r*r && c<r*r) && !(a>r*r && b>r*r && c>r*r))\ncout << \"c\" << endl;\n\n\nif(a>r*r && b>r*r && c>r*r){\n\nif(f(x1,y1,x2,y2) || f(x2,y2,x3,y3) || f(x1,y1,x3,y3))\ncout << \"c\" << endl;\n\nelse if(g(x1,y1,x2,y2,x3,y3,x4,y4) && g(x2,y2,x1,y1,x3,y3,x4,y4) && g(x3,y3,x2,y2,x1,y1,x4,y4))\ncout << \"a\" << endl;\n\nelse cout << \"d\" << endl;\n\n}\n\n\n}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n#define EPS 1e-10\nstruct point{\n\tdouble x,y;\n\tvoid make(){\n\t\tcin>>x>>y;\n\t}\n\tpoint(){};\n\tpoint(double x,double y):x(x),y(y){};\n\tpoint operator + (point &p) { return point(x+p.x,y+p.y)  ; }\n\tpoint operator - (point &p) { return point(x-p.x,y-p.y)  ; }\n\tdouble norm() { return x*x+y*y;}\n\tdouble abs() { return sqrt(norm()) ;}\n};\nstruct line{\n\tpoint s,e;\n};\n\ndouble cross(point a,point b){\n\treturn a.x*b.y-a.y*b.x;\n}\ndouble dot(point a,point b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nstruct circle{\n\tpoint p;\n\tdouble r;\n\tvoid make(){\n\t\tp.make();\n\t\tcin>>r;\n\t}\n};\n\ndouble abs(point a){\n\treturn a.abs();\n}\ndouble distance(line l,point p){\n\tpoint tmp = l.e-l.s;\n\tif(dot(tmp,p-l.s) < EPS) return abs(p-l.s);\n\tif(dot(l.s-l.e,p-l.e) < EPS ) return abs(p-l.e);\n\treturn abs(cross(l.e-l.s,p-l.s ) / abs(l.e-l.s) );\n}\n\n\nint main(){\n\twhile(1){\n\t\tpoint p[3];\n\t\tp[0].make();\n\t\tif(p[0].x==0 && p[0].y==0 )break;\n\t\tp[1].make();\n\t\tp[2].make();\n\t\tcircle c;\n\t\tc.make();\n\t\tdouble d[3];\n\t\tdouble l[3];\n\t\tdouble r = c.r;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tpoint dis = p[i]-c.p;\n\t\t\td[i] = dis.abs();\n\t\t\tline lt;\n\t\t\tlt.s = p[(i+1)%3];\n\t\t\tlt.e = p[(i+2)%3];\n\t\t\tl[i] = distance(lt,c.p);\n\t\t}\n\t\tdouble area = abs(cross(p[2]-p[0],p[1]-p[0]) );\n\t\tdouble area2 = 0.0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tarea2+= abs( cross(p[i]-c.p, p[(i+1)%3]-c.p ) );\n\t\t}\n\t\t\n\t\tif( r <= l[0]+EPS && r <= l[1]+EPS && r <= l[2]+EPS && area2 <= area + EPS ){\n\t\t//    cout<<l[0]<<' '<<l[1]<<' '<<l[2]<<endl;\n\t\t\tcout<<'a'<<endl;\n\t\t}else if(d[0] <= r+EPS && d[1] <= r+EPS && d[2] <= r+EPS){\n\t\t\tcout<<'b'<<endl;\n\t\t}else if(d[0] > r && d[1] > r&& d[2] >r && l[0]>r&&l[1]>r&&l[2]>r){\n\t\t\tcout<<'d'<<endl;\n\t\t}else {\n\t\t\tcout<<'c'<<endl;\n\t\t}\n\n\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint x1, y1, x2, y2, x3, y3, x4, y4, r;\n\nint distDbl(int ax, int ay, int bx, int by) {\n    return (bx - ax) * (bx - ax) + (by - ay) * (by - ay);\n}\n\ndouble getPerpDistDbl(int ax, int ay, int bx, int by, int cx, int cy) {\n    double a = (double)(by - ay) / (bx - ax);\n    double b = ay - a * ax;\n    double res = (a * cx - cy + b) * (a * cx - cy + b) / (1 + a * a);\n    return res;\n}\n\ndouble getPerpDistSegDbl(int ax, int ay, int bx, int by, int cx, int cy) {\n    double a = (double)(by - ay) / (bx - ax);\n    double b = ay - a * ax;\n    double x = (ax + a * (ay - b)) / (1 + a * a);\n    double y = a * x + b;\n    double res;\n    if (min(ax, bx) <= x && x <= max(ax,bx) &&\n        min(ay, by) <= y && y <= max(ay,by)) {\n        res = (a * cx - cy + b) * (a * cx - cy + b) / (1 + a * a);\n    } else {\n        res = min(distDbl(ax,ay,cx,cy), distDbl(bx,by,cx,cy));\n    }\n    return res;\n}\n\nbool isA() {\n    int c = 0;\n    if (0 < (x2-x1)*(y4-y1)-(y2-y1)*(x4-x1)) ++c;\n    if (0 < (x3-x2)*(y4-y2)-(y3-y2)*(x4-x2)) ++c;\n    if (0 < (x1-x3)*(y4-y3)-(y1-y3)*(x4-x3)) ++c;\n    if (c % 3 != 0) return false;\n    if (getPerpDistDbl(x1, y1, x2, y2, x4, y4) <= r*r) return false;\n    if (getPerpDistDbl(x2, y2, x3, y3, x4, y4) <= r*r) return false;\n    if (getPerpDistDbl(x3, y3, x1, y1, x4, y4) <= r*r) return false;\n    return true;\n}\n\nbool isB() {\n    if (distDbl(x1,y1,x4,y4) <= r*r && distDbl(x2,y2,x4,y4) <= r*r && distDbl(x3,y3,x4,y4) <= r*r) {\n        return true;\n    }\n    return false;\n}\n\nbool isC() {\n    if (getPerpDistSegDbl(x1,y1,x2,y2,x4,y4) <= r*r) return true;\n    if (getPerpDistSegDbl(x2,y2,x3,y3,x4,y4) <= r*r) return true;\n    if (getPerpDistSegDbl(x3,y3,x1,y1,x4,y4) <= r*r) return true;\n    return false;\n}\n\nint main() {\n    while (cin >> x1 >> y1, (x1 || y1)) {\n        cin >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n        if (isB()) cout << \"b\" << endl;\n        else if (isA()) cout << \"a\" << endl;\n        else if (isC()) cout << \"c\" << endl;\n        else cout << \"d\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <vector>\n\nusing namespace std;\n\n//-------------------------------------------------------------------------\n// geometric library\n \nnamespace geometry {\n \n#define EPS 1E-10 ///< 0とみなすサイズ。適当\n \n    struct point {\n        double x;\n        double y;\n \n\t\tpoint() {}\n\t\tpoint(double x, double y) : x(x), y(y) {}\n        point& operator += (const point& rhs) { x += rhs.x; y += rhs.y; return *this; }\n        point& operator -= (const point& rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n        point& operator /= (double factor) { x /= factor; y /= factor; return *this; }\n        point& operator *= (double factor) { x *= factor; y *= factor; return *this; }\n        bool operator == (const point& rhs) const { return (std::abs(x - rhs.x) < EPS) && (std::abs(y - rhs.y) < EPS); }\n        bool operator != (const point& rhs) const { return !(*this == rhs); }\n        bool operator <= (const point& rhs) const { return x < rhs.x || (x == rhs.x && y <= rhs.y); }\n        bool operator >= (const point& rhs) const { return x > rhs.x || (x == rhs.x && y >= rhs.y); }\n        bool operator < (const point& rhs) const { return !(*this >= rhs); }\n        bool operator > (const point& rhs) const { return !(*this <= rhs); }\n\t\tdouble arg() const { return atan2(y, x); }\n        double norm() const { return sqrt(x * x + y * y); }\n\t\tpoint get_normal() const { return point(-y, x); }\n    };\n\ttypedef point vec2d;\n \n    struct circle {\n        point center;\n        double radius;\n\t\tcircle() {}\n\t\tcircle(double x, double y, double r) : center(x, y), radius(r) {}\n    };\n \n\tstruct triangle {\n\t\tpoint p[3];\n\t};\n \n    enum rotate_dir {\n        rotate_None = 0,\n        rotate_CW = 1,\n        rotate_CCW = -1\n    };\n \n    point operator + (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p += p2;\n        return p;\n    }\n \n    point operator / (const point& p1, double factor)\n    {\n        point p(p1);\n        p /= factor;\n        return p;\n    }\n  \n    point operator * (const point& p1, double factor)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator * (double factor, const point& p1)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator - (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p -= p2;\n        return p;\n    }\n \n    std::istream& operator >> (std::istream& is, point& p)\n    {\n        is >> p.x >> p.y;\n        return is;\n    }\n\n    std::istream& operator >> (std::istream& is, circle& c)\n    {\n        is >> c.center >> c.radius;\n        return is;\n    }\n\n    ///! 2点の距離\n    double get_distance(const point& p1, const point& p2)\n    {\n        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    }\n \n    double cross_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.y - p2.x * p1.y;\n    }\n \n    double inner_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n\t///! 直線s-eにpを投影した点を求める\n\tpoint get_project(const point& s, const point& e, const point& p)\n\t{\n\t\tdouble scale = inner_product(p - s, e - s) / (e - s).norm();\n\t\treturn s + scale * (e - s) / (e - s).norm();\n\t}\n\n     ///! pがs-e間(s,e上含む)にあればtrue\n    bool is_inter_point(const point& s, const point& e, const point& p) {\n        double d = get_distance(s, p) + get_distance(p, e) - get_distance(s, e);\n        return abs(d) < EPS;\n    }\n \n    ///! p1-p2-p3が左右どちらの方向に折れているかを判定\n    rotate_dir direction(const point& p1, const point& p2, const point& p3)\n    {\n        point p1_p3 = p1 - p3;\n        point p2_p3 = p2 - p3;\n        double cross = cross_product(p1_p3, p2_p3);\n \n        if (std::abs(cross) < EPS) {\n            return rotate_None;\n        }\n        else if (cross > 0) {\n            return rotate_CW;\n        }\n        else {\n            return rotate_CCW;\n        }\n    }\n\n\tbool is_inside_circle(const point& p, const circle& c)\n\t{\n\t\treturn get_distance(p, c.center) <= c.radius + EPS;\n\t}\n\n\tbool is_inside_circle(const triangle& t, const circle& c)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (!is_inside_circle(t.p[i], c)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n \n    // (p1s, p1e)と(p2s, p2e)の線分交差判定.EPS以下で接している場合はtrue、重なっている場合はfalse\n    bool intersect(const point& p1s, const point& p1e, const point& p2s, const point& p2e)\n    {\n        assert(p1s != p1e && p2s != p2e);\n        return\n            (direction(p1s, p1e, p2s) != direction(p1s, p1e, p2e)) &&\n            (direction(p2s, p2e, p1s) != direction(p2s, p2e, p1e));\n    }\n\n\t// 円と三角形が交差するかどうか\n\tbool intersect(const circle& c, const triangle& t)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tpoint ps = t.p[i], pe = t.p [(i + 1) % 3];\n\n\t\t\tif (is_inside_circle(ps, c) != is_inside_circle(pe, c)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (is_inside_circle(ps, c) && is_inside_circle(pe, c)) {\n\t\t\t\tcontinue; // この辺は交差しない\n\t\t\t}\n\t\t\tpoint m = get_project(ps, pe, c.center);\n\n\t\t\tif (get_distance(m, c.center) <= c.radius + EPS && is_inter_point(ps, pe, m)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} \n\n    // targetが三角形p1,p2,p3の内部にあるかどうか\n    bool is_inside_triangle(const point& target, const point& p1, const point& p2, const point& p3)\n    {\n        point center_of_gravity = (p1 + p2 + p3) / 3; // 重心\n \n        if (center_of_gravity == target) return true;\n \n        // 重心とtargetを結んだ線分が三角形の辺と交叉するなら、点は三角形の外部にある\n        bool intersect_any =\n            intersect(p1, p2, center_of_gravity, target) ||\n            intersect(p2, p3, center_of_gravity, target) ||\n            intersect(p3, p1, center_of_gravity, target);\n \n        return !intersect_any;\n    }\n\n\tbool is_inside_triangle(const point& target, const triangle& t)\n\t{\n\t\treturn is_inside_triangle(target, t.p[0], t.p[1], t.p[2]);\n\t}\n \n\tbool is_inside_triangle(const circle& c, const triangle& t)\n\t{\n\t\tif (is_inside_triangle(c.center, t) && !intersect(c, t)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n \n} // namespace geometry\n\n\n//-----------------------------------------------\n//\n\nusing namespace geometry;\n\nint main(void) {\n\ttriangle triangle;\n\tcircle circle;\n\n\twhile (cin >> triangle.p[0]) {\n\t\tif (triangle.p[0].x == 0 && triangle.p[0].y == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> triangle.p[1] >> triangle.p [2] >> circle;\n\n\t\tif (is_inside_triangle(circle, triangle)) {\n\t\t\tcout << \"a\" << endl;\n\t\t} else if (is_inside_circle(triangle, circle)) {\n\t\t\tcout << \"b\" << endl;\n\t\t} else if (intersect(circle, triangle)) {\n\t\t\tcout << \"c\" << endl;\n\t\t} else {\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-1;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) < c.r - kyuriEPS ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n\tif( ctt >= 1 ) return 2;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r + kyuriEPS){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs( (t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x) );\n\t}\n\t//std::cout << area << \" \" << tS2 << std::endl;\n\t\n\tif( fabs( fabs(area) - tS2 ) < kyuriEPS ) return 0; \t\n\t\n\treturn 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <complex>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\ntypedef complex<ll> P;\n\nint x, y, r;\nP tri[3];\npair<P,ll> circle;\n\nll cross(P e1, P e2) {\n\treturn e1.real() * e2.imag() - e1.imag() * e2.real();\n}\n\nbool inc() {\n\tP e0 = tri[0] - circle.first;\n\tP e1 = tri[1] - circle.first;\n\tP e2 = tri[2] - circle.first;\n\tll d0 = cross(e0, e1);\n\tll d1 = cross(e1, e2);\n\tll d2 = cross(e2, e0);\n\tif(d0 * d1 > 0 && d1 * d2 > 0 && d2 * d0 > 0) return true;\n\treturn false;\n}\n\nll norm2(P p) {\n\treturn p.real() * p.real() + p.imag() * p.imag();\n}\n\nvoid dist2(P p1, P p2, P p, ll& nm, ll& de) {\n\tll a = p2.imag() - p1.imag();\n\tll b = -(p2.real() - p1.real());\n\tll c = - a * p1.real() - b * p1.imag();\n\tnm = a * p.real() + b * p.imag() + c;\n\tnm = nm * nm;\n\tde = a * a + b * b;\n\tif(de == 0) {\n\t\tnm = norm2(p1 - p);\n\t\tde = 1;\n\t}\n}\n\n\nvoid solve() {\n\tbool iscin = inc();\n\tll r2 = circle.second * circle.second;\n\tvector<pll> d(6);\n\tdist2(tri[0], tri[1], circle.first, d[0].first, d[0].second);\n\tdist2(tri[1], tri[2], circle.first, d[1].first, d[1].second);\n\tdist2(tri[2], tri[0], circle.first, d[2].first, d[2].second);\n\tif(iscin && (d[0].first >= r2 * d[0].second) &&\n\t\t        (d[1].first >= r2 * d[1].second) &&\n\t\t        (d[2].first >= r2 * d[2].second)) {\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\n\td[3].first = norm2(tri[0] - circle.first); d[3].second = 1;\n\td[4].first = norm2(tri[1] - circle.first); d[4].second = 1;\n\td[5].first = norm2(tri[2] - circle.first); d[5].second = 1;\n\tif(d[3].first <= r2 && d[4].first <= r2 && d[5].first <= r2) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\tbool inter = false;\n\trep(i,6) {\n\t\tif(d[i].first <= r2 * d[i].second) {\n\t\t\tinter = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(inter) {\n\t\tcout << \"c\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"d\" << endl;\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttri[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[1] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttri[2] = P(x, y);\n\t\t\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tscanf(\"%d\", &r);\n\t\tcircle.first = P(x, y);\n\t\tcircle.second = r;\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Point{ int x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Point c; int r; };\n\ninline double dist(const Point &p1, const Point &p2){\n\treturn sqrt( pow(p2.x-p1.x,2.0)+pow(p2.y-p1.y,2.0) );\n}\ninline double dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble b = 1;\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + b * p.y + c ) / sqrt( pow(a,2.0)+pow(b,2.0) );\n\t}\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) > 0;\n}\ninline bool isRight(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) < 0;\n}\n\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( isLeft( t.a, t.b, p ) && isLeft( t.b, t.c, p ) && isLeft( t.c, t.a, p ) )\n\t\treturn true;\n\telse if( isRight( t.a, t.b, p ) && isRight( t.b, t.c, p ) && isRight( t.c, t.a, p ) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r <= dist( t.a, t.b, c.c ) &&\n\t\t\tc.r <= dist( t.b, t.c, c.c ) &&\n\t\t\tc.r <= dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) <= c.r &&\n\t  dist( t.b, c.c ) <= c.r &&\n\t  dist( t.c, c.c ) <= c.r )\n\t  return true;\n  else\n\t  return false;\n}\nbool isCross(const Point &tp1, const Point &tp2, const Circle &c)\n{\n\tPoint p1 = tp1;\n\tPoint p2 = tp2;\n\tif( p2.x < p1.x )\n\t\tswap( p1, p2 );\n\n\tif( dist( p1, p2, c.c ) > c.r )\n\t\treturn false;\n\telse{\n\t\tif( p1.x != p2.x ){\n\t\t\tdouble x1, x2;\n\t\t\tdouble a = (p2.y - p1.y) / (p2.x - p1.x);\n\t\t\tdouble b = -a * p1.x + p1.y;\n\t\t\tdouble A = 1 + pow(a,2.0);\n\t\t\tdouble B = -( c.c.x - a * b + a * c.c.y );\n\t\t\tdouble C = pow( c.c.x, 2.0 ) + pow( b, 2.0 ) - 2*b*c.c.y + pow( c.c.y, 2.0 ) - pow( c.r, 2.0 );\n\n\t\t\tx1 = ( -B + sqrt( pow(B,2.0) - A * C ) ) / A;\n\t\t\tx2 = ( -B - sqrt( pow(B,2.0) - A * C ) ) / A;\n\n\t\t\tif( p1.x <= x1 && x1 <= p2.x || p1.x <= x2 && x2 <= p2.x )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}else{\n\t\t\tif( p2.y < p1.y )\n\t\t\t\tswap( p1, p2 );\n\n\t\t\tdouble d = dist( p1, p2, c.c );\n\t\t\tdouble l = sqrt( pow(c.r,2.0) - pow(d,2.0) );\n\n\t\t\tdouble y1 = c.c.y - l;\n\t\t\tdouble y2 = c.c.y + l;\n\n\t\t\tif( p1.y <= y1 && y1 <= p2.y || p1.y <= y2 && y2 <= p2.y )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( isCross(t.a,t.b,c) || isCross(t.b,t.c,c) || isCross(t.c,t.a,c) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t,c ) )\n\t\treturn 'b';\n\tif( isCross( t,c ) )\n\t\treturn 'c';\n\telse\n\t\treturn 'd';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( cin.eof() )\n\t\t\tbreak;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point>& ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  int x[4];\n  int y[4];\n  while(~scanf(\"%d %d\",&x[0],&y[0])){\n    if(x[0] == 0 && y[0] == 0) break;\n\n    for(int i=1;i<4;i++){\n      scanf(\"%d %d\",&x[i],&y[i]);\n    }\n    int r;\n    scanf(\"%d\",&r);\n\n    vector<Line> lines;\n    vector<Point> points;\n\n    for(int i=0;i<4;i++){\n      points.push_back(Point(x[i],y[i]));\n    }\n\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        lines.push_back(Line(Point(x[i],y[i]),Point(x[j],y[j])));\n      }\n    }\n\n    vector<Point> convex_hull = compute_convex_hull(points);\n\n    if(convex_hull.size() == 3){\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n      }\n\n      if(r <= dist + EPS){\n        //a\n        printf(\"a\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n        }\n        if(r >= dist - EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n\n      }\n    }\n\n    else if(convex_hull.size() == 4){\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n      }\n\n      if(dist > r){\n        //d\n        printf(\"d\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n        }\n        \n        if(r <= dist + EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n      }\n    }\n\n    else{\n      assert(0);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < 0) in = !in;\n\t\tif (crs(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3, p; long double r; Segment l1, l2, l3;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> p.px >> p.py >> r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, p) < r && dst(p2, p) < r && dst(p3, p) < r) printf(\"b\\n\");\n\t\telse if(dst(l1, p) > r && dst(l2, p) > r && dst(l3, p) > r) printf(contain({p1, p2, p3}, p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct P{\n    P(){}\n    P(ll _r, ll _i):r(_r), i(_i){}\n    void real(const ll& v){r = v;}\n    void imag(const ll& v){i = v;}\n    ll r, i;\n};\n\nll real(const P& p){return p.r;}\nll imag(const P& p){return p.i;}\nll norm(const P& p){ll r = real(p), i = imag(p); return r * r + i * i;}\n\nP operator+(const P& lhs, const P& rhs){\n    return P(real(lhs)+real(rhs), imag(lhs)+imag(rhs));\n}\nP operator-(const P& lhs, const P& rhs){\n    return P(real(lhs)-real(rhs), imag(lhs)-imag(rhs));\n}\nP operator-(const P& p){\n    return P(-real(p), -imag(p));\n}\n\nll cross(const P& lhs, const P& rhs){\n    return real(lhs)*imag(rhs) - imag(lhs)*real(rhs);\n}\n\nll dot(const P& lhs, const P& rhs){\n    return real(lhs)*real(rhs) + imag(lhs)*imag(rhs);\n}\n\n// (distance between ab and p) ^ 2\nll distance(const P& a, const P& b, const P& p){\n    ll c = cross(p-a, b-a);\n    return c * c / norm(b-a);\n}\n\nP ps[3], cc;\nll radius;\n\nbool doesLineAcrossCircle(const P& a, const P& b){\n    // printf(\"(%lld, %lld)-(%lld, %lld): %lld\\n\",\n    //        real(a), imag(a), real(b), imag(b), distance(a, b, cc));\n    if(distance(a, b, cc) > radius * radius){return false;}\n    if(dot(cc-a, b-a) * dot(cc-b, b-a) > 0){return false;}\n    return true;\n}\n\nbool isCircleInTriangle(){\n    REP(i, 3){\n        if(distance(ps[i], ps[(i+1)%3], cc) < radius * radius){return false;}\n    }\n\n    int count_n = 0, count_p = 0;\n    REP(i, 3){\n        ll c = cross(cc-ps[i], ps[(i+1)%3]-ps[i]);\n        if(c < 0){\n            count_n += 1;\n        }else if(c == 0){\n            count_n += 1; count_p += 1;\n        }else{\n            count_p += 1;\n        }\n    }\n\n    if(count_n % 3 == 0 || count_p % 3 == 0){return true;}\n    return false;\n}\n\nbool isTriangleInCircle(){\n    REP(i, 3){\n        if(norm(ps[i]-cc) > radius * radius){return false;}\n    }\n    return true;\n}\n\nbool isIntersected(){\n    REP(i, 3){\n        if(doesLineAcrossCircle(ps[i], ps[(i+1)%3])){return true;}\n    }\n    return false;\n}\n\nint main(){\n    ll re, im;\n    while(std::cin >> re >> im, re || im){\n        ps[0].real(re); ps[0].imag(im);\n        \n        FOR(i, 1, 3){\n            ll re, im;\n            std::cin >> re >> im;\n        \n            ps[i].real(re); ps[i].imag(im);\n        }\n        \n        {\n            ll re, im;\n            std::cin >> re >> im;\n            \n            cc.real(re); cc.imag(im);\n        }\n        \n        std::cin >> radius;\n        \n        if(isCircleInTriangle()){puts(\"a\");}\n        else if(isTriangleInCircle()){puts(\"b\");}\n        else if(isIntersected()){puts(\"c\");}\n        else{puts(\"d\");}\n    }   \n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<sstream>\n#include<functional>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define REP(i,s,e) for(int i=int(s);i<int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nusing namespace std;\n\nbool f(double x1,double y1,double x2,double y2,double x4,double y4,double r){\n\ndouble p=(y2-y1)/(x2-x1);\ndouble q=y1-y4-p*(x1-x4);\ndouble d=p*p*q*q-(1+p*p)*(q*q-r*r);\n\nif(x1!=x2){\nif(d>=0 && (-p*q+sqrt(d))/(1+p*p)<max(x2-x4,x1-x4) && (-p*q-sqrt(d))/(1+p*p)>min(x2-x4,x1-x4))\nreturn true;\nelse return false;\n}\nelse if(abs(x1-x4)<=r && max(y1-y4,y2-y4)>sqrt(r*r-(x1-x4)*(x1-x4)) && min(y1-y4,y2-y4)<-sqrt(r*r-(x1-x4)*(x1-x4)))\nreturn true;\nelse return false;\n}\n\nbool g(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4,double r){\n\ndouble a=sqrt((x1-x4)*(x1-x4)+(y1-y4)*(y1-y4));\ndouble b=(y1-y4)/(x1-x4);\ndouble c=(y2-y3)/(x2-x3);\ndouble x=(y2-y4-c*(x2-x4))/(b-c);\ndouble y=(b*(y2-y4)-b*c*(x2-x4))/(b-c);\n\nif(x1!=x4 && x2!=x3 && b!=c && a>sqrt((x-x1+x4)*(x-x1+x4)+(y-y1+y4)*(y-y1+y4)))\nreturn true;\nelse if(x1==x4 && x2!=x3 && abs(y1-y4)>abs(y1-y2+c*(x2-x4)))\nreturn true;\nelse if(x1!=x4 && x2==x3 && a>sqrt((x2-x1)*(x2-x1)+(b*(x2-x4)-y1+y4)*(b*(x2-x4)-y1+y4)))\nreturn true;\nelse return false;\n\n}\n\nint main(){\n\ndouble x1,y1,x2,y2,x3,y3,x4,y4,r;\n\nwhile(true){\n\ncin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4 >> r;\n\nif(x1==0 && y1==0) break;\n\n\ndouble a,b,c;\na=(x1-x4)*(x1-x4)+(y1-y4)*(y1-y4);\nb=(x2-x4)*(x2-x4)+(y2-y4)*(y2-y4);\nc=(x3-x4)*(x3-x4)+(y3-y4)*(y3-y4);\n\nif(a<r*r && b<r*r && c<r*r)\ncout << \"b\" << endl;\nif(!(a<r*r && b<r*r && c<r*r) && !(a>r*r && b>r*r && c>r*r))\ncout << \"c\" << endl;\n\nif(a>r*r && b>r*r && c>r*r){\nif(f(x1,y1,x2,y2,x4,y4,r) || f(x2,y2,x3,y3,x4,y4,r) || f(x1,y1,x3,y3,x4,y4,r))\ncout << \"c\" << endl;\nelse if(g(x1,y1,x2,y2,x3,y3,x4,y4,r) || g(x2,y2,x1,y1,x3,y3,x4,y4,r) || g(x3,y3,x2,y2,x1,y1,x4,y4,r))\ncout << \"d\" << endl;\nelse cout << \"a\" << endl;\n\n}\n}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//12\n#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\ndouble dt(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\nint main(){\n  for(;;){\n    int x,y;\n    P t[3],c;\n    int r;\n    for(int i=0;i<3;i++){\n      cin>>x>>y;\n      if((i|x|y)==0)return 0;\n      t[i]=P(x,y);\n    }\n    cin>>x>>y;\n    c=P(x,y);\n    cin>>r;\n    if(abs(t[0]-c)<=r&&abs(t[1]-c)<=r&&abs(t[2]-c)<=r){\n      cout<<'b'<<endl;\n    }else{\n      double d[3];\n      bool f[2]={};\n      for(int i=0;i<3;i++){\n\tP l=t[(i+1)%3]-t[i];\n\tif(dt(l,c-t[i])>0&&dt(-l,c-t[(i+1)%3])){\n\t  d[i]=fabs(cr(l,c-t[i])/abs(l));\n\t}else{\n\t  d[i]=min(abs(c-t[0]),abs(c-t[1]));\n\t}\n\tf[cr(l,c-t[i])<0]=true;\n      }\n      if(f[0]^f[1]&&d[0]>=r&&d[1]>=r&&d[2]>=r){\n\tcout<<'a'<<endl;\n      }else if(d[0]<=r||d[1]<=r||d[2]<=r){\n\tcout<<'c'<<endl;\n      }else{\n\tcout<<'d'<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\ntypedef long double ld;\n\nconst ld eps = 1e-9;\n\nstruct Point { // ポイントクラス兼ベクトルクラス\n    ld x, y;\n    Point() {}\n    Point(ld x, ld y) : x(x), y(y) {}\n    Point operator+(const Point &o) const {\n        return Point(x + o.x, y + o.y);\n    }\n    Point operator-(const Point &o) const {\n        return Point(x - o.x, y - o.y);\n    }\n    Point operator*(ld a) const {\n        return Point(a*x, a*y);\n    }\n    Point operator/(ld a) const {\n        return Point(x/a, y/a);\n    }\n    ld norm() const {\n        return sqrt(x*x + y*y);\n    }\n    Point unit() const { // 単位ベクトル\n        return (*this)/norm();\n    }\n};\nld dot(const Point &a, const Point &b) {\n    return a.x * b.x + a.y * b.y;\n}\nld cross(const Point &a, const Point &b) {\n   return a.x * b.y - a.y * b.x;\n}\n#define CCW 1\n#define CW -1\n#define CAB 2\n#define ABC -2\n#define ACB 0\nint ccw(Point a, Point b, Point c) {\n    // aを基準とする位置ベクトルを考える\n\tb = b - a; c = c - a;\n\tif (cross(b, c) > eps) return CCW; // 反時計周り\n\tif (cross(b, c) < -eps) return CW;// 時計周り\n\tif (dot(b, c) < 0) return CAB;     // c--a--bがこの順番に一直線上\n\tif (b.norm() < c.norm()) return ABC; // a--b--cがこの順番に一直線上\n\treturn ACB;                         // a--c--bが一直線上\n}\ntypedef Point Vector;\n\nstruct Segment {\n    Point from, to;\n    Segment() {}\n    Segment(Point from, Point to) : from(from), to(to) {}\n    bool intersects(const Segment &o) const {\n        return (ccw(from, to, o.from) != ccw(from, to, o.to)) &&\n                    (ccw(o.from, o.to, from) != ccw(o.from, o.to, to));\n    }\n    ld length() const {\n        return (to-from).norm();\n    }\n    bool contains(const Point &p) const {\n        return ccw(from, to, p) == ACB;\n    }\n};\n\nstruct Line : public Segment {\n    Line() {}\n    Line(Segment s) : Segment(s) {}\n    Line(Point from, Point to) : Segment(from, to) {}\n    ld distance(const Point &p) const {\n        Vector v1 = p - from;\n        Vector v2 = to - from;\n        ld S = abs(cross(v1, v2));   // v1,v2が張る平行四辺形の面積\n        return S / length();         // それを線分の長さで割る\n    }\n    Point projection(const Point &p) const {\n        Vector v1 = p - from, v2 = to - from;\n        ld l = dot(v1, v2) / v2.norm();\n        return from + (v2.unit()) * l;\n    }\n};\n\nstruct Circle {\n    Point o;\n    ld r;\n    Circle() {}\n    Circle(Point o, ld r) : o(o), r(r) {}\n    Circle(ld x, ld y, ld r) : o(Point(x, y)), r(r) {}\n    bool intersects(const Segment& s) const {\n        if (contains(s.from) && contains(s.to)) return false;\n        Line l(s);\n        if (l.distance(o) > r + eps) return false;\n        if (contains(s.from) != contains(s.to)) return true;\n        return s.contains(l.projection(o));\n    }\n    bool contains(const Point& p) const {\n        ld dx = o.x - p.x;\n        ld dy = o.y - p.y;\n        return r*r + eps >= dx*dx + dy*dy;\n    }\n};\n\nPoint p[3];\nCircle C;\n\nbool b() {\n    for (int i = 0; i < 3; i++) \n        if (!C.contains(p[i]))\n            return false;\n    return true;\n}\n\nbool c() {\n    for (int i = 0; i < 3; i++) {\n        Segment s(p[i%3], p[(i+1)%3]);\n        if (C.intersects(s)) \n            return true;\n    }\n    return false;\n}\n\nbool a() {\n    Point g = (p[0] + p[1] + p[2]) / 3.0;\n    Segment s(C.o, g);\n    for (int i = 0; i < 3; i++) {\n        Segment edge(p[i%3], p[(i+1)%3]);\n        if (s.intersects(edge)) return false;\n    }\n    return true;\n}\n\nint main() {\n    while (cin >> p[0].x >> p[0].y, p[0].x || p[0].y) {\n        cin >> p[1].x >> p[1].y;\n        cin >> p[2].x >> p[2].y;\n        cin >> C.o.x >> C.o.y;\n        cin >> C.r;\n        if (b()) {\n            cout << \"b\" << endl;\n        } else if (c()) {\n            cout << \"c\" << endl;\n        } else if (a()) {\n            cout << \"a\" << endl;\n        } else {\n            cout << \"d\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**************** Geometrical Library ****************/\n\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define\tEPS\t1e-9\n\nenum {CCW=1,CW=-1,ON=0};\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\nclass Point{\npublic:\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy):x(xx),y(yy){}\n};\n\nclass Line:public vector<Point>{\npublic:\n\tLine(const Point &a,const Point &b){\n\t\tpb(a),pb(b);\n\t}\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\nclass Polygon:public vector<Point>{};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(){}\n\tCircle(const Point &cc,double rr):c(cc),r(rr){}\n};\n\nPoint &operator +=(Point &a,const Point &b){\n\ta.x+=b.x,a.y+=b.y;\n\treturn a;\n}\n\nPoint &operator -=(Point &a,const Point &b){\n\ta.x-=b.x,a.y-=b.y;\n\treturn a;\n}\n\nPoint &operator *=(Point &a,double c){\n\ta.x*=c,a.y*=c;\n\treturn a;\n}\n\nPoint &operator /=(Point &a,double c){\n\ta.x/=c,a.y/=c;\n\treturn a;\n}\n\nPoint operator +(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c+=b;\n}\n\nPoint operator -(const Point &a,const Point &b){\n\tPoint c=a;\n\treturn c-=b;\n}\n\nPoint operator *(double c,const Point &a){\n\tPoint b=a;\n\treturn b*=c;\n}\n\nPoint operator /(const Point &a,double c){\n\tPoint b=a;\n\treturn b/=c;\n}\n\nbool operator <(const Point &a,const Point &b){\n\treturn (a.x==b.x)?(a.y<b.y):(a.x<b.x);\n}\n\nbool operator >(const Point &a,const Point &b){\n\treturn b<a;\n}\n\ndouble dot(const Point &a,const Point &b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ndouble norm2(const Point &a){\n\treturn dot(a,a);\n}\n\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=l[0].y-l[1].y;\n\tb=l[1].x-l[0].x;\n\tc=l[0].x*l[1].y-l[1].x*l[0].y;\n}\n\nPoint perp_foot(const Point &p,const Line &l){\n\tdouble a,b,c;\n\tcalc_abc(l,a,b,c);\n\treturn p-(a*p.x+b*p.y+c)/(a*a+b*b)*Point(a,b);\n}\n\nint intersect(const Circle &c,const Line &l,Point *p=NULL,Point *q=NULL){\n\tPoint m=perp_foot(c.c,l);\n\tdouble d2=norm2(c.c-m);\n\tif(c.r*c.r+EPS<d2)\treturn 0;\n\telse if(abs(c.r*c.r-d2)<EPS){\n\t\tif(p&&q)\t*p=*q=m;\n\t\treturn 1;\n\t}\n\telse{\n\t\tif(p&&q){\n\t\t\tPoint v;\n\t\t\tdouble n0=norm2(l[0]-m),n1=norm2(l[1]-m);\n\t\t\tif(n0<n1)\tv=l[1]-m,n0=n1;\n\t\t\telse\t\tv=l[0]-m;\n\t\t\tv*=sqrt((c.r*c.r-d2)/n0);\n\t\t\t*p=m+v,*q=m-v;\n\t\t}\n\t\treturn 2;\n\t}\n}\n\nint intersect(const Circle &c,const Segment &s,Point *p=NULL,Point *q=NULL){\n\tPoint pp,qq;\n\tint n=intersect(c,Line(s[0],s[1]),&pp,&qq);\n\tif(n==0)\treturn 0;\n\telse if(n==1){\n\t\tif(dot(pp-s[0],pp-s[1])<EPS){\n\t\t\tif(p&&q)\t*p=*q=pp;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\telse{\n\t\tbool bp=(dot(pp-s[0],pp-s[1])<EPS);\n\t\tbool bq=(dot(qq-s[0],qq-s[1])<EPS);\n\t\tif(bp&&bq){\n\t\t\tif(p&&q)\t*p=pp,*q=qq;\n\t\t\treturn 2;\n\t\t}\n\t\tif(bp||bq){\n\t\t\tif(p&&q)\t*p=(bp?pp:qq);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n\n/**************** Library END ****************/\n\n#include<cstdio>\n\nint main(){\n\tfor(Point p,q,r;scanf(\"%lf%lf%lf%lf%lf%lf\",&p.x,&p.y,&q.x,&q.y,&r.x,&r.y),p.x||p.y;){\n\t\tCircle c;\tscanf(\"%lf%lf%lf\",&c.c.x,&c.c.y,&c.r);\n\n\t\tint cnt=ccw(p,q,c.c)+ccw(q,r,c.c)+ccw(r,p,c.c);\n\t\tPoint s=perp_foot(c.c,Line(p,q));\n\t\tPoint t=perp_foot(c.c,Line(q,r));\n\t\tPoint u=perp_foot(c.c,Line(r,p));\n\t\tif((cnt==3*CCW || cnt==3*CW)\n\t\t&& c.r*c.r<norm2(s-c.c)+EPS\n\t\t&& c.r*c.r<norm2(t-c.c)+EPS\n\t\t&& c.r*c.r<norm2(u-c.c)+EPS){\n\t\t\tputs(\"a\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(norm2(p-c.c)<c.r*c.r+EPS\n\t\t&& norm2(q-c.c)<c.r*c.r+EPS\n\t\t&& norm2(r-c.c)<c.r*c.r+EPS){\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(intersect(c,Segment(p,q))==0\n\t\t&& intersect(c,Segment(q,r))==0\n\t\t&& intersect(c,Segment(r,p))==0){\n\t\t\tputs(\"d\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tputs(\"c\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n#define X real()\n#define Y imag()\n\ndouble dot(P& a, P& b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P& a, P& b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint sign(double x){\n  if(x > EPS) return 1;\n  if(x < -EPS) return -1;\n  return 0;\n}\n\n//a -> b, a -> c\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(sign(cross(b, c)) > 0) return 1; //反時計\n  if(sign(cross(b, c)) < 0) return -1; //時計\n  if(sign(dot(b, c)) < 0) return +2; //c-a-b\n  if(norm(b) < norm(c)) return -2; //a-b-c\n  return 0; //a-c-b\n}\n\ndouble min_d(P a, P b, P c){\n  double d1 = abs(c - a);\n  double d2 = abs(c - b);\n  b -= a; c -= a;\n  double k = dot(b, c) / norm(b);\n  if(0 < k && k < 1) return abs(c - k * b);\n  else return min(d1, d2);\n}\n\nstring solve(P p[3], P c, double r){\n  if(ccw(p[0], p[1], p[2]) == -1) swap(p[1], p[2]);\n  double maxdist = 0, mindist = 1e18;\n  int ccw_v[3];\n  REP(i, 3){\n    maxdist = max(maxdist, abs(p[i] -  c));\n    mindist = min(mindist, min_d(p[i], p[(i + 1) % 3], c));\n    ccw_v[i] = ccw(p[i], p[(i + 1) % 3], c);\n  }\n  if(maxdist < r) return \"b\";\n  if(ccw_v[0] == ccw_v[1] && ccw_v[1] == ccw_v[2] && ccw_v[0] == 1){\n    if(mindist >= r + EPS) return \"a\";\n    else return \"c\";\n  }else{\n    if(mindist > r) return \"d\";\n    else return \"c\";\n  }\n}\n\nint main(){\n  P p[3];\n  P c; double r;\n  while(cin>>p[0].X>>p[0].Y>>p[1].X>>p[1].Y>>p[2].X>>p[2].Y>>c.X>>c.Y>>r){\n    cout<<solve(p, c, r)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(double& v,double& w,double& x,double& y,int& n,int bx,int by,int ex,int ey,int cx,int cy,int cr){\n  double vx,vy,px,py,ds;\n  ds=sqrt((ex-bx)*(ex-bx)+(ey-by)*(ey-by));\n  vx=(ex-bx)/ds;\n  vy=(ey-by)/ds;\n  ds=((ey-by)*cx+(bx-ex)*cy+(by-ey)*bx+(ex-bx)*by)/((ey-by)*vy-(bx-ex)*vx);\n  px=cx-vy*ds;\n  py=cy+vx*ds;\n  if(0){\n  }else if(cr>ds){\n    n=2;\n    ds=sqrt(cr*cr-ds*ds);\n    v=px+vx*ds;\n    w=py+vy*ds;\n    x=px-vx*ds;\n    y=py-vy*ds;\n  }else if(cr<ds){\n    n=0;\n  }else{\n    n=1;\n    v=px;\n    w=py;\n  }\n  return;\n}\nint g(int bx,int by,int ex,int ey,int cx,int cy,int cr){\n  int n;\n  double v,w,x,y;\n  f(v,w,x,y,n,bx,by,ex,ey,cx,cy,cr);\n  if(0){\n  }else if(n==0){\n    return 0;\n  }else if(n==1){\n    if(bx==ex)\n      return min(by,ey)<=w&&w<=max(by,ey);\n    else\n      return min(bx,ex)<=v&&v<=max(bx,ex);\n  }else{\n    if(bx==ex)\n      return min(by,ey)<=min(w,y)&&max(w,y)<=max(by,ey);\n    else\n      return min(bx,ex)<=min(v,x)&&min(v,x)<=max(bx,ex);\n  }\n}\nint range(double p,double q,double r){\n  return (q<r?q:r)<p&&p<(q<r?r:q);\n}\nint rangea(double p,double q,double r){\n  if(q*r<0&&fabs(q)+fabs(r)>M_PI){\n    p+=2*M_PI*(p<0);\n    q+=2*M_PI*(q<0);\n    r+=2*M_PI*(r<0);\n  }\n  return range(p,q,r);\n}\nint pit(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n  if(rangea(atan2(ay-py,ax-px),atan2(ay-by,ax-bx),atan2(ay-cy,ax-cx))){\n    if(rangea(atan2(by-py,bx-px),atan2(by-ay,bx-ax),atan2(by-cy,bx-cx))){\n      return 1;\n    }\n  }\n  return 0;\n}\nint main(){\n  int i;\n  int ac[3],ax[3],ay[3],cx,cy,cr;\n  while(cin>>ax[0]>>ay[0]&&ax[0]&&ay[0]){\n    for(i=1;i<3;i++)\n      cin>>ax[i]>>ay[i];\n    cin>>cx>>cy>>cr;\n    for(i=0;i<3;i++)\n      ac[i]=(ax[i]-cx)*(ax[i]-cx)+(ay[i]-cy)*(ay[i]-cy)>cr*cr;\n    if(0){\n    }else if(ac[0]&ac[1]&ac[2]){\n      for(i=0;i<3;i++){\n\tif(g(ax[i],ay[i],ax[(i+1)%3],ay[(i+1)%3],cx,cy,cr))\n\t  break;\n      }\n      if(i==3){\n\tif(pit(ax[0],ay[0],ax[1],ay[1],ax[2],ay[2],cx,cy))\n\t  cout<<\"a\"<<endl;\n\telse\n\t  cout<<\"d\"<<endl;\n      }else{\n\tcout<<\"c\"<<endl;\n      }\n    }else if(ac[0]|ac[1]|ac[2]){\n      cout<<\"c\"<<endl;\n    }else{\n      cout<<\"b\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\n\nconst double EPS = 1e-9;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\nbool EPS_less(double lhs, double rhs) {return lhs < rhs - EPS;}\nbool EPS_equal(double lhs, double rhs) {return lhs <= rhs + EPS;}\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return EPS_less(center.distance(p), r);}\n    bool include(const Segment& s) const {return EPS_less(center.distance(s), r) || EPS_equal(center.distance(s), r);}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n//     if(s.ccw(p) == ON) return distance(p);\n    if(EPS_less(s.start.distance(p) + s.end.distance(p), s.start.distance(s.end))) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x - y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.start - s.end;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + Point(t, t) * v2;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n    for(auto& e: edge) if(circle.include(e)) return \"c\";\n\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center) > 0) ++ccw;\n        if(e.ccw(circle.center) < 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nstruct Point{\n  int x;\n  int y;\n};\n\nstruct Delta{\n  Point p[3];\n};\n\nstruct Circle{\n  Point p;\n  int radius;\n};\n\ndouble distance(Point p1, Point p2){\n  return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n\ndouble dist_line(Point pl1, Point pl2, Point p){\n  int a = pl1.x - pl2.x;\n  int b = pl2.y - pl1.y;\n  int c = pl1.y * pl2.x - pl1.x * pl2.y;\n  double ans = b * p.x + a * p.y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n\t  cerr << \"cannot find the file\" << endl;\n\t  return 1;\n  }\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n\tDelta *d = (Delta *) malloc(sizeof(Delta));\n\tfor (int i = 0; i < 5; i++) {\n\t\tgetline(ifs, str);\n\n      if(str == \"0 0\") break;\n\t  \n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n\t      if(str[j] == ' '){\t\t\t\n\t\t\tstr[j] = '\\0';\n\t\t\tbreak;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\t  \n    }\n    if(str == \"0 0\") break;\n\t\n\n    if(distance(d->p[0], c->p) <= c->radius&& distance(d->p[1], c->p) <= c->radius&& distance(d->p[2], c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(d->p[0], d->p[1], c->p) >= c->radius&& dist_line(d->p[0], d->p[2], c->p) >= c->radius&& dist_line(d->p[1], d->p[2], c->p) >= c->radius){\n\t\tif (dist_line(d->p[0], d->p[1], d->p[2]) <= distance(d->p[0], c->p) && dist_line(d->p[1], d->p[2], d->p[0]) <= distance(d->p[1], c->p) && dist_line(d->p[2], d->p[0], d->p[1]) <= distance(d->p[2], c->p))\n\t\t\tcout << 'd' << endl;\n\t\telse\n\t\t\tcout << 'a' << endl;\n    }\n    else if(dist_line(d->p[0], d->p[1], c->p) <= c->radius|| dist_line(d->p[0], d->p[2], c->p) <= c->radius|| dist_line(d->p[1], d->p[2], c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Triangle and Circle\n\n#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値, Polygonのメンバ変数\n#include<algorithm> // min()\n\nconst double EPS = 1e-10;\nenum POSITION {ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\nclass Polygon;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Segment(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(double x1 = 0.0, double y1 = 0.0, double x2 = 0.0, double y2 = 0.0) :source_point(Point(x1, y1)), target_point(Point(x2, y2)) {}\n    Line(const Point& a, const Point& b) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    bool parallel(const Line&) const;\n    bool orthogonal(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Segment&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    std::vector<Point> crosspoint(const Circle&) const;\n};\nclass Polygon {\n    std::vector<Point> point;\npublic:\n    Polygon() {}\n    const std::vector<Point>& vertex() const {return point;}\n    const Point& vertex(int i) const {return point.at(i);}\n    const std::vector<Segment> edge() const {\n        std::vector<Segment> result;\n        for(int i = 0; i < size(); ++i) result.push_back(Segment(vertex(i), vertex((i + 1) % size())));\n        return result;\n    }\n    const Segment edge(int i) const {return Segment(vertex(i), vertex((i + 1) % size()));}\n    int size() const {return point.size();}\n    void add(const Point&);\n    double area() const;\n    bool convex() const;\n    bool include(const Point&) const;\n    bool on_edge(const Point&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return COUNTER_CLOCKWISE;\n    if(v1.cross(v2) < -EPS) return CLOCKWISE;\n    if(v1.dot(v2) < -EPS) return ONLINE_BACK;\n    if(v2.norm() - v1.norm() > EPS) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    return std::min(source().distance(p), target().distance(p));\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    return std::min({a, b, c, d});\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {return source().distance(p) + target().distance(p) - target().distance(source()) <= EPS;}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + v2 * (v1.dot(v2) / v2.norm()));\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nbool Line::parallel(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dxl - dyl * dx) <= EPS;\n}\nbool Line::orthogonal(const Line& l) const {\n    double dx = target().x() - source().x();\n    double dy = target().y() - source().y();\n    double dxl = l.target().x() - l.source().x();\n    double dyl = l.target().y() - l.source().y();\n    return fabs(dy * dyl + dxl * dx) <= EPS;\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) < r();}\nbool Circle::include(const Segment& s) const {return center().distance(s) <= r();}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nstd::vector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    std::vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n// Polygon\nvoid Polygon::add(const Point& p) {point.push_back(p);}\ndouble Polygon::area() const {\n    double sum = 0.0;\n    for(int i = 0; i < size(); ++i) sum += vertex(i).cross(vertex((i+1) % size()));\n    return fabs(sum) / 2.0;\n}\nbool Polygon::convex() const {\n    POSITION direction = ONLINE_BACK;\n    for(int i = 1; i < size(); ++i) {\n        POSITION d = vertex(i - 1).ccw(vertex(i), vertex((i + 1) % size()));\n        if(d != CLOCKWISE && d != COUNTER_CLOCKWISE) continue;\n        if(direction == ONLINE_BACK) direction = d;\n        if(direction != d) return false;\n    }\n    return true;\n}\nbool Polygon::include(const Point& p) const {\n    bool in = false;\n    for(int i = 0; i < size(); ++i) {\n        Point a = vertex(i) - p;\n        Point b = vertex((i + 1) % size()) - p;\n        if(a.y() > b.y()) std::swap(a, b);\n        if(a.y() <= 0.0 && 0 < b.y() && a.cross(b) < 0.0) in = !in;\n        if(fabs(a.cross(b)) <= EPS && a.dot(b) <= EPS) return true;\n    }\n    return in;\n}\nbool Polygon::on_edge(const Point& p) const {\n    for(int i = 0; i < size(); ++i) if(vertex(i).ccw(vertex((i + 1) % size()), p) == ON_SEGMENT) return true;\n    return false;\n}\n\nusing namespace std;\n\nstring solve(const Polygon& triangle, const Circle& circle) {\n    bool triangleInCircle = true;\n    for(const auto& p: triangle.vertex()) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    for(const auto& e: triangle.edge()) if(circle.include(e)) return \"c\";\n\n    if(triangle.include(circle.center())) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x, y, r;\n    while(cin >> x >> y, x != 0 || y != 0) {\n        Polygon triangle;\n        for(int i = 1; i < 4; ++i) {\n            triangle.add(Point(x, y));\n            cin >> x >> y;\n        }\n        cin >> r;\n        Circle circle(x, y, r);\n        cout << solve(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n#include<cassert>\n\n#define SQRD(a) ((a)*(a))\n\nusing namespace std;\n\nstruct Point{ double x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Point c; int r; };\n\ninline double dist(const Point &p1, const Point &p2){\n\treturn sqrt( pow(p2.x-p1.x,2.0)+pow(p2.y-p1.y,2.0) );\n}\ninline double dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + p.y + c ) / sqrt( SQRD(a) + 1 );\n\t}\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) >= 0;\n}\ninline bool isRight(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) <= 0;\n}\n\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( isLeft( t.a, t.b, p ) && isLeft( t.b, t.c, p ) && isLeft( t.c, t.a, p ) )\n\t\treturn true;\n\tif( isRight( t.a, t.b, p ) && isRight( t.b, t.c, p ) && isRight( t.c, t.a, p ) )\n\t\treturn true;\n\treturn false;\n}\n\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r <= dist( t.a, t.b, c.c ) &&\n\t\t\tc.r <= dist( t.b, t.c, c.c ) &&\n\t\t\tc.r <= dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) <= c.r &&\n\t  dist( t.b, c.c ) <= c.r &&\n\t  dist( t.c, c.c ) <= c.r )\n\t  return true;\n  else\n\t  return false;\n}\nbool isCross(const Point &p1, const Point &p2, const Circle &c)\n{\n\tPoint a1;\n\tPoint a2;\n\tdouble d = dist(p1,p2,c.c);\n\tdouble l = dist(p1,p2);\n\t\t\t\n\tif( d > c.r )\n\t\treturn false;\n\telse{\n\t\tif( p1.x != p2.x ){\n\t\t\tdouble a = (p2.y - p1.y) / (p2.x - p1.x);\n\t\t\tdouble b = -a * p1.x + p1.y;\n\t\t\tdouble A = 1 + pow(a,2.0);\n\t\t\tdouble B = a * b - c.c.x - a * c.c.y;\n\t\t\tdouble C = SQRD(c.c.x) + SQRD(c.c.y) - SQRD(c.r) + SQRD(b) - 2*b*c.c.y;\n\n\t\t\tassert( SQRD(B)-A*C >= 0 );\n\t\t\ta1.x = ( -B + sqrt( SQRD(B) - A * C ) ) / A;\n\t\t\ta2.x = ( -B - sqrt( SQRD(B) - A * C ) ) / A;\n\t\t\ta1.y = a * a1.x + b;\n\t\t\ta2.y = a * a1.x + b;\n\t\t\t\n\t\t\tif( dist(a1,p1) <= l && dist(a1,p2) <= l ||\n\t\t\t\tdist(a2,p1) <= l && dist(a2,p2) <= l )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}else{\n\t\t\tdouble e = sqrt( SQRD(c.r) - SQRD(d) );\n\n\t\t\ta1.x = p1.x; a1.y = c.c.y - e;\n\t\t\ta2.x = p2.x; a2.y = c.c.y + e;\n\n\t\t\tif( dist(a1,p1) <= l && dist(a1,p2) <= l ||\n\t\t\t\tdist(a2,p1) <= l && dist(a2,p2) <= l )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( isCross(t.a,t.b,c) || isCross(t.b,t.c,c) || isCross(t.c,t.a,c) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t,c ) )\n\t\treturn 'b';\n\tif( isCross( t,c ) )\n\t\treturn 'c';\n\telse\n\t\treturn 'd';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( cin.eof() )\n\t\t\tbreak;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> Po;\nPo p[3],o;\n\ndouble dot(Po x, Po y){return x.real()*y.real()+x.imag()*y.imag();}\n\ndouble cross(Po x, Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a, Po b, Po c){return abs(cross(b-a,c-a))/2;}\n\nbool inter(Po a, Po b, Po c, Po x){\n  return (fabs(area(a,b,x)+area(b,c,x)+area(c,a,x)-area(a,b,c)) < EPS);\n}\n\ndouble seg_dis(Po a, Po b, Po c){\n  if(dot(b-a,c-a)<EPS)return abs(c-a);\n  if(dot(a-b,c-b)<EPS)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nint main(){\n  double x[4],y[4],r;\n\n  for(;;){\n    cin >> x[0] >> y[0];\n    if(!x[0] && !y[0])break;\n\n    for(int i=1;i<4;i++)cin >> x[i] >> y[i];\n    cin >> r;\n\n    for(int i=0;i<3;i++)p[i] = Po(x[i],y[i]);\n    o = Po(x[3],y[3]);\n\n\n    bool f = true;;\n    for(int i=0;i<3;i++)f &= !(abs(o-p[i])>r);\n    if(f)cout << \"b\\n\";\n    else if(inter(p[0],p[1],p[2],o)){\n      f = true;\n      for(int i=0;i<3;i++)f &= !(seg_dis(p[i],p[(i+1)%3],o)<r);\n      if(f)cout << \"a\\n\";\n      else cout << \"c\\n\";\n    }else{\n      for(int i=0;i<3;i++)f |= !(seg_dis(p[i],p[(i+1)%3],o)>r);\n      if(f)cout << \"c\\n\";\n      else cout << \"d\\n\";\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0){\n\t\t\tif(acx*acx+acy*acy<=r*r)return true;\n\t\t}else{\n\t\t\tif(abx*acx+aby*acy>abx*abx+aby*aby){\n\t\t\t\tif(bcx*bcx+bcy*bcy<=r*r)return true;\n\t\t\t}else if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<0)ok1=false;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)>0)ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<0)ok1=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)>0)ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<0)ok1=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)>0)ok2=false;\n\treturn ok1||ok2;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<=r*r&&(c-g)*(c-g)+(d-h)*(d-h)<=r*r&&(e-g)*(e-g)+(f-h)*(f-h)<=r*r)printf(\"b\\n\");\n\t\telse if(inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cfloat>\nusing namespace std;\n\nconst double EPS = 1e-9;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};\n\nbool EPS_less(double lhs, double rhs) {return lhs < rhs - EPS;}\nbool EPS_equal(double lhs, double rhs) {return lhs <= rhs + EPS;}\n\n// classes\nclass Point;\nclass Segment;\nclass Circle;\n\n// members\nclass Point {\npublic:\n    double x, y;\n    Point(double x, double y) :x(x), y(y) {}\n    const Point& operator=(const Point& p) {x = p.x; y = p.y; return *this;}\n    const Point operator+(const Point& p) const {return Point(x + p.x, y + p.y);}\n    const Point operator-(const Point& p) const {return Point(x - p.x, y - p.y);}\n    const Point operator*(const Point& p) const {return Point(x * p.x, y * p.y);}\n    double distance(const Point& p) const;\n    double distance(const Segment& s) const;\n    double dot(const Point& p) const;\n    double cross(const Point& p) const;\n    const Point projection(const Segment& s) const;\n};\nclass Segment {\npublic:\n    Point start, end;\n    Segment(const Point& s, const Point& e) :start(s), end(e) {}\n    POSITION ccw(const Point& p) const {\n        const Point& a = start;\n        const Point& b = end;\n        Point v1 = b - a;\n        Point v2 = p - a;\n        double d = v1.cross(v2);\n        if(d < 0.0) return ABOVE;\n        if(d > 0.0) return UNDER;\n        if(v1.dot(v2) < -EPS) return BACKWARD;\n        if(v2.distance(Point(0, 0)) - v1.distance(Point(0, 0)) > EPS) return FORWARD;\n        return ON;\n    }\n};\nclass Circle {\npublic:\n    Point center;\n    double r;\n    Circle(double x, double y, double r) :center(Point(x, y)), r(r * r) {}\n    bool include(const Point& p) const {return EPS_less(center.distance(p), r);}\n    bool include(const Segment& s) const {\n        return EPS_less(center.distance(s), r) || EPS_equal(center.distance(s), r);}\n};\n\n// implements\ndouble Point::distance(const Point& p) const {return (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);}\ndouble Point::distance(const Segment& s) const {\n    Point p = projection(s);\n    if(s.ccw(p) == ON) return distance(p);\n    return min(distance(s.start), distance(s.end));\n}\ndouble Point::dot(const Point& p) const {return x * p.x + y * p.y;}\ndouble Point::cross(const Point& p) const {return x * p.y - y * p.x;}\nconst Point Point::projection(const Segment& s) const {\n    Point v1 = *this - s.start;\n    Point v2 = s.end - s.start;\n    double t = v1.dot(v2) / s.start.distance(s.end);\n    return s.start + Point(t, t) * v2;\n}\n\n// main\nstring check(const vector<Point>& triangle, const Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    bool triangleInCircle = true;\n    for(auto& p: triangle) triangleInCircle &= circle.include(p);\n    if(triangleInCircle) return \"b\";\n\n    for(auto& e: edge) if(circle.include(e)) return \"c\";\n\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center) > 0) ++ccw;\n        if(e.ccw(circle.center) < 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a+b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\trep(i,2)g[i+1]=pin();\n\t\tP p=pin();double r;cin>>r;\n\t\tC c(p,r);\n\t\tbool h=true;\n\t\trep(i,3)if(!(abs(g[i]-c.c)<c.r+EPS))h=false;\n\t\tif(h){\n\t\t\tcout<<'b'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\th=true;\n\t\tif(inconvex(g,c.c)==0)h=false;\n\t\trep(i,3)if(distanceLP(L(g[i],g[(i+1)%3]),c.c)+EPS<c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'a'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,3)if(intersectCS(c,L(g[i],g[(i+1)%3])))h=true;\n\t\tif(h)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(contains(c,g[0])==OUT)return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        if(contains(g,c))puts(\"a\");\n        else if(contains(c,g))puts(\"b\");\n        else{\n            bool x=false;\n            for(int i=0;i<g.size();i++){\n                if(intersectCS(c,Segment(g[i],next(g,i))))x=true;\n            }\n            puts(x?\"c\":\"d\");\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<iomanip>\n#include<bitset>\n#include<utility>\n#include<list>\n#include<map>\n#include<set>\n#include<cstring>\n#include<sstream>\n#include<cctype>\nusing namespace std;\nconst double EPS=1e-10;\nconst double INF=1e9;\ntypedef complex<double>P;\nnamespace std{\n    bool operator<(const P& a,const P& b){\n        return real(a)!=real(b)?real(a)<real(b):imag(a)<imag(b);\n    }\n}\n#define EQ(a,b) (fabs((a)-(b))<EPS)\n#define EQV(a,b) (EQ(real(a),real(b))&&EQ(imag(a),imag(b)))\ndouble cross(const P &a,const P &b){\n    return imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n    return real(conj(a)*b);\n}\n\nstruct L:public vector<P>{\n    L(const P &a,const P &b){\n        push_back(a);push_back(b);\n    }\n    L(){}\n};\n\ntypedef vector<P>G;\n\nstruct C{\n    P p;double r;\n    C(const P &p_,double r_):p(p_),r(r_){}\n    C(){}\n};\n\nint ccw(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>0)return 1;///counter clockwise\n    if(cross(b,c)<0)return -1;///clockwise\n    if(dot(b,c)<0)return 2;///c--a--b on line\n    if(norm(b)<norm(c))return -2;///a--b--c on line\n    return 0;\n}\nbool orthogonal(P &p,P &q){\n    return EQ(dot(p,q),0.0);\n}\nbool intersectLL(const L &l,const L &m){\n    return abs(cross(l[1]-l[0],m[1]-m[0]))>EPS||///non-parallel\n        abs(cross(l[1]-l[0],m[0]-l[0]))<EPS;///same line\n}\nbool intersectLS(const L &l,const L &s){\n    return cross(l[1]-l[0],s[0]-l[0])*///s[0] is left of l\n        cross(l[1]-l[0],s[1]-l[0])<EPS;///s[1] is right of l\n}\nbool intersectLP(const L &l,const P &p){\n    return abs(cross(l[1]-p,l[0]-p))<EPS;\n}\nbool intersectSS(const L &s,const L &t){\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nbool intersectSP(const L &s,const P &p){\n    return abs(abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]))<EPS;\n    ///triangle inequality\n}\nP projection(const L &l,const P &p){\n    double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n    return l[0]+t*(l[0]-l[1]);\n}\nP reflection(const L &l,const P &p){\n    return p+(projection(l,p)-p)*2.0;\n}\ndouble distanceLP(const L &l,const P &p){\n    return abs(p-projection(l,p));\n}\ndouble distanceLL(const L &l,const L &m){\n    return intersectLL(l,m)?0:distanceLP(l,m[1]);\n}\ndouble distanceLS(const L &l,const L &s){\n    if(intersectLS(l,s))return 0;\n    return min(distanceLP(l,s[0]),distanceLP(l,s[1]));\n}\ndouble distanceSP(const L &s,const P &p){\n    const P r=projection(s,p);\n    if(intersectSP(s,r))return abs(r-p);\n    return min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L &s,const L &t){\n    if(intersectSS(s,t))return 0;\n    return min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n            min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\nP crossPoint(const L &l,const L &m){\n    double A=cross(l[1]-l[0],m[1]-m[0]);\n    double B=cross(l[1]-l[0],l[1]-m[0]);\n    if(abs(A)<EPS&&abs(B)<EPS)return m[0];///same line\n    ///if(abs(A)<EPS)assert(false);\n    return m[0]+B/A*(m[1]-m[0]);\n\n}\n\nP extreme(const G &g,const L &l){\n    int k=0;\n    for(int i=1;i<g.size();i++){\n        if(dot(g[i],l[1]-l[0])>dot(g[k],l[1]-l[0]))k=i;\n    }\n    return g[k];\n}\n\nG andrewScan(G s){\n    G u,l;\n    if(s.size()<3)return s;\n    sort(s.begin(),s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n\n    for(int i=2;i<s.size();i++){\n        for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=-1;n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for(int i=s.size()-3;i>=0;i--){\n        for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=-1;n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n    reverse(l.begin(),l.end());\n    for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n    return l;\n}\n/*\nIN 2\nON 1\nOUT 0\n*/\nint contains(G g,P p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        P a=g[i]-p,b=g[(i+1)%n]-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return (x?2:0);\n}\n\nint main(){\n    G g(3);\n    C c;\n    while(scanf(\"%lf%lf\",&g[0].real(),&g[0].imag()),g[0].real()!=0||g[0].imag()!=0){\n        for(int i=1;i<3;i++)scanf(\"%lf%lf\",&g[i].real(),&g[i].imag());\n        scanf(\"%lf%lf%lf\",&c.p.real(),&c.p.imag(),&c.r);\n\n        bool flag=true;\n\n        for(int i=0;i<3;i++){\n            flag&=(distanceSP(L(g[i],g[(i+1)%3]),c.p)+EPS>c.r);\n        }\n\n        if(flag){\n            if(contains(g,c.p)==2)puts(\"a\");\n            else puts(\"d\");\n            continue;\n        }\n        flag=true;\n        for(int i=0;i<3;i++){\n            flag&=(c.r+EPS>abs(g[i]-c.p));\n        }\n        if(flag){\n            puts(\"b\");\n            continue;\n        }\n        puts(\"c\");\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define EPS (1e-10)\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(0,0),double r=0):p(p),r(r){}\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistancePP(Point p1,Point p2)\n{\n  return sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));\n}\n\nbool isTriangleInCircle(vector<Point> &p,Circle c)\n{\n  double d1,d2,d3;\n  d1 = getDistancePP(p[0],c.p);\n  d2 = getDistancePP(p[1],c.p);\n  d3 = getDistancePP(p[2],c.p);\n  return d1 <= c.r && d2 <= c.r && d3 <= c.r;\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1))/abs(s.p2-s.p1);\n}\n\ndouble getDistanceSP(Segment s,Point p)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nbool isPointInTriangle(vector<Point> &p,Point c)\n{\n  int res1 = ccw(p[0],p[1],c);\n  int res2 = ccw(p[1],p[2],c);\n  int res3 = ccw(p[2],p[0],c);\n  return (res1 == CLOCKWISE && res2 == CLOCKWISE && res3 == CLOCKWISE) || (res1 == COUNTER_CLOCKWISE && res2 == COUNTER_CLOCKWISE && res3 == COUNTER_CLOCKWISE);\n}\n\nbool isCircleInTriangle(vector<Point> &p,Circle c)\n{\n  double dist[3];\n  dist[0] = getDistanceSP(Segment(p[0],p[1]),c.p);\n  dist[1] = getDistanceSP(Segment(p[1],p[2]),c.p);\n  dist[2] = getDistanceSP(Segment(p[2],p[0]),c.p);  \n  return isPointInTriangle(p,c.p) && dist[0] >= c.r && dist[1] >= c.r && dist[2] >= c.r;\n}\n\n\n\n\nint main()\n{\n  vector<Point> T(3);\n  while(cin >> T[0].x >> T[0].y,(int)T[0].x|(int)T[0].y)\n    {\n      for(int i=1;i<=2;i++)\n\tcin >> T[i].x >> T[i].y;     \n      Circle c;\n      cin >> c.p.x >> c.p.y;\n      cin >> c.r;\n\n      double dist[3];\n      dist[0] = getDistanceSP(Segment(T[0],T[1]),c.p);\n      dist[1] = getDistanceSP(Segment(T[1],T[2]),c.p);\n      dist[2] = getDistanceSP(Segment(T[2],T[0]),c.p);  \n\n      if(isTriangleInCircle(T,c))\n\tcout << 'b' << endl;\n      else if(isCircleInTriangle(T,c))\n\tcout << 'a' << endl;\n      else if(dist[0] <= c.r || dist[1] <= c.r || dist[2] <= c.r)\n\tcout << 'c' << endl;\n      else \n\tcout << 'd' << endl;      \n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\n#define EPS 1e-8\n\nusing namespace std;\n\ntypedef complex<double> P; \ntypedef vector<P> G;\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a)*b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b){\n        push_back(a);\n        push_back(b);\n    }\n    L(){}\n};\n\nstruct C{\n    P p;\n    double r;\n    C(const P &p, double r) : p(p), r(r) { }\n    C(){}\n};\n\nbool intersectSP(const L &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n#define curr(G, i) G[i]\n#define next(G, i) G[(i+1)%G.size()]\nenum { OUT, ON, IN };\nint contains(const G &g, const P &p) {\n    bool in = false;\n    for (int i = 0; i < g.size(); ++i) {\n        P a = curr(g,i) - p, b = next(g,i) - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b))\n            if (cross(a, b) < 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\nint main(){\n    int tmpx, tmpy,r;\n    while(cin >> tmpx >> tmpy){\n        if((tmpx | tmpy) == 0) break;\n        G v(3);\n        L *e = new L[3];\n        C c;\n        v[0] = P(tmpx, tmpy);\n        cin >> tmpx >> tmpy;\n        v[1] = P(tmpx, tmpy);\n        cin >> tmpx >> tmpy;\n        v[2] = P(tmpx, tmpy);\n        e[0] = L(v[0],v[1]);\n        e[1] = L(v[0],v[2]);\n        e[2] = L(v[1],v[2]);\n        cin >> tmpx >> tmpy >> r;\n        c = C(P(tmpx,tmpy), r);\n        //a:T contains C\n        bool isA = true;\n        for(int i=0;i<3;i++){\n            //for all edges\n            if(distanceSP(e[i], c.p) < r){\n                isA = false;\n            }\n        }\n        if(isA && contains(v, c.p) == IN){\n            cout << \"a\" << endl;\n            continue;\n        }\n        //b:C contains T\n        bool isB = true;\n        for(int i=0;i<3;i++){\n            //for all vertex\n            if(abs(v[i] - c.p) > r){\n                isB = false;\n            }\n        }\n        if(isB){\n            cout << \"b\" << endl;\n            continue;\n        }\n        bool isC = false;\n        for(int i=0;i<3;i++){\n            if(distanceSP(e[i], c.p) <= r){\n                isC = true;\n            }\n        }\n        if(isC){\n            cout << \"c\" << endl;\n        }else{\n            cout << \"d\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\n\nclass Point {\npublic:\n\tdouble x, y;\n\n\tPoint() {\n\t\tx = y = 0;\n\t}\n};\n\nPoint Circle, Triangle[3];\ndouble Radius, ShortestDist[3], DistanceOfPointToPoint[3];\nbool isCirclePointInsideTriangleFlag;\n\n\nbool isCirclePointInsideTriangle() {\n\tPoint vecMA, vecMB, vecMC;\n\tdouble a, b, c;\n\n\tvecMA.x = Circle.x - Triangle[0].x;\n\tvecMA.y = Circle.y - Triangle[0].y;\n\tvecMB.x = Circle.x - Triangle[1].x;\n\tvecMB.y = Circle.y - Triangle[1].y;\n\tvecMC.x = Circle.x - Triangle[2].x;\n\tvecMC.y = Circle.y - Triangle[2].y;\n\n\ta = vecMA.x * vecMB.y - vecMA.y * vecMB.x;\n\tb = vecMB.x * vecMC.y - vecMB.y * vecMC.x;\n\tc = vecMC.x * vecMA.y - vecMC.y * vecMA.x;\n\n\tif ((a <= 0 && b <= 0 && c <= 0) || (a >= 0 && b >= 0 && c >= 0)) {\n\t\treturn true;\n\t}\t\n\treturn false;\n}\n\n//distanceOfp1Top2\ndouble calculationDistanceByPointToPoint(const Point& p1, const Point&p2) {\n\treturn sqrt((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));\n}\n\nbool bothLess90Degree(const Point &a, const Point &b, const Point &c)\n{\n\treturn ((a.x - b.x)*(c.x - b.x) + (a.y - b.y)*(c.y - b.y)) > 0;\n}\n\n//distanceOfp1ToLine(p2,p3)\ndouble calculationDistanceByPointToLine(const Point& p1, const Point&p2, const Point&p3) {\n\tdouble k, b;\n\n\tif (bothLess90Degree(p1, p2, p3) && bothLess90Degree(p1, p3, p2)) {\n\t\tif (p2.x == p3.x) {\n\t\t\treturn fabs(p1.x - p2.x);\n\t\t}\n\n\t\tk = (p3.y - p2.y) / (p3.x - p2.x);\n\t\tb = p2.y - k * p2.x;\n\n\t\treturn ((fabs(k*p1.x - p1.y + b)) / sqrt(k*k + 1));\n\t}\n\n\treturn min(calculationDistanceByPointToPoint(p1, p2), calculationDistanceByPointToPoint(p1, p3));\n}\n\nbool isB() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (DistanceOfPointToPoint[i] > Radius) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool isA() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (ShortestDist[i] < Radius) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (isCirclePointInsideTriangleFlag) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool isD() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tif (ShortestDist[i] < Radius) {\n\t\t\treturn false;\n\t\t}\n\t\tif (fabs(ShortestDist[i] - Radius) < 1e-10) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (isCirclePointInsideTriangleFlag) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid solve() {\n\n\t//distanceOfCirclePointToTrianglePoint\n\tfor (int i = 0; i < 3; i++) {\n\t\tDistanceOfPointToPoint[i] = calculationDistanceByPointToPoint(Circle,Triangle[i]);\n\t}\n\tif ( isB() ) {\n\t\tcout << \"b\" << endl;\n\t\treturn;\n\t}\n\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tShortestDist[i] = calculationDistanceByPointToLine(Circle, Triangle[i], Triangle[(i+1)%3]);\n\t}\n\tif( isA() ){\n\t\tcout << \"a\" << endl;\n\t\treturn;\n\t}\n\tif (isD()) {\n\t\tcout << \"d\" << endl;\n\t\treturn;\n\t}\n\n\tcout << \"c\" << endl;\n}\n\n\nint main() {\n\n\twhile (true) {\n\t\tcin >> Triangle[0].x >> Triangle[0].y;\n\t\tif (Triangle[0].x == 0 && Triangle[0].y == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i < 3; i++) {\n\t\t\tcin >> Triangle[i].x >> Triangle[i].y;\n\t\t}\n\t\tcin >> Circle.x >> Circle.y >> Radius;\n\n\t\tisCirclePointInsideTriangleFlag = isCirclePointInsideTriangle();\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\ndouble sign(double r) { return r < -EPS ? -1.0 : r > EPS ? 1.0 : 0.0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0.0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) <= 0.0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n\n// code for problem\nint x, y, r;\nvector<P> T;\nC cc;\n\nbool isPinC() {\n\tP e0 = T[0] - cc.p;\n\tP e1 = T[1] - cc.p;\n\tP e2 = T[2] - cc.p;\n\tdouble d0 = e0.det(e1);\n\tdouble d1 = e1.det(e2);\n\tdouble d2 = e2.det(e0);\n\tif(d0 * d1 >= 0.0 && d1 * d2 >= 0.0 && d2 * d0 >= 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\tvector<double> d(3);\n\td[0] = (T[0] - cc.p).norm();\n\td[1] = (T[1] - cc.p).norm();\n\td[2] = (T[2] - cc.p).norm();\n\tif(sign(d[0] - cc.r) <= 0.0 && sign(d[1] - cc.r) <= 0.0 && sign(d[2] - cc.r) <= 0.0) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\tbool in = isPinC();\n\tL l0(T[0], T[1]);\n\tL l1(T[1], T[2]);\n\tL l2(T[2], T[0]);\n\td[0] = l0.dSP(cc.p);\n\td[1] = l1.dSP(cc.p);\n\td[2] = l2.dSP(cc.p);\n\tif(in && sign(d[0] - cc.r) >= 0.0 && sign(d[1] - cc.r) >= 0.0 && sign(d[2] - cc.r) >= 0.0) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(!in && sign(d[0] - cc.r) > 0.0) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\tT = vector<P>(3);\n\tfor(;;) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\tT[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}\n        "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>     // fabs(), hypot()\n#include<vector>    // Circle::crosspoint()の戻り値\nusing namespace std;\n\nconst double EPS = 0.0;\nenum POSITION {FORWARD = -2, UNDER, ON, ABOVE, BACKWARD};   // ccw(a, b, p)で3点a, b, pの位置関係を返す\n                                                            //   0: a-p-b, 2: p-a-b, -2: a-b-p, 1: -a-b-の上にp, -1: -a-b-の下にp\n// class\nclass Point;\nclass Segment;\nclass Line;\nclass Circle;\n// member\nclass Point {\n    double x_value, y_value;\npublic:\n    Point() :x_value(0.0), y_value(0.0) {}\n    Point(double d) :x_value(d), y_value(d) {}\n    Point(double a, double b) :x_value(a), y_value(b) {}\n    double x() const {return x_value;}\n    double y() const {return y_value;}\n    double x(double d) {return x_value = d;}\n    double y(double d) {return y_value = d;}\n    bool operator== (const Point&) const;\n    bool operator!= (const Point&) const;\n    bool operator< (const Point&) const;\n    bool operator> (const Point&) const;\n    bool operator<= (const Point&) const;\n    bool operator>= (const Point&) const;\n    const Point operator-() const;\n    const Point& operator=(const Point&);\n    const Point& operator+=(const Point&);\n    const Point& operator-=(const Point&);\n    const Point& operator*=(const Point&);\n    const Point& operator/=(const Point&);\n    double dot(const Point&) const;\n    double cross(const Point&) const;\n    double abs() const;\n    double norm() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Line&) const;\n    const Point reflection(const Line&) const;\n    POSITION ccw(const Point&, const Point&) const;\n};\nconst Point operator+(const Point& lhs, const Point& rhs);\nconst Point operator-(const Point& lhs, const Point& rhs);\nconst Point operator*(const Point& lhs, const Point& rhs);\nconst Point operator/(const Point& lhs, const Point& rhs);\nclass Segment {\n    Point source_point, target_point;\npublic:\n    Segment(const Point& a = Point(),const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Line line() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Line {\n    Point source_point, target_point;\npublic:\n    Line(const Point& a = Point(), const Point& b = Point()) :source_point(a), target_point(b) {}\n    const Point& source() const {return source_point;}\n    const Point& target() const {return target_point;}\n    const Point& source(const Point& p) {return source_point = p;}\n    const Point& target(const Point& p) {return target_point = p;}\n    const Segment segment() const;\n    double distance(const Point&) const;\n    double distance(const Segment&) const;\n    double distance(const Line&) const;\n    bool intersect(const Point&) const;\n    bool intersect(const Segment&) const;\n    bool intersect(const Line&) const;\n    const Point projection(const Point&) const;\n    const Point reflection(const Point&) const;\n    const Point crosspoint(const Line&) const;\n    POSITION ccw(const Point&) const;\n};\nclass Circle {\n    Point center_point;\n    double radius;\npublic:\n    Circle(double a = 0.0, double b = 0.0, double c = 0.0) :center_point(Point(a, b)), radius(c) {}\n    const Point& center() const {return center_point;}\n    double x() const {return center_point.x();}\n    double y() const {return center_point.y();}\n    double r() const {return radius;}\n    const Point& center(const Point& p) {return center_point = p;}\n    double x(double d) {return center_point.x(d);}\n    double y(double d) {return center_point.y(d);}\n    double r(double d) {return radius = d;}\n    bool include(const Point&) const;\n    bool include(const Circle&) const;\n    bool intersect(const Circle&) const;\n    vector<Point> crosspoint(const Circle&) const;\n};\n// Point\nbool Point::operator== (const Point &p) const {return x() == p.x() && y() == p.y();}\nbool Point::operator!= (const Point &p) const {return x() != p.x() || y() != p.y();}\nbool Point::operator<(const Point &p) const {return x() != p.x() ? x() < p.x() : y() < p.y();}\nbool Point::operator>(const Point &p) const {return x() != p.x() ? x() > p.x() : y() > p.y();}\nbool Point::operator<=(const Point &p) const {return x() != p.x() ? x() < p.x() : y() <= p.y();}\nbool Point::operator>=(const Point &p) const {return x() != p.x() ? x() > p.x() : y() >= p.y();}\nconst Point operator+(const Point& lhs, const Point& rhs) {return Point(lhs.x() + rhs.x(), lhs.y() + rhs.y());}\nconst Point operator-(const Point& lhs, const Point& rhs) {return Point(lhs.x() - rhs.x(), lhs.y() - rhs.y());}\nconst Point operator*(const Point& lhs, const Point& rhs) {return Point(lhs.x() * rhs.x(), lhs.y() * rhs.y());}\nconst Point operator/(const Point& lhs, const Point& rhs) {return Point(lhs.x() / rhs.x(), lhs.y() / rhs.y());}\nconst Point Point::operator-() const {return Point(-x(), -y());}\nconst Point& Point::operator=(const Point& p) {x(p.x()); y(p.y()); return *this;}\nconst Point& Point::operator+=(const Point& p) {return *this = *this + p;}\nconst Point& Point::operator-=(const Point& p) {return *this = *this - p;}\nconst Point& Point::operator*=(const Point& p) {return *this = *this * p;}\nconst Point& Point::operator/=(const Point& p) {return *this = *this / p;}\ndouble Point::dot(const Point& p) const {return x() * p.x() + y() * p.y();}\ndouble Point::cross(const Point& p) const {return x() * p.y() - y() * p.x();}\ndouble Point::abs() const {return hypot(x(), y());}\ndouble Point::norm() const {return x() * x() + y() * y();}\ndouble Point::distance(const Point& p) const {return (p - (*this)).abs();}\ndouble Point::distance(const Segment& s) const {return s.distance(*this);}\ndouble Point::distance(const Line& l) const {return l.distance(*this);}\nbool Point::intersect(const Point& p) const {return *this == p;}\nbool Point::intersect(const Segment& s) const {return s.intersect(*this);}\nbool Point::intersect(const Line& l) const {return l.intersect(*this);}\nconst Point Point::projection(const Line& l) const {return l.projection(*this);}\nconst Point Point::reflection(const Line& l) const {return l.reflection(*this);}\nPOSITION Point::ccw(const Point& b, const Point& p) const {\n    const Point& a = *this;\n    Point v1 = b - a;\n    Point v2 = p - a;\n    if(v1.cross(v2) > EPS) return ABOVE;\n    if(v1.cross(v2) < -EPS) return UNDER;\n    if(v1.dot(v2) < -EPS) return BACKWARD;\n    if(v2.norm() - v1.norm() > EPS) return FORWARD;\n    return ON;\n}\n// Segment\nconst Line Segment::line() const {return Line(source(), target());}\ndouble Segment::distance(const Point& p) const {\n    Point q = line().projection(p);\n    if(intersect(q)) return q.distance(p);\n    double a = source().distance(p);\n    double b = target().distance(p);\n    return a < b ? a : b;\n}\ndouble Segment::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    double c = s.distance(source());\n    double d = s.distance(target());\n    a = a < b ? a : b;\n    a = a < c ? a : c;\n    return a < d ? a : d;\n}\ndouble Segment::distance(const Line& l) const {return l.distance(*this);}\nbool Segment::intersect(const Point& p) const {\n    return fabs(source().distance(p) + target().distance(p) - target().distance(source())) <= EPS;\n}\nbool Segment::intersect(const Segment& s) const {\n    bool a = ccw(s.source()) * ccw(s.target()) <= 0;\n    bool b = s.ccw(source()) * s.ccw(target()) <= 0;\n    return a && b;\n}\nbool Segment::intersect(const Line& l) const {return l.intersect(*this);}\nPOSITION Segment::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Line\nconst Segment Line::segment() const {return Segment(source(), target());}\ndouble Line::distance(const Point& p) const {return p.distance(projection(p));}\ndouble Line::distance(const Segment& s) const {\n    if(intersect(s)) return 0.0;\n    double a = distance(s.source());\n    double b = distance(s.target());\n    return a < b ? a : b;\n}\ndouble Line::distance(const Line& l) const {return intersect(l) ? 0.0 : distance(l.source());}\nbool Line::intersect(const Point& p) const {\n    Point v1 = source() - p;\n    Point v2 = target() - p;\n    return fabs(v2.cross(v1)) < EPS;\n}\nbool Line::intersect(const Segment& s) const {\n    Point v1 = target() - source();\n    Point v2 = s.source() - source();\n    Point v3 = s.target() - source();\n    return v1.cross(v2) * v1.cross(v3) <= EPS;\n}\nbool Line::intersect(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = l.source() - source();\n    return fabs(v1.cross(v2)) > EPS || fabs(v1.cross(v3)) < EPS;\n}\nconst Point Line::projection(const Point& p) const {\n    Point v1 = p - source();\n    Point v2 = source() - target();\n    return Point(source() + (v1.dot(v2) / v2.norm()) * v2);\n}\nconst Point Line::reflection(const Point& p) const {\n    return p + (projection(p) - p) * 2.0;\n}\nconst Point Line::crosspoint(const Line& l) const {\n    Point v1 = target() - source();\n    Point v2 = l.target() - l.source();\n    Point v3 = target() - l.source();\n    double a = v1.cross(v2);\n    double b = v1.cross(v3);\n    if(fabs(a) <= EPS && fabs(b) <= EPS) l.source();\n    return l.source() + v2 * (b / a);\n}\nPOSITION Line::ccw(const Point& p) const {return source().ccw(target(), p);}\n// Circle\nbool Circle::include(const Point& p) const {return center().distance(p) - r() <= EPS;}\nbool Circle::include(const Circle& c) const {return center().distance(c.center()) - (r() - c.r()) <= EPS;}\nbool Circle::intersect(const Circle& c) const {return center().distance(c.center()) - r() - c.r() <= EPS;}\nvector<Point> Circle::crosspoint(const Circle& c) const {\n    double angle = atan2(c.y() - y(), c.x() - x());\n    double d = center().distance(c.center());\n    double add = acos((d * d + r() * r() - c.r() * c.r()) / (2.0 * d * r()));\n    vector<Point> result;\n    result.push_back(Point(x() + r() * cos(angle + add), y() + r() * sin(angle + add)));\n    result.push_back(Point(x() + r() * cos(angle - add), y() + r() * sin(angle - add)));\n    return result;\n}\n\nstring check(vector<Point>& triangle, Circle& circle) {\n    vector<Segment> edge;\n    for(int i = 0; i < 3; ++i) edge.push_back(Segment(triangle[i], triangle[(i + 1) % 3]));\n\n    // 3頂点すべてが円の内部\n    bool triangleInCircle = true;\n    for(auto& p: triangle) if(!circle.include(p)) triangleInCircle = false;\n    if(triangleInCircle) return \"b\";\n\n    // ある辺が円と交わる\n    int edgesOutOfCircle = 0;\n    for(auto& e: edge) {\n        if(circle.center().distance(e) - circle.r() > EPS) ++edgesOutOfCircle;\n    }\n    if(edgesOutOfCircle != 3) return \"c\";\n\n    // 円の中心が三角形の内部\n    int cw = 0, ccw = 0;\n    for(auto& e: edge) {\n        if(e.ccw(circle.center()) >= 0) ++ccw;\n        if(e.ccw(circle.center()) <= 0) ++cw;\n    }\n    if(cw == 3 || ccw == 3) return \"a\";\n\n    return \"d\";\n}\n\nint main() {\n    double x[4], y[4], r;\n    while(cin >> x[0] >> y[0], x[0] + y[0]) {\n        cin >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3] >> r;\n        vector<Point> triangle = {\n            Point(x[0], y[0]),\n            Point(x[1], y[1]),\n            Point(x[2], y[2]),\n        };\n        Circle circle(x[3], y[3], r);\n        cout << check(triangle, circle) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) {\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nint ccw(P a, P b, P c) {\n  b = vec(a,b); c = vec(a,c);\n  if(sgn(outp(b,c),0.0) > 0) return +1;\n  if(sgn(outp(b,c),0.0) < 0) return -1;\n  if(sgn(inp(b,c),0.0) < 0)  return +2;\n  if(sgn(abs(b),abs(c)) < 0) return -2;\n  return 0;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nbool iSP(L s, P p) {\n    return ccw(s.a, s.b, p) == 0;\n}\nD dSP(L s, P p) {\n  P r = proj(s, p);\n  if(iSP(s, r)) return abs(p - r); // 写像がs上にある\n  return min(abs(p - s.a), abs(p - s.b)); // 写像がs上にない\n}\nint containsGP(vector<P> g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(g[i], g[(i+1)%g.size()], p) == 0) return 0;\n    P a = vec(p, g[i]);\n    P b = vec(p, g[(i+1)%g.size()]);\n    if(a.y > b.y) swap(a, b);\n    if(sgn(a.y, 0.0) <= 0 && sgn(b.y, 0.0) > 0 && sgn(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\nint iCS(C c, L s) {\n  if(sgn(abs(c.p - s.a), c.r) <= 0 && sgn(abs(c.p - s.b), c.r) <= 0)\n    return -2;\n  if(sgn(abs(c.p - s.a), c.r) <= 0 || sgn(abs(c.p - s.b), c.r) <= 0)\n    return -1;\n  if(sgn(dLP(s, c.p), c.r) < 0)\n    return +2;\n  if(sgn(dLP(s, c.p), c.r) == 0)\n    return +1;\n  return 0;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    // a\n    if(containsGP(tri, cir.p) >= 0 &&\n       sgn(cir.r, dSP(L(tri[0], tri[1]), cir.p)) <= 0 &&\n       sgn(cir.r, dSP(L(tri[1], tri[2]), cir.p)) <= 0 &&\n       sgn(cir.r, dSP(L(tri[2], tri[0]), cir.p)) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(iCS(cir, L(tri[0], tri[1])) == 0 &&\n       iCS(cir, L(tri[1], tri[2])) == 0 &&\n       iCS(cir, L(tri[2], tri[0])) == 0) {\n      cout << \"d\" << endl;\n      continue;\n    }\n    cout << \"c\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#define PI 3.141592653589\nusing namespace std;\n\ndouble x[3],y[3],rx,ry,r;\n\nint trgin() {\n\tint i,k;\n\tdouble a,b,c,d=0;\n\tfor (i=0; i<3; i++) {\n\t k=(i+1) % 3;\n\t a=sqrt((x[i]-x[k])*(x[i]-x[k])+(y[i]-y[k])*(y[i]-y[k]));\n\t b=sqrt((x[i]-rx)*(x[i]-rx)+(y[i]-ry)*(y[i]-ry));\n\t c=sqrt((x[k]-rx)*(x[k]-rx)+(y[k]-ry)*(y[k]-ry));\n     d=d+acos((b*b+c*c-a*a)/(2*b*c));\n\t}\n\tif ((d-PI*2)<0.000001 && (d-PI*2)>-0.000001) return 1;\n\treturn 0;\n}\nint line(double x1,double y1,double x2,double y2) {\n    double x,y,m,d;\n\tif (y1==y2) { x=rx;y=y1;} else if (x1==x2) { x=x1;y=ry;}\n\telse {\n    m=(y2-y1)/(x2-x1);\n\tx=(ry-y1+m*x1+rx/m)/(m+1/m);\n\ty=y1+m*(x-x1);\n\t}\n\td=(rx-x)*(rx-x)+(ry-y)*(ry-y);\n    if (d==r*r) return 1; else if (d<r*r) return 2;\n\treturn 0;\n}\nint main() {\n\tint i,j,k,f;\n\twhile(true) {\n\t\tfor (i=0;i<3;i++) {\n\t\tcin >> x[i] >> y[i];\n\t\tif (x[i]==0) break;\n\t}\n    if (i!=3) break;\n\tcin >> rx >> ry >> r;\n    for (i=0;i<3;i++) if ((x[i]-rx)*(x[i]-rx)+(y[i]-ry)*(y[i]-ry)>r*r) break;\n\tif (i==3) { cout << 'b' << endl; continue;}\n\tfor (i=0,f=0,k=0;i<3;i++) {\n\t\tj=line(x[i],y[i],x[(i+1) % 3],y[(i+1) % 3]); k+=j;\n\t\tif (j>1) break;\n\t}\n\tif (i==3) if (trgin()==1) { cout << 'a' << endl; continue;} else if (k==0) {cout << 'd' << endl; continue;}\n\tcout << 'c' << endl;\n\t}\nreturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; double r;\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint convex_contains(const G &gg, const P &p) {\n    const int n = gg.size();\n    P g = (gg[0] + gg[n/3] + gg[2*n/3]) / 3.0; // inner-point\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n        int c = (a + b) / 2;\n        if (cross(gg[a]-g, gg[c]-g) > 0) { // angle < 180 deg\n            if (cross(gg[a]-g, p-g) > 0 && cross(gg[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(gg[a]-g, p-g) < 0 && cross(gg[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(gg[a] - p, gg[b] - p) < 0) return false;\n    if (cross(gg[a] - p, gg[b] - p) > 0) return true;\n    return false;\n}\n\nint main(){\n    double x, y;\n    while(cin >> x >> y, x+y){\n        G g;\n        g.push_back(P(x, y));\n        for(int i=0; i< 2; i++){\n            cin >> x >> y;\n            g.push_back(P(x, y));\n        }\n        cin >> x >> y;\n        double r;\n        cin >> r;\n        C c(P(x, y), r);\n        if(convex_contains(g, c.p)){\n            bool a = true;\n            for(int i=0; i< 3; i++){\n                L l(g[i], g[(i+1)%3]);\n                if(!(distanceLP(l, c.p)-c.r > EPS)) a = false;\n            }\n            if(a) cout << \"a\" << endl;\n            else cout << \"c\" << endl;\n        }\n        else {\n            bool b = true;\n            for(int i=0; i< 3; i++){\n                if(!(c.r-abs(g[i]-c.p) > EPS)) b = false;\n            }\n            if(b) cout << \"b\" << endl;\n            else cout << \"d\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n// ------ Classes ------ //\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tfriend bool operator==(const Point& p1, const Point& p2) { return p1.px == p2.px && p1.py == p2.py; }\n\tfriend bool operator!=(const Point& p1, const Point& p2) { return p1.px != p2.px || p1.py != p2.py; }\n\tfriend bool operator<(const Point& p1, const Point& p2) { return p1.px < p2.px ? true : (p1.px == p2.px && p1.py < p2.py); }\n\tfriend bool operator>(const Point& p1, const Point& p2) { return p1.px > p2.px ? true : (p1.px == p2.px && p1.py > p2.py); }\n\tfriend bool operator<=(const Point& p1, const Point& p2) { return !(p1 > p2); }\n\tfriend bool operator>=(const Point& p1, const Point& p2) { return !(p1 < p2); }\n\tfriend Point operator+(const Point& p1, const Point& p2) { return Point(p1.px + p2.px, p1.py + p2.py); }\n\tfriend Point operator-(const Point& p1, const Point& p2) { return Point(p1.px - p2.px, p1.py - p2.py); }\n\tfriend Point operator*(const Point& p1, long double d) { return Point(p1.px * d, p1.py + d); }\n\tfriend Point operator*(long double d, const Point& p1) { return p1 * d; }\n\tfriend Point operator/(const Point& p1, long double d) { return Point(p1.px / d, p1.py / d); }\n\tPoint& operator+=(const Point& p1) { px += p1.px; py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px; py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d; py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d; py /= d; return *this; }\n};\nclass Segment {\npublic:\n\tPoint p1, p2;\n\tSegment() : p1(Point()), p2(Point()) {};\n\tSegment(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tSegment(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tfriend bool operator==(const Segment& s1, const Segment& s2) { return (s1.p1 == s2.p1 && s1.p2 == s2.p2) || (s1.p1 == s2.p2 && s1.p2 == s2.p1); }\n\tfriend bool operator!=(const Segment& s1, const Segment& s2) { return !(s1 == s2); }\n};\n// ------ Functions ------ //\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nPoint pol(long double r, long double d) { return Point(cosl(d) * r, sinl(d) * r); }\nint ccw(Point p0, Point p1, Point p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nlong double dst(const Point& a, const Point& b) {\n\treturn sqrtl((a.px - b.px) * (a.px - b.px) + (a.py - b.py) * (a.py - b.py));\n}\nlong double dst(const Segment& a, const Point& b) {\n\tif (dot(a.p2 - a.p1, b - a.p1) < 0.0) return abs(b - a.p1);\n\tif (dot(a.p1 - a.p2, b - a.p2) < 0.0) return abs(b - a.p2);\n\treturn abs(crs(a.p2 - a.p1, b - a.p1) / abs(a.p2 - a.p1));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 0 && 0 < b.py)\n\t\t\tif (crs(a, b) < -1e-10) in = !in;\n\t\tif (-1e-10 < crs(a, b) && crs(a, b) < 1e-10 && dot(a, b) < 1e-10) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n// ------ Main ------ //\nPoint p1, p2, p3, p; long double r; Segment l1, l2, l3;\nint main() {\n\twhile(cin >> p1.px >> p1.py >> p2.px >> p2.py >> p3.px >> p3.py >> p.px >> p.py >> r) {\n\t\tl1 = Segment(p1, p2);\n\t\tl2 = Segment(p2, p3);\n\t\tl3 = Segment(p3, p1);\n\t\tif(dst(p1, p) <= r + 1e-10 && dst(p2, p) <= r + 1e-10 && dst(p3, p) <= r + 1e-10) printf(\"b\\n\");\n\t\telse if(dst(l1, p) >= r - 1e-10 && dst(l2, p) >= r - 1e-10 && dst(l3, p) >= r - 1e-10) printf(contain({p1, p2, p3}, p) ? \"a\\n\" : \"d\\n\");\n\t\telse printf(\"c\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n    if(rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS * len) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\n//多角形の面積\ntemplate<class T>\nT area(const vector<point<T> >& v){\n\tT ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S,const point<T> &p){ return sqrt(dist2(S,p)); }\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ntemplate<class T>\ndouble geodist(point<T> a,point<T> b,const circle<T> &C){\n\tdouble r=C.r;\n\tsegment<T> s(a,b);\n\tif(dist(s,C.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=C.c;\n\tb-=C.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntemplate<class T>\nstd::istream& operator>>(std::istream& is, point<T>& point){return ( is >> point.x >> point.y );}\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n\n//円の接点\nvector<P> GetContact(const P& p,const P& q,const double r){\n\tP a = p-q;\n\tdouble s = SQ(a.x) + SQ(a.y);\n\tdouble D = sqrt(s - SQ(r));\n\tdouble dx = r * D * a.y / s;\n\tdouble dy = r * D * a.x / s;\n\tdouble bx = SQ(r) * a.x / s;\n\tdouble by = SQ(r) * a.y / s;\n\tvector<P> ans(2);\n\tans[0].x = bx + dx;\n\tans[0].y = by - dy;\n\tans[1].x = bx - dx;\n\tans[1].y = by + dy;\n\n\tans[0] += q;\n\tans[1] += q;\n\n\treturn ans;\n}\n\n//todo : verifyしてないので、そのうち。\n// 円が交差しているか 「=」は問によって変更する\ntemplate<class T>\nint CircleCross(const circle<T> &c1,const circle<T> &c2){\n\tdouble l = abs(c1.c - c2.c);\n\tif(l >= c1.r + c2.r) return 3; //外部にある\n\tif(l + c1.r <= c2.r) return 2; //c1 ⊃ c2\n\tif(l + c2.r <= c1.r) return 1; //c1 ⊂ c2\n\treturn 0; //交差している\n}\n\n\ntypedef pair<P,P> PD;\n//円同士の交点\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\n\n//三角形の中にあるか\nbool InTri(const P p[3],const P& o){\n\treturn \n\t\t(ccw(p[0],p[1],p[2]) == ccw(p[0],p[1],o)) &&\n\t\t(ccw(p[1],p[2],p[0]) == ccw(p[1],p[2],o)) &&\n\t\t(ccw(p[2],p[0],p[1]) == ccw(p[2],p[0],o));\n}\n\n\nint main(){\n\tP p[3];\n\tC c;\n\twhile(cin>>p[0],p[0].x != 0 || p[0].y != 0){\n\t\tcin>>p[1]>>p[2];\n\t\tcin>>c.c>>c.r;\n\t\tbool ok = true;\n\t\tFOR(i,3){\n\t\t\tif(abs(p[i]-c.c) >= c.r) ok = false;\n\t\t}\n\n\t\t//in-circle\n\t\tif(ok){ puts(\"b\"); continue; }\n\n\t\tFOR(i,3){\n\t\t\tdouble l = dist(S(p[i],p[(i+1)%3]),c.c);\n\t\t\tif(l <= c.r) ok = true;\n\t\t}\n\n\t\t//intersect\n\t\tif(ok){ puts(\"c\"); continue; }\n\n\t\tif(InTri(p,c.c))\n\t\t\tputs(\"a\"); //in-triangle\n\t\telse\n\t\t\tputs(\"d\"); //otherwise\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cfloat>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct circle{ point p; double r; };\n\ndouble dot(point a, point b) { return (a.x * b.x + a.y * b.y); }\n\ndouble cross(point a, point b) { return (a.x * b.y - a.y * b.x); }\n\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint is_point_on_line(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1 + (a2 - a1) * (cross(b2 - b1,b1 - a1) / cross(b2 - b1,a2 - a1));\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n\n  if(cross(a1-a2,b1-b2)==0){\n    return is_point_on_line(a1,a2,b1) || is_point_on_line(a1,a2,b2) \n        || is_point_on_line(b1,b2,a1) || is_point_on_line(b1,b2,a2);\n  }\n  else {\n    point r=intersection_l(a1,a2,b1,b2);\n    return is_point_on_line(a1,a2,r) && is_point_on_line(b1,b2,r);\n  }\n\n}\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint inside(point p, vector<point> ps, int n){\n  point a,b;\n  a=b=p;\n  b.x=1000000;\n  ps.push_back(ps[0]);\n  double ymx=-DBL_MAX,ymn=DBL_MAX;\n  for(int i=0;i<n;i++){\n    ymx=max(ymx,ps[i].y);\n    ymn=min(ymn,ps[i].y);\n  }\n  if(a.y<=ymn||a.y>=ymx)return 0;\n\n  for(int i=0;i<n;i++){\n    if(is_point_on_line(ps[i],ps[i+1],p))return 1;\n  }\n  \n  int cnt1=0;\n  for(int i=0;i<n;i++)\n    if(is_point_on_line(a,b,ps[i]))cnt1++;\n\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(is_intersected_ls(ps[i],ps[i+1],a,b))cnt++;\n    \n  return (cnt-cnt1)%2;\n}\n\nint crossCP(vector<point> t, circle C){\n\n  double ans=0;\n  int tsz=t.size();\n\n  for(int i=0;i<tsz;i++){\n    double tmp=dist(t[i],C.p);\n    if(tmp>ans)ans=tmp;\n  }\n\n  if(C.r>=ans)return 2;\n\n  int res1=inside(C.p,t,tsz);\n  double res2=DBL_MAX;\n\n  t.push_back(t[0]);\n\n  for(int i=0;i<tsz;i++)\n    res2=min(res2,distance_ls_p(t[i],t[i+1],C.p));\n\n  if(res1 && C.r<=res2)return 1;\n  else if(!res1 && C.r<res2)return 4;\n  else return 3;\n}\n\nint main(void){\n  point p;\n  vector<point> t;\n  circle C;\n  string ans=\"zabcd\";\n\n  while(true){\n    t.clear();\n    for(int i=0;i<3;i++){\n      cin >> p.x >> p.y;\n      if(p.x==0 && p.y==0)return 0;\n      t.push_back(p);\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    int res=crossCP(t,C);\n    cout << ans[res] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\ntypedef double D;\nconst D EPS = 1e-8;\nconst D PI = M_PI;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P st, P en) { return en - st; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD abs(P p) { return sqrt(inp(p,p)); }\nint sgn(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\nP proj(L l, P p) {\n  P a = vec(l.a,l.b);\n  P b = vec(l.a,p);\n  D t = inp(a,b)/abs(a);\n  return l.a + (a/abs(a))*t;\n}\nD dLP(L l, P p) {\n    return abs(p - proj(l, p));\n}\nint ccw(P a, P b, P c) {\n  b = vec(a,b); c = vec(a,c);\n  if(sgn(outp(b,c),0.0) > 0) return +1;\n  if(sgn(outp(b,c),0.0) < 0) return -1;\n  if(sgn(inp(b,c),0.0) < 0)  return +2;\n  if(sgn(abs(b),abs(c)) < 0) return -2;\n  return 0;\n}\nbool in_triangle(vector<P> g, P p) {\n  double a = 0.0, b = 0.0;\n  REP(i,3) {\n    a += abs(outp(g[i] - p, g[(i+1)%3] - p));\n    b += outp(g[i], g[(i+1)%3]);\n  }\n  return sgn(abs(a), abs(b)) == 0;\n}\nint iCS(C c, L s) {\n  if(sgn(abs(c.p - s.a), c.r) <= 0 && sgn(abs(c.p - s.b), c.r) <= 0)\n    return -2;\n  if(sgn(abs(c.p - s.a), c.r) <= 0 || sgn(abs(c.p - s.b), c.r) <= 0)\n    return -1;\n  if(sgn(dLP(s, c.p), c.r) < 0)\n    return +2;\n  if(sgn(dLP(s, c.p), c.r) == 0)\n    return +1;\n  return 0;\n}\nint main() {\n  while(true) {\n    int x, y;\n    vector<P> tri;\n    cin >> x >> y;\n    if(x == 0 && y == 0) break;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    cin >> x >> y;\n    tri.emplace_back(x, y);\n    C cir;\n    cin >> cir.p.x >> cir.p.y >> cir.r;\n    // cerr << \"circle(\" << cir.p.x << \",\" << cir.p.y << \",\" << cir.r << \");\" << endl;\n    // cerr << \"line(\" << tri[0].x << \",\" << tri[0].y << \",\" << tri[1].x << \",\" << tri[1].y << \");\" << endl;\n    // cerr << \"line(\" << tri[1].x << \",\" << tri[1].y << \",\" << tri[2].x << \",\" << tri[2].y << \");\" << endl;\n    // cerr << \"line(\" << tri[2].x << \",\" << tri[2].y << \",\" << tri[0].x << \",\" << tri[0].y << \");\" << endl;\n    // b\n    if(sgn(abs(vec(cir.p, tri[0])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[1])), cir.r) <= 0 &&\n       sgn(abs(vec(cir.p, tri[2])), cir.r) <= 0) {\n      cout << \"b\" << endl;\n      continue;\n    }\n    // a\n    if(in_triangle(tri, cir.p) &&\n       sgn(cir.r, dLP(L(tri[0], tri[1]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[1], tri[2]), cir.p)) <= 0 &&\n       sgn(cir.r, dLP(L(tri[2], tri[0]), cir.p)) <= 0) {\n      cout << \"a\" << endl;\n      continue;\n    }\n    if(iCS(cir, L(tri[0], tri[1])) == 0 &&\n       iCS(cir, L(tri[1], tri[2])) == 0 &&\n       iCS(cir, L(tri[2], tri[0])) == 0) {\n      cout << \"d\" << endl;\n      continue;\n    }\n    cout << \"c\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//objects-----------------------------------------------------------------\ntypedef complex<double>Point;\ntypedef Point Vector;\ntypedef vector<Point>Polygon;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Line{\n    Point p1,p2;\n    Line(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\n//constants---------------------------------------------------------------\nconst double PI=acos(-1);\nconst double EPS=1e-12;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\nconst int IN=2;\nconst int ON=1;\nconst int OUT=0;\n//calculations------------------------------------------------------------\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\ninline double arg(Vector p){return atan2(imag(p),real(p));}\ninline Vector polar(double a,double r){return Vector(cos(r),sin(r))*a;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define equalsv(a,b) (equals(real(a),real(b))&&equals(imag(a),imag(b)))\n#define curr(P,i) P[(i)%P.size()]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i-1+P.size())%P.size()]\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n//inputer-----------------------------------------------------------------\nvoid inputPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid inputSegment(Segment &s){\n    inputPoint(s.p1);\n    inputPoint(s.p2);\n}\n\nvoid inputLine(Line &l){\n    inputPoint(l.p1);\n    inputPoint(l.p2);\n}\n\nvoid inputCircle(Circle &c){\n    inputPoint(c.p);\n    scanf(\"%lf\",&c.r);\n}\n\nvoid inputPolygon(Polygon &g,int n){\n    g.resize(n);\n    for(int i=0;i<n;i++)inputPoint(g[i]);\n}\n\n//orthogonal--------------------------------------------------------------\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool orthogonal(Line l1,Line l2){\n    return orthogonal(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//parallel----------------------------------------------------------------\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Line l1,Line l2){\n    return parallel(l1.p1-l1.p2,l2.p1-l2.p2);\n}\n\n//project&reflect---------------------------------------------------------\nPoint project(Line s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Line s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\n//distance----------------------------------------------------------------\ndouble distancePP(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble distanceLP(Line l,Point p){\n    return fabs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble distanceLL(Line l,Line m){\n    if(parallel(l,m))return distanceLP(l,m.p1);\n    return 0.0;\n}\n\ndouble distanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0)return distancePP(p,s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0)return distancePP(p,s.p2);\n    return distanceLP(Line(s.p1,s.p2),p);\n}\n\ndouble distanceSS(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)*ccw(s1.p1,s1.p2,s2.p2)<=0&&\n        ccw(s2.p1,s2.p2,s1.p1)*ccw(s2.p1,s2.p2,s1.p2)<=0)return 0;\n    return min(min(distanceSP(s1,s2.p1),distanceSP(s1,s2.p2)),\n            min(distanceSP(s2,s1.p1),distanceSP(s2,s1.p2)));\n}\n\ndouble distanceCS(Circle c,Segment s){\n    return distanceSP(s,c.p)-c.r;\n}\n\n//intersect----------------------------------------------------------------\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersectSS(Segment s1,Segment s2){\n    return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectCL(Circle c,Line l){\n    return fabs(cross(l.p2-l.p1,c.p-l.p1)/abs(l.p2-l.p1))<=c.r+EPS;\n}\n\nbool intersectCC(Circle c1,Circle c2){\n    return abs(c1.p-c2.p)<=c1.r+c2.r+EPS;\n}\n\nbool intersectCS(Circle c,Segment s){\n    return distanceSP(s,c.p)<=c.r+EPS;\n}\n\n//crossPoint--------------------------------------------------------------\nPoint crossPoint(Segment s1,Segment s2){\n    double crs=cross(s1.p2-s1.p1,s2.p2-s2.p1);\n    return s2.p1+(s2.p2-s2.p1)*cross(s1.p2-s1.p1,s1.p2-s2.p1)*(1.0/crs);\n}\n\npair<Point,Point>crossPoints(Circle c,Line l){\n    assert(intersectCL(c,l));\n    Vector pr=project(l,c.p);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(square(c.r)-norm(pr-c.p));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point>crossPoints(Circle c1,Circle c2){\n    assert(intersectCC(c1,c2));\n    double d=abs(c1.p-c2.p);\n    double a=acos((square(c1.r)+square(d)-square(c2.r))/(2*c1.r*d));\n    double t=arg(c2.p-c1.p);\n    return make_pair(c1.p+polar(c1.r,t+a),c1.p+polar(c1.r,t-a));\n}\n\n//polygon------------------------------------------------------------------\ndouble area(Polygon &g){\n    const int sz=g.size();\n    double res=cross(g[sz-1],g[0]);\n    for(int i=1;i<sz;i++)res+=cross(g[i-1],g[i]);\n\n    return fabs(res)*0.5;\n}\n\nbool convex(Polygon &g){\n    for(int i=0;i<g.size();i++){\n        if(ccw(prev(g,i),curr(g,i),next(g,i))==CLOCKWISE)return false;\n    }\n    return true;\n}\n\n//other-------------------------------------------------------------------\nint contains(Circle c,Point p){\n    double d=distancePP(c.p,p);\n    if(equals(d,c.r))return ON;\n    return d<c.r?IN:OUT;\n}\n\nint contains(Polygon g,Point p){\n    int n=g.size();\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=next(g,i)-p;\n        if(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return ON;\n        if(imag(a)>imag(b))swap(a,b);\n        if(imag(a)<EPS&&EPS<imag(b)&&cross(a,b)>EPS)x=!x;\n    }\n    return x?IN:OUT;\n}\n\nint contains(Circle c,Polygon g){\n    for(int i=0;i<g.size();i++){\n        if(!contains(c,g[i]))return OUT;\n    }\n    return IN;\n}\n\nint contains(Polygon g,Circle c){\n    if(contains(g,c.p)!=IN)return OUT;\n    for(int i=0;i<g.size();i++){\n        if(distanceCS(c,Segment(g[i],next(g,i)))<-EPS)return OUT;\n    }\n    return IN;\n}\n//end---------------------------------------------------------------------\n\nint main(){\n    while(true){\n        Polygon g(3);\n        Circle c;\n        inputPoint(g[0]);\n        if(real(g[0])==0&&imag(g[0])==0)break;\n        inputPoint(g[1]);\n        inputPoint(g[2]);\n\n        inputCircle(c);\n\n        bool f=true;\n\n        if(contains(c,g)){\n            puts(\"b\");\n            continue;\n        }\n\n        f=true;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(distanceCS(c,s)<-EPS)f=false;\n        }\n        if(f&&contains(g,c.p)){\n            puts(\"a\");\n            continue;\n        }\n\n        f=false;\n        for(int i=0;i<g.size();i++){\n            Segment s(g[i],next(g,i));\n            if(intersectCS(c,s)){\n                f=true;\n            }\n        }\n\n        if(f){\n            puts(\"c\");\n        }\n        else puts(\"d\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n#define EPS 1e-6\ntypedef complex<double> P;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble dist(const P& a, const P& b)\n{\n\treturn sqrt((a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag()));\n}\n\nbool isIntoC(const P& p, const C& c)\n{\n\treturn dist(p, c.p) < c.r+EPS;\n}\n\nbool isIntoC(const L& l, const C& c)\n{\n\treturn dist(l[0], c.p) < c.r+EPS && dist(l[1], c.p) < c.r+EPS;\n}\n\nint CrossPtNum(const C& c, const L& l)\n{\n\tP LV=l[0]-l[1];\n\tdouble A=(LV.real()*LV.real())+(LV.imag()*LV.imag());\n\tdouble B=(LV.real()*l[0].real())-(LV.real()*c.p.real())+(LV.imag()*l[0].imag())-(LV.imag()*c.p.imag());\n\tdouble C=(l[0].real()-c.p.real())*(l[0].real()-c.p.real())+(l[0].imag()-c.p.imag())*(l[0].imag()-c.p.imag())-(c.r*c.r);\n\n\tif(fabs(B*B-A*C) < EPS) return 1;\n\tif(B*B-A*C  > 0) return 2;\n\t\n\treturn 0;\n}\n\nbool intersectSC(const L& l, const C& c)\n{\n\tif(isIntoC(l, c)) return false;\n\t\n\tdouble vc=dot(l[1]-l[0], c.p-l[0]);\n\tif(vc<0)\n\t{\n\t\tdouble dif=c.r-dist(l[0], c.p);\n\t\treturn dif+EPS > 0;\n\t}\n\t\n\tdouble vv=dot(l[1]-l[0], l[1]-l[0]);\n\t\n\tif(vc > vv)\n\t{\n\t\tdouble d=dist(l[1], c.p);\n\t\tdouble dif=c.r*c.r-d*d;\n\t\t\n\t\treturn dif+EPS > 0;\n\t}\n\t\n\tdouble cc=dot(c.p-l[0], c.p-l[0]);\n\tdouble dif=c.r*c.r-(cc-(vc/vv)*vc);\n\t\n\treturn dif+EPS > 0;\n}\n\nint main()\n{\n\tint x,y,r;\n\twhile(scanf(\"%d%d\", &x, &y), (x||y))\n\t{\n\t\tvector<P> tri;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\ttri.push_back(P(x,y));\n\t\t\tif(i==2) break;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t}\n\t\n\t\tscanf(\"%d%d%d\", &x,&y,&r);\n\t\tC c(P(x,y), r);\n\t\t\n\t\tbool g=true;\n\t\tfor(int i=0; i<3; i++)\n\t\t{\n\t\t\tif(!isIntoC(tri[i], c))\n\t\t\t{\n\t\t\t\tg=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(g) \n\t\t{\n\t\t\tputs(\"b\");\n\t\t\tcontinue;\n\t\t}\n\t\tint cr[3];\n\t\tcr[0]=cross(tri[0]-tri[1], tri[0]-c.p);\n\t\tcr[1]=cross(tri[1]-tri[2], tri[1]-c.p);\n\t\tcr[2]=cross(tri[2]-tri[0], tri[2]-c.p);\n\t\t\n\t\tif(cr[0]<EPS&&cr[1]<EPS&&cr[2]<EPS||cr[0]+EPS>0&&cr[1]+EPS>0&&cr[2]+EPS>0)\n\t\t{\n\t\t\tg=true;\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t{\n\t\t\t\tif(CrossPtNum(c, L(tri[i], tri[(i+1)%3])) == 2) g=false;\n\t\t\t}\n\t\t\tif(g) \n\t\t\t{\n\t\t\t\tputs(\"a\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int i=0; i<tri.size(); i++)\n\t\tfor(int j=i+1; j<tri.size(); j++)\n\t\t{\n\t\t\tif(intersectSC(L(tri[i], tri[j]), c))\tg=true;\n\t\t}\n\t\tif(g)\n\t\t{\n\t\t\tputs(\"c\");\n\t\t\tcontinue;\n\t\t\t\n\t\t}\n\t\t\n\t\tputs(\"d\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nconst double EPS = 1e-8;\nconst int N = 3;\ntypedef complex<double> P;\n\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nenum { OUT, ON, IN };\nint contains(const G &g, const P &p) {\n  bool in = false;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = curr(g,i) - p, b = next(g,i) - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\nbool input(P &p){\n  int x, y; cin >>x >>y;\n  p = P(x, y);\n  return !(x == 0 && y == 0);\n}\n\nchar solve(G &g, P &p, int r){\n  double maxd = 0, mind = 1e9;\n  REP(i, N){\n    maxd = max(maxd, abs(curr(g, i) - p));\n    mind = min(mind, distanceSP(L(curr(g, i), next(g, i)), p));\n  }\n  if(maxd <= r) return 'b';\n  int cont = contains(g, p);\n  if(cont == IN && mind >= r) return 'a';\n  if(cont == OUT && mind > r) return 'd';\n  return 'c';\n}\n\nint main() {\n  G g(N);\n  while(input(g[0])){\n    FOR(i, 1, N) input(g[i]);\n    P p; int r;\n    input(p); cin >>r;\n    cout <<solve(g, p, r) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\t\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\n\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\ntypedef struct circle{\n\tpoint p;\n\tdouble r;\n} circle;\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\ncircle make(point p,double r){ circle c;\n\tc.p = p ;\n\tc.r = r;\n\treturn c;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// circle_versino\nint ccw(circle c0,circle c1){\n\tdouble  d = abs(c0.p-c1.p);\n\tdouble r0 = c0.r,r1 = c1.r;\n\t\n\t//c0in c1\n\tif(d<r1-r0)return -2;\n\t//c1 in c0\n\tif(d<r0-r1)return 2;\n\t//c0 cross c1\n\tif(abs(r0-r1)<=d&&d<=r0+r1)return 1;\n\t//c0 not cross c1\n\treturn 0;\n\n}\n\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\nint main(){\n\twhile(1){\n\tvector<point> tri(3);\n\ttri[0] = make();\n\tif(tri[0].x==0&&tri[0].y==0)break;\n\ttri[1] = make();\n\ttri[2] = make();\n\tvector<line> l(3);\n\tl[0] = make(tri[0],tri[1]);\n\tl[1] = make(tri[1],tri[2]);\n\tl[2] = make(tri[2],tri[0]);\n\n\tpoint p = make();\n\tdouble r ; cin>>r;\n\tcircle c = make(p,r);\n\t// circle in triangle\n\tif(r<=distance(l[0],p)&&r<=distance(l[1],p)&&\n\t\t\tr<=distance(l[2],p)&&contains(tri,p) ){\n\tcout<<'a'<<endl;\n\tcontinue;\n\t}\n\t// triangle in circle \n\tif(r>=distance(tri[0],p)&&r>=distance(tri[1],p)&&r>=distance(tri[2],p)){\n\tcout<<'b'<<endl;\n\tcontinue;\n\t}\n\t//cross\n\t\n\tif(r>=distance(l[0],p)|| r>=distance(l[1],p)|| r>=distance(l[2],p)){\n\tcout<<'c'<<endl;\n\tcontinue;\n\t}\n\t\n\tcout<<'d'<<endl;\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const point& a, const point& b) {\n\treturn abs(a - b);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nbool contain(const polygon& p, const point& a) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(abs(p[i] - a) < EPS)\n\t\t\treturn true;\n\n\tvector<point> points;\n\tpoints.push_back(a);\n\n\tconst segment seg(point(0, a.y), point(10001, a.y));\n\tfor(int i = 0; i < p.size(); ++i) {\n\t\tsegment edge(p[i], p[(i + 1 + p.size()) % p.size()]);\n\t\tif(intersect(seg, edge))\n\t\t\tpoints.push_back(crosspoint(seg, edge));\n\t}\n\n\tif(points.size() < 3)\n\t\treturn false;\n\n\tsort(points.begin(), points.end());\n\n\treturn points[1] == a;\n}\n\nbool contain(const circle& c, const polygon& p) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(c.c, p[i]) > c.r - EPS)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool contain(const polygon& p, const circle& c) {\n\tif(!contain(p, c.c))\n\t\treturn false;\n\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(segment(p[i], p[(i + 1) % p.size()]), c.c) < c.r + EPS)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nbool intersect(const polygon& p, const circle& c) {\n\tfor(int i = 0; i < p.size(); ++i)\n\t\tif(dist(segment(p[i], p[(i + 1) % p.size()]), c.c) < c.r - EPS)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int x, y; cin >> x >> y, x;) {\n\t\tpolygon triangle;\n\t\ttriangle.push_back(point(x, y));\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tcin >> x >> y;\n\t\t\ttriangle.push_back(point(x, y));\n\t\t}\n\n\t\tint r;\n\t\tcin >> x >> y >> r;\n\t\tcircle c(point(x, y), r);\n\n\t\tif(contain(c, triangle))\n\t\t\tcout << 'b' << endl;\n\n\t\telse if(contain(triangle, c))\n\t\t\tcout << 'a' << endl;\n\n\t\telse if(intersect(triangle, c))\n\t\t\tcout << 'c' << endl;\n\n\t\telse\n\t\t\tcout << 'd' << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nbool CL_intersect(int ax,int ay,int bx,int by,int cx,int cy,int r){\n\tint acx=cx-ax;\n\tint acy=cy-ay;\n\tint bcx=cx-bx;\n\tint bcy=cy-by;\n\tint abx=bx-ax;\n\tint aby=by-ay;\n\tif(acx*acx+acy*acy>=r*r||bcx*bcx+bcy*bcy>=r*r){\n\t\tif(abx*acx+aby*acy<0){\n\t\t\tif(acx*acx+acy*acy<=r*r)return true;\n\t\t}else{\n\t\t\tif(abx*acx+aby*acy>abx*abx+aby*aby){\n\t\t\t\tif(bcx*bcx+bcy*bcy<=r*r)return true;\n\t\t\t}else if(acx*acx+acy*acy-(long long)(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby)<=r*r)return true;\n\t\t}\n\t}\n\treturn false;\n}\nbool inclusive(int ax,int ay,int bx,int by,int cx,int cy,int px,int py){\n\tbool ok1=true;\n\tbool ok2=true;\n\tif((bx-ax)*(py-ay)-(px-ax)*(by-ay)<=0)ok1=false;\n\telse ok2=false;\n\tif((cx-bx)*(py-by)-(px-bx)*(cy-by)<=0)ok1=false;\n\telse ok2=false;\n\tif((ax-cx)*(py-cy)-(px-cx)*(ay-cy)<=0)ok1=false;\n\telse ok2=false;\n\treturn ok1||ok2;\n}\nint main(){\n\tint a,b,c,d,e,f,g,h,r;\n\twhile(scanf(\"%d%d\",&a,&b),a||b){\n\t\tscanf(\"%d%d%d%d%d%d%d\",&c,&d,&e,&f,&g,&h,&r);\n\t\tif((a-g)*(a-g)+(b-h)*(b-h)<=r*r&&(c-g)*(c-g)+(d-h)*(d-h)<=r*r&&(e-g)*(e-g)+(f-h)*(f-h)<=r*r)printf(\"b\\n\");\n\t\telse if(inclusive(a,b,c,d,e,f,g,h))printf(\"a\\n\");\n\t\telse if(CL_intersect(a,b,c,d,g,h,r)||CL_intersect(a,b,e,f,g,h,r)||CL_intersect(e,f,c,d,g,h,r))printf(\"c\\n\");\n\t\telse printf(\"d\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<complex>\n#define EPS 1e-10\nusing namespace std;\n\ntypedef complex<double> Po;\n\n\nPo p[3],o;\n\ndouble cross(Po x, Po y){return x.real()*y.imag() - x.imag()*y.real();}\n\ndouble area(Po a, Po b, Po c){return abs(cross(b-a,c-a))/2;}\n\nbool inter(Po a, Po b, Po c, Po x){\n  return (fabs(area(a,b,x)+area(b,c,x)+area(c,a,x)-area(a,b,c)) < EPS);\n}\n\ndouble line_dis(Po a, Po b, Po c){return abs(cross(b-a,c-a))/abs(b-a);}\n\nint main(){\n  double x[4],y[4],r;\n\n  for(;;){\n    cin >> x[0] >> y[0];\n    if(!x[0] && !y[0])break;\n\n    for(int i=1;i<4;i++)cin >> x[i] >> y[i];\n    cin >> r;\n\n    for(int i=0;i<3;i++)p[i] = Po(x[i],y[i]);\n    o = Po(x[3],y[3]);\n\n\n    bool f[3];\n    for(int i=0;i<3;i++)f[i] = (abs(o-p[i])<r+EPS);\n    if(f[0] && f[1] && f[2])cout << \"b\\n\";\n    else{\n      if(inter(p[0],p[1],p[2],o)){\n\tfor(int i=0;i<3;i++)f[i] = (line_dis(p[i],p[(i+1)%3],o)>r+EPS);\n\tif(f[0] && f[1] && f[2])cout << \"a\\n\";\n\telse cout << \"c\\n\";\n      }else{\n\tfor(int i=0;i<3;i++)f[i] = (line_dis(p[i],p[(i+1)%3],o)<r+EPS);\n\tif(f[0] || f[1] || f[2])cout << \"c\\n\";\n\telse cout << \"d\\n\";\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& _p, double _r) : p(_p), r(_r) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > 0.0 && d1 * d2 > 0.0 && d2 * d0 > 0.0) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(6);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL l1(tr[1], tr[2]);\n\tL l2(tr[2], tr[0]);\n\td[3] = distP2LS(cc.p, l0);\n\td[4] = distP2LS(cc.p, l1);\n\td[5] = distP2LS(cc.p, l2);\n\tif(in && d[3] >= cc.r && d[4] >= cc.r && d[5] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect ?\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\n\t// intersects each other ?\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-7\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0,double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n  Point operator * (double a){ return Point(x*a, y*a); }\n  Point operator / (double a){ return Point(x/a, y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nclass Segment{\npublic:\n  Vector t,s;\n  Segment(Vector t,Vector s) : t(t),s(s) {}\n};\n\nclass Circle{\npublic:\n  double x,y,r;\n  Circle(double x = 0.0,double y = 0.0,double r = 0.0) : x(x),y(y),r(r) {}\n};\n\nPoint point[3];\nCircle ci;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nbool check(){\n  Point cp = Point(ci.x,ci.y);\n  int c1 = ccw(point[0],point[1],cp);\n  int c2 = ccw(point[1],point[2],cp);\n  int c3 = ccw(point[2],point[0],cp);\n  return (c1 == c2 && c2 == c3);\n}\n\ntypedef Segment Line;\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.s-l.t,p-l.t)/(l.s-l.t).abs());\n}\n\ndouble getDistanceSP(Segment seg,Point p){\n  if(dot(seg.s-seg.t,p-seg.t) < 0.0) return (p-seg.t).abs();\n  if(dot(seg.t-seg.s,p-seg.s) < 0.0) return (p-seg.s).abs(); \n  return getDistanceLP(seg,p);\n}\n\nint getStateCS(Circle c,Segment seg){\n  Point cp = Point(c.x,c.y);\n  if(getDistanceSP(seg,cp) >= c.r){\n    return 1;\n  }else if(getDistanceSP(seg,cp) < c.r){\n      return 2;\n  }\n  return 3;\n}\n\nbool isCross(){\n  Point cp = Point(ci.x,ci.y);\n  for(int i = 0 ; i < 3 ; i++){\n    Point p = point[i];\n    Point diff = p - cp;\n    if(diff.abs() == ci.r) return true;\n  }\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  \n  for(int i = 0 ; i < 3 ; i++){\n    if(getDistanceSP(seg[i],cp) < ci.r){\n      return true;\n    }\n  }\n\n  for(int i = 0 ; i < 3 ; i++){\n    Segment ns = seg[i];\n    Point p1 = ns.t, p2 = ns.s;\n    if(p1.abs() < ci.r && p2.abs() > ci.r) return true;\n    if(p1.abs() > ci.r && p2.abs() < ci.r) return true;\n  }\n\n  return false;\n}\n\nvoid judge(){\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n\n  int CinT = 0,TinC = 0;\n  for(int i = 0 ; i < 3 ; i++){\n    int N = getStateCS(ci,seg[i]);\n    if(N == 1){\n      CinT++;\n    }else if(N == 2){\n      TinC++;\n    }\n  }\n\n  if(CinT == 3 && check()){\n    cout << 'a' << endl;\n  }else if(TinC == 3){\n    cout << 'b' << endl;\n  }else{\n    if(isCross()){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}\n\nint main(){\n  while(true){\n    cin >> point[0].x >> point[0].y;\n    if(!point[0].x && !point[0].y) break;\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> point[i+1].x >> point[i+1].y;\n    }\n    cin >> ci.x >> ci.y >> ci.r;\n    judge();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-7\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0,double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n  Point operator * (double a){ return Point(x*a, y*a); }\n  Point operator / (double a){ return Point(x/a, y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nclass Segment{\npublic:\n  Vector t,s;\n  Segment(Vector t,Vector s) : t(t),s(s) {}\n  Point projection(Point &p){\n    Vector b = s - t;\n    double d = dot(p-t,b) / b.norm();\n    return t + b*d;\n  }\n};\n\nclass Circle{\npublic:\n  double x,y,r;\n  Circle(double x = 0.0,double y = 0.0,double r = 0.0) : x(x),y(y),r(r) {}\n};\n\nPoint point[3];\nCircle ci;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nbool check(){\n  Point cp = Point(ci.x,ci.y);\n  int c1 = ccw(point[0],point[1],cp);\n  int c2 = ccw(point[1],point[2],cp);\n  int c3 = ccw(point[2],point[0],cp);\n \n  if(c1 == c2 && c2 == c3) return true;\n  return false;\n}\n\ntypedef Segment Line;\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.s-l.t,p-l.t)/(l.s-l.t).abs());\n}\n\ndouble getDistanceSP(Segment seg,Point p){\n  if(dot(seg.s-seg.t,p-seg.t) < 0.0) return (p-seg.t).abs();\n  if(dot(seg.t-seg.s,p-seg.s) < 0.0) return (p-seg.s).abs(); \n  return getDistanceLP(seg,p);\n}\n\nint getStateCS(Circle c,Segment seg){\n  Point cp = Point(c.x,c.y);\n  Point p = seg.projection(cp);\n  Point pp = p - cp;\n  Vector a = seg.t - cp;\n  Vector b = seg.s - cp;\n  if(check() && a.abs() > c.r && b.abs() > c.r){\n    if(pp.abs()+EPS > c.r && ccw(seg.t,seg.s,p)==0){\n      return 1;\n    }\n  }else if(a.abs() < c.r && b.abs() < c.r){\n    if(pp.abs()-EPS < c.r && ccw(seg.t,seg.s,p)==0){\n      return 2;\n    }\n  }\n  return 3;\n}\n\nbool isCross(){\n  Point cp = Point(ci.x,ci.y);\n  for(int i = 0 ; i < 3 ; i++){\n    Point p = point[i];\n    Point diff = p - cp;\n    if(diff.abs() == ci.r) return true;\n  }\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  \n  for(int i = 0 ; i < 3 ; i++){\n    if(getDistanceSP(seg[i],cp) < ci.r){\n      return true;\n    }\n  }\n\n  for(int i = 0 ; i < 3 ; i++){\n    Segment ns = seg[i];\n    Point p1 = ns.t, p2 = ns.s;\n    if(p1.abs() < ci.r && p2.abs() > ci.r) return true;\n    if(p1.abs() > ci.r && p2.abs() < ci.r) return true;\n  }\n\n  return false;\n}\n\nvoid judge(){\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n\n  int CinT = 0,TinC = 0;\n  for(int i = 0 ; i < 3 ; i++){\n    int N = getStateCS(ci,seg[i]);\n    if(N == 1){\n      CinT++;\n    }else if(N == 2){\n      TinC++;\n    }\n  }\n\n  if(CinT == 3){\n    cout << 'a' << endl;\n  }else if(TinC == 3){\n    cout << 'b' << endl;\n  }else{\n    if(isCross()){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}\n\nint main(){\n  while(true){\n    cin >> point[0].x >> point[0].y;\n    if(!point[0].x && !point[0].y) break;\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> point[i+1].x >> point[i+1].y;\n    }\n    cin >> ci.x >> ci.y >> ci.r;\n    judge();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\n#define Y imag()\n#define X real()\nconst double EPS = 1e-8;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\ndouble get(P a[3]){\n\tdouble A = abs(a[0]-a[1]);\n\tdouble B = abs(a[1]-a[2]);\n\tdouble C = abs(a[2]-a[0]);\n\tdouble s = (A+B+C) / 2.0;\n\tdouble S = sqrt( s * (s-A) * (s-B) * (s-C) );\n\treturn S;\n}\ndouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\ndouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tdouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\tbool in = fabs(S) < EPS;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) < r - EPS || getPedal(L(a[1],a[2]),c) < r - EPS || getPedal(L(a[0],a[2]),c) < r - EPS;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) < r*r && nijo(a[1]-c) < r*r && nijo(a[2]-c) < r*r) cout << \"b\" << endl;\n\t\telse if(in && !hit) cout << \"a\" << endl;\n\t\telse if(hit) cout << \"c\" << endl;\n\t\telse cout << \"d\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <cstdio>\n#include <string>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n#define self (*this)\ntypedef double R;\n\nconst R eps = 1e-8;\nconst R inf = 1e12;\nconst R pi = acos(-1);\ntypedef complex<R> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\nR cross(const P& a, const P& b) { return imag(conj(a)*b); }\nR dot(const P& a, const P& b) { return real(conj(a)*b); }\nstruct L : public vector<P> {\n    L(const P &a = P(), const P &b = P()) {\n        push_back(a); push_back(b);\n    }\n    L(R a, R b, R c){ // ax+by+c=0\n        if(fabs(a) < eps) self = L(P(0,-c/b),P(1,-c/b));\n        else if(fabs(b) < eps) self = L(P(-c/a,0),P(-c/a,1));\n        else self = L(P(-c/a,0), P(0,-c/b));\n    }\n    P vec() const { return self[1] - self[0]; }\n};\n\nstruct S : public vector<P> {\n    // A to B\n    S(const P &a = P(), const P &b = P()) { push_back(a); push_back(b); }\n    L toL() const { return L(self[0], self[1]); }\n    P vec() const { return toL().vec(); }\n    R len() const { return abs(vec()); }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; R r;\n    C(const P &p = P(), R r = 0) : p(p), r(r) { }\n};\n\n// CCW\nenum { CCW = +1, CW = -1, CAB = +2, ABC = -2, SAMEPOINT = 0 };\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return CCW; // a->b->c 反時計回り\n    if (cross(b, c) < 0)   return  CW; // a->b->c 時計回り\n    if (dot(b, c) < 0)     return CAB; // c--a--b 直線上\n    if (norm(b) < norm(c)) return ABC; // a--b--c 直線上\n    return SAMEPOINT; // 2点以上が重なっている\n}\n\n// A->C方向の角ABCの大きさを[0,2*Pi]で求める\nR arg(P a, P b, P c) {\n    R th = arg((a - b) / (c - b));\n    return th > 0 ? th : th+2*pi;\n}\n\n// 交差判定\nbool col(const L &l, const L &m) {\n    return abs(cross(l.vec(), m.vec())) > eps || abs(cross(l.vec(), m[0]-l[0])) < eps;\n}\n\nbool col(const L &l, const S &s) {\n    return cross(l.vec(), s[0]-l[0])*cross(l.vec(), s[1]-l[0]) < eps;\n}\n\nbool col(const L &l, const P &p) {\n    return abs(cross(l[1]-p, l[0]-p)) < eps;\n}\n\nbool col(const S &s, const S &t) {\n    return\n        ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n        ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool col(const S &s, const P &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < eps; // triangle inequality\n}\n\nint col(const C& c1, const C& c2){\n    double d = abs(c1.p - c2.p), r1 = c1.r, r2 = c2.r;\n    if(r1 + r2 < d) return 0; // 離れている\n    if(abs(r1 + r2 - d) < eps) return 1; // 外接\n    if(abs(d - abs(r1 - r2)) < eps) return -1; // 内接\n    if(d < r1 - r2)            return +3; // c1 が c2 の中にある\n    if(d < r2 - r1)            return -3; // c2 が c1 の中にある\n    return 2; // 2つの交点を持つ\n}\n\n// 射影\nP proj(const L &l, const P &p) {\n    double t = dot(p-l[0], l.vec()) / norm(l.vec());\n    return l[0] + t*(l.vec());\n}\nL proj(const L& l, const L& m) {\n    return L(proj(l,m[0]), proj(l,m[1]));\n}\n\n// 反射\nP refl(const L &l, const P &p) {\n    return p + 2. * (proj(l, p) - p);\n}\nL refl(const L& l, const L& m) {\n    return L(refl(l,m[0]), refl(l,m[1]));\n}\n\n// 距離\nR dist(const P &p, const P &q){\n    return abs(p - q);\n}\n\nR dist(const L &l, const P &p) {\n    return abs(p - proj(l, p));\n}\n\nR dist(const L &l, const L &m) {\n    return col(l, m) ? 0 : dist(l, m[0]);\n}\n\nR dist(const L &l, const S &s) {\n    if (col(l, s)) return 0;\n    return min(dist(l, s[0]), dist(l, s[1]));\n}\n\nR dist(const S &s, const P &p) {\n    const P r = proj(s.toL(), p);\n    if (col(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nR dist(const S &s, const S &t) {\n    if (col(s, t)) return 0;\n    return min(min(dist(s, t[0]), dist(s, t[1])),\n               min(dist(t, s[0]), dist(t, s[1])));\n}\n\nR dist(const C &c, const P &p) {\n    return max(0. , abs(c.p - p) - c.r);\n}\n\n// positive -> outside\n// zero     -> on the boundaly\n// negative -> inside\nR dist(const C& c, const L& l){\n    R d = dist(l,c.p);\n    return max(0. , d - c.r);\n}\n\n// 交点\nvector<P> hit(const L &l, const L &m) {\n    R A = cross(l.vec(), m.vec());\n    R B = cross(l.vec(), l[1] - m[0]);\n    if (abs(A) < eps && abs(B) < eps) return {m[0]}; // same line\n    if (abs(A) < eps) return {}; // parallel\n    return {m[0] + B / A * (m.vec())};\n}\n\nvector<P> hit(const S& s, const S& t) {\n    if(col(s,t)) return hit(s,t);\n    else return {};\n}\n\nvector<P> hit(const L& l, const S& s){\n    if(col(l,s)) return hit(l,s);\n    else return {};\n}\n\n// Verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1183\n//        : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2045\nvector<P> hit(const C& c, const L& l){\n    R d = dist(l,c.p); // 中心と直線の距離\n    if(fabs(d-c.r) < eps) return { proj(l, c.p) }; // 触れている\n    if(d > c.r) return {}; // 離れている\n    P h = proj(l, c.p);\n    P u = sqrt(c.r*c.r - d*d) * (l.vec()) / abs(l.vec());\n    return {h+u, h-u};\n}\n\nvector<P> hit(const C& c, const S& s){\n    vector<P> cs = hit(c,s.toL()), res;\n    for(const P& p : cs) {\n        if(col(s,p)) res.push_back(p);\n    }\n    return res;\n}\n\nvector<P> hit(const C& c1, const C& c2){\n    if(abs(c1.p - c2.p) < 0) return {}; // 中心が同じ\n    int i = col(c1,c2);\n    if(i==0 || abs(i)==3) return {}; // 共通部分なし || 内部\n    R r1 = c1.r, r2 = c2.r, d = abs(c1.p - c2.p);\n    if(i==1) return { c1.p + (c2.p - c1.p) * r1/d }; // 接する\n    P p = c1.p - c2.p;\n    R A = -2. * p.real(), B = 2 * p.imag();\n    R C = norm(c1.p) - norm(c2.p) - r1*r1 + r2*r2;\n    return hit(c1, L(A,B,C)); // 2つの交点を持つ\n}\n\nvector<P> hit(const C& c, const G& g){\n    vector<P> res;\n    int n = g.size();\n    rep(i,n){\n        vector<P> ps = hit(c, S(g[i],g[(i+1)%n]));\n        rep(j,ps.size()) res.push_back(ps[j]);\n    }\n    return res;\n}\n\n// 内包判定\nenum { OUT, ON, IN };\nint inside(const P& p, const C& c) {\n    double d = abs(p-c.p), r = c.r;\n    if(abs(d - r) < eps) return ON;\n    if(d > r) return OUT;\n    return IN;\n}\n\nint inside(const P& p, const G &g) {\n    int n = g.size(), a = 0, b = n;\n    P in = (g[0] + g[n/3] + g[2*n/3]) / 3.0; // inner\n    while (a+1 < b) { // invariant: c is in fan in-g[a]-g[b]\n        int c = (a + b) / 2;\n        if (cross(g[a]-in, g[c]-in) > 0) { // angle < 180 deg\n            if (cross(g[a]-in, p-in) > 0 && cross(g[c]-in, p-in) < 0) b = c;\n            else a = c;\n        } else {\n            if (cross(g[a]-in, p-in) < 0 && cross(g[c]-in, p-in) > 0) a = c;\n            else b = c;\n        }\n    }\n    b %= n;\n    if (cross(g[a] - p, g[b] - p) < 0) return OUT;\n    if (cross(g[a] - p, g[b] - p) > 0) return IN;\n    return ON;\n}\n\nbool inside(const C& c, const G& g) {\n    int n = g.size();\n    rep(i,n){\n        P a = g[i], b = g[(i+1)%n];\n        if(!inside(a,c) || !inside(b,c)) return false;\n    }\n    return true;\n}\n\nbool inside(const G& g, const C& c) {\n    int n = g.size();\n    rep(i,n){\n        P a = g[i], b = g[(i+1)%n];\n        if(cross(b-a, c.p-a) + eps > 0 && dist(S(a,b),c.p) + eps > c.r) {\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n\nchar solve(C c, G t){\n    if(inside(c,t)) return 'a';\n    if(inside(t,c)) return 'b';\n    bool isc = false;\n    t.push_back(t.front());\n    rep(i,3){\n        if(hit(c, S(t[i],t[i+1])).size()){\n            isc = true;\n        }\n    }\n    if(isc) return 'c';\n    return 'd';\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b && a){\n        G t(3);\n        t[0] = P(a,b);\n        rep(i,2){\n            int a,b;\n            cin>>a>>b;\n            t[i+1] = P(a,b);\n        }\n        int a,b,r;\n        cin>>a>>b>>r;\n        C c(P(a,b),r);\n        cout << solve(c,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\ndouble cross(const P& a, const P& b) {\n    return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n    return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n    P p; double r;\n    C(const P &p, double r) : p(p), r(r) { }\n};\n\nP projection(const L &l, const P &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) {\n    return abs(p - projection(l, p));\n}\n\nint convex_contains(const G &gg, const P &p) {\n    const int n = gg.size();\n    P g = (gg[0] + gg[n/3] + gg[2*n/3]) / 3.0; // inner-point\n    int a = 0, b = n;\n    while (a+1 < b) { // invariant: c is in fan g-P[a]-P[b]\n        int c = (a + b) / 2;\n        if (cross(gg[a]-g, gg[c]-g) > 0) { // angle < 180 deg\n            if (cross(gg[a]-g, p-g) > 0 && cross(gg[c]-g, p-g) < 0) b = c;\n            else                                                  a = c;\n        } else {\n            if (cross(gg[a]-g, p-g) < 0 && cross(gg[c]-g, p-g) > 0) a = c;\n            else                                                  b = c;\n        }\n    }\n    b %= n;\n    if (cross(gg[a] - p, gg[b] - p) < 0) return false;\n    if (cross(gg[a] - p, gg[b] - p) > 0) return true;\n    return false;\n}\n\nint main(){\n    double x, y;\n    while(cin >> x >> y, x+y){\n        G g;\n        g.push_back(P(x, y));\n        for(int i=0; i< 2; i++){\n            cin >> x >> y;\n            g.push_back(P(x, y));\n        }\n        cin >> x >> y;\n        double r;\n        cin >> r;\n        C c(P(x, y), r);\n        if(convex_contains(g, c.p)){\n            bool a = true;\n            for(int i=0; i< 3; i++){\n                L l(g[i], g[(i+1)%3]);\n                if(!(c.r < distanceLP(l, c.p))) a = false;\n            }\n            if(a) cout << \"a\" << endl;\n            else cout << \"c\" << endl;\n        }\n        else {\n            bool b = true;\n            for(int i=0; i< 3; i++){\n                if(!(abs(g[i]-c.p) < c.r)) b = false;\n            }\n            if(b) cout << \"b\" << endl;\n            else cout << \"d\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nbool onLine(const Line &l, const Point &p) {\n  Point pj = projection(l,p);\n  return ccw(l[0],pj,l[1]) == -2;\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point> ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool is_convex_hull(vector<Point>& ps,const Point& c){\n  for(int i=0;i<ps.size();i++){\n    if(is_equal(ps[i],c)) return true;\n  }\n  return false;\n}\n\nint main(){\n  double x[4];\n  double y[4];\n  while(~scanf(\"%lf %lf\",&x[0],&y[0])){\n    if(is_equal(Point(x[0],y[0]),Point(0.0,0.0))) break;\n\n    for(int i=1;i<4;i++){\n      scanf(\"%lf %lf\",&x[i],&y[i]);\n    }\n    double r;\n    scanf(\"%lf\",&r);\n\n    vector<Line> lines;\n    vector<Point> points;\n\n    for(int i=0;i<4;i++){\n      points.push_back(Point(x[i],y[i]));\n    }\n\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        lines.push_back(Line(Point(x[i],y[i]),Point(x[j],y[j])));\n      }\n    }\n\n    vector<Point> convex_hull = compute_convex_hull(points);\n\n    if(!is_convex_hull(convex_hull,points[3])){\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n      }\n      \n      if(r <= dist + EPS){\n        //a\n        printf(\"a\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n        }\n        if(r >= dist - EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n      }\n    }\n    else {\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        if(onLine(lines[i],Point(x[3],y[3]))){\n          dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n        }\n      }\n      for(int i=0;i<3;i++){\n        dist = min(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n      }\n      \n      if(dist > r){\n        //d\n        printf(\"d\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n          // cout << points[i].imag() << \" \" << points[i].real() << endl;\n          // cout << points[3].imag() << \" \" << points[3].real() << endl;\n          // cout << dist << endl;\n        }\n        \n        if(r >= dist - EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          // cout << dist << endl;\n          printf(\"c\\n\");\n        }\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdafx.h\"\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nstruct Point{\n  int x;\n  int y;\n};\n\nstruct Delta{\n  Point p[3];\n};\n\nstruct Circle{\n  Point p;\n  int radius;\n};\n\ndouble distance(Point p1, Point p2){\n  return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n\ndouble dist_line(Point pl1, Point pl2, Point p){\n  int a = pl1.x - pl2.x;\n  int b = pl2.y - pl1.y;\n  int c = pl1.y * pl2.x - pl1.x * pl2.y;\n  double ans = b * p.x + a * p.y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n\t  cerr << \"cannot find the file\" << endl;\n\t  return 1;\n  }\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n\tDelta *d = (Delta *) malloc(sizeof(Delta));\n\tfor (int i = 0; i < 5; i++) {\n\t\tgetline(ifs, str);\n\n      if(str == \"0 0\") break;\n\t  \n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n\t      if(str[j] == ' '){\t\t\t\n\t\t\tstr[j] = '\\0';\n\t\t\tbreak;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\t  \n    }\n    if(str == \"0 0\") break;\n\t\n\n    if(distance(d->p[0], c->p) <= c->radius&& distance(d->p[1], c->p) <= c->radius&& distance(d->p[2], c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(d->p[0], d->p[1], c->p) >= c->radius&& dist_line(d->p[0], d->p[2], c->p) >= c->radius&& dist_line(d->p[1], d->p[2], c->p) >= c->radius){\n\t\tif (dist_line(d->p[0], d->p[1], d->p[2]) <= distance(d->p[0], c->p) && dist_line(d->p[1], d->p[2], d->p[0]) <= distance(d->p[1], c->p) && dist_line(d->p[2], d->p[0], d->p[1]) <= distance(d->p[2], c->p))\n\t\t\tcout << 'd' << endl;\n\t\telse\n\t\t\tcout << 'a' << endl;\n    }\n    else if(dist_line(d->p[0], d->p[1], c->p) <= c->radius|| dist_line(d->p[0], d->p[2], c->p) <= c->radius|| dist_line(d->p[1], d->p[2], c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point& a, const Point& b) { return Point{ a.px - b.px,a.py - b.py }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double dst(const Point& a, const Point& b) { return abs(Minus(b , a)); }\nlong double dst(const Line& a, const Point& b) {\n\treturn dot(Minus(a.p2, a.p1), Minus(b, a.p1)) < 0.0 ? abs(Minus(b, a.p1)) : (dot(Minus(a.p1, a.p2), Minus(b, a.p2)) < 0.0 ? abs(Minus(b, a.p2)) : abs(crs(Minus(a.p2, a.p1), Minus(b, a.p1)) / abs(Minus(a.p2, a.p1))));\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = Minus(v[i], p), b = Minus(v[(i + 1) % v.size()], p);\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= 1e-10 && 1e-10 < b.py)\n\t\t\tif (crs(a, b) < -1e-10) in = !in;\n\t\tif (fabs(crs(a, b)) <= 1e-10 && dot(a, b) <= 1e-10) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nint main() {\n\twhile (true) {\n\t\tPoint r1, r2, r3, r4; long double r;\n\t\tcin >> r1.px >> r1.py; if (fabs(r1.px) <= 1e-10 && fabs(r1.py) <= 1e-10)break;\n\t\tcin >> r2.px >> r2.py >> r3.px >> r3.py >> r4.px >> r4.py >> r;\n\t\tLine l1 = Line{ r1,r2 }, l2 = { r2,r3 }, l3 = { r3,r1 };\n\t\tlong double c1 = min(dst(l1, r4), min(dst(l2, r4), dst(l3, r4)));\n\t\tlong double c2 = max(dst(r1, r4), max(dst(r2, r4), dst(r3, r4)));\n\t\tlong double c3 = min(dst(r1, r4), min(dst(r2, r4), dst(r3, r4)));\n\t\t//cout << dst(l1, r4) << ' ' << dst(l2, r4) << ' ' << dst(l3, r4) << endl;\n\t\tint c4 = contain({ r1,r2,r3 }, r4);\n\t\tif (c1 >= r - 1e-10 && c4 != 0) { cout << \"a\" << endl; }\n\t\telse if (c2 <= r + 1e-10) { cout << \"b\" << endl; }\n\t\telse if (c3 <= r + 1e-10) { cout << \"c\" << endl; }\n\t\telse { cout << \"d\" << endl; }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n#define OUT 0\n#define ON 1\n#define IN 2\n#define EPS (1e-10)\nclass P{                    //???\npublic:\n    double x,y;\n    \n    P(double _x=0,double _y=0):x(_x),y(_y){};\n    P operator + (P &p     ){ return P( x+p.x , y+p.y ); }  //??????\n    P operator - (P &p     ){ return P( x-p.x , y-p.y ); }  //??????\n    P operator * (double k ){ return P( x*k   , y*k    ); } //??????\n    P operator / (double k ){ return P( x/k   , y/k    ); } //??????\n    \n    bool operator == (const P &p){ return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS ); }\n    //    bool operator < (const P &p)const{ return ( x!=p.x ? x<p.x:y<p.y ); }\n    \n    double norm(){ return x*x+y*y; }        //?????????\n    double abs() { return sqrt(norm()); }   //??§??????\n    \n};\nstruct C{P p;double r;};    //???\nstruct L{P p1,p2;};         //??´???\ntypedef vector<P> Polygon;  //????§???¢\ntypedef P Vector;           //????????????\n\ndouble dot  (Vector a,Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a,Vector b) { return a.x*b.y-a.y*b.x; }\ndouble sqDist(P a, P b)         {return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);}\ndouble dist (P a, P b)          {return sqrt(sqDist(a,b));}\nVector vec(L a)                 {return P(a.p2.x-a.p1.x,a.p2.y-a.p1.y);}\n\nint ccw(P p0,P p1,P p2){    //AOJ_BOOK_P386 verified\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    \n    if( cross(a,b) > EPS  ) return 1 ;      //COUNTER_CLOCKWISE\n    if( cross(a,b) < -EPS ) return -1;      //CLOCKWISE\n    if( dot(a,b)   < -EPS ) return 2;       //ONLINE_BACK\n    if( a.norm()   < b.norm() ) return -2;  //ONLINE_FRONT\n    \n    return 0;                               //ON_SEGMENT;\n}\n\n//??´?????´????????? verified AOJ0058\nbool orthogonal(P p1,P p2,P p3,P p4){ return abs(dot(p1-p2,p3-p4))<EPS; }\n\n//??????????????????\nbool intersect(P p1,P p2,P p3,P p4){ return ( ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); }\n\n//????????¨???????????¢ verified ARC042-B\ndouble dLP(L l, P p) { return abs(cross(l.p2-l.p1, p-l.p1)) /(l.p2-l.p1).abs(); }\n\n//??´?????¨??´????????¢??? verified AOJ CGL_2\nint rLL(L a,L b){\n    if( cross(vec(a),vec(b))==0 ) return 2; //??????\n    if( dot(vec(a),vec(b))==0 )   return 1; //?????´\n    return 0;\n}\n\n// ?????¨??????????????????\nint contains(C c, P p){\n    double d = (c.p-p).abs();\n    if(d-c.r>EPS) return OUT;\n    if(abs(d-c.r)<EPS) return ON;\n    return IN;\n}\n\n//??´?????¨??????????????????(????????£???????????´??????????????±???)\nbool intersect_circle_(P center, double r, L line){\n    if( dLP(line,center) <= r+EPS ) return true;\n    return false;\n}\n\n//????????¨???????????¢ verified QUPC-G\ndouble dSP(L s, P p){\n    if(dot((s.p2-s.p1)   , p-s.p1) <= EPS) return (p - s.p1).abs();\n    if(dot((s.p2-s.p1)*-1, p-s.p2) <= EPS) return (p - s.p2).abs();\n    return dLP(s, p);\n}\n\n//????????¨??????????????????(????????£???????????´??????????????±???) verified QUPC-G\nbool iCS(C c, L l){\n    int c1 = contains(c, l.p1);\n    int c2 = contains(c, l.p2);\n    if(c1 > c2) swap(c1, c2);\n    \n    // (OUT, OUT) (OUT, ON) (OUT, IN) (ON, ON) (ON, IN) (IN, IN) ???6??????\n    if(c1 == OUT && c2 == IN) return true;\n    if(c1 == IN  && c2 == IN) return false;\n    if(c1 == ON) return true; // (??\\????????¨???)\n    double d = dSP(l, c.p);\n    if(d-c.r<-EPS) return true;\n    if(d-c.r>EPS) return false;\n    return true; // (??\\????????¨???)\n}\n\n//????´?????§???¢??????\nbool isSimple( Polygon pol ){\n    //???????????????????????????pol?????\\????????????\n    size_t pol_size = pol.size()-1;\n    rep(i,pol_size){\n        for(int j=i+2;j<pol_size;j++){\n            if( i==j || i==(j-1+pol_size)%pol_size || i==(j+1+pol_size)%pol_size )continue;\n            if( intersect(pol[i], pol[i+1], pol[j], pol[j+1]) )return false;\n        }\n    }\n    return true;\n}\n\n//?????????????§???¢????????´?????????????????????????±??????? true???????????´ verified AOJ0012\nint isPointInsidePolygon(vector<P> pol,P p){\n    int c=0;\n    rep(i,pol.size()){\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])==0 ) return ON;\n        if( cross(pol[i]-pol[(i+1)%pol.size()] , p-pol[(i+1)%pol.size()])>0 ) c++;\n    }\n    if( c%pol.size() )return OUT;\n    return IN;\n}\n\n//?????¨???????§???¢???????????¶???????????????\nint CPOLarea(C c ,Polygon pol){\n    vector<L> lines;\n    vector<int> res(pol.size());\n    bool POLinC=true, isFar=true;\n    \n    rep(i,pol.size()){\n        if( contains(c,pol[i])==OUT )POLinC=false;\n        res[i] = contains(c,pol[i]);\n        lines.pb( L{ pol[i] , pol[(i+1)%pol.size()] });\n        if( sqDist(c.p,pol[i])<c.r*c.r )isFar=false;\n    }\n    \n    if( POLinC )                                        return 2;   //????§???¢??????????????¨b\n    if( isPointInsidePolygon(pol, c.p)==IN && isFar )   return 3;   //????§???¢????????¨??????a\n    rep(i,lines.size()) if( iCS(c,lines[i]) )           return 1;   //????§???¢??¨????????????c\n    return 0;\n}\n\n//?????? verified AOJ0068,QUPC-G\n//???????????§??????\nbool cmp_x(const P& p, const P& q){\n    if(p.x != q.x)return p.x<q.x;\n    return p.y<q.y;\n}\n\n//??????????±???????\nvector<P> convex_hull(vector<P> ps){\n    int n = ps.size();\n    sort(all(ps),cmp_x);\n    int k=0;            //?????????????????°\n    vector<P> qs(n*2);  //?§????????????????\n    //?????´???????????????\n    rep(i,n){\n        while( k>1 && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    //?????´???????????????\n    for(int i=n-2, t=k;i>=0;i--){\n        while( k>t && cross((qs[k-1]-qs[k-2]) , (ps[i]-qs[k-1]))<=0 ) k--;\n        qs[k++]=ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\nint main(){\n    int a,b;\n    while(cin>>a>>b&&(a||b)){\n        Polygon pol(3);\n        pol[0] = P(a,b);\n        rep(i,2)cin>>pol[i+1].x>>pol[i+1].y;\n        C c;\n        cin>>c.p.x>>c.p.y>>c.r;\n        int res =  CPOLarea(c,pol);\n        \n        cout<<(char)('a'+(3-res))<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\n\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\nint ccw(P a, P b, P c) {\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) : x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y-l.x;\n}\n\nR distLP(const L &l, const P &p) {\n    return abs(cross(vec(l), p-l.x)/abs(vec(l)));\n}\n\nR distSP(const L &s, const P &p) {\n    P s2 = vec(s)*P(0, 1);\n    if (ccw(s.x, s.x+s2, p) == 1) return abs(s.x-p);\n    if (ccw(s.y, s.y+s2, p) == -1) return abs(s.y-p);\n    return min(min(abs(s.x-p), abs(s.y-p)), distLP(s, p));\n}\n\nstruct C {\n    P p;\n    R r;\n    C() {}\n    C(P p, R r) : p(p), r(r) {}\n};\n\nstruct T {\n    P d[3];\n    T() {}\n    T(P x, P y, P z) {\n        d[0] = x; d[1] = y; d[2] = z;\n    }\n    P& operator[](int p) {\n        return d[p];\n    }\n    const P& operator[](int p) const {\n        return d[p];\n    }\n    int size() const {\n        return 3;\n    }\n};\n\nP cu(const T &t, int i) {\n    return t[(i%3+3)%3];\n}\n\n//0:P is out 1:P is on line 2:P is in\nint contains(const T &pol, P p) {\n    int in = -1;\n    for (int i = 0; i < (int)pol.size(); i++) {\n        P a=cu(pol,i)-p, b=cu(pol,i+1)-p;\n        if (ccw(a, b, P(0, 0)) == 0) return 1;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)) {\n            if (cross(a, b) < 0) in *= -1;\n        }\n    }\n    return in+1;\n}\n\nbool solve() {\n    T t;\n    for (int i = 0; i < 3; i++) {\n        double x, y;\n        if (scanf(\"%lf %lf\", &x, &y) != 2) return false;\n        t[i] = P(x, y);\n    }\n    C c;\n    double x, y;\n    cin >> x >> y;\n    c.p = P(x, y);\n    double r;\n    cin >> r;\n    c.r = r;\n\n    R ma = -1e9, mi = 1e9;\n    for (int i = 0; i < 3; i++) {\n        ma = max(ma, abs(t[i]-c.p));\n        mi = min(mi, distSP(L(cu(t, i), cu(t, i+1)), c.p));\n    }\n//    cout << ma << \" \" << mi << endl;\n    if (sgn(ma, c.r) != -1) {\n        cout << \"b\" << endl;\n        return true;\n    }\n\n    if (contains(t, c.p) != 0 && sgn(c.r, mi) != -1) {\n        cout << \"a\" << endl;\n        return true;\n    }\n\n    if (sgn(mi, c.r) != -1) {\n        cout << \"c\" << endl;\n        return true;\n    }\n    cout << \"d\" << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <array>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define eq(n,m) (abs((n)-(m)) < EPS)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double EPS_GIG = 1e-3;\nconst double PI = acos(-1.0);\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x_, double y_):x(x_), y(y_){};\n\tpoint(const point &p):x(p.x), y(p.y){}\n\tpoint():x(0), y(0){}\n\tpoint& operator+=(point a){x += a.x;y += a.y;return *this;}\n\tpoint& operator-=(point a){x -= a.x;y -= a.y;return *this;}\n\tpoint& operator*=(point a){\n\t\tdouble xx = x * a.x - y * a.y;\n\t\tdouble yy = x * a.y + y * a.x;\n\t\tx = xx;y = yy;return *this;\n\t}\n\tpoint& operator*=(double a){x *= a;y *= a;return *this;}\n\tpoint& operator/=(double a){x /= a;y /= a;return *this;}\n\tpoint operator+(point a) const{return point(x, y)+=a;}\n\tpoint operator-(point a) const{return point(x, y)-=a;}\n\tpoint operator-() const{return point(-x, -y);}\n\tpoint operator*(point a) const{return point(x, y)*=a;}\n\tpoint operator*(double a) const{return point(x, y)*=a;}\n\tpoint operator/(double a) const{return point(x, y)/=a;}\n\tbool operator<(point a) const{return (x != a.x ? x < a.x : y < a.y);}\n\tdouble real() {return x;}\n\tdouble imag() {return y;}\n};\n\ntemplate <class T>\npoint operator*(const T a, const point p){return p * a;}\n\npoint conj(point p) {return point(p.x, -p.y);}\ndouble arg(point p) {return arg(complex<double>(p.x, p.y));}\ndouble abs(point p) {return abs(complex<double>(p.x, p.y));}\ndouble norm(point p) {return norm(complex<double>(p.x, p.y));}\ndouble real(point p) {return p.x;}\ndouble imag(point p) {return p.y;}\n\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\n\n// 扇型、中心と半径、二つの端点\n// 現在中心角が180未満の前提\nstruct sector {\n\tpoint o;\n\tpoint a, b;\n\tdouble r;\n\tsector(){}\n\tsector(point O, point A, point B, double _r) :o(O), a(A), b(B), r(_r) {}\n};\n\nstruct segment : public array<point, 2> {\n\tsegment(const point &a, const point &b) {\n\t\tat(0) = a;\n\t\tat(1) = b;\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn (conj(a)*b).y;\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn (conj(a)*b).x;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > 2 * PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.x * cos(rad) - p.y * sin(rad);\n\tdouble y = p.y * cos(rad) + p.x * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS)   return +1;       // counter clockwise\n\tif (cross(b, c) + EPS < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\tauto a = s[0] - p;\n\tauto b = s[1] - p;\n\treturn (abs(cross(a, b)) < EPS && dot(a, b) <= EPS); // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n//端点の交差hは考えない\nbool strictIntersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) == -1 &&\n\t\tccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) == -1;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n/*多角形内包判定\nhalf-line crossing method\nOUT:0\nON:1\nIN:2\n*/\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (a.y > b.y) swap(a, b);\n\t\tif (a.y < EPS && EPS < b.y && cross(a, b) > EPS)in = !in;\n\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n/*\nOUT:0\nON:1\nIN:2\n*/\nint contain_sector(const sector &sec, point &p){\n\tif(eq(abs(p - sec.o), sec.r))return 1;\n\tif(intersectSP(segment(sec.o, sec.a), p))return 1;\n\tif(intersectSP(segment(sec.o, sec.b), p))return 1;\n\tif(abs(p - sec.o) + EPS > sec.r)return 0;\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(angle(vec, vecA) + EPS < angle(vecA, vecB) && angle(vec, vecB) + EPS < angle(vecA, vecB))return 2;\n\treturn 0;\n}\n\n//交点\npoint crosspointSS(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<point> crosspointCL(const circle &c, const segment &l) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto pro_p = projection(l, c.p);\n\tauto dist = distanceLP(l, c.p);\n\tif(abs(dist - c.r) < EPS){\n\t\tret[0] = pro_p;\n\t\treturn ret;\n\t}\n\tif(c.r < dist){\n\t\treturn ret;\n\t}\n\tpoint vec = (l[1] - l[0]) * sqrt(c.r * c.r - dist * dist) / abs(l[1] - l[0]);\n\tret[0] = pro_p + vec;\n\tret[1] = pro_p - vec;\n\treturn ret;\n}\n\nvector<point> crosspointCC(const circle c1, const circle c2) {\n\tauto ret = vector<point>(2, point(INF, INF));\n\tauto dist = abs(c2.p - c1.p);\n\tif(eq(dist, c1.r + c2.r) || eq(dist, abs(c2.r - c1.r))){\n\t\tauto tmp = c2.p - c1.p;\n\t\tret[0] = c1.p + tmp * (c1.r / dist);\n\t\treturn ret;\n\t}\n\tif(c1.r + c2.r < dist || dist < abs(c1.r - c2.r)){\n\t\treturn ret;\n\t}\n\tauto alpha = acos((c1.r * c1.r + dist * dist - c2.r * c2.r) / (2 * c1.r * dist));\n\tauto theta = atan2(c2.p.y - c1.p.y, c2.p.x - c1.p.x);\n\tret[0] = c1.p + point(cos(theta + alpha) * c1.r, sin(theta + alpha) * c1.r);\n\tret[1] = c1.p + point(cos(theta - alpha) * c1.r, sin(theta - alpha) * c1.r);\n\treturn ret;\n}\n\nbool isOnSector(const sector sec, const point p) {\n\tpoint vec = p - sec.o;\n\tpoint vecA = sec.a - sec.o;\n\tpoint vecB = sec.b - sec.o;\n\tif(eq(angle(vec, vecA) + angle(vec, vecB), angle(vecA, vecB)))return true;\n\treturn false;\n}\n\nvector<point> crosspointSecS(const sector sec, const segment s) {\n\tcircle c = circle(sec.o, sec.r);\n\tauto ret = crosspointCL(c, s);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(eq(ret[i], inf))continue;\n\t\tif(!isOnSector(sec, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!intersectSP(s, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\nvector<point> crosspointSecSec(const sector sec1, const sector sec2) {\n\tcircle c1 = circle(sec1.o, sec1.r);\n\tcircle c2 = circle(sec2.o, sec2.r);\n\tauto ret = crosspointCC(c1, c2);\n\tpoint inf = point(INF, INF);\n\tREP(i, 2){\n\t\tif(!isOnSector(sec1, ret[i])){\n\t\t\tret[i] = inf;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isOnSector(sec2, ret[i])){\n\t\t\tret[i] = inf;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a + b) * 0.5;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (d.y < c.y) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (c.y <= m.y && m.y < d.y)  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= EPS) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tif(ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]) == -1)return false;\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (pt[i].y > pt[is].y) is = i;\n    if (pt[i].y < pt[js].y) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointSS(segment(A, B), l));\n  }\n  return Q;\n}\n\npoint max_circle_size_in_polygon_check(double mid, vector<point> &v){\n\tll n = v.size();\n\tvector<point> now(v);\n\tREP(i, n){\n\t\tauto a = v[i];\n\t\tauto b = v[(i+1)%n];\n\t\tauto vec = b - a;\n\t\tvec /= abs(vec);\n\t\tvec *= mid;\n\t\tvec = vec * point(0, 1);\n\t\tsegment seg = segment(a + vec, b + vec);\n\t\tnow = convex_cut(now, seg);\n\t}\n\treturn (now.empty() ? point(INF, INF): now[0]);\n}\n\n// 凸多角形に入る最大の円\ncircle max_circle_size_in_polygon(vector<point> &v){\n\tdouble l = 0;\n\tdouble r = convex_diameter(v);\n\tpoint ret;\n\tREP(_, 1000){\n\t\tif(abs(l - r) < EPS)break;\n\t\tdouble mid = (l + r) / 2;\n\t\tret = max_circle_size_in_polygon_check(mid, v);\n\t\tif(!eq(ret, point(INF, INF)))l = mid;\n\t\telse r = mid;\n\t}\n\treturn circle(ret, l);\n}\n\n//　三角形の外接円\ncircle circumscribed_circle(vector<point> p) {\n\tsegment seg_a = segment((p[1] + p[0]) * 0.5,\n\t(p[1] + p[0]) * 0.5 + (p[1] - p[0]) * point(0, 1));\n\tsegment seg_b = segment((p[2] + p[1]) * 0.5,\n\t(p[2] + p[1]) * 0.5 + (p[2] - p[1]) * point(0, 1));\n\tcircle ret;\n\tret.p = crosspointSS(seg_a, seg_b);\n\tret.r = distancePP(p[0], ret.p);\n\treturn ret;\n}\n\n// ################################### 3D ####################################\n\nstruct quaternion;\nquaternion conj(quaternion q);\nstruct point3d {\n\tdouble x, y, z;\n\tpoint3d():x(0), y(0), z(0){}\n\tpoint3d(const point3d &p):x(p.x), y(p.y), z(p.z){}\n\tpoint3d(const quaternion &q); // 先行宣言\n\tpoint3d(double x_, double y_, double z_):x(x_), y(y_), z(z_){}\n\n\tpoint3d& operator+=(point3d a){x += a.x;y += a.y;z += a.z;return *this;}\n\tpoint3d& operator-=(point3d a){x -= a.x;y -= a.y;z -= a.z;return *this;}\n\tpoint3d& operator*=(quaternion q); // 先行宣言\n\tpoint3d& operator*=(double a){x *= a;y *= a;z *= a;return *this;}\n\tpoint3d& operator/=(double a){x /= a;y /= a;z /= a;return *this;}\n\tpoint3d operator+(point3d a) const{return point3d(x, y, z)+=a;}\n\tpoint3d operator-(point3d a) const{return point3d(x, y, z)-=a;}\n\tpoint3d operator-() const{return point3d(-x, -y, -z);}\n\tpoint3d operator*(quaternion q); // 先行宣言\n\tpoint3d operator*(double a) const{return point3d(x, y, z)*=a;}\n\tpoint3d operator/(double a) const{return point3d(x, y, z)/=a;}\n\tbool operator<(point3d a) const{\n\t\treturn (x != a.x ? x < a.x : (y != a.y ? y < a.y : z < a.z));}\n};\n\ntemplate <class T>\npoint3d operator*(const T a, const point3d p){return p * a;}\n\nstruct segment3d: public array<point3d, 2> {\n\tsegment3d(const point3d &a, const point3d &b) {\n\t\tat(0) = a;\n\t\tat(1) = b;\n\t}\n};\n\ndouble abs(point3d p) {\treturn sqrt(p.x * p.x + p.y * p.y + p.z * p.z); }\ndouble norm(point3d p) {\treturn p.x * p.x + p.y * p.y + p.z * p.z; }\ndouble dot(point3d a, point3d b){\treturn a.x * b.x + a.y * b.y + a.z * b.z; }\npoint3d cross(point3d a, point3d b){\n\treturn point3d(a.y * b.z - a.z * b.y,\n\t\t\t\t\t\t\t\t a.z * b.x - a.x * b.z,\n\t\t\t\t\t\t\t   a.x * b.y - a.y * b.x);\n}\n\npoint3d projection(const segment3d &l, const point3d &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint3d reflection(const segment3d &l, const point3d &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\n\nbool intersect3dSP(const segment3d &s, const point3d &p) {\n\tauto a = s[0] - p;\n\tauto b = s[1] - p;\n\treturn (abs(cross(a, b)) < EPS && dot(a, b) <= EPS); // triangle inequality\n}\n\nbool intersect3dLP(const segment3d &l, const point3d &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n\ndouble angle(point3d a, point3d b){\n\tdouble tmp = dot(a, b) / (abs(a) * abs(b));\n\tif(tmp < -1)tmp = -1;\n\tif(tmp > 1)tmp = 1;\n\treturn acos(tmp);\n}\n\nstruct plane {\n\tdouble a, b, c, d;\n\tplane():a(0), b(0), c(0), d(0){}\n\tplane(double a_, double b_, double c_, double d_):a(a_), b(b_), c(c_), d(d_){}\n\tplane(point3d p1, point3d p2, point3d p3){\n\t\tpoint3d A = p2 - p1;\n\t\tpoint3d B = p3 - p1;\n\t\tpoint3d p = cross(A, B);\n\t\ta = p.x;b = p.y;c = p.z;\n\t\td = -(a * p1.x + b * p1.y + c * p1.z);\n\t}\n\tdouble assignment(point3d p){\n\t\treturn a * p.x + b * p.y + c * p.z + d;\n\t}\n};\n\ndouble distance(point3d p, plane pl){\n\tdouble a = abs(p.x * pl.a + p.y * pl.b + p.z * pl.c + pl.d);\n\tdouble b = sqrt(pl.a * pl.a + pl.b * pl.b + pl.c * pl.c);\n\treturn a / b;\n}\n\ndouble distance(plane p, point3d pl){\n\treturn distance(pl, p);\n}\n\npoint3d projection(point3d p, plane pl){\n\tdouble d = distance(p, pl);\n\tpoint3d a = point3d(pl.a, pl.b, pl.c);a /= abs(a);\n\tpoint3d ret = p + a * d;\n\tif(distance(ret, pl) < EPS)return ret;\n\treturn p - a * d;\n}\n\npoint3d crossPoint3d(segment3d s, plane p){\n\tdouble bunsi = p.a * s[0].x + p.b * s[0].y + p.c * s[0].z + p.d;\n\tdouble bunbo = p.a * (s[0].x - s[1].x) +\n\t\t\t\t\t\t\t\t p.b * (s[0].y - s[1].y) +\n\t\t\t\t\t\t\t\t p.c * (s[0].z - s[1].z);\n\tif(abs(bunbo) < EPS)return point3d(INF, INF, INF);\n\tdouble t = bunsi / bunbo;\n\treturn s[0] + (s[1] - s[0]) * t;\n}\n\nstruct quaternion {\n\tdouble x, y, z, w;\n\tquaternion():x(0), y(0), z(0){}\n\tquaternion(const point3d &p):x(p.x), y(p.y), z(p.z), w(0){}\n\tquaternion(double x_, double y_, double z_, double w_):x(x_), y(y_), z(z_), w(w_){}\n\t// ベクトルpを軸にrad回転させる\n\tquaternion(const point3d &p, double rad){\n\t\tassert(abs(p) > EPS);\n\t\tpoint3d np(p);np /= abs(np);\n\t\tx = np.x * sin(rad / 2);\n\t\ty = np.y * sin(rad / 2);\n\t\tz = np.z * sin(rad / 2);\n\t\tw = cos(rad / 2);\n\t}\n\tquaternion& operator*=(double a){x *= a;y *= a;z *= a;w *= a;return *this;}\n\tquaternion& operator/=(double a){x /= a;y /= a;z /= a;w /= a;return *this;}\n\tquaternion& operator*=(quaternion q){\n\t\tdouble xx = w * q.x + x * q.w - y * q.z + z * q.y;\n\t\tdouble yy = w * q.y + x * q.z + y * q.w - z * q.x;\n\t\tdouble zz = w * q.z - x * q.y + y * q.x + z * q.w;\n\t\tdouble ww = w * q.w - x * q.x - y * q.y - z * q.z;\n\t\t*this = quaternion(xx, yy, zz, ww);return *this;\n\t}\n\tquaternion operator*(quaternion q) const{return quaternion(x, y, z, w)*=q;}\n\tquaternion operator*(double a) const{return quaternion(x, y, z, w)*=a;}\n\tquaternion operator/(double a) const{return quaternion(x, y, z, w)/=a;}\n};\n\nquaternion conj(quaternion q) {\n\t return quaternion(-q.x, -q.y, -q.z, q.w);\n }\ndouble abs(quaternion q) {\n\treturn sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);\n}\nquaternion normalization(quaternion q){\n\treturn q / abs(q);\n}\n\npoint3d::point3d(const quaternion &q):x(q.x), y(q.y), z(q.z){}\npoint3d& point3d::operator*=(quaternion q){\n\tnormalization(q);\n\t*this = point3d(q * quaternion(*this) * conj(q));\n\treturn *this;\n}\npoint3d point3d::operator*(quaternion q){ return point3d(x, y, z)*= q; }\n\n// vecへ平行移動\nvoid translation(vector<point3d> &p, point3d vec){\n\tREP(i, p.size())p[i] += vec;\n}\n\nvoid scale(vector<point3d> &p, double s){\n\tREP(i, p.size())p[i] *= s;\n}\n\n// pをaxisを軸にaからbまで回転する\nvoid RotateWithAngleAxis(vector<point3d> &p, segment3d axis, point3d a, point3d b) {\n\tpoint3d tmp = axis[0];\n\ttranslation(p, -tmp);\n\taxis[0] -= tmp;axis[1] -= tmp;\n\ta -= tmp;b -= tmp;\n\n\tpoint3d avec = a - projection(axis, a);\n\tpoint3d bvec = b - projection(axis, b);\n\tif(abs(avec) < EPS || abs(bvec) < EPS){\n\n\t}\n\telse if(eq(abs(cross(avec, bvec)), 0)){\n\t\tquaternion q = quaternion(axis[1], angle(avec, bvec));\n\t\tREP(i, p.size())p[i] *= q;\n\t}\n\telse{\n\t\tquaternion q = quaternion(cross(bvec, avec), angle(avec, bvec));\n\t\tREP(i, p.size())p[i] *= q;\n\t}\n\n\ttranslation(p, tmp);\n\taxis[0] += tmp;axis[1] += tmp;\n\ta += tmp;b += tmp;\n}\n\n// ################################### 3D ####################################\n// ################################### IO ####################################\n\nistream& operator>>(std::istream& is, point3d& p){\n\tis >> p.x >> p.y >> p.z;\n\treturn is;\n}\n\nostream& operator<<(ostream& os, const point3d& p){\n\tos << p.x << \" \" << p.y << \" \" << p.z;\n\treturn os;\n}\n\nostream& operator<<(ostream& os, const quaternion& q){\n\tos << q.x << \" \" << q.y << \" \" << q.z << \" \" << q.w;\n\treturn os;\n}\n\nostream& operator<<(ostream& os, const plane& p){\n\tos << p.a << \"x + \" << p.b << \"y + \" << p.c << \"z + \" << p.d;\n\treturn os;\n}\n\nistream& operator>>(std::istream& is, point& p){\n\tis >> p.x >> p.y;\n  return is;\n}\n\nostream& operator<<(ostream& os, const point& p){\n\tos << p.x << \" \" << p.y;\n\treturn os;\n}\n\n// ################################### IO ####################################\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tpoint a, b, c, d;\n\tdouble r;\n\twhile(cin >> a, !eq(abs(a), 0)) {\n\t\tcin >> b >> c >> d >> r;\n\t\tvector<point> v({a, b, c});\n\n\t\tsegment sega(a, b);\n\t\tsegment segb(b, c);\n\t\tsegment segc(a, c);\n\t\tcircle cir(d, r);\n\n\t\tif(r < EPS + distanceSP(sega, d) &&\n\t\t\t r < EPS + distanceSP(segb, d) &&\n\t\t   r < EPS + distanceSP(segc, d) && contains(v, d) != 0){\n\t\t  cout << \"a\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(abs(a - d) <= EPS + r && abs(b - d) <= EPS + r && abs(c - d) < EPS + r){\n\t\t\tcout << \"b\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool flag = true;\n\t\tREP(i, 3){\n\t\t\tif(!flag)break;\n\t\t\tsegment seg(v[i], v[(i+1)%3]);\n\t\t\tauto ps = crosspointCL(cir, seg);\n\t\t\tREP(j, 2){\n\t\t\t\tauto p = ps[j];\n\t\t\t\tif(eq(p, point(INF, INF)))continue;\n\t\t\t\tif(intersectSP(seg, p)){\n\t\t\t\t\tcout << \"c\" << endl;\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag)cout << \"d\" << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define EPS (1e-10)\nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n\n  bool operator < (const Point& p) const\n  {\n    return x != p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nstruct Circle\n{\n  Point p;\n  double r;\n  Circle(Point p=Point(0,0),double r=0):p(p),r(r){}\n};\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Point a)\n{\n  return sqrt(norm(a));\n}\n\ndouble getDistancePP(Point p1,Point p2)\n{\n  return sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2));\n}\n\nbool isTriangleInCircle(Point p1,Point p2,Point p3,Point s1,double r)\n{\n  double d1,d2,d3;\n  d1 = getDistancePP(p1,s1);\n  d2 = getDistancePP(p2,s1);\n  d3 = getDistancePP(p3,s1);\n  return d1 <= r && d2 <= r && d3 <= r;\n}\n\ndouble getDistanceLP(Line s,Point p)\n{\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistancePS(Point p,Segment s)\n{\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isPointInCircle(Point *p,Circle c)\n{\n  return (ccw(*p,*(p+1),c.p) == CLOCKWISE && ccw(*(p+1),*(p+2),c.p) == CLOCKWISE && ccw(*(p+2),*p,c.p) == CLOCKWISE) || (ccw(*p,*(p+1),c.p) == COUNTER_CLOCKWISE && ccw(*(p+1),*(p+2),c.p) == COUNTER_CLOCKWISE && ccw(*(p+2),*p,c.p) == COUNTER_CLOCKWISE);\n}\n\nvoid printP(Point p)\n{\n  cout << p.x << \" x \" << p.y << endl; \n}\n\nint main()\n{\n  Point T[3];\n  while(cin >> T[0].x >> T[0].y,(int)T[0].x|(int)T[0].y)\n    {\n      for(int i=1;i<=2;i++)\n\tcin >> T[i].x >> T[i].y;     \n      Circle c;\n      cin >> c.p.x >> c.p.y;\n      cin >> c.r;\n\n      double dist[3];\n      dist[0] = getDistancePS(c.p,Segment(T[0],T[1]));\n      dist[1] = getDistancePS(c.p,Segment(T[1],T[2]));\n      dist[2] = getDistancePS(c.p,Segment(T[2],T[0]));\n\n      //cout << \"isPointInCircle? \" << isPointInCircle(T,c) << endl;\n      //cout << ccw(T[0],T[1],c.p) << endl;\n      //cout << ccw(T[1],T[2],c.p) << endl;\n      //cout << ccw(T[2],T[0],c.p) << endl;\n      //cout << \"----------------\" << endl;\n      //cout << dist[0] << endl;     \n      //cout << dist[1] << endl;     \n      //cout << dist[2] << endl;     \n\n      if(isTriangleInCircle(T[0],T[1],T[2],c.p,c.r))\n\tcout << 'b' << endl;\n      else if(isPointInCircle(T,c) && dist[0] >= c.r && dist[1] >= c.r && dist[2] >= c.r)\n\tcout << 'a' << endl;\n      else if(dist[0] <= c.r || dist[1] <= c.r || dist[2] <= c.r)\n\tcout << 'c' << endl;\n      else \n\tcout << 'd' << endl;      \n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Point{\n  double x, y;\n  Point(){ x = 0; y = 0; }\n  Point(double x_, double y_){ x = x_; y = y_; }\n  void SetPoint(double x_, double y_){ x = x_; y = y_; }\n};\n\nstruct Line{\n  double a, b, c;\n  Line(){ a = 0; b = 0; c = 0; }\n  Line(double a_, double b_, double c_){ a = a_; b = b_; c = c_; }\n  void SetLine(double a_, double b_, double c_){ a = a_; b = b_; c = c_; }\n};\n\nstruct Circle{\n  double x, y, r;\n  Circle(){ x = 0; y = 0; r = 0; }\n  Circle(double x_, double y_, double r_){ x = x_; y = y_; r = r_; }\n  void SetCircle(double x_, double y_, double r_){ x = x_; y = y_; r = r_; }\n};\n\ndouble GetDistance(const Point a, const Point b){\n  return sqrt(pow(a.x-b.x, 2) + pow(a.y-b.y, 2));\n}\n\nLine GetStraightLine(const Point& a, const Point& b){\n  Line l;\n  double x = a.x - b.x;\n  double y = a.y - b.y;\n  l.SetLine(y, -x, x*a.y - y*a.x);\n  return l;\n}\n\nbool IsAttached(const Circle& c, const Line& l){\n  double d = abs(l.a*c.x + l.b*c.y + l.c)/(sqrt(pow(l.a, 2) + pow(l.b, 2)));\n  if(d < c.r) return true;\n  else return false;\n}\n\nchar Solved(const Point& a, const Point& b,\n\t    const Point& c, const Circle& cir){\n  Point center(cir.x, cir.y);\n\n  if(cir.r >= GetDistance(center, a) && cir.r >= GetDistance(center, b) &&\n     cir.r >= GetDistance(center, c)) return 'b';\n\n  Line ab = GetStraightLine(a, b);\n  Line bc = GetStraightLine(b, c);\n  Line ca = GetStraightLine(c, a);\n\n  if(IsAttached(cir, ab) || IsAttached(cir, ab) || IsAttached(cir, ab)) return 'c';\n\n  double max_x = max(a.x, max(b.x, c.x));\n  double min_x = min(a.x, min(b.x, c.x));\n  double max_y = max(a.y, max(b.y, c.y));\n  double min_y = min(a.y, min(b.y, c.y));\n\n  if(min_x <= cir.x - cir.r && cir.x + cir.r <= max_x &&\n     min_y <= cir.y - cir.r && cir.y + cir.r <= max_y) return 'a';\n\n  return 'd';\n}\n\nint main(){\n  Point a, b, c;\n  Circle cir;\n\n  while(1){\n    cin >> a.x >> a.y;\n    if(a.x == 0 && a.y == 0) break;\n    cin >> b.x >> b.y;\n    cin >> c.x >> c.y;\n    cin >> cir.x >> cir.y >> cir.r;\n    cout << Solved(a, b, c, cir) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r&&!EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r&&!EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r&&!EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t&&((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <vector>\n\nusing namespace std;\n\n//-------------------------------------------------------------------------\n// geometric library\n \nnamespace geometry {\n \n#define EPS 1E-10 ///< 0とみなすサイズ。適当\n \n    struct point {\n        double x;\n        double y;\n \n\t\tpoint() {}\n\t\tpoint(double x, double y) : x(x), y(y) {}\n        point& operator += (const point& rhs) { x += rhs.x; y += rhs.y; return *this; }\n        point& operator -= (const point& rhs) { x -= rhs.x; y -= rhs.y; return *this; }\n        point& operator /= (double factor) { x /= factor; y /= factor; return *this; }\n        point& operator *= (double factor) { x *= factor; y *= factor; return *this; }\n        bool operator == (const point& rhs) const { return (std::abs(x - rhs.x) < EPS) && (std::abs(y - rhs.y) < EPS); }\n        bool operator != (const point& rhs) const { return !(*this == rhs); }\n        bool operator <= (const point& rhs) const { return x < rhs.x || (x == rhs.x && y <= rhs.y); }\n        bool operator >= (const point& rhs) const { return x > rhs.x || (x == rhs.x && y >= rhs.y); }\n        bool operator < (const point& rhs) const { return !(*this >= rhs); }\n        bool operator > (const point& rhs) const { return !(*this <= rhs); }\n\t\tdouble arg() const { return atan2(y, x); }\n        double norm() const { return sqrt(x * x + y * y); }\n\t\tpoint get_normal() const { return point(-y, x); }\n    };\n\ttypedef point vec2d;\n \n    struct circle {\n        point center;\n        double radius;\n\t\tcircle() {}\n\t\tcircle(double x, double y, double r) : center(x, y), radius(r) {}\n    };\n \n\tstruct triangle {\n\t\tpoint p[3];\n\t};\n \n    enum rotate_dir {\n        rotate_None = 0,\n        rotate_CW = 1,\n        rotate_CCW = -1\n    };\n \n    point operator + (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p += p2;\n        return p;\n    }\n \n    point operator / (const point& p1, double factor)\n    {\n        point p(p1);\n        p /= factor;\n        return p;\n    }\n  \n    point operator * (const point& p1, double factor)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator * (double factor, const point& p1)\n    {\n        point p(p1);\n        p *= factor;\n        return p;\n    }\n \n    point operator - (const point& p1, const point& p2)\n    {\n        point p(p1);\n        p -= p2;\n        return p;\n    }\n \n    std::istream& operator >> (std::istream& is, point& p)\n    {\n        is >> p.x >> p.y;\n        return is;\n    }\n\n    std::istream& operator >> (std::istream& is, circle& c)\n    {\n        is >> c.center >> c.radius;\n        return is;\n    }\n\n    ///! 2点の距離\n    double get_distance(const point& p1, const point& p2)\n    {\n        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n    }\n \n    double cross_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.y - p2.x * p1.y;\n    }\n \n    double inner_product(const point& p1, const point& p2)\n    {\n        return p1.x * p2.x + p1.y * p2.y;\n    }\n\n\t///! 直線s-eにpを投影した点を求める\n\tpoint get_project(const point& s, const point& e, const point& p)\n\t{\n\t\tdouble scale = inner_product(p - s, e - s) / (e - s).norm();\n\t\treturn s + scale * (e - s) / (e - s).norm();\n\t}\n\n     ///! pがs-e間(s,e上含む)にあればtrue\n    bool is_inter_point(const point& s, const point& e, const point& p) {\n        double d = get_distance(s, p) + get_distance(p, e) - get_distance(s, e);\n        return abs(d) < EPS;\n    }\n \n    ///! p1-p2-p3が左右どちらの方向に折れているかを判定\n    rotate_dir direction(const point& p1, const point& p2, const point& p3)\n    {\n        point p1_p3 = p1 - p3;\n        point p2_p3 = p2 - p3;\n        double cross = cross_product(p1_p3, p2_p3);\n \n        if (std::abs(cross) < EPS) {\n            return rotate_None;\n        }\n        else if (cross > 0) {\n            return rotate_CW;\n        }\n        else {\n            return rotate_CCW;\n        }\n    }\n\n\tbool is_inside_circle(const point& p, const circle& c)\n\t{\n\t\treturn get_distance(p, c.center) <= c.radius + EPS;\n\t}\n\n\tbool is_inside_circle(const triangle& t, const circle& c)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (!is_inside_circle(t.p[i], c)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n \n    ///! (p1s, p1e)と(p2s, p2e)の線分交差判定.EPS以下で接している場合はtrue、重なっている場合はfalse\n    bool intersect(const point& p1s, const point& p1e, const point& p2s, const point& p2e)\n    {\n        assert(p1s != p1e && p2s != p2e);\n        return\n            (direction(p1s, p1e, p2s) != direction(p1s, p1e, p2e)) &&\n            (direction(p2s, p2e, p1s) != direction(p2s, p2e, p1e));\n    }\n\n\t///! 円と三角形が交差するかどうか\n\tbool intersect(const circle& c, const triangle& t)\n\t{\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tpoint ps = t.p[i], pe = t.p [(i + 1) % 3];\n\n\t\t\tif (is_inside_circle(ps, c) != is_inside_circle(pe, c)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (is_inside_circle(ps, c) && is_inside_circle(pe, c)) {\n\t\t\t\tcontinue; // この辺は交差しない\n\t\t\t}\n\t\t\tpoint m = get_project(ps, pe, c.center);\n\n\t\t\tif (get_distance(m, c.center) <= c.radius + EPS && is_inter_point(ps, pe, m)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} \n\n    ///! targetが三角形p1,p2,p3の内部にあるかどうか\n    bool is_inside_triangle(const point& target, const point& p1, const point& p2, const point& p3)\n    {\n        point center_of_gravity = (p1 + p2 + p3) / 3; // 重心\n \n        if (center_of_gravity == target) return true;\n \n        // 重心とtargetを結んだ線分が三角形の辺と交叉するなら、点は三角形の外部にある\n        bool intersect_any =\n            intersect(p1, p2, center_of_gravity, target) ||\n            intersect(p2, p3, center_of_gravity, target) ||\n            intersect(p3, p1, center_of_gravity, target);\n \n        return !intersect_any;\n    }\n\n\tbool is_inside_triangle(const point& target, const triangle& t)\n\t{\n\t\treturn is_inside_triangle(target, t.p[0], t.p[1], t.p[2]);\n\t}\n \n\tbool is_inside_triangle(const circle& c, const triangle& t)\n\t{\n\t\tif (!is_inside_triangle(c.center, t)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tpoint m = get_project(t.p[i], t.p [(i + 1) % 3], c.center);\n\n\t\t\tif (get_distance(m, c.center) < c.radius - EPS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n \n} // namespace geometry\n\n\n//-----------------------------------------------\n//\n\nusing namespace geometry;\n\nchar solve(const triangle& triangle, const circle& circle) {\n\tif (is_inside_triangle(circle, triangle)) {\n\t\treturn 'a';\n\t} else if (is_inside_circle(triangle, circle)) {\n\t\treturn 'b';\n\t} else if (intersect(circle, triangle)) {\n\t\treturn 'c';\n\t} else {\n\t\treturn 'd';\n\t}\n}\n\nint main(void) {\n\ttriangle triangle;\n\tcircle circle;\n\tint n = 1;\n\n\twhile (cin >> triangle.p[0]) {\n\t\tif (triangle.p[0].x == 0 && triangle.p[0].y == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> triangle.p[1] >> triangle.p [2] >> circle;\n\n\t\tcout << solve(triangle, circle) << endl;\n\t\tn++;\n\t}\n}\n\n//-----------------------------------------------\n// tests\n\nstatic bool check_impl(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int r, char expect)\n{\n\ttriangle t;\n\tcircle c;\n\n\tt.p[0].x = x1; t.p [0].y = y1;\n\tt.p[1].x = x2; t.p [1].y = y2;\n\tt.p[2].x = x3; t.p [2].y = y3;\n\tc.center.x = x4; c.center.y = y4;\n\tc.radius = r;\n\n\tchar result = solve(t, c);\n\treturn result == expect;\n}\n\nstatic void check(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int r, char expect)\n{\n\tassert(check_impl(x1, y1, x2, y2, x3, y3, x4, y4, r, expect));\n\tassert(check_impl(x2, y2, x3, y3, x1, y1, x4, y4, r, expect));\n\tassert(check_impl(x3, y3, x1, y1, x2, y2, x4, y4, r, expect));\n}\n\nstatic void test()\n{\n\t// 三角形が円に含まれる\n\tcheck(5, 5, 15, 5, 10, 10, 10, 10, 8, 'b');\n\t// 円が三角形に含まれる\n\tcheck(5, 5, 15, 5, 10, 20, 10, 10, 3, 'a');\n\t// 共通部分あり\n\tcheck(3, 12, 9, 3, 11, 12, 8, 7, 5, 'c');\n\t// 共通部分なし\n\tcheck(15, 3, 17, 7, 22, 5, 7, 6, 4, 'd');\n\n\t// 3頂点とも円周上\n\tcheck(5, 5, 15, 5, 10, 10, 10, 5, 5, 'b');\n\t// 2頂点が円周上、1頂点が円の外部\n\tcheck(5, 5, 15, 5, 10, 11, 10, 5, 5, 'c');\n\t// 2頂点が円周上、1頂点が円の内部\n\tcheck(5, 5, 15, 5, 10, 9, 10, 5, 5, 'b');\n\t// 1頂点が円周上、2頂点が円の外部\n\tcheck(15, 5, 20, 5, 20, 20, 10, 5, 5, 'c');\n\t// 1頂点が円周上、2頂点が円の内部\n\tcheck(15, 5, 20, 5, 20, 20, 10, 5, 5, 'c');\n\n\t// 円が3角形の内部、1辺が円に接している\n\tcheck(5, 5, 5, 20, 15, 20, 7, 15, 2, 'a');\n\t// 円が3角形の内部、2辺が円に接している\n\tcheck(5, 5, 5, 20, 30, 20, 8, 17, 3, 'a');\n\t// 円が3角形の外部、1辺が円に接している\n\tcheck(5, 5, 15, 5, 15, 25, 20, 20, 5, 'c');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nclass Vector2\n{\npublic:\n\tdouble length() const\n\t{\n\t\treturn sqrt( static_cast<double>( x * x + y * y ) );\n\t}\n\tint clossProduct( const Vector2& v ) const\n\t{\n\t\treturn this->x * v.y - this->y * v.x;\n\t}\n\tVector2 operator-( const Vector2& v ) const\n\t{\n\t\tVector2 ret;\n\t\tret.x = this->x - v.x;\n\t\tret.y = this->y - v.y;\n\t\treturn ret;\n\t}\n\n\tint x, y;\n};\n\nint main()\n{\n\tVector2 tri[ 3 ];\n\tVector2 cir;\n\tint cirR;\n\n\twhile( cin >> tri[ 0 ].x >> tri[ 0 ].y && !( !tri[ 0 ].x && !tri[ 0 ].y ) ){\n\t\tfor( int i = 1; i < 3; ++i ){\n\t\t\tcin >> tri[ i ].x >> tri[ i ].y;\n\t\t}\n\t\tcin >> cir.x >> cir.y;\n\t\tcin >> cirR;\n\n\t\tint flags = 0;\n\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\tVector2 ao = cir - tri[ i ];\n\t\t\tVector2 ab = tri[ ( i + 1 ) % 3 ] - tri[ i ];\n\t\t\tdouble distance = abs( ab.clossProduct( ao ) ) / ab.length();\n\t\t\tif( distance >= cirR ){\n\t\t\t\tflags |= ( 1 << i );\n\t\t\t}\n\t\t}\n\n\t\tchar result;\n\t\tif( flags == 7 ){\n\t\t\tint dir = 0;\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tVector2 oa = tri[ i ] - cir;\n\t\t\t\tVector2 ob = tri[ ( i + 1 ) % 3 ] - cir;\n\t\t\t\tif( oa.x * ob.y > oa.y * ob.x ){\n\t\t\t\t\tdir |= ( 1 << i );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dir % 7 == 0 ){\n\t\t\t\tresult = 'a';\n\t\t\t}else{\n\t\t\t\tresult = 'd';\n\t\t\t}\n\t\t}else if( flags == 0 ){\n\t\t\tint dir = 0;\n\t\t\tfor( int i = 0; i < 3; ++i ){\n\t\t\t\tVector2 oa = tri[ i ] - cir;\n\t\t\t\tif( oa.length() <= cirR ){\n\t\t\t\t\tdir |= ( 1 << i );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( dir == 7 ){\n\t\t\t\tresult = 'b';\n\t\t\t}else{\n\t\t\t\treturn 'c';\n\t\t\t}\n\t\t}else{\n\t\t\tresult = 'c';\n\t\t}\n\n\t\tcout << result << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n//      getline(ifs, str);\n        cin >> str;\n\n      if(str == \"0 0\\n\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n        str.back() = '\\0';\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\\n\") break;\n\n\n    if(distance(&d->p[0], &c->p) <= c->radius&& distance(&d->p[1], &c->p) <= c->radius&& distance(&d->p[2], &c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) >= c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) >= c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) >= c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) <= distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) <= distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) <= distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else\n            cout << 'a' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) <= c->radius|| dist_line(&d->p[0], &d->p[2], &c->p) <= c->radius|| dist_line(&d->p[1], &d->p[2], &c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <fstream>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\ntypedef complex<double> P;\n\nint chk(P a,P b,double r){\n\tdouble t = abs(a-b) - r;\n\tif( fabs(t) < EPS ) return 0;\n\treturn t < 0 ? -1 : 1;\n}\ndouble cross(P a,P b){\n\treturn imag(a*conj(b));\n}\n\n\nint main(){\n\tP a,b,c,d;\n\tdouble r;\n\twhile(cin >> a.real() >> a.imag() , a.real() != 0 || a.imag() != 0 ){\n\t\tcin >> b.real() >> b.imag();\n\t\tcin >> c.real() >> c.imag();\n\t\tcin >> d.real() >> d.imag();\n\t\tcin >> r;\n\t\t\n\t\tint in = 0;\n\t\tint mk = cross(a-d,b-d) <= 0 ;\n\t\tif( mk == (cross(b-d,c-d) <= 0) && mk == (cross(c-d,a-d) <= 0)){\n\t\t\tin = 1;\n\t\t}\n\t\t\n\t\tif( chk(a,d,r) <= 0 &&  chk(b,d,r) <= 0 &&  chk(c,d,r) <= 0 ){\n\t\t\tcout << \"b\" << endl;\n\t\t}else if( chk(a,d,r) >= 0 &&  chk(b,d,r) >= 0 &&  chk(c,d,r) >= 0){\n\t\t\tif( in ){\n\t\t\t\tcout << \"a\" << endl;\n\t\t\t}else{\n\t\t\t\tcout << \"d\" << endl;\n\t\t\t}\n\t\t}else{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\n\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n      getline(cin, str);\n\n      if(i == 0 && str == \"0 0\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\") break;\n\n\n    if(distance(&d->p[0], &c->p) < c->radius&& distance(&d->p[1], &c->p) < c->radius&& distance(&d->p[2], &c->p) < c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) > c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) > c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) > c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) < distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) < distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) < distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else\n            cout << 'a' << endl;\n    }\n    else{\n      cout << 'c' << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-7\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0,double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n  Point operator * (double a){ return Point(x*a, y*a); }\n  Point operator / (double a){ return Point(x/a, y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nclass Segment{\npublic:\n  Vector t,s;\n  Segment(Vector t,Vector s) : t(t),s(s) {}\n};\n\nclass Circle{\npublic:\n  double x,y,r;\n  Circle(double x = 0.0,double y = 0.0,double r = 0.0) : x(x),y(y),r(r) {}\n};\n\nPoint point[3];\nCircle ci;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nbool check(){\n  Point cp = Point(ci.x,ci.y);\n  int c1 = ccw(point[0],point[1],cp);\n  int c2 = ccw(point[1],point[2],cp);\n  int c3 = ccw(point[2],point[0],cp);\n  return (c1 == c2 && c2 == c3);\n}\n\ntypedef Segment Line;\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.s-l.t,p-l.t)/(l.s-l.t).abs());\n}\n\ndouble getDistanceSP(Segment seg,Point p){\n  if(dot(seg.s-seg.t,p-seg.t) < 0.0) return (p-seg.t).abs();\n  if(dot(seg.t-seg.s,p-seg.s) < 0.0) return (p-seg.s).abs(); \n  return getDistanceLP(seg,p);\n}\n\nint getStateCS(Circle c,Segment seg){\n  Point cp = Point(c.x,c.y);\n  if(getDistanceSP(seg,cp)+EPS > c.r){\n    return 1;\n  }else if(getDistanceSP(seg,cp)+EPS < c.r){\n      return 2;\n  }\n  return 3;\n}\n\nbool isCross(){\n  Point cp = Point(ci.x,ci.y);\n  for(int i = 0 ; i < 3 ; i++){\n    Point p = point[i];\n    Point diff = p - cp;\n    if(diff.abs() == ci.r) return true;\n  }\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  \n  for(int i = 0 ; i < 3 ; i++){\n    if(getDistanceSP(seg[i],cp)+EPS < ci.r){\n      return true;\n    }\n  }\n\n  for(int i = 0 ; i < 3 ; i++){\n    Segment ns = seg[i];\n    Point p1 = ns.t, p2 = ns.s;\n    if(p1.abs() < ci.r && p2.abs() > ci.r) return true;\n    if(p1.abs() > ci.r && p2.abs() < ci.r) return true;\n  }\n\n  return false;\n}\n\nvoid judge(){\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n\n  int CinT = 0,TinC = 0;\n  for(int i = 0 ; i < 3 ; i++){\n    int N = getStateCS(ci,seg[i]);\n    if(N == 1){\n      CinT++;\n    }else if(N == 2){\n      TinC++;\n    }\n  }\n\n  if(CinT == 3 && check()){\n    cout << 'a' << endl;\n  }else if(TinC == 3){\n    cout << 'b' << endl;\n  }else{\n    if(isCross()){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}\n\nint main(){\n  while(true){\n    cin >> point[0].x >> point[0].y;\n    if(!point[0].x && !point[0].y) break;\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> point[i+1].x >> point[i+1].y;\n    }\n    cin >> ci.x >> ci.y >> ci.r;\n    judge();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\n#define EPS 1e-7\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x = 0.0,double y = 0.0) : x(x),y(y) {}\n  Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n  Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n  Point operator * (double a){ return Point(x*a, y*a); }\n  Point operator / (double a){ return Point(x/a, y/a); }\n  double abs(){ return sqrt(norm()); }\n  double norm(){ return x*x + y*y; }\n};\n\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\nclass Segment{\npublic:\n  Vector t,s;\n  Segment(Vector t,Vector s) : t(t),s(s) {}\n};\n\nclass Circle{\npublic:\n  double x,y,r;\n  Circle(double x = 0.0,double y = 0.0,double r = 0.0) : x(x),y(y),r(r) {}\n};\n\nPoint point[3];\nCircle ci;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return 1;\n  if(cross(a,b) < -EPS) return -1;\n  if(dot(a,b) < -EPS) return 2;\n  if(a.norm() < b.norm()) return -2;\n  return 0;\n}\n\nbool check(){\n  Point cp = Point(ci.x,ci.y);\n  int c1 = ccw(point[0],point[1],cp);\n  int c2 = ccw(point[1],point[2],cp);\n  int c3 = ccw(point[2],point[0],cp);\n  return (c1 == c2 && c2 == c3);\n}\n\ntypedef Segment Line;\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.s-l.t,p-l.t)/(l.s-l.t).abs());\n}\n\ndouble getDistanceSP(Segment seg,Point p){\n  if(dot(seg.s-seg.t,p-seg.t) < 0.0) return (p-seg.t).abs();\n  if(dot(seg.t-seg.s,p-seg.s) < 0.0) return (p-seg.s).abs(); \n  return getDistanceLP(seg,p);\n}\n\nint getStateCS(Circle c,Segment seg){\n  Point cp = Point(c.x,c.y);\n  if(getDistanceSP(seg,cp) >= c.r){\n    return 1;\n  }\n  return 3;\n}\n\nbool isCross(){\n  Point cp = Point(ci.x,ci.y);\n\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  int cnt = 0;\n  for(int i = 0 ; i < 3 ; i++){\n    if(getDistanceSP(seg[i],cp) > ci.r){\n      cnt++;\n    }\n  }\n\n  if(cnt == 3 && !check()) return false;\n  return true;\n}\n\nvoid judge(){\n  Segment seg[3] = {\n    Segment(point[0],point[1]),\n    Segment(point[1],point[2]),\n    Segment(point[2],point[0])\n  };\n  Point cp = Point(ci.x,ci.y);\n  int TinC = 0;\n  for(int i = 0 ; i < 3 ; i++,TinC++){\n    if((point[i]-cp).abs() > ci.r){\n      break;\n    }\n  }\n\n  if(TinC == 3){\n    cout << 'b' << endl;\n    return;\n  }\n\n  int CinT = 0;\n  for(int i = 0 ; i < 3 ; i++){\n    if(getStateCS(ci,seg[i]) == 1){\n      CinT++;\n    }\n  }\n\n  if(CinT == 3 && check()){\n    cout << 'a' << endl;\n  }else{\n    if(isCross()){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}\n\nint main(){\n  while(true){\n    cin >> point[0].x >> point[0].y;\n    if(!point[0].x && !point[0].y) break;\n    for(int i = 0 ; i < 2 ; i++){\n      cin >> point[i+1].x >> point[i+1].y;\n    }\n    cin >> ci.x >> ci.y >> ci.r;\n    judge();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\ntypedef long long ll;\nusing namespace std;\n \nstruct Pos{\n    double x,y;\n    Pos(double x,double y) : x(x) , y(y) {}\n    Pos(){}\n};\n \nstruct Triangle{\n    Pos pos[3];\n};\nstruct Circle{\n    Pos pos;\n    double r;\n};\n \nstatic const double kyuriEPS = 1e-4;\ntypedef std::complex<double> myPoint;\ndouble dot(const myPoint& a, const myPoint& b) {return real(conj(a)*b);}\nstruct myL : public std::vector<myPoint> {\n    myL(const myPoint &a, const myPoint &b) {push_back(a); push_back(b);}\n};\n \nbool intersectSP(const myL &s, const myPoint &p) {\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < kyuriEPS;\n} \nmyPoint projection(const myL &l, const myPoint &p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);\n}\n \ndouble distanceSP(const myL &s, const myPoint &p) {\n    const myPoint r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return std::min(abs(s[0] - p), abs(s[1] - p));\n}\n//ct\nint judgeHit(const Circle &c,const Triangle &t){\n    int counter = 0 , ctt = 0;\n    for(int i = 0 ; i < 3 ; i++){\n        if( abs(myPoint(c.pos.x,c.pos.y)-myPoint(t.pos[i].x,t.pos[i].y)) < c.r - kyuriEPS ){\n            ctt++;\n        }\n    }\n    if( ctt == 3 ) return 1;\n\tif( ctt >= 1 ) return 2;\n    for(int i = 0 ; i < 3 ; i++){\n        double dist = distanceSP(myL(myPoint(t.pos[i].x,t.pos[i].y),myPoint(t.pos[(i+1)%3].x,t.pos[(i+1)%3].y)),myPoint(c.pos.x,c.pos.y));\n        if( dist <= c.r + kyuriEPS){\n            counter++;\n        }\n    }\n    if( counter >= 1 ) return 2;\n     \n\tdouble tS2 = fabs( (t.pos[1].x-t.pos[0].x)*(t.pos[2].y-t.pos[0].y) - (t.pos[1].y-t.pos[0].y)*(t.pos[2].x-t.pos[0].x) );\n\t\n\t// a.pos[i] on B\n\tdouble area = 0;\n\tfor(int j = 0 ; j < 3 ; j++){\n\t\tarea += fabs( (t.pos[j].x-c.pos.x)*(t.pos[(j+1)%3].y-c.pos.y) - (t.pos[j].y-c.pos.y)*(t.pos[(j+1)%3].x-c.pos.x) );\n\t}\n\t//std::cout << area << \" \" << tS2 << std::endl;\n\t\n\tif( fabs( fabs(area) - tS2 ) < kyuriEPS ) return 0; \t\n\t\n\treturn 3;\n}\n \nint main(){\n    Triangle t;\n    Circle c;\n    while(cin >> t.pos[0].x >> t.pos[0].y && (t.pos[0].x||t.pos[0].y)){\n        for(int i = 1 ; i < 3 ; i++)\n            cin >> t.pos[i].x >> t.pos[i].y;\n        cin >> c.pos.x >> c.pos.y >> c.r;\n        cout << (char)('a'+judgeHit(c,t)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\ttypedef double R;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n\ttypedef complex<R> P;\n\tistream& operator>>(istream &is, P &p) {\n\t\tR x, y;\n\t\tis >> x >> y;\n\t\tp = P(x, y);\n\t\treturn is;\n\t}\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tP dir()const {return SELF[1] - SELF[0];}\n\t\tfriend istream& operator>>(istream &is, L &l) {\n\t\t\tP p1, p2;\n\t\t\tis >> p1 >> p2;\n\t\t\tl = L(p1, p2);\n\t\t\treturn is;\n\t\t}\n\t\tbool online(const P &p)const {return !sig(outp(p-SELF[0], dir()));}\n\t\tR distance(const P &p)const {return abs(outp(dir(), p - SELF[0])) / abs(dir());}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tbool online(const P &p){return !sig(abs(SELF[0]-p) + abs(SELF[1] - p) - abs(SELF[0] - SELF[1]));}\n\t\tfriend inline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\t\tR distance(const P &p)const {\n\t\t\tif(inp(p-SELF[0],  dir()) < EPS) return abs(p - SELF[0]);\n\t\t\tif(inp(p-SELF[1], -dir()) < EPS) return abs(p - SELF[1]);\n\t\t\treturn L::distance(p);\n\t\t}\n\t};\n\n\tstruct C : public P{\n\t\tR r;\n\t\tfriend istream& operator>>(istream &is, C &c) {\n\t\t\toperator>>(is, (P &)c);\n\t\t\tis >> c.r;\n\t\t\treturn is;\n\t\t}\n\t\tbool inside(const P& p)const { return abs(p-SELF) < r - EPS;}\n\t\tbool inside2(const P& p)const { return abs(p-SELF) < r + EPS;}\n\t\tfriend inline bool cc_intersect(const C &a, const C &b){return abs(a-b)<a.r+b.r+EPS && abs(a-b)>abs(a.r - b.r)-EPS;}\n\t\tfriend inline bool cl_intersect(const C &c, const L &l){return l.distance(c) < c.r + EPS;}\n\t\tfriend inline bool cs_intersect(const C &c, const S &s){return (!c.inside(s[0]) || !c.inside(s[1])) && s.distance(c) < c.r - EPS;}\n\t\tfriend inline bool cs_intersect2(const C &c, const S &s){return (!c.inside(s[0]) || !c.inside(s[1])) && s.distance(c) < c.r + EPS;}\n\t};\n\t\n\tstruct G : public vector<P>{\n\t\tenum {OUT, IN, ON};\n\t\tS edge(int i)const {return S(at(i), at((i+1)%size()));}\n\t\tbool contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(L(at(i), at((i+1)%size())).online(p)) return ON;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn sig(sum) ? IN : OUT;\n\t\t}\n\t\t\n\t\tbool contains(const C &c)const {\n\t\t\tif(!contains((P)c)) return false;\n\t\t\tR sum = .0;\n\t\t\tREP(i, size())\n\t\t\t\tif(c.inside(at(i)) || cs_intersect(c, edge(i))) return false;\t// online\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tR area(){\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t};\n#undef SELF\n#undef at\n};\nusing namespace geom;\n\nint n;\n\nchar check(const C& c, const G &g){\n\tif(g.contains(c)) return 'a';\n\tint f = 1;\n\tREP(i, 3) if(!c.inside2(g[i])) f = 0;\n\tif(f) return 'b';\n\tREP(i, 3) if(cs_intersect(c, g.edge(i))) return 'c';\n\treturn 'd';\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tG g;\n\t\tC c;\n\t\tREP(i, 3){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\tif(p.X == 0) return 0;\n\t\t\tg.push_back(p);\n\t\t}\n\t\tcin >> c;\n\t\tcout << check(c, g) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\n// OÏ\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\n// àÏ\ndouble dot(P a, P b)\n{\treturn a.real() * b.real() + a.imag() * b.imag();\t}\n\n// _ÆüªÌ£\ndouble dist(P a, P b, P c)\n{\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\t\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nbool LineCrossCircle(P a, P b, P c, double r)\n{\n\treturn dist(a, b, c) <= r && (r <= abs(a - c) || r <= abs(b - c));\n}\n\nbool CircleInTriangle(P p[3], P c, double r)\n{\n\tdouble S = abs(cross(p[0] - p[2], p[1] - p[2]));\n\t\n\trep(i, 3) S -= abs(cross(p[(i + 1) % 3] - p[i], c - p[i]));\n\t\n\treturn abs(S) < EPS;\n}\n\nbool TriangleInCircle(P p[3], P c, double r)\n{\n\treturn abs(p[0] - c) <= r;\n}\n\nbool TriangleCrossCircle(P p[3], P c, double r)\n{\n\trep(i, 3) if(LineCrossCircle(p[i], p[(i + 1) % 3], c, r)) return true;\t\n\t\n\treturn false;\n}\n\n\nint main()\n{\n    P p[3], c;\n\tdouble r;\n\t\n\twhile(cin >> p[0].real() >> p[0].imag() && (p[0].real() || p[0].imag()))\n\t{\n\t\trep(i, 2) cin >> p[i + 1].real() >> p[i + 1].imag();\n\t\t\n\t\tcin >> c.real() >> c.imag() >> r;\n\t\t\n\t\tif(TriangleCrossCircle(p, c, r))\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\telse if(TriangleInCircle(p, c, r))\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if(CircleInTriangle(p, c, r))\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst double EPS = 1.0e-10;\n\nclass P {\npublic:\n\tdouble x, y;\n\tP() {}\n\tP(double x_, double y_) : x(x_), y(y_) {}\n\tP(const P& p) : x(p.x), y(p.y) {}\n\tP operator+(const P& p) const { return P(x+p.x, y+p.y); } \n\tP operator-(const P& p) const { return P(x-p.x, y-p.y); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(double s) const { return P(x*s, y*s); }\n\tP operator/(double s) const { return P(x/s, y/s); }\n\tP& operator=(const P& p) { x=p.x; y=p.y; return (*this); }\n\tdouble dot(const P& p) const { return x*p.x + y*p.y; }\n\tdouble det(const P& p) const { return x*p.y - y*p.x; }\n\tdouble norm() const { return sqrt(x*x + y*y); }\n\tdouble norm2() const { return x*x + y*y; }\n};\n\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\ndouble sign(double r) { return r < -EPS ? -1.0 : r > EPS ? 1.0 : 0.0; }\n\nclass L {\npublic:\n\tP s, t;\n\tL() {}\n\tL(P s_, P t_) : s(s_), t(t_) {}\n\tL(const L& l) : s(l.s), t(l.t) {}\n\tL& operator=(const L& l) { s=l.s; t=l.t; return (*this); }\n\tdouble length() { return (s - t).norm(); }\n\tP vec() const { return t - s; }\n\tdouble dLP(const P& p) const { return abs(tri(s, t, p)) / vec().norm(); }\n\tdouble dSP(const P& p) const {\n\t\tif(sign(vec().dot(p - s)) <= 0.0) return (p - s).norm();\n\t\tif(sign(vec().dot(p - t)) <= 0.0) return (p - t).norm();\n\t\treturn dLP(p);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p_, double r_) : p(p_), r(r_) {}\n\tC(const C& c) : p(c.p), r(c.r) {}\n\tC& operator=(const C& c) { p=c.p; r=c.r; return (*this); }\n};\n\n\n// code for problem\nint x, y, r;\nvector<P> T;\nC cc;\n\nbool isPinC() {\n\tP e0 = T[0] - cc.p;\n\tP e1 = T[1] - cc.p;\n\tP e2 = T[2] - cc.p;\n\tdouble d0 = e0.det(e1);\n\tdouble d1 = e1.det(e2);\n\tdouble d2 = e2.det(e0);\n\tif(sign(d0) == sign(d1) && sign(d0) == sign(d2)) return true;\n\treturn false;\n}\n\nvoid solve() {\n\tvector<double> d(3);\n\td[0] = (T[0] - cc.p).norm();\n\td[1] = (T[1] - cc.p).norm();\n\td[2] = (T[2] - cc.p).norm();\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] < cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\tbool in = isPinC();\n\tL l0(T[0], T[1]);\n\tL l1(T[1], T[2]);\n\tL l2(T[2], T[0]);\n\td[0] = l0.dSP(cc.p);\n\td[1] = l1.dSP(cc.p);\n\td[2] = l2.dSP(cc.p);\n\tif(in && d[0] >= cc.r && d[1] >= cc.r && d[2] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\tsort(d.begin(), d.end());\n\tif(!in && d[0] > cc.r) {\n\t\tprintf(\"d\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"c\\n\");\n}\n\nint main() {\n\tT = vector<P>(3);\n\tfor(;;) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\tT[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\ntypedef complex<double> P;\n\n// OÏ\ndouble cross(P a, P b)\n{\treturn a.real() * b.imag() - b.real() * a.imag();\t}\n\n// àÏ\ndouble dot(P a, P b)\n{\treturn a.real() * b.real() + a.imag() * b.imag();\t}\n\n// _ÆüªÌ£\ndouble dist(P a, P b, P c)\n{\n\tif(dot(b - a, c - a) < EPS) return abs(c - a);\n\tif(dot(a - b, c - b) < EPS) return abs(c - b);\n\t\n\treturn abs(cross(b - a, c - a)) / abs(b - a);\n}\n\nbool LineCrossCircle(P a, P b, P c, double r)\n{\n\treturn dist(a, b, c) <= r && (r < abs(a - c) || r < abs(b - c));\n}\n\nbool CircleInTriangle(P p[3], P c, double r)\n{\n\tdouble S = abs(cross(p[0] - p[2], p[1] - p[2]));\n\t\n\trep(i, 3) S -= abs(cross(p[(i + 1) % 3] - p[i], c - p[i]));\n\t\n\treturn abs(S) < EPS;\n}\n\nbool TriangleInCircle(P p[3], P c, double r)\n{\n\treturn abs(p[0] - c) <= r;\n}\n\nbool TriangleCrossCircle(P p[3], P c, double r)\n{\n\trep(i, 3) if(LineCrossCircle(p[i], p[(i + 1) % 3], c, r)) return true;\t\n\t\n\treturn false;\n}\n\n\nint main()\n{\n    P p[3], c;\n\tdouble r;\n\t\n\twhile(cin >> p[0].real() >> p[0].imag() && (p[0].real() || p[0].imag()))\n\t{\n\t\trep(i, 2) cin >> p[i + 1].real() >> p[i + 1].imag();\n\t\t\n\t\tcin >> c.real() >> c.imag() >> r;\n\t\t\n\t\tif(TriangleCrossCircle(p, c, r))\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t\telse if(TriangleInCircle(p, c, r))\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if(CircleInTriangle(p, c, r))\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//12\n#include<iostream>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real()+.5;\n}\n\nint dt(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag()+.5;\n}\n\nint main(){\n  for(;;){\n    int x,y;\n    P t[3],c;\n    int r;\n    for(int i=0;i<3;i++){\n      cin>>x>>y;\n      if((i|x|y)==0)return 0;\n      t[i]=P(x,y);\n    }\n    cin>>x>>y;\n    c=P(x,y);\n    cin>>r;\n    if(abs(t[0]-c)<=r&&abs(t[1]-c)<=r&&abs(t[2]-c)<=r){\n      cout<<'b'<<endl;\n    }else{\n      double d[3];\n      bool f[2]={};\n      for(int i=0;i<3;i++){\n\tP l=t[(i+1)%3]-t[i];\n\tif(dt(l,c-t[i])>0&&dt(-l,c-t[(i+1)%3])>0){\n\t  d[i]=fabs(cr(l,c-t[i])/abs(l));\n\t}else{\n\t  d[i]=min(abs(c-t[0]),abs(c-t[1]));\n\t}\n\tf[cr(l,c-t[i])<0]=true;\n      }\n      if(f[0]^f[1]&&d[0]>=r&&d[1]>=r&&d[2]>=r){\n\tcout<<'a'<<endl;\n      }else if(d[0]<=r||d[1]<=r||d[2]<=r){\n\tcout<<'c'<<endl;\n      }else{\n\tcout<<'d'<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<set>\n#define rep(i,n) for(int i = 0;i < n ; ++i)\n\nusing namespace std;\n\nusing ll = long long;\nusing Point = complex<double>;\nconst double eps = 1e-7;\n\ndouble dot(Point a, Point b){\n    return real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b){\n    return imag(conj(a)*b);\n}\n\n\nstruct Line{\n    Point a,b;\n};\n\nbool isis_sp(Line s, Point p){\n    return (abs(s.a-p)+abs(s.b-p)-abs(s.b-s.a)<eps);\n}\n\nPoint proj(Line l, Point p){\n    double t = dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n    return l.a + t * (l.a-l.b);\n}\n\ndouble dist_sp(Line s, Point p){\n    Point r = proj(s,p);\n    return isis_sp(s,r) ? abs(p-r) : min(abs(p-s.a),abs(p-s.b));\n}\n\nbool solve(){\n    Point p[3];\n    rep(i,3){\n        int x,y;\n        cin>>x>>y;\n        if(x==0&&y==0)return false;\n        p[i]=Point(x,y);\n    }\n    Point c;\n    int x,y;\n    cin>>x>>y;\n    c = Point(x,y);\n    double r; cin>>r;\n    int f = 0;\n    rep(i,3)if(abs(p[i]-c)>=r+eps)++f;\n    if(f==0){\n        cout<<\"b\"<<endl;\n        return true;\n    }\n    if(f<3){\n        cout<<\"c\"<<endl;\n        return true;\n    }\n    double sum = 0;\n    rep(i,3){\n        sum += arg((p[(i+1)%3]-c)/(p[i]-c));\n    }\n    bool in = (abs(sum)>3);\n    if(in){\n        bool cr = false;\n        rep(i,3){\n            Line l = Line{p[i],p[(i+1)%3]};\n            if(dist_sp(l,c)<r-eps)cr = true;\n        }\n        if(cr)cout<<\"c\"<<endl;\n        else cout<<\"a\"<<endl;\n    }\n    else {\n        bool cr = false;\n        rep(i,3){\n            Line l = Line{p[i],p[(i+1)%3]};\n            if(dist_sp(l,c)<r+eps)cr = true;\n        }\n        if(cr)cout<<\"c\"<<endl;\n        else cout<<\"d\"<<endl;\n    }\n    return true;\n}\n\nint main(){\n     while(solve());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define F first\n#define S second\n\n#define X real()\n#define Y imag()\n\n#define EPS (1e-7)\n\ntypedef complex<double> Point;\ntypedef pair<double, Point> Circle;\n\nbool isPointInCircle(Point p, Circle c) {\n  if(abs(p-c.S) < abs(c.F)) return true;\n  return false;\n}\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X+a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n  return a.X*b.Y-a.Y*b.X;\n}\n\ntypedef pair<Point, Point> Segment;\ntypedef Segment Line;\n\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.S-l.F, p-l.F)) / abs(l.S-l.F);\n}\n\ndouble distanceSP(Segment s, Point p) {\n  Point a = s.F, b = s.S;\n  \n  if(dot(b-a, p-a) < EPS) return abs(p-a);\n  if(dot(a-b, p-b) < EPS) return abs(p-b);\n  return distanceLP(s, p);\n}\n\nint main() {\n  \n  while(1) {\n    Point points[3];\n    Circle circle;\n  \n    for(int i=0; i<3; i++) {\n      double x, y; cin >> x >> y;\n      if(x == 0) return 0;\n    \n      points[i] = Point(x, y);\n    }\n  \n    {\n      double x, y; cin >> x >> y;\n      circle.S = Point(x, y);\n      cin >> circle.F;\n    }\n  \n    bool ok = 1;\n    for(int i=0; i<3; i++) {\n      ok &= isPointInCircle(points[i], circle);\n    }\n    if(ok) {\n      cout << 'b' << endl;\n      continue;\n    }\n    \n    int ins = 0;\n    for(int i=0; i<3; i++) {\n      Segment seg = make_pair(points[(i+1)%3], points[i]);\n      ins += circle.F < distanceSP(seg, circle.S) + EPS;\n    }\n    if(ins == 3) {\n      int flg = 0;\n      for(int i=0; i<3; i++) {\n        if(dot(points[(i+1)%3]-points[i], circle.S-points[i]) * dot(points[(i+2)%3]-points[(i+1)%3], circle.S-points[(i+1)%3]) > 0) {\n          flg ++;\n        }\n      }\n      if(flg == 3) cout << 'a' << endl;\n      else cout << 'd' << endl;\n      continue;\n    }\n    \n    cout << 'c' << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\nint main(){\n\tint a,b;\n\twhile(cin>>a>>b,a+b){\n\t\tG g(3);\n\t\tg[0]=P(a,b);\n\t\trep(i,2)g[i+1]=pin();\n\t\tP p=pin();double r;cin>>r;\n\t\tC c(p,r);\n\t\tbool h=true;\n\t\trep(i,3)if(abs(g[i]-c.c)>c.r+EPS)h=false;\n\t\tif(h){\n\t\t\tcout<<'b'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\th=true;\n\t\tif(inconvex(g,c.c)!=2)h=false;\n\t\trep(i,3)if(distanceSP(L(g[i],g[(i+1)%3]),c.c)+EPS<c.r)h=false;\n\t\tif(h){\n\t\t\tcout<<'a'<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,3)if(intersectCS(c,L(g[i],g[(i+1)%3])))h=true;\n\t\tif(h)cout<<'c'<<endl;\n\t\telse cout<<'d'<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nconst double eps = 1e-7;\nnamespace boost {\ntemplate <class T>\nstruct integer_iterator {\n    T a;\n    bool operator != (integer_iterator const & it) const { return a != it.a; }\n    T operator * () const { return a; }\n    integer_iterator & operator ++ () { ++ a; return *this; }\n    integer_iterator operator ++ (int) { return { a ++ }; }\n};\ntemplate <class T>\nstruct integer_range {\n    T l, r;\n    typedef integer_iterator<T> iterator;\n    iterator begin() const { return { l }; }\n    iterator end  () const { return { r }; }\n};\ntemplate <class T>\ninteger_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }\ntemplate <class T>\nstruct integer_iterator_with_step {\n    T a, d, i;\n    bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }\n    T operator * () const { return a+d*i; }\n    integer_iterator_with_step & operator ++ () { ++ i; return *this; }\n    integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }\n};\ntemplate <class T>\nstruct strided_integer_range {\n    T l, r, s;\n    typedef integer_iterator_with_step<T> iterator;\n    iterator begin() const { return { l, s, 0 }; }\n    iterator end  () const { return { l, s, (r - l) / s }; }\n};\ntemplate <class T>\nstrided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }\n}\n#include <utility>\n#include <cmath>\n#define ttt template <typename T>\n#define pca point<T> const &\nttt struct point { T x, y; };\nttt point<T> operator + (pca a, pca b) { return { a.x+b.x, a.y+b.y }; }\nttt point<T> operator - (pca a, pca b) { return { a.x-b.x, a.y-b.y }; }\nttt point<T> operator - (pca a) { return { -a.x, -a.y }; }\nttt point<T> operator * (T a, pca b) { return { a*b.x, a*b.y }; }\nttt std::pair<T,T> to_pair(pca a) { return { a.x, a.y }; }\nttt bool operator == (pca a, pca b) { return to_pair(a) == to_pair(b); }\nttt bool operator != (pca a, pca b) { return to_pair(a) != to_pair(b); }\nttt bool operator <  (pca a, pca b) { return to_pair(a) <  to_pair(b); }\nttt bool operator <= (pca a, pca b) { return to_pair(a) <= to_pair(b); }\nttt bool operator >= (pca a, pca b) { return to_pair(a) >= to_pair(b); }\nttt bool operator >  (pca a, pca b) { return to_pair(a) >  to_pair(b); }\nttt T length_squared(pca p) { return p.x*p.x + p.y*p.y; }\nttt double length(pca p) { return sqrt(length_squared(p)); }\nttt point<T> normalized(pca a) { return (1 / length(a)) * a; }\nttt T   dot(pca p, pca q) { return p.x * q.x + p.y * q.y; }\nttt T cross(pca p, pca q) { return p.x * q.y - p.y * q.x; }\nttt int ccw(pca a, pca b, pca c) { T x = cross(b - a, c - a); return x > 0 ? 1 : x < 0 ? -1 : 0; }\n#undef ttt\n#undef pca\ntemplate <typename T> std::istream & operator >> (std::istream & input, point<T> & p) { return input >> p.x >> p.y; }\ntemplate <typename T> std::ostream & operator << (std::ostream & output, const point<T> & p) { return output << p.x << ' ' << p.y; }\ntemplate <typename T> struct circle { point<T> p; T r; };\ntemplate <typename T> bool operator == (circle<T> const & a, circle<T> const & b) { return a.p == b.p and a.r == b.r; }\ntemplate <typename T> bool operator != (circle<T> const & a, circle<T> const & b) { return not (a == b); }\ntemplate <typename T> struct line { point<T> a, b; };\ntemplate <typename T> struct ray { point<T> a, b; };\ntemplate <typename T> struct segment { point<T> a, b; };\ntemplate <typename T> T length_squared(segment<T> const & p) { return length_squared(p.a - p.b); }\ntemplate <typename T> double length(segment<T> const & p) { return length(p.a - p.b); }\ntemplate <typename T>    line<T> to_line(    ray<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>    line<T> to_line(segment<T> const & a) { return (line<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(   line<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T>     ray<T>  to_ray(segment<T> const & a) { return (ray<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment(line<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T> segment<T> to_segment( ray<T> const & a) { return (segment<T>){ a.a, a.b }; }\ntemplate <typename T>\nstruct arc { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT length(arc<T> const & a) { return a.r * (a.b - a.a); }\ntemplate <typename T>\nbool valid(arc<T> const & a) {\n    assert (0 <= a.r);\n    return\n        - M_PI < a.a + eps and a.a < M_PI + eps and\n        - M_PI < a.b + eps and a.b < M_PI + eps;\n}\ntemplate <typename T>\ncircle<T> to_circle(arc<T> const & a) { return { a.p, a.r }; }\n\ntemplate <typename T>\nstruct circular_sector { point<T> p; T r; T a, b; };\ntemplate <typename T>\nT sq(T x) { return x * x; }\ntemplate <typename T>\npoint<T> rotate_90(point<T> const & a) {\n    return { - a.y, a.x };\n}\ntemplate <typename T>\npoint<T> rotate_270(point<T> const & a) {\n    return { a.y, - a.x };\n}\ntemplate <typename T>\npoint<T> rotate_180(point<T> const & a) {\n    return { - a.x, - a.y };\n}\npoint<double> rotate(point<double> const & a, double th) {\n    return {\n        a.x * cos(th) - a.y * sin(th),\n        a.x * sin(th) + a.y * cos(th) };\n}\ntemplate <>\nint ccw(point<double> const & a, point<double> const & b, point<double> const & c) {\n    double x = cross(b - a, c - a);\n    return x > eps ? 1 : x < - eps ? -1 : 0;\n}\n\ndouble distance(point<double> const & a, point<double> const & b) {\n    return length(b - a);\n}\n\ndouble distance(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return std::abs( cross(p, e) );\n}\ndouble distance(point<double> const & a, line<double> const & b) {\n    return distance(b,a);\n}\n\nbool does_include(circle<double> const & a, point<double> const & b) {\n    return length(a.p - b) < a.r + eps;\n}\nbool is_on_circumference(point<double> const & a, circle<double> const & b) {\n    return std::abs(length(b.p - a) - b.r) < eps;\n}\n// commutable\nbool does_include(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < std::abs(a.r - b.r) + eps;\n}\n// commutable\nbool does_intersect(circle<double> const & a, circle<double> const & b) {\n    return length(a.p - b.p) < a.r + b.r + eps;\n}\n// commutable\nbool does_circumscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - (a.r + b.r)) < eps;\n}\n// commutable\nbool does_inscribe(circle<double> const & a, circle<double> const & b) {\n    return std::abs(length(a.p - b.p) - std::abs(a.r - b.r)) < eps;\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, circle<double> const & b) {\n    std::vector<point<double> > result;\n    if (distance(a.p, b.p) < eps) {\n        // nop\n    } else if (not does_intersect(a,b)) {\n        // nop\n    } else if (does_include(a,b) and not does_inscribe(a,b)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(a,b) or does_circumscribe(a,b)) {\n        circle<double> x = a;\n        circle<double> y = b;\n        if (not (x.r < y.r)) std::swap(x, y);\n        result.push_back(y.r * normalized(x.p - y.p) + y.p);\n    } else {\n        //       c\n        //      /|\\\n        // a.r / | \\ b.r\n        //    /th|  \\\n        //   a-------b\n        //       l\n        double l = length(b.p - a.p);\n        double ac = ( sq(a.r) - sq(b.r) + sq(l) ) / ( 2 * l ); // a * cos(th)\n        double as = sqrt( sq(a.r) - sq(ac) );\n        point<double> e = normalized(b.p - a.p);\n        result.push_back(a.p + ac*e + as*rotate_90(e));\n        result.push_back(a.p + ac*e + as*rotate_270(e));\n    }\n    for (auto p : result) {\n        assert (does_include(a, p));\n        assert (does_include(b, p));\n    }\n    return result;\n}\n\nstd::vector<line<double> > tangents(circle<double> const & a, point<double> const & b) {\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not is_on_circumference(b,a)) {\n        // truly included\n        // nop\n    } else if (is_on_circumference(b,a)) {\n        point<double> e = normalized(a.p - b);\n        result.push_back({\n                b + rotate_90(e),\n                b + rotate_270(e) });\n    } else {\n        double theta = asin(a.r / length(b - a.p));\n        result.push_back({ b, b + rotate(a.p - b, + theta) });\n        result.push_back({ b, b + rotate(a.p - b, - theta) });\n    }\n    return result;\n}\n\nstd::vector<line<double> > common_inner_tangents(circle<double> const & a, circle<double> const & b) {\n    point<double> p = a.p + (a.r / (a.r + b.r)) * (b.p - a.p);\n    return tangents(a,p);\n}\nstd::vector<line<double> > common_outer_tangents(circle<double> a, circle<double> b) {\n    if (b.r < a.r) std::swap(a,b);\n    std::vector<line<double> > result;\n    if (does_include(a,b) and not does_inscribe(b,a)) {\n        // truly included\n        // nop\n    } else if (does_inscribe(b,a)) {\n        point<double> e = normalized(a.p - b.p);\n        result.push_back({\n                b.p + a.r*e + rotate_90(e),\n                b.p + a.r*e + rotate_270(e) });\n    } else {\n        point<double> d = b.p - a.p;\n        double theta = asin((b.r - a.r) / length(d));\n        point<double> dp = rotate(d, + theta);\n        point<double> dm = rotate(d, - theta);\n        point<double> ep = rotate_90(normalized(dp));\n        point<double> em = rotate_270(normalized(dm));\n        result.push_back({ a.p + a.r*ep, a.p + a.r*ep + dp });\n        result.push_back({ a.p + a.r*em, a.p + a.r*em + dm });\n    }\n    return result;\n}\nstd::vector<line<double> > common_tangents(circle<double> const & a, circle<double> const & b) {\n    std::vector<line<double> > result;\n    for (auto l : common_inner_tangents(a,b)) result.push_back(l);\n    for (auto l : common_outer_tangents(a,b)) result.push_back(l);\n    return result;\n}\n\npoint<double> nearest_point(line<double> const & a, point<double> const & b) {\n    point<double> p = b   - a.a;\n    point<double> q = a.b - a.a;\n    point<double> e = normalized(q);\n    return a.a + dot(p, e) * e;\n}\nbool is_tangent(line<double> const & a, circle<double> const & b) {\n    return std::abs( b.r - distance(a, b.p) ) < eps;\n}\nbool does_include(segment<double> const & a, point<double> const & b) {\n    point<double> p = b - a.a;\n    point<double> e = normalized(a.b - a.a);\n    return std::abs( cross(e, p) ) < eps and - eps < dot(e, p) and dot(e, p) < length(a) + eps;\n}\nbool is_tangent(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return is_tangent(l, b) and does_include(a, nearest_point(l, b.p));\n}\nbool does_intersect(line<double> const & a, circle<double> const & b) {\n    return distance(a, b.p) < b.r + eps;\n}\nbool does_intersect(circle<double> const & a, line<double> const & b) {\n    return does_intersect(b, a);\n}\nbool does_intersect(segment<double> const & a, circle<double> const & b) {\n    auto l = to_line(a);\n    return does_intersect(l, b) and\n        (does_include(a, nearest_point(l, b.p)) or\n         distance(a.a, b.p) < b.r + eps or\n         distance(a.b, b.p) < b.r + eps);\n}\n\nbool does_intersect(line<double> const & a, line<double> const & b) {\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return eps < std::abs( cross(p, q) );\n}\nbool is_parallel(line<double> const & a, line<double> const & b) {\n    return not does_intersect(a, b);\n}\nbool does_intersect(segment<double> const & a, segment<double> const & b) {\n    return\n        ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) == -1 and\n        ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) == -1;\n}\npoint<double> intersection_point(line<double> const & a, line<double> const & b) {\n    assert (does_intersect(a, b));\n    point<double> p = a.b - a.a;\n    point<double> q = b.b - b.a;\n    return a.a + ( cross(q, b.a - a.a) / cross(q, p) ) * p;\n}\n\nbool does_include(ray<double> const & a, point<double> const & b) {\n    return ccw(a.a, a.b, b) == 0 and dot(a.b - a.a, b - a.a) > - eps;\n}\nbool does_intersect(ray<double> const & a, segment<double> const & b) {\n    if (does_include(a, b.a) or does_include(a, b.b)) return true;\n    line<double> la = to_line(a);\n    line<double> lb = to_line(b);\n    if (is_parallel(la, lb)) return false;\n    point<double> p = intersection_point(la, lb);\n    return does_include(a,p) and does_include(b,p);\n}\nbool does_intersect(segment<double> const & a, ray<double> const & b) {\n    return does_intersect(b, a);\n}\n\npoint<double> projection(point<double> const & a, line<double> const & b) {\n    point<double> e = normalized(b.b - b.a);\n    return dot(e, a - b.a) * e + b.a;\n}\ndouble distance(segment<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_line(a));\n    if (does_include(a, p)) {\n        return distance(to_line(a), b);\n    } else{\n        return std::min(distance(a.a, b), distance(a.b, b));\n    }\n}\ndouble distance(point<double> const & a, segment<double> const & b) {\n    return distance(b, a);\n}\ndouble distance(segment<double> const & a, segment<double> const & b) {\n    return std::min(std::min(std::min(\n            distance(a.a, b),\n            distance(a.b, b)),\n            distance(a, b.a)),\n            distance(a, b.b));\n}\n\npoint<double> projection(point<double> const & a, circle<double> const & b) {\n    return b.r * normalized(a - b.p) + b.p;\n}\nbool does_include(arc<double> const & a, point<double> const & b) {\n    assert (valid(a));\n    point<double> e = b - a.p;\n    double r = length(e);\n    double th = atan2(e.y, e.x);\n    return std::abs(a.r - r) < eps and  a.a < th + eps and th < a.b + eps;\n}\ndouble distance(arc<double> const & a, point<double> const & b) {\n    point<double> p = projection(b, to_circle(a));\n    if (does_include(a, p)) {\n        return distance(p, b);\n    } else{\n        point<double> l = a.r * (point<double>) { cos(a.a), sin(a.a) } + a.p;\n        point<double> r = a.r * (point<double>) { cos(a.b), sin(a.b) } + a.p;\n        return std::min(distance(l, b), distance(r, b));\n    }\n}\ndouble distance(point<double> const & a, arc<double> const & b) {\n    return distance(b, a);\n}\n\nstd::vector<point<double> > intersection_points(circle<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    if (not does_intersect(a, b)) {\n        // nop\n    } else if (is_tangent(b, a)) {\n        result.push_back(nearest_point(b, a.p));\n    } else {\n        point<double> e = normalized(b.b - b.a);\n        point<double> p = nearest_point(b, a.p);\n        double h = distance(p, a.p);\n        double w = sqrt( sq(a.r) - sq(h) );\n        result.push_back(  w * e + p);\n        result.push_back(- w * e + p);\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, circle<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, line<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), b)) {\n        if (does_include(a, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(arc<double> const & a, segment<double> const & b) {\n    std::vector<point<double> > result;\n    for (auto p : intersection_points(to_circle(a), to_line(b))) {\n        if (does_include(a, p) and does_include(b, p)) {\n            result.push_back(p);\n        }\n    }\n    return result;\n}\nstd::vector<point<double> > intersection_points(line<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nstd::vector<point<double> > intersection_points(segment<double> const & a, arc<double> const & b) {\n    return intersection_points(b, a);\n}\nbool does_intersect(arc<double> const & a, segment<double> const & b) {\n    return not intersection_points(a, b).empty();\n}\nbool does_intersect(segment<double> const & a, arc<double> const & b) {\n    return does_intersect(b, a);\n}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\nint main() {\n    while (true) {\n        point<ll> p[3];\n        cin >> p[0];\n        if (p[0].x == 0 and p[0].y == 0) break;\n        cin >> p[1] >> p[2];\n        circle<ll> c;\n        cin >> c.p >> c.r;\n        if (\n                length_squared(c.p - p[0]) <= sq(c.r) and\n                length_squared(c.p - p[1]) <= sq(c.r) and\n                length_squared(c.p - p[2]) <= sq(c.r)) {\n            cout << 'b' << endl;\n        } else if (\n                ccw(p[0], p[1], c.p) == 0 or\n                ccw(p[1], p[2], c.p) == 0 or\n                ccw(p[2], p[0], c.p) == 0) {\n            cout << 'c' << endl;\n        } else {\n            ll x = sq(cross(p[1] - p[0], c.p - p[0])) - sq(c.r) * length_squared(p[1] - p[0]);\n            ll y = sq(cross(p[2] - p[1], c.p - p[1])) - sq(c.r) * length_squared(p[2] - p[1]);\n            ll z = sq(cross(p[0] - p[2], c.p - p[2])) - sq(c.r) * length_squared(p[0] - p[2]);\n            if (abs(\n                    ccw(p[0], p[1], c.p) +\n                    ccw(p[1], p[2], c.p) +\n                    ccw(p[2], p[0], c.p)) == 3) {\n                if (x < 0 or y < 0 or z < 0) {\n                    cout << 'c' << endl;\n                } else {\n                    cout << 'a' << endl;\n                }\n            } else {\n                if (x < 0 or y < 0 or z < 0) {\n                    cout << 'c' << endl;\n                } else {\n                    cout << 'd' << endl;\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\n#define EPS 1.e-6\ntypedef complex<double> C;\n\nC v[4];\ndouble r;\n\ndouble dot(C &a, C &b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble ncross(C &a, C &b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint tri_in_check() {\n  int c[3];\n  C a;\n  double r2 = r*r;\n  for (int i=0; i<3; i++) {\n    a = v[i] - v[3];\n    if (norm(a) < r2) {\n      c[i] = -1;\n    } else if (norm(a) > r2){\n      c[i] = 1;\n    } else {\n      c[i] = 0;\n    }\n  }\n  if (c[0]>=0. && c[1]>=0. && c[2]>=0.) {\n    return 1;\n  } else if (c[0]<=0. && c[1]<=0. && c[2]<=0.) {\n    return -1;\n  }\n  return 0;\n}\n\nbool center_in_check() {\n  C a, b;\n  bool f[3];\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[(i+1)%3];\n    f[i] = (ncross(a,b) > 0);\n  }\n  return (f[0]==f[1] && f[0]==f[2]);\n}\n\nint intersect() {\n  C a, b;\n  double na, nb, dab, d, sd, s, t;\n  bool contact = false;\n  for (int i=0; i<3; i++) {\n    a = v[(i+1)%3] - v[i];\n    b = v[3] - v[i];\n    na = norm(a);\n    nb = norm(b);\n    dab = dot(a,b);\n    d = dab*dab - na*(nb-r*r);\n    if (d <=EPS) {\n      if (fabs(d) < EPS) {\n        contact = true;\n      }\n      continue;\n    }\n    sd = sqrt(d);\n    s = (dab+sd)/na;\n    t = (dab-sd)/na;\n    if ((s>EPS&&s<1.-EPS) || (t>EPS&&t<1.-EPS)) {\n      return 1;\n    }\n    if ((fabs(s)<EPS && fabs(s-1.)<EPS) || (fabs(t)<EPS && fabs(t-1.)<EPS)) {\n      contact = true;\n    }\n  }\n  return (contact ? 0 : -1);\n}\n\nint main() {\n  int t;\n  while (1) {\n    cin >> v[0].real() >> v[0].imag();\n    if (!v[0].real() && !v[0].imag()) break;\n    for (int i=1; i<4; i++) {\n      cin >> v[i].real() >> v[i].imag();\n    }\n    cin >> r;\n    if (tri_in_check() == -1) {\n      cout << \"b\" << endl;\n    } else {\n      t = intersect();\n      if (t == 1) {\n        cout << \"!c\" << endl;\n      } else if (center_in_check()) {\n        cout << \"a\" << endl;\n      } else if (t == 0) {\n        cout << \"?c\" << endl;\n      }  else {\n        cout << \"d\" << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#define dis(p,q) ((p)*(p)+(q)*(q))\nusing namespace std;\nint lc(double bx,double by,double ex,double ey,double cx,double cy,double cr){\n  int p,q;\n  if(0){\n  }else if(dis(cx-bx,cy-by)>cr*cr){\n    p=1;\n  }else if(dis(cx-bx,cy-by)<cr*cr){\n    p=0;\n  }else{\n    p=2;\n  }\n  if(0){\n  }else if(dis(cx-ex,cy-ey)>cr*cr){\n    q=1;\n  }else if(dis(cx-ex,cy-ey)<cr*cr){\n    q=0;\n  }else{\n    q=2;\n  }\n  if(p==0&&q==0)\n    return 0;\n  if(p!=1||q!=1)\n    return 1;\n  double vx,vy,px,py,qx,qy,rx,ry,ds;\n  ds=sqrt(dis(bx-ex,by-ey));\n  vx=(ex-bx)/ds;\n  vy=(ey-by)/ds;\n  ds=((ey-by)*cx+(bx-ex)*cy+(by-ey)*bx+(ex-bx)*by)/((ey-by)*vy-(bx-ex)*vx);\n  px=cx-vy*ds;\n  py=cy+vx*ds;\n  if(0){\n  }else if(cr>ds){\n    ds=sqrt(cr*cr-ds*ds);\n    qx=px+vx*ds;\n    qy=py+vy*ds;\n    rx=px-vx*ds;\n    ry=py-vy*ds;\n    if(bx==ex)\n      return min(by,ey)<=min(qy,ry)&&max(qy,ry)<=max(by,ey);\n    else\n      return min(bx,ex)<=min(qx,rx)&&max(qx,rx)<=max(bx,ex);\n  }else if(cr==ds){\n    if(bx==ex)\n      return min(by,ey)<=py&&py<=max(by,ey);\n    else\n      return min(bx,ex)<=px&&px<=max(bx,ex);\n  }\n  return 0;\n}\nint pt(double px,double py,double qx,double qy,double rx,double ry,double sx,double sy){\n  if(((rx-qx)*(py-qy)-(px-qx)*(ry-qy)<=0&&(sx-rx)*(py-ry)-(px-rx)*(sy-ry)<=0&&(qx-sx)*(py-sy)-(px-sx)*(qy-sy)<=0)||\n     ((rx-qx)*(py-qy)-(px-qx)*(ry-qy)>=0&&(sx-rx)*(py-ry)-(px-rx)*(sy-ry)>=0&&(qx-sx)*(py-sy)-(px-sx)*(qy-sy)>=0))\n    return 1;\n  return 0;\n}\nint main(){\n  int i;\n  int x[4],y[4],r;\n  while(cin>>x[0]>>y[0]&&(x[0]||y[0])){\n    for(i=1;i<4;i++)\n      cin>>x[i]>>y[i];\n    cin>>r;\n    for(i=0;i<3;i++){\n      if(lc(x[i],y[i],x[(i+1)%3],y[(i+1)%3],x[3],y[3],r))\n\tbreak;\n    }\n    if(i==3){\n      if(dis(x[0]-x[3],y[0]-y[3])<r*r){\n\tcout<<\"b\"<<endl;\n      }else{\n\tif(pt(x[3],y[3],x[0],y[0],x[1],y[1],x[2],y[2]))\n\t  cout<<\"a\"<<endl;\n\telse\n\t  cout<<\"d\"<<endl;\n      }\n    }else{\n      cout<<\"c\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n \n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\npublic:\n  double x, y;\n  \n  Point ( double x = 0, double y = 0): x(x), y(y){}\n  \n  Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n  Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n  Point operator * ( double a ){ return Point(x*a, y*a); }\n  Point operator / ( double a ){ return Point(x/a, y/a); }\n  \n  double abs() { return sqrt(norm());}\n  double norm() { return x*x + y*y; }\n  \n  bool operator < ( const Point &p ) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\n\nclass Segment{\npublic:\n  Point p1, p2;\n  Segment ( Point p1 = Point(0.0,0.0), Point p2 = Point(0.0,0.0)): p1(p1), p2(p2){}\n  double abs() { return sqrt(norm());}\n  double norm() { return (p2.x - p1.x)*(p2.x - p1.x) + (p2.y - p1.y)*(p2.y - p1.y); }\n};\ntypedef Segment Line;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\nbool isOrthogonal( Vector a, Vector b){\n  return equals(dot(a,b),0.0);\n}\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals( dot(s1.p2-s1.p1 , s2.p2-s2.p1) ,0.0 );\n}\nbool isParallel(Vector a, Vector b){\n  return equals(cross(a,b),0.0);\n}\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2 - s1.p1 , s2.p2 - s2.p1),0.0);\n}\nPoint project(Segment s,Point p){\n  Vector base = s.p2-s.p1;\n  double t = dot(p-s.p1,base)/norm(base);\n  return s.p1+base*t;\n}\nPoint reflect(Segment s,Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n \n// EPS can be 0\n// need to check for 920, 833, 866\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <=0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1 , s1.p2 , s2.p1 , s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1-s2.p1));\n  double d2 = abs(cross(base, s1.p1-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\ndouble getDistanceLP(Line s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nbool isConvex( Point P[4] ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\nbool isConvex( vector<Point> P ){\n    int c = ccw(P[0], P[1], P[2]);\n    for ( int i = 1; i < 4; i++ ){\n      if ( c != ccw(P[i], P[(i+1)%4], P[(i+2)%4] )) return false;\n    }\n    return true;\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3)return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  \n  //int n;\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n  \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  \n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n  \n  return l;\n}\n\ndouble S3( double x1, double y1, double x2,double y2, double x3, double y3 ){\n \n  double sum = 0;\n  sum = ( x1*y2 - x2*y1 ) + ( x2*y3 - x3*y2 ) + ( x3*y1 - x1*y3 );\n  sum = abs(sum);\n  sum /= 2;\n \n  return sum;\n}\nbool eq(double x,double y){\n  double z=x-y;\n  if(z<0.000000001)return true;\n  else return false;\n}\nint check(Point O,Point A,Point B,Point C){\n  double a = S3(A.x , A.y , B.x , B.y , O.x , O.y);\n  double b = S3(B.x , B.y , C.x , C.y , O.x , O.y);\n  double c = S3(C.x , C.y , A.x , A.y , O.x , O.y);\n\n  double d = S3(A.x,A.y,B.x,B.y,C.x,C.y);\n\n  if(eq((a+b+c),d)){\n    return 1;\n  }else{\n    return -1;\n  }\n}\n\nint main(){\n  Point a,b,c,o;\n  double r;\n  double A,B,C;\n  while(cin>>a.x>>a.y){\n    if(a.x==0.0&&a.y==0.0)break;\n    cin>>b.x>>b.y>>c.x>>c.y>>o.x>>o.y>>r;\n\n    A=getDistance(a,o);\n    B=getDistance(b,o);\n    C=getDistance(c,o);\n    if(A<r&&B<r&&C<r){cout<<\"b\"<<endl;continue;}\n\n    A=getDistanceSP(Segment(a,b),o);\n    B=getDistanceSP(Segment(b,c),o);\n    C=getDistanceSP(Segment(c,a),o);\n\n    if(A>r&&B>r&&C>r&&check(o,a,b,c)==1){cout<<\"a\"<<endl;continue;}\n    \n    if(A>r&&B>r&&C>r&&check(o,a,b,c)==-1){cout<<\"d\"<<endl;continue;}\n    cout<<\"c\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<iomanip>\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define fr first\n#define sc second\n\nstruct line: public vector< complex<double> >{\n  line(){};\n  line( const complex<double>& a, const complex<double>& b){\n    push_back(a);\n    push_back(b);\n  }\n};\nstruct circle {\n  complex<double> p; double r;\n  circle():p(0,0),r(0){};\n  circle(const complex<double> &p, double r) : p(p),r(r){}\n};\n\ntypedef complex < double > P;\ntypedef line               L;\ntypedef pair < P, P >      Ls;\ntypedef vector< P >        G;\ntypedef vector< P >        Ps;\ntypedef vector< L >        LLL;\ntypedef circle             C;\nconst double EPS = 1e-9;\nconst double INF = 1e8;\n\nbool   eq(P,P); //点:点 同一判定\ndouble cross(P,P); //外積\ndouble dot(P,P); //内積\nint    ccw(P,P,P); //3点の位置関係\nbool   parallel(L,L); // 直線//直線\nbool   orthogonal(L,L); //直線⊥直線\nbool   intersect(L,L); //線分:線分交差\nbool   intersect(L,P); //線分:点交差\nbool   intersect(Ls,Ls); //直線:直線交差\nbool   intersect(Ls,L); //直線:線分交差\nbool   intersect(Ls,P); //直線:点交差\nint    intersect(C,L); //円:線分交点数\nbool   intersect(C,Ls); //円:直線交差\nbool   intersect(C,C); //円:円交差\nbool   intersect(C,P); //円:点交差\ndouble distance(L,L); //線分:線分の距離\ndouble distance(L,P); //線分:点の距離\ndouble distance(P,P); //点:点の距離\ndouble distance(Ls,P); //直線:点距離\ndouble distance(Ls,Ls); //直線:直線距離\ndouble distance(Ls,L); //直線:線分距離\nP      crosspoint(L,L); //線分:線分交点計算\nL      crosspoint(C,Ls); //円:直線交点計算\nL      crosspoint(C,L); //円:線分交点計算\nL      crosspoint(C,C); //円:円交点計算\nint    contains(G,P); //図形:点内包判定\nbool   contains(C,P);\ndouble area2(G); //面積\nbool   isconvex(G); //凸性判定\nPs     convex(G); //凸包\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\nL llcomb(Ls a){\n  L line( a.fr, a.sc);\n  return line;\n}\nLs llrcomb(L a){\n  Ls line( a[0], a[1]);\n  return line;\n}\nbool eq( P a, P b){ //OK\n  return abs( a - b) < EPS;\n}\ndouble cross( P a,  P b){ //OK\n  return imag( conj(a) * b);\n}\ndouble dot( P a, P b){ //OK\n  return real( conj(a) * b);\n}\nP projection( L l, P p) { //OK\n  double t = dot( p - l[0], l[0] - l[1]) / norm( l[0] - l[1]);\n  return l[0] + t * ( l[0] - l[1]);\n}\nint ccw( P a, P b, P c){  //OK\n  b -= a, c -= a;\n  if(cross(b,c) > 0)    return +1;  // a → b で 反時計方向におれて c\n  if(cross(b,c) < 0)    return -1; // a → b で 時計方向におれて c\n  if(dot(b,c) < 0)      return +2;  // c -- a -- b\n  if(norm(b) < norm(c)) return -2; // a -- b -- c\n                        return 0;  // a -- c -- b\n}\nbool intersect( L a, L b){ //OK\n  return ccw( a[0], a[1], b[0]) * ccw( a[0], a[1], b[1]) <= 0 &&\n    ccw( b[0], b[1], a[0]) * ccw( b[0], b[1], a[1]) <= 0;\n}\nbool intersect( L a, P p){ //OK\n   return abs( a[0] - p) + abs( a[1] - p) - abs( a[1] - a[0]) < EPS;\n}\nbool intersect( Ls l, Ls m) { //OK\n  return abs(cross(l.sc-l.fr, m.sc-m.fr)) > EPS ||\n         abs(cross(l.sc-l.fr, m.fr-l.fr)) < EPS;\n}\nbool intersect(Ls l, L s) { //OK\n  return cross( l.sc - l.fr, s[0] - l.fr) *\n         cross( l.sc - l.fr, s[1] - l.fr) < EPS;\n}\nbool intersect(Ls l, P p) { //OK\n  return abs( cross( l.sc - p, l.fr - p)) < EPS;\n}\nbool intersect( C c, Ls s){ //OK\n  return distance( s, c.p) <= c.r + EPS;\n}\nbool intersect( C a, C b){ //OK\n  return ( norm( a.p - b.p) - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n    ( norm( a.p - b.p) - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n}\nint intersect( C c, L l){ //OK\n  if( norm( projection( l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  const double d1 = abs( c.p - l[0]), d2 = abs( c.p - l[1]);\n  if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if( d1 < c.r - EPS && d2 > c.r + EPS\n      || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n  const P h = projection( l, c.p);\n  if( dot( l[0] - h, l[1] - h) < 0) return 2;\n  return 0;\n}\nbool intersect( C c, P p){ //OK\n  return abs( abs( p - c.p) - c.r ) < EPS;\n}\ndouble distance( L s, P p){ //OK\n  P r = projection(s, p);\n  if ( intersect( s, r)) return abs( r - p);\n  return min( abs( s[0] - p), abs( s[1] - p));\n}\ndouble distance( L a, L b){ //OK\n  if(intersect( a, b)) return 0;\n  return min( min( distance( a, b[0]), distance( a, b[1])),\n              min( distance( b, a[0]), distance( b, a[1])));\n}\ndouble distance( Ls l, P p) { //OK\n  return abs(p - projection( llcomb(l), p));\n}\ndouble distance( Ls l, Ls m) { //OK\n  return intersect( l, m) ? 0 : distance( l, m.fr);\n}\ndouble distance( Ls l, L s) { //OK\n  if (intersect(l, s)) return 0;\n  return min(distance(l, s[0]), distance(l, s[1]));\n}\ndouble distance( P a, P b){ //OK\n  return abs( a - b);\n}\nbool parallel( L a, L b){\n  return abs( cross( a[1] - a[0], b[1] - b[0])) < EPS;\n}\nbool orthogonal( L a, L b){\n  return dot( a[0] - a[1], b[0] - b[1]) < EPS;\n}\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nint contains(G Q, P p){ //OK\n  bool in = false;\n  for(int i = 0 ; i < Q.size() ; i++ ){\n    P a = curr(Q,i) - p, b = next(Q,i) - p;\n    if(imag(a) > imag(b)) swap(a,b);\n    if(imag(a) <= 0 && 0 < imag(b) && cross(a,b) < 0) in = !in;\n    if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\nbool contains(C c,P p){\n  return abs( c.p - p) < c.r + EPS;\n}\ndouble area2(G p){ //OK\n  double A = 0;\n  for (int i = 0; i < p.size(); ++i){\n    A += cross(curr(p, i), next(p, i));\n  }\n  return A;\n}\nbool isconvex(G p) { // OK\n  for (int i = 0; i < p.size(); ++i){\n    if (ccw(prev(p, i), curr(p, i), next(p, i)) > 0) return false;\n  }\n  return true;\n}\nPs convex(Ps ps) { //n>=3 OK\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Ps ch(2 * ps.size());\n  for (int i = 0; i < ps.size(); ch[k++] = ps[i++]){\n    while (k >= 2 and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  for (int i = ps.size()-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n    while (k >= t and ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nP crosspoint(L l, L m) { //OK\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\nL crosspoint( C c, Ls l) { //OK\n  const P hp = projection( llcomb(l), c.p), h =  hp - c.p;\n  const double d2 = norm(h);\n  P v = sqrt( c.r * c.r - d2) * ( l.sc - l.fr) / abs( l.sc - l.fr);\n  return L(hp - v, hp + v);\n}\nL crosspoint( C c, L l) { //OK\n  if(intersect(c, l) == 2) return crosspoint(c, llrcomb(l));\n  L ret = crosspoint(c, llrcomb(l));\n  if(dot(l[0] - ret[0], l[1] - ret[0]) < 0) ret[1] = ret[0];\n  else ret[0] = ret[1];\n  return ret;\n}\nL crosspoint(C c1, C c2){ //OK\n  double d = abs(c1.p - c2.p);\n  double s = (c1.r + c2.r + d) / 2;\n  double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n  double h = 2 * S / d;\n  P v = ( c2.p - c1.p) / ( abs( c2.p - c1.p));\n  double m = sqrt( c1.r * c1.r - h * h);\n  return L( c1.p + m * v + h * v * P(0,1), c1.p + m * v - h * v * P(0,1));\n}\n\nint main(){\n  G p;\n  L l[3];\n  C c;\n  p.resize(3);\n  while(cin >> p[0].real() >> p[0].imag(), p[0].real()||p[0].imag()){\n    for(int i = 1 ; i < 3 ; i++ ){\n      cin >> p[i].real() >> p[i].imag();\n    }\n    cin >> c.p.real() >> c.p.imag();\n    cin >> c.r;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      l[i] = L( p[i], p[(i+1)%3]);\n    }\n\n    bool flag = true;\n\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(distance(l[i], c.p) + EPS < c.r) flag = false;\n    }\n    if(flag && contains( p, c.p)){\n      cout << 'a' << endl;\n      continue;\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(!contains( c, p[i])) flag = true;\n    }\n    if(!flag){\n      cout << 'b' << endl;\n      continue;\n    }\n    for(int i = 0 ; i < 3 ; i++ ){\n      if(intersect( c, l[i]) == 0) flag = false;\n    }\n    if(flag){\n      cout << 'c' << endl;\n    }else{\n      cout << 'd' << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((((cross(a,b)>0))&&(cross(b,c)>0))&&(cross(c,a)>0))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0);\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\t// OüªÆ~ÌSÌ£ªÇêàræè¨¨«­A©ÂO_Æ~ÌSÌ£ªræèå«­A©Â~Ì_ªOp`ÌàÉ¶ÝµÈ¢ê\n\t\t// ¤Êªðà½È¢\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r&&!EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))\n\t\t\t){\n\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef long double Double;\ntypedef complex<Double> P;\n#define Y imag()\n#define X real()\nconst Double EPS = (long double) 1 * 1e-12;\n\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\n\nDouble AreaOfPolygon(vector<P> p){\n}\nDouble get(P b[3]){\n\tP a[3];\n\tfor(int i = 0 ; i < 3 ; i++) a[i] = b[i];\n\ta[0] -= a[2];\n\ta[1] -= a[2];\n\treturn 0.5 * abs( a[0].X * a[1].Y - a[1].X * a[0].Y );\n}\n\n\nDouble nijo(P a){\n\treturn a.X * a.X + a.Y * a.Y;\n}\n \nDouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nP projection(const L &l, const P &p) {Double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\n\n\nDouble getPedal(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\n\nint main(){\n\tP a[3],c;Double r;\n\twhile(cin >> a[0].X >> a[0].Y && (a[0].X != 0 || a[0].Y != 0)){\n\t\tfor(int i = 1 ; i < 3 ; i++) cin >> a[i].X >> a[i].Y;\n\t\tcin >> c.X >> c.Y >> r;\n\t\tDouble S = get(a);\n\t\tfor(int i = 0 ; i < 3 ; i++){\n\t\t\tP b[3];\n\t\t\tb[0] = a[i];\n\t\t\tb[1] = a[(i+1)%3];\n\t\t\tb[2] = c;\n\t\t\tS -= get(b);\n\t\t}\n\t\t//cout << S << endl;\n\t\tbool in = S == 0;\n\t\tbool hit = getPedal(L(a[0],a[1]),c) < r || getPedal(L(a[1],a[2]),c) < r || getPedal(L(a[0],a[2]),c) < r;\n\t\t//cout << getPedal(L(a[0],a[1]),c) << \" \" << r << endl;\n\t\tif(  nijo(a[0]-c) < r*r && nijo(a[1]-c) < r*r && nijo(a[2]-c) < r*r) cout << \"b\" << endl;\n\t\telse if(in && !hit) cout << \"a\" << endl;\n\t\telse if(hit) cout << \"c\" << endl;\n\t\telse cout << \"d\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cmath>\n\n#define SAME_SIGN( a , b ) a * b > EPS\n\nnamespace geometry{\n\n\t#define EPS 1E-10\n\n\tstruct point{\n\t\tdouble x;\n\t\tdouble y;\n\t\tpoint(){}\n\t\tpoint( double x , double y ):x(x),y(y){}\n\t\tpoint& operator += ( const point& p ){ x += p.x; y += p.y; return *this; }\n\t\tpoint& operator -= ( const point& p ){ x -= p.x; y -= p.y; return *this; }\n\t\tpoint& operator *= ( double factor ){ x *= factor; y *= factor; return *this; }\n\t\tpoint& operator /= ( double factor ){ x /= factor; y /= factor; return *this; }\n\t\tbool operator == ( const point& p ) const { return (std::abs(x - p.x) < EPS && std::abs(y - p.y) < EPS); }\n\t\tbool operator != ( const point& p ) const { return !(*this == p); }\n\t\tdouble norm() const{ return sqrt( pow( x , 2) + pow( y , 2 ) ); }\n\t};\n\n\ttypedef point vector2d;\n\n\tstruct circle{\n\t\tpoint center;\n\t\tdouble radius;\n\t};\n\n\tstruct triangle{\n\t\tpoint a;\n\t\tpoint b;\n\t\tpoint c;\n\t};\n\n\tpoint operator + ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp += p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator - ( const point& p1 , const point& p2 ){\n\t\t\tpoint p(p1);\n\t\t\tp -= p2;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator * ( double factor , const point& p1 ){\n\t\t\tpoint p(p1);\n\t\t\tp *= factor;\n\t\t\treturn p;\n\t\t}\n\t\tpoint operator / ( const point& p1 , double factor ){\n\t\t\tpoint p(p1);\n\t\t\tp /= factor;\n\t\t\treturn p;\n\t\t}\n\n\tstd::istream& operator >> ( std::istream& s , point& p )\n\t{\n\t\treturn s >> p.x >> p.y;\n\t}\n\n\tdouble get_distance( const point& p1 , const point& p2 )\n\t{\n\t\treturn sqrt( pow( p1.x - p2.x , 2 ) + pow( p1.y - p2.y , 2 ) );\n\t}\n\n\tdouble get_dot_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.x + oa.y * ob.y;\n\t}\n\n\tdouble get_cross_product( const point& a , const point& b , const point& o )\n\t{\n\t\tvector2d oa = a - o;\n\t\tvector2d ob = b - o;\n\t\treturn oa.x * ob.y - oa.y * ob.x;\n\t}\n\n\tpoint get_project( const point& s , const point& e , const point& p ){\n\t\tdouble scale = get_dot_product( s , e , p ) / ( e - s ).norm();\n\t\treturn s + scale * ( e - s ) / ( e - s ).norm();\n\t}\n\n\tbool is_inter_point( const point& s , const point& e , const point& p ){\n\t\treturn std::abs(get_distance( s , p ) + get_distance( e , p ) - get_distance( s , e )) < EPS;\n\t}\n}\n\nusing namespace geometry;\n\nbool input_data( triangle& tri , circle& cir )\n{\n\tstd::cin >> tri.a;\n\tif( tri.a.x == 0 && tri.a.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.b;\n\tif( tri.b.x == 0 && tri.b.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> tri.c;\n\tif( tri.c.x == 0 && tri.c.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.center;\n\tif( cir.center.x == 0 && cir.center.y == 0 ){\n\t\treturn false;\n\t}\n\tstd::cin >> cir.radius;\n\treturn true;\n}\n\nbool is_overlap_for_one_side( const point& p1 , const point& p2 , circle& cir )\n{\n\tif( is_inter_point( p1 , p2 , get_project( p1 , p2 , cir.center )) ){\n\t\tif( get_distance( get_project( p1 , p2 , cir.center ) , cir.center ) <= cir.radius + EPS ){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse{\n\t\treturn false;\n\t}\n}\n\nbool is_overlap( triangle& tri , circle& cir )\n{\n\t// オーバーラップなし、あるいは円が三角形に完全に含まれる場合にfalse\n\tif( !(is_overlap_for_one_side( tri.a , tri.b , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.b , tri.c , cir )) &&\n\t\t!(is_overlap_for_one_side( tri.c , tri.a , cir ))\n\t\t){\n\t\t\treturn false;\n\t}\n\telse{\n\t\treturn true;\n\t}\n\n}\n\nvoid output_positional_relation_of_circle_and_triangle( triangle& tri , circle& cir )\n{\n\tif( get_distance( tri.a , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.b , cir.center ) <= cir.radius &&\n\t\tget_distance( tri.c , cir.center ) <= cir.radius\n\t\t){\n\t\t\tstd::cout << 'b' << std::endl;\n\t}\n\telse{\n\t\tif( get_distance( tri.a , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.b , cir.center ) > cir.radius &&\n\t\t\tget_distance( tri.c , cir.center ) > cir.radius\n\t\t\t){\n\t\t\t\tif( !(is_overlap( tri , cir )) ){\n\t\t\t\t\tif( SAME_SIGN( get_cross_product( tri.a , tri.b , cir.center ) , get_cross_product( tri.b , tri.c , cir.center ) ) &&\n\t\t\t\t\t\tSAME_SIGN( get_cross_product( tri.b , tri.c , cir.center ) , get_cross_product( tri.c , tri.a , cir.center ) )\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\tstd::cout << 'a' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstd::cout << 'd' << std::endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstd::cout << 'c' << std::endl;\n\t\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tstd::cout << 'c' << std::endl;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\ttriangle tri;\n\tcircle cir;\n\n\twhile(input_data(tri, cir)){\n\t\toutput_positional_relation_of_circle_and_triangle( tri , cir );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\ndouble EPS = 1e-10;\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n\n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n\n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n\n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n\n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n};\n\nstruct segment{\n  point a,b;\n};\n\nstruct circle{\n  point p;\n  double r;\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\nint ccw(point p0, point p1, point p2){\n  point a = p1 - p0;\n  point b = p2 - p0;\n  if(cross(a,b)>EPS)return +1;\n  if(cross(a,b)<EPS)return -1;\n  if(dot(a,b)<-EPS)return +2;\n  if(a.x*a.x+a.y*a.y<b.x*b.x+b.y*b.y)return -2;\n  return 0;\n}\n\ndouble vec_abs(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble distance_ls_p(point a, point b, point c) {\n  if ( dot(b-a, c-a) < EPS ) return vec_abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return vec_abs(c-b);\n  return abs(cross(b-a, c-a)) / vec_abs(b-a);\n}\n\ndouble dist(point a,point b){\n  return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));\n}\n\nint crossCS(point a, point b, circle c){\n  double res=distance_ls_p(a,b,c.p);\n  double ac=dist(a,c.p);\n  double bc=dist(b,c.p);\n\n  if(res>c.r || (ac<c.r && bc<c.r))return 0;\n  else if(c.r-res<EPS ||(ac<c.r && bc>=c.r)||(ac>=c.r && bc<c.r))return 1;\n  else return 2;\n}\n\nint EQ(point a, point b){\n  return vec_abs(a-b)<=EPS;\n}\n\nvector<segment> construct_edge(point* p, int n){\n  vector<segment>seg,seg2;\n  segment temp;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i!=j){\n\ttemp.a=p[i];\n\ttemp.b=p[j];\n\tseg.push_back(temp);\n      }\n    }\n  }\n\n  int t=seg.size();\n  for(int i=0;i<t;i++){\n    int fg=0;\n    for(int j=0;j<t;j++){\n     \n      if(i!=j && EQ(seg[i].b,seg[j].a)){\n\tif(ccw(seg[i].a,seg[i].b,seg[j].b)==1){\n\t  fg=1;\n\t  break;\n\t}\n      }\n    }\n    if(!fg)seg2.push_back(seg[i]);\n  }\n  return seg2;\n}\n\nint point_contain(vector<segment> ps, point p, int n){\n  int cnt=ccw(ps[0].a,ps[0].b,p);\n\n  for(int i=0;i<n;i++)\n    if(cnt!=ccw(ps[i].a,ps[i].b,p))return 0;\n  \n  return 1;\n}\n\nint containCS(point a,point b,circle c){\n  if(distance_ls_p(a,b,c.p)<c.r-EPS)return 1;\n  else return 0;\n}\n\nint main(void){\n  point p[3];\n  vector<segment> t;\n  circle C;\n\n  while(true){\n    for(int i=0;i<3;i++){\n      cin >> p[i].x >> p[i].y;\n      if(p[i].x==0 && p[i].y==0)return 0;\n    }\n    cin >> C.p.x >> C.p.y >> C.r;\n\n    double ans=0;\n    for(int i=0;i<3;i++){\n\tint tmp=dist(p[i],C.p);\n\tif(tmp>ans){\n\t  ans=tmp;\n\t}\n    }\n    if(C.r>ans){\n      cout <<'b'<<endl;\n      continue;\n    }\n    \n    t=construct_edge(p,3);\n    int res1=point_contain(t,C.p,3);\n    double res2=100000000;\n    for(int i=0;i<3;i++)\n      res2=min(res2,distance_ls_p(t[i].a,t[i].b,C.p));\n\n    if(res1 && C.r<=res2)cout <<'a'<< endl;\n    else if(!res1 && C.r<res2)cout <<'d'<< endl;\n    else cout <<'c'<< endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\n\nconst double EPS (1e-8);\nconst double PI=acos(-1.0);\n\ntemplate<class T>\nstruct point{\n    T x,y;\n    point() : x(0), y(0) {}\n    point(const T& x,const T& y) : x(x), y(y) {}\n    point operator+(const point &a)const{ return point(x+a.x,y+a.y); }\n    point& operator+=(const point &a){x += a.x; y += a.y; return *this;}\n    point operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n    point& operator-=(const point &a){x -= a.x; y -= a.y; return *this;}\n    point operator*(const double a)const{ return point(a*x,a*y); }\n    point& operator*=(const double a){ x *= a; y *= a; return *this;}\n    point operator/(const double a)const{ return point(x/a,y/a); }\n    point& operator/=(const double a){ x /= a; y /= a; return *this;}\n\t\n\t//比較用\n\tbool operator<(const point &a)const{return (x != a.x) ? (x < a.x) : (y < a.y);}\n \n};\n\ntemplate<class T> T SQ(T x){ return x*x; }\ntemplate<class T> T dist2(const point<T> &a,const point<T> &b){return SQ(a.x-b.x)+SQ(a.y-b.y);}\ntemplate<class T> T abs(const point<T>& p){return sqrt(SQ(p.x) + SQ(p.y));}\ntemplate<class T> T dot(const point<T>& a,const point<T>& b)\n{return a.x*b.x + a.y*b.y;}\ntemplate<class T> T cross(const point<T>& a,const point<T>& b)\n{return a.x*b.y - a.y*b.x;}\ntemplate<class T> point<T> rot(const point<T>& a,const double theta){\n        return point<T>(a.x*cos(theta)-a.y*sin(theta),\n\t\t\ta.x*sin(theta)+a.y*cos(theta));\n}\ntemplate<class T>\ndouble arg(const point<T> &a){\tdouble t=atan2(a.y,a.x); return t<0?t+2*PI:t; }\n\nenum{CCW=1,CW=-1,ON=0};\ntemplate<class T>\nint ccw(const point<T> &a,point<T> b,point<T> c){\n\tb -= a; c -= a;\n    double rdir=cross(b,c);\n    double len = abs(b) * abs(c); //誤差対策 (速度がやばい時は外すか、二乗に置き換える)\n    if(rdir> EPS * len) return CCW; //cがabより上(反時計周り)\n    if(rdir<-EPS * len) return CW; // cがabより下(時計周り)\n    return ON; // a,b,cが一直線上\n}\n\n//多角形の面積\ntemplate<class T>\nT area(const vector<point<T> >& v){\n\tT ans = 0;\n\tfor (int i = 2; i < (int)v.size(); i++){\n\t\tans += cross(v[i-1] - v[0],v[i] - v[0]);\n\t}\n\treturn abs(ans) / 2;\n}\n\ntemplate<class T>\nstruct segment{\n    point<T> a,b;\n    segment() : a(point<T>()), b(point<T>()) {}\n    segment(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nstruct line{\n    point<T> a,b;\n    line() : a(point<T>()), b(point<T>()) {}\n    line(const point<T>& a,const point<T>& b) : a(a), b(b) {}\n};\n\ntemplate<class T>\nbool intersect(const segment<T> &S1,const segment<T> &S2){\n    if(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n    || max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n    || max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n    || max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n    return ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n        && ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S,const point<T> &p){\n    if(dot(S.b-S.a,p-S.a)<=0) return dist2(p,S.a);\n    if(dot(S.a-S.b,p-S.b)<=0) return dist2(p,S.b);\n    return (double)SQ(cross(S.b-S.a,p-S.a)) / dist2(S.a,S.b);\n}\n\ntemplate<class T>\ndouble dist(const segment<T> &S,const point<T> &p){ return sqrt(dist2(S,p)); }\n\ntemplate<class T>\ndouble dist(const segment<T> &S1,const segment<T> &S2){\n    if(intersect(S1,S2)) return 0;\n    return sqrt(min(min(dist2(S1,S2.a),dist2(S1,S2.b)),\n                    min(dist2(S2,S1.a),dist2(S2,S1.b))));\n}\n\ntemplate<class T>\ndouble dist(const line<T> &L,const point<T> &p){\n    return sqrt((double)SQ(cross(L.b-L.a,p-L.a)) / dist2(L.a,L.b));\n}\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n\tcircle(){}\n\tcircle(const point<T> &c, T& r) : c(c),r(r) {}\n};\n\n//a -- bの間の円が入った時の、a - b間の距離\n//円の間に\ntemplate<class T>\ndouble geodist(point<T> a,point<T> b,const circle<T> &C){\n\tdouble r=C.r;\n\tsegment<T> s(a,b);\n\tif(dist(s,C.c)>r) \n\t\treturn abs(a-b);\n\n\ta-=C.c;\n\tb-=C.c;\n\n\tdouble L1=abs(a);\n\tdouble t1=arg(a)+acos(r/L1); if(t1<0) t1+=2*PI;\n\tdouble t2=arg(a)-acos(r/L1); if(t2<0) t2+=2*PI;\n\n\tdouble L2=abs(b);\n\tdouble t3=arg(b)+acos(r/L2); if(t3<0) t3+=2*PI;\n\tdouble t4=arg(b)-acos(r/L2); if(t4<0) t4+=2*PI;\n\n\tdouble theta=2*PI;\n\ttheta=min(theta,min(abs(t1-t4),2*PI-abs(t1-t4)));\n\ttheta=min(theta,min(abs(t2-t3),2*PI-abs(t2-t3)));\n\treturn sqrt(L1*L1-r*r)+sqrt(L2*L2-r*r)+r*theta;\n}\n\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const point<T>& point){return ( os << '(' << point.x << ',' << point.y << ')' );}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os, const segment<T>& seg){return ( os << '{' << seg.a << ',' << seg.b << '}' );}\n \ntemplate<class T>\nstd::istream& operator>>(std::istream& is, point<T>& point){return ( is >> point.x >> point.y );}\n\ntypedef point<double> P;\ntypedef segment<double> S;\ntypedef line<double> L;\ntypedef circle<double> C;\n\n\n//円の接点\nvector<P> GetContact(const P& p,const P& q,const double r){\n\tP a = p-q;\n\tdouble s = SQ(a.x) + SQ(a.y);\n\tdouble D = sqrt(s - SQ(r));\n\tdouble dx = r * D * a.y / s;\n\tdouble dy = r * D * a.x / s;\n\tdouble bx = SQ(r) * a.x / s;\n\tdouble by = SQ(r) * a.y / s;\n\tvector<P> ans(2);\n\tans[0].x = bx + dx;\n\tans[0].y = by - dy;\n\tans[1].x = bx - dx;\n\tans[1].y = by + dy;\n\n\tans[0] += q;\n\tans[1] += q;\n\n\treturn ans;\n}\n\n//todo : verifyしてないので、そのうち。\n// 円が交差しているか 「=」は問によって変更する\ntemplate<class T>\nint CircleCross(const circle<T> &c1,const circle<T> &c2){\n\tdouble l = abs(c1.c - c2.c);\n\tif(l >= c1.r + c2.r) return 3; //外部にある\n\tif(l + c1.r <= c2.r) return 2; //c1 ⊃ c2\n\tif(l + c2.r <= c1.r) return 1; //c1 ⊂ c2\n\treturn 0; //交差している\n}\n\n\ntypedef pair<P,P> PD;\n//円同士の交点\nPD GetContact(const P& p, const P &q,double pr,double pq){\n\tP a = q-p;\n\tP b = rot(a,PI / 2);\n\tdouble c = abs(a);\n\tb = b / c;\n\n\tdouble s = (pr + pq + c) / 2;\n\tdouble men = sqrt(s * (s - pr) * (s - pq) * (s - c));\n\tdouble l = 2 * men / c;\n\tdouble lp = sqrt(SQ(pr) - SQ(l));\n\t\n\ta = a / c * lp;\n\tb = b * l;\n\treturn PD(p + a + b,p + a - b);\n}\n\n//凸包\nvector<P> convex_hull(vector<P>& ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<P> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n\n  ch.resize(k-1);\n\n  return ch;\n}\n\n\n//三角形の中にあるか\nbool InTri(const P p[3],const P& o){\n\treturn \n\t\t(ccw(p[0],p[1],p[2]) == ccw(p[0],p[1],o)) &&\n\t\t(ccw(p[1],p[2],p[0]) == ccw(p[1],p[2],o)) &&\n\t\t(ccw(p[2],p[0],p[1]) == ccw(p[2],p[0],o));\n}\n\n\nint main(){\n\tP p[3];\n\tC c;\n\twhile(cin>>p[0],p[0].x != 0 || p[0].y != 0){\n\t\tcin>>p[1]>>p[2];\n\t\tcin>>c.c>>c.r;\n\t\tbool ok = true;\n\t\tFOR(i,3){\n\t\t\tif(abs(p[i]-c.c) > c.r) ok = false;\n\t\t}\n\n\t\t//in-circle\n\t\tif(ok){ puts(\"b\"); continue; }\n\n\t\tFOR(i,3){\n\t\t\tdouble l = dist(S(p[i],p[(i+1)%3]),c.c);\n\t\t\tif(l < c.r) ok = true;\n\t\t}\n\n\t\t//intersect\n\t\tif(ok){ puts(\"c\"); continue; }\n\n\t\tif(InTri(p,c.c))\n\t\t\tputs(\"a\"); //in-triangle\n\t\telse\n\t\t\tputs(\"d\"); //otherwise\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP intersect_ls(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\ndouble distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.c < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nint main(){\n\tdouble x,y;\n\twhile(cin>>x>>y,x+y){\n\t\tG q(3);\n\t\tq[0]=P(x,y);\n\t\tPIN(&q[1],2);\n\t\tG p=convex_hull(q);\n\t\tC c=CIN();\n\t\tbool h=true;\n\t\trep(i,3)if(c.r<EPS+abs(p[i]-c.c))h=false;\n\t\tif(h){cout<<\"b\"<<endl;continue;}\n\t\th=false;\n\t\trep(i,3)if(intersectCL(c,L(p[i],p[(i+1)%3])))h=true;\n\t\tif(h){cout<<\"c\"<<endl;continue;}\n\t\th=true;\n\t\trep(i,3)if(ccw(p[i],p[(i+1)%3],c.c)==-1)h=false;\n\t\tif(h)cout<<\"a\"<<endl;\n\t\telse cout<<\"d\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\n\ntypedef complex<double> P;\ntypedef const P &rP;\ntypedef pair<P,P> seg;\n//naiseki\ndouble dot(rP a, rP b){\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n//gaiseki\ndouble cross(rP a, rP b){\n    return real(a) * imag(b) - imag(a) * real(b);\n}\nbool intersectSP(P a,P b, const P &p) {\n  return abs(a-p)+abs(b-p)-abs(b-a) < EPS; // triangle inequality\n}\nP projection(P a,P b, const P &p) {\n  double t = dot(p-a, a-b) / norm(a-b);\n  return a + t*(a-b);\n}\ndouble distanceSP(P a,P b, const P &p) {\n  const P r = projection(a,b, p);\n  if (intersectSP(a,b, r)) return abs(r - p);\n  return min(abs(a - p), abs(b - p));\n}\nbool foo(P a,P b,P c,P d){\n\tP aa=a-c,ar=d-a;\n\tP bb=b-a,br=d-b;\n\tP cc=c-b,cr=d-c;\n\tdouble a2=dot(aa,ar),b2=dot(bb,br),c2=dot(cc,cr);\n\tif(a2>EPS&&b2>EPS&&c2>EPS) return true;\n\tif(a2<-EPS&&b2<-EPS&&c2<-EPS) return true;\n\treturn false;\n}\nbool foo2(P a,P b,P p,double r){\n\tdouble t=dot(b-a,p-a);\n\tif(t<-EPS){\n\t\t// cout<<\"a\"<<endl;\n\t\tif(r-abs(p-a)>EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse return false;\n\t}\n\tif(t-abs(b-a)*abs(b-a)>EPS){\n\t\t// cout<<\"b\"<<endl;\n\t\tif(r-abs(p-b)>EPS){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\t// cout<<\"c\"<<endl;\n\tdouble h=abs(p-a)*abs(p-a)-t*t/abs(b-a)/abs(b-a);\n\t// printf(\"%.6lf\\n\",h);\n\tif(h-r*r>EPS){\n\t\treturn false;\n\t}\n\treturn true;\n}\nvoid mainmain(){\n\tdouble r;\n\tdouble x,y;\n\twhile(cin>>x>>y,x||y){\n\t\t// cout<<x<<\" \"<<y<<endl;\n\t\tvector<P> z;\n\t\tz.PB(P(x,y));\n\t\trep(i,3){\n\t\t\tcin>>x>>y;\n\t\t\tz.PB(P(x,y));\n\t\t}\n\t\tcin>>r;\n\t\t// cout<<r<<endl;\n\t\tif(r>=abs(z[0]-z[3])&&r>=abs(z[1]-z[3])&&r>=abs(z[2]-z[3])){\n\t\t\tcout<<\"b\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tbool f=true;\n\t\trep(i,3){\n\t\t\tdouble t=distanceSP(z[i%3],z[(i+1)%3],z[3]);\n\t\t\t// cout<<t<<endl;\n\t\t\tif(r-t>EPS){\n\t\t\t\t// cout<<real(z[i%3])<<\" \"<<imag(z[(i+1)%3])<<endl;\n\t\t\t\tf=false;\n\t\t\t}\n\t\t}\n\t\tif(f&&foo(z[0],z[1],z[2],z[3])){\n\t\t\tcout<<\"a\\n\";\n\t\t}\n\t\telse if(foo2(z[0],z[1],z[3],r)||foo2(z[1],z[2],z[3],r)||foo2(z[2],z[0],z[3],r)){\n\t\t\tcout<<\"c\\n\";\n\t\t}\n\t\telse cout<<\"d\\n\";\n\t\t// cout<<\"aaa\"<<endl;\t\n\t}\n\t// cout<<abs(P(0,0)-P(1,1))<<endl;\n}\n\n\n\n}\nmain() try{\n\t// vector<P> d;\n\t// double r;\n\t// rep(i,3){\n\t\t// double x,y;\n\t\t// cin>>x>>y;\n\t\t// d.PB(P(x,y));\n\t// }\n\t// cin>>r;\n\t// cout<<foo2(d[0],d[1],d[2],r)<<endl;\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\nclass inPoint{\npublic:\n  int x;\n  int y;\n};\n\nclass Delta{\npublic:\n  inPoint p[3];\n};\n\nclass Circle{\npublic:\n  inPoint p;\n  int radius;\n};\n\ndouble distance(inPoint *p1, inPoint *p2){\n  return sqrt((p1->x-p2->x)*(p1->x-p2->x)+(p1->y-p2->y)*(p1->y-p2->y));\n}\n\ndouble dist_line(inPoint *pl1, inPoint *pl2, inPoint *p){\n  int a = pl1->x - pl2->x;\n  int b = pl2->y - pl1->y;\n  int c = pl1->y * pl2->x - pl1->x * pl2->y;\n  double ans = b * p->x + a * p->y + c;\n  ans = (ans >= 0) ? ans : -ans;\n  return ans / sqrt(a*a + b*b);\n}\nint main(void){\n  string str;\n  /*\n  ifstream ifs(\"../input.txt\");\n  if (ifs.fail()) {\n      cerr << \"cannot find the file\" << endl;\n      return 1;\n  }\n  */\n  while(1){\n    Circle *c = (Circle *) malloc(sizeof(Circle));\n    Delta *d = (Delta *) malloc(sizeof(Delta));\n    for (int i = 0; i < 5; i++) {\n      getline(cin, str);\n\n      if(str == \"0 0\") break;\n\n      int j;\n      for(j = 0; j <(int) str.size(); j++){\n          if(str[j] == ' '){\n            str[j] = '\\0';\n            break;\n        }\n      }\n      switch(i){\n        case 0:\n        case 1:\n        case 2:\n        d->p[i].x = atoi(str.c_str());\n        d->p[i].y = atoi(&str[j+1]);\n        break;\n        case 3:\n        c->p.x = atoi(str.c_str());\n        c->p.y = atoi(&str[j+1]);\n        break;\n        case 4:\n        c->radius = atoi(str.c_str());\n        break;\n      }\n\n    }\n    if(str == \"0 0\") break;\n\n\n    if(distance(&d->p[0], &c->p) <= c->radius&& distance(&d->p[1], &c->p) <= c->radius&& distance(&d->p[2], &c->p) <= c->radius){\n      cout << 'b' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) >= c->radius&& dist_line(&d->p[0], &d->p[2], &c->p) >= c->radius&& dist_line(&d->p[1], &d->p[2], &c->p) >= c->radius){\n        if (dist_line(&d->p[0], &d->p[1], &d->p[2]) <= distance(&d->p[0], &c->p) && dist_line(&d->p[1], &d->p[2], &d->p[0]) <= distance(&d->p[1], &c->p) && dist_line(&d->p[2], &d->p[0], &d->p[1]) <= distance(&d->p[2], &c->p))\n            cout << 'd' << endl;\n        else\n            cout << 'a' << endl;\n    }\n    else if(dist_line(&d->p[0], &d->p[1], &c->p) <= c->radius|| dist_line(&d->p[0], &d->p[2], &c->p) <= c->radius|| dist_line(&d->p[1], &d->p[2], &c->p) <= c->radius){\n      cout << 'c' << endl;\n    }\n    else{\n\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nstatic const double eps = 1e-10;\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nbool equals(double a, double b)\n{\n\treturn(fabs(a - b) < eps);\n}\n\nclass Point\n{\npublic:\n\tdouble x, y;\n\tPoint(double x = 0, double y = 0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return(Point(x + p.x, y + p.y)); }\n\tPoint operator - (Point p){ return(Point(x - p.x, y - p.y)); }\n\tPoint operator * (double a){ return(Point(a * x, a * y)); }\n\tPoint operator / (double a){ return(Point(x / a, y / a)); }\n\n\tdouble abs(){ return(sqrt(norm())); }\n\tdouble norm(){ return(x * x + y * y); }\n\n\tbool operator < (const Point& p) const\n\t{\n\t\treturn(x != p.x ? x < p.x : y < p.y);\n\t}\n\n\tbool operator == (const Point& p) const\n\t{\n\t\treturn(fabs(x - p.x) < eps && fabs(y - p.y) < eps);\n\t}\n};\ntypedef Point Vector;\n\n\nstruct Segment\n{\n\tPoint p1, p2;\n\tSegment(Point p1, Point p2) : p1(p1), p2(p2){};\n};\ntypedef Segment Line;\n\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) : c(c), r(r){}\n};\n\ndouble dot(Vector a, Vector b)\n{\n\treturn(a.x * b.x + a.y * b.y);\n}\n\ndouble cross(Vector a, Vector b)\n{\n\treturn(a.x * b.y - a.y * b.x);\n}\n\nPoint project(Segment s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn(s.p1 + base * r);\n}\n\nPoint reflect(Segment s, Point p)\n{\n\treturn(p + (project(s, p) - p) * 2.0);\n}\n\nbool isOrthogonal(Vector a, Vector b)\n{\n\treturn(equals(dot(a, b), 0.0));\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isOrthogonal(a1 - a2, b1 - b2));\n}\n\nbool isOrthogonal(Segment s1, Segment s2)\n{\n\treturn(equals(dot(s1.p2 - s2.p1, s2.p2 - s2.p1), 0.0));\n}\n\nbool isParallel(Vector a, Vector b)\n{\n\treturn(equals(cross(a, b), 0.0));\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn(isParallel(a1 - a2, b1 - b2));\n}\n\nbool isParallel(Segment s1, Segment s2)\n{\n\treturn(equals(cross(s1.p1 - s1.p1, s2.p2 - s2.p1), 0.0));\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif (cross(a, b) > eps)\n\t{\n\t\treturn(COUNTER_CLOCKWISE);\n\t}\n\tif (cross(a, b) < -eps)\n\t{\n\t\treturn(CLOCKWISE);\n\t}\n\tif (dot(a, b) < -eps)\n\t{\n\t\treturn(ONLINE_BACK);\n\t}\n\tif (a.norm() < b.norm())\n\t{\n\t\treturn(ONLINE_FRONT);\n\t}\n\treturn(ON_SEGMENT);\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n\treturn(ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2)\n{\n\treturn(intersect(s1.p1, s1.p2, s2.p1, s2.p2));\n}\n\ndouble getDistance(Point a, Point b)\n{\n\treturn((a - b).abs());\n}\n\ndouble getDistanceLP(Line l, Point p)\n{\n\treturn(abs((cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs())));\n}\n\ndouble getDistanceSP(Segment s, Point p)\n{\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)\n\t{\n\t\treturn((p - s.p1).abs());\n\t}\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)\n\t{\n\t\treturn((p - s.p2).abs());\n\t}\n\treturn(getDistanceLP(s, p));\n}\n\ndouble getDistance(Segment s1, Segment s2)\n{\n\tif (intersect(s1, s2))\n\t{\n\t\treturn(0.0);\n\t}\n\treturn(min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2))));\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn(s1.p1 + (s1.p2 - s1.p1) * t);\n}\n\ndouble arg(Vector p)\n{\n\treturn(atan2(p.y, p.x));\n}\n\nVector polar(double a, double r)\n{\n\treturn(Point(cos(r) * a, sin(r) * a));\n}\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2)\n{\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn(make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a)));\n}\n\npair<Point, Point> getCrossPoints(Circle c, Line l)\n{\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r * c.r - (pr - c.c).norm());\n\treturn(make_pair(pr - e * base, pr + e * base));\n}\n\nvoid solve()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tPoint p1;\n\twhile (cin >> p1.x >> p1.y, p1.x || p1.y)\n\t{\n\t\tPoint p2, p3, p4;\n\t\tint r;\n\t\tcin >> p2.x >> p2.y >> p3.x >> p3.y >> p4.x >> p4.y >> r;\n\t\t\n\t\tif (r - getDistance(p4, p1) > eps && r - getDistance(p4, p2) > eps && r - getDistance(p4, p3) > eps)\n\t\t{\n\t\t\tcout << \"b\" << endl;\n\t\t}\n\t\telse if (cross(p2 - p1, p4 - p1) * cross(p3 - p1, p4 - p1) < eps && cross(p2 - p3, p4 - p3) * cross(p1 - p3, p4 - p3) < eps && cross(p1 - p2, p4 - p2) * cross(p3 - p2, p4 - p2) < eps &&\n\t\t\t     getDistanceSP(Segment(p1, p2), p4) - r > eps && getDistanceSP(Segment(p1, p3), p4) - r > eps && getDistanceSP(Segment(p2, p3), p4) - r > eps)\n\t\t{\n\t\t\tcout << \"a\" << endl;\n\t\t}\n\t\telse if (getDistanceSP(Segment(p1, p2), p4) - r > eps && getDistanceSP(Segment(p1, p3), p4) - r > eps && getDistanceSP(Segment(p2, p3), p4) - r > eps)\n\t\t{\n\t\t\tcout << \"d\" << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"c\" << endl;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n// ½ÊãÌ_ExNg\ntypedef complex<double> P;\nnamespace std{\n\tbool operator< (const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// OÏ\ndouble cross(const P& a, const P& b){\n\treturn imag(conj(a)*b);\n}\n\n// àÏ\ndouble dot(const P& a, const P& b){\n\treturn real(conj(a)*b);\n}\n\n// ¼ü\nstruct L : public vector<P> {\n\tL(const P &a, const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n// ½p`\ntypedef vector<P> G;\n\n// ~\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r) : p(p), r(r) {}\n};\n\nint ccw(P a, P b, P c)\n{\n\tb -= a;\n\tc -= a;\n\tif(cross(b, c) > 0)   return +1; // ½vñè\n\tif(cross(b, c) < 0)   return -1; // vñè\n\tif(dot(b, c) < 0)     return +2; // c--a--b\n\tif(norm(b) < norm(c)) return -2; // a--b--c\n\treturn 0;\n}\n\n// üªÆ_Ìð·»è\nbool intersectSP(const L& s, const P& p){\n\treturn abs(s[0]-p) + abs(s[1]-p) - abs(s[1]-s[0]) < EPS;\n}\n\n// ¼üãÌ_ÌËe\nP projection(const L& l, const P& p){\n\tdouble t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n\treturn l[0] + t*(l[0]-l[1]);\n}\n\n// üªÆ_Ì£\ndouble distanceSP(const L& s, const P& p){\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0]-p), abs(s[1]-p));\n}\n\nchar detect(const G& tri, const C& c)\n{\n\tbool inner[3];\n\trep(i, 3){\n\t\tinner[i] = abs(tri[i] - c.p) - EPS <= c.r;\n\t}\n\tif(inner[0] && inner[1] && inner[2])\n\t\treturn 'b';\n\tif(inner[0] || inner[1] || inner[2])\n\t\treturn 'c';\n\t\n\trep(i, 3){\n\t\tL l(tri[i], tri[(i+1)%3]);\n\t\tif(distanceSP(l, c.p) - EPS <= c.r)\n\t\t\treturn 'c';\n\t}\n\t\n\tint v = 0;\n\trep(i, 3){\n\t\tint now = ccw(tri[i], tri[(i+1)%3], c.p);\n\t\tif(abs(now) == 2 || now * v < 0)\n\t\t\treturn 'd';\n\t\tv = now;\n\t}\n\t\n\treturn 'a';\n}\n\nint main()\n{\n\tfor(;;){\n\t\tG tri(3);\n\t\trep(i, 3){\n\t\t\tscanf(\"%lf%lf\", &tri[i].real(), &tri[i].imag());\n\t\t\tif(fabs(tri[i].real()) < EPS)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(fabs(tri[0].real()) < EPS)\n\t\t\tbreak;\n\t\t\n\t\tP p;\n\t\tdouble r;\n\t\tscanf(\"%lf%lf%lf\", &p.real(), &p.imag(), &r);\n\t\tprintf(\"%c\\n\", detect(tri, C(p, r)));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace geometry\n{\t\n\ttypedef double D;\n\ttypedef complex<D> P;\n\ttypedef pair<P, P> S;\n\ttypedef S L;\n\ttypedef pair<P, D> C;\n\t\n\t#define EPS \t\t(1e-10)\n\t#define EQ(a, b) \t(abs((a) - (b)) < EPS)\n\t#define EQV(a, b) \t(EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n\t\n\tstatic const int COUNTER_CLOCKWISE \t=  1;\n\tstatic const int CLOCKWISE\t\t\t= -1;\n\tstatic const int ONLINE_BACK\t\t=  2;\n\tstatic const int ONLINE_FRONT\t\t= -2;\n\tstatic const int ON_SEGMENT\t\t\t=  0;\n\t\n\tstatic const int IN\t\t= 2;\n\tstatic const int ON\t\t= 1;\n\tstatic const int OUT\t= 0;\n\t\n\tbool cmp(const P& a, const P& b){\n\t\tif (a.real() != b.real()) return a.real() < b.real();\n\t\treturn a.imag() < b.imag();\n\t}\n\t\n\tvoid debug(P p){\n\t\tprintf(\"    x: %f, y: %f\\n\", p.real(), p.imag()); \n\t}\n\tvoid debug(C c){\n\t\tprintf(\"    x: %f, y: %f, r: %f\\n\", c.first.real(), c.first.imag(), c.second);\n\t}\n\tvoid debug(S s){\n\t\tprintf(\"{\\n\");\n\t\tdebug(s.first);\n\t\tdebug(s.second);\n\t\tprintf(\"}\\n\");\n\t}\n\tvoid debug(vector<P> poly){\n\t\tprintf(\"{\\n\");\n\t\tfor (int i = 0; i < poly.size(); i++){\n\t\t\tdebug(poly[i]);\n\t\t}\n\t\tprintf(\"}\\n\");\n\t}\n\t\n\tD norm(P a) { return a.real() * a.real() + a.imag() * a.imag(); }\n\t\n\tD dot(P a, P b) { return a.real() * b.real() + a.imag() * b.imag(); }\n\tD cross(P a, P b) { return a.real() * b.imag() - a.imag() * b.real(); }\n\t\n\tbool isOrthogonal(P a1, P a2, P b1, P b2) { return EQ(dot(a1 - a2, b1 - b2), 0.0); }\n\tbool isOrthogonal(L a, L b) { return isOrthogonal(a.first, a.second, b.first, b.second); }\n\tbool isParallel(P a1, P a2, P b1, P b2) { return EQ(cross(a1 - a2, b1 - b2), 0.0); }\n\tbool isParallel(L a, L b) { return isParallel(a.first, a.second, b.first, b.second); }\n\t\n\tbool isPointOnLine(P a, P b, P c) { return EQ(cross(b - a, c - a), 0.0); }\n\tbool isPointOnLine(L a, P b) { return isPointOnLine(a.first, a.second, b); }\n\tbool isPointOnSegment(P a, P b, P c) {\n\t\treturn EQ(cross(b - a, c - a), 0.0) &&\n\t\t       (dot(b - a, c - a) > -EPS) &&\n\t\t\t   (dot(a - b, c - b) > -EPS);\n\t}\n\tbool isPointOnSegment(S a, P b) { return isPointOnLine(a.first, a.second, b); }\n\t\n\tint ccw(P p0, P p1, P p2){\n\t\tP a = p1 - p0;\n\t\tP b = p2 - p0;\n\t\tif (cross(a, b) > EPS) \treturn COUNTER_CLOCKWISE;\n\t\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t\tif (dot(a, b) < -EPS)\treturn ONLINE_BACK;\n\t\tif (norm(a) < norm(b))\treturn ONLINE_FRONT;\n\t\treturn ON_SEGMENT;\n\t}\n\t\n\tbool intersect(P p1, P p2, P p3, P p4){\n\t\treturn ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t\t       ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0;\n\t}\n\tbool intersect(S s1, S s2){\n\t\treturn intersect(s1.first, s1.second, s2.first, s2.second);\n\t}\n\t\n\tD distanceLP(P a, P b, P c) { return abs(cross(b - a, c - a)) / abs(b - a); }\n\tD distanceLP(L a, P b) { return distanceLP(a.first, a.second, b); }\n\tD distanceSP(P a, P b, P c) {\n\t\tif (dot(b - a, c - a) < EPS) return abs(c - a);\n\t\tif (dot(a - b, c - b) < EPS) return abs(c - b);\n\t\treturn abs(cross(b - a, c - a)) / abs(b - a);\n\t}\n\tD distanceSP(S a, P b) { return distanceSP(a.first, a.second, b); }\n\tD distanceCS(C c, S s){\n\t\treturn distanceSP(s, c.first) - c.second;\n\t}\n\t\n\tbool intersectCL(C c, L l){\n\t\treturn c.second - distanceLP(l, c.first) > -EPS;\n\t}\n\tbool intersectCS(C c, S s){\n\t\tif (EQ(c.second - abs(c.first - s.first), 0.0) ||\n\t\t\tEQ(c.second - abs(c.first - s.second), 0.0)) return true;\n\t\tif (c.second - distanceSP(s, c.first) > -EPS){\n\t\t\treturn (c.second - abs(c.first - s.first) < EPS ||\n\t\t\t\t    c.second - abs(c.first - s.second) < EPS);\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tP project(S s, P p){\n\t\tP base = s.second - s.first;\n\t\tD r = dot(p - s.first, base) / norm(base);\n\t\treturn s.first + base * r;\n\t}\n\tP reflect(S s, P p){\n\t\treturn p + (project(s, p) - p) * (D)2.0;\n\t}\n\t\n\tP crossPoint(S s1, S s2){\n\t\tP base = s2.second - s2.first;\n\t\tD d1 = abs(cross(base, s1.first - s2.first));\n\t\tD d2 = abs(cross(base, s1.second - s2.first));\n\t\tD t = d1 / (d1 + d2);\n\t\treturn s1.first + (s1.second - s1.first) * t;\n\t}\n\t\n\tD area(vector<P> poly){\n\t\tif (poly.size() < 3) return 0.0;\n\t\tD res = 0.0;\n\t\tfor (int i = 1; i < poly.size() - 1; i++){\n\t\t\tP v1 = poly[i] - poly[0];\n\t\t\tP v2 = poly[i + 1] - poly[0];\n\t\t\tres += abs(cross(v1, v2)) / 2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpair<P, P> crossPoints(C c, L l){\n\t\tP pr = project(l, c.first);\n\t\tP e = (l.second - l.first) / abs(l.second- l.first);\n\t\tD base = sqrt(c.second * c.second - norm(pr - c.first));\n\t\treturn make_pair(pr + e * base, pr - e * base);\n\t}\n\t\n\tbool intersect(C c1, C c2){\n\t\treturn abs(c1.first - c2.first) - c1.second - c2.second < EPS;\n\t}\n\t\n\tpair<P, P> crossPoints(C c1, C c2){\n\t\tD d = abs(c1.first - c2.first);\n\t\tD a = acos((c1.second * c1.second + d * d - c2.second * c2.second) / (2 * c2.second * d));\n\t\tD t = arg(c2.first - c1.first);\n\t\treturn make_pair(c1.first + polar(c1.second, t + a), c1.first + polar(c1.second, t - a));\n\t}\n\t\n\tint contains(vector<P> g, P p){\n\t\tint n = g.size();\n\t\tbool x = false;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\t\tif (abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON;\n\t\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\t\tif (a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS) x = !x;\n\t\t}\n\t\treturn (x ? IN : OUT);\n\t}\n\t\n\tint contains(C c, P p) {\n\t\tD d = abs(c.first - p);\n\t\tif (EQ(d, c.second)) return ON;\n\t\tif (d < c.second) return IN;\n\t\treturn OUT;\n\t}\n\t\n\tvector<P> convexHull(vector<P> s){\n\t\tif (s.size() < 3) return s;\n\t\tvector<P> u, l;\n\t\tsort(s.begin(), s.end(), cmp);\n\t\tu.push_back(s[0]);\n\t\tu.push_back(s[1]);\n\t\tl.push_back(s[s.size() - 1]);\n\t\tl.push_back(s[s.size() - 2]);\n\t\tfor (int i = 2; i < s.size(); i++){\n\t\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != CLOCKWISE/* && ccw(u[n - 2], u[n - 1], s[i]) != ONLINE_FRONT*/; n--){\n\t\t\t\tu.pop_back();\n\t\t\t}\n\t\t\tu.push_back(s[i]);\n\t\t}\n\t\tfor (int i = s.size() - 3; i >= 0; i--){\n\t\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != CLOCKWISE/* && ccw(l[n - 2], l[n - 1], s[i]) != ONLINE_FRONT*/; n--){\n\t\t\t\tl.pop_back();\n\t\t\t}\n\t\t\tl.push_back(s[i]);\n\t\t}\n\t\treverse(l.begin(), l.end());\n\t\tfor (int i = u.size() - 2; i >= 1; i--){\n\t\t\tl.push_back(u[i]);\n\t\t}\n\t\treturn l;\n\t}\n}\n\nusing namespace geometry;\n\nvoid solve(vector<P> t, C c)\n{\n\tbool f = true;\n\tfor (int i = 0; i < 3; i++){\n\t\tif (!contains(c, t[i])) f = false;\n\t}\n\tif (f){\n\t\tputs(\"b\");\n\t\treturn;\n\t}\n\t\n\tf = true;\n\tfor (int i = 0; i < 3; i++){\n\t\tS s(t[i], t[(i + 1) % 3]);\n\t\tif (distanceCS(c, s) < -EPS) f = false;\n\t}\n\tif (f && contains(t, c.first)){\n\t\tputs(\"a\");\n\t\treturn;\n\t}\n\t\n\tfor (int i = 0; i < 3; i++){\n\t\tS s(t[i], t[(i + 1) % 3]);\n\t\tif (intersectCS(c, s)){\n\t\t\tputs(\"c\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tputs(\"d\");\n}\n\nint main()\n{\n\tD x, y, r;\n\twhile (true){\n\t\tvector<P> t;\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tcin >> x >> y;\n\t\t\tif (EQ(i + x + y, 0)) return 0;\n\t\t\tt.push_back(P(x, y));\n\t\t}\n\t\tcin >> x >> y >> r;\n\t\tC c(P(x, y), r);\n\t\t\n\t\tsolve(t, c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn (((cross(a,b)>0||EQ(0,cross(a,b)))&&(cross(b,c)>=0||EQ(0,cross(b,c)))&&(cross(c,a)>=0||EQ(0,cross(a,b))))\n\t\t||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n\nstruct Circle{\n\tdouble x,y,r;\n};\n\nstruct Triangle{\n\tcomplex<double> p[3];\n};\n\nint main(){\n\n\tCircle c;\n\tTriangle t;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tif(x==0&&y==0){\n\t\t\t\tf=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt.p[i]=complex<double>(x,y);\n\t\t}\n\t\tif(f)\n\t\t\tbreak;\n\t\tcin>>c.x>>c.y>>c.r;\n\t\t// vZ\n\t\t// Op`ð\\¬·éR_ªÆàÉ~ÌàÉ éÈçÎAOp`Í~ÉÜÜêé\n\t\tif(((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)<c.r*c.r||EQ((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)<c.r*c.r||EQ((t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y),c.r*c.r))\n\t\t\t&&((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)<c.r*c.r||EQ((t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y),c.r*c.r))\n\t\t\t){\n\t\t\t\tcout<<\"b\"<<endl;\n\t\t}\n\t\t// 3üªÆ~ÌSÌ£ªÇêàrÈãÅ èA©Â~Ì_ªOp`ÌàÉ¶Ý·éÈçÎA~ÍOp`ÉÜÜêé\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[0],t.p[1],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y)),c.r))\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r||EQ(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y)),c.r))\n\t\t\t&&isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y))\n\t\t\t){\n\t\t\t\tcout<<\"a\"<<endl;\n\t\t}\n\t\telse if((distance_ls_p(t.p[0],t.p[1],P(c.x,c.y))>c.r)\n\t\t\t&&(distance_ls_p(t.p[1],t.p[2],P(c.x,c.y))>c.r)\n\t\t\t&&(distance_ls_p(t.p[2],t.p[0],P(c.x,c.y))>c.r)\n\t\t\t&&(!isInTriangle(t.p[0],t.p[1],t.p[2],P(c.x,c.y)))){\n\t\t\t\tcout<<\"d\"<<endl;\n\t\t}\n\t\t// ~ªOp`ÉÜÜê¸A©ÂO_ÆàÉ~ÌOÉ éÈçÎAOp`Æ~Ì¤ÊªÍÈ¢\n\t\t//else if((t.p[0].real()-c.x)*(t.p[0].real()-c.x)+(t.p[0].imag()-c.y)*(t.p[0].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[1].real()-c.x)*(t.p[1].real()-c.x)+(t.p[1].imag()-c.y)*(t.p[1].imag()-c.y)>c.r*c.r\n\t\t//\t&&(t.p[2].real()-c.x)*(t.p[2].real()-c.x)+(t.p[2].imag()-c.y)*(t.p[2].imag()-c.y)>c.r*c.r){\n\t\t//\t\tcout<<\"d\"<<endl;\n\t\t//}\n\t\telse{\n\t\t\tcout<<\"c\"<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n\n#define IL inline \nnamespace geo {\n    typedef double D;\n    typedef bool B;\n    typedef complex<D> P;\n#define X real()\n#define Y imag()\n    B comp(const P& l, const P& r){ return (l.X == r.X) ? l.Y < r.Y : l.X < r.X; }\n    typedef pair<P, P> L;  //line\n    typedef pair<P, P> LS; //line segment\n    typedef pair<P, D> C;  //circle\n    typedef vector<P> Poly;\n    const D EPS = 1e-8;\n    //Decompotision Macro\n#define DCl(a,b,l) P (a),(b);tie(a,b)=l; \n#define DCc(a,b,c) P (a);D (b);tie(a,b)=c; \n    \n    //A dot B\n    IL D dot(P a, P b) { return a.X*b.X + a.Y*b.Y; }\n    //A cross B\n    IL D cross(P a, P b) { return a.X*b.Y - a.Y*b.X; }\n    IL D ccw(P a,P b,P c){\n        return cross(b - a, c - a);\n    }\n\n    IL int sgn(P a,P b, P c){\n        if(cross(b-a,c-a) > EPS)return 1;\n        if(cross(b-a,c-a) < -EPS)return -1;\n        if(dot(b-a,c-a) < -EPS)return 2; // b-a-c\n        if(dot(a-b,c-b) < -EPS)return -2; // a-b-c\n        return 0;\n    }\n    IL D signed_distance_P_L(P p, L l) {\n        DCl(a,b,l);\n        return ccw(a,b,p)/ abs(b - a);\n    }\n    \n    IL D distance_P_L(P p, L l) {\n        return abs(signed_distance_P_L(p,l));\n    }\n\n    IL D distance_P_LS(P p, LS ls) {\n        DCl(a,b,ls);\n        if (dot(b - a, p - a) < EPS) return abs(p - a);\n        if (dot(a - b, p - b) < EPS) return abs(p - b);\n        return abs(cross(b - a, p - a)) / abs(b - a);\n    }\n\n    \n    IL B is_L_L(L p, L q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return\n            abs(cross(a - b, c - d)) > EPS ||\n            abs(cross(a - b ,d - b)) < EPS;\n    }\n    IL B is_L_LS(L l, LS ls) {\n        DCl(a,b,l);\n        DCl(c,d,ls);\n        return ccw(a,b,c)*ccw(a,b,d)<EPS;\n    }\n    IL B is_LS_LS(LS p, LS q) {\n        DCl(a,b,p);\n        DCl(c,d,q);\n        return sgn(a,b,c)*sgn(a,b,d) <= 0\n            && sgn(c,d,a)*sgn(c,d,b) <= 0;\n    }\n\n    IL D distance_LS_LS(LS p,LS q){\n        if(is_LS_LS(p,q))return 0;\n        return min({\n                distance_P_LS(p.fi,q),\n                distance_P_LS(p.se,q),\n                distance_P_LS(q.fi,p),\n                distance_P_LS(q.se,p)    \n                    });\n    }\n\n    //caution: have to use isintersected_L_L before this function\n    IL P cross_point_L_L(L p, L q) {\n        DCl(a,b,p);\n        D d1 = signed_distance_P_L(a, q);\n        D d2 = signed_distance_P_L(b, q);\n        return (a * d2 - b * d1) / (d2 - d1);\n    }\n    \n    IL B is_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        return abs(rp - rq) - d <EPS &&\n                                 rp + rq - d > -EPS;\n    }\n    IL LS cross_C_C(C p, C q) {\n        DCc(cp,rp,p);\n        DCc(cq,rq,q);\n        D d = abs(cp - cq);\n        D rc = (d*d + rp*rp - rq*rq) / (2 * d);\n        D rs = sqrt(rp*rp - rc*rc);\n        P diff = (cq - cp) / d;\n        return {cp + P(rc, rs)*diff, cp + P(rc, -rs)*diff};\n    }\n    IL Poly convex_hull(Poly p) {\n        int n = p.size();\n        Poly res(2 * n);\n        int k = 0, t;\n        sort(ALL(p),comp);\n        REP(i,n) {\n            while (k > 1 && ccw(res[k-2],res[k-1],p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        t = k;\n        REP(j,n-1){\n            int i= n - 2 - j;\n            while (k > t && ccw(res[k - 2],res[k - 1], p[i]) < EPS)k--;\n            res[k++] = p[i];\n        }\n        res.resize(k - 1);\n        return res;\n    }\n    IL B convex_in(Poly& l,P& p) {\n        int a = 0, b = l.size(), c;\n        D A, C;\n        P g = (l[a] + l[b - 1] + l[b / 2]) / 3.0;\n        while (b - a > 1) {\n            c = (a + b) / 2;\n            A = cross(l[a] - g, p - l[a]);\n            C = cross(l[c] - g, p - l[c]);\n            if (cross(l[a] - g, l[c] - g) >= 0) {\n                if (A > -EPS&&C < -EPS)b = c;\n                else a = c;\n            }\n            else {\n                if (C < -EPS || A > -EPS)b = c;\n                else a = c;\n            }\n        }\n        return(cross(l[b%l.size()] - l[a], p - l[b%l.size()]) > -EPS);\n    }\n\n        //not necessary?\n    IL D convex_area(Poly& l) {\n        double res = 0;\n        int n = l.size();\n        FOR(i,2,n)\n            res += (abs(cross(l[i - 1] - l[0], l[i] - l[i - 1]))) / 2.0;\n        return res;\n    }\n    IL D area(Poly& l){\n        double res=0;\n        int n=l.size();\n        REP(i,n)res+=cross(l[i],l[(i+1)%n]);\n          return abs(res)/2.0;\n    }\n    inline vector<L> tangent_line(C c, P p) {\n        vector<L> res;\n        DCc(cp,r,c);\n        P v = p - cp;\n        D dist = abs(v);\n        if (dist - r > -EPS) {\n            double _cos = r / dist;\n            double _sin = sqrt(1.0 - _cos*_cos);\n            v = v * (r / dist);\n            {\n                P e = P(_cos * v.X - _sin * v.Y, _sin*v.X + _cos*v.Y);\n                res.push_back({p, cp + e});\n            }\n            if(dist-r > EPS){\n                P e = P( _cos*v.X + _sin*v.Y ,-_sin*v.X + _cos*v.Y );\n                res.push_back({p, cp + e});\n            }\n        }\n        return res;\n    }\n    IL vector<L> inner_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        D dist = abs(Mp - Mq);\n        if (dist - (Rp + Rq) > -EPS) {\n            P mid = (Mq*Rp + Mp*Rq) / (Rp + Rq);\n            res = tangent_line(p, mid);\n        }\n        return res;\n    }\n    inline vector<L> outer_common_tangent_line(C p, C q) {\n        vector<L> res;\n        DCc(Mp,Rp,p);\n        DCc(Mq,Rq,q);\n        P v = Mp - Mq;\n        D dist = abs(v);\n        if (dist - abs(Rp - Rq) >- EPS) {\n            if (abs(Rp - Rq) < EPS) {\n                P e = v*P( 0, 1 );\n                e = e / dist;\n                res.pb(L(Mp + e, Mq + e));\n                res.pb(L(Mp - e, Mq - e));\n            }\n            else {\n                P mid = Mp + (Mq - Mp) * Rp / (Rp - Rq);\n                res = tangent_line(p, mid);\n            }\n        }\n        return res;\n    }\n\n     vector<Poly> decomposition(Poly p){\n        int n = p.size();\n        vector<Poly> res;\n        while(n>=3){\n            [&](){\n                FOR(i, 0, n){\n                    P a = p[i];\n                    P b = p[(i+1)%n];\n                    P c = p[(i+2)%n];\n                    if (ccw(a,b,c)<0)continue;\n                    if([&](){\n                            FOR(j,3,n){\n                                P d=p[(i+j)%n];\n                                if(ccw(a,b,d)>-EPS&&ccw(b,c,d)>-EPS&&ccw(c,a,d)>-EPS)\n                                    return true;\n                            }\n                            return false;\n                        }()\n                        )continue;\n                    Poly nxt;\n                    REP(j,n)if((i+j)%n!=(i+1)%n)nxt.push_back(p[(i+j)%n]);\n                    swap(p,nxt);\n                    res.push_back({a,b,c});\n                    n--;\n                    return;\n                }\n            }();\n        }\n        return res;\n    }\n    int in_triangle(P p,Poly q){\n        REP(i,3)if(abs(p-q[i])<EPS)return 3;//on point\n        REP(i,3){\n            int s=sgn(q[i],q[(i+1)%3],p);\n            if(s!=1){\n                if(s==0)return 2;//on line\n                else return 0; // not in\n            }\n        }\n        return 1; // inside triangle\n    }\n    int in_C(P q,C c){\n        DCc(p,r,c);\n        if(abs(r-abs(p-q))<EPS)return 2; //on\n        return r-abs(p-q)>-EPS ? 1:0;\n    }\n    int is_triangle_C(Poly t,C c){\n        DCc(p,r,c);\n        int cnt=0;\n        REP(i,3)\n            cnt+=(in_C(t[i],c)>0);\n        if(cnt==3)return 3; // t in c\n        if(cnt==0){\n            double d=distance_P_LS(p,LS(t[2],t[0]));\n            REP(i,2)\n                d=min(d,distance_P_LS(p,LS(t[i],t[i+1])));\n            if(r-d>EPS)return 1; //intersect\n            if(in_triangle(p,t))return 2;//c in t\n            else return 0; //not intersect\n        }\n        return 1;//intersect\n    }\n}\n\n\nusing namespace geo;\n\nint main(){\n    int x,y,r;\n    while(cin>>x>>y,x!=0||y!=0){\n        Poly t={P(x,y)};\n        REP(i,2){\n            cin>>x>>y;\n            t.pb(P(x,y));\n        }\n        cin>>x>>y>>r;\n        C c(P(x,y),r);\n        int res=is_triangle_C(t,c);\n        if(res==2)cout<<\"a\"<<endl;\n        if(res==3)cout<<\"b\"<<endl;\n        if(res==1)cout<<\"c\"<<endl;\n        if(res==0)cout<<\"d\"<<endl;\n\n    }\n   \n    \n    return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double eps = 1e-10;\n\nbool equals(double a, double b) { return fabs(a-b) < eps; }\ndouble dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\ndouble norm(P a) { return dot(a,a); }\ndouble abs(P a) { return sqrt(norm(a)); }\ndouble cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\n\ndouble getDistanceLP(P s1, P s2, P p) {\n  return fabs(cross(s2 - s1, p - s1)/abs(s2 - s1));\n}\n\ndouble getDistanceSP(P s1, P s2, P p) {\n  if(dot(s2 - s1, p - s1) < 0.0) return abs(p - s1);\n  if(dot(s1 - s2, p - s2) < 0.0) return abs(p - s2);\n  return getDistanceLP(s1, s2, p);\n}\n\n\nint ccw(P p0, P a, P b) {\n  a -= p0;\n  b -= p0;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\nG tri;\nP co;\ndouble R;\n\n\nbool isInC(P t, P p, double r) {\n  double d = norm(t - p);\n  return equals(d, r*r) || d < r*r;\n}\n\nbool isInC(G g, P p, double r) {\n  for(int i = 0; i < g.size(); ++i) {\n    if(!isInC(g[i],p,r)) return false;\n  }\n  return true;\n}\n\nbool isInG(P t, G g) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    if(ccw(g[i], g[(i+1)%n], t) == -1) return false;\n  }\n  return true;\n}\n\nbool isInG(P t, double r, G g) {\n  if(!isInG(t, g)) return false;\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    double d = getDistanceLP(g[i], g[(i+1)%n], t);\n    if(equals(d, r)) continue;\n    if(d < r) return false;\n  }\n  return true;\n}\n\nbool isIntersect(P t, double r, G g) {\n  int n = g.size();\n  for(int i = 0; i < n; ++i) {\n    double d = getDistanceSP(g[i], g[(i+1)%n], t);\n    if(equals(d, r) || d < r) return true;\n  }\n  return false;\n}\n\nchar solve() {\n  if(isInC(tri, co, R)) return 'b';\n  if(isInG(co, R, tri)) return 'a';\n  if(isIntersect(co, R, tri)) return 'c';\n  return 'd';\n}\n\nint main() {\n  P p;\n  while(cin >> p.real() >> p.imag()\n\t&& (p.real() || p.imag())) {\n    tri.clear();\n    tri.push_back(p);\n    for(int i = 1; i < 3; ++i) {\n      cin >> p.real() >> p.imag();\n      tri.push_back(p);\n    }\n    if(ccw(tri[0], tri[1], tri[2]) == -1) {\n      swap(tri[0], tri[1]);\n    }\n    cin >> co.real() >> co.imag();\n    cin >> R;\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n#include <assert.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\nnamespace std {\n  bool operator < (const Point& a, const Point& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const Point& a, const Point& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const Point& a, const Point& b) {\n  return real(conj(a)*b);\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nbool is_equal(const Point &l,const Point &m){\n  return ((abs(real(l) - real(m)) < EPS) && (abs(imag(l) - imag(m) < EPS)));\n}\n\nbool cmp_x(const Point& p, const Point& q){\n  if(p.real() != q.real()) return p.real() < q.real();\n  return p.imag() < q.imag();\n}\n\nvector<Point> compute_convex_hull(vector<Point>& ps){\n  sort(ps.begin(), ps.end(), cmp_x);\n  int k = 0;\n  vector<Point> qs(ps.size() * 2);\n  for(int i=0; i < ps.size(); i++){\n    while(k > 1 && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  for(int i = ps.size() - 2,t = k; i >= 0; i--){\n    while(k > t && cross(qs[k - 1] - qs[k - 2],ps[i] - qs[k - 1]) <= 0) k--;\n    qs[k++] = ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nint main(){\n  double x[4];\n  double y[4];\n  while(~scanf(\"%lf %lf\",&x[0],&y[0])){\n    if(is_equal(Point(x[0],y[0]),Point(0.0,0.0))) break;\n\n    for(int i=1;i<4;i++){\n      scanf(\"%lf %lf\",&x[i],&y[i]);\n    }\n    double r;\n    scanf(\"%lf\",&r);\n\n    vector<Line> lines;\n    vector<Point> points;\n\n    for(int i=0;i<4;i++){\n      points.push_back(Point(x[i],y[i]));\n    }\n\n    for(int i=0;i<3;i++){\n      for(int j=i+1;j<3;j++){\n        lines.push_back(Line(Point(x[i],y[i]),Point(x[j],y[j])));\n      }\n    }\n\n    vector<Point> convex_hull = compute_convex_hull(points);\n\n    if(convex_hull.size() == 3){\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n      }\n\n      if(r <= dist + EPS){\n        //a\n        printf(\"a\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n        }\n        if(r >= dist - EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n\n      }\n    }\n\n    else if(convex_hull.size() == 4){\n      double dist = numeric_limits<double>::max();\n      for(int i=0;i<3;i++){\n        dist = min(distanceLP(lines[i],Point(x[3],y[3])),dist);\n      }\n\n      if(dist > r){\n        //d\n        printf(\"d\\n\");\n      }\n      else{\n        dist = numeric_limits<double>::min();\n        for(int i=0;i<3;i++){\n          dist = max(sqrt(dot(points[i]-points[3],points[i]-points[3])),dist);\n        }\n        \n        if(r <= dist + EPS){\n          //b\n          printf(\"b\\n\");\n        }\n        else{\n          //c\n          printf(\"c\\n\");\n        }\n      }\n    }\n\n    else{\n      assert(0);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Point{ int x,y; };\nstruct Triangle{ Point a,b,c; };\nstruct Circle{ Point c; int r; };\n\ninline double dist(const Point &p1, const Point &p2){\n\treturn sqrt( pow(p2.x-p1.x,2.0)+pow(p2.y-p1.y,2.0) );\n}\ninline double dist(const Point &p1, const Point &p2, const Point &p)\n{\n\tif( p1.x == p2.x ){\n\t\treturn abs( p1.x - p.x );\n\t}else{\n\t\tdouble a = -(p2.y-p1.y)/double(p2.x-p1.x);\n\t\tdouble b = 1;\n\t\tdouble c = -a * p1.x - p1.y;\n\n\t\treturn fabs( a * p.x + b * p.y + c ) / sqrt( pow(a,2.0)+pow(b,2.0) );\n\t}\n}\ninline bool isLeft(const Point &a, const Point &b, const Point &p){\n\tdouble vx = b.x - a.x, vy = b.y - a.y;\n\tdouble px = p.x - a.x, py = p.y - a.y;\n\treturn (vx * py - px * vy) > 0;\n}\n\ninline bool isInside(const Point &p, const Triangle &t )\n{\n\tif( isLeft( t.a, t.b, p ) && isLeft( t.b, t.c, p ) && isLeft( t.c, t.a, p ) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool Contains(const Triangle &t, const Circle &c)\n{\n\tif( isInside( c.c, t ) ){\n\t\tif( c.r <= dist( t.a, t.b, c.c ) &&\n\t\t\tc.r <= dist( t.b, t.c, c.c ) &&\n\t\t\tc.r <= dist( t.c, t.a, c.c ) )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool IsContained(const Triangle &t, const Circle &c)\n{\n  if( dist( t.a, c.c ) <= c.r &&\n\t  dist( t.b, c.c ) <= c.r &&\n\t  dist( t.c, c.c ) <= c.r )\n\t  return true;\n  else\n\t  return false;\n}\nbool isCross(const Point &tp1, const Point &tp2, const Circle &c)\n{\n\tPoint p1 = tp1;\n\tPoint p2 = tp2;\n\tif( p2.x < p1.x )\n\t\tswap( p1, p2 );\n\n\tif( dist( p1, p2, c.c ) > c.r )\n\t\treturn false;\n\telse{\n\t\tif( p1.x != p2.x ){\n\t\t\tdouble x1, x2;\n\t\t\tdouble a = (p2.y - p1.y) / (p2.x - p1.x);\n\t\t\tdouble b = -a * p1.x + p1.y;\n\t\t\tdouble A = 1 + pow(a,2.0);\n\t\t\tdouble B = -( c.c.x - a * b + a * c.c.y );\n\t\t\tdouble C = pow( c.c.x, 2.0 ) + pow( b, 2.0 ) - 2*b*c.c.y + pow( c.c.y, 2.0 ) - pow( c.r, 2.0 );\n\n\t\t\tx1 = ( -B + sqrt( pow(B,2.0) - A * C ) ) / A;\n\t\t\tx2 = ( -B - sqrt( pow(B,2.0) - A * C ) ) / A;\n\n\t\t\tif( p1.x <= x1 && x1 <= p2.x || p1.x <= x2 && x2 <= p2.x )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}else{\n\t\t\tif( p2.y < p1.y )\n\t\t\t\tswap( p1, p2 );\n\n\t\t\tdouble d = dist( p1, p2, c.c );\n\t\t\tdouble l = sqrt( pow(c.r,2.0) - pow(d,2.0) );\n\n\t\t\tdouble y1 = c.c.y - l;\n\t\t\tdouble y2 = c.c.y + l;\n\n\t\t\tif( p1.y <= y1 && y1 <= p2.y || p1.y <= y2 && y2 <= p2.y )\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\nbool isCross(const Triangle &t, const Circle &c ){\n\n\tif( isCross(t.a,t.b,c) || isCross(t.b,t.c,c) || isCross(t.c,t.a,c) )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nchar judgeRel(const Triangle &t, const Circle &c){\n\tif( Contains( t,c ) )\n\t\treturn 'a';\n\tif( IsContained( t,c ) )\n\t\treturn 'b';\n\tif( isCross( t,c ) )\n\t\treturn 'c';\n\telse\n\t\treturn 'd';\n}\n\nint main()\n{\n\twhile(true){\n\t\tTriangle t;\n\t\tCircle c;\n\t\tcin >> t.a.x >> t.a.y;\n\t\tif( cin.eof() )\n\t\t\tbreak;\n\t\tif( t.a.x == 0 && t.a.y == 0 )\n\t\t\tbreak;\n\t\tcin >> t.b.x >> t.b.y >> t.c.x >> t.c.y >> c.c.x >> c.c.y >> c.r;\n\t\tcout << judgeRel( t, c ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\n#include <complex>\nusing namespace std;\n \n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\n// geometry library\n\nconst double EPS = 1.0e-8;\nconst double INF = 1.0e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator<(const P& p, const P& q) {\n\t\treturn p.real() != q.real() ? p.real() < q.real() : p.imag() < q.imag(); \n\t}\n}\n\ndouble cross(const P& p, const P& q) {\n\treturn imag(conj(p) * q); \n}\n\ndouble dot(const P& p, const P& q) {\n\treturn real(conj(p) * q);\n}\n\nclass L : public vector<P> {\npublic:\n\tL(const P& p, const P& q) {\n\t\tthis->push_back(p);\n\t\tthis->push_back(q);\n\t}\n};\n\nclass C {\npublic:\n\tP p;\n\tdouble r;\n\tC() : p(0.0, 0.0), r(0.0) {}\n\tC(const P& _p, double _r) : p(_p), r(_r) {} \n};\n\n// compute distance between 2 points\ndouble distP2P(const P& p, const P& q) {\n\tP d = p - q;\n\treturn sqrt(norm(d));\n}\n\n// compute shortest distance to line\ndouble distP2L(const P& p, const L& l) {\n\tdouble a = l[1].real() - l[0].real();\n\tdouble b = l[0].imag() - l[1].imag();\n\tdouble c = - a * l[0].real() - b * l[0].imag();\n\tdouble de = abs(a * p.real() + b * p.imag() + c);\n\tdouble nm = sqrt(a * a + b * b);\n\treturn de / nm;\n}\n\n// compute shortest distance to line segment\ndouble distP2LS(const P& p, const L& l) {\n\tdouble d1 = dot(p - l[0], l[1] - l[0]);\n\tdouble d2 = dot(p - l[1], l[0] - l[1]);\n\tif(d1 < 0 || d2 < 0) {\n\t\treturn min(distP2P(p, l[0]), distP2P(p, l[1]));\n\t}\n\treturn distP2L(p, l);\n}\n\n// code for problem\nint x, y, r;\nP tr[3];\nC cc;\n\nbool isPinT(const P& p, P t[3]) {\n\tP e0 = t[0] - p;\n\tP e1 = t[1] - p;\n\tP e2 = t[2] - p;\n\tdouble d0 = cross(e0, e1);\n\tdouble d1 = cross(e1, e2);\n\tdouble d2 = cross(e2, e0);\n\tif(d0 * d1 > -EPS && d1 * d2 > -EPS && d2 * d0 > -EPS) return true;\n\treturn false;\n}\n\nvoid solve() {\n\t// triangle is in circle ?\n\tvector<double> d(6);\n\td[0] = distP2P(tr[0], cc.p);\n\td[1] = distP2P(tr[1], cc.p);\n\td[2] = distP2P(tr[2], cc.p);\n\tif(d[0] <= cc.r && d[1] <= cc.r && d[2] <= cc.r) {\n\t\tprintf(\"b\\n\");\n\t\treturn;\n\t}\n\n\t// circle is in triangle ?\n\tbool in = isPinT(cc.p, tr);\n\tL l0(tr[0], tr[1]);\n\tL l1(tr[1], tr[2]);\n\tL l2(tr[2], tr[0]);\n\td[3] = distP2LS(cc.p, l0);\n\td[4] = distP2LS(cc.p, l1);\n\td[5] = distP2LS(cc.p, l2);\n\tif(in && d[3] >= cc.r && d[4] >= cc.r && d[5] >= cc.r) {\n\t\tprintf(\"a\\n\");\n\t\treturn;\n\t}\n\n\t// intersects each other ?\n\tsort(d.begin(), d.end());\n\tif(d[0] <= cc.r) {\n\t\tprintf(\"c\\n\");\n\t\treturn;\n\t}\n\n\t// not intersect\n\tprintf(\"d\\n\");\n}\n\nint main() {\n\twhile( 1 ) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif(x == 0 && y == 0) break;\n\t\ttr[0] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[1] = P(x, y);\n\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ttr[2] = P(x, y);\n\n\t\tscanf(\"%d%d%d\", &x, &y, &r);\n\t\tcc = C(P(x, y), r);\n\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\n\nmain :: IO ()\nmain = do\n  [x1, y1] <- f\n  unless (x1 == 0 && y1 == 0) $ do\n    [x2, y2] <- f\n    [x3, y3] <- f\n    [xc, yc] <- f\n    r <- readLn\n    let v1 = Vect (fromIntegral x1) (fromIntegral y1)\n    let v2 = Vect (fromIntegral x2) (fromIntegral y2)\n    let v3 = Vect (fromIntegral x3) (fromIntegral y3)\n    let vc = Vect (fromIntegral xc) (fromIntegral yc)\n    putStrLn $ solve (Triangle v1 v2 v3) (Circle vc (fromIntegral r))\n    main\n  where\n    f = map read <$> words <$> getLine\n\nsolve :: Triangle Double -> Circle Double -> String\nsolve tri cir\n  | triInCir tri cir = \"b\"\n  | cirInTri tri cir = \"a\"\n  | not (ccInTri tri cir) && cirOutTri tri cir = \"d\"\n  | otherwise = \"c\"\n\neps :: Floating a => a\neps = 1e-9\n\ndata Vect a = Vect {vecX :: a, vecY :: a} deriving Show\ndata Segment a = Segment {segB :: Vect a, segE :: Vect a} deriving Show\ndata Circle a = Circle {cirC :: Vect a, cirR :: a} deriving Show\ndata Triangle a = Triangle {triA :: Vect a, triB :: Vect a, triC :: Vect a} deriving Show\n\nnorm :: Num a => Vect a -> a\nnorm (Vect x y) = x ^ 2 + y ^ 2\n\n(.-.) :: Num a => Vect a -> Vect a -> Vect a\n(Vect x1 y1) .-. (Vect x2 y2) = Vect (x1 - x2) (y1 - y2)\n\ncross :: Num a => Vect a -> Vect a -> a\ncross (Vect x1 y1) (Vect x2 y2) = x1 * y2 - y1 * x2\n\ndot :: Num a => Vect a -> Vect a -> a\ndot (Vect x1 y1) (Vect x2 y2) = x1 * x2 + y1 * y2\n\nabsV :: Floating a => Vect a -> a\nabsV = sqrt . norm\n\ndistanceLP :: (Floating a) => Segment a -> Vect a -> a\ndistanceLP (Segment v1 v2) v = abs (cross base (v .-. v1) / absV base)\n  where\n    base = v2 .-. v1\n\ndistanceSP :: (Ord a, Floating a) => Segment a -> Vect a -> a\ndistanceSP (Segment v1 v2) v\n  | dot (v2 .-. v1) (v .-. v1) < 0 = absV (v .-. v1)\n  | dot (v1 .-. v2) (v .-. v2) < 0 = absV (v .-. v2)\n  | otherwise = distanceLP (Segment v1 v2) v\n\ntriInCir :: Triangle Double -> Circle Double -> Bool\ntriInCir tri cir = (abs (r2 - nca) < eps || r2 > nca) &&\n                   (abs (r2 - ncb) < eps || r2 > ncb) &&\n                   (abs (r2 - ncc) < eps || r2 > ncc)\n  where\n    nca = norm ((triA tri) .-. (cirC cir))\n    ncb = norm ((triB tri) .-. (cirC cir))\n    ncc = norm ((triC tri) .-. (cirC cir))\n    r2  = (cirR cir) ^ 2\n\nccInTri :: Triangle Double -> Circle Double -> Bool\nccInTri tri cir = ((abs ca < eps || ca > 0) &&\n                   (abs cb < eps || cb > 0) &&\n                   (abs cc < eps || cc > 0)) ||\n                  ((abs ca < eps || ca < 0) &&\n                   (abs cb < eps || cb < 0) &&\n                   (abs cc < eps || cc < 0))\n  where\n    ca = cross ((triB tri) .-. (triA tri)) ((cirC cir) .-. (triA tri))\n    cb = cross ((triC tri) .-. (triB tri)) ((cirC cir) .-. (triB tri))\n    cc = cross ((triA tri) .-. (triC tri)) ((cirC cir) .-. (triC tri))\n\ncirInTri :: Triangle Double -> Circle Double -> Bool\ncirInTri tri cir = ccInTri tri cir &&\n                   (abs (la - (cirR cir)) < eps || la > (cirR cir)) && \n                   (abs (lb - (cirR cir)) < eps || lb > (cirR cir)) && \n                   (abs (lc - (cirR cir)) < eps || lc > (cirR cir))\n  where\n    la = distanceLP (Segment (triB tri) (triC tri)) (cirC cir)\n    lb = distanceLP (Segment (triC tri) (triA tri)) (cirC cir)\n    lc = distanceLP (Segment (triA tri) (triB tri)) (cirC cir)\n    \ncirOutTri :: Triangle Double -> Circle Double -> Bool\ncirOutTri tri cir = la > (cirR cir) &&\n                    lb > (cirR cir) &&\n                    lc > (cirR cir)\n  where\n    la = distanceSP (Segment (triB tri) (triC tri)) (cirC cir)\n    lb = distanceSP (Segment (triC tri) (triA tri)) (cirC cir)\n    lc = distanceSP (Segment (triA tri) (triB tri)) (cirC cir)\n\n"
  },
  {
    "language": "C",
    "code": "#include<math.h>\nint count_common_circle_segment(int x1,int y1,int x2,int y2,int r){\n\tint x12=x2-x1;\n\tint y12=y2-y1;\n\tfloat d=fabs(-y12*x1+x12*y1)/hypot(x12,y12);\n\tint ip1=-x1*x12-y1*y12;\n\tint ip2=x2*x12+y2*y12;\n\tif(ip1>0&&ip2>0&&d<=r)\n\t\tif(d<r)\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\treturn 0;\n}\nint is_origin_inner_triangle(int x1,int y1,int x2,int y2,int x3,int y3){\n\tfloat o1,o2,o3;\n\to1=(float)x2*y3-(float)y2*x3;\n\to2=(float)x3*y1-(float)y3*x1;\n\to3=(float)x1*y2-(float)y1*x2;\n\treturn o1*o2>0&&o2*o3>0;\n}\nint main(){\n\tint x1,y1,x2,y2,x3,y3,x4,y4,r;\n\tint inner1,inner2,inner3;\n\tint common1,common2,common3;\n\tfor(;scanf(\"%d%d%d%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4,&r),x1|y1;){\n\t\tx1-=x4,y1-=y4;\n\t\tx2-=x4,y2-=y4;\n\t\tx3-=x4,y3-=y4;\n\t\tinner1=x1*x1+y1*y1<=r*r;\n\t\tinner2=x2*x2+y2*y2<=r*r;\n\t\tinner3=x3*x3+y3*y3<=r*r;\n\t\tif(inner1&&inner2&&inner3){\n\t\t\tputs(\"b\");\n\t\t}else if(!inner1&&!inner2&&!inner3){\n\t\t\tcommon1=count_common_circle_segment(x2,y2,x3,y3,r);\n\t\t\tcommon2=count_common_circle_segment(x3,y3,x1,y1,r);\n\t\t\tcommon3=count_common_circle_segment(x1,y1,x2,y2,r);\n\t\t\tif(common1==2||common2==2||common3==2){\n\t\t\t\tputs(\"c\");\n\t\t\t}else if(common1==1||common2==1||common3==1){\n\t\t\t\tif(is_origin_inner_triangle(x1,y1,x2,y2,x3,y3))\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"c\");\n\t\t\t}else{\n\t\t\t\tif(is_origin_inner_triangle(x1,y1,x2,y2,x3,y3))\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"d\");\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"c\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "float q;\nA,B,C,D,E,F,R;\nM(a,b,c,d,e,f){\n\te=c-a;\n\tf=d-b;\n\tq=fabs(-f*a+e*b)/hypot(e,f);\n\treturn a*e+b*f<0&c*e+d*f>0&q<=R?q<R?2:1:0;\n}\nI(){\n\tq=E*B-F*A;\n\treturn(C*F-D*E)*q>0&q*(A*D-B*C)>0;\n}\nmain(v,w,o,c){\n\tfor(;scanf(\"%d%d%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&v,&w,&R),A;){\n\t\tA-=v,B-=w;\n\t\tC-=v,D-=w;\n\t\tE-=v,F-=w;\n\t\to=(A*A+B*B>R*R)+(C*C+D*D>R*R)+(E*E+F*F>R*R);\n\t\tc=M(C,D,E,F)|M(E,F,A,B)|M(A,B,C,D);\n\t\tif(o){\n\t\t\tif(o-3|c&2){\n\t\t\t\tputs(\"c\");\n\t\t\t}else{\n\t\t\t\tif(I())\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse{\n\t\t\t\t\tif(c&1){\n\t\t\t\t\t\tputs(\"c\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tputs(\"d\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"b\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint xa,ya,xb,yb,xc,yc,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 >= (double)rr2)return 0;\n\tif(abw<0)return 0;\n\tif(abw>ab2)return 0;\n\treturn 1;\n}\n\ndouble dist2(int px,int py,int qx,int qy,int ax,int ay){\n\tint vx=qx-px,vy=qy-py,wx=ax-px,wy=ay-py;\n\tint tim=vx*wy-wx*vy;\n\treturn (double)tim*tim/(vx*vx+vy*vy);\n}\n\nint main(){\n\tif(crosscheck(10,3,10,9,10,10,1))printf(\"OK\\n\");\n\n\twhile(scanf(\"%d %d\",&xa,&ya)*xa){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&xb,&yb,&xc,&yc,&wx,&wy,&r);\n\n\t\tint ccc=0,ttt=0,ddd;\n\n\t\tint d1=(xa-wx)*(xa-wx)+(ya-wy)*(ya-wy)-r*r;\n\t\tint d2=(xb-wx)*(xb-wx)+(yb-wy)*(yb-wy)-r*r;\n\t\tint d3=(xc-wx)*(xc-wx)+(yc-wy)*(yc-wy)-r*r;\n\t\tdouble dis1=dist2(xa,ya,xb,yb,wx,wy)-r*r;\n\t\tdouble dis2=dist2(xb,yb,xc,yc,wx,wy)-r*r;\n\t\tdouble dis3=dist2(xc,yc,xa,ya,wx,wy)-r*r;\n\t\tint tim1=(wx-xa)*(yb-ya)-(wy-ya)*(xb-xa);\n\t\tint tim2=(wx-xb)*(yc-yb)-(wy-yb)*(xc-xb);\n\t\tint tim3=(wx-xc)*(ya-yc)-(wy-yc)*(xa-xc);\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c\\n\");continue;}\n\n\t\tif (tim1*tim2>0 && tim2*tim3>0) ttt=1;\n\n\t\tif(dis1==0 && dis2==0 && dis3==0){printf(\"a\\n\");continue;}\n\t\tif(dis1==0 || dis2==0 || dis3==0){printf(\"c\\n\");continue;}\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"c\\n\");continue;}\n\t\tif(ttt==1){printf(\"a\\n\");continue;}\n\t\tprintf(\"d\\n\");\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <math.h>           // fabs(), sqrt(), atan2()\n#include <stdbool.h>\n\nint tx1, ty1, tx2, ty2, tx3, ty3;\nint cx, cy, cr;\n\ndouble\ndot(int ax, int ay, int bx, int by)\n{\n\treturn ax * bx + ay * by;\n}\n\ndouble\ncross(int ax, int ay, int bx, int by)\n{\n\treturn ax * by - ay * bx;\n}\n\ndouble\nvabs(int x, int y)\n{\n\treturn sqrt(x * x + y * y);\n}\n\ndouble\ngetDistanceLP(int lx1, int ly1, int lx2, int ly2, int px, int py)\n{\n\treturn fabs(cross(lx2 - lx1, ly2 - ly1, px - lx1, py - ly1) / vabs(lx2 - lx1, ly2 - ly1));\n}\n\ndouble\ngetDistanceSP(int lx1, int ly1, int lx2, int ly2, int px, int py)\n{\n\tif (dot(lx2 - lx1, ly2 - ly1, px - lx1, py - ly1) < 0.0)\n\t\treturn vabs(px - lx1, py - ly1);\n\n\tif (dot(lx1 - lx2, ly1 - ly2, px - lx2, py - ly2) < 0.0)\n\t\treturn vabs(px - lx2, py - ly2);\n\n\treturn getDistanceLP(lx1, ly1, lx2, ly2, px, py);\n}\n\nchar\nsolve()\n{\n\tdouble r1 = vabs(tx1 - cx, ty1 - cy);\n\tdouble r2 = vabs(tx2 - cx, ty2 - cy);\n\tdouble r3 = vabs(tx3 - cx, ty3 - cy);\n\tif (r1 <= cr && r2 <= cr && r3 <= cr)\n\t\treturn 'b';\n\n\tdouble th21 = atan2(tx2 - tx1, ty2 - ty1);\n\tdouble th31 = atan2(tx3 - tx1, ty3 - ty1);\n\tdouble th12 = atan2(tx1 - tx2, ty1 - ty2);\n\tdouble th32 = atan2(tx3 - tx2, ty3 - ty2);\n\tdouble thc1 = atan2(cx - tx1, cy - ty1);\n\tdouble thc2 = atan2(cx - tx2, cy - ty2);\n\n\tif (((th21 <= thc1 && thc1 <= th31) || (th31 <= thc1 && thc1 <= th21)) &&\n\t    ((th12 <= thc2 && thc2 <= th32) || (th32 <= thc2 && thc2 <= th12)))\n\t{\n\t\tr1 = getDistanceLP(tx1, ty1, tx2, ty2, cx, cy);\n\t\tr2 = getDistanceLP(tx3, ty3, tx2, ty2, cx, cy);\n\t\tr3 = getDistanceLP(tx3, ty3, tx1, ty1, cx, cy);\n\t\tif (r1 >= cr && r2 >= cr && r3 >= cr)\n\t\t\treturn 'a';\n\t\telse\n\t\t\treturn 'c';\n\t}\n\telse\n\t{\n\t\tr1 = getDistanceSP(tx1, ty1, tx2, ty2, cx, cy);\n\t\tr2 = getDistanceSP(tx3, ty3, tx2, ty2, cx, cy);\n\t\tr3 = getDistanceSP(tx3, ty3, tx1, ty1, cx, cy);\n\t\tif (r1 > cr && r2 > cr && r3 > cr)\n\t\t\treturn 'd';\n\t\telse\n\t\t\treturn 'c';\n\t}\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &tx1, &ty1);\n\t\tif (tx1 == 0 && ty1 == 0)\n\t\t\tbreak;\n\n\t\tscanf(\"%d%d\", &tx2, &ty2);\n\t\tscanf(\"%d%d\", &tx3, &ty3);\n\t\tscanf(\"%d%d\", &cx, &cy);\n\t\tscanf(\"%d\", &cr);\n\t\tprintf(\"%c\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "float q;\nA,B,C,D,E,F,R;\nM(a,b,c,d,e,f){\n\te=c-a;\n\tf=d-b;\n\tq=fabs(-f*a+e*b)/hypot(e,f);\n\treturn a*e+b*f<0&c*e+d*f>0&q<=R?q<R?2:1:0;\n}\nI(){\n\tq=E*B-F*A;\n\treturn(C*F-D*E)*q>0&q*(A*D-B*C)>0;\n}\nmain(v,w,o,c){\n\tfor(;scanf(\"%d%d%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&v,&w,&R),A;){\n\t\tA-=v,B-=w;\n\t\tC-=v,D-=w;\n\t\tE-=v,F-=w;\n\t\to=(A*A+B*B>R*R)+(C*C+D*D>R*R)+(E*E+F*F>R*R);\n\t\tc=M(C,D,E,F)|M(E,F,A,B)|M(A,B,C,D);\n\t\tif(o){\n\t\t\tif(o-3){\n\t\t\t\tputs(\"c\");\n\t\t\t}else{\n\t\t\t\tif(c&2)\n\t\t\t\t\tputs(\"c\");\n\t\t\t\telse{\n\t\t\t\t\tif(I())\n\t\t\t\t\t\tputs(\"a\");\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(c&1){\n\t\t\t\t\t\t\tputs(\"c\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tputs(\"d\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"b\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint sig(double r) { return r < -EPS ? -1 : r > EPS ? 1 : 0; }\n\nstruct P {\n\tdouble x, y;\n\tP() {}\n\tP(double x, double y) : x(x), y(y) {}\n\tP operator+(const P &a) const { return P(x + a.x, y + a.y); }\n\tP operator-(const P &a) const { return P(x - a.x, y - a.y); }\n\tP operator*(const P &a) const { return P(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tP operator-() const { return P(-x, -y); }\n\tP operator*(const double &k) const { return P(x * k, y * k); }\n\tP operator/(const double &k) const { return P(x / k, y / k); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble abs() const { return sqrt(abs2()); }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const P &a) const { return x * a.x + y * a.y; }\n\tdouble det(const P &a) const { return x * a.y - y * a.x; }\n\tP proj(const P &a) const { double k = dot(a) / abs2(); return P(x * k, y * k); }\n\tbool operator<(const P &a) const { return x != a.x ? x < a.x : y < a.y; }\n\tbool operator==(const P &a) const { return sig(x - a.x) == 0 && sig(y - a.y) == 0; }\n};\n\nostream &operator<<(ostream&os, const P&a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\ndouble tri(P a, P b, P c) { return (b - a).det(c - a); }\n\nstruct L {\n\tP a, b;\n\tL() {}\n\tL(P a, P b) : a(a), b(b) {}\n\tP vec() const { return b - a; }\n\tP proj(const P &p) const { return a + vec().proj(p - a); }\n\tP refl(const P &p) const { return proj(p) * 2 - p; }\n\tint iSP(const P &p) const {\n\t\tint s = sig(vec().det(p - a));\n\t\tif (s != 0) return s;\n\t\tif (sig(vec().dot(p - a)) < 0) return -2;\n\t\tif (sig(vec().dot(p - b)) < 0) return 2;\n\t\treturn 0;\n\t}\n\tint iLL(const L &l) const {\n\t\tif (sig(vec().det(l.vec()))) return 1;\n\t\tif (sig(vec().det(l.a - a))) return 0;\n\t\treturn -1;\n\t}\n\tbool iLS(const L &l) const { return sig(tri(a, b, l.a)) * sig(tri(a, b, l.b)) <= 0; }\n\tbool iSS(const L &l) const { return iLS(l) && l.iLS(*this); }\n\tP pLL(const L &l) const { return a + vec() * (l.a - a).det(l.vec()) / b.det(l.vec()); }\n\tdouble dLP(const P &p) const { return abs(tri(a, b, p)) / vec().abs(); }\n\tdouble dSP(const P &p) const {\n\t\tif (sig(vec().dot(p - a)) <= 0) return (p - a).abs();\n\t\tif (sig(vec().dot(p - b)) >= 0) return (p - b).abs();\n\t\treturn dLP(p);\n\t}\n\tdouble dLL(const L &l) const { return iLL(l) ? 0 : dLP(l.a); }\n\tdouble dLS(const L &l) const { return iLS(l) ? 0 : min(dLP(l.a), dLP(l.b)); }\n\tdouble dSS(const L &l) const { return iSS(l) ? 0 : min(min(dSP(l.a), dSP(l.b)), min(l.dSP(a), l.dSP(b))); }\n};\n\nstruct C {\n\tP p;\n\tdouble r;\n\tC() {}\n\tC(P p, double r) : p(p), r(r) {}\n\tint iCC(C c) {\n\t\tdouble d = (c.p - p).abs();\n\t\tif (sig(d) == 0 && sig(r - c.r) == 0) return -1;\n\t\tif (sig(r - c.r - d) > 0) return 2;\n\t\tif (sig(c.r - r - d) > 0) return -2;\n\t\treturn (sig(r + c.r - d) >= 0) ? 1 : 0;\n\t}\n\tbool iCS(L l) {\n\t\treturn (sig(r - l.dSP(p)) >= 0&& sig(r - max((l.a - p).abs(), (l.b - p).abs())) <= 0);\n\t}\n\tpair<P,P> pCC(C c) {\n\t\tdouble d = (c.p - p).abs();\n\t\tdouble x = (d * d + r * r - c.r * c.r) / (d * 2);\n\t\tP e = (c.p - p) / d, w = e * P(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\t\treturn make_pair(p + e * x - w, p + e * x + w);\n\t}\n\tpair<P,P> pCL(L l) {\n\t\tP h = l.proj(p);\n\t\tdouble d = (h - p).abs();\n\t\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\t\tP e = (l.b - l.a) / (l.b - l.a).abs();\n\t\treturn make_pair(h - e * y, h + e * y);\n\t}\n\tpair<P,P> tCP(P p) {\n\t\tdouble d2 = (p - this->p).abs2();\n\t\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\t\tP h = this->p + (p - this->p) * (r * r / d2);\n\t\tP w = (p - this->p) * P(0, 1) * (x * r / d2);\n\t\treturn make_pair(h - w, h + w);\n\t}\n\tdouble aCC(C c) {\n\t\tdouble d = (p - c.p).abs();\n\t\tif (sig(r - c.r - d) >= 0) return c.r * c.r * PI;\n\t\tif (sig(c.r - r - d) >= 0) return r * r * PI;\n\t\tif (sig(r + c.r - d) <= 0) return 0;\n\t\tdouble x = (d * d + r * r - c.r * c.r) / (d * 2);\n\t\tdouble h = sqrt(r * r - x * x);\n\t\treturn r * r * atan2(h, x) + c.r * c.r * atan2(h, d - x) - d * h; \n\t}\n};\n\n\nint main() {\n\tint x[3], y[3];\n\tint xx, yy, r;\n\tP p[3],g;\n\tL s[3];\n\tC c;\n\tIL {\n\t\tcin >> x[0] >> y[0];\n\t\tif (x[0] == 0 && y[0] == 0) break;\n\t\tcin >> x[1] >> y[1];\n\t\tcin >> x[2] >> y[2];\n\t\tcin >> xx >> yy;\n\t\tcin >> r;\n\t\trep(i, 3) p[i] = P(x[i], y[i]);\n\t\tg = (p[0] + p[1] + p[2]) / 3;\n\t\trep(i, 3) s[i] = L(p[i], p[(i+1)%3]);\n\t\tc = C(P(xx, yy), r);\n\t\tif (!(L(g, c.p)).iSS(s[0]) && !(L(g, c.p)).iSS(s[1]) && !(L(g, c.p)).iSS(s[2]) && sig(s[0].dSP(c.p) - c.r) > 0 && sig(s[1].dSP(c.p) - c.r) > 0 && sig(s[2].dSP(c.p) - c.r) > 0) {\n\t\t\tcout << \"a\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sig((c.p - p[0]).abs() - r) < 0 && sig((c.p - p[1]).abs() - r) < 0 && sig((c.p - p[2]).abs() - r) < 0) {\n\t\t\tcout << \"b\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (sig(s[0].dSP(c.p) - c.r) <= 0 || sig(s[1].dSP(c.p) - c.r) <= 0 || sig(s[2].dSP(c.p) - c.r) <= 0) {\n\t\t\tcout << \"c\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"d\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <math.h>           // fabs(), sqrt(), atan2()\n#include <stdbool.h>\n\nconst double EPS = 1e-3;\n\nint tx1, ty1, tx2, ty2, tx3, ty3;\nint cx, cy, cr;\n\ndouble\ndot(int ax, int ay, int bx, int by)\n{\n\treturn ax * bx + ay * by;\n}\n\ndouble\ncross(int ax, int ay, int bx, int by)\n{\n\treturn ax * by - ay * bx;\n}\n\ndouble\nvabs(int x, int y)\n{\n\treturn sqrt(x * x + y * y);\n}\n\ndouble\ngetDistanceLP(int lx1, int ly1, int lx2, int ly2, int px, int py)\n{\n\treturn fabs(cross(lx2 - lx1, ly2 - ly1, px - lx1, py - ly1) / vabs(lx2 - lx1, ly2 - ly1));\n}\n\ndouble\ngetDistanceSP(int lx1, int ly1, int lx2, int ly2, int px, int py)\n{\n\tif (dot(lx2 - lx1, ly2 - ly1, px - lx1, py - ly1) < 0.0)\n\t\treturn vabs(px - lx1, py - ly1);\n\n\tif (dot(lx1 - lx2, ly1 - ly2, px - lx2, py - ly2) < 0.0)\n\t\treturn vabs(px - lx2, py - ly2);\n\n\treturn getDistanceLP(lx1, ly1, lx2, ly2, px, py);\n}\n\nchar\nsolve()\n{\n\tdouble r1 = vabs(tx1 - cx, ty1 - cy);\n\tdouble r2 = vabs(tx2 - cx, ty2 - cy);\n\tdouble r3 = vabs(tx3 - cx, ty3 - cy);\n\tif (r1 <= cr + EPS && r2 <= cr + EPS && r3 <= cr + EPS)\n\t\treturn 'b';\n\n\tdouble th21 = atan2(tx2 - tx1, ty2 - ty1);\n\tdouble th31 = atan2(tx3 - tx1, ty3 - ty1);\n\tdouble th12 = atan2(tx1 - tx2, ty1 - ty2);\n\tdouble th32 = atan2(tx3 - tx2, ty3 - ty2);\n\tdouble thc1 = atan2(cx - tx1, cy - ty1);\n\tdouble thc2 = atan2(cx - tx2, cy - ty2);\n\n\tif (((th21 <= thc1 + EPS && thc1 <= th31 + EPS) || (th31 <= thc1 + EPS && thc1 <= th21 + EPS)) &&\n\t    ((th12 <= thc2 + EPS && thc2 <= th32 + EPS) || (th32 <= thc2 + EPS && thc2 <= th12 + EPS)))\n\t{\n\t\tr1 = getDistanceLP(tx1, ty1, tx2, ty2, cx, cy);\n\t\tr2 = getDistanceLP(tx3, ty3, tx2, ty2, cx, cy);\n\t\tr3 = getDistanceLP(tx3, ty3, tx1, ty1, cx, cy);\n\t\tif (r1 + EPS >= cr && r2 + EPS >= cr && r3 + EPS >= cr)\n\t\t\treturn 'a';\n\t\telse\n\t\t\treturn 'c';\n\t}\n\telse\n\t{\n\t\tr1 = getDistanceSP(tx1, ty1, tx2, ty2, cx, cy);\n\t\tr2 = getDistanceSP(tx3, ty3, tx2, ty2, cx, cy);\n\t\tr3 = getDistanceSP(tx3, ty3, tx1, ty1, cx, cy);\n\t\tif (r1 > cr + EPS && r2 > cr + EPS && r3 > cr + EPS)\n\t\t\treturn 'd';\n\t\telse\n\t\t\treturn 'c';\n\t}\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &tx1, &ty1);\n\t\tif (tx1 == 0 && ty1 == 0)\n\t\t\tbreak;\n\n\t\tscanf(\"%d%d\", &tx2, &ty2);\n\t\tscanf(\"%d%d\", &tx3, &ty3);\n\t\tscanf(\"%d%d\", &cx, &cy);\n\t\tscanf(\"%d\", &cr);\n\t\tprintf(\"%c\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\ntypedef struct {\n\tint x,y;\n} coord_t;\n\ntypedef struct {\n\tcoord_t c;\n\tint r;\n} circle_t;\n\ntypedef struct {\n\tcoord_t a,b,c;\n} triangle_t;\n\ncoord_t read_coord(void) {\n\tcoord_t ret;\n\tscanf(\"%d%d\",&ret.x,&ret.y);\n\treturn ret;\n}\n\ncoord_t sub_coord(coord_t dest,coord_t src) {\n\tcoord_t ret;\n\tret.x=dest.x-src.x;\n\tret.y=dest.y-src.y;\n\treturn ret;\n}\n\nint point_in_triangle(coord_t p,triangle_t t) {\n\tcoord_t vec1=sub_coord(t.b,t.a);\n\tcoord_t vec2=sub_coord(t.c,t.a);\n\tcoord_t vecp=sub_coord(p,t.a);\n\t/* x*vec1 + y*vec2 == vecp */\n\tdouble d=(double)vec1.x*vec2.y-(double)vec1.y*vec2.x;\n\tdouble x=(double)vec2.y*vecp.x-(double)vec2.x*vecp.y;\n\tdouble y=-(double)vec1.y*vecp.x+(double)vec1.x*vecp.y;\n\t/* x/d>=0 && y/d>=0 && (x+y)/d<=1 */\n\tif(d>0.0) {\n\t\treturn x>=0 && y>=0 && x+y<d+EPS;\n\t} else if(d<0.0) {\n\t\treturn x<=0 && y<=0 && x+y+EPS>d;\n\t} else {\n\t\t/* sankakukei ga nai */\n\t\treturn 0;\n\t}\n}\n\nint point_in_circle(coord_t p,circle_t c) {\n\treturn (double)(p.x-c.c.x)*(p.x-c.c.x)+(double)(p.y-c.c.y)*(p.y-c.c.y)\n\t\t<(double)c.r*c.r+EPS;\n}\n\ndouble ten_to_chokusen_no_kyori(coord_t p,coord_t l0, coord_t l1) {\n\t/* (x,y) = (x0,y0)+t(x1-x0,y1-y0)\n\t *\n\t * x+b*y+c==0 ga t ni kansuru koutousiki\n\t *\n\t * x0-t*x0+t*x1+b*y0-b*t*y0+b*t*y1+c==0\n\t * (x0+b*y0+c)+(-x0+x1-b*y0+b*y1)*t==0\n\t *\n\t * y0*b+c==-x0\n\t * (y1-y0)*b==x0-x1\n\t * b=(x0-x1)/(y1-y0)\n\t * c=-x0-y0*(x0-x1)/(y1-y0)\n\t *\n\t * x+(x0-x1)/(y1-y0)*y+(-x0-y0*(x0-x1)/(y1-y0))==0\n\t * (y1-y0)*x+(x0-x1)*y+(-x0*(y1-y0)-y0*(x0-x1))==0\n\t * (y1-y0)*x+(x0-x1)*y+(x1*y0-x0*y1)==0\n\t */\n\t double a=l1.y-l0.y;\n\t double b=l0.x-l1.x;\n\t double c=(double)l1.x*l0.y-(double)l0.x*l1.y;\n\t return fabs(a*p.x+b*p.y+c)/sqrt(a*a+b*b);\n}\n\nint is_senbun_circle_hit(coord_t l0,coord_t l1,circle_t en) {\n\t/* |(x0,y0)+t*(dx,dy)|==r where dx=x1-x0,dy=y1-y0\n\t * (x0+t*dx)^2+(y0+t*dy)^2==r^2\n\t * (dx^2+dy^2)*t^2+2*(x0*dx+y0*dy)*t+(x0^2+y0^2-r^2)==0\n\t */\n\tcoord_t d=sub_coord(l1,l0);\n\tdouble a=(double)d.x*d.x+(double)d.y*d.y;\n\tdouble b=2.0*((double)l0.x*d.x+(double)l0.y*d.y);\n\tdouble c=(double)l0.x*l0.x+(double)l0.y*l0.y-(double)en.r*en.r;\n\tdouble hanbetusiki=b*b-4.0*a*c;\n\tdouble sqrd,t0,t1;\n\tif(hanbetusiki<=0.0 && hanbetusiki>-EPS)hanbetusiki=0.0;\n\tif(hanbetusiki<0.0)return 0;\n\tsqrd=sqrt(hanbetusiki);\n\tt0=(-b-sqrd)/(2.0*a);\n\tt1=(-b+sqrd)/(2.0*a);\n\treturn (0.0<t0+EPS && t0<1.0+EPS) || (0.0<t1+EPS && t1<1.0+EPS);\n}\n\nint main(void) {\n\ttriangle_t t;\n\tcircle_t c;\n\tfor(;;) {\n\t\tt.a=read_coord();\n\t\tif(t.a.x==0 && t.a.y==0)break;\n\t\tt.b=read_coord();\n\t\tt.c=read_coord();\n\t\tc.c=read_coord();\n\t\tscanf(\"%d\",&c.r);\n\t\tif(point_in_circle(t.a,c) && point_in_circle(t.b,c) && point_in_circle(t.c,c)) {\n\t\t\t/* sankakukei ga en ni fukumareru */\n\t\t\tputs(\"b\");\n\t\t} else if(point_in_triangle(c.c,t)) {\n\t\t\t/* en no chuusinn ga sankakukei no naka ni aru */\n\t\t\tif(ten_to_chokusen_no_kyori(c.c,t.a,t.b)+EPS>c.r &&\n\t\t\tten_to_chokusen_no_kyori(c.c,t.b,t.c)+EPS>c.r &&\n\t\t\tten_to_chokusen_no_kyori(c.c,t.c,t.a)+EPS>c.r) {\n\t\t\t\t/* sankakukei ni en ga fukumareru */\n\t\t\t\tputs(\"a\");\n\t\t\t} else {\n\t\t\t\t/* en ga sankakukei kara hamidasu */\n\t\t\t\tputs(\"c\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* en ga sankakukei no sotogawa ni aru */\n\t\t\tif(is_senbun_circle_hit(t.a,t.b,c) ||\n\t\t\tis_senbun_circle_hit(t.b,t.c,c) ||\n\t\t\tis_senbun_circle_hit(t.c,t.a,c)) {\n\t\t\t\t/* sankakukei to en ga maziwaru */\n\t\t\t\tputs(\"c\");\n\t\t\t} else {\n\t\t\t\t/* en to sankakukei wa hanareteru */\n\t\t\t\tputs(\"d\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint xa,ya,xb,yb,xc,yc,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr,int type){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif(type==0 && tim*tim/ab2 >= (double)rr2)return 0;\n\tif(type==1 && tim*tim/ab2 != (double)rr2)return 0;\n\tif(abw<0)return 0;\n\tif(abw>ab2)return 0;\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d %d\",&xa,&ya)*xa){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&xb,&yb,&xc,&yc,&wx,&wy,&r);\n\n\t\tint ttt=0;\n\n\t\tint d1=(xa-wx)*(xa-wx)+(ya-wy)*(ya-wy)-r*r;\n\t\tint d2=(xb-wx)*(xb-wx)+(yb-wy)*(yb-wy)-r*r;\n\t\tint d3=(xc-wx)*(xc-wx)+(yc-wy)*(yc-wy)-r*r;\n\t\tint tim1=(wx-xa)*(yb-ya)-(wy-ya)*(xb-xa);\n\t\tint tim2=(wx-xb)*(yc-yb)-(wy-yb)*(xc-xb);\n\t\tint tim3=(wx-xc)*(ya-yc)-(wy-yc)*(xa-xc);\n\n\t\tif (tim1*tim2>0 && tim2*tim3>0) ttt=1;\n\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"c\\n\");continue;}\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r,0)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r,0)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r,0)){printf(\"c\\n\");continue;}\n\n\t\tif(ttt==1){printf(\"a\\n\");continue;}\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r,1)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r,1)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r,1)){printf(\"c\\n\");continue;}\n\t\t\n\t\tprintf(\"d\\n\");\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint xa,ya,xb,yb,xc,yc,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 >= (double)rr2)return 0;\n\tif(abw<=0)return 0;\n\tif(abw>=ab2)return 0;\n\treturn 1;\n}\n\ndouble dist2(int px,int py,int qx,int qy,int ax,int ay){\n\tint vx=qx-px,vy=qy-py,wx=ax-px,wy=ay-py;\n\tint tim=vx*wy-wx*vy;\n\treturn (double)tim*tim/(vx*vx+vy*vy);\n}\n\nint main(){\n\tif(crosscheck(10,3,10,9,10,10,1))printf(\"OK\\n\");\n\n\twhile(scanf(\"%d %d\",&xa,&ya)*xa){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&xb,&yb,&xc,&yc,&wx,&wy,&r);\n\n\t\tint ttt=0;\n\n\t\tint d1=(xa-wx)*(xa-wx)+(ya-wy)*(ya-wy)-r*r;\n\t\tint d2=(xb-wx)*(xb-wx)+(yb-wy)*(yb-wy)-r*r;\n\t\tint d3=(xc-wx)*(xc-wx)+(yc-wy)*(yc-wy)-r*r;\n\t\tdouble dis1=dist2(xa,ya,xb,yb,wx,wy)-r*r;\n\t\tdouble dis2=dist2(xb,yb,xc,yc,wx,wy)-r*r;\n\t\tdouble dis3=dist2(xc,yc,xa,ya,wx,wy)-r*r;\n\t\tint tim1=(wx-xa)*(yb-ya)-(wy-ya)*(xb-xa);\n\t\tint tim2=(wx-xb)*(yc-yb)-(wy-yb)*(xc-xb);\n\t\tint tim3=(wx-xc)*(ya-yc)-(wy-yc)*(xa-xc);\n\n\t\tif (tim1*tim2>0 && tim2*tim3>0) ttt=1;\n\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"c\\n\");continue;}\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c\\n\");continue;}\n\n\t\tif(ttt==1){printf(\"a\\n\");continue;}\n\t\tif(dis1==0 || dis2==0 || dis3==0){printf(\"c\\n\");continue;}\n\t\t\n\t\tprintf(\"d\\n\");\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\ntypedef struct {\n\tdouble x,y;\n} coord_t;\n\ntypedef struct {\n\tcoord_t c;\n\tdouble r;\n} circle_t;\n\ntypedef struct {\n\tcoord_t a,b,c;\n} triangle_t;\n\ncoord_t read_coord(void) {\n\tcoord_t ret;\n\tscanf(\"%lf%lf\",&ret.x,&ret.y);\n\treturn ret;\n}\n\ncoord_t sub_coord(coord_t dest,coord_t src) {\n\tcoord_t ret;\n\tret.x=dest.x-src.x;\n\tret.y=dest.y-src.y;\n\treturn ret;\n}\n\nint point_in_triangle(coord_t p,triangle_t t) {\n\tcoord_t vec1=sub_coord(t.b,t.a);\n\tcoord_t vec2=sub_coord(t.c,t.a);\n\tcoord_t vecp=sub_coord(p,t.a);\n\t/* x*vec1 + y*vec2 == vecp */\n\tdouble d=vec1.x*vec2.y-vec1.y*vec2.x;\n\tdouble x=vec2.y*vecp.x-vec2.x*vecp.y;\n\tdouble y=-vec1.y*vecp.x+vec1.x*vecp.y;\n\t/* x/d>=0 && y/d>=0 && (x+y)/d<=1 */\n\tif(d>0.0) {\n\t\treturn x>=0 && y>=0 && x+y<d+EPS;\n\t} else if(d<0.0) {\n\t\treturn x<=0 && y<=0 && x+y+EPS>d;\n\t} else {\n\t\t/* sankakukei ga nai */\n\t\treturn 0;\n\t}\n}\n\nint point_in_circle(coord_t p,circle_t c) {\n\treturn (p.x-c.c.x)*(p.x-c.c.x)+(p.y-c.c.y)*(p.y-c.c.y)<c.r*c.r+EPS;\n}\n\ndouble ten_to_chokusen_no_kyori(coord_t p,coord_t l0, coord_t l1) {\n\t/* (x,y) = (x0,y0)+t(x1-x0,y1-y0)\n\t *\n\t * x+b*y+c==0 ga t ni kansuru koutousiki\n\t *\n\t * x0-t*x0+t*x1+b*y0-b*t*y0+b*t*y1+c==0\n\t * (x0+b*y0+c)+(-x0+x1-b*y0+b*y1)*t==0\n\t *\n\t * y0*b+c==-x0\n\t * (y1-y0)*b==x0-x1\n\t * b=(x0-x1)/(y1-y0)\n\t * c=-x0-y0*(x0-x1)/(y1-y0)\n\t *\n\t * x+(x0-x1)/(y1-y0)*y+(-x0-y0*(x0-x1)/(y1-y0))==0\n\t * (y1-y0)*x+(x0-x1)*y+(-x0*(y1-y0)-y0*(x0-x1))==0\n\t * (y1-y0)*x+(x0-x1)*y+(x1*y0-x0*y1)==0\n\t */\n\t double a=l1.y-l0.y;\n\t double b=l0.x-l1.x;\n\t double c=l1.x*l0.y-l0.x*l1.y;\n\t return fabs(a*p.x+b*p.y+c)/sqrt(a*a+b*b);\n}\n\nint is_senbun_circle_hit(coord_t l0,coord_t l1,circle_t en) {\n\t/* |(x0,y0)+t*(dx,dy)-(cx,cy)|==r where dx=x1-x0,dy=y1-y0\n\t * ((x0-cx)+t*dx)^2+((y0-cy)+t*dy)^2==r^2\n\t * (dx^2+dy^2)*t^2+2*((x0-cx)*dx+(y0-cy)*dy)*t+((x0-cx)^2+(y0-cy)^2-r^2)==0\n\t */\n\tcoord_t p0=sub_coord(l0,en.c);\n\tcoord_t d=sub_coord(l1,l0);\n\tdouble a=d.x*d.x+d.y*d.y;\n\tdouble b=2.0*(p0.x*d.x+p0.y*d.y);\n\tdouble c=p0.x*p0.x+p0.y*p0.y-en.r*en.r;\n\tdouble hanbetusiki=b*b-4.0*a*c;\n\tdouble sqrd,t0,t1;\n\tif(hanbetusiki<=0.0 && hanbetusiki>-EPS)hanbetusiki=0.0;\n\tif(hanbetusiki<0.0)return 0;\n\tsqrd=sqrt(hanbetusiki);\n\tt0=(-b-sqrd)/(2.0*a);\n\tt1=(-b+sqrd)/(2.0*a);\n\treturn (0.0<t0+EPS && t0<1.0+EPS) || (0.0<t1+EPS && t1<1.0+EPS);\n}\n\nint main(void) {\n\ttriangle_t t;\n\tcircle_t c;\n\tfor(;;) {\n\t\tt.a=read_coord();\n\t\tif(t.a.x==0 && t.a.y==0)break;\n\t\tt.b=read_coord();\n\t\tt.c=read_coord();\n\t\tc.c=read_coord();\n\t\tscanf(\"%lf\",&c.r);\n\t\tif(point_in_circle(t.a,c) && point_in_circle(t.b,c) && point_in_circle(t.c,c)) {\n\t\t\t/* sankakukei ga en ni fukumareru */\n\t\t\tputs(\"b\");\n\t\t} else if(point_in_triangle(c.c,t)) {\n\t\t\t/* en no chuusinn ga sankakukei no naka ni aru */\n\t\t\tif(ten_to_chokusen_no_kyori(c.c,t.a,t.b)+EPS>c.r &&\n\t\t\tten_to_chokusen_no_kyori(c.c,t.b,t.c)+EPS>c.r &&\n\t\t\tten_to_chokusen_no_kyori(c.c,t.c,t.a)+EPS>c.r) {\n\t\t\t\t/* sankakukei ni en ga fukumareru */\n\t\t\t\tputs(\"a\");\n\t\t\t} else {\n\t\t\t\t/* en ga sankakukei kara hamidasu */\n\t\t\t\tputs(\"c\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* en ga sankakukei no sotogawa ni aru */\n\t\t\tif(is_senbun_circle_hit(t.a,t.b,c) ||\n\t\t\tis_senbun_circle_hit(t.b,t.c,c) ||\n\t\t\tis_senbun_circle_hit(t.c,t.a,c)) {\n\t\t\t\t/* sankakukei to en ga maziwaru */\n\t\t\t\tputs(\"c\");\n\t\t\t} else {\n\t\t\t\t/* en to sankakukei wa hanareteru */\n\t\t\t\tputs(\"d\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "float q;\nA,B,C,D,E,F,R;\nM(a,b,c,d,e,f){\n\te=c-a;\n\tf=d-b;\n\tq=fabs(-f*a+e*b)/hypot(e,f);\n\tif(a*e+b*f<0&&c*e+d*f>0&&q<=R)\n\t\tif(q<R)\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\treturn 0;\n}\nI(){\n\tq=E*B-F*A;\n\treturn(C*F-D*E)*q>0&q*(A*D-B*C)>0;\n}\nmain(v,w,o,c){\n\tfor(;scanf(\"%d%d%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&v,&w,&R),A;){\n\t\tA-=v,B-=w;\n\t\tC-=v,D-=w;\n\t\tE-=v,F-=w;\n\t\to=(A*A+B*B>R*R)+(C*C+D*D>R*R)+(E*E+F*F>R*R);\n\t\tif(!o)\n\t\t\tputs(\"b\");\n\t\telse if(o==3){\n\t\t\tc=M(C,D,E,F)|M(E,F,A,B)|M(A,B,C,D);\n\t\t\tif(c&2)\n\t\t\t\tputs(\"c\");\n\t\t\telse if(c&1){\n\t\t\t\tif(I())\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"c\");\n\t\t\t}else{\n\t\t\t\tif(I())\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"d\");\n\t\t\t}\n\t\t}else\n\t\t\tputs(\"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0153: Triangle and Circle\n// 2017.8.12 bal4u@uu\n\n#include <stdio.h>\n\nlong long x[10], y[10];\nlong long xe, ye, r;\n\nint atSameSide(long long x1, long long y1, long long x2, long long y2,\n\tlong long xa, long long ya, long long xb, long long yb)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint between(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\tsb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2);\n\treturn (sa >= 0 && sb >= 0) || (sa < 0 && sb < 0);\n}\n\nint disCmp(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y, long long r)\n{\n\tlong long a, b, c, t;\t\t\t/* ax + by + c = 0 */\n\tlong long squ;\n\ta = y1 - y2, b = x2 - x1, c = y2*x1-x2*y1;\n\tsqu = a*a + b*b;\n\tif (squ == 0) return 0;\n\tt = (a * x) + (b * y) + c;\n\tt = t*t - r*r*squ;\n\tif (t > 0) return 1;\n\tif (t < 0) return -1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, f;\n\tlong long d[3], rr;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\t\tif (!i && !x[0] && !y[0]) return 0;\n\t\t\tx[i + 3] = x[i], y[i + 3] = y[i];\n\t\t}\n\t\tscanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = (x[i] - xe)*(x[i] - xe) + (y[i] - ye)*(y[i] - ye);\n\t\tif (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; }\n\t\tif (rr >= d[0] || rr >= d[1] || rr >= d[2]) { puts(\"c\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tf = atSameSide(x[i], y[i], x[i + 1], y[i + 1],\n\t\t\t\tx[i + 2], y[i + 2], xe, ye);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r);\n\t\tif (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >= 0 ? \"a\" : \"c\"); continue; }\n\t\tif (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tif (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0;\n\t\tputs(f ? \"d\" : \"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint xa,ya,xb,yb,xc,yc,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 >= (double)rr2)return 0;\n\tif(abw<0)return 0;\n\tif(abw>ab2)return 0;\n\treturn 1;\n}\n\ndouble dist2(int px,int py,int qx,int qy,int ax,int ay){\n\tint vx=qx-px,vy=qy-py,wx=ax-px,wy=ay-py;\n\tint tim=vx*wy-wx*vy;\n\treturn (double)tim*tim/(vx*vx+vy*vy);\n}\n\nint main(){\n\tif(crosscheck(10,3,10,9,10,10,1))printf(\"OK\\n\");\n\n\twhile(scanf(\"%d %d\",&xa,&ya)*xa){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&xb,&yb,&xc,&yc,&wx,&wy,&r);\n\n\t\tint ccc=0,ttt=0,ddd;\n\n\t\tint d1=(xa-wx)*(xa-wx)+(ya-wy)*(ya-wy)-r*r;\n\t\tint d2=(xb-wx)*(xb-wx)+(yb-wy)*(yb-wy)-r*r;\n\t\tint d3=(xc-wx)*(xc-wx)+(yc-wy)*(yc-wy)-r*r;\n\t\tdouble dis1=dist2(xa,ya,xb,yb,wx,wy)-r*r;\n\t\tdouble dis2=dist2(xb,yb,xc,yc,wx,wy)-r*r;\n\t\tdouble dis3=dist2(xc,yc,xa,ya,wx,wy)-r*r;\n\t\tint tim1=(wx-xa)*(yb-ya)-(wy-ya)*(xb-xa);\n\t\tint tim2=(wx-xb)*(yc-yb)-(wy-yb)*(xc-xb);\n\t\tint tim3=(wx-xc)*(ya-yc)-(wy-yc)*(xa-xc);\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c\\n\");continue;}\n\n\t\tif (tim1*tim2>0 && tim2*tim3>0) ttt=1;\n\n\t\tif(dis1==0 && dis2==0 && dis3==0){printf(\"a\\n\");continue;}\n\t\tif(dis1==0 || dis2==0 || dis3==0){printf(\"d\\n\");continue;}\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"d\\n\");continue;}\n\t\tif(ttt==1){printf(\"a\\n\");continue;}\n\t\tprintf(\"d\\n\");\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint xa,ya,xb,yb,xc,yc,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2==rr2 || bw2==rr2)return 0;\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 >= (double)rr2)return 0;\n\tif(abw<=0)return 0;\n\tif(abw>=ab2)return 0;\n\treturn 1;\n}\n\ndouble dist2(int px,int py,int qx,int qy,int ax,int ay){\n\tint vx=qx-px,vy=qy-py,wx=ax-px,wy=ay-py;\n\tint tim=vx*wy-wx*vy;\n\treturn (double)tim*tim/(vx*vx+vy*vy);\n}\n\nint main(){\n\tif(crosscheck(10,3,10,9,10,10,1))printf(\"OK\\n\");\n\n\twhile(scanf(\"%d %d\",&xa,&ya)*xa){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&xb,&yb,&xc,&yc,&wx,&wy,&r);\n\n\t\tint ttt=0;\n\n\t\tint d1=(xa-wx)*(xa-wx)+(ya-wy)*(ya-wy)-r*r;\n\t\tint d2=(xb-wx)*(xb-wx)+(yb-wy)*(yb-wy)-r*r;\n\t\tint d3=(xc-wx)*(xc-wx)+(yc-wy)*(yc-wy)-r*r;\n\t\tdouble dis1=dist2(xa,ya,xb,yb,wx,wy)-r*r;\n\t\tdouble dis2=dist2(xb,yb,xc,yc,wx,wy)-r*r;\n\t\tdouble dis3=dist2(xc,yc,xa,ya,wx,wy)-r*r;\n\t\tint tim1=(wx-xa)*(yb-ya)-(wy-ya)*(xb-xa);\n\t\tint tim2=(wx-xb)*(yc-yb)-(wy-yb)*(xc-xb);\n\t\tint tim3=(wx-xc)*(ya-yc)-(wy-yc)*(xa-xc);\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c1\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c2\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c3\\n\");continue;}\n\n\t\tif (tim1*tim2>0 && tim2*tim3>0) ttt=1;\n\n\t\tif(dis1==0 && dis2==0 && dis3==0){printf(\"a\\n\");continue;}\n\t\tif(dis1==0 || dis2==0 || dis3==0){printf(\"c\\n\");continue;}\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"c\\n\");continue;}\n\t\tif(ttt==1){printf(\"a\\n\");continue;}\n\t\tprintf(\"d\\n\");\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,n,m;\nint x1,y1,x2,y2,x3,y3,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 > (double)rr2)return 0;\n\tif(abw<0)return 0;\n\tif(abw>ab2)return 0;\n\treturn 1;\n}\n\nint main(){\n\tif(crosscheck(10,3,10,9,10,10,1))printf(\"OK\\n\");\n\n\twhile(scanf(\"%d %d\",&x1,&y1)*x1){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&x2,&y2,&x3,&y3,&wx,&wy,&r);\n\n\t\tif(crosscheck(x1,y1,x2,y2,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\tif(crosscheck(x2,y2,x3,y3,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\tif(crosscheck(x3,y3,x1,y1,wx,wy,r)){printf(\"c\\n\");continue;}\n\n\t\tint d1=(x1-wx)*(x1-wx)+(y1-wy)*(y1-wy)-r*r;\n\t\tint d2=(x2-wx)*(x2-wx)+(y2-wy)*(y2-wy)-r*r;\n\t\tint d3=(x3-wx)*(x3-wx)+(y3-wy)*(y3-wy)-r*r;\n\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"d\\n\");continue;}\n\n\t\tint tim1=(wx-x1)*(y2-y1)-(wy-y1)*(x2-x1);\n\t\tint tim2=(wx-x2)*(y3-y2)-(wy-y2)*(x3-x2);\n\t\tint tim3=(wx-x3)*(y1-y3)-(wy-y3)*(x1-x3);\n\n\t\tif(tim1*tim2>0 && tim2*tim3>0){printf(\"a\\n\");continue;}\n\t\tprintf(\"d\\n\");\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint xa,ya,xb,yb,xc,yc,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 >= (double)rr2)return 0;\n\tif(abw<0)return 0;\n\tif(abw>ab2)return 0;\n\treturn 1;\n}\n\nint touchcheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 0;\n\tif( tim*tim/ab2 != (double)rr2)return 0;\n\tif(abw<0)return 0;\n\tif(abw>ab2)return 0;\n\treturn 1;\n}\n\nint main(){\n\tif(crosscheck(10,3,10,9,10,10,1))printf(\"OK\\n\");\n\n\twhile(scanf(\"%d %d\",&xa,&ya)*xa){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&xb,&yb,&xc,&yc,&wx,&wy,&r);\n\n\t\tint ttt=0;\n\n\t\tint d1=(xa-wx)*(xa-wx)+(ya-wy)*(ya-wy)-r*r;\n\t\tint d2=(xb-wx)*(xb-wx)+(yb-wy)*(yb-wy)-r*r;\n\t\tint d3=(xc-wx)*(xc-wx)+(yc-wy)*(yc-wy)-r*r;\n\t\tint tim1=(wx-xa)*(yb-ya)-(wy-ya)*(xb-xa);\n\t\tint tim2=(wx-xb)*(yc-yb)-(wy-yb)*(xc-xb);\n\t\tint tim3=(wx-xc)*(ya-yc)-(wy-yc)*(xa-xc);\n\n\t\tif (tim1*tim2>0 && tim2*tim3>0) ttt=1;\n\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"c\\n\");continue;}\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c\\n\");continue;}\n\n\t\tif(ttt==1){printf(\"a\\n\");continue;}\n\n\t\tif(touchcheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(touchcheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(touchcheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\t\n\t\tprintf(\"d\\n\");\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint xa,ya,xb,yb,xc,yc,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 >= (double)rr2)return 0;\n\tif(abw<0)return 0;\n\tif(abw>ab2)return 0;\n\treturn 1;\n}\n\nint touchcheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 != (double)rr2)return 0;\n\tif(abw<0)return 0;\n\tif(abw>ab2)return 0;\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d %d\",&xa,&ya)*xa){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&xb,&yb,&xc,&yc,&wx,&wy,&r);\n\n\t\tint ttt=0;\n\n\t\tint d1=(xa-wx)*(xa-wx)+(ya-wy)*(ya-wy)-r*r;\n\t\tint d2=(xb-wx)*(xb-wx)+(yb-wy)*(yb-wy)-r*r;\n\t\tint d3=(xc-wx)*(xc-wx)+(yc-wy)*(yc-wy)-r*r;\n\t\tint tim1=(wx-xa)*(yb-ya)-(wy-ya)*(xb-xa);\n\t\tint tim2=(wx-xb)*(yc-yb)-(wy-yb)*(xc-xb);\n\t\tint tim3=(wx-xc)*(ya-yc)-(wy-yc)*(xa-xc);\n\n\t\tif (tim1*tim2>0 && tim2*tim3>0) ttt=1;\n\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"c\\n\");continue;}\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c\\n\");continue;}\n\n\t\tif(ttt==1){printf(\"a\\n\");continue;}\n\n\t\tif(touchcheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(touchcheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\telse if(touchcheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c\\n\");continue;}\n\t\t\n\t\tprintf(\"d\\n\");\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <math.h>           // fabs(), sqrt(), atan2()\n#include <stdbool.h>\n\nconst double EPS = 1e-10;\n\nint tx1, ty1, tx2, ty2, tx3, ty3;\nint cx, cy, cr;\n\ndouble\ndot(int ax, int ay, int bx, int by)\n{\n\treturn ax * bx + ay * by;\n}\n\ndouble\ncross(int ax, int ay, int bx, int by)\n{\n\treturn ax * by - ay * bx;\n}\n\ndouble\nvabs(int x, int y)\n{\n\treturn sqrt(x * x + y * y);\n}\n\ndouble\ngetDistanceLP(int lx1, int ly1, int lx2, int ly2, int px, int py)\n{\n\treturn fabs(cross(lx2 - lx1, ly2 - ly1, px - lx1, py - ly1) / vabs(lx2 - lx1, ly2 - ly1));\n}\n\ndouble\ngetDistanceSP(int lx1, int ly1, int lx2, int ly2, int px, int py)\n{\n\tif (dot(lx2 - lx1, ly2 - ly1, px - lx1, py - ly1) < 0.0)\n\t\treturn vabs(px - lx1, py - ly1);\n\n\tif (dot(lx1 - lx2, ly1 - ly2, px - lx2, py - ly2) < 0.0)\n\t\treturn vabs(px - lx2, py - ly2);\n\n\treturn getDistanceLP(lx1, ly1, lx2, ly2, px, py);\n}\n\nchar\nsolve()\n{\n\tdouble r1 = vabs(tx1 - cx, ty1 - cy);\n\tdouble r2 = vabs(tx2 - cx, ty2 - cy);\n\tdouble r3 = vabs(tx3 - cx, ty3 - cy);\n\tif ((r1 <= cr + EPS) && (r2 <= cr + EPS) && (r3 <= cr + EPS))\n\t\treturn 'b';\n\n\tdouble th21 = atan2(tx2 - tx1, ty2 - ty1);\n\tdouble th31 = atan2(tx3 - tx1, ty3 - ty1);\n\tdouble th12 = atan2(tx1 - tx2, ty1 - ty2);\n\tdouble th32 = atan2(tx3 - tx2, ty3 - ty2);\n\tdouble thc1 = atan2(cx - tx1, cy - ty1);\n\tdouble thc2 = atan2(cx - tx2, cy - ty2);\n\n\tif (((th21 <= thc1 + EPS && thc1 <= th31 + EPS) || (th31 <= thc1 + EPS && thc1 <= th21 + EPS)) &&\n\t    ((th12 <= thc2 + EPS && thc2 <= th32 + EPS) || (th32 <= thc2 + EPS && thc2 <= th12 + EPS)))\n\t{\n\t\tr1 = getDistanceLP(tx1, ty1, tx2, ty2, cx, cy);\n\t\tr2 = getDistanceLP(tx3, ty3, tx2, ty2, cx, cy);\n\t\tr3 = getDistanceLP(tx3, ty3, tx1, ty1, cx, cy);\n\t\tif (r1 + EPS >= cr && r2 + EPS >= cr && r3 + EPS >= cr)\n\t\t\treturn 'a';\n\t\telse\n\t\t\treturn 'c';\n\t}\n\telse\n\t{\n\t\tr1 = getDistanceSP(tx1, ty1, tx2, ty2, cx, cy);\n\t\tr2 = getDistanceSP(tx3, ty3, tx2, ty2, cx, cy);\n\t\tr3 = getDistanceSP(tx3, ty3, tx1, ty1, cx, cy);\n\t\tif (r1 > cr + EPS && r2 > cr + EPS && r3 > cr + EPS)\n\t\t\treturn 'd';\n\t\telse\n\t\t\treturn 'c';\n\t}\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &tx1, &ty1);\n\t\tif (tx1 == 0 && ty1 == 0)\n\t\t\tbreak;\n\n\t\tscanf(\"%d%d\", &tx2, &ty2);\n\t\tscanf(\"%d%d\", &tx3, &ty3);\n\t\tscanf(\"%d%d\", &cx, &cy);\n\t\tscanf(\"%d\", &cr);\n\t\tprintf(\"%c\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0153: Triangle and Circle\n// 2017.8.11\n\n#include <stdio.h>\n\nlong long x[10], y[10];\nlong long xe, ye, r;\n\nint atSameSide(long long x1, long long y1, long long x2, long long y2,\n\tlong long xa, long long ya, long long xb, long long yb)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\treturn (int)(sa >= 0 && sb >= 0);\n}\n\nint between(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\tsb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2);\n\treturn (int)(sa >= 0 && sb >= 0);\n}\n\nint disCmp(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y, long long r)\n{\n\tlong long a, b, c, t;\t\t\t/* ax + by + c = 0 */\n\tlong long squ;\n\ta = y1 - y2, b = x2 - x1, c = y2*x1-x2*y1;\n\tsqu = a*a + b*b;\n\tif (squ == 0) return 0;\n\tt = (a * x) + (b * y) + c;\n\tt = t*t - r*r*squ;\n\tif (t > 0) return 1;\n\tif (t < 0) return -1;\n\treturn 0;\n}\n\nint main()\n{\n\tint i, f;\n\tlong long d[3], rr;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\t\tif (!i && !x[0] && !y[0]) return 0;\n\t\t\tx[i + 3] = x[i], y[i + 3] = y[i];\n\t\t}\n\t\tscanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = (x[i] - xe)*(x[i] - xe) + (y[i] - ye)*(y[i] - ye);\n\t\tif (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; }\n\t\tif (rr >= d[0] || rr >= d[1] || rr >= d[2]) { puts(\"c\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tf = atSameSide(x[i], y[i], x[i + 1], y[i + 1],\n\t\t\t\tx[i + 2], y[i + 2], xe, ye);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r);\n\t\tif (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >= 0 ? \"a\" : \"c\"); continue; }\n\t\tif (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tif (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0;\n\t\tputs(f ? \"d\" : \"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "float q;A,B,C,D,E,F,R;M(a,b,c,d,e,f){e=c-a;f=d-b;q=fabs(f*a-e*b)/hypot(e,f);return a*e+b*f<0&c*e+d*f>0&q<=R?q<R?2:1:0;}main(v,w,o,c){for(;scanf(\"%d%d%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&v,&w,&R),A;puts(o?o-3|c&2?\"c\":(C*F-D*E)*q>0&q*(A*D-B*C)>0?\"a\":c&1?\"c\":\"d\":\"b\"))A-=v,B-=w,C-=v,D-=w,E-=v,F-=w,o=(A*A+B*B>R*R)+(C*C+D*D>R*R)+(E*E+F*F>R*R),c=M(C,D,E,F)|M(E,F,A,B)|M(A,B,C,D),q=E*B-F*A;exit(0);}"
  },
  {
    "language": "C",
    "code": "float q;A,B,C,D,E,F,R,v,w;M(a,b,c,d,e,f){e=c-a;f=d-b;q=fabs(f*a-e*b)/hypot(e,f);return a*e+b*f<0&c*e+d*f>0&q<=R?q<R?2:1:0;}main(o,c){for(;~scanf(\"%d%d%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&v,&w,&R);v=A&&!puts(o?o-3|c&2?\"c\":(C*F-D*E)*q>0&q*(A*D-B*C)>0?\"a\":c&1?\"c\":\"d\":\"b\"))A-=v,B-=w,C-=v,D-=w,E-=v,F-=w,o=(A*A+B*B>R*R)+(C*C+D*D>R*R)+(E*E+F*F>R*R),c=M(C,D,E,F)|M(E,F,A,B)|M(A,B,C,D),q=E*B-F*A;}"
  },
  {
    "language": "C",
    "code": "float q;\nA,B,C,D,E,F,R;\nM(a,b,c,d,e,f){\n\te=c-a;\n\tf=d-b;\n\tq=fabs(-f*a+e*b)/hypot(e,f);\n\treturn a*e+b*f<0&c*e+d*f>0&q<=R?q<R?2:1:0;\n}\nI(){\n\tq=E*B-F*A;\n\treturn(C*F-D*E)*q>0&q*(A*D-B*C)>0;\n}\nmain(v,w,o,c){\n\tfor(;scanf(\"%d%d%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&v,&w,&R),A;){\n\t\tA-=v,B-=w;\n\t\tC-=v,D-=w;\n\t\tE-=v,F-=w;\n\t\to=(A*A+B*B>R*R)+(C*C+D*D>R*R)+(E*E+F*F>R*R);\n\t\tc=M(C,D,E,F)|M(E,F,A,B)|M(A,B,C,D);\n\t\tputs(o?o-3|c&2?\"c\":I()?\"a\":c&1?\"c\":\"d\":\"b\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <math.h>           // fabs(), sqrt(), atan2()\n#include <stdbool.h>\n\nconst double EPS = 1e-3;\n\nint tx1, ty1, tx2, ty2, tx3, ty3;\nint cx, cy, cr;\n\ndouble\ndot(int ax, int ay, int bx, int by)\n{\n\treturn ax * bx + ay * by;\n}\n\ndouble\ncross(int ax, int ay, int bx, int by)\n{\n\treturn ax * by - ay * bx;\n}\n\ndouble\nvabs(int x, int y)\n{\n\treturn sqrt(x * x + y * y);\n}\n\ndouble\ngetDistanceLP(int lx1, int ly1, int lx2, int ly2, int px, int py)\n{\n\treturn fabs(cross(lx2 - lx1, ly2 - ly1, px - lx1, py - ly1) / vabs(lx2 - lx1, ly2 - ly1));\n}\n\ndouble\ngetDistanceSP(int lx1, int ly1, int lx2, int ly2, int px, int py)\n{\n\tif (dot(lx2 - lx1, ly2 - ly1, px - lx1, py - ly1) < 0.0)\n\t\treturn vabs(px - lx1, py - ly1);\n\n\tif (dot(lx1 - lx2, ly1 - ly2, px - lx2, py - ly2) < 0.0)\n\t\treturn vabs(px - lx2, py - ly2);\n\n\treturn getDistanceLP(lx1, ly1, lx2, ly2, px, py);\n}\n\nchar\nsolve()\n{\n\tdouble r1 = vabs(tx1 - cx, ty1 - cy);\n\tdouble r2 = vabs(tx2 - cx, ty2 - cy);\n\tdouble r3 = vabs(tx3 - cx, ty3 - cy);\n\tif (r1 <= cr + EPS && r2 <= cr + EPS && r3 <= cr + EPS)\n\t\treturn 'b';\n\n\tdouble th21 = atan2(tx2 - tx1, ty2 - ty1);\n\tdouble th31 = atan2(tx3 - tx1, ty3 - ty1);\n\tdouble th12 = atan2(tx1 - tx2, ty1 - ty2);\n\tdouble th32 = atan2(tx3 - tx2, ty3 - ty2);\n\tdouble thc1 = atan2(cx - tx1, cy - ty1);\n\tdouble thc2 = atan2(cx - tx2, cy - ty2);\n\n\tif (((th21 <= thc1 + EPS && thc1 <= th31 + EPS) || (th31 <= thc1 + EPS && thc1 <= th21 + EPS)) &&\n\t    ((th12 <= thc2 + EPS && thc2 <= th32 + EPS) || (th32 <= thc2 + EPS && thc2 <= th12 + EPS)))\n\t{\n\t\tr1 = getDistanceLP(tx1, ty1, tx2, ty2, cx, cy);\n\t\tr2 = getDistanceLP(tx3, ty3, tx2, ty2, cx, cy);\n\t\tr3 = getDistanceLP(tx3, ty3, tx1, ty1, cx, cy);\n\t\tif (r1 + EPS >= cr && r2 + EPS >= cr && r3 + EPS >= cr)\n\t\t\treturn 'a';\n\t\telse\n\t\t\treturn 'c';\n\t}\n\telse\n\t{\n\t\tr1 = getDistanceLP(tx1, ty1, tx2, ty2, cx, cy);\n\t\tr2 = getDistanceLP(tx3, ty3, tx2, ty2, cx, cy);\n\t\tr3 = getDistanceLP(tx3, ty3, tx1, ty1, cx, cy);\n\t\tif (r1 > cr + EPS && r2 > cr + EPS && r3 > cr + EPS)\n\t\t\treturn 'd';\n\t\telse\n\t\t\treturn 'c';\n\t}\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &tx1, &ty1);\n\t\tif (tx1 == 0 && ty1 == 0)\n\t\t\tbreak;\n\n\t\tscanf(\"%d%d\", &tx2, &ty2);\n\t\tscanf(\"%d%d\", &tx3, &ty3);\n\t\tscanf(\"%d%d\", &cx, &cy);\n\t\tscanf(\"%d\", &cr);\n\t\tprintf(\"%c\\n\", solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#define EPS (1e-7)\n\ntypedef struct {\n\tint x,y;\n} coord_t;\n\ntypedef struct {\n\tcoord_t c;\n\tint r;\n} circle_t;\n\ntypedef struct {\n\tcoord_t a,b,c;\n} triangle_t;\n\ncoord_t read_coord(void) {\n\tcoord_t ret;\n\tscanf(\"%d%d\",&ret.x,&ret.y);\n\treturn ret;\n}\n\ncoord_t sub_coord(coord_t dest,coord_t src) {\n\tcoord_t ret;\n\tret.x=dest.x-src.x;\n\tret.y=dest.y-src.y;\n\treturn ret;\n}\n\nint point_in_triangle(coord_t p,triangle_t t) {\n\tcoord_t vec1=sub_coord(t.b,t.a);\n\tcoord_t vec2=sub_coord(t.c,t.a);\n\tcoord_t vecp=sub_coord(p,t.a);\n\t/* x*vec1 + y*vec2 == vecp */\n\tint d=vec1.x*vec2.y-vec1.y*vec2.x;\n\tint x=vec2.y*vecp.x-vec2.x*vecp.y;\n\tint y=-vec1.y*vecp.x+vec1.x*vecp.y;\n\t/* x/d>=0 && y/d>=0 && (x+y)/d<=1 */\n\tif(d>0) {\n\t\treturn x>=0 && y>=0 && x+y<=d;\n\t} else if(d<0) {\n\t\treturn x<=0 && y<=0 && x+y>=d;\n\t} else {\n\t\t/* sankakukei ga nai */\n\t\treturn 0;\n\t}\n}\n\nint point_in_circle(coord_t p,circle_t c) {\n\treturn (p.x-c.c.x)*(p.x-c.c.x)+(p.y-c.c.y)*(p.y-c.c.y)<=c.r*c.r;\n}\n\ndouble ten_to_chokusen_no_kyori(coord_t p,coord_t l0, coord_t l1) {\n\t/* (x,y) = (x0,y0)+t(x1-x0,y1-y0)\n\t *\n\t * x+b*y+c==0 ga t ni kansuru koutousiki\n\t *\n\t * x0-t*x0+t*x1+b*y0-b*t*y0+b*t*y1+c==0\n\t * (x0+b*y0+c)+(-x0+x1-b*y0+b*y1)*t==0\n\t *\n\t * y0*b+c==-x0\n\t * (y1-y0)*b==x0-x1\n\t * b=(x0-x1)/(y1-y0)\n\t * c=-x0-y0*(x0-x1)/(y1-y0)\n\t *\n\t * x+(x0-x1)/(y1-y0)*y+(-x0-y0*(x0-x1)/(y1-y0))==0\n\t * (y1-y0)*x+(x0-x1)*y+(-x0*(y1-y0)-y0*(x0-x1))==0\n\t * (y1-y0)*x+(x0-x1)*y+(x1*y0-x0*y1)==0\n\t */\n\t double a=l1.y-l0.y;\n\t double b=l0.x-l1.x;\n\t double c=l1.x*l0.y-l0.x*l1.y;\n\t return fabs(a*p.x+b*p.y+c)/sqrt(a*a+b*b);\n}\n\nint is_senbun_circle_hit(coord_t l0,coord_t l1,circle_t en) {\n\t/* |(x0,y0)+t*(dx,dy)|==r where dx=x1-x0,dy=y1-y0\n\t * (x0+t*dx)^2+(y0+t*dy)^2==r^2\n\t * (dx^2+dy^2)*t^2+2*(x0*dx+y0*dy)*t+(x0^2+y0^2-r^2)==0\n\t */\n\tcoord_t d=sub_coord(l1,l0);\n\tdouble a=(double)d.x*d.x+(double)d.y*d.y;\n\tdouble b=2.0*((double)l0.x*d.x+(double)l0.y*d.y);\n\tdouble c=(double)l0.x*l0.x+(double)l0.y*l0.y-(double)en.r*en.r;\n\tdouble hanbetusiki=b*b-4.0*a*c;\n\tdouble sqrd,t0,t1;\n\tif(hanbetusiki<=0.0 && hanbetusiki>-EPS)hanbetusiki=0.0;\n\tif(hanbetusiki<0.0)return 0;\n\tsqrd=sqrt(hanbetusiki);\n\tt0=(-b-sqrd)/(2.0*a);\n\tt1=(-b+sqrd)/(2.0*a);\n\treturn (0.0<t0+EPS && t0<1.0+EPS) || (0.0<t1+EPS && t1<1.0+EPS);\n}\n\nint main(void) {\n\ttriangle_t t;\n\tcircle_t c;\n\tfor(;;) {\n\t\tt.a=read_coord();\n\t\tif(t.a.x==0 && t.a.y==0)break;\n\t\tt.b=read_coord();\n\t\tt.c=read_coord();\n\t\tc.c=read_coord();\n\t\tscanf(\"%d\",&c.r);\n\t\tif(point_in_circle(t.a,c) && point_in_circle(t.b,c) && point_in_circle(t.c,c)) {\n\t\t\t/* sankakukei ga en ni fukumareru */\n\t\t\tputs(\"b\");\n\t\t} else if(point_in_triangle(c.c,t)) {\n\t\t\t/* en no chuusinn ga sankakukei no naka ni aru */\n\t\t\tif(ten_to_chokusen_no_kyori(c.c,t.a,t.b)+EPS>c.r &&\n\t\t\tten_to_chokusen_no_kyori(c.c,t.b,t.c)+EPS>c.r &&\n\t\t\tten_to_chokusen_no_kyori(c.c,t.c,t.a)+EPS>c.r) {\n\t\t\t\t/* sankakukei ni en ga fukumareru */\n\t\t\t\tputs(\"a\");\n\t\t\t} else {\n\t\t\t\t/* en ga sankakukei kara hamidasu */\n\t\t\t\tputs(\"c\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* en ga sankakukei no sotogawa ni aru */\n\t\t\tif(is_senbun_circle_hit(t.a,t.b,c) ||\n\t\t\tis_senbun_circle_hit(t.b,t.c,c) ||\n\t\t\tis_senbun_circle_hit(t.c,t.a,c)) {\n\t\t\t\t/* sankakukei to en ga maziwaru */\n\t\t\t\tputs(\"c\");\n\t\t\t} else {\n\t\t\t\t/* en to sankakukei wa hanareteru */\n\t\t\t\tputs(\"d\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0153: Triangle and Circle\n// 2017.8.11\n\n#include <stdio.h>\n\nlong long x[10], y[10];\nlong long xe, ye, r;\n\nint atSameSide(long long x1, long long y1, long long x2, long long y2,\n\tlong long xa, long long ya, long long xb, long long yb)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (ya - y1) + (y2 - y1) * (x1 - xa);\n\tsb = (x2 - x1) * (yb - y1) + (y2 - y1) * (x1 - xb);\n\treturn (int)(sa >= 0 && sb >= 0);\n}\n\nint between(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y)\n{\n\tlong long sa, sb;\n\tsa = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n\tsb = (x1 - x2) * (x - x2) + (y1 - y2) * (y - y2);\n\treturn (int)(sa >= 0 && sb >= 0);\n}\n\nint disCmp(long long x1, long long y1, long long x2, long long y2,\n\tlong long x, long long y, long long r)\n{\n\tlong long a, b, c, t;\t\t\t/* ax + by + c = 0 */\n\tlong long squ;\n\ta = y1 - y2, b = x2 - x1, c = (-b * y1) + (-a * x1);\n\tsqu = a*a + b*b;\n\tif (squ == 0) return 0;\n\tt = (a * x) + (b * y) + c;\n\treturn (int)(t*t - r*r*squ);\t\t// distance > r ?\n}\n\nint main()\n{\n\tint i, f;\n\tlong long d[3], rr;\n\n\twhile (1) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\t\tif (!i && !x[0] && !y[0]) return 0;\n\t\t\tx[i + 3] = x[i], y[i + 3] = y[i];\n\t\t}\n\t\tscanf(\"%lld%lld%lld\", &xe, &ye, &r); rr = r*r;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = (x[i] - xe)*(x[i] - xe) + (y[i] - ye)*(y[i] - ye);\n\t\tif (rr >= d[0] && rr >= d[1] && rr >= d[2]) { puts(\"b\"); continue; }\n\t\tif (rr >= d[0] || rr >= d[1] || rr >= d[2]) { puts(\"c\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++)\n\t\t\tf = atSameSide(x[i], y[i], x[i + 1], y[i + 1],\n\t\t\t\tx[i + 2], y[i + 2], xe, ye);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\td[i] = disCmp(x[i], y[i], x[i + 1], y[i + 1], xe, ye, r);\n\t\tif (f) { puts(d[0] >= 0 && d[1] >= 0 && d[2] >= 0 ? \"a\" : \"c\"); continue; }\n\t\tif (d[0] > 0 && d[1] > 0 && d[2] > 0) { puts(\"d\"); continue; }\n\n\t\tfor (f = 1, i = 0; f && i < 3; i++) {\n\t\t\tif (between(x[i], y[i], x[i + 1], y[i + 1], xe, ye) && d[i] <= 0) f = 0;\n\t\t}\n\t\tputs(f ? \"d\" : \"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint xa,ya,xb,yb,xc,yc,wx,wy,r;\n\nint crosscheck(int tx,int ty,int sx,int sy,int wx,int wy,int rr){\n\n\tint abx=sx-tx,aby=sy-ty;\n\tint awx=wx-tx,awy=wy-ty;\n\tint bwx=wx-sx,bwy=wy-sy;\n\n\tint rr2=rr*rr;\n\tint aw2=awx*awx+awy*awy;\n\tint bw2=bwx*bwx+bwy*bwy;\n\tint ab2=abx*abx+aby*aby;\n\n\tint tim=abx*awy-aby*awx;\n\tint abw=abx*awx+aby*awy;\n\n\tif(aw2==rr2 || bw2==rr2)return 0;\n\tif(aw2<rr2 && bw2<rr2)return 0;\n\tif(aw2<rr2 || bw2<rr2)return 1;\n\tif( tim*tim/ab2 >= (double)rr2)return 0;\n\tif(abw<=0)return 0;\n\tif(abw>=ab2)return 0;\n\treturn 1;\n}\n\ndouble dist2(int px,int py,int qx,int qy,int ax,int ay){\n\tint vx=qx-px,vy=qy-py,wx=ax-px,wy=ay-py;\n\tint tim=vx*wy-wx*vy;\n\treturn (double)tim*tim/(vx*vx+vy*vy);\n}\n\nint main(){\n\tif(crosscheck(10,3,10,9,10,10,1))printf(\"OK\\n\");\n\n\twhile(scanf(\"%d %d\",&xa,&ya)*xa){\n\t\tscanf(\"%d %d %d %d %d %d %d\",&xb,&yb,&xc,&yc,&wx,&wy,&r);\n\n\t\tint ttt=0;\n\n\t\tint d1=(xa-wx)*(xa-wx)+(ya-wy)*(ya-wy)-r*r;\n\t\tint d2=(xb-wx)*(xb-wx)+(yb-wy)*(yb-wy)-r*r;\n\t\tint d3=(xc-wx)*(xc-wx)+(yc-wy)*(yc-wy)-r*r;\n\t\tdouble dis1=dist2(xa,ya,xb,yb,wx,wy)-r*r;\n\t\tdouble dis2=dist2(xb,yb,xc,yc,wx,wy)-r*r;\n\t\tdouble dis3=dist2(xc,yc,xa,ya,wx,wy)-r*r;\n\t\tint tim1=(wx-xa)*(yb-ya)-(wy-ya)*(xb-xa);\n\t\tint tim2=(wx-xb)*(yc-yb)-(wy-yb)*(xc-xb);\n\t\tint tim3=(wx-xc)*(ya-yc)-(wy-yc)*(xa-xc);\n\n\t\tif(crosscheck(xa,ya,xb,yb,wx,wy,r)){printf(\"c1\\n\");continue;}\n\t\telse if(crosscheck(xb,yb,xc,yc,wx,wy,r)){printf(\"c2\\n\");continue;}\n\t\telse if(crosscheck(xc,yc,xa,ya,wx,wy,r)){printf(\"c3\\n\");continue;}\n\n\t\tif (tim1*tim2>0 && tim2*tim3>0) ttt=1;\n\n\t\tprintf(\"%d %d %d\\n\",d1,d2,d3);\n\n\t\tif(d1<=0 && d2<=0 && d3<=0){printf(\"b\\n\");continue;}\n\t\tif(d1==0 || d2==0 || d3==0){printf(\"c\\n\");continue;}\n\t\tif(ttt==1){printf(\"a\\n\");continue;}\n\t\tif(dis1==0 && dis2==0 && dis3==0){printf(\"a\\n\");continue;}\n\t\tif(dis1==0 || dis2==0 || dis3==0){printf(\"c\\n\");continue;}\n\t\tprintf(\"d\\n\");\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n//üª(x1,y1)-(x2,y2)Æ~ü(S(0,0),¼ar)Ì¤L_ÌÂ\n//½¾µüªÌn_ÆI_ÍÆàÉ~ÌO¤É éÆ·éB\nint count_common_circle_segment(int x1,int y1,int x2,int y2,int r){\n\tint x12=x2-x1;\n\tint y12=y2-y1;\n\tdouble d=fabs(-y12*x1+x12*y1)/hypot(x12,y12);\n\tint ip1=-x1*x12-y1*y12;\n\tint ip2=x2*x12+y2*y12;\n\tif(d==r){\n\t\tif(ip1>0&&ip2>0){\n\t\t\treturn 1;\n\t\t}\n\t}else if(d<r){\n\t\tif(ip1>0&&ip2>0){\n\t\t\treturn 2;\n\t\t}\n\t}\n\treturn 0;\n}\n//´_(0,0)ªOp`ÌàÉ é©»è\nint is_origin_inner_triangle(int x1,int y1,int x2,int y2,int x3,int y3){\n\tdouble o1,o2,o3;\n\to1=(double)x2*y3-(double)y2*x3;\n\to2=(double)x3*y1-(double)y3*x1;\n\to3=(double)x1*y2-(double)y1*x2;\n\treturn o1*o2>0&&o2*o3>0;\n}\nint main(){\n\tint x1,y1,x2,y2,x3,y3,x4,y4,r;\n\tint inner1,inner2,inner3;\n\tint common1,common2,common3;\n\tfor(;scanf(\"%d%d%d%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4,&r),x1|y1;){\n\t\tx1-=x4,y1-=y4;\n\t\tx2-=x4,y2-=y4;\n\t\tx3-=x4,y3-=y4;\n\t\tinner1=x1*x1+y1*y1<=r*r;\n\t\tinner2=x2*x2+y2*y2<=r*r;\n\t\tinner3=x3*x3+y3*y3<=r*r;\n\t\tif(inner1&&inner2&&inner3){\n\t\t\tputs(\"b\");\n\t\t}else if(!inner1&&!inner2&&!inner3){\n\t\t\tcommon1=count_common_circle_segment(x2,y2,x3,y3,r);\n\t\t\tcommon2=count_common_circle_segment(x3,y3,x1,y1,r);\n\t\t\tcommon3=count_common_circle_segment(x1,y1,x2,y2,r);\n\t\t\tif(common1==2||common2==2||common3==2){\n\t\t\t\tputs(\"c\");\n\t\t\t}else if(common1==1||common2==1||common3==1){\n\t\t\t\tif(is_origin_inner_triangle(x1,y1,x2,y2,x3,y3))\n\t\t\t\t\tputs(\"a\");//àÚ\n\t\t\t\telse\n\t\t\t\t\tputs(\"c\");//OÚ\n\t\t\t}else{\n\t\t\t\tif(is_origin_inner_triangle(x1,y1,x2,y2,x3,y3))\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"d\");\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"c\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n//üª(x1,y1)-(x2,y2)Æ~(S(0,0),¼ar)ª¤L_ðÂ©»è\nint has_common_circle_segment(int x1,int y1,int x2,int y2,int r){\n\tint x12=x2-x1;\n\tint y12=y2-y1;\n\tif(fabs(-y12*x1+x12*y1)/hypot(x12,y12)<=r){\n\t\tif(x2*x12+y2*y12>0&&-x1*x12-y1*y12>0){\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n//´_(0,0)ªOp`ÌàÉ é©»è\nint is_origin_inner_triangle(int x1,int y1,int x2,int y2,int x3,int y3){\n\tdouble o1,o2,o3;\n\to1=(double)x2*y3-(double)y2*x3;\n\to2=(double)x3*y1-(double)y3*x1;\n\to3=(double)x1*y2-(double)y1*x2;\n\treturn o1*o2>0&&o2*o3>0;\n}\nint main(){\n\tint x1,y1,x2,y2,x3,y3,x4,y4,r;\n\tint inner1,inner2,inner3;\n\tint common1,common2,common3;\n\tfor(;scanf(\"%d%d%d%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&x3,&y3,&x4,&y4,&r),x1|y1;){\n\t\tx1-=x4,y1-=y4;\n\t\tx2-=x4,y2-=y4;\n\t\tx3-=x4,y3-=y4;\n\t\tinner1=x1*x1+y1*y1<=r*r;\n\t\tinner2=x2*x2+y2*y2<=r*r;\n\t\tinner3=x3*x3+y3*y3<=r*r;\n\t\tif(inner1&&inner2&&inner3){\n\t\t\tputs(\"b\");\n\t\t}else if(!inner1&&!inner2&&!inner3){\n\t\t\tcommon1=has_common_circle_segment(x2,y2,x3,y3,r);\n\t\t\tcommon2=has_common_circle_segment(x3,y3,x1,y1,r);\n\t\t\tcommon3=has_common_circle_segment(x1,y1,x2,y2,r);\n\t\t\tif(common1||common2||common3){\n\t\t\t\tputs(\"c\");\n\t\t\t}else{\n\t\t\t\tif(is_origin_inner_triangle(x1,y1,x2,y2,x3,y3))\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"d\");\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"c\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define hypot _hypot\nfloat q;\nA,B,C,D,E,F,R;\nM(a,b,c,d,e,f){\n\te=c-a;\n\tf=d-b;\n\tq=fabs(-f*a+e*b)/hypot(e,f);\n\tif(a*e+b*f<0&&c*e+d*f>0&&q<=R)\n\t\tif(q<R)\n\t\t\treturn 2;\n\t\telse\n\t\t\treturn 1;\n\treturn 0;\n}\nI(){\n\tq=E*B-F*A;\n\treturn(C*F-D*E)*q>0&q*(A*D-B*C)>0;\n}\nmain(v,w,o,c){\n\tfor(;scanf(\"%d%d%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&v,&w,&R),A;){\n\t\tA-=v,B-=w;\n\t\tC-=v,D-=w;\n\t\tE-=v,F-=w;\n\t\to=(A*A+B*B>R*R)+(C*C+D*D>R*R)+(E*E+F*F>R*R);\n\t\tif(!o)\n\t\t\tputs(\"b\");\n\t\telse if(o==3){\n\t\t\tc=M(C,D,E,F)|M(E,F,A,B)|M(A,B,C,D);\n\t\t\tif(c&2)\n\t\t\t\tputs(\"c\");\n\t\t\telse if(c&1){\n\t\t\t\tif(I())\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"c\");\n\t\t\t}else{\n\t\t\t\tif(I())\n\t\t\t\t\tputs(\"a\");\n\t\t\t\telse\n\t\t\t\t\tputs(\"d\");\n\t\t\t}\n\t\t}else\n\t\t\tputs(\"c\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] x, y;\n\tint cx, cy, r;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tx = new int[3];\n\t\t\ty = new int[3];\n\t\t\tx[0] = sc.nextInt();\n\t\t\ty[0] = sc.nextInt();\n\t\t\tif( (x[0]|y[0]) == 0 ) break;\n\t\t\t\n\t\t\tfor(int i=1;i<3;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\t\t\tcx = sc.nextInt();\n\t\t\tcy = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\t\n\t\t\tif(inCir()) System.out.println(\"b\");\n\t\t\telse {\n\t\t\t\tboolean a = inTri();\n\t\t\t\tint b = closs();\n\t\t\t\tif( a&(b<=1) ) System.out.println(\"a\");\n\t\t\t\telse if(b>=1) System.out.println(\"c\");\n\t\t\t\telse System.out.println(\"d\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean inCir() {\n\t\tfor(int i=0;i<3;i++) if( (cx-x[i])*(cx-x[i])+(cy-y[i])*(cy-y[i]) > r*r )\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\t\n\tboolean inTri(){\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tif (clossLine(new int[]{x[i],x[(i+1)%3]}, new int[]{y[i],y[(i+1)%3]},\n\t\t\t\t\t      new int[]{cx,x[(i+2)%3]}, new int[]{cy,y[(i+2)%3]}) )\n\t\t\t\t\t  return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tboolean clossLine(int[] x1, int[] y1, int[] x2, int[] y2) {\n\t\tint v1 = (y2[0]-y1[0])*(x1[1]-x1[0]) - (y1[1]-y1[0])*(x2[0]-x1[0]);\n\t\tint v2 = (y2[1]-y1[0])*(x1[1]-x1[0]) - (y1[1]-y1[0])*(x2[1]-x1[0]);\n\t\tint v3 = (y1[0]-y2[0])*(x2[1]-x2[0]) - (y2[1]-y2[0])*(x1[0]-x2[0]);\n\t\tint v4 = (y1[1]-y2[0])*(x2[1]-x2[0]) - (y2[1]-y2[0])*(x1[1]-x2[0]);\n\t\tif( ( v1&v2&v3&v4 ) == 0 ) return true;\n\t\tboolean a = v1 > 0 ^ v2 < 0;\n\t\tboolean b = v3 > 0 ^ v4 < 0; \n\t\treturn a&b;\n\t}\n\t\n\tint closs() {\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tlong dx = x[(i+1)%3] - x[i];\n\t\t\tlong dy = y[(i+1)%3] - y[i];\n\t\t\tlong px = cx-x[i];\n\t\t\tlong py = cy-y[i];\n\t\t\tlong px1 = cx-x[(i+1)%3];\n\t\t\tlong py1 = cy-y[(i+1)%3];\n\t\t\t\n\t\t\tlong left = (dx*py - dy*px) * (dx*py - dy*px);\n\t\t\tlong right = (long)(r*r)*( dx*dx+dy*dy );\n\t\t\tif( left <= right ) {\n\t\t\t\tif( ( px * px + py * py ) * ( dx*dx+dy*dy ) - left > ( dx*dx+dy*dy ) * ( dx*dx+dy*dy ) || \n\t\t\t\t\t( px1 * px1 + py1 * py1 ) * ( dx*dx+dy*dy ) - left > ( dx*dx+dy*dy ) * ( dx*dx+dy*dy )) \n\t\t\t\t\tcontinue;\n\t\t\t\tif( left == right )\n\t\t\t\t\treturn 1;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tint [] dp;\n\tint max = 1000;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint2D [] triP = new Point2D[3];\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\ttriP[0] = new Point2D.Double(x, y);\n\t\t\tfor(int i = 1;  i < 3; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\ttriP[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tLine2D [] triL = new Line2D[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttriL[i] = new Line2D.Double(triP[i], triP[(i+1) % 3]);\n\t\t\t}\n\t\t\tint cx = sc.nextInt();\n\t\t\tint cy = sc.nextInt();\n\t\t\tint cr = sc.nextInt();\n\t\t\tPoint2D cp = new Point2D.Double(cx, cy);\n\t\t\t\n\t\t\tint state = -1;\n\t\t\tboolean isBorC = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\tif(dis < cr){\n\t\t\t\t\tisBorC = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isBorC){\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tdouble dis = triP[i].distance(cp);\n\t\t\t\t\tif(dis > cr){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flg){\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboolean flg = true;\n\t\t\t\tint sign = triL[0].relativeCCW(cp);\n\t\t\t\tfor(int i = 1; i < 3;i++){\n\t\t\t\t\tint now = triL[i].relativeCCW(cp);\n\t\t\t\t\tif(now * sign != 1){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((char)('a' + state));\n\t\t}\n\t}\n\t\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tIN:while(true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tdouble minx = x1;\n\t\t\tdouble maxx = x1;\n\t\t\tdouble miny = y1;\n\t\t\tdouble maxy = y1;\n\t\t\tPoint2D.Double p1 = new Point2D.Double(x1, y1);\n\t\t\tif(x1 == 0 && y1 == 0) break;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tminx = Math.min(x2, minx);\n\t\t\tminy = Math.min(y2, miny);\n\t\t\tmaxx = Math.max(x2, maxx);\n\t\t\tmaxy = Math.max(y2, maxy);\n\t\t\tPoint2D.Double p2 = new Point2D.Double(x2, y2);\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tminx = Math.min(x3, minx);\n\t\t\tminy = Math.min(y3, miny);\n\t\t\tmaxx = Math.max(x3, maxx);\n\t\t\tmaxy = Math.max(y3, maxy);\n\t\t\tPoint2D.Double p3 = new Point2D.Double(x3, y3);\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tminx = Math.min(x4, minx);\n\t\t\tminy = Math.min(y4, miny);\n\t\t\tmaxx = Math.max(x4, maxx);\n\t\t\tmaxy = Math.max(y4, maxy);\n\t\t\tPoint2D.Double p4 = new Point2D.Double(x4, y4);\n\t\t\tdouble r = sc.nextDouble();\n\t\t\t\n\t\t\tLine2D.Double a = new Line2D.Double(p2,p3);\n\t\t\tLine2D.Double b = new Line2D.Double(p3,p1);\n\t\t\tLine2D.Double c = new Line2D.Double(p1,p2);\n\t\t\t\n\t\t\tif(p1.distance(p4) <= r && p2.distance(p4) <= r && p3.distance(p4) <= r) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue IN;\n\t\t\t}\n\t\t\telse if(a.ptSegDist(p4) >= r && b.ptSegDist(p4) >= r && c.ptSegDist(p4) >= r) {\n\n\t\t\t\tLine2D.Double da = new Line2D.Double(p1,p4);\n                Line2D.Double db = new Line2D.Double(p2,p4);\n                Line2D.Double dc = new Line2D.Double(p3,p4);\n                if(minx<x4 && x4<maxx && miny<y4 && y4<maxy && !a.intersectsLine(da) && !b.intersectsLine(db) && !c.intersectsLine(dc)){\n                    System.out.println(\"a\");\n                }\n                else {\n                    if(a.ptSegDist(p4) == r || b.ptSegDist(p4) == r || c.ptSegDist(p4) == r) {\n                        System.out.println(\"c\");\n                    }\n                    else{\n                        System.out.println(\"d\");\n                    }\n                }\n            }\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Triangle and Circle\npublic class Main{\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tpublic static double distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tpublic static boolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tpublic static int ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static Point proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tpublic static double inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static final double EPS = 1.0e-8;\n\tpublic static double norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint pp = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tif(pp.x==0&&pp.y==0)break;\n\t\t\tPoint[] p = new Point[3];\n\t\t\tp[0]=pp;\n\t\t\tfor(int i=1;i<3;i++)p[i]=new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tPoint c = new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tdouble r = sc.nextDouble();\n\t\t\tboolean isB = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tif(!(Math.pow(c.x-p[i].x, 2)+Math.pow(c.y-p[i].y, 2)<=r*r))isB = false;\n\t\t\t}\n\t\t\tif(isB){\n\t\t\t\tSystem.out.println(\"b\");continue;\n\t\t\t}\n\t\t\tboolean left = true;\n\t\t\tboolean right = true;\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble max = 0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble ex = extp(sub(p[(i+1)%3], p[i]), sub(c, p[i]));\n\t\t\t\tif(ex <= 0)left = false;\n\t\t\t\tif(ex >= 0)right = false;\n\t\t\t\tLine l = new Line(p[i], p[(i+1)%3]);\n\t\t\t\tdouble d = distanceSP(l, c);\n\t\t\t\tmin = Math.min(min, d);\n\t\t\t\tmax = Math.max(max, d);\n\t\t\t}\n\t\t\tboolean in = left|right;\n\t\t\tif(in && min >= r)System.out.println(\"a\");\n\t\t\telse if(!in && min > r)System.out.println(\"d\");\n\t\t\telse System.out.println(\"c\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tboolean flag = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (!(nor(ps[3], ps[i]) <= r * r))\n\t\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = Line.extp(Line.sub(ps[(i + 1) % 3], ps[i]),\n\t\t\t\t\t\tLine.sub(ps[3], ps[i]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tPoint2D [] triP;\n\tLine2D [] triL;\n\tPoint2D cp;\n\tint cr;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ttriP = new Point2D[3];\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\ttriP[0] = new Point2D.Double(x, y);\n\t\t\tfor(int i = 1;  i < 3; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\ttriP[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\ttriL = new Line2D[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttriL[i] = new Line2D.Double(triP[i], triP[(i+1) % 3]);\n\t\t\t}\n\t\t\tint cx = sc.nextInt();\n\t\t\tint cy = sc.nextInt();\n\t\t\tcr = sc.nextInt();\n\t\t\tcp = new Point2D.Double(cx, cy);\n\n\t\t\tboolean res = isB();\n\t\t\tif(res){\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tboolean res2 = isIn();\n\t\t\tif(res2){\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\t\tif(dis < cr){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\t\tif(dis <= cr){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean isIn() {\n\t\tint sign = triL[0].relativeCCW(cp);\n\t\tfor(int i = 1; i < 3;i++){\n\t\t\tint now = triL[i].relativeCCW(cp);\n\t\t\tif(now * sign != 1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean isB() {\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble dis = triP[i].distance(cp);\n\t\t\tif(dis > cr){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tboolean flag = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (!(nor(ps[3], ps[i]) <= r * r))\n\t\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[(i + 1) % 3], ps[i]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = Line.extp(Line.sub(ps[(i + 1) % 3], ps[i]),\n\t\t\t\t\t\tLine.sub(ps[3], ps[i]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tint [] dp;\n\tint max = 1000;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint2D [] triP = new Point2D[3];\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\ttriP[0] = new Point2D.Double(x, y);\n\t\t\tfor(int i = 1;  i < 3; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\ttriP[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tLine2D [] triL = new Line2D[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttriL[i] = new Line2D.Double(triP[i], triP[(i+1) % 3]);\n\t\t\t}\n\t\t\tint cx = sc.nextInt();\n\t\t\tint cy = sc.nextInt();\n\t\t\tint cr = sc.nextInt();\n\t\t\tPoint2D cp = new Point2D.Double(cx, cy);\n\t\t\t\n\t\t\tint state = -1;\n\t\t\tboolean isBorC = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\tif(dis <= cr){\n\t\t\t\t\tisBorC = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isBorC){\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\t\tif(dis >= cr){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flg){\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboolean flg = true;\n\t\t\t\tint sign = triL[0].relativeCCW(cp);\n\t\t\t\tfor(int i = 1; i < 3;i++){\n\t\t\t\t\tint now = triL[i].relativeCCW(cp);\n\t\t\t\t\tif(now * sign != 1){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((char)('a' + state));\n\t\t}\n\t}\n\t\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tint [] dp;\n\tint max = 1000;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint2D [] triP = new Point2D[3];\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\ttriP[0] = new Point2D.Double(x, y);\n\t\t\tfor(int i = 1;  i < 3; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\ttriP[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tLine2D [] triL = new Line2D[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttriL[i] = new Line2D.Double(triP[i], triP[(i+1) % 3]);\n\t\t\t}\n\t\t\tint cx = sc.nextInt();\n\t\t\tint cy = sc.nextInt();\n\t\t\tint cr = sc.nextInt();\n\t\t\tPoint2D cp = new Point2D.Double(cx, cy);\n\t\t\t\n\t\t\tint state = -1;\n\t\t\tboolean isBorC = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\tif(dis <= cr){\n\t\t\t\t\tisBorC = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isBorC){\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tdouble dis = triP[i].distance(cp);\n\t\t\t\t\tif(dis >= cr){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flg){\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboolean flg = true;\n\t\t\t\tint sign = triL[0].relativeCCW(cp);\n\t\t\t\tfor(int i = 1; i < 3;i++){\n\t\t\t\t\tint now = triL[i].relativeCCW(cp);\n\t\t\t\t\tif(now * sign != 1){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((char)('a' + state));\n\t\t}\n\t}\n\t\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.IOException;\n\npublic class Main {\n\t/**\n\t * @param args\n\t */\n\tstatic class Shape {\n\t\tpublic\tint\tx = 0;\n\t\tpublic\tint\ty = 0;\n\t\tpublic\tint\tr = 0;\n\n\t\tpublic Shape(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic Shape(int x, int y, int r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tstatic class Line {\n\t\tpublic\tShape\tps = null;\n\t\tpublic\tShape\tpe = null;\n\t\tpublic\tint\t\ta  = 0;\n\t\tpublic\tint\t\tb  = 0;\n\t\tpublic\tint\t\tc  = 0;\n\n\t\tpublic Line(Shape ps, Shape pe) {\n\t\t\tthis.ps = ps;\n\t\t\tthis.pe = pe;\n\t\t\tthis.a  = pe.y-ps.y;\n\t\t\tthis.b  = ps.x-pe.x;\n\t\t\tthis.c  = -(this.a*ps.x+this.b*ps.y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[][]\td = null;\n\n\t\twhile((d = inp()) != null) {\n\t\t\tsolve(d);\n\t\t}\n\t}\n\n\tprivate static void solve(int[][] d) {\n\t\t{\n\t\t\tint\trr = (d[3][2]*d[3][2]);\n\t\t\tint\td0 = distPow(d[3], d[0]);\n\t\t\tint\td1 = distPow(d[3], d[1]);\n\t\t\tint\td2 = distPow(d[3], d[2]);\n\n\t\t\tif (d0 <= rr && d1 <= rr && d2 <= rr) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tPoint2D.Double\tp1 = new Point2D.Double(d[0][0], d[0][1]);\n\t\t\tPoint2D.Double\tp2 = new Point2D.Double(d[1][0], d[1][1]);\n\t\t\tPoint2D.Double\tp3 = new Point2D.Double(d[2][0], d[2][1]);\n\t\t\tPoint2D.Double\tp4 = new Point2D.Double(d[3][0], d[3][1]);\n\t\t\tLine2D.Double\tl1 = new Line2D.Double(p1, p2);\n\t\t\tLine2D.Double\tl2 = new Line2D.Double(p2, p3);\n\t\t\tLine2D.Double\tl3 = new Line2D.Double(p3, p1);\n\t\t\tdouble\t\t\tdr = (double)d[3][2];\n\t\t\tdouble\t\t\ts1 = l1.ptSegDist(p4);\n\t\t\tdouble\t\t\ts2 = l2.ptSegDist(p4);\n\t\t\tdouble\t\t\ts3 = l3.ptSegDist(p4);\n\n\t\t\tif (s1 >= dr && s2 >= dr && s3 >= dr) {\n\t\t\t\tint\tn1 = crossSign(d[0], d[1], d[3]);\n\t\t\t\tint\tn2 = crossSign(d[1], d[2], d[3]);\n\t\t\t\tint\tn3 = crossSign(d[2], d[0], d[3]);\n\n\t\t\t\tif ((n1 == n2) && (n2 == n3) && s1 == dr && s2 == dr && s3 == dr) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else {\n\t\t\t\t\tif (s1 == dr || s2 == dr || s3 == dr) {\n\t\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\t}  else {\n\t\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int distPow(int[] p1, int[] p2) {\n\t\treturn (p1[0]-p2[0])*(p1[0]-p2[0])+(p1[1]-p2[1])*(p1[1]-p2[1]);\n\t}\n\n\tprivate static int crossSign(int[] p1, int[] p2, int[] p3) {\n\t\tint[]\tvab = { p2[0]-p1[0], p2[1]-p1[1] };\n\t\tint[]\tvap = { p3[0]-p1[0], p3[1]-p1[1] };\n\t\tint\t\tsgn = cross(vab, vap);\n\t\treturn (sgn==0)?0:((sgn>0)?1:-1);\n\t}\n\n\tprivate static int cross(int[] va, int[] vb) {\n\t\treturn va[0]*vb[1]-va[1]*vb[0];   // x1*x2 + y1*y2\n\t}\n\n\tprivate static int[][] inp() {\n\t\tint[][]\td = new int[4][];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i < 3) {\n\t\t\t\tint[]\tp = { parseNum(), parseNum() };\n\t\t\t\tif (p[0] == 0 && p[1] == 0) return null;\n\t\t\t\td[i] = p;\n\t\t\t} else {\n\t\t\t\tint[]\tp = { parseNum(), parseNum(), parseNum() };\n\t\t\t\td[i] = p;\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = 0;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n\n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if ((skp == 0 || buf == -1) && buf != '.') {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic int space(Point a, Point b, Point c){\n\t\treturn (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);\n\t}\n\tpublic double dist(Point a, Point b){\n\t\treturn Math.sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n\t}\n\tpublic double dist(Point a, Point b, Point c){\n\t\treturn Math.abs(space(a, b, c) / dist(a, b));\n\t}\n\tpublic boolean inOrOut(Triangle tr, Point p){\n\t\tdouble key = Math.signum(space(tr.a, tr.b, p)) + Math.signum(space(tr.b, tr.c, p)) + Math.signum(space(tr.c, tr.a, p));\n\t\treturn (Math.abs(key) == 3);\n\t}\n\tpublic void relation(Triangle tr, Circle c){\n\t/*\twriter.println(\"dist(tr.a, c.p) = \" + dist(tr.a, c.p));\n\t\twriter.println(\"dist(tr.b, c.p) = \" + dist(tr.b, c.p));\n\t\twriter.println(\"dist(tr.c, c.p) = \" + dist(tr.c, c.p));\n\t\twriter.println(\"space(tr.a, tr.b, c.p) = \" + space(tr.a, tr.b, c.p));\n\t\twriter.println(\"space(tr.b, tr.c, c.p) = \" + space(tr.b, tr.c, c.p));\n\t\twriter.println(\"space(tr.c, tr.a, c.p) = \" + space(tr.c, tr.a, c.p));\n\t\twriter.println(\"inOrOut(tr, c.p) = \" + inOrOut(tr, c.p));\n\t\twriter.println(\"dist(tr.a, tr.b, c.p) = \" + dist(tr.a, tr.b, c.p));\n\t\twriter.println(\"dist(tr.b, tr.c, c.p) = \" + dist(tr.b, tr.c, c.p));\n\t\twriter.println(\"dist(tr.c, tr.a, c.p) = \" + dist(tr.c, tr.a, c.p));*/\n\t\t\n\t\tif( dist(tr.a, c.p) <= c.r && dist(tr.b, c.p) <= c.r && dist(tr.c, c.p) <= c.r ){\n\t\t\twriter.println(\"b\");\n\t\t} else if( inOrOut(tr, c.p) && (dist(tr.a, tr.b, c.p) >= c.r && dist(tr.b, tr.c, c.p) >= c.r && dist(tr.c, tr.a, c.p) >= c.r) ){\n\t\t\twriter.println(\"a\");\n\t\t} else if( (dist(tr.a, tr.b, c.p) >= c.r || Math.min(dist(tr.a, c.p), dist(tr.b, c.p)) >= c.r) &&\n\t\t\t(dist(tr.b, tr.c, c.p) >= c.r || Math.min(dist(tr.b, c.p), dist(tr.c, c.p)) >= c.r) &&\n\t\t\t(dist(tr.c, tr.a, c.p) >= c.r || Math.min(dist(tr.c, c.p), dist(tr.a, c.p)) >= c.r) ){\n\t\t\twriter.println(\"d\");\n\t\t} else {\n\t\t\twriter.println(\"c\");\n\t\t}\n\t\treturn;\n\t}\n\t\t\t\n\tpublic void solve() throws IOException{\n\t\tint n, m;\n\t\twhile( (n = nextInt()) != 0 | (m = nextInt()) != 0 ){\n\t\t\tint p = nextInt(), q = nextInt(), r = nextInt(), s = nextInt();\n\t\t\tTriangle tr = new Triangle(n, m, p, q, r, s);\n\t\t\tint x = nextInt(), y = nextInt(), z = nextInt();\n\t\t\tCircle c = new Circle(x, y, z);\n\t\t\trelation(tr, c);\n\t\t}\n\t}\t\t\t\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}\n\nclass Triangle{\n\tPoint a;\n\tPoint b;\n\tPoint c;\n\tTriangle(int p, int q, int r, int s, int t, int u){\n\t\ta = new Point(p, q);\n\t\tb = new Point(r, s);\n\t\tc = new Point(t, u);\n\t}\n}\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\nclass Circle{\n\tPoint p;\n\tint r;\n\tCircle(int x, int y, int r){\n\t\tp = new Point(x, y);\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * AOJ id=0153\n * Triangle and Circle\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint[] x = new int[3];\n\t\t\tint[] y = new int[3];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tif(i==0 && x[i]==0 && y[i]==0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tint rx = sc.nextInt();\n\t\t\tint ry = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(solve(x, y, rx, ry, r));\n\t\t}\n\t}\n\n\tprivate String solve(int[] x, int[] y, int rx, int ry, int r) {\n\t\tint[] vx = new int[3];\n\t\tint[] vy = new int[3];\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tvx[i] = x[(i+1)%3]-x[i];\n\t\t\tvy[i] = y[(i+1)%3]-y[i];\n\t\t}\n\t\tint inCircle = 0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint xd = (x[i]-rx)*(x[i]-rx);\n\t\t\tint yd = (y[i]-ry)*(y[i]-ry);\n\t\t\tif(r*r >= xd+yd)\n\t\t\t\tinCircle++;\n\t\t}\n\t\tif(inCircle==3)\n\t\t\treturn \"b\";\n\t\telse if(inCircle==1 || inCircle==2)\n\t\t\treturn \"c\";\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint vrx = rx-x[i];\n\t\t\tint vry = ry-y[i];\n\t\t\t\n\t\t\tint inp = vx[i]*vrx+vy[i]*vry;\n\t\t\tif(inp<0){\n\t\t\t\tif(vrx*vrx+vry*vry < r*r)\n\t\t\t\t\treturn \"c\";\n\t\t\t}else{\n\t\t\t\tif(inp > vx[i]*vx[i]+vy[i]*vy[i]){\n\t\t\t\t\tif((rx-x[(i+1)%3])*(rx-x[(i+1)%3])+(ry-y[(i+1)%3])*(ry-y[(i+1)%3]) <r*r)\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t}else{\n\t\t\t\t\tif(vrx*vrx+vry*vry-inp*inp < (long)(vx[i]*vx[i]+vy[i]*vy[i])*r*r){\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t}\n\t\t\n\t\tint l=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(vx[i]*(ry-y[i])-(rx-x[i])*vy[i]<0)\n\t\t\t\tl++;\n\t\t}\n\t\tif(l==3 || l==0)\n\t\t\treturn \"a\";\n\t\telse\n\t\t\treturn \"d\";\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.IOException;\n\npublic class Main {\n\t/**\n\t * @param args\n\t */\n\tstatic class Shape {\n\t\tpublic\tint\tx = 0;\n\t\tpublic\tint\ty = 0;\n\t\tpublic\tint\tr = 0;\n\n\t\tpublic Shape(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic Shape(int x, int y, int r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tstatic class Line {\n\t\tpublic\tShape\tps = null;\n\t\tpublic\tShape\tpe = null;\n\t\tpublic\tint\t\ta  = 0;\n\t\tpublic\tint\t\tb  = 0;\n\t\tpublic\tint\t\tc  = 0;\n\n\t\tpublic Line(Shape ps, Shape pe) {\n\t\t\tthis.ps = ps;\n\t\t\tthis.pe = pe;\n\t\t\tthis.a  = pe.y-ps.y;\n\t\t\tthis.b  = ps.x-pe.x;\n\t\t\tthis.c  = -(this.a*ps.x+this.b*ps.y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[][]\td = null;\n\n\t\twhile((d = inp()) != null) {\n\t\t\tsolve(d);\n\t\t}\n\t}\n\n\tprivate static void solve(int[][] d) {\n\t\t{\n\t\t\tint\trr = (d[3][2]*d[3][2]);\n\t\t\tint\td0 = distPow(d[3], d[0]);\n\t\t\tint\td1 = distPow(d[3], d[1]);\n\t\t\tint\td2 = distPow(d[3], d[2]);\n\n\t\t\tif (d0 <= rr && d1 <= rr && d2 <= rr) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tPoint2D.Double\tp1 = new Point2D.Double(d[0][0], d[0][1]);\n\t\t\tPoint2D.Double\tp2 = new Point2D.Double(d[1][0], d[1][1]);\n\t\t\tPoint2D.Double\tp3 = new Point2D.Double(d[2][0], d[2][1]);\n\t\t\tPoint2D.Double\tp4 = new Point2D.Double(d[3][0], d[3][1]);\n\t\t\tLine2D.Double\tl1 = new Line2D.Double(p1, p2);\n\t\t\tLine2D.Double\tl2 = new Line2D.Double(p2, p3);\n\t\t\tLine2D.Double\tl3 = new Line2D.Double(p3, p1);\n\t\t\tdouble\t\t\tdr = (double)d[3][2];\n\t\t\tdouble\t\t\ts1 = l1.ptSegDist(p4);\n\t\t\tdouble\t\t\ts2 = l2.ptSegDist(p4);\n\t\t\tdouble\t\t\ts3 = l3.ptSegDist(p4);\n\n\t\t\tif (s1 >= dr && s2 >= dr && s3 >= dr) {\n\t\t\t\tint\tn1 = crossSign(d[0], d[1], d[3]);\n\t\t\t\tint\tn2 = crossSign(d[1], d[2], d[3]);\n\t\t\t\tint\tn3 = crossSign(d[2], d[0], d[3]);\n\n\t\t\t\tif ((n1 == n2) && (n2 == n3) && s1 <= dr && s2 <= dr && s3 <= dr) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else {\n\t\t\t\t\tif (s1 <= dr || s2 <= dr || s3 <= dr) {\n\t\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\t}  else {\n\t\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int distPow(int[] p1, int[] p2) {\n\t\treturn (p1[0]-p2[0])*(p1[0]-p2[0])+(p1[1]-p2[1])*(p1[1]-p2[1]);\n\t}\n\n\tprivate static int crossSign(int[] p1, int[] p2, int[] p3) {\n\t\tint[]\tvab = { p2[0]-p1[0], p2[1]-p1[1] };\n\t\tint[]\tvap = { p3[0]-p1[0], p3[1]-p1[1] };\n\t\tint\t\tsgn = cross(vab, vap);\n\t\treturn (sgn==0)?0:((sgn>0)?1:-1);\n\t}\n\n\tprivate static int cross(int[] va, int[] vb) {\n\t\treturn va[0]*vb[1]-va[1]*vb[0];   // x1*x2 + y1*y2\n\t}\n\n\tprivate static int[][] inp() {\n\t\tint[][]\td = new int[4][];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i < 3) {\n\t\t\t\tint[]\tp = { parseNum(), parseNum() };\n\t\t\t\tif (p[0] == 0 && p[1] == 0) return null;\n\t\t\t\td[i] = p;\n\t\t\t} else {\n\t\t\t\tint[]\tp = { parseNum(), parseNum(), parseNum() };\n\t\t\t\td[i] = p;\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = 0;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n\n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if ((skp == 0 || buf == -1) && buf != '.') {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tdouble dis = Math.max(\n\t\t\t\t\t\tnew Line(ps[i], ps[(i + 1) % 3]).disToPoint(ps[3]),\n\t\t\t\t\t\tnew Line(ps[(i + 1) % 3], ps[i]).disToPoint(ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]));\n\t\t\t}\n\t\t\tboolean in = eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0\n\t\t\t\t\t|| eps[0] < 0 && eps[1] < 0 && eps[2] < 0;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tint [] dp;\n\tint max = 1000;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint2D [] triP = new Point2D[3];\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\ttriP[0] = new Point2D.Double(x, y);\n\t\t\tfor(int i = 1;  i < 3; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\ttriP[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\tLine2D [] triL = new Line2D[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttriL[i] = new Line2D.Double(triP[i], triP[(i+1) % 3]);\n\t\t\t}\n\t\t\tint cx = sc.nextInt();\n\t\t\tint cy = sc.nextInt();\n\t\t\tint cr = sc.nextInt();\n\t\t\tPoint2D cp = new Point2D.Double(cx, cy);\n\n\t\t\tint state = -1;\n\t\t\tboolean isBorC = false;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\tif(dis <= cr){\n\t\t\t\t\tisBorC = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isBorC){\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tdouble dis = triP[i].distance(cp);\n\t\t\t\t\tif(dis >= cr){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!flg){\n\t\t\t\t\tstate = 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstate = 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboolean flg = true;\n\t\t\t\tint sign = triL[0].relativeCCW(cp);\n\t\t\t\tfor(int i = 1; i < 3;i++){\n\t\t\t\t\tint now = triL[i].relativeCCW(cp);\n\t\t\t\t\tif(now * sign != 1){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstate = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((char)('a' + state));\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] x, y;\n\tint cx, cy, r;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tx = new int[3];\n\t\t\ty = new int[3];\n\t\t\tx[0] = sc.nextInt();\n\t\t\ty[0] = sc.nextInt();\n\t\t\tif( (x[0]|y[0]) == 0 ) break;\n\t\t\t\n\t\t\tfor(int i=1;i<3;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\t\t\tcx = sc.nextInt();\n\t\t\tcy = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\t\n\t\t\tif(inCir()) System.out.println(\"b\");\n\t\t\telse {\n\t\t\t\tboolean a = inTri();\n\t\t\t\tboolean b = closs();\n\t\t\t\tif( a&(!b) ) System.out.println(\"a\");\n\t\t\t\telse if(b) System.out.println(\"c\");\n\t\t\t\telse System.out.println(\"d\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean inCir() {\n\t\tfor(int i=0;i<3;i++) if( (cx-x[i])*(cx-x[i])+(cy-y[i])*(cy-y[i]) > r*r )\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\t\n\tboolean inTri(){\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tif (clossLine(new int[]{x[i],x[(i+1)%3]}, new int[]{y[i],y[(i+1)%3]},\n\t\t\t\t\t      new int[]{cx,x[(i+2)%3]}, new int[]{cy,y[(i+2)%3]}) )\n\t\t\t\t\t  return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tboolean clossLine(int[] x1, int[] y1, int[] x2, int[] y2) {\n\t\tint v1 = (y2[0]-y1[0])*(x1[1]-x1[0]) - (y1[1]-y1[0])*(x2[0]-x1[0]);\n\t\tint v2 = (y2[1]-y1[0])*(x1[1]-x1[0]) - (y1[1]-y1[0])*(x2[1]-x1[0]);\n\t\tint v3 = (y1[0]-y2[0])*(x2[1]-x2[0]) - (y2[1]-y2[0])*(x1[0]-x2[0]);\n\t\tint v4 = (y1[1]-y2[0])*(x2[1]-x2[0]) - (y2[1]-y2[0])*(x1[1]-x2[0]);\n\t\tif( ( v1&v2&v3&v4 ) == 0 ) return true;\n\t\tboolean a = v1 > 0 ^ v2 < 0;\n\t\tboolean b = v3 > 0 ^ v4 < 0; \n\t\treturn a&b;\n\t}\n\t\n\tboolean closs() {\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tint dx = x[(i+1)%3] - x[i];\n\t\t\tint dy = y[(i+1)%3] - y[i];\n\t\t\tint px = cx-x[i];\n\t\t\tint py = cy-y[i];\n\t\t\tif( (dx*py - dy*px) * (dx*py - dy*px) <= r*r*( dx*dx+dy*dy ) )\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x, y;\n\t\t\n\t\tpublic Vector(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tpublic double norm(){\n\t\t\treturn Math.hypot(x, y);\n\t\t}\n\t\t\n\t\tpublic double sqrNorm(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\t\n\t\tpublic double ip(Vector v){\n\t\t\treturn x*v.x+y*v.y;\n\t\t}\n\t\t\n\t\tpublic Vector add(Vector v){\n\t\t\treturn new Vector(x+v.x, y+v.y);\n\t\t}\n\t\t\n\t\tpublic Vector subtract(Vector v){\n\t\t\treturn new Vector(x-v.x, y-v.y);\n\t\t}\n\t\t\n\t\tpublic Vector multiply(double a){\n\t\t\treturn new Vector(x*a, y*a);\n\t\t}\n\t}\n\t\n\tboolean inTriangle(Vector[] v){\n\t\tdouble theta=0;\n\t\tfor(int i=0;i<3;++i){\n\t\t\ttheta+=Math.acos(v[i].ip(v[(i+1)%3])/v[i].norm()/v[(i+1)%3].norm());\n\t\t}\n\t\treturn theta>=Math.PI*2-1e-7;\n\t}\n\t\n\tchar solve(Vector[] a, Vector p, double r){\n\t\tVector[] v=new Vector[3], e=new Vector[3];\n\t\tr*=r;\n\t\t\n\t\tboolean isB=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tv[i]=a[i].subtract(p);\n\t\t\te[i]=a[(i+1)%3].subtract(a[i]);\n\t\t\tisB&=v[i].sqrNorm()<r;\n\t\t}\n\t\tif(isB) return 'b';\n\t\t\n\t\tVector[] h=new Vector[3];\n\t\tboolean isA=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\t//点pより三角形の辺と直交するvector\n\t\t\t//hi=vi+(ei・(-vi)/|ei|^2)ei\n\t\t\th[i]=v[i].subtract(e[i].multiply(e[i].ip(v[i])/e[i].sqrNorm()));\n\t\t\tisA&=h[i].sqrNorm()>r;\n\t\t}\n\t\tif(isA&&inTriangle(v)) return 'a';\n\t\t\n\t\tboolean isC=false;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tVector n=h[i].add(p);\n\t\t\tif(v[i].sqrNorm()<r||(n.subtract(a[i]).ip(n.subtract(a[(i+1)%3]))>0&&h[i].sqrNorm()<r)){\n\t\t\t\tisC=true;\n\t\t\t}\n\t\t}\n\t\tif(isC) return 'c';\n\t\telse return 'd';\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x=ni(),y=ni();\n\t\t\tif(x==0&y==0)break;\n\t\t\t\n\t\t\tVector[] a=new Vector[3];\n\t\t\t\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\ta[i]=new Vector(x, y);\n\t\t\t\tx=ni(); y=ni();\n\t\t\t}\n\t\t\tVector p=new Vector(x, y);\n\t\t\tdouble r=ni();\n\t\t\t\n\t\t\tSystem.out.println(solve(a,p,r));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tboolean flag = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (!(nor(ps[3], ps[i]) <= r * r))\n\t\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = Line.extp(Line.sub(ps[(i + 1) % 3], ps[i]),\n\t\t\t\t\t\tLine.sub(ps[3], ps[i]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tLine[] ls = new Line[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tls[i] = new Line(ps[i], ps[(i + 1) % 3]);\n\t\t\t\tdouble dis = ls[i].disToPoint(ps[3]);\n\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t\tmin = Math.min(min, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[3]).ep(ls[i]);\n\t\t\t}\n\t\t\tif (r < min) {\n\t\t\t\tif (eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0 || eps[0] < 0\n\t\t\t\t\t\t&& eps[1] < 0 && eps[2] < 0)\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t} else {\n\t\t\t\tif (max < r)\n\t\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\t\n\t\t\tif(x1 == 0 && y1 == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\tfinal int x3 = sc.nextInt();\n\t\t\tfinal int y3 = sc.nextInt();\n\t\t\t\n\t\t\tPoint2D[][] lines = new Point2D[][]{\n\t\t\t\t{new Point2D(x1, y1), new Point2D(x2, y2)},\n\t\t\t\t{new Point2D(x2, y2), new Point2D(x3, y3)},\n\t\t\t\t{new Point2D(x3, y3), new Point2D(x1, y1)}\n\t\t\t};\n\t\t\t\n\t\t\tfinal int r_x = sc.nextInt();\n\t\t\tfinal int r_y = sc.nextInt();\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tPoint2D circle = new Point2D(r_x, r_y);\n\t\t\t\n\t\t\tboolean circle_flag = true;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tif(circle.dist(lines[i][0]) > r){\n\t\t\t\t\tcircle_flag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(circle_flag){\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tboolean intersect = true;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tPoint2D[] ret = new Point2D[2];\n\t\t\t\tcircle.interpoint_lc(lines[i][0], lines[i][1], circle, r, ret);\n\t\t\t\t\n\t\t\t\t//System.out.println(Arrays.toString(ret));\n\t\t\t\t\n\t\t\t\tif(ret[0] == null && ret[1] == null){\n\t\t\t\t\tintersect = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(intersect){\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdouble area = circle.area(lines[0][0], lines[1][0], lines[2][0]);\n\t\t\tdouble sum = Math.abs(lines[0][0].cross(lines[1][0]) + lines[1][0].cross(lines[2][0]));\n\t\t\t//System.out.println(area + \" \" + sum);\n\t\t\t\n\t\t\tif(area >= sum){\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\tpublic static class Point2D {\n\t\tpublic double x;\n\t\tpublic double y;\n\n\t\tpublic static final double EPS = 1e-9;\n\n\t\tpublic Point2D(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic Point2D(Point2D point) {\n\t\t\tthis.x = point.x;\n\t\t\tthis.y = point.y;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \",\" + y;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Point2D) {\n\t\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\t\n\t\t\t\tif(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic Point2D add(double x, double y) {\n\t\t\treturn new Point2D(this.x + x, this.y + y);\n\t\t}\n\n\t\tpublic Point2D sub(double x, double y) {\n\t\t\treturn add(-x, -y);\n\t\t}\n\n\t\tpublic Point2D add(Point2D another) {\n\t\t\treturn add(another.x, another.y);\n\t\t}\n\n\t\tpublic Point2D sub(Point2D another) {\n\t\t\treturn sub(another.x, another.y);\n\t\t}\n\n\t\tpublic Point2D mul(double d) {\n\t\t\treturn new Point2D(this.x * d, this.y * d);\n\t\t}\n\n\t\tpublic Point2D div(double d) {\n\t\t\treturn new Point2D(this.x / d, this.y / d);\n\t\t}\n\n\t\tpublic double dot(double x, double y) {\n\t\t\treturn this.x * x + this.y * y;\n\t\t}\n\n\t\tpublic double dot(Point2D another) {\n\t\t\treturn dot(another.x, another.y);\n\t\t}\n\n\t\tpublic double cross(double x, double y) {\n\t\t\treturn this.x * y - this.y * x;\n\t\t}\n\n\t\tpublic double cross(Point2D another) {\n\t\t\treturn cross(another.x, another.y);\n\t\t}\n\n\t\tpublic double dist(double x, double y) {\n\t\t\treturn Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n\t\t\t\t\t* (this.y - y));\n\t\t}\n\n\t\tpublic double dist(Point2D another) {\n\t\t\treturn dist(another.x, another.y);\n\t\t}\n\n\t\tpublic double dist_o() {\n\t\t\treturn dist(0, 0);\n\t\t}\n\n\t\tpublic Point2D unit() {\n\t\t\treturn div(dist_o());\n\t\t}\n\n\t\tpublic boolean pol(Point2D start, Point2D end) {\n\t\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t\t}\n\n\t\tpublic boolean pos(Point2D start, Point2D end) {\n\t\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t\t}\n\n\t\tpublic double pld(Point2D start, Point2D end) {\n\t\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t\t/ end.sub(start).dist_o());\n\t\t}\n\n\t\tpublic double psd(Point2D start, Point2D end) {\n\t\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\t\treturn this.dist(start);\n\t\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\t\treturn this.dist(end);\n\t\t\t} else {\n\t\t\t\treturn Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static int signum(double x){\n\t\t\treturn Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n\t\t}\n\t\t\n\t\tpublic static boolean eq(double x, double y){\n\t\t\treturn signum(x - y) == 0;\n\t\t}\n\t\t\n\t\tpublic static int ccw(Point2D p, Point2D r, Point2D s){\n\t\t\tPoint2D a = r.sub(p);\n\t\t\tPoint2D b = s.sub(p);\n\t\t\t\n\t\t\tfinal int sgn = Point2D.signum(a.cross(b));\n\t\t\tif(sgn != 0){\n\t\t\t\treturn sgn;\n\t\t\t}else if(a.x * b.x < -EPS && a.y * b.y < -EPS){\n\t\t\t\treturn -1;\n\t\t\t}else if(a.dist_o() < b.dist_o() - EPS){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\t\tPoint2D b2) {\n\t\t\treturn (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n\t\t\t\t\t&& (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n\t\t}\n\n\t\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\t\tPoint2D b2) {\n\t\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t\t}\n\n\t\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\t\tPoint2D b2) {\n\t\t\tPoint2D b = b2.sub(b1);\n\t\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\t\treturn a1.add(v);\n\t\t}\n\n\t\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\t\tPoint2D b2) {\n\t\t\tPoint2D a = a2.sub(a1);\n\t\t\tPoint2D b = b2.sub(b1);\n\t\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\t\tPoint2D v = a.mul(t);\n\t\t\treturn a1.add(v);\n\t\t}\n\n\t\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\t\tdouble r2) {\n\t\t\tdouble dis = p1.dist(p2);\n\n\t\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\t\treturn new Point2D[0]; // same\n\t\t\t}\n\n\t\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\t\tret[0] = p1.add(tmp);\n\t\t\t\treturn ret;\n\t\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\t\treturn new Point2D[0]; // out\n\t\t\t}\n\n\t\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\t\tPoint2D tmp = null;\n\t\t\t\tif (r1 > r2) {\n\t\t\t\t\ttmp = p2.sub(p1);\n\t\t\t\t} else {\n\t\t\t\t\ttmp = p1.sub(p2);\n\t\t\t\t}\n\n\t\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\t\tret[0] = p1.add(tmp);\n\t\t\t\treturn ret;\n\t\t\t} else if (dis_m + EPS > dis) {\n\t\t\t\treturn new Point2D[0]; // inner\n\t\t\t} else {\n\t\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t\t/ (2 * dis * r1));\n\t\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n\t\t\tif(Point2D.intersect_s(start1, end1, start2, end2)){\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t\treturn Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\t\tPoint2D ans[]) {\n\t\t\tif (c.pld(start, end) > r + EPS)\n\t\t\t\treturn;\n\t\t\tPoint2D v = end.sub(start).unit();\n\t\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\t\tdouble t = -v.dot(start.sub(c));\n\t\t\tdouble s = Math.sqrt(delta);\n\t\t\tans[0] = start.add(v.mul(t + s));\n\t\t\tans[1] = start.add(v.mul(t + s));\n\t\t}\n\n\t\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\t\tPoint2D v = b.sub(a).unit();\n\t\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t\t(-1) * v.y, v.x);\n\t\t\treturn v.mul(p.pld(a, b));\n\t\t}\n\n\t\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tLine[] ls = new Line[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tls[i] = new Line(ps[i], ps[(i + 1) % 3]);\n\t\t\t\tdouble dis = ls[i].disToPoint(ps[3]);\n\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t\tmin = Math.min(min, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[3]).ep(ls[i]);\n\t\t\t}\n\t\t\tif (r < min) {\n\t\t\t\tif (eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0 || eps[0] < 0\n\t\t\t\t\t\t&& eps[1] < 0 && eps[2] < 0)\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t} else if (r > min) {\n\t\t\t\tif (max < r)\n\t\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t} else\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Triangle and Circle\npublic class Main{\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tpublic static double distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tpublic static boolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tpublic static int ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static Point proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tpublic static double inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static final double EPS = 1.0e-8;\n\tpublic static double norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint pp = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tif(pp.x==0&&pp.y==0)break;\n\t\t\tPoint[] p = new Point[3];\n\t\t\tp[0]=pp;\n\t\t\tfor(int i=1;i<3;i++)p[i]=new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tPoint c = new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tdouble r = sc.nextDouble();\n\t\t\tboolean isB = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tif(!(Math.pow(c.x-p[i].x, 2)+Math.pow(c.y-p[i].y, 2)<=r*r))isB = false;\n\t\t\t}\n\t\t\tif(isB){\n\t\t\t\tSystem.out.println(\"b\");continue;\n\t\t\t}\n\t\t\tboolean left = true;\n\t\t\tboolean right = true;\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble max = 0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble ex = extp(sub(p[(i+1)%3], p[i]), sub(c, p[i]));\n\t\t\t\tif(ex < 0)left = false;\n\t\t\t\telse if(ex > 0)right = false;\n\t\t\t\tLine l = new Line(p[i], p[(i+1)%3]);\n\t\t\t\t//tü«Ìüªàl¦È¢ÆÊçÈ¢ AOJ0129QÆ\n\t\t\t\tLine m = new Line(p[(i+1)%3], p[i]);\n\t\t\t\tdouble d = Math.max(distanceSP(l, c), distanceSP(m, c));\n\t\t\t\tmin = Math.min(min, d);\n\t\t\t\tmax = Math.max(max, d);\n\t\t\t}\n\t\t\tboolean in = left|right;\n\t\t\tif(in && min >= r)System.out.println(\"a\");\n\t\t\telse if(!in && min > r)System.out.println(\"d\");\n\t\t\telse System.out.println(\"c\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.*;\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tIN:while(true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tdouble minx = x1;\n\t\t\tdouble maxx = x1;\n\t\t\tdouble miny = y1;\n\t\t\tdouble maxy = y1;\n\t\t\tPoint2D.Double p1 = new Point2D.Double(x1, y1);\n\t\t\tif(x1 == 0 && y1 == 0) break;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tminx = Math.min(x2, minx);\n\t\t\tminy = Math.min(y2, miny);\n\t\t\tmaxx = Math.max(x2, maxx);\n\t\t\tmaxy = Math.max(y2, maxy);\n\t\t\tPoint2D.Double p2 = new Point2D.Double(x2, y2);\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tminx = Math.min(x3, minx);\n\t\t\tminy = Math.min(y3, miny);\n\t\t\tmaxx = Math.max(x3, maxx);\n\t\t\tmaxy = Math.max(y3, maxy);\n\t\t\tPoint2D.Double p3 = new Point2D.Double(x3, y3);\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tminx = Math.min(x4, minx);\n\t\t\tminy = Math.min(y4, miny);\n\t\t\tmaxx = Math.max(x4, maxx);\n\t\t\tmaxy = Math.max(y4, maxy);\n\t\t\tPoint2D.Double p4 = new Point2D.Double(x4, y4);\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tLine2D.Double a = new Line2D.Double(p1,p2);\n\t\t\tLine2D.Double b = new Line2D.Double(p1,p3);\n\t\t\tLine2D.Double c = new Line2D.Double(p2,p3);\n\t\t\t\n\t\t\tif(p1.distance(p4) <= r && p2.distance(p4) <= r && p3.distance(p4) <= r) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue IN;\n\t\t\t}\n\t\t\telse if(a.ptSegDist(p4) >= r && b.ptSegDist(p4) >= r && c.ptSegDist(p4) >= r) {\n\n\t\t\t\tLine2D.Double da = new Line2D.Double(p1,p4);\n                Line2D.Double db = new Line2D.Double(p2,p4);\n                Line2D.Double dc = new Line2D.Double(p3,p4);\n                if(minx<x4 && x4<maxx && miny<y4 && y4<maxy && !a.intersectsLine(da) && !b.intersectsLine(db) && !c.intersectsLine(dc)){\n                    System.out.println(\"a\");\n                }\n                else {\n                    if(a.ptSegDist(p4) == r || b.ptSegDist(p4) == r || c.ptSegDist(p4) == r) {\n                        System.out.println(\"c\");\n                    }\n                    else{\n                        System.out.println(\"d\");\n                    }\n                }\n            }\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.IOException;\n\npublic class Main {\n\t/**\n\t * @param args\n\t */\n\tstatic class Line extends Line2D.Double {\n\t\tpublic Line(int[] p1, int[] p2) {\n\t\t\tsuper(p1[0], p1[1], p2[0], p2[1]);\n\t\t}\n\t}\n\n\tstatic class Shape {\n\t\tpublic\tint\tx = 0;\n\t\tpublic\tint\ty = 0;\n\t\tpublic\tint\tr = 0;\n\n\t\tpublic Shape(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic Shape(int x, int y, int r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[][]\td = null;\n\n\t\twhile((d = inp()) != null) {\n\t\t\tsolve(d);\n\t\t}\n\t}\n\n\tprivate static void solve(int[][] d) {\n\t\t{\n\t\t\tint\trr = (d[3][2]*d[3][2]);\n\t\t\tint\td0 = distPow(d[3], d[0]);\n\t\t\tint\td1 = distPow(d[3], d[1]);\n\t\t\tint\td2 = distPow(d[3], d[2]);\n\n\t\t\tif (d0 <= rr && d1 <= rr && d2 <= rr) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tint\t\tn1 = crossSign(d[0], d[1], d[3]);\n\t\t\tint\t\tn2 = crossSign(d[1], d[2], d[3]);\n\t\t\tint\t\tn3 = crossSign(d[2], d[0], d[3]);\n\t\t\tLine\tl1 = new Line(d[0], d[1]);\n\t\t\tLine\tl2 = new Line(d[1], d[2]);\n\t\t\tLine\tl3 = new Line(d[2], d[0]);\n\t\t\tdouble\tdr = (double)d[3][2];\n\t\t\tdouble\ts1 = l1.ptSegDist(d[3][0], d[3][1]);\n\t\t\tdouble\ts2 = l2.ptSegDist(d[3][0], d[3][1]);\n\t\t\tdouble\ts3 = l3.ptSegDist(d[3][0], d[3][1]);\n\n\t\t\tif ((n1 == n2) && (n2 == n3)) {\n\t\t\t\tif (s1 >= dr && s2 >= dr && s3 >= dr) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (s1 > dr && s2 > dr && s3 > dr) {\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static int distPow(int[] p1, int[] p2) {\n\t\treturn (p1[0]-p2[0])*(p1[0]-p2[0])+(p1[1]-p2[1])*(p1[1]-p2[1]);\n\t}\n\n\tprivate static int crossSign(int[] p1, int[] p2, int[] p3) {\n\t\tint[]\tvab = { p2[0]-p1[0], p2[1]-p1[1] };\n\t\tint[]\tvap = { p3[0]-p1[0], p3[1]-p1[1] };\n\t\tint\t\tsgn = cross(vab, vap);\n\t\treturn (sgn==0)?0:((sgn>0)?1:-1);\n\t}\n\n\tprivate static int cross(int[] va, int[] vb) {\n\t\treturn va[0]*vb[1]-va[1]*vb[0];   // x1*x2 + y1*y2\n\t}\n\n\tprivate static int[][] inp() {\n\t\tint[][]\td = new int[4][];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i < 3) {\n\t\t\t\tint[]\tp = { parseNum(), parseNum() };\n\t\t\t\tif (p[0] == 0 && p[1] == 0) return null;\n\t\t\t\td[i] = p;\n\t\t\t} else {\n\t\t\t\tint[]\tp = { parseNum(), parseNum(), parseNum() };\n\t\t\t\td[i] = p;\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = 0;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n\n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if ((skp == 0 || buf == -1) && buf != '.') {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic int space(Point a, Point b, Point c){\n\t\treturn (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);\n\t}\n\tpublic double dist(Point a, Point b){\n\t\treturn Math.sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n\t}\n\tpublic double dist(Point a, Point b, Point c){\n\t\treturn Math.abs(space(a, b, c) / dist(a, b));\n\t}\n\tpublic boolean inOrOut(Triangle tr, Point p){\n\t\tdouble key = Math.signum(space(tr.a, tr.b, p)) + Math.signum(space(tr.b, tr.c, p)) + Math.signum(space(tr.c, tr.a, p));\n\t\treturn (Math.abs(key) == 3);\n\t}\n\tpublic boolean crossOrNot(Point a, Point b, Circle c){\n\t\tif( dist(a, b, c.p) > c.r ){\n\t\t\treturn true;\n\t\t}\n\t\tif( Math.min(dist(a, c.p), dist(b, c.p)) <= c.r ){\n\t\t\treturn false;\n\t\t}\n\t\tdouble l = Math.max(dist(a, c.p), dist(b, c.p));\n\t\tdouble d = dist(a, b, c.p);\n\t\tif( Math.sqrt(l*l - d*d) > dist(a, b) ){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\t\t\n\tpublic void relation(Triangle tr, Circle c){\n\t\tif( dist(tr.a, c.p) <= c.r && dist(tr.b, c.p) <= c.r && dist(tr.c, c.p) <= c.r ){\n\t\t\twriter.println(\"b\");\n\t\t} else if( inOrOut(tr, c.p) && (dist(tr.a, tr.b, c.p) >= c.r && dist(tr.b, tr.c, c.p) >= c.r && dist(tr.c, tr.a, c.p) >= c.r) ){\n\t\t\twriter.println(\"a\");\n\t\t} else if( crossOrNot(tr.a, tr.b, c) && crossOrNot(tr.b, tr.c, c) && crossOrNot(tr.c, tr.a, c) ){\n\t\t\twriter.println(\"d\");\n\t\t} else {\n\t\t\twriter.println(\"c\");\n\t\t}\n\t\treturn;\n\t}\n\t\t\t\n\tpublic void solve() throws IOException{\n\t\tint n, m;\n\t\twhile( (n = nextInt()) != 0 | (m = nextInt()) != 0 ){\n\t\t\tint p = nextInt(), q = nextInt(), r = nextInt(), s = nextInt();\n\t\t\tTriangle tr = new Triangle(n, m, p, q, r, s);\n\t\t\tint x = nextInt(), y = nextInt(), z = nextInt();\n\t\t\tCircle c = new Circle(x, y, z);\n\t\t\trelation(tr, c);\n\t\t}\n\t}\t\t\t\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}\n\nclass Triangle{\n\tPoint a;\n\tPoint b;\n\tPoint c;\n\tTriangle(int p, int q, int r, int s, int t, int u){\n\t\ta = new Point(p, q);\n\t\tb = new Point(r, s);\n\t\tc = new Point(t, u);\n\t}\n}\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\nclass Circle{\n\tPoint p;\n\tint r;\n\tCircle(int x, int y, int r){\n\t\tp = new Point(x, y);\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n \npublic class Main {\n     \n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n \n        while (true) {\n            final int x1 = sc.nextInt();\n            final int y1 = sc.nextInt();\n             \n            if(x1 == 0 && y1 == 0){\n                break;\n            }\n             \n            final int x2 = sc.nextInt();\n            final int y2 = sc.nextInt();\n            final int x3 = sc.nextInt();\n            final int y3 = sc.nextInt();\n             \n            Point2D[][] lines = new Point2D[][]{\n                {new Point2D(x1, y1), new Point2D(x2, y2)},\n                {new Point2D(x2, y2), new Point2D(x3, y3)},\n                {new Point2D(x3, y3), new Point2D(x1, y1)}\n            };\n             \n            final int r_x = sc.nextInt();\n            final int r_y = sc.nextInt();\n            final int r = sc.nextInt();\n             \n            Point2D circle = new Point2D(r_x, r_y);\n            \n            double min_line_dist = Double.MAX_VALUE;\n            double max_pt_dist = Double.MIN_VALUE;\n            for(int i = 0; i < 3; i++){\n                max_pt_dist = Math.max(max_pt_dist, circle.dist(lines[i][0]));\n                min_line_dist = Math.min(min_line_dist, circle.psd(lines[i][0], lines[i][1]));\n                \n            }\n            \n            if(max_pt_dist <= r){\n            \tSystem.out.println(\"b\");\n            \tcontinue;\n            }\n            \n            double[] cross = new double[3];\n            for(int i = 0; i < 3; i++){\n            \tfor(int j = 0; j < 2; j++){\n            \t\tlines[i][j] = lines[i][j].sub(circle);\n            \t}\n            }\n            \n            for(int i = 0; i < 3; i++){\n            \tcross[i] = lines[i][0].cross(lines[i][1]);\n            \t//System.out.println(cross[i]);\n            }\n             \n            \n            if(cross[0] < 0 && cross[1] < 0 && cross[2] < 0 || cross[0] > 0 && cross[1] > 0 && cross[2] > 0){\n            \tif(min_line_dist < r){\n            \t\tSystem.out.println(\"c\");\n            \t}else{\n            \t\tSystem.out.println(\"a\");\n            \t}\n            }else{\n            \tif(min_line_dist <= r){\n            \t\tSystem.out.println(\"c\");\n            \t}else{\n            \t\tSystem.out.println(\"d\");\n            \t}\n            } \n        }\n    }\n     \n    public static class Point2D {\n        public double x;\n        public double y;\n \n        public static final double EPS = 1e-9;\n \n        public Point2D(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n \n        public Point2D(Point2D point) {\n            this.x = point.x;\n            this.y = point.y;\n        }\n \n        public String toString() {\n            return x + \",\" + y;\n        }\n \n        @Override\n        public boolean equals(Object o) {\n            if (o instanceof Point2D) {\n                Point2D another = (Point2D) o;\n                 \n                if(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n                    return true;\n                }\n                 \n                return false;\n            }\n            return false;\n        }\n \n        public Point2D add(double x, double y) {\n            return new Point2D(this.x + x, this.y + y);\n        }\n \n        public Point2D sub(double x, double y) {\n            return add(-x, -y);\n        }\n \n        public Point2D add(Point2D another) {\n            return add(another.x, another.y);\n        }\n \n        public Point2D sub(Point2D another) {\n            return sub(another.x, another.y);\n        }\n \n        public Point2D mul(double d) {\n            return new Point2D(this.x * d, this.y * d);\n        }\n \n        public Point2D div(double d) {\n            return new Point2D(this.x / d, this.y / d);\n        }\n \n        public double dot(double x, double y) {\n            return this.x * x + this.y * y;\n        }\n \n        public double dot(Point2D another) {\n            return dot(another.x, another.y);\n        }\n \n        public double cross(double x, double y) {\n            return this.x * y - this.y * x;\n        }\n \n        public double cross(Point2D another) {\n            return cross(another.x, another.y);\n        }\n \n        public double dist(double x, double y) {\n            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                    * (this.y - y));\n        }\n \n        public double dist(Point2D another) {\n            return dist(another.x, another.y);\n        }\n \n        public double dist_o() {\n            return dist(0, 0);\n        }\n \n        public Point2D unit() {\n            return div(dist_o());\n        }\n \n        public boolean pol(Point2D start, Point2D end) {\n            return end.sub(start).cross(this.sub(start)) < EPS;\n        }\n \n        public boolean pos(Point2D start, Point2D end) {\n            return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n        }\n \n        public double pld(Point2D start, Point2D end) {\n            return Math.abs((end.sub(start).cross(this.sub(start)))\n                    / end.sub(start).dist_o());\n        }\n \n        public double psd(Point2D start, Point2D end) {\n            if (end.sub(start).dot(this.sub(start)) < EPS) {\n                return this.dist(start);\n            } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n                return this.dist(end);\n            } else {\n                return Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n            }\n        }\n         \n        public static int signum(double x){\n            return Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n        }\n         \n        public static boolean eq(double x, double y){\n            return signum(x - y) == 0;\n        }\n         \n        public static int ccw(Point2D p, Point2D r, Point2D s){\n            Point2D a = r.sub(p);\n            Point2D b = s.sub(p);\n             \n            final int sgn = Point2D.signum(a.cross(b));\n            if(sgn != 0){\n                return sgn;\n            }else if(a.x * b.x < -EPS && a.y * b.y < -EPS){\n                return -1;\n            }else if(a.dist_o() < b.dist_o() - EPS){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n         \n        public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            return (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n                    && (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n        }\n \n        public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n        }\n \n        public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            Point2D b = b2.sub(b1);\n            double d1 = Math.abs(b.cross(a1.sub(b1)));\n            double d2 = Math.abs(b.cross(a2.sub(b1)));\n            double t = d1 / (d1 + d2);\n            Point2D a = a2.sub(a1), v = a.mul(t);\n            return a1.add(v);\n        }\n \n        public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            Point2D a = a2.sub(a1);\n            Point2D b = b2.sub(b1);\n            double t = b.cross(b1.sub(a1)) / b.cross(a);\n            Point2D v = a.mul(t);\n            return a1.add(v);\n        }\n \n        public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n                double r2) {\n            double dis = p1.dist(p2);\n \n            if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n                return new Point2D[0]; // same\n            }\n \n            if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n                Point2D tmp = p2.sub(p1);\n                tmp = tmp.mul(r1 / tmp.dist_o());\n                Point2D ret[] = new Point2D[1];\n                ret[0] = p1.add(tmp);\n                return ret;\n            } else if (dis + EPS > r1 + r2) {\n                return new Point2D[0]; // out\n            }\n \n            double dis_m = Math.abs(r1 - r2);\n \n            if (dis_m + EPS > dis && dis_m - EPS < dis) {\n                Point2D tmp = null;\n                if (r1 > r2) {\n                    tmp = p2.sub(p1);\n                } else {\n                    tmp = p1.sub(p2);\n                }\n \n                double min = Math.min(r1, r2);\n \n                tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n                Point2D ret[] = new Point2D[1];\n                ret[0] = p1.add(tmp);\n                return ret;\n            } else if (dis_m + EPS > dis) {\n                return new Point2D[0]; // inner\n            } else {\n                Point2D ret[] = new Point2D[2];\n \n                double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                        / (2 * dis * r1));\n                double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n                ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                        * Math.sin(a + theta) + p1.y);\n                ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                        * Math.sin(a - theta) + p1.y);\n                return ret;\n            }\n        }\n         \n        public static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n            if(Point2D.intersect_s(start1, end1, start2, end2)){\n                return 0;\n            }else{\n                return Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n            }\n        }\n         \n        public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n                Point2D ans[]) {\n            if (c.pld(start, end) > r + EPS)\n                return;\n            Point2D v = end.sub(start).unit();\n            double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                    - start.dist(c) * start.dist(c) + r * r;\n            double t = -v.dot(start.sub(c));\n            double s = Math.sqrt(delta);\n            ans[0] = start.add(v.mul(t + s));\n            ans[1] = start.add(v.mul(t + s));\n        }\n        \n        public void interpoint_sc(Point2D start, Point2D end, Point2D c, double r,\n                Point2D ans[]) {\n            if (c.psd(start, end) > r + EPS)\n                return;\n            Point2D v = end.sub(start).unit();\n            double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                    - start.dist(c) * start.dist(c) + r * r;\n            double t = -v.dot(start.sub(c));\n            double s = Math.sqrt(delta);\n            ans[0] = start.add(v.mul(t + s));\n            ans[1] = start.add(v.mul(t + s));\n        }\n        \n        public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n            Point2D v = b.sub(a).unit();\n            v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                    (-1) * v.y, v.x);\n            return v.mul(p.pld(a, b));\n        }\n \n        public double area(Point2D a, Point2D b, Point2D c) {\n            return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n        }\n \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x, y;\n\t\t\n\t\tpublic Vector(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tpublic double norm(){\n\t\t\treturn Math.hypot(x, y);\n\t\t}\n\t\t\n\t\tpublic double sqrNorm(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\t\n\t\tpublic double ip(Vector v){\n\t\t\treturn x*v.x+y*v.y;\n\t\t}\n\t\t\n\t\tpublic Vector add(Vector v){\n\t\t\treturn new Vector(x+v.x, y+v.y);\n\t\t}\n\t\t\n\t\tpublic Vector subtract(Vector v){\n\t\t\treturn new Vector(x-v.x, y-v.y);\n\t\t}\n\t\t\n\t\tpublic Vector multiply(double a){\n\t\t\treturn new Vector(x*a, y*a);\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn String.format(\"(%5f,%5f)\", x, y);\n\t\t}\n\t}\n\t\n\tboolean inTriangle(Vector[] v){\n\t\tdouble theta=0;\n\t\tfor(int i=0;i<3;++i){\n\t\t\ttheta+=Math.acos(v[i].ip(v[(i+1)%3])/v[i].norm()/v[(i+1)%3].norm());\n\t\t}\n\t\treturn theta>=Math.PI*2-1e-7;\n\t}\n\t\n\tchar solve(Vector[] a, Vector p, double r){\n\t\tVector[] v=new Vector[3], e=new Vector[3];\n\t\tr*=r;\n\t\t\n\t\tboolean isB=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tv[i]=a[i].subtract(p);\n\t\t\te[i]=a[(i+1)%3].subtract(a[i]);\n\t\t\tisB&=v[i].sqrNorm()<r;\n\t\t}\n\t\tif(isB) return 'b';\n\t\t\n\t\tVector[] h=new Vector[3];\n\t\tboolean isA=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\t//点pより三角形の辺と直交するvector\n\t\t\t//hi=vi+(ei・(-vi)/|ei|^2)ei\n\t\t\th[i]=v[i].subtract(e[i].multiply(e[i].ip(v[i])/e[i].sqrNorm()));\n\t\t\tisA&=h[i].sqrNorm()>r;\n\t\t}\n\t\t//debug(h);\n\t\t\n\t\tif(isA&&inTriangle(v)) return 'a';\n\t\t\n\t\tboolean isC=false;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tVector n=h[i].add(p);\n\t\t//\tdebug(n,n.subtract(a[i]).ip(n.subtract(a[(i+1)%3])));\n\t\t\tif(v[i].sqrNorm()<r||(n.subtract(a[i]).ip(n.subtract(a[(i+1)%3]))<=0&&h[i].sqrNorm()<r)){\n\t\t\t\tisC=true;\n\t\t\t}\n\t\t}\n\t\tif(isC) return 'c';\n\t\telse return 'd';\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x=ni(),y=ni();\n\t\t\tif(x==0&y==0)break;\n\t\t\t\n\t\t\tVector[] a=new Vector[3];\n\t\t\t\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\ta[i]=new Vector(x, y);\n\t\t\t\tx=ni(); y=ni();\n\t\t\t}\n\t\t\tVector p=new Vector(x, y);\n\t\t\tdouble r=ni();\n\t\t\t\n\t\t\tSystem.out.println(solve(a,p,r));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\n/**\n * AOJ id=0153\n * Triangle and Circle\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint[] x = new int[3];\n\t\t\tint[] y = new int[3];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tif(i==0 && x[i]==0 && y[i]==0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tint rx = sc.nextInt();\n\t\t\tint ry = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(solve(x, y, rx, ry, r));\n\t\t}\n\t}\n\n\tprivate String solve(int[] x, int[] y, int rx, int ry, int r) {\n\t\tint[] vx = new int[3];\n\t\tint[] vy = new int[3];\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tvx[i] = x[(i+1)%3]-x[i];\n\t\t\tvy[i] = y[(i+1)%3]-y[i];\n\t\t}\n\t\t\n\t\tint inCircle = 0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint xd = (x[i]-rx)*(x[i]-rx);\n\t\t\tint yd = (y[i]-ry)*(y[i]-ry);\n\t\t\t\n\t\t\tif(r*r >= xd+yd)\n\t\t\t\tinCircle++;\n\t\t}\n\t\t\n\t\tif(inCircle==3)\n\t\t\treturn \"b\";\n\t\telse if(inCircle==1 || inCircle==2)\n\t\t\treturn \"c\";\n\t\t\n\t\tint l=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(vx[i]*(ry-y[i])-(rx-x[i])*vy[i]<0)\n\t\t\t\tl++;\n\t\t}\n\t\tif(l==3 || l==0)\n\t\t\treturn \"a\";\n\t\telse\n\t\t\treturn \"d\";\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * AOJ id=0153\n * Triangle and Circle\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint[] x = new int[3];\n\t\t\tint[] y = new int[3];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tif(i==0 && x[i]==0 && y[i]==0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tint rx = sc.nextInt();\n\t\t\tint ry = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(solve(x, y, rx, ry, r));\n\t\t}\n\t}\n\n\tprivate String solve(int[] x, int[] y, int rx, int ry, int r) {\n\t\tint[] vx = new int[3];\n\t\tint[] vy = new int[3];\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tvx[i] = x[(i+1)%3]-x[i];\n\t\t\tvy[i] = y[(i+1)%3]-y[i];\n\t\t}\n\t\t\n\t\tint inCircle = 0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint xd = (x[i]-rx)*(x[i]-rx);\n\t\t\tint yd = (y[i]-ry)*(y[i]-ry);\n\t\t\tif(r*r >= xd+yd)\n\t\t\t\tinCircle++;\n\t\t}\n\t\tif(inCircle==3)\n\t\t\treturn \"b\";\n//\t\telse if(inCircle==1 || inCircle==2)\n//\t\t\t// 接している場合は三角形の中に円がはいっている可能性がある？\n//\t\t\treturn \"c\";\n\t\t\n\t\tif(inCircle==0){\n\t\t\tint l=0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tif(vx[i]*(ry-y[i])-(rx-x[i])*vy[i]<0)\n\t\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(l==3 || l==0)\n\t\t\t\treturn \"a\";\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint vrx = rx-x[i];\n\t\t\tint vry = ry-y[i];\n\t\t\t\n\t\t\tint inp = vx[i]*vrx+vy[i]*vry;\n\t\t\tif(inp<0){\n\t\t\t\tif(vrx*vrx+vry*vry < r*r)\n\t\t\t\t\treturn \"c\";\n\t\t\t}else{\n\t\t\t\tif(inp > vx[i]*vx[i]+vy[i]*vy[i]){\n\t\t\t\t\tif((rx-x[(i+1)%3])*(rx-x[(i+1)%3])+(ry-y[(i+1)%3])*(ry-y[(i+1)%3]) <r*r)\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t}else{\n\t\t\t\t\tif(vrx*vrx+vry*vry-inp*inp < (long)(vx[i]*vx[i]+vy[i]*vy[i])*r*r){\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn \"d\";\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r * r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[3]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Triangle and Circle\npublic class Main{\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tpublic static double distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tpublic static boolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tpublic static int ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static Point proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tpublic static double inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static final double EPS = 1.0e-8;\n\tpublic static double norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint pp = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tif(pp.x==0&&pp.y==0)break;\n\t\t\tPoint[] p = new Point[3];\n\t\t\tp[0]=pp;\n\t\t\tfor(int i=1;i<3;i++)p[i]=new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tPoint c = new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tdouble r = sc.nextDouble();\n\t\t\tboolean isB = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tif(!(Math.pow(c.x-p[i].x, 2)+Math.pow(c.y-p[i].y, 2)<=r*r))isB = false;\n\t\t\t}\n\t\t\tif(isB){\n\t\t\t\tSystem.out.println(\"b\");continue;\n\t\t\t}\n\t\t\tboolean left = true;\n\t\t\tboolean right = true;\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble max = 0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble ex = extp(sub(p[(i+1)%3], p[i]), sub(c, p[i]));\n\t\t\t\tif(ex <= 0)left = false;\n\t\t\t\tif(ex >= 0)right = false;\n\t\t\t\tLine l = new Line(p[i], p[(i+1)%3]);\n\t\t\t\tdouble d = distanceSP(l, c);\n\t\t\t\tmin = Math.min(min, d);\n\t\t\t\tmax = Math.max(max, d);\n\t\t\t}\n\t\t\tboolean in = left|right;\n\t\t\tif(in && min >= r)System.out.println(\"a\");\n\t\t\telse if(!in && min >= r)System.out.println(\"d\");\n\t\t\telse System.out.println(\"c\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Triangle and Circle\npublic class Main {\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tpublic static double distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tpublic static boolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tpublic static int ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static Point proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tpublic static double inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static final double EPS = 1.0e-8;\n\tpublic static double norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint pp = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tif(pp.x==0&&pp.y==0)break;\n\t\t\tPoint[] p = new Point[3];\n\t\t\tp[0]=pp;\n\t\t\tfor(int i=1;i<3;i++)p[i]=new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tPoint c = new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tdouble r = sc.nextDouble();\n\t\t\tboolean isB = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tif(!(Math.pow(c.x-p[i].x, 2)+Math.pow(c.y-p[i].y, 2)<=r*r))isB = false;\n\t\t\t}\n\t\t\tif(isB){\n\t\t\t\tSystem.out.println(\"b\");continue;\n\t\t\t}\n\t\t\tboolean left = true;\n\t\t\tboolean right = true;\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble max = 0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble ex = extp(sub(p[(i+1)%3], p[i]), sub(c, p[i]));\n\t\t\t\tif(ex < 0)left = false;\n\t\t\t\telse if(ex > 0)right = false;\n\t\t\t\tLine l = new Line(p[i], p[(i+1)%3]);\n\t\t\t\t//???????????????????????????????????¨???????????? AOJ0129?????§\n\t\t\t\tLine m = new Line(p[(i+1)%3], p[i]);\n\t\t\t\tdouble d = Math.max(distanceSP(l, c), distanceSP(m, c));\n\t\t\t\tmin = Math.min(min, d);\n\t\t\t\tmax = Math.max(max, d);\n\t\t\t}\n\t\t\tboolean in = left|right;\n\t\t\tif(in && min >= r)System.out.println(\"a\");\n\t\t\telse if(!in && min > r)System.out.println(\"d\");\n\t\t\telse System.out.println(\"c\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tloop: while (true) {\n\t\t\tPoint2D.Double[] points = new Point2D.Double[4];\n\t\t\tint maxx = Integer.MIN_VALUE;\n\t\t\tint maxy = Integer.MIN_VALUE;\n\t\t\tint minx = Integer.MAX_VALUE;\n\t\t\tint miny = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tif (i == 0 && x == 0 && y == 0) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tpoints[i] = new Point2D.Double(x, y);\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tmaxx = Math.max(maxx, x);\n\t\t\t\t\tmaxy = Math.max(maxy, y);\n\t\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble r = scanner.nextDouble();\n\t\t\tLine2D.Double a = new Line2D.Double(points[1], points[2]);\n\t\t\tLine2D.Double b = new Line2D.Double(points[2], points[0]);\n\t\t\tLine2D.Double c = new Line2D.Double(points[0], points[1]);\n\t\t\tEllipse2D.Double circle = new Ellipse2D.Double(points[3].x,\n\t\t\t\t\tpoints[3].y, r * 2, r * 2);\n\t\t\tdouble d0 = points[3].distance(points[0]);\n\t\t\tdouble d1 = points[3].distance(points[1]);\n\t\t\tdouble d2 = points[3].distance(points[2]);\n\t\t\tdouble ap = a.ptSegDist(points[3]);\n\t\t\tdouble bp = b.ptSegDist(points[3]);\n\t\t\tdouble cp = c.ptSegDist(points[3]);\n\n\t\t\tif (d0 <= r && d1 <= r && d2 <= r) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t} else if (ap >= r && bp >= r && cp >= r) {\n\t\t\t\tLine2D.Double da = new Line2D.Double(points[0], points[3]);\n\t\t\t\tLine2D.Double db = new Line2D.Double(points[1], points[3]);\n\t\t\t\tLine2D.Double dc = new Line2D.Double(points[2], points[3]);\n\t\t\t\tdouble x3 = points[3].x;\n\t\t\t\tdouble y3 = points[3].y;\n\t\t\t\tif (minx < x3 && x3 < maxx && miny < y3 && y3 < maxy\n\t\t\t\t\t\t&& !a.intersectsLine(da) && !b.intersectsLine(db)\n\t\t\t\t\t\t&& !c.intersectsLine(dc)) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else {\n\t\t\t\t\tif (ap == r || bp == r || cp == r) {\n\t\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[3]));\n\t\t\t\tif (eps[i] < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (eps[i] > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tloop: while (true) {\n\t\t\tPoint2D.Double[] points = new Point2D.Double[4];\n\t\t\tint maxx = Integer.MIN_VALUE;\n\t\t\tint maxy = Integer.MIN_VALUE;\n\t\t\tint minx = Integer.MAX_VALUE;\n\t\t\tint miny = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tif (i == 0 && x == 0 && y == 0) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tpoints[i] = new Point2D.Double(x, y);\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tmaxx = Math.max(maxx, x);\n\t\t\t\t\tmaxy = Math.max(maxy, y);\n\t\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble r = scanner.nextDouble();\n\t\t\tLine2D.Double a = new Line2D.Double(points[1], points[2]);\n\t\t\tLine2D.Double b = new Line2D.Double(points[2], points[0]);\n\t\t\tLine2D.Double c = new Line2D.Double(points[0], points[1]);\n\t\t\tEllipse2D.Double circle = new Ellipse2D.Double(points[3].x,\n\t\t\t\t\tpoints[3].y, r * 2, r * 2);\n\t\t\tdouble d0 = points[3].distance(points[0]);\n\t\t\tdouble d1 = points[3].distance(points[1]);\n\t\t\tdouble d2 = points[3].distance(points[2]);\n\t\t\tdouble ap = a.ptSegDist(points[3]);\n\t\t\tdouble bp = b.ptSegDist(points[3]);\n\t\t\tdouble cp = c.ptSegDist(points[3]);\n\t\t\tPath2D.Double path = new Path2D.Double();\n\t\t\tpath.moveTo(points[0].x, points[0].y);\n\t\t\tpath.lineTo(points[1].x, points[1].y);\n\t\t\tpath.lineTo(points[2].x, points[2].y);\n\t\t\tif (d0 <= r && d1 <= r && d2 <= r) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t} else if (ap >= r && bp >= r && cp >= r) {\n\t\t\t\tif (path.contains(points[3])) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else {\n\t\t\t\t\tif (ap == r || bp == r || cp == r) {\n\t\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\n\npublic class Main {\n\t/**\n\t * @param args\n\t */\n\tstatic class Shape {\n\t\tpublic\tint\tx = 0;\n\t\tpublic\tint\ty = 0;\n\t\tpublic\tint\tr = 0;\n\n\t\tpublic Shape(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic Shape(int x, int y, int r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tstatic class Line {\n\t\tpublic\tShape\tps = null;\n\t\tpublic\tShape\tpe = null;\n\t\tpublic\tint\t\ta  = 0;\n\t\tpublic\tint\t\tb  = 0;\n\t\tpublic\tint\t\tc  = 0;\n\n\t\tpublic Line(Shape ps, Shape pe) {\n\t\t\tthis.ps = ps;\n\t\t\tthis.pe = pe;\n\t\t\tthis.a  = pe.y-ps.y;\n\t\t\tthis.b  = ps.x-pe.x;\n\t\t\tthis.c  = -(a*ps.x+b*ps.y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tShape[]\ts = null;\n\n\t\twhile((s = inp()) != null) {\n\t\t\tsolve(s[0], s[1], s[2], s[3]);\n\t\t}\n\t}\n\n\tprivate static void solve(Shape p1, Shape p2, Shape p3, Shape c) {\n\t\t{\n\t\t\tint\trr = (c.r*c.r);\n\t\t\tint\td0 = (c.x-p1.x)*(c.x-p1.x)+(c.x-p1.y)*(c.y-p1.y);\n\t\t\tint\td1 = (c.x-p2.x)*(c.x-p2.x)+(c.x-p2.y)*(c.y-p2.y);\n\t\t\tint\td2 = (c.x-p3.x)*(c.x-p3.x)+(c.x-p3.y)*(c.y-p3.y);\n\n\t\t\t// 三角形が円の内部に含まれるか\n\t\t\tif (d0 <= rr && d1 <= rr && d2 <= rr) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tint\t\tn1 = crossSign(p1, p2, c);\n\t\t\tint\t\tn2 = crossSign(p2, p3, c);\n\t\t\tint\t\tn3 = crossSign(p3, p1, c);\n\t\t\tLine\tl1 = new Line(p1, p2);\n\t\t\tLine\tl2 = new Line(p2, p3);\n\t\t\tLine\tl3 = new Line(p3, p1);\n\n\t\t\t// 円の中心が三角形の内部に含まれるか\n\t\t\tif ((n1 == n2) && (n2 == n3)) {\n\t\t\t\tint\tc1 = checkDist(l1, c);\n\t\t\t\tint\tc2 = checkDist(l2, c);\n\t\t\t\tint\tc3 = checkDist(l3, c);\n\n\t\t\t\t// 円が三角形内部に含まれるか\n\t\t\t\tif (c1 <= 0 && c2 <= 0 && c3 <= 0) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 円と線分が交わるか\n\t\t\t\tif (checkCross(l1, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (checkCross(l2, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (checkCross(l2, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(\"d\");\n\t}\n\n\tprivate static boolean checkCross(Line l, Shape c) {\n\t\tdouble\tdl = Math.sqrt(Math.pow(l.pe.x-l.ps.x, 2)+Math.pow(l.pe.y-l.ps.y, 2));\n\t\tdouble\tex = (double)(l.pe.x-l.ps.x)/dl;\n\t\tdouble\tey = (double)(l.pe.y-l.ps.y)/dl;\n\t\tdouble\tvx = -ey;\n\t\tdouble\tvy = ex;\n\t\tdouble\tdk = (double)(-(l.a*c.x+l.b*c.y+l.c))/(((double)l.a)*vx+((double)l.b)*vy);\n\t\tdouble\tsp = (double)(c.r*c.r)-(dk*dk);\n\t\tboolean\trt = false;\n\n\t\tif (sp >= 0) {\n\t\t\tdouble\txp = (double)c.x+dk*vx;\n\t\t\tdouble\typ = (double)c.y+dk*vy;\n\t\t\tdouble\tds = Math.sqrt(sp);\n\t\t\tdouble\tx1 = xp+ds*ex;\n\t\t\tdouble\ty1 = yp+ds*ey;\n\t\t\tdouble\tx2 = xp-ds*ex;\n\t\t\tdouble\ty2 = yp-ds*ey;\n\t\t\tdouble\txs = (double)Math.min(l.ps.x, l.pe.x);\n\t\t\tdouble\txe = (double)Math.max(l.ps.x, l.pe.x);\n\t\t\tdouble\tys = (double)Math.min(l.ps.y, l.pe.y);\n\t\t\tdouble\tye = (double)Math.max(l.ps.y, l.pe.y);\n\n\t\t\tif (xs <= x1 && x1 <= xe && ys <= y1 && y1 <= ye) {\n\t\t\t\trt = true;\n\t\t\t}\n\n\t\t\tif (xs <= x2 && x2 <= xe && ys <= y2 && y2 <= ye) {\n\t\t\t\trt = true;\n\t\t\t}\n\t\t}\n\n\t\treturn rt;\n\t}\n\n\tprivate static int checkDist(Line l, Shape p) {\n\t\tint\ts = p.r*p.r*(l.a*l.a+l.b*l.b);\n\t\tint\tt = (l.a*p.x+l.b*p.y+l.c)*(l.a*p.x+l.b*p.y+l.c);\n\t\treturn (s==t)?0:((s<t)?-1:1);\n\t}\n\n\tprivate static int crossSign(Shape s1, Shape s2, Shape s3) {\n\t\tint[]\tvab = { s2.x-s1.x, s2.y-s1.y };\n\t\tint[]\tvap = { s3.x-s1.x, s3.y-s1.y };\n\t\tint\t\tsgn = cross(vab, vap);\n\t\treturn (sgn==0)?0:((sgn>0)?1:-1);\n\t}\n\n\tprivate static int cross(int[] va, int[] vb) {\n\t\treturn va[0]*vb[1]-va[1]*vb[0];   // x1*x2 + y1*y2\n\t}\n\n\tprivate static Shape[] inp() {\n\t\tShape[]\td = new Shape[4];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i < 3) {\n\t\t\t\tint[]\tp = { parseNum(), parseNum() };\n\t\t\t\tif (p[0] == 0 && p[1] == 0) return null;\n\t\t\t\td[i] = new Shape(p[0], p[1]);\n\t\t\t} else {\n\t\t\t\tint[]\tp = { parseNum(), parseNum(), parseNum() };\n\t\t\t\td[i] = new Shape(p[0], p[1], p[2]);\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = 0;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n\n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if ((skp == 0 || buf == -1) && buf != '.') {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tLine[] ls = new Line[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tls[i] = new Line(ps[i], ps[(i + 1) % 3]);\n\t\t\t\tdouble dis = ls[i].disToPoint(ps[3]);\n\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[3]).ep(ls[i]);\n\t\t\t}\n\t\t\tif (r < min) {\n\t\t\t\tif (eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0 || eps[0] < 0\n\t\t\t\t\t\t&& eps[1] < 0 && eps[2] < 0)\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t} else {\n\t\t\t\tif (max < r)\n\t\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Triangle and Circle\npublic class Main{\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tpublic static double distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tpublic static boolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tpublic static int ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static Point proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tpublic static double inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static final double EPS = 1.0e-8;\n\tpublic static double norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint pp = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tif(pp.x==0&&pp.y==0)break;\n\t\t\tPoint[] p = new Point[3];\n\t\t\tp[0]=pp;\n\t\t\tfor(int i=1;i<3;i++)p[i]=new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tPoint c = new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tdouble r = sc.nextDouble();\n\t\t\tboolean isB = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tif(!(Math.pow(c.x-p[i].x, 2)+Math.pow(c.y-p[i].y, 2)<=r*r))isB = false;\n\t\t\t}\n\t\t\tif(isB){\n\t\t\t\tSystem.out.println(\"b\");continue;\n\t\t\t}\n\t\t\tboolean left = true;\n\t\t\tboolean right = true;\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble max = 0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble ex = extp(sub(p[(i+1)%3], p[i]), sub(c, p[i]));\n\t\t\t\tif(ex < 0)left = false;\n\t\t\t\telse if(ex > 0)right = false;\n\t\t\t\tLine l = new Line(p[i], p[(i+1)%3]);\n\t\t\t\tLine m = new Line(p[(i+1)%3], p[i]);\n\t\t\t\tdouble d = Math.max(distanceSP(l, c), distanceSP(m, c));\n\t\t\t\tmin = Math.min(min, d);\n\t\t\t\tmax = Math.max(max, d);\n\t\t\t}\n\t\t\tboolean in = left|right;\n\t\t\tif(in && min >= r)System.out.println(\"a\");\n\t\t\telse if(!in && min > r)System.out.println(\"d\");\n\t\t\telse System.out.println(\"c\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] x, y;\n\tint cx, cy, r;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tx = new int[3];\n\t\t\ty = new int[3];\n\t\t\tx[0] = sc.nextInt();\n\t\t\ty[0] = sc.nextInt();\n\t\t\tif( (x[0]|y[0]) == 0 ) break;\n\t\t\t\n\t\t\tfor(int i=1;i<3;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\t\t\tcx = sc.nextInt();\n\t\t\tcy = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\t\n\t\t\tif(inCir()) System.out.println(\"b\");\n\t\t\telse {\n\t\t\t\tboolean a = inTri();\n\t\t\t\tboolean b = closs();\n\t\t\t\tif( a&(!b) ) System.out.println(\"a\");\n\t\t\t\telse if(b) System.out.println(\"c\");\n\t\t\t\telse System.out.println(\"d\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean inCir() {\n\t\tfor(int i=0;i<3;i++) if( (cx-x[i])*(cx-x[i])+(cy-y[i])*(cy-y[i]) > r*r )\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\t\n\tboolean inTri(){\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tif (clossLine(new int[]{x[i],x[(i+1)%3]}, new int[]{y[i],y[(i+1)%3]},\n\t\t\t\t\t      new int[]{cx,x[(i+2)%3]}, new int[]{cy,y[(i+2)%3]}) )\n\t\t\t\t\t  return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tboolean clossLine(int[] x1, int[] y1, int[] x2, int[] y2) {\n\t\tint v1 = (y2[0]-y1[0])*(x1[1]-x1[0]) - (y1[1]-y1[0])*(x2[0]-x1[0]);\n\t\tint v2 = (y2[1]-y1[0])*(x1[1]-x1[0]) - (y1[1]-y1[0])*(x2[1]-x1[0]);\n\t\tint v3 = (y1[0]-y2[0])*(x2[1]-x2[0]) - (y2[1]-y2[0])*(x1[0]-x2[0]);\n\t\tint v4 = (y1[1]-y2[0])*(x2[1]-x2[0]) - (y2[1]-y2[0])*(x1[1]-x2[0]);\n\t\tif( ( v1&v2&v3&v4 ) == 0 ) return true;\n\t\tboolean a = v1 > 0 ^ v2 < 0;\n\t\tboolean b = v3 > 0 ^ v4 < 0; \n\t\treturn a&b;\n\t}\n\t\n\tboolean closs() {\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tlong dx = x[(i+1)%3] - x[i];\n\t\t\tlong dy = y[(i+1)%3] - y[i];\n\t\t\tlong px = cx-x[i];\n\t\t\tlong py = cy-y[i];\n\t\t\tif( (dx*py - dy*px) * (dx*py - dy*px) <= (long)(r*r)*( dx*dx+dy*dy ) )\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif(x1==0 && y1==0) break;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tdouble maxx = Math.max(Math.max(x1,x2), x3);\n\t\t\tdouble maxy = Math.max(Math.max(y1,y2), y3);\n\t\t\tdouble minx = Math.min(Math.min(x1,x2), x3);\n\t\t\tdouble miny = Math.min(Math.min(y1,y2), y3);\t\t\t\n\t\t\tPoint2D.Double p1 = new Point2D.Double(x1,y1);\n\t\t\tPoint2D.Double p2 = new Point2D.Double(x2,y2);\n\t\t\tPoint2D.Double p3 = new Point2D.Double(x3,y3);\n\t\t\tPoint2D.Double p4 = new Point2D.Double(x4,y4);\n\t\t\tLine2D.Double a = new Line2D.Double(p2,p3);\n\t\t\tLine2D.Double b = new Line2D.Double(p3,p1);\n\t\t\tLine2D.Double c = new Line2D.Double(p1,p2);\n\t\t\tdouble r = sc.nextDouble();\n\n\t\t\tif(p4.distance(p1)<=r && p4.distance(p2)<=r && p4.distance(p3)<=r){\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t}else if(a.ptSegDist(p4)>=r && b.ptSegDist(p4)>=r && c.ptSegDist(p4)>=r){\n\t\t\t\tLine2D.Double da = new Line2D.Double(p1,p4);\n\t\t\t\tLine2D.Double db = new Line2D.Double(p2,p4);\n\t\t\t\tLine2D.Double dc = new Line2D.Double(p3,p4);\n\t\t\t\tif(minx<x4 && x4<maxx && miny<y4 && y4<maxy && a.intersectsLine(da)==false\n\t\t\t\t\t\t&& b.intersectsLine(db)==false && c.intersectsLine(dc)==false){\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t}else{\n\t\t\t\t\tif(a.ptSegDist(p4)==r || b.ptSegDist(p4)==r || c.ptSegDist(p4)==r){\n\t\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(\n\t\t\t\t\t\tnew Line(ps[i], ps[(i + 1) % 3]).disToPoint(ps[3]),\n\t\t\t\t\t\tnew Line(ps[(i + 1) % 3], ps[i]).disToPoint(ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[3]));\n\t\t\t}\n\t\t\tboolean in = eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0\n\t\t\t\t\t|| eps[0] < 0 && eps[1] < 0 && eps[2] < 0;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.IOException;\n\npublic class Main {\n\t/**\n\t * @param args\n\t */\n\tstatic class Shape {\n\t\tpublic\tint\tx = 0;\n\t\tpublic\tint\ty = 0;\n\t\tpublic\tint\tr = 0;\n\n\t\tpublic Shape(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic Shape(int x, int y, int r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tstatic class Line {\n\t\tpublic\tShape\tps = null;\n\t\tpublic\tShape\tpe = null;\n\t\tpublic\tint\t\ta  = 0;\n\t\tpublic\tint\t\tb  = 0;\n\t\tpublic\tint\t\tc  = 0;\n\n\t\tpublic Line(Shape ps, Shape pe) {\n\t\t\tthis.ps = ps;\n\t\t\tthis.pe = pe;\n\t\t\tthis.a  = pe.y-ps.y;\n\t\t\tthis.b  = ps.x-pe.x;\n\t\t\tthis.c  = -(this.a*ps.x+this.b*ps.y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tShape[]\ts = null;\n\n\t\twhile((s = inp()) != null) {\n\t\t\tsolve(s[0], s[1], s[2], s[3]);\n\t\t}\n\t}\n\n\tprivate static void solve(Shape p1, Shape p2, Shape p3, Shape c) {\n\t\t{\n\t\t\tint\trr = (c.r*c.r);\n\t\t\tint\td0 = distPow(c, p1);\n\t\t\tint\td1 = distPow(c, p2);\n\t\t\tint\td2 = distPow(c, p3);\n\n\t\t\t// 三角形が円の内部に含まれるか\n\t\t\tif (d0 <= rr && d1 <= rr && d2 <= rr) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tint\t\tn1 = crossSign(p1, p2, c);\n\t\t\tint\t\tn2 = crossSign(p2, p3, c);\n\t\t\tint\t\tn3 = crossSign(p3, p1, c);\n\t\t\tLine\tl1 = new Line(p1, p2);\n\t\t\tLine\tl2 = new Line(p2, p3);\n\t\t\tLine\tl3 = new Line(p3, p1);\n\n\t\t\t// 円の中心が三角形の内部に含まれるか\n\t\t\tif ((n1 == n2) && (n2 == n3)) {\n\t\t\t\tint\tc1 = checkDist(l1, c);\n\t\t\t\tint\tc2 = checkDist(l2, c);\n\t\t\t\tint\tc3 = checkDist(l3, c);\n\n\t\t\t\t// 円が三角形内部に含まれるか\n\t\t\t\tif (c1 <= 0 && c2 <= 0 && c3 <= 0) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 円と線分が交わるか\n\t\t\t\tif (checkCross(l1, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (checkCross(l2, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (checkCross(l2, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(\"d\");\n\t}\n\n\tprivate static int distPow(Shape s1, Shape s2) {\n\t\treturn (s1.x-s2.x)*(s1.x-s2.x)+(s1.y-s2.y)*(s1.y-s2.y);\n\t}\n\n\tprivate static boolean checkCross(Line l, Shape c) {\n\t\tLine2D.Double ld = new Line2D.Double(l.ps.x, l.ps.y, l.pe.x, l.pe.y);\n\t\treturn (ld.ptSegDistSq(c.x, c.y) <= (double)(c.r*c.r))?true:false;\n\t}\n\n\tprivate static int checkDist(Line l, Shape p) {\n\t\tint\ts = p.r*p.r*(l.a*l.a+l.b*l.b);\n\t\tint\tt = (l.a*p.x+l.b*p.y+l.c)*(l.a*p.x+l.b*p.y+l.c);\n\t\treturn (s==t)?0:((s<t)?-1:1);\n\t}\n\n\tprivate static int crossSign(Shape s1, Shape s2, Shape s3) {\n\t\tint[]\tvab = { s2.x-s1.x, s2.y-s1.y };\n\t\tint[]\tvap = { s3.x-s1.x, s3.y-s1.y };\n\t\tint\t\tsgn = cross(vab, vap);\n\t\treturn (sgn==0)?0:((sgn>0)?1:-1);\n\t}\n\n\tprivate static int cross(int[] va, int[] vb) {\n\t\treturn va[0]*vb[1]-va[1]*vb[0];   // x1*x2 + y1*y2\n\t}\n\n\tprivate static Shape[] inp() {\n\t\tShape[]\td = new Shape[4];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i < 3) {\n\t\t\t\tint[]\tp = { parseNum(), parseNum() };\n\t\t\t\tif (p[0] == 0 && p[1] == 0) return null;\n\t\t\t\td[i] = new Shape(p[0], p[1]);\n\t\t\t} else {\n\t\t\t\tint[]\tp = { parseNum(), parseNum(), parseNum() };\n\t\t\t\td[i] = new Shape(p[0], p[1], p[2]);\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = 0;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n\n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if ((skp == 0 || buf == -1) && buf != '.') {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif(x1==0 && y1==0) break;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint maxx = Math.max(Math.max(x1,x2), x3);\n\t\t\tint maxy = Math.max(Math.max(y1,y2), y3);\n\t\t\tint minx = Math.min(Math.min(x1,x2), x3);\n\t\t\tint miny = Math.min(Math.min(y1,y2), y3);\t\t\t\n\t\t\tPoint2D.Double p1 = new Point2D.Double(x1,y1);\n\t\t\tPoint2D.Double p2 = new Point2D.Double(x2,y2);\n\t\t\tPoint2D.Double p3 = new Point2D.Double(x3,y3);\n\t\t\tPoint2D.Double p4 = new Point2D.Double(x4,y4);\n\t\t\tLine2D.Double a = new Line2D.Double(p2,p3);\n\t\t\tLine2D.Double b = new Line2D.Double(p3,p1);\n\t\t\tLine2D.Double c = new Line2D.Double(p1,p2);\n\t\t\tint r = sc.nextInt();\n\n\t\t\tif(p4.distance(p1)<=r && p4.distance(p2)<=r && p4.distance(p3)<=r){\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t}else if(a.ptSegDist(p4)>=r && b.ptSegDist(p4)>=r && c.ptSegDist(p4)>=r){\n\t\t\t\tLine2D.Double da = new Line2D.Double(p1,p4);\n\t\t\t\tLine2D.Double db = new Line2D.Double(p2,p4);\n\t\t\t\tLine2D.Double dc = new Line2D.Double(p3,p4);\t\t\t\n\t\t\t\tif(minx<x4 && x4<maxx && miny<y4 && y4<maxy && a.intersectsLine(da)==false\n\t\t\t\t\t\t&& b.intersectsLine(db)==false && c.intersectsLine(dc)==false){\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * AOJ id=0153\n * Triangle and Circle\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint[] x = new int[3];\n\t\t\tint[] y = new int[3];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tif(i==0 && x[i]==0 && y[i]==0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tint rx = sc.nextInt();\n\t\t\tint ry = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(solve(x, y, rx, ry, r));\n\t\t}\n\t}\n\n\tprivate String solve(int[] x, int[] y, int rx, int ry, int r) {\n\t\tint[] vx = new int[3];\n\t\tint[] vy = new int[3];\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tvx[i] = x[(i+1)%3]-x[i];\n\t\t\tvy[i] = y[(i+1)%3]-y[i];\n\t\t}\n\t\t\n\t\tint inCircle = 0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint xd = (x[i]-rx)*(x[i]-rx);\n\t\t\tint yd = (y[i]-ry)*(y[i]-ry);\n\t\t\tif(r*r >= xd+yd)\n\t\t\t\tinCircle++;\n\t\t}\n\t\tif(inCircle==3)\n\t\t\treturn \"b\";\n//\t\telse if(inCircle==1 || inCircle==2)\n//\t\t\t// 接している場合は三角形の中に円がはいっている可能性がある？\n//\t\t\treturn \"c\";\n\t\t\n\n\t\tint l=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(vx[i]*(ry-y[i])-(rx-x[i])*vy[i]<0)\n\t\t\t\tl++;\n\t\t}\n\t\tif(l==3 || l==0)\n\t\t\treturn \"a\";\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint vrx = rx-x[i];\n\t\t\tint vry = ry-y[i];\n\t\t\t\n\t\t\tint inp = vx[i]*vrx+vy[i]*vry;\n\t\t\tif(inp<0){\n\t\t\t\tif(vrx*vrx+vry*vry < r*r)\n\t\t\t\t\treturn \"c\";\n\t\t\t}else{\n\t\t\t\tif(inp > vx[i]*vx[i]+vy[i]*vy[i]){\n\t\t\t\t\tif((rx-x[(i+1)%3])*(rx-x[(i+1)%3])+(ry-y[(i+1)%3])*(ry-y[(i+1)%3]) <r*r)\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t}else{\n\t\t\t\t\tif(vrx*vrx+vry*vry-inp*inp < (long)(vx[i]*vx[i]+vy[i]*vy[i])*r*r){\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn \"d\";\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Triangle and Circle\npublic class Main{\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tpublic static double distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tpublic static boolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tpublic static int ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static Point proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tpublic static double inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static final double EPS = 1.0e-8;\n\tpublic static double norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint pp = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tif(pp.x==0&&pp.y==0)break;\n\t\t\tPoint[] p = new Point[3];\n\t\t\tp[0]=pp;\n\t\t\tfor(int i=1;i<3;i++)p[i]=new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tPoint c = new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tdouble r = sc.nextDouble();\n\t\t\tboolean isB = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tif(!(Math.pow(c.x-p[i].x, 2)+Math.pow(c.y-p[i].y, 2)<=r*r))isB = false;\n\t\t\t}\n\t\t\tif(isB){\n\t\t\t\tSystem.out.println(\"b\");continue;\n\t\t\t}\n\t\t\tboolean left = true;\n\t\t\tboolean right = true;\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble max = 0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble ex = extp(sub(p[(i+1)%3], p[i]), sub(c, p[i]));\n\t\t\t\tif(ex < 0)left = false;\n\t\t\t\telse if(ex > 0)right = false;\n\t\t\t\tLine l = new Line(p[i], p[(i+1)%3]);\n\t\t\t\tdouble d = distanceSP(l, c);\n//\t\t\t\tLine m = new Line(p[(i+1)%3], p[i]);\n//\t\t\t\tdouble d = Math.max(distanceSP(l, c), distanceSP(m, c));\n\t\t\t\tmin = Math.min(min, d);\n\t\t\t\tmax = Math.max(max, d);\n\t\t\t}\n\t\t\tboolean in = left|right;\n\t\t\tif(in && min >= r)System.out.println(\"a\");\n\t\t\telse if(!in && min > r)System.out.println(\"d\");\n\t\t\telse System.out.println(\"c\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tPoint2D [] triP;\n\tLine2D [] triL;\n\tPoint2D cp;\n\tint cr;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\ttriP = new Point2D[3];\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\tif((x|y) == 0) break;\n\t\t\ttriP[0] = new Point2D.Double(x, y);\n\t\t\tfor(int i = 1;  i < 3; i++){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\ttriP[i] = new Point2D.Double(x, y);\n\t\t\t}\n\t\t\ttriL = new Line2D[3];\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\ttriL[i] = new Line2D.Double(triP[i], triP[(i+1) % 3]);\n\t\t\t}\n\t\t\tint cx = sc.nextInt();\n\t\t\tint cy = sc.nextInt();\n\t\t\tcr = sc.nextInt();\n\t\t\tcp = new Point2D.Double(cx, cy);\n\t\t\t\n\t\t\tint state = -1;\n\t\t\t\n\t\t\tboolean res = isB();\n\t\t\tif(res){\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tboolean res2 = isIn();\n\t\t\tif(res2){\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\t\tif(dis < cr){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tdouble dis = triL[i].ptSegDist(cp);\n\t\t\t\t\tif(dis < cr){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate boolean isIn() {\n\t\tboolean flg = true;\n\t\tint sign = triL[0].relativeCCW(cp);\n\t\tfor(int i = 1; i < 3;i++){\n\t\t\tint now = triL[i].relativeCCW(cp);\n\t\t\tif(now * sign != 1){\n\t\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flg){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isB() {\n\t\tboolean flg = true;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdouble dis = triP[i].distance(cp);\n\t\t\tif(dis > cr){\n\t\t\t\tflg = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flg){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tboolean flag = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tif (!(nor(ps[3], ps[i]) <= r * r))\n\t\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[(i + 1) % 3], ps[i]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = Line.extp(Line.sub(ps[(i + 1) % 3], ps[i]),\n\t\t\t\t\t\tLine.sub(ps[3], ps[i]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif(x1==0 && y1==0) break;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint maxx = Math.max(Math.max(x1,x2), x3);\n\t\t\tint maxy = Math.max(Math.max(y1,y2), y3);\n\t\t\tint minx = Math.min(Math.min(x1,x2), x3);\n\t\t\tint miny = Math.min(Math.min(y1,y2), y3);\t\t\t\n\t\t\tPoint2D.Double p1 = new Point2D.Double(x1,y1);\n\t\t\tPoint2D.Double p2 = new Point2D.Double(x2,y2);\n\t\t\tPoint2D.Double p3 = new Point2D.Double(x3,y3);\n\t\t\tPoint2D.Double p4 = new Point2D.Double(x4,y4);\n\t\t\tLine2D.Double a = new Line2D.Double(p2,p3);\n\t\t\tLine2D.Double b = new Line2D.Double(p3,p1);\n\t\t\tLine2D.Double c = new Line2D.Double(p1,p2);\n\t\t\tint r = sc.nextInt();\n\n\t\t\tif(p4.distance(p1)<=r && p4.distance(p2)<=r && p4.distance(p3)<=r){\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t}else if(a.ptLineDist(p4)>=r && b.ptLineDist(p4)>=r && c.ptLineDist(p4)>=r){\n\t\t\t\tLine2D.Double da = new Line2D.Double(p1,p4);\n\t\t\t\tLine2D.Double db = new Line2D.Double(p2,p4);\n\t\t\t\tLine2D.Double dc = new Line2D.Double(p3,p4);\t\t\t\t\n\t\t\t\tif(minx<x4 && x4<maxx && miny<y4 && y4<maxy && a.intersectsLine(da)==false\n\t\t\t\t\t\t&& b.intersectsLine(db)==false && c.intersectsLine(dc)==false){\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Triangle and Circle\npublic class Main{\n\n\tpublic static class Point {\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t}\n\tpublic static class Line {\n\t\tpublic Point s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t}\n\tpublic static double distanceSP(Line s, Point p) {\n\t\tPoint r = proj(s, p);\n\t\tif (intersectSP(s, r)) return norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.s, p)), norm(sub(s.t, p)));\n\t}\n\tpublic static boolean intersectSP(Line s, Point p) {\n\t\treturn ccw(s.s, s.t, p) == 0;\n\t}\n\tpublic static int ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a);\n\t\tPoint q = sub(c, a);\n\t\tif(extp(p, q) > EPS) return 1;\t\t// counter clockwise\n\t\tif(extp(p, q) < -EPS)return -1;\t\t// clockwise\n\t\tif(inp(p, q) < -EPS) return 2;\t\t// c--a--b on line\n\t\tif(Math.abs(norm(p) - norm(q)) < EPS) return -2;\t// a--b--c on line\n\t\treturn 0;\t\t\t\t// a--c--b(or a--c=b) on line \n\t}\n\tpublic static Point sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\tpublic static Point proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\tpublic static double inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\tpublic static double extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\tpublic static final double EPS = 1.0e-8;\n\tpublic static double norm(Point p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tPoint pp = new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tif(pp.x==0&&pp.y==0)break;\n\t\t\tPoint[] p = new Point[3];\n\t\t\tp[0]=pp;\n\t\t\tfor(int i=1;i<3;i++)p[i]=new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tPoint c = new Point(sc.nextDouble(),sc.nextDouble());\n\t\t\tdouble r = sc.nextDouble();\n\t\t\tboolean isB = true;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tif(!(Math.pow(c.x-p[i].x, 2)+Math.pow(c.y-p[i].y, 2)<=r*r))isB = false;\n\t\t\t}\n\t\t\tif(isB){\n\t\t\t\tSystem.out.println(\"b\");continue;\n\t\t\t}\n\t\t\tboolean left = true;\n\t\t\tboolean right = true;\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble max = 0;\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tdouble ex = extp(sub(p[(i+1)%3], p[i]), sub(c, p[i]));\n\t\t\t\tif(ex <= 0)left = false;\n\t\t\t\tif(ex >= 0)right = false;\n\t\t\t\tLine l = new Line(p[i], p[(i+1)%3]);\n\t\t\t\tLine m = new Line(p[(i+1)%3], p[i]);\n\t\t\t\tdouble d = Math.max(distanceSP(l, c), distanceSP(m, c));\n\t\t\t\tmin = Math.min(min, d);\n\t\t\t\tmax = Math.max(max, d);\n\t\t\t}\n\t\t\tboolean in = left|right;\n\t\t\tif(in && min >= r)System.out.println(\"a\");\n\t\t\telse if(!in && min >= r)System.out.println(\"d\");\n\t\t\telse System.out.println(\"c\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tloop: while (true) {\n\t\t\tPoint2D.Double[] points = new Point2D.Double[4];\n\t\t\tint maxx = Integer.MIN_VALUE;\n\t\t\tint maxy = Integer.MIN_VALUE;\n\t\t\tint minx = Integer.MAX_VALUE;\n\t\t\tint miny = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tif (i == 0 && x == 0 && y == 0) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tpoints[i] = new Point2D.Double(x, y);\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tmaxx = Math.max(maxx, x);\n\t\t\t\t\tmaxy = Math.max(maxy, y);\n\t\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble r = scanner.nextDouble();\n\t\t\tLine2D.Double a = new Line2D.Double(points[1], points[2]);\n\t\t\tLine2D.Double b = new Line2D.Double(points[2], points[0]);\n\t\t\tLine2D.Double c = new Line2D.Double(points[0], points[1]);\n\t\t\tdouble d0 = points[3].distance(points[0]);\n\t\t\tdouble d1 = points[3].distance(points[1]);\n\t\t\tdouble d2 = points[3].distance(points[2]);\n\t\t\tdouble ap = a.ptSegDist(points[3]);\n\t\t\tdouble bp = b.ptSegDist(points[3]);\n\t\t\tdouble cp = c.ptSegDist(points[3]);\n\t\t\tPath2D.Double path = new Path2D.Double();\n\t\t\tpath.moveTo(points[0].x, points[0].y);\n\t\t\tpath.lineTo(points[1].x, points[1].y);\n\t\t\tpath.lineTo(points[2].x, points[2].y);\n\n\t\t\tif (d0 <= r && d1 <= r && d2 <= r) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t} else if (path.contains(points[3])) {\n\t\t\t\tif (ap > r && bp > r && cp > r) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (d0 > r && d1 > r && d2 > r) {\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tLine[] ls = new Line[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tls[i] = new Line(ps[i], ps[(i + 1) % 3]);\n\t\t\t\tdouble dis = ls[i].disToPoint(ps[3]);\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[3]).ep(ls[i]);\n\t\t\t}\n\t\t\tif (r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t} else if (eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0 || eps[0] < 0\n\t\t\t\t\t&& eps[1] < 0 && eps[2] < 0) {\n\t\t\t\tif (r <= min)\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t} else {\n\t\t\t\tif (r < min) {\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t} else\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tloop: while (true) {\n\t\t\tPoint2D.Double[] points = new Point2D.Double[4];\n\t\t\tint maxx = Integer.MIN_VALUE;\n\t\t\tint maxy = Integer.MIN_VALUE;\n\t\t\tint minx = Integer.MAX_VALUE;\n\t\t\tint miny = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tif (i == 0 && x == 0 && y == 0) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tpoints[i] = new Point2D.Double(x, y);\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tmaxx = Math.max(maxx, x);\n\t\t\t\t\tmaxy = Math.max(maxy, y);\n\t\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble r = scanner.nextDouble();\n\t\t\tLine2D.Double a = new Line2D.Double(points[1], points[2]);\n\t\t\tLine2D.Double b = new Line2D.Double(points[2], points[0]);\n\t\t\tLine2D.Double c = new Line2D.Double(points[0], points[1]);\n\t\t\tEllipse2D.Double circle = new Ellipse2D.Double(points[3].x,\n\t\t\t\t\tpoints[3].y, r * 2, r * 2);\n\t\t\tdouble d0 = points[3].distance(points[0]);\n\t\t\tdouble d1 = points[3].distance(points[1]);\n\t\t\tdouble d2 = points[3].distance(points[2]);\n\t\t\tdouble ap = a.ptSegDist(points[3]);\n\t\t\tdouble bp = b.ptSegDist(points[3]);\n\t\t\tdouble cp = c.ptSegDist(points[3]);\n\t\t\tPath2D.Double path = new Path2D.Double();\n\t\t\tpath.moveTo(points[0].x, points[0].y);\n\t\t\tpath.lineTo(points[1].x, points[1].y);\n\t\t\tpath.lineTo(points[2].x, points[2].y);\n\t\t\tif (d0 <= r && d1 <= r && d2 <= r) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t} else if (ap > r && bp > r && cp > r) {\n\t\t\t\tif (path.contains(points[3])) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else {\n\t\t\t\t\tif (ap == r || bp == r || cp == r) {\n\t\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x, y;\n\t\t\n\t\tpublic Vector(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tpublic double norm(){\n\t\t\treturn Math.hypot(x, y);\n\t\t}\n\t\t\n\t\tpublic double sqrNorm(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\t\n\t\tpublic double ip(Vector v){\n\t\t\treturn x*v.x+y*v.y;\n\t\t}\n\t\t\n\t\tpublic Vector add(Vector v){\n\t\t\treturn new Vector(x+v.x, y+v.y);\n\t\t}\n\t\t\n\t\tpublic Vector subtract(Vector v){\n\t\t\treturn new Vector(x-v.x, y-v.y);\n\t\t}\n\t\t\n\t\tpublic Vector multiply(double a){\n\t\t\treturn new Vector(x*a, y*a);\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn String.format(\"(%5f,%5f)\", x, y);\n\t\t}\n\t}\n\t\n\tboolean inTriangle(Vector[] v){\n\t\tdouble theta=0;\n\t\tfor(int i=0;i<3;++i){\n\t\t\ttheta+=Math.acos(v[i].ip(v[(i+1)%3])/v[i].norm()/v[(i+1)%3].norm());\n\t\t}\n\t\treturn theta>=Math.PI*2-1e-7;\n\t}\n\t\n\tchar solve(Vector[] a, Vector p, double r){\n\t\tVector[] v=new Vector[3], e=new Vector[3];\n\t\tr*=r;\n\t\t\n\t\tboolean isB=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tv[i]=a[i].subtract(p);\n\t\t\te[i]=a[(i+1)%3].subtract(a[i]);\n\t\t\tisB&=v[i].sqrNorm()<=r;\n\t\t}\n\t\tif(isB) return 'b';\n\t\t\n\t\tVector[] h=new Vector[3];\n\t\tboolean isA=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\t//点pより三角形の辺と直交するvector\n\t\t\t//hi=vi+(ei・(-vi)/|ei|^2)ei\n\t\t\th[i]=v[i].subtract(e[i].multiply(e[i].ip(v[i])/e[i].sqrNorm()));\n\t\t\tisA&=h[i].sqrNorm()>=r;\n\t\t}\n\t\t//debug(h);\n\t\t\n\t\tif(isA&&inTriangle(v)) return 'a';\n\t\t\n\t\tboolean isC=false;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tVector n=h[i].add(p);\n\t\t//\tdebug(n,n.subtract(a[i]).ip(n.subtract(a[(i+1)%3])));\n\t\t\tif(v[i].sqrNorm()<=r||(n.subtract(a[i]).ip(n.subtract(a[(i+1)%3]))<=0&&h[i].sqrNorm()<=r)){\n\t\t\t\tisC=true;\n\t\t\t}\n\t\t}\n\t\tif(isC) return 'c';\n\t\telse return 'd';\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x=ni(),y=ni();\n\t\t\tif(x==0&y==0)break;\n\t\t\t\n\t\t\tVector[] a=new Vector[3];\n\t\t\t\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\ta[i]=new Vector(x, y);\n\t\t\t\tx=ni(); y=ni();\n\t\t\t}\n\t\t\tVector p=new Vector(x, y);\n\t\t\tdouble r=ni();\n\t\t\t\n\t\t\tSystem.out.println(solve(a,p,r));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tdouble dis = new Line(ps[i], ps[(i + 1) % 3]).disToPoint(ps[3]);\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t\tdis = new Line(ps[(i + 1) % 3], ps[i]).disToPoint(ps[3]);\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]));\n\t\t\t}\n\t\t\tboolean in = eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0\n\t\t\t\t\t|| eps[0] < 0 && eps[1] < 0 && eps[2] < 0;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * AOJ id=0153\n * Triangle and Circle\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint[] x = new int[3];\n\t\t\tint[] y = new int[3];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tif(i==0 && x[i]==0 && y[i]==0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tint rx = sc.nextInt();\n\t\t\tint ry = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(solve(x, y, rx, ry, r));\n\t\t}\n\t}\n\n\tprivate String solve(int[] x, int[] y, int rx, int ry, int r) {\n\t\tint[] vx = new int[3];\n\t\tint[] vy = new int[3];\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tvx[i] = x[(i+1)%3]-x[i];\n\t\t\tvy[i] = y[(i+1)%3]-y[i];\n\t\t}\n\t\tint inCircle = 0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint xd = (x[i]-rx)*(x[i]-rx);\n\t\t\tint yd = (y[i]-ry)*(y[i]-ry);\n\t\t\tif(r*r >= xd+yd)\n\t\t\t\tinCircle++;\n\t\t}\n\t\tif(inCircle==3)\n\t\t\treturn \"b\";\n\t\telse if(inCircle==1 || inCircle==2)\n\t\t\treturn \"c\";\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint vrx = rx-x[i];\n\t\t\tint vry = ry-y[i];\n\t\t\t\n\t\t\tint inp = vx[i]*vrx+vy[i]*vry;\n\t\t\tif(inp<0){\n\t\t\t\tif(vrx*vrx+vry*vry < r*r)\n\t\t\t\t\treturn \"c\";\n\t\t\t}else{\n\t\t\t\tif(inp*inp > vx[i]*vx[i]+vy[i]*vy[i]){\n\t\t\t\t\tif(vx[(i+1)%3]*vx[(i+1)%3]+vy[(i+1)%3]*vy[(i+1)%3] <r*r)\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t}else{\n\t\t\t\t\tif(vrx*vrx+vry*vry-inp*inp > (long)(vx[i]*vx[i]+vy[i]*vy[i])*r*r){\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t}\n\t\t\n\t\tint l=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(vx[i]*(ry-y[i])-(rx-x[i])*vy[i]<0)\n\t\t\t\tl++;\n\t\t}\n\t\tif(l==3 || l==0)\n\t\t\treturn \"a\";\n\t\telse\n\t\t\treturn \"d\";\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] x, y;\n\tint cx, cy, r;\n\t\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tx = new int[3];\n\t\t\ty = new int[3];\n\t\t\tx[0] = sc.nextInt();\n\t\t\ty[0] = sc.nextInt();\n\t\t\tif( (x[0]|y[0]) == 0 ) break;\n\t\t\t\n\t\t\tfor(int i=1;i<3;i++) {\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\t\t\tcx = sc.nextInt();\n\t\t\tcy = sc.nextInt();\n\t\t\tr = sc.nextInt();\n\t\t\t\n\t\t\tif(inCir()) System.out.println(\"b\");\n\t\t\telse {\n\t\t\t\tboolean a = inTri();\n\t\t\t\tboolean b = closs();\n\t\t\t\tif( a&(!b) ) System.out.println(\"a\");\n\t\t\t\telse if(b) System.out.println(\"c\");\n\t\t\t\telse System.out.println(\"d\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tboolean inCir() {\n\t\tfor(int i=0;i<3;i++) if( (cx-x[i])*(cx-x[i])+(cy-y[i])*(cy-y[i]) > r*r )\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\t\n\tboolean inTri(){\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tif (clossLine(new int[]{x[i],x[(i+1)%3]}, new int[]{y[i],y[(i+1)%3]},\n\t\t\t\t\t  new int[]{cx,x[(i+2)%3]}, new int[]{cy,y[(i+2)%3]}) )\n\t\t\t\t\t  return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tboolean clossLine(int[] x1, int[] y1, int[] x2, int[] y2) {\n\t\tboolean a = (y2[0]-y1[0])*(x1[1]-x1[0]) > (y1[1]-y1[0])*(x2[0]-x1[0]) \n\t\t\t\t^\t(y2[1]-y1[0])*(x1[1]-x1[0]) > (y1[1]-y1[0])*(x2[1]-x1[0]);\n\t\tboolean b = (y1[0]-y2[0])*(x2[1]-x2[0]) > (y2[1]-y2[0])*(x1[0]-x2[0]) \n\t\t\t\t^\t(y1[1]-y2[0])*(x2[1]-x2[0]) > (y2[1]-y2[0])*(x1[1]-x2[0]); \n\t\treturn a&b;\n\t}\n\t\n\tboolean closs() {\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tint dx = x[(i+1)%3] - x[i];\n\t\t\tint dy = y[(i+1)%3] - y[i];\n\t\t\tint px = cx-x[i];\n\t\t\tint py = cy-y[i];\n\t\t\tif( (dx*py - dy*px) * (dx*py - dy*px) < r*r*( dx*dx+dy*dy ) )\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tdouble triArea(double a, double b, int c) {\n\t\tdouble s = (a+b+c)/2;\n\t\treturn s*(s-a)*(s-b)*(s-c);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tPoint3 p[]=new Point3[3];\n\t\t\tfor(int i=0;i<3;i++) {\n\t\t\t\tp[i]=new Point3(in.nextDouble(), in. nextDouble());\n\t\t\t\tif(p[0].x==0&&p[0].y==0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tPoint3 c=new Point3(in.nextDouble(), in.nextDouble());\n\t\t\tdouble r=in.nextDouble();\n\t\t\tboolean judge=false;\n\t\t\tif(ccw(p[0],c,p[1])==1&&ccw(p[1],c,p[2])==1&&ccw(p[2],c,p[0])==1\n\t\t\t\t\t||ccw(p[0],c,p[1])==-1&&ccw(p[1],c,p[2])==-1&&ccw(p[2],c,p[0])==-1)\n\t\t\t\tjudge=true;\n\n\t\t\tdouble rd1=pointDistance(p[0], c);\n\t\t\tdouble rd2=pointDistance(p[1], c);\n\t\t\tdouble rd3=pointDistance(p[2], c);\n\t\t\t//円の中心と辺の距離\n\t\t\tdouble d1=Point3.lp_dis(c.x, c.y, p[0].x, p[0].y, p[1].x, p[1].y);\n\t\t\tdouble d2=Point3.lp_dis(c.x, c.y, p[1].x, p[1].y, p[2].x, p[2].y);\n\t\t\tdouble d3=Point3.lp_dis(c.x, c.y, p[2].x, p[2].y, p[0].x, p[0].y);\n\n\t\t\tif(judge)//円の中心が三角形内\n\t\t\t{\n\n\t\t\t\tif(r>=rd1&&r>=rd2&&r>=rd3)\n\t\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\telse if(r<=d1&&r<=d2&&r<=d3)\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\telse System.out.println(\"c\");\n\t\t\t}\n\t\t\telse//円の中心が三角形外(接する含む)\n\t\t\t{\n\t\t\t\tif(r>=rd1&&r>=rd2&&r>=rd3)\n\t\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\telse if(r<d1&&r<d2&&r<d3)\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\telse System.out.println(\"c\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic double ccw(Point3 p1,Point3 p2,Point3 p3)\n\t{\n\t\tPoint3 a=new Point3(p2.x-p1.x, p2.y-p1.y);\n\t\tPoint3 b=new Point3(p3.x-p1.x, p3.y-p1.y);\n\t\tif(crossProduct(a, b)>0) return 1;//counter clockwise\n\t\tif(crossProduct(a, b)<0) return -1;//clockwise\n\t\telse return 0;\n\t}\n\t//外積\n\tstatic double crossProduct(Point3 a,Point3 b)\n\t{\n\t\treturn a.x*b.y-a.y*b.x;\n\t}\n\tstatic double pointDistance(Point3 p1, Point3 p2)\n\t{\n\t\treturn Math.hypot(p1.x-p2.x, p1.y-p2.y); \n\t}\n}\n\nclass Point3\n{\n\tdouble x;\n\tdouble y;\n\tPoint3(double x,double y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n\t\n\t//point to line dis\n\tstatic double lp_dis(double px,double py,double x1,double y1,double x2,double y2)\n\t{\n\t\tdouble dx=x2-x1,dy=y2-y1;\n\t\tdouble a=dx*dx+dy*dy,b=dx*(x1-px)+dy*(y1-py);\n\t\tdouble t=-b/a;\n\t\tif(t<0) t=0;\n\t\tif(t>1) t=1;\n\t\tdouble tx=x1+dx*t;\n\t\tdouble ty=y1+dy*t;\n\t\treturn Math.hypot(px-tx, py-ty);\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x, y;\n\t\t\n\t\tpublic Vector(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tpublic double norm(){\n\t\t\treturn Math.hypot(x, y);\n\t\t}\n\t\t\n\t\tpublic double sqrNorm(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\t\n\t\tpublic double ip(Vector v){\n\t\t\treturn x*v.x+y*v.y;\n\t\t}\n\t\t\n\t\tpublic Vector add(Vector v){\n\t\t\treturn new Vector(x+v.x, y+v.y);\n\t\t}\n\t\t\n\t\tpublic Vector subtract(Vector v){\n\t\t\treturn new Vector(x-v.x, y-v.y);\n\t\t}\n\t\t\n\t\tpublic Vector multiply(double a){\n\t\t\treturn new Vector(x*a, y*a);\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn String.format(\"(%f,%f)\", x, y);\n\t\t}\n\t}\n\t\n\tboolean inTriangle(Vector[] v){\n\t\tdouble theta=0;\n\t\tfor(int i=0;i<3;++i){\n\t\t\ttheta+=Math.acos(v[i].ip(v[(i+1)%3])/v[i].norm()/v[(i+1)%3].norm());\n\t\t}\n\t\treturn theta>=Math.PI*2-1e-7;\n\t}\n\t\n\tchar solve(Vector[] a, Vector p, double r){\n\t\tVector[] v=new Vector[3], e=new Vector[3];\n\t\tr*=r;\n\t\t\n\t\tboolean isB=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tv[i]=a[i].subtract(p);\n\t\t\te[i]=a[(i+1)%3].subtract(a[i]);\n\t\t\tisB&=v[i].sqrNorm()<=r;\n\t\t}\n\t\tif(isB) return 'b';\n\t\t\n\t\tVector[] h=new Vector[3];\n\t\tboolean isA=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\t//円の中心より三角形の辺と直交するvector\n\t\t\t//hi=vi+(ei・(-vi)/|ei|^2)ei\n\t\t\th[i]=v[i].subtract(e[i].multiply(e[i].ip(v[i])/e[i].sqrNorm()));\n\t\t\tisA&=h[i].sqrNorm()>=r;\n\t\t}\n\t\tif(isA&&inTriangle(v)) return 'a';\n\t\t\n\t\t//円の半径以内に三角形の辺∨頂点が存在?\n\t\tboolean isC=false;\n\t\tfor(int i=0;i<3;++i){\n\t\t\t//n: 三角形の辺を延長した直線と, それに直交する円の中心からの直線の交点\n\t\t\tVector n=h[i].add(p);\n\t\t\tif(v[i].sqrNorm()<=r||(n.subtract(a[i]).ip(n.subtract(a[(i+1)%3]))<=0&&h[i].sqrNorm()<=r)){\n\t\t\t\tisC=true;\n\t\t\t}\n\t\t}\n\t\tif(isC) return 'c';\n\t\telse return 'd';\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x=ni(),y=ni();\n\t\t\tif(x==0&y==0)break;\n\t\t\t\n\t\t\tVector[] a=new Vector[3];\n\t\t\t\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\ta[i]=new Vector(x, y);\n\t\t\t\tx=ni(); y=ni();\n\t\t\t}\n\t\t\tVector p=new Vector(x, y);\n\t\t\tdouble r=ni();\n\t\t\t\n\t\t\tSystem.out.println(solve(a,p,r));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * AOJ id=0153\n * Triangle and Circle\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint[] x = new int[3];\n\t\t\tint[] y = new int[3];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tif(i==0 && x[i]==0 && y[i]==0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tint rx = sc.nextInt();\n\t\t\tint ry = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(solve(x, y, rx, ry, r));\n\t\t}\n\t}\n\n\tprivate String solve(int[] x, int[] y, int rx, int ry, int r) {\n\t\tint[] vx = new int[3];\n\t\tint[] vy = new int[3];\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tvx[i] = x[(i+1)%3]-x[i];\n\t\t\tvy[i] = y[(i+1)%3]-y[i];\n\t\t}\n\t\tint inCircle = 0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint xd = (x[i]-rx)*(x[i]-rx);\n\t\t\tint yd = (y[i]-ry)*(y[i]-ry);\n\t\t\tif(r*r >= xd+yd)\n\t\t\t\tinCircle++;\n\t\t}\n\t\tif(inCircle==3)\n\t\t\treturn \"b\";\n\t\telse if(inCircle==1 || inCircle==2)\n\t\t\treturn \"c\";\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint vrx = rx-x[i];\n\t\t\tint vry = ry-y[i];\n\t\t\t\n\t\t\tint inp = vx[i]*vrx+vy[i]*vry;\n\t\t\tif(inp<0){\n\t\t\t\tif(vrx*vrx+vry*vry < r*r)\n\t\t\t\t\treturn \"c\";\n\t\t\t}else{\n\t\t\t\tif(inp*inp > vx[i]*vx[i]+vy[i]*vy[i]){\n\t\t\t\t\tif((rx-x[(i+1)%3])*(rx-x[(i+1)%3])+(ry-y[(i+1)%3])*(ry-y[(i+1)%3]) <r*r)\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t}else{\n\t\t\t\t\tif(vrx*vrx+vry*vry-inp*inp < (long)(vx[i]*vx[i]+vy[i]*vy[i])*r*r){\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t}\n\t\t\n\t\tint l=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(vx[i]*(ry-y[i])-(rx-x[i])*vy[i]<0)\n\t\t\t\tl++;\n\t\t}\n\t\tif(l==3 || l==0)\n\t\t\treturn \"a\";\n\t\telse\n\t\t\treturn \"d\";\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic int space(Point a, Point b, Point c){\n\t\treturn (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);\n\t}\n\tpublic double dist(Point a, Point b){\n\t\treturn Math.sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n\t}\n\tpublic double dist(Point a, Point b, Point c){\n\t\treturn Math.abs(space(a, b, c) / dist(a, b));\n\t}\n\tpublic boolean inOrOut(Triangle tr, Point p){\n\t\tdouble key = Math.signum(space(tr.a, tr.b, p)) + Math.signum(space(tr.b, tr.c, p)) + Math.signum(space(tr.c, tr.a, p));\n\t\treturn (Math.abs(key) == 3);\n\t}\n\tpublic void relation(Triangle tr, Circle c){\n\t\tif( dist(tr.a, c.p) < c.r && dist(tr.b, c.p) < c.r && dist(tr.c, c.p) < c.r ){\n\t\t\twriter.println(\"b\");\n\t\t} else if( inOrOut(tr, c.p) && (dist(tr.a, tr.b, c.p) > c.r && dist(tr.b, tr.c, c.p) > c.r && dist(tr.c, tr.a, c.p) > c.r) ){\n\t\t\twriter.println(\"a\");\n\t\t} else if( (dist(tr.a, tr.b, c.p) > c.r || Math.min(dist(tr.a, c.p), dist(tr.b, c.p)) > c.r) &&\n\t\t\t(dist(tr.b, tr.c, c.p) > c.r || Math.min(dist(tr.b, c.p), dist(tr.c, c.p)) > c.r) &&\n\t\t\t(dist(tr.c, tr.a, c.p) > c.r || Math.min(dist(tr.c, c.p), dist(tr.a, c.p)) > c.r) ){\n\t\t\twriter.println(\"d\");\n\t\t} else {\n\t\t\twriter.println(\"c\");\n\t\t}\n\t\treturn;\n\t}\n\t\t\t\n\tpublic void solve() throws IOException{\n\t\tint n, m;\n\t\twhile( (n = nextInt()) != 0 | (m = nextInt()) != 0 ){\n\t\t\tint p = nextInt(), q = nextInt(), r = nextInt(), s = nextInt();\n\t\t\tTriangle tr = new Triangle(n, m, p, q, r, s);\n\t\t\tint x = nextInt(), y = nextInt(), z = nextInt();\n\t\t\tCircle c = new Circle(x, y, z);\n\t\t\trelation(tr, c);\n\t\t}\n\t}\t\t\t\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}\n\nclass Triangle{\n\tPoint a;\n\tPoint b;\n\tPoint c;\n\tTriangle(int p, int q, int r, int s, int t, int u){\n\t\ta = new Point(p, q);\n\t\tb = new Point(r, s);\n\t\tc = new Point(t, u);\n\t}\n}\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\nclass Circle{\n\tPoint p;\n\tint r;\n\tCircle(int x, int y, int r){\n\t\tp = new Point(x, y);\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic int space(Point a, Point b, Point c){\n\t\treturn (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);\n\t}\n\tpublic double dist(Point a, Point b){\n\t\treturn Math.sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n\t}\n\tpublic double dist(Point a, Point b, Point c){\n\t\treturn Math.abs(space(a, b, c) / dist(a, b));\n\t}\n\tpublic boolean inOrOut(Triangle tr, Point p){\n\t\tdouble key = Math.signum(space(tr.a, tr.b, p)) + Math.signum(space(tr.b, tr.c, p)) + Math.signum(space(tr.c, tr.a, p));\n\t\treturn (Math.abs(key) == 3);\n\t}\n\tpublic boolean crossOrNot(Point a, Point b, Circle c){\n\t\tif( dist(a, b, c.p) > c.r ){\n\t\t\treturn true;\n\t\t}\n\t\tif( Math.min(dist(a, c.p), dist(b, c.p)) <= c.r ){\n\t\t\treturn false;\n\t\t}\n\t\tdouble l = Math.max(dist(a, c.p), dist(b, c.p));\n\t\tdouble d = dist(a, b, c.p);\n\t\tif( Math.sqrt(l*l - d*d) > dist(a, b) ){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\t\t\n\tpublic void relation(Triangle tr, Circle c){\n\t/*\twriter.println(\"dist(tr.a, c.p) = \" + dist(tr.a, c.p));\n\t\twriter.println(\"dist(tr.b, c.p) = \" + dist(tr.b, c.p));\n\t\twriter.println(\"dist(tr.c, c.p) = \" + dist(tr.c, c.p));\n\t\twriter.println(\"space(tr.a, tr.b, c.p) = \" + space(tr.a, tr.b, c.p));\n\t\twriter.println(\"space(tr.b, tr.c, c.p) = \" + space(tr.b, tr.c, c.p));\n\t\twriter.println(\"space(tr.c, tr.a, c.p) = \" + space(tr.c, tr.a, c.p));\n\t\twriter.println(\"inOrOut(tr, c.p) = \" + inOrOut(tr, c.p));\n\t\twriter.println(\"dist(tr.a, tr.b, c.p) = \" + dist(tr.a, tr.b, c.p));\n\t\twriter.println(\"dist(tr.b, tr.c, c.p) = \" + dist(tr.b, tr.c, c.p));\n\t\twriter.println(\"dist(tr.c, tr.a, c.p) = \" + dist(tr.c, tr.a, c.p));*/\n\t\t\n\t\tif( dist(tr.a, c.p) <= c.r && dist(tr.b, c.p) <= c.r && dist(tr.c, c.p) <= c.r ){\n\t\t\twriter.println(\"b\");\n\t\t} else if( inOrOut(tr, c.p) && (dist(tr.a, tr.b, c.p) >= c.r && dist(tr.b, tr.c, c.p) >= c.r && dist(tr.c, tr.a, c.p) >= c.r) ){\n\t\t\twriter.println(\"a\");\n\t\t} else if( crossOrNot(tr.a, tr.b, c) && crossOrNot(tr.b, tr.c, c) && crossOrNot(tr.c, tr.a, c) ){\n\t\t\twriter.println(\"d\");\n\t\t} else {\n\t\t\twriter.println(\"c\");\n\t\t}\n\t\treturn;\n\t}\n\t\t\t\n\tpublic void solve() throws IOException{\n\t\tint n, m;\n\t\twhile( (n = nextInt()) != 0 | (m = nextInt()) != 0 ){\n\t\t\tint p = nextInt(), q = nextInt(), r = nextInt(), s = nextInt();\n\t\t\tTriangle tr = new Triangle(n, m, p, q, r, s);\n\t\t\tint x = nextInt(), y = nextInt(), z = nextInt();\n\t\t\tCircle c = new Circle(x, y, z);\n\t\t\trelation(tr, c);\n\t\t}\n\t}\t\t\t\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}\n\nclass Triangle{\n\tPoint a;\n\tPoint b;\n\tPoint c;\n\tTriangle(int p, int q, int r, int s, int t, int u){\n\t\ta = new Point(p, q);\n\t\tb = new Point(r, s);\n\t\tc = new Point(t, u);\n\t}\n}\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\nclass Circle{\n\tPoint p;\n\tint r;\n\tCircle(int x, int y, int r){\n\t\tp = new Point(x, y);\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n \npublic class Main {\n     \n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n \n        while (true) {\n            final int x1 = sc.nextInt();\n            final int y1 = sc.nextInt();\n             \n            if(x1 == 0 && y1 == 0){\n                break;\n            }\n             \n            final int x2 = sc.nextInt();\n            final int y2 = sc.nextInt();\n            final int x3 = sc.nextInt();\n            final int y3 = sc.nextInt();\n             \n            Point2D[][] lines = new Point2D[][]{\n                {new Point2D(x1, y1), new Point2D(x2, y2)},\n                {new Point2D(x2, y2), new Point2D(x3, y3)},\n                {new Point2D(x3, y3), new Point2D(x1, y1)}\n            };\n             \n            final int r_x = sc.nextInt();\n            final int r_y = sc.nextInt();\n            final int r = sc.nextInt();\n             \n            Point2D circle = new Point2D(r_x, r_y);\n            \n            double min_line_dist = Double.MAX_VALUE;\n            double max_pt_dist = Double.MIN_VALUE;\n            for(int i = 0; i < 3; i++){\n                max_pt_dist = Math.max(max_pt_dist, circle.dist(lines[i][0]));\n                min_line_dist = Math.min(min_line_dist, circle.psd(lines[i][0], lines[i][1]));\n                \n            }\n            \n            if(max_pt_dist < r){\n            \tSystem.out.println(\"b\");\n            \tcontinue;\n            }\n            \n            if(min_line_dist <= r){\n            \tSystem.out.println(\"c\");\n            \tcontinue;\n            }\n            \n            double[] cross = new double[3];\n            for(int i = 0; i < 3; i++){\n            \tfor(int j = 0; j < 2; j++){\n            \t\tlines[i][j] = lines[i][j].sub(circle);\n            \t}\n            }\n            \n            for(int i = 0; i < 3; i++){\n            \tcross[i] = lines[i][0].cross(lines[i][1]);\n            \t//System.out.println(cross[i]);\n            }\n             \n            \n            if(cross[0] < 0 && cross[1] < 0 && cross[2] < 0 || cross[0] > 0 && cross[1] > 0 && cross[2] > 0){\n            \tSystem.out.println(\"a\");\n            }else{\n            \tSystem.out.println(\"d\");\n            }\n            \n             \n        }\n    }\n     \n    public static class Point2D {\n        public double x;\n        public double y;\n \n        public static final double EPS = 1e-9;\n \n        public Point2D(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n \n        public Point2D(Point2D point) {\n            this.x = point.x;\n            this.y = point.y;\n        }\n \n        public String toString() {\n            return x + \",\" + y;\n        }\n \n        @Override\n        public boolean equals(Object o) {\n            if (o instanceof Point2D) {\n                Point2D another = (Point2D) o;\n                 \n                if(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n                    return true;\n                }\n                 \n                return false;\n            }\n            return false;\n        }\n \n        public Point2D add(double x, double y) {\n            return new Point2D(this.x + x, this.y + y);\n        }\n \n        public Point2D sub(double x, double y) {\n            return add(-x, -y);\n        }\n \n        public Point2D add(Point2D another) {\n            return add(another.x, another.y);\n        }\n \n        public Point2D sub(Point2D another) {\n            return sub(another.x, another.y);\n        }\n \n        public Point2D mul(double d) {\n            return new Point2D(this.x * d, this.y * d);\n        }\n \n        public Point2D div(double d) {\n            return new Point2D(this.x / d, this.y / d);\n        }\n \n        public double dot(double x, double y) {\n            return this.x * x + this.y * y;\n        }\n \n        public double dot(Point2D another) {\n            return dot(another.x, another.y);\n        }\n \n        public double cross(double x, double y) {\n            return this.x * y - this.y * x;\n        }\n \n        public double cross(Point2D another) {\n            return cross(another.x, another.y);\n        }\n \n        public double dist(double x, double y) {\n            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                    * (this.y - y));\n        }\n \n        public double dist(Point2D another) {\n            return dist(another.x, another.y);\n        }\n \n        public double dist_o() {\n            return dist(0, 0);\n        }\n \n        public Point2D unit() {\n            return div(dist_o());\n        }\n \n        public boolean pol(Point2D start, Point2D end) {\n            return end.sub(start).cross(this.sub(start)) < EPS;\n        }\n \n        public boolean pos(Point2D start, Point2D end) {\n            return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n        }\n \n        public double pld(Point2D start, Point2D end) {\n            return Math.abs((end.sub(start).cross(this.sub(start)))\n                    / end.sub(start).dist_o());\n        }\n \n        public double psd(Point2D start, Point2D end) {\n            if (end.sub(start).dot(this.sub(start)) < EPS) {\n                return this.dist(start);\n            } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n                return this.dist(end);\n            } else {\n                return Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n            }\n        }\n         \n        public static int signum(double x){\n            return Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n        }\n         \n        public static boolean eq(double x, double y){\n            return signum(x - y) == 0;\n        }\n         \n        public static int ccw(Point2D p, Point2D r, Point2D s){\n            Point2D a = r.sub(p);\n            Point2D b = s.sub(p);\n             \n            final int sgn = Point2D.signum(a.cross(b));\n            if(sgn != 0){\n                return sgn;\n            }else if(a.x * b.x < -EPS && a.y * b.y < -EPS){\n                return -1;\n            }else if(a.dist_o() < b.dist_o() - EPS){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n         \n        public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            return (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n                    && (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n        }\n \n        public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n        }\n \n        public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            Point2D b = b2.sub(b1);\n            double d1 = Math.abs(b.cross(a1.sub(b1)));\n            double d2 = Math.abs(b.cross(a2.sub(b1)));\n            double t = d1 / (d1 + d2);\n            Point2D a = a2.sub(a1), v = a.mul(t);\n            return a1.add(v);\n        }\n \n        public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            Point2D a = a2.sub(a1);\n            Point2D b = b2.sub(b1);\n            double t = b.cross(b1.sub(a1)) / b.cross(a);\n            Point2D v = a.mul(t);\n            return a1.add(v);\n        }\n \n        public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n                double r2) {\n            double dis = p1.dist(p2);\n \n            if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n                return new Point2D[0]; // same\n            }\n \n            if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n                Point2D tmp = p2.sub(p1);\n                tmp = tmp.mul(r1 / tmp.dist_o());\n                Point2D ret[] = new Point2D[1];\n                ret[0] = p1.add(tmp);\n                return ret;\n            } else if (dis + EPS > r1 + r2) {\n                return new Point2D[0]; // out\n            }\n \n            double dis_m = Math.abs(r1 - r2);\n \n            if (dis_m + EPS > dis && dis_m - EPS < dis) {\n                Point2D tmp = null;\n                if (r1 > r2) {\n                    tmp = p2.sub(p1);\n                } else {\n                    tmp = p1.sub(p2);\n                }\n \n                double min = Math.min(r1, r2);\n \n                tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n                Point2D ret[] = new Point2D[1];\n                ret[0] = p1.add(tmp);\n                return ret;\n            } else if (dis_m + EPS > dis) {\n                return new Point2D[0]; // inner\n            } else {\n                Point2D ret[] = new Point2D[2];\n \n                double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                        / (2 * dis * r1));\n                double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n                ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                        * Math.sin(a + theta) + p1.y);\n                ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                        * Math.sin(a - theta) + p1.y);\n                return ret;\n            }\n        }\n         \n        public static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n            if(Point2D.intersect_s(start1, end1, start2, end2)){\n                return 0;\n            }else{\n                return Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n            }\n        }\n         \n        public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n                Point2D ans[]) {\n            if (c.pld(start, end) > r + EPS)\n                return;\n            Point2D v = end.sub(start).unit();\n            double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                    - start.dist(c) * start.dist(c) + r * r;\n            double t = -v.dot(start.sub(c));\n            double s = Math.sqrt(delta);\n            ans[0] = start.add(v.mul(t + s));\n            ans[1] = start.add(v.mul(t + s));\n        }\n        \n        public void interpoint_sc(Point2D start, Point2D end, Point2D c, double r,\n                Point2D ans[]) {\n            if (c.psd(start, end) > r + EPS)\n                return;\n            Point2D v = end.sub(start).unit();\n            double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                    - start.dist(c) * start.dist(c) + r * r;\n            double t = -v.dot(start.sub(c));\n            double s = Math.sqrt(delta);\n            ans[0] = start.add(v.mul(t + s));\n            ans[1] = start.add(v.mul(t + s));\n        }\n        \n        public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n            Point2D v = b.sub(a).unit();\n            v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                    (-1) * v.y, v.x);\n            return v.mul(p.pld(a, b));\n        }\n \n        public double area(Point2D a, Point2D b, Point2D c) {\n            return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n        }\n \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n \npublic class Main {\n \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int x1 = sc.nextInt();\n            int y1 = sc.nextInt();\n            if ((x1 | y1) == 0)\n                break;\n            int x2 = sc.nextInt();\n            int y2 = sc.nextInt();\n            int x3 = sc.nextInt();\n            int y3 = sc.nextInt();\n            int x4 = sc.nextInt();\n            int y4 = sc.nextInt();\n            int r = sc.nextInt();\n            // 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n            // 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n            // 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n            // 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n            // 5行目 円の半径r（整数）\n            //\n            Point2D.Double[] ps = new Point2D.Double[4];\n            ps[0] = new Point2D.Double(x1, y1);\n            ps[1] = new Point2D.Double(x2, y2);\n            ps[2] = new Point2D.Double(x3, y3);\n            ps[3] = new Point2D.Double(x4, y4);\n            double max = 0;\n            for (int i = 0; i < 3; i++) {\n \n                max = Math.max(max, nor(ps[3], ps[i]));\n            }\n            if (r >= max) {\n                System.out.println(\"b\");\n                continue;\n            }\n            double min = Double.MAX_VALUE;\n            for (int i = 0; i < 3; i++) {\n \n                double dis = Math.max(\n                        new Line(ps[i], ps[(i + 1) % 3]).disToPoint(ps[3]),\n                        new Line(ps[(i + 1) % 3], ps[i]).disToPoint(ps[3]));\n                min = Math.min(min, dis);\n            }\n            double[] eps = new double[3];\n            for (int i = 0; i < 3; i++) {\n                eps[i] = new Line(ps[i], ps[3]).ep(new Line(ps[i],\n                        ps[(i + 1) % 3]));\n            }\n            boolean in = eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0\n                    || eps[0] < 0 && eps[1] < 0 && eps[2] < 0;\n            if (r <= min && in)\n                System.out.println(\"a\");\n            else if (!in && r < min)\n                System.out.println(\"d\");\n            else\n                System.out.println(\"c\");\n        }\n    }\n \n    public static double nor(Point2D.Double p, Point2D.Double q) {\n        return Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n    }\n}\n \n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n \nclass Line {\n    public Point2D.Double p1;\n    public Point2D.Double p2;\n \n    Line(Point2D.Double p1, Point2D.Double p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n \n    public double length() {\n        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n                * (p1.y - p2.y));\n    }\n \n    public double ip(Line l) {\n        Point2D.Double q1 = l.p1;\n        Point2D.Double q2 = l.p2;\n        return (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n    }\n \n    public double ep(Line l) {\n        Point2D.Double q1 = l.p1;\n        Point2D.Double q2 = l.p2;\n        return (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n    }\n \n    public double disToPoint(Point2D.Double q1) {\n        Line p1q1 = new Line(p1, q1);\n        double ip1 = p1q1.ip(this);\n        double ip2 = this.ip(this);\n        if (ip1 <= 0)\n            return p1q1.length();\n        else if (0 < ip1 && ip1 < ip2) {\n            double d2 = ip1 / this.length();\n            double size = p1q1.length();\n            return Math.sqrt(size * size - d2 * d2);\n        } else {\n            Line p2q1 = new Line(p2, q1);\n            return p2q1.length();\n        }\n    }\n \n    public boolean isCross(Line q1q2) {\n        Point2D.Double q1 = q1q2.p1;\n        Point2D.Double q2 = q1q2.p2;\n        Line p1q1 = new Line(p1, q1);\n        Line p1q2 = new Line(p1, q2);\n        Line q1p1 = new Line(q1, p1);\n        Line q1p2 = new Line(q1, p2);\n        if (this.ep(p1q1) * this.ep(p1q2) < 0\n                && q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n            return true;\n        else\n            return false;\n    }\n \n    public double minDistance(Line q1q2) {\n        if (this.isCross(q1q2))\n            return 0;\n        double ans = Double.MAX_VALUE;\n        Point2D.Double q1 = q1q2.p1;\n        Point2D.Double q2 = q1q2.p2;\n        ans = Math.min(ans, this.disToPoint(q1));\n        ans = Math.min(ans, this.disToPoint(q2));\n        ans = Math.min(ans, q1q2.disToPoint(p1));\n        ans = Math.min(ans, q1q2.disToPoint(p2));\n        return ans;\n    }\n \n    public String toString() {\n        return p1 + \"=>\" + p2;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tLine[] ls = new Line[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tls[i] = new Line(ps[i], ps[(i + 1) % 3]);\n\t\t\t\tdouble dis = ls[i].disToPoint(ps[3]);\n\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[3]).ep(ls[i]);\n\t\t\t}\n\t\t\tif (r < min) {\n\t\t\t\tif (eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0 || eps[0] < 0\n\t\t\t\t\t\t&& eps[1] < 0 && eps[2] < 0) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t} else {\n\t\t\t\tif (r >= max) {\n\t\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tScanner sc;\n\t\n\tclass Vector{\n\t\tpublic double x, y;\n\t\t\n\t\tpublic Vector(double x, double y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t\t\n\t\tpublic double norm(){\n\t\t\treturn Math.hypot(x, y);\n\t\t}\n\t\t\n\t\tpublic double sqrNorm(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\t\n\t\tpublic double ip(Vector v){\n\t\t\treturn x*v.x+y*v.y;\n\t\t}\n\t\t\n\t\tpublic Vector add(Vector v){\n\t\t\treturn new Vector(x+v.x, y+v.y);\n\t\t}\n\t\t\n\t\tpublic Vector subtract(Vector v){\n\t\t\treturn new Vector(x-v.x, y-v.y);\n\t\t}\n\t\t\n\t\tpublic Vector multiply(double a){\n\t\t\treturn new Vector(x*a, y*a);\n\t\t}\n\t}\n\t\n\tboolean inTriangle(Vector[] v){\n\t\tdouble theta=0;\n\t\tfor(int i=0;i<3;++i){\n\t\t\ttheta+=Math.acos(v[i].ip(v[(i+1)%3])/v[i].norm()/v[(i+1)%3].norm());\n\t\t}\n\t\treturn theta>=Math.PI*2-1e-7;\n\t}\n\t\n\tchar solve(Vector[] a, Vector p, double r){\n\t\tVector[] v=new Vector[3], e=new Vector[3];\n\t\t\n\t\tboolean isB=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tv[i]=a[i].subtract(p);\n\t\t\te[i]=a[(i+1)%3].subtract(a[i]);\n\t\t\tisB&=v[i].norm()<=r;\n\t\t}\n\t\tif(isB) return 'b';\n\t\t\n\t\tVector[] h=new Vector[3];\n\t\tboolean isA=true;\n\t\tfor(int i=0;i<3;++i){\n\t\t\t//点pより三角形の辺と直交するvector\n\t\t\t//hi=vi+(ei・(-vi)/|ei|^2)ei\n\t\t\th[i]=v[i].subtract(e[i].multiply(e[i].ip(v[i])/e[i].sqrNorm()));\n\t\t\tisA&=h[i].norm()>=r;\n\t\t}\n\t\tif(isA&&inTriangle(v)) return 'a';\n\t\t\n\t\tboolean isC=false;\n\t\tfor(int i=0;i<3;++i){\n\t\t\tVector n=h[i].add(p);\n\t\t\tif(v[i].norm()<=r||(n.subtract(a[i]).ip(n.subtract(a[(i+1)%3]))>0&&h[i].norm()<=r)){\n\t\t\t\tisC=true;\n\t\t\t}\n\t\t}\n\t\tif(isC) return 'c';\n\t\telse return 'd';\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint x=ni(),y=ni();\n\t\t\tif(x==0&y==0)break;\n\t\t\t\n\t\t\tVector[] a=new Vector[3];\n\t\t\t\n\t\t\tfor(int i=0;i<3;++i){\n\t\t\t\ta[i]=new Vector(x, y);\n\t\t\t\tx=ni(); y=ni();\n\t\t\t}\n\t\t\tVector p=new Vector(x, y);\n\t\t\tdouble r=ni();\n\t\t\t\n\t\t\tSystem.out.println(solve(a,p,r));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tnew Main().io();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n \npublic class Main {\n     \n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n \n        while (true) {\n            final int x1 = sc.nextInt();\n            final int y1 = sc.nextInt();\n             \n            if(x1 == 0 && y1 == 0){\n                break;\n            }\n             \n            final int x2 = sc.nextInt();\n            final int y2 = sc.nextInt();\n            final int x3 = sc.nextInt();\n            final int y3 = sc.nextInt();\n             \n            Point2D[][] lines = new Point2D[][]{\n                {new Point2D(x1, y1), new Point2D(x2, y2)},\n                {new Point2D(x2, y2), new Point2D(x3, y3)},\n                {new Point2D(x3, y3), new Point2D(x1, y1)}\n            };\n             \n            final int r_x = sc.nextInt();\n            final int r_y = sc.nextInt();\n            final int r = sc.nextInt();\n             \n            Point2D circle = new Point2D(r_x, r_y);\n             \n            boolean circle_flag = true;\n            for(int i = 0; i < 3; i++){\n                if(circle.dist(lines[i][0]) > r){\n                    circle_flag = false;\n                    break;\n                }\n            }\n             \n            if(circle_flag){\n                System.out.println(\"b\");\n                continue;\n            }\n             \n            boolean intersect = false;\n            for(int i = 0; i < 3; i++){\n                Point2D[] ret = new Point2D[2];\n                circle.interpoint_sc(lines[i][0], lines[i][1], circle, r, ret);\n                 \n                //System.out.println(Arrays.toString(ret));\n                 \n                if(ret[0] != null && ret[1] != null){\n                    intersect = true;\n                    break;\n                }\n            }\n             \n            if(intersect){\n                System.out.println(\"c\");\n                continue;\n            }\n             \n            double area = circle.area(lines[0][0], lines[1][0], lines[2][0]);\n            double sum = Math.abs(lines[0][0].cross(lines[1][0]) + lines[1][0].cross(lines[2][0]));\n            //System.out.println(area + \" \" + sum);\n             \n            if(area >= sum){\n                System.out.println(\"a\");\n            }else{\n                System.out.println(\"d\");\n            }\n             \n             \n        }\n    }\n     \n    public static class Point2D {\n        public double x;\n        public double y;\n \n        public static final double EPS = 1e-9;\n \n        public Point2D(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n \n        public Point2D(Point2D point) {\n            this.x = point.x;\n            this.y = point.y;\n        }\n \n        public String toString() {\n            return x + \",\" + y;\n        }\n \n        @Override\n        public boolean equals(Object o) {\n            if (o instanceof Point2D) {\n                Point2D another = (Point2D) o;\n                 \n                if(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n                    return true;\n                }\n                 \n                return false;\n            }\n            return false;\n        }\n \n        public Point2D add(double x, double y) {\n            return new Point2D(this.x + x, this.y + y);\n        }\n \n        public Point2D sub(double x, double y) {\n            return add(-x, -y);\n        }\n \n        public Point2D add(Point2D another) {\n            return add(another.x, another.y);\n        }\n \n        public Point2D sub(Point2D another) {\n            return sub(another.x, another.y);\n        }\n \n        public Point2D mul(double d) {\n            return new Point2D(this.x * d, this.y * d);\n        }\n \n        public Point2D div(double d) {\n            return new Point2D(this.x / d, this.y / d);\n        }\n \n        public double dot(double x, double y) {\n            return this.x * x + this.y * y;\n        }\n \n        public double dot(Point2D another) {\n            return dot(another.x, another.y);\n        }\n \n        public double cross(double x, double y) {\n            return this.x * y - this.y * x;\n        }\n \n        public double cross(Point2D another) {\n            return cross(another.x, another.y);\n        }\n \n        public double dist(double x, double y) {\n            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                    * (this.y - y));\n        }\n \n        public double dist(Point2D another) {\n            return dist(another.x, another.y);\n        }\n \n        public double dist_o() {\n            return dist(0, 0);\n        }\n \n        public Point2D unit() {\n            return div(dist_o());\n        }\n \n        public boolean pol(Point2D start, Point2D end) {\n            return end.sub(start).cross(this.sub(start)) < EPS;\n        }\n \n        public boolean pos(Point2D start, Point2D end) {\n            return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n        }\n \n        public double pld(Point2D start, Point2D end) {\n            return Math.abs((end.sub(start).cross(this.sub(start)))\n                    / end.sub(start).dist_o());\n        }\n \n        public double psd(Point2D start, Point2D end) {\n            if (end.sub(start).dot(this.sub(start)) < EPS) {\n                return this.dist(start);\n            } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n                return this.dist(end);\n            } else {\n                return Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n            }\n        }\n         \n        public static int signum(double x){\n            return Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n        }\n         \n        public static boolean eq(double x, double y){\n            return signum(x - y) == 0;\n        }\n         \n        public static int ccw(Point2D p, Point2D r, Point2D s){\n            Point2D a = r.sub(p);\n            Point2D b = s.sub(p);\n             \n            final int sgn = Point2D.signum(a.cross(b));\n            if(sgn != 0){\n                return sgn;\n            }else if(a.x * b.x < -EPS && a.y * b.y < -EPS){\n                return -1;\n            }else if(a.dist_o() < b.dist_o() - EPS){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n         \n        public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            return (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n                    && (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n        }\n \n        public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n        }\n \n        public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            Point2D b = b2.sub(b1);\n            double d1 = Math.abs(b.cross(a1.sub(b1)));\n            double d2 = Math.abs(b.cross(a2.sub(b1)));\n            double t = d1 / (d1 + d2);\n            Point2D a = a2.sub(a1), v = a.mul(t);\n            return a1.add(v);\n        }\n \n        public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            Point2D a = a2.sub(a1);\n            Point2D b = b2.sub(b1);\n            double t = b.cross(b1.sub(a1)) / b.cross(a);\n            Point2D v = a.mul(t);\n            return a1.add(v);\n        }\n \n        public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n                double r2) {\n            double dis = p1.dist(p2);\n \n            if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n                return new Point2D[0]; // same\n            }\n \n            if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n                Point2D tmp = p2.sub(p1);\n                tmp = tmp.mul(r1 / tmp.dist_o());\n                Point2D ret[] = new Point2D[1];\n                ret[0] = p1.add(tmp);\n                return ret;\n            } else if (dis + EPS > r1 + r2) {\n                return new Point2D[0]; // out\n            }\n \n            double dis_m = Math.abs(r1 - r2);\n \n            if (dis_m + EPS > dis && dis_m - EPS < dis) {\n                Point2D tmp = null;\n                if (r1 > r2) {\n                    tmp = p2.sub(p1);\n                } else {\n                    tmp = p1.sub(p2);\n                }\n \n                double min = Math.min(r1, r2);\n \n                tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n                Point2D ret[] = new Point2D[1];\n                ret[0] = p1.add(tmp);\n                return ret;\n            } else if (dis_m + EPS > dis) {\n                return new Point2D[0]; // inner\n            } else {\n                Point2D ret[] = new Point2D[2];\n \n                double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                        / (2 * dis * r1));\n                double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n                ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                        * Math.sin(a + theta) + p1.y);\n                ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                        * Math.sin(a - theta) + p1.y);\n                return ret;\n            }\n        }\n         \n        public static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n            if(Point2D.intersect_s(start1, end1, start2, end2)){\n                return 0;\n            }else{\n                return Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n            }\n        }\n         \n        public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n                Point2D ans[]) {\n            if (c.pld(start, end) > r + EPS)\n                return;\n            Point2D v = end.sub(start).unit();\n            double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                    - start.dist(c) * start.dist(c) + r * r;\n            double t = -v.dot(start.sub(c));\n            double s = Math.sqrt(delta);\n            ans[0] = start.add(v.mul(t + s));\n            ans[1] = start.add(v.mul(t + s));\n        }\n        \n        public void interpoint_sc(Point2D start, Point2D end, Point2D c, double r,\n                Point2D ans[]) {\n            if (c.psd(start, end) > r + EPS)\n                return;\n            Point2D v = end.sub(start).unit();\n            double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                    - start.dist(c) * start.dist(c) + r * r;\n            double t = -v.dot(start.sub(c));\n            double s = Math.sqrt(delta);\n            ans[0] = start.add(v.mul(t + s));\n            ans[1] = start.add(v.mul(t + s));\n        }\n        \n        public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n            Point2D v = b.sub(a).unit();\n            v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                    (-1) * v.y, v.x);\n            return v.mul(p.pld(a, b));\n        }\n \n        public double area(Point2D a, Point2D b, Point2D c) {\n            return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n        }\n \n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * AOJ id=0153\n * Triangle and Circle\n * @author scache\n *\n */\npublic class Main0153 {\n\tpublic static void main(String[] args) {\n\t\tMain0153 p = new Main0153();\n\t}\n\n\tpublic Main0153() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint[] x = new int[3];\n\t\t\tint[] y = new int[3];\n\t\t\tfor(int i=0;i<3;i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t\tif(i==0 && x[i]==0 && y[i]==0)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tint rx = sc.nextInt();\n\t\t\tint ry = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t\n\t\t\tSystem.out.println(solve(x, y, rx, ry, r));\n\t\t}\n\t}\n\n\tprivate String solve(int[] x, int[] y, int rx, int ry, int r) {\n\t\tint[] vx = new int[3];\n\t\tint[] vy = new int[3];\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tvx[i] = x[(i+1)%3]-x[i];\n\t\t\tvy[i] = y[(i+1)%3]-y[i];\n\t\t}\n\t\t\n\t\tint inCircle = 0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint xd = (x[i]-rx)*(x[i]-rx);\n\t\t\tint yd = (y[i]-ry)*(y[i]-ry);\n\t\t\tif(r*r >= xd+yd)\n\t\t\t\tinCircle++;\n\t\t}\n\t\tif(inCircle==3)\n\t\t\treturn \"b\";\n//\t\telse if(inCircle==1 || inCircle==2)\n//\t\t\t// 接している場合は三角形の中に円がはいっている可能性がある？\n//\t\t\treturn \"c\";\n\t\t\n\n\t\tint l=0;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(vx[i]*(ry-y[i])-(rx-x[i])*vy[i]<0)\n\t\t\t\tl++;\n\t\t}\n\t\tif(l==3 || l==0)\n\t\t\treturn \"a\";\n\t\t\n\t\t\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint vrx = rx-x[i];\n\t\t\tint vry = ry-y[i];\n\t\t\t\n\t\t\tint inp = vx[i]*vrx+vy[i]*vry;\n\t\t\tif(inp<0){\n\t\t\t\tif(vrx*vrx+vry*vry < r*r)\n\t\t\t\t\treturn \"c\";\n\t\t\t}else{\n\t\t\t\tif(inp > vx[i]*vx[i]+vy[i]*vy[i]){\n\t\t\t\t\tif((rx-x[(i+1)%3])*(rx-x[(i+1)%3])+(ry-y[(i+1)%3])*(ry-y[(i+1)%3]) <r*r)\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t}else{\n\t\t\t\t\tif(vrx*vrx+vry*vry-inp*inp < (long)(vx[i]*vx[i]+vy[i]*vy[i])*r*r){\n\t\t\t\t\t\treturn \"c\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn \"d\";\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tLine[] ls = new Line[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tls[i] = new Line(ps[i], ps[(i + 1) % 3]);\n\t\t\t\tdouble dis = ls[i].disToPoint(ps[3]);\n\t\t\t\tmax = Math.max(max, dis);\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[3]).ep(ls[i]);\n\t\t\t}\n\t\t\tif (r < min) {\n\t\t\t\tif (eps[0] >= 0 && eps[1] >= 0 && eps[2] >= 0 || eps[0] < 0\n\t\t\t\t\t\t&& eps[1] < 0 && eps[2] < 0) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t} else if (r >= min) {\n\t\t\t\tif (r > max) {\n\t\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tloop: while (true) {\n\t\t\tPoint2D.Double[] points = new Point2D.Double[4];\n\t\t\tint maxx = Integer.MIN_VALUE;\n\t\t\tint maxy = Integer.MIN_VALUE;\n\t\t\tint minx = Integer.MAX_VALUE;\n\t\t\tint miny = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint x = scanner.nextInt();\n\t\t\t\tint y = scanner.nextInt();\n\t\t\t\tif (i == 0 && x == 0 && y == 0) {\n\t\t\t\t\tbreak loop;\n\t\t\t\t}\n\t\t\t\tpoints[i] = new Point2D.Double(x, y);\n\t\t\t\tif (i != 3) {\n\t\t\t\t\tmaxx = Math.max(maxx, x);\n\t\t\t\t\tmaxy = Math.max(maxy, y);\n\t\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble r = scanner.nextDouble();\n\t\t\tLine2D.Double a = new Line2D.Double(points[1], points[2]);\n\t\t\tLine2D.Double b = new Line2D.Double(points[2], points[0]);\n\t\t\tLine2D.Double c = new Line2D.Double(points[0], points[1]);\n\t\t\tdouble d0 = points[3].distance(points[0]);\n\t\t\tdouble d1 = points[3].distance(points[1]);\n\t\t\tdouble d2 = points[3].distance(points[2]);\n\t\t\tdouble ap = a.ptSegDist(points[3]);\n\t\t\tdouble bp = b.ptSegDist(points[3]);\n\t\t\tdouble cp = c.ptSegDist(points[3]);\n\t\t\tPath2D.Double path = new Path2D.Double();\n\t\t\tpath.moveTo(points[0].x, points[0].y);\n\t\t\tpath.lineTo(points[1].x, points[1].y);\n\t\t\tpath.lineTo(points[2].x, points[2].y);\n\n\t\t\tif (d0 <= r && d1 <= r && d2 <= r) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t} else if (path.contains(points[3])) {\n\t\t\t\tif (ap > r && bp > r && cp > r) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (d0 >= r && d1 >= r && d2 >= r) {\n\t\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r * r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(Line.distanceSP(new Line(ps[i],\n\t\t\t\t\t\tps[(i + 1) % 3]), ps[3]), Line.distanceSP(new Line(\n\t\t\t\t\t\tps[i], ps[(i + 1) % 3]), ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble ep = Line.extp(Line.sub(ps[(i + 1) % 3], ps[i]),\n\t\t\t\t\t\tLine.sub(ps[3], ps[i]));\n\t\t\t\tif (ep < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (ep > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic static double distanceSP(Line s, Point2D.Double p) {\n\t\tPoint2D.Double r = proj(s, p);\n\t\tif (intersectSP(s, r))\n\t\t\treturn norm(sub(r, p));\n\t\treturn Math.min(norm(sub(s.p1, p)), norm(sub(s.p2, p)));\n\t}\n\n\tpublic static boolean intersectSP(Line s, Point2D.Double p) {\n\t\treturn ccw(s.p1, s.p2, p) == 0;\n\t}\n\n\tpublic static int ccw(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n\t\tPoint2D.Double p = sub(b, a);\n\t\tPoint2D.Double q = sub(c, a);\n\t\tif (extp(p, q) > EPS)\n\t\t\treturn 1; // counter clockwise\n\t\tif (extp(p, q) < -EPS)\n\t\t\treturn -1; // clockwise\n\t\tif (inp(p, q) < -EPS)\n\t\t\treturn 2; // c--a--b on line\n\t\tif (Math.abs(norm(p) - norm(q)) < EPS)\n\t\t\treturn -2; // a--b--c on line\n\t\treturn 0; // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic static Point2D.Double sub(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn new Point2D.Double(p1.x - p2.x, p1.y - p2.y);\n\t}\n\n\tpublic static Point2D.Double proj(Line l, Point2D.Double p) {\n\t\tdouble t = inp(sub(p, l.p1), sub(l.p1, l.p2))\n\t\t\t\t/ Math.pow(norm(sub(l.p1, l.p2)), 2);\n\t\tPoint2D.Double tp = sub(l.p1, l.p2);\n\t\treturn new Point2D.Double(l.p1.x + t * tp.x, l.p1.y + t * tp.y);\n\t}\n\n\tpublic static double inp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.x + p1.y * p2.y;\n\t}\n\n\tpublic static double extp(Point2D.Double p1, Point2D.Double p2) {\n\t\treturn p1.x * p2.y - p2.x * p1.y;\n\t}\n\n\tpublic static final double EPS = 1.0e-8;\n\n\tpublic static double norm(Point2D.Double p) {\n\t\treturn Math.hypot(p.x, p.y);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\t\n\tpublic int space(Point a, Point b, Point c){\n\t\treturn (a.x-c.x)*(b.y-c.y) - (a.y-c.y)*(b.x-c.x);\n\t}\n\tpublic double dist(Point a, Point b){\n\t\treturn Math.sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));\n\t}\n\tpublic double dist(Point a, Point b, Point c){\n\t\treturn Math.abs(space(a, b, c) / dist(a, b));\n\t}\n\tpublic boolean inOrOut(Triangle tr, Point p){\n\t\tdouble key = Math.signum(space(tr.a, tr.b, p)) + Math.signum(space(tr.b, tr.c, p)) + Math.signum(space(tr.c, tr.a, p));\n\t\treturn (Math.abs(key) == 3);\n\t}\n\tpublic void relation(Triangle tr, Circle c){\n\t/*\twriter.println(\"dist(tr.a, c.p) = \" + dist(tr.a, c.p));\n\t\twriter.println(\"dist(tr.b, c.p) = \" + dist(tr.b, c.p));\n\t\twriter.println(\"dist(tr.c, c.p) = \" + dist(tr.c, c.p));\n\t\twriter.println(\"space(tr.a, tr.b, c.p) = \" + space(tr.a, tr.b, c.p));\n\t\twriter.println(\"space(tr.b, tr.c, c.p) = \" + space(tr.b, tr.c, c.p));\n\t\twriter.println(\"space(tr.c, tr.a, c.p) = \" + space(tr.c, tr.a, c.p));\n\t\twriter.println(\"inOrOut(tr, c.p) = \" + inOrOut(tr, c.p));\n\t\twriter.println(\"dist(tr.a, tr.b, c.p) = \" + dist(tr.a, tr.b, c.p));\n\t\twriter.println(\"dist(tr.b, tr.c, c.p) = \" + dist(tr.b, tr.c, c.p));\n\t\twriter.println(\"dist(tr.c, tr.a, c.p) = \" + dist(tr.c, tr.a, c.p));*/\n\t\t\n\t\tif( dist(tr.a, c.p) <= c.r && dist(tr.b, c.p) <= c.r && dist(tr.c, c.p) <= c.r ){\n\t\t\twriter.println(\"b\");\n\t\t} else if( inOrOut(tr, c.p) && (dist(tr.a, tr.b, c.p) >= c.r && dist(tr.b, tr.c, c.p) >= c.r && dist(tr.c, tr.a, c.p) >= c.r) ){\n\t\t\twriter.println(\"a\");\n\t\t} else if( (dist(tr.a, tr.b, c.p) > c.r || Math.min(dist(tr.a, c.p), dist(tr.b, c.p)) > c.r) &&\n\t\t\t(dist(tr.b, tr.c, c.p) > c.r || Math.min(dist(tr.b, c.p), dist(tr.c, c.p)) > c.r) &&\n\t\t\t(dist(tr.c, tr.a, c.p) > c.r || Math.min(dist(tr.c, c.p), dist(tr.a, c.p)) > c.r) ){\n\t\t\twriter.println(\"d\");\n\t\t} else {\n\t\t\twriter.println(\"c\");\n\t\t}\n\t\treturn;\n\t}\n\t\t\t\n\tpublic void solve() throws IOException{\n\t\tint n, m;\n\t\twhile( (n = nextInt()) != 0 | (m = nextInt()) != 0 ){\n\t\t\tint p = nextInt(), q = nextInt(), r = nextInt(), s = nextInt();\n\t\t\tTriangle tr = new Triangle(n, m, p, q, r, s);\n\t\t\tint x = nextInt(), y = nextInt(), z = nextInt();\n\t\t\tCircle c = new Circle(x, y, z);\n\t\t\trelation(tr, c);\n\t\t}\n\t}\t\t\t\n\tpublic static void main (String args[]) throws IOException{\n\t\tnew Main().run();\n\t}\n\t\n\tBufferedReader reader;\n\tStringTokenizer tokenizer;\n\tPrintWriter writer;\n\t\n\tpublic void run() throws IOException{\n\t\ttry{\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\ttokenizer = null;\n\t\t\twriter = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\treader.close();\n\t\t\twriter.close();\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\tpublic int nextInt() throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\t\t\n\tpublic String nextToken() throws IOException{\n\t\twhile( tokenizer == null || !tokenizer.hasMoreTokens() ){\n\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t}\n\t\treturn tokenizer.nextToken();\n\t}\n}\n\nclass Triangle{\n\tPoint a;\n\tPoint b;\n\tPoint c;\n\tTriangle(int p, int q, int r, int s, int t, int u){\n\t\ta = new Point(p, q);\n\t\tb = new Point(r, s);\n\t\tc = new Point(t, u);\n\t}\n}\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\nclass Circle{\n\tPoint p;\n\tint r;\n\tCircle(int x, int y, int r){\n\t\tp = new Point(x, y);\n\t\tthis.r = r;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n \npublic class Main {\n     \n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n \n        while (true) {\n            final int x1 = sc.nextInt();\n            final int y1 = sc.nextInt();\n             \n            if(x1 == 0 && y1 == 0){\n                break;\n            }\n             \n            final int x2 = sc.nextInt();\n            final int y2 = sc.nextInt();\n            final int x3 = sc.nextInt();\n            final int y3 = sc.nextInt();\n             \n            Point2D[][] lines = new Point2D[][]{\n                {new Point2D(x1, y1), new Point2D(x2, y2)},\n                {new Point2D(x2, y2), new Point2D(x3, y3)},\n                {new Point2D(x3, y3), new Point2D(x1, y1)}\n            };\n             \n            final int r_x = sc.nextInt();\n            final int r_y = sc.nextInt();\n            final int r = sc.nextInt();\n             \n            Point2D circle = new Point2D(r_x, r_y);\n            \n            double min_line_dist = Double.MAX_VALUE;\n            double max_pt_dist = Double.MIN_VALUE;\n            for(int i = 0; i < 3; i++){\n                double cur = circle.dist(lines[i][0]);\n                max_pt_dist = Math.max(max_pt_dist, circle.dist(lines[i][0]));\n                min_line_dist = Math.min(min_line_dist, circle.psd(lines[i][0], lines[i][1]));\n                \n            }\n            \n            if(max_pt_dist < r){\n            \tSystem.out.println(\"b\");\n            \tcontinue;\n            }\n            \n            if(min_line_dist < r){\n            \tSystem.out.println(\"c\");\n            \tcontinue;\n            }\n            \n            double[] cross = new double[3];\n            for(int i = 0; i < 3; i++){\n            \tfor(int j = 0; j < 2; j++){\n            \t\tlines[i][j] = lines[i][j].sub(circle);\n            \t}\n            }\n            \n            for(int i = 0; i < 3; i++){\n            \tcross[i] = lines[i][0].cross(lines[i][1]);\n            \t//System.out.println(cross[i]);\n            }\n             \n            \n            if(cross[0] < 0 && cross[1] < 0 && cross[2] < 0 || cross[0] > 0 && cross[1] > 0 && cross[2] > 0){\n            \tSystem.out.println(\"a\");\n            }else{\n            \tSystem.out.println(\"d\");\n            }\n            \n             \n        }\n    }\n     \n    public static class Point2D {\n        public double x;\n        public double y;\n \n        public static final double EPS = 1e-9;\n \n        public Point2D(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n \n        public Point2D(Point2D point) {\n            this.x = point.x;\n            this.y = point.y;\n        }\n \n        public String toString() {\n            return x + \",\" + y;\n        }\n \n        @Override\n        public boolean equals(Object o) {\n            if (o instanceof Point2D) {\n                Point2D another = (Point2D) o;\n                 \n                if(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n                    return true;\n                }\n                 \n                return false;\n            }\n            return false;\n        }\n \n        public Point2D add(double x, double y) {\n            return new Point2D(this.x + x, this.y + y);\n        }\n \n        public Point2D sub(double x, double y) {\n            return add(-x, -y);\n        }\n \n        public Point2D add(Point2D another) {\n            return add(another.x, another.y);\n        }\n \n        public Point2D sub(Point2D another) {\n            return sub(another.x, another.y);\n        }\n \n        public Point2D mul(double d) {\n            return new Point2D(this.x * d, this.y * d);\n        }\n \n        public Point2D div(double d) {\n            return new Point2D(this.x / d, this.y / d);\n        }\n \n        public double dot(double x, double y) {\n            return this.x * x + this.y * y;\n        }\n \n        public double dot(Point2D another) {\n            return dot(another.x, another.y);\n        }\n \n        public double cross(double x, double y) {\n            return this.x * y - this.y * x;\n        }\n \n        public double cross(Point2D another) {\n            return cross(another.x, another.y);\n        }\n \n        public double dist(double x, double y) {\n            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y)\n                    * (this.y - y));\n        }\n \n        public double dist(Point2D another) {\n            return dist(another.x, another.y);\n        }\n \n        public double dist_o() {\n            return dist(0, 0);\n        }\n \n        public Point2D unit() {\n            return div(dist_o());\n        }\n \n        public boolean pol(Point2D start, Point2D end) {\n            return end.sub(start).cross(this.sub(start)) < EPS;\n        }\n \n        public boolean pos(Point2D start, Point2D end) {\n            return (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n        }\n \n        public double pld(Point2D start, Point2D end) {\n            return Math.abs((end.sub(start).cross(this.sub(start)))\n                    / end.sub(start).dist_o());\n        }\n \n        public double psd(Point2D start, Point2D end) {\n            if (end.sub(start).dot(this.sub(start)) < EPS) {\n                return this.dist(start);\n            } else if (start.sub(end).dot(this.sub(end)) < EPS) {\n                return this.dist(end);\n            } else {\n                return Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n            }\n        }\n         \n        public static int signum(double x){\n            return Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n        }\n         \n        public static boolean eq(double x, double y){\n            return signum(x - y) == 0;\n        }\n         \n        public static int ccw(Point2D p, Point2D r, Point2D s){\n            Point2D a = r.sub(p);\n            Point2D b = s.sub(p);\n             \n            final int sgn = Point2D.signum(a.cross(b));\n            if(sgn != 0){\n                return sgn;\n            }else if(a.x * b.x < -EPS && a.y * b.y < -EPS){\n                return -1;\n            }else if(a.dist_o() < b.dist_o() - EPS){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n         \n        public static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            return (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n                    && (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n        }\n \n        public static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            return a1.sub(a2).cross(b1.sub(b2)) < EPS;\n        }\n \n        public static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            Point2D b = b2.sub(b1);\n            double d1 = Math.abs(b.cross(a1.sub(b1)));\n            double d2 = Math.abs(b.cross(a2.sub(b1)));\n            double t = d1 / (d1 + d2);\n            Point2D a = a2.sub(a1), v = a.mul(t);\n            return a1.add(v);\n        }\n \n        public static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n                Point2D b2) {\n            Point2D a = a2.sub(a1);\n            Point2D b = b2.sub(b1);\n            double t = b.cross(b1.sub(a1)) / b.cross(a);\n            Point2D v = a.mul(t);\n            return a1.add(v);\n        }\n \n        public static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n                double r2) {\n            double dis = p1.dist(p2);\n \n            if (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n                return new Point2D[0]; // same\n            }\n \n            if (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n                Point2D tmp = p2.sub(p1);\n                tmp = tmp.mul(r1 / tmp.dist_o());\n                Point2D ret[] = new Point2D[1];\n                ret[0] = p1.add(tmp);\n                return ret;\n            } else if (dis + EPS > r1 + r2) {\n                return new Point2D[0]; // out\n            }\n \n            double dis_m = Math.abs(r1 - r2);\n \n            if (dis_m + EPS > dis && dis_m - EPS < dis) {\n                Point2D tmp = null;\n                if (r1 > r2) {\n                    tmp = p2.sub(p1);\n                } else {\n                    tmp = p1.sub(p2);\n                }\n \n                double min = Math.min(r1, r2);\n \n                tmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n \n                Point2D ret[] = new Point2D[1];\n                ret[0] = p1.add(tmp);\n                return ret;\n            } else if (dis_m + EPS > dis) {\n                return new Point2D[0]; // inner\n            } else {\n                Point2D ret[] = new Point2D[2];\n \n                double theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n                        / (2 * dis * r1));\n                double a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n \n                ret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n                        * Math.sin(a + theta) + p1.y);\n                ret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n                        * Math.sin(a - theta) + p1.y);\n                return ret;\n            }\n        }\n         \n        public static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n            if(Point2D.intersect_s(start1, end1, start2, end2)){\n                return 0;\n            }else{\n                return Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n            }\n        }\n         \n        public void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n                Point2D ans[]) {\n            if (c.pld(start, end) > r + EPS)\n                return;\n            Point2D v = end.sub(start).unit();\n            double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                    - start.dist(c) * start.dist(c) + r * r;\n            double t = -v.dot(start.sub(c));\n            double s = Math.sqrt(delta);\n            ans[0] = start.add(v.mul(t + s));\n            ans[1] = start.add(v.mul(t + s));\n        }\n        \n        public void interpoint_sc(Point2D start, Point2D end, Point2D c, double r,\n                Point2D ans[]) {\n            if (c.psd(start, end) > r + EPS)\n                return;\n            Point2D v = end.sub(start).unit();\n            double delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n                    - start.dist(c) * start.dist(c) + r * r;\n            double t = -v.dot(start.sub(c));\n            double s = Math.sqrt(delta);\n            ans[0] = start.add(v.mul(t + s));\n            ans[1] = start.add(v.mul(t + s));\n        }\n        \n        public Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n            Point2D v = b.sub(a).unit();\n            v = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n                    (-1) * v.y, v.x);\n            return v.mul(p.pld(a, b));\n        }\n \n        public double area(Point2D a, Point2D b, Point2D c) {\n            return Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n        }\n \n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tsc.useDelimiter(\",|\\\\s+\");\n\t\twhile (true) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tif ((x1 | y1) == 0)\n\t\t\t\tbreak;\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint x3 = sc.nextInt();\n\t\t\tint y3 = sc.nextInt();\n\t\t\tint x4 = sc.nextInt();\n\t\t\tint y4 = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\t// 1行目 三角形の第1の頂点の座標x1 y1（整数 整数；半角空白区切り）\n\t\t\t// 2行目 三角形の第2の頂点の座標x2 y2（整数 整数；半角空白区切り）\n\t\t\t// 3行目 三角形の第3の頂点の座標x3 y3（整数 整数；半角空白区切り）\n\t\t\t// 4行目 円の中心の座標x4 y4（整数 整数；半角空白区切り）\n\t\t\t// 5行目 円の半径r（整数）\n\t\t\t//\n\t\t\tPoint2D.Double[] ps = new Point2D.Double[4];\n\t\t\tps[0] = new Point2D.Double(x1, y1);\n\t\t\tps[1] = new Point2D.Double(x2, y2);\n\t\t\tps[2] = new Point2D.Double(x3, y3);\n\t\t\tps[3] = new Point2D.Double(x4, y4);\n\t\t\tdouble max = 0;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\n\t\t\t\tmax = Math.max(max, nor(ps[3], ps[i]));\n\t\t\t}\n\t\t\tif (r >= max) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tdouble dis = Math.max(\n\t\t\t\t\t\tnew Line(ps[i], ps[(i + 1) % 3]).disToPoint(ps[3]),\n\t\t\t\t\t\tnew Line(ps[(i + 1) % 3], ps[i]).disToPoint(ps[3]));\n\t\t\t\tmin = Math.min(min, dis);\n\t\t\t}\n\t\t\tdouble[] eps = new double[3];\n\t\t\tboolean right = true;\n\t\t\tboolean left = true;\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\teps[i] = new Line(ps[i], ps[(i + 1) % 3]).ep(new Line(ps[i],\n\t\t\t\t\t\tps[3]));\n\t\t\t\tif (eps[i] < 0)\n\t\t\t\t\tleft = false;\n\t\t\t\telse if (eps[i] > 0)\n\t\t\t\t\tright = false;\n\t\t\t}\n\t\t\tboolean in = left | right;\n\t\t\tif (r <= min && in)\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\telse if (!in && r < min)\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\telse\n\t\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t}\n\n\tpublic static double nor(Point2D.Double p, Point2D.Double q) {\n\t\treturn Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));\n\t}\n}\n\n// Output\n//\n// 入力データセットごとに以下の判定結果を出力します。\n//\n// 円が三角形に含まれる場合 a\n// 三角形が円に含まれる場合 b\n// それ以外の場合で、共通部分がある場合には c\n// 共通部分がない場合には d\n\nclass Line {\n\tpublic Point2D.Double p1;\n\tpublic Point2D.Double p2;\n\n\tLine(Point2D.Double p1, Point2D.Double p2) {\n\t\tthis.p1 = p1;\n\t\tthis.p2 = p2;\n\t}\n\n\tpublic double length() {\n\t\treturn Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y)\n\t\t\t\t* (p1.y - p2.y));\n\t}\n\n\tpublic double ip(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.x - q1.x) + (p2.y - p1.y) * (q2.y - q1.y);\n\t}\n\n\tpublic double ep(Line l) {\n\t\tPoint2D.Double q1 = l.p1;\n\t\tPoint2D.Double q2 = l.p2;\n\t\treturn (p2.x - p1.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q2.x - q1.x);\n\t}\n\n\tpublic double disToPoint(Point2D.Double q1) {\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tdouble ip1 = p1q1.ip(this);\n\t\tdouble ip2 = this.ip(this);\n\t\tif (ip1 <= 0)\n\t\t\treturn p1q1.length();\n\t\telse if (0 < ip1 && ip1 < ip2) {\n\t\t\tdouble d2 = ip1 / this.length();\n\t\t\tdouble size = p1q1.length();\n\t\t\treturn Math.sqrt(size * size - d2 * d2);\n\t\t} else {\n\t\t\tLine p2q1 = new Line(p2, q1);\n\t\t\treturn p2q1.length();\n\t\t}\n\t}\n\n\tpublic boolean isCross(Line q1q2) {\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tLine p1q1 = new Line(p1, q1);\n\t\tLine p1q2 = new Line(p1, q2);\n\t\tLine q1p1 = new Line(q1, p1);\n\t\tLine q1p2 = new Line(q1, p2);\n\t\tif (this.ep(p1q1) * this.ep(p1q2) < 0\n\t\t\t\t&& q1q2.ep(q1p1) * q1q2.ep(q1p2) < 0)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic double minDistance(Line q1q2) {\n\t\tif (this.isCross(q1q2))\n\t\t\treturn 0;\n\t\tdouble ans = Double.MAX_VALUE;\n\t\tPoint2D.Double q1 = q1q2.p1;\n\t\tPoint2D.Double q2 = q1q2.p2;\n\t\tans = Math.min(ans, this.disToPoint(q1));\n\t\tans = Math.min(ans, this.disToPoint(q2));\n\t\tans = Math.min(ans, q1q2.disToPoint(p1));\n\t\tans = Math.min(ans, q1q2.disToPoint(p2));\n\t\treturn ans;\n\t}\n\n\tpublic String toString() {\n\t\treturn p1 + \"=>\" + p2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.IOException;\n\npublic class Main {\n\t/**\n\t * @param args\n\t */\n\tstatic class Shape {\n\t\tpublic\tint\tx = 0;\n\t\tpublic\tint\ty = 0;\n\t\tpublic\tint\tr = 0;\n\n\t\tpublic Shape(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic Shape(int x, int y, int r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tstatic class Line {\n\t\tpublic\tShape\tps = null;\n\t\tpublic\tShape\tpe = null;\n\t\tpublic\tint\t\ta  = 0;\n\t\tpublic\tint\t\tb  = 0;\n\t\tpublic\tint\t\tc  = 0;\n\n\t\tpublic Line(Shape ps, Shape pe) {\n\t\t\tthis.ps = ps;\n\t\t\tthis.pe = pe;\n\t\t\tthis.a  = pe.y-ps.y;\n\t\t\tthis.b  = ps.x-pe.x;\n\t\t\tthis.c  = -(a*ps.x+b*ps.y);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tShape[]\ts = null;\n\n\t\twhile((s = inp()) != null) {\n\t\t\tsolve(s[0], s[1], s[2], s[3]);\n\t\t}\n\t}\n\n\tprivate static void solve(Shape p1, Shape p2, Shape p3, Shape c) {\n\t\t{\n\t\t\tint\trr = (c.r*c.r);\n\t\t\tint\td0 = (c.x-p1.x)*(c.x-p1.x)+(c.x-p1.y)*(c.y-p1.y);\n\t\t\tint\td1 = (c.x-p2.x)*(c.x-p2.x)+(c.x-p2.y)*(c.y-p2.y);\n\t\t\tint\td2 = (c.x-p3.x)*(c.x-p3.x)+(c.x-p3.y)*(c.y-p3.y);\n\n\t\t\t// 三角形が円の内部に含まれるか\n\t\t\tif (d0 <= rr && d1 <= rr && d2 <= rr) {\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t{\n\t\t\tint\t\tn1 = crossSign(p1, p2, c);\n\t\t\tint\t\tn2 = crossSign(p2, p3, c);\n\t\t\tint\t\tn3 = crossSign(p3, p1, c);\n\t\t\tLine\tl1 = new Line(p1, p2);\n\t\t\tLine\tl2 = new Line(p2, p3);\n\t\t\tLine\tl3 = new Line(p3, p1);\n\n\t\t\t// 円の中心が三角形の内部に含まれるか\n\t\t\tif ((n1 == n2) && (n2 == n3)) {\n\t\t\t\tint\tc1 = checkDist(l1, c);\n\t\t\t\tint\tc2 = checkDist(l2, c);\n\t\t\t\tint\tc3 = checkDist(l3, c);\n\n\t\t\t\t// 円が三角形内部に含まれるか\n\t\t\t\tif (c1 <= 0 && c2 <= 0 && c3 <= 0) {\n\t\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 円と線分が交わるか\n\t\t\t\tif (checkCross(l1, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (checkCross(l2, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (checkCross(l2, c)) {\n\t\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(\"d\");\n\t}\n\n\tprivate static boolean checkCross(Line l, Shape c) {\n\t\tLine2D.Double ld = new Line2D.Double(l.ps.x, l.ps.y, l.pe.x, l.pe.y);\n\t\treturn (ld.ptSegDistSq(c.x, c.y) <= (double)(c.r*c.r))?true:false;\n\t}\n\n\tprivate static int checkDist(Line l, Shape p) {\n\t\tint\ts = p.r*p.r*(l.a*l.a+l.b*l.b);\n\t\tint\tt = (l.a*p.x+l.b*p.y+l.c)*(l.a*p.x+l.b*p.y+l.c);\n\t\treturn (s==t)?0:((s<t)?-1:1);\n\t}\n\n\tprivate static int crossSign(Shape s1, Shape s2, Shape s3) {\n\t\tint[]\tvab = { s2.x-s1.x, s2.y-s1.y };\n\t\tint[]\tvap = { s3.x-s1.x, s3.y-s1.y };\n\t\tint\t\tsgn = cross(vab, vap);\n\t\treturn (sgn==0)?0:((sgn>0)?1:-1);\n\t}\n\n\tprivate static int cross(int[] va, int[] vb) {\n\t\treturn va[0]*vb[1]-va[1]*vb[0];   // x1*x2 + y1*y2\n\t}\n\n\tprivate static Shape[] inp() {\n\t\tShape[]\td = new Shape[4];\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (i < 3) {\n\t\t\t\tint[]\tp = { parseNum(), parseNum() };\n\t\t\t\tif (p[0] == 0 && p[1] == 0) return null;\n\t\t\t\td[i] = new Shape(p[0], p[1]);\n\t\t\t} else {\n\t\t\t\tint[]\tp = { parseNum(), parseNum(), parseNum() };\n\t\t\t\td[i] = new Shape(p[0], p[1], p[2]);\n\t\t\t}\n\t\t}\n\n\t\treturn d;\n\t}\n\n\tprivate static int parseNum() {\n\t\ttry {\n\t\t\tint\tbuf = 0;\n\t\t\tint\tnum = 0;\n\t\t\tint\tmns = 0;\n\t\t\tint\tskp = 1;\n\n\t\t\t// -,0〜9以外は読み飛ばす\n\t\t\twhile (true) {\n\t\t\t\tbuf = System.in.read();\n\t\t\t\tif (buf == '-') {\n\t\t\t\t\tmns = 1;\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if (buf >= '0' && buf <= '9') {\n\t\t\t\t\tnum = num * 10 + (buf - '0');\n\t\t\t\t\tskp = 0;\n\t\t\t\t} else if ((skp == 0 || buf == -1) && buf != '.') {\n\t\t\t\t\treturn (mns == 0)?num:num*(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {}\n\t\treturn -1;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                if (input.All(n => n == 0)) break;\n\n                Point a = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point b = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point c = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point p = new Point(input[0], input[1]);\n                double r = double.Parse(Console.ReadLine());\n\n                double pa = (a - p).Abs;\n                double pb = (b - p).Abs;\n                double pc = (c - p).Abs;\n\n                if (pa <= r && pb <= r && pc <= r)\n                {\n                    sb.AppendLine(\"b\");\n                }\n                else\n                {\n                    if (IsPInside(a, b, c, p))\n                    {\n                        sb.AppendLine(CheckPIn(a, b, c, p, r));\n                    }\n                    else\n                    {\n                        sb.AppendLine(CheckPOut(a, b, c, p, r));\n                    }\n                }\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsPInside(Point a, Point b, Point c, Point p)\n        {\n            double c1 = (b - a).Cross(p - b);\n            double c2 = (c - b).Cross(p - c);\n            double c3 = (a - c).Cross(p - a);\n\n            if (c1 > 0 && c2 > 0 && c3 > 0) return true;\n            if (c1 < 0 && c2 < 0 && c3 < 0) return true;\n            return false;\n        }\n\n        static string CheckPIn(Point a, Point b, Point c, Point p, double r)\n        {\n            double sp1 = GetDistSP(a, b, p);\n            double sp2 = GetDistSP(b, c, p);\n            double sp3 = GetDistSP(c, a, p);\n\n            if (sp1 >= r && sp2 >= r && sp3 >= r) return \"a\";\n            return \"c\";\n        }\n\n        static string CheckPOut(Point a, Point b, Point c, Point p, double r)\n        {\n            double sp1 = GetDistSP(a, b, p);\n            double sp2 = GetDistSP(b, c, p);\n            double sp3 = GetDistSP(c, a, p);\n\n            if (sp1 > r && sp2 > r && sp3 > r) return \"d\";\n            return \"c\";\n        }\n\n        static double GetDistSP(Point a, Point b, Point p)\n        {\n            if ((b - a).Dot(p - a) < 0.0) return (p - a).Abs;\n            if ((a - b).Dot(p - b) < 0.0) return (p - b).Abs;\n            return GetDistLP(a, b, p);\n        }\n\n        static double GetDistLP(Point a, Point b, Point p)\n        {\n            return Math.Abs((b - a).Cross(p - a) / (b - a).Abs);\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                if (input.All(n => n == 0)) break;\n\n                Point a = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point b = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point c = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point p = new Point(input[0], input[1]);\n                double r = double.Parse(Console.ReadLine());\n\n                double pa = (a - p).Abs;\n                double pb = (b - p).Abs;\n                double pc = (c - p).Abs;\n\n                if (pa <= r && pb <= r && pc <= r)\n                {\n                    sb.AppendLine(\"b\");\n                }\n                else\n                {\n                    if (IsPInside(a, b, c, p))\n                    {\n                        sb.AppendLine(CheckPIn(a, b, c, p, r));\n                    }\n                    else\n                    {\n                        sb.AppendLine(CheckPOut(a, b, c, p, r));\n                    }\n                }\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsPInside(Point a, Point b, Point c, Point p)\n        {\n            double c1 = (b - a).Cross(p - b);\n            double c2 = (c - b).Cross(p - c);\n            double c3 = (a - c).Cross(p - a);\n\n            if (c1 > 0 && c2 > 0 && c3 > 0) return true;\n            if (c1 < 0 && c2 < 0 && c3 < 0) return true;\n            return false;\n        }\n\n        static string CheckPIn(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 >= r && lp2 >= r && lp3 >= r) return \"a\";\n            return \"c\";\n        }\n\n        static string CheckPOut(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"d\";\n            return \"c\";\n        }\n\n        static double GetDistSP(Point a, Point b, Point p)\n        {\n            if ((b - a).Dot(p - a) < 0.0) return (p - a).Abs;\n            if ((a - b).Dot(p - b) < 0.0) return (p - b).Abs;\n            return GetDistLP(a, b, p);\n        }\n\n        static double GetDistLP(Point a, Point b, Point p)\n        {\n            return Math.Abs((b - a).Cross(p - a) / (b - a).Abs);\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    struct Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                if (input.All(n => n == 0)) break;\n\n                Point a = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point b = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point c = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point p = new Point(input[0], input[1]);\n                double r = double.Parse(Console.ReadLine());\n\n                if (IsPInside(a, b, c, p))\n                {\n                    sb.AppendLine(CheckPIn(a, b, c, p, r));\n                }\n                else\n                {\n                    sb.AppendLine(CheckPOut(a, b, c, p, r));\n                }\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsPInside(Point a, Point b, Point c, Point p)\n        {\n            double c1 = (b - a).Cross(p - b);\n            double c2 = (c - b).Cross(p - c);\n            double c3 = (a - c).Cross(p - a);\n\n            if (c1 > EPS && c2 > EPS && c3 > EPS) return true;\n            if (c1 < -EPS && c2 < -EPS && c3 < -EPS) return true;\n            return false;\n        }\n\n        static string CheckPIn(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"a\";\n\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa < r && pb < r && pc < r) return \"b\";\n\n            return \"c\";\n        }\n\n        static string CheckPOut(Point a, Point b, Point c, Point p, double r)\n        {\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa < r && pb < r && pc < r) return \"b\";\n\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (pa > r && lp1 > r &&\n                pb > r && lp2 > r &&\n                pc > r && lp3 > r) return \"d\";\n\n            return \"c\";\n        }\n\n        static double GetDistSP(Point a, Point b, Point p)\n        {\n            if ((b - a).Dot(p - a) < 0.0) return (p - a).Abs;\n            if ((a - b).Dot(p - b) < 0.0) return (p - b).Abs;\n            return GetDistLP(a, b, p);\n        }\n\n        static double GetDistLP(Point a, Point b, Point p)\n        {\n            return Math.Abs((b - a).Cross(p - a) / (b - a).Abs);\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    struct Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    struct Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0153\n{\n    public class Program\n\n    {\n        const double EPS = 1E-10;\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] aXY = RIntAr(); if (aXY.Sum() == 0) break;\n                int[] bXY = RIntAr();\n                int[] cXY = RIntAr();\n                int[] pXY = RIntAr();\n                int r = RInt();\n\n                bool isCenterInTrianle = IsPointInTrianle(pXY, aXY, bXY, cXY);\n\n                if (getDistance(pXY, aXY) <= r * r && getDistance(pXY, bXY) <= r * r && getDistance(pXY, cXY) <= r * r)\n                {\n                    Console.WriteLine(\"b\");\n                }\n                else if (isCenterInTrianle == true && getDistance(pXY, aXY, bXY) >= r * r && getDistance(pXY, bXY, cXY) >= r * r && getDistance(pXY, cXY, aXY) >= r * r)\n                {\n                    Console.WriteLine(\"a\");\n                }\n                else if (isCenterInTrianle == false && getDistance(pXY, aXY, bXY) > r * r && getDistance(pXY, bXY, cXY) > r * r && getDistance(pXY, cXY, aXY) > r * r)\n                {\n                    Console.WriteLine(\"d\");\n                }\n                else\n                {\n                    Console.WriteLine(\"c\");\n                }\n            }\n        }\n\n        private static bool IsPointInTrianle(int[] pXY, int[] aXY, int[] bXY, int[] cXY)\n        {\n            Vector a = new Vector(aXY[0], aXY[1]);\n            Vector b = new Vector(bXY[0], bXY[1]);\n            Vector c = new Vector(cXY[0], cXY[1]);\n            Vector p = new Vector(pXY[0], pXY[1]);\n\n            double c1 = Vector.CrossProduct(b - a, p - b);\n            double c2 = Vector.CrossProduct(c - b, p - c);\n            double c3 = Vector.CrossProduct(a - c, p - a);\n\n            if ((c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0)) return true;\n            else return false;\n        }\n\n        private static int getDistance(int[] pXY, int[] aXY)\n        {\n            int a = (int)Math.Pow(Math.Abs(pXY[0] - aXY[0]), 2);\n            int b = (int)Math.Pow(Math.Abs(pXY[1] - aXY[1]), 2);\n            return a + b;\n        }\n\n        private static double getDistance(int[] pXY, int[] aXY, int[] bXY)\n        {\n            return Vector.RangeOfPointAndLineSegment(aXY[0], aXY[1], bXY[0], bXY[1], pXY[0], pXY[1]);\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n\n        public partial struct Vector : IFormattable\n        {\n\n            #region Internal Fields\t\n            internal double _x;\n            internal double _y;\n            #endregion Internal Fields\t\n\n            #region Public Properties\t\n            public double X { get { return _x; } set { _x = value; } }\n            public double Y { get { return _y; } set { _y = value; } }\n            #endregion Public Properties\n\n            #region Constructors\n            public Vector(double x, double y) { _x = x; _y = y; }\n            public Vector(double[] line) { _x = line[0]; _y = line[1]; }\n            #endregion Constructors\n\n            #region Public Methods\t\n            public static bool operator ==(Vector vector1, Vector vector2) { return vector1.X == vector2.X && vector1.Y == vector2.Y; }\n            public static bool operator !=(Vector vector1, Vector vector2) { return !(vector1 == vector2); }\n            public static bool Equals(Vector vector1, Vector vector2) { return vector1.X.Equals(vector2.X) && vector1.Y.Equals(vector2.Y); }\n            public override bool Equals(object o)\n            {\n                if ((null == o) || !(o is Vector)) return false;\n                Vector value = (Vector)o;\n                return Vector.Equals(this, value);\n            }\n            public bool Equals(Vector value) { return Vector.Equals(this, value); }\n            public override int GetHashCode() { return X.GetHashCode() ^ Y.GetHashCode(); }\n            #endregion Public Methods\t\n\n            #region Internal Properties\t\n            public override string ToString() { return ConvertToString(null /* format string */, null /* format provider */); }\n            public string ToString(IFormatProvider provider) { return ConvertToString(null /* format string */, provider); }\n            string IFormattable.ToString(string format, IFormatProvider provider) { return ConvertToString(format, provider); }\n            internal string ConvertToString(string format, IFormatProvider provider)\n            {\n                char separator = ' ';\n                return String.Format(provider, \"{1:\" + format + \"}{0}{2:\" + format + \"}\", separator, _x, _y);\n            }\n            #endregion Internal Properties\t\n\n            #region Public Methods\n\n            public double Length { get { return Math.Sqrt(_x * _x + _y * _y); } }\n            public double LengthSquared { get { return _x * _x + _y * _y; } }\n            public void Normalize()\n            {\n                this /= Math.Max(Math.Abs(_x), Math.Abs(_y));\n                this /= Length;\n            }\n\n            public static double CrossProduct(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n            public static double AngleBetween(Vector vector1, Vector vector2)\n            {\n                double sin = vector1._x * vector2._y - vector2._x * vector1._y;\n                double cos = vector1._x * vector2._x + vector1._y * vector2._y;\n                return Math.Atan2(sin, cos) * (180 / Math.PI);\n            }\n\n            public static Vector Rotation(Vector v, double angle) { return Rotation(v, angle, new Vector(0, 0)); }\n            public static Vector Rotation(Vector v, double angle, Vector basePoint)\n            {\n                double rad = angle * Math.PI / 180;\n                Vector res = new Vector();\n                res.X = (v.X - basePoint.X) * Math.Cos(rad) - (v.Y - basePoint.Y) * Math.Sin(rad) + basePoint.X;\n                res.Y = (v.X - basePoint.X) * Math.Sin(rad) + (v.Y - basePoint.Y) * Math.Cos(rad) + basePoint.Y;\n                return res;\n            }\n\n            /// <summary>\n            /// 線分ABと点Pの距離を求める\n            /// </summary>\n            /// <param name=\"sx\">線分ABの始点x座標</param>\n            /// <param name=\"sy\">線分ABの始点y座標</param>\n            /// <param name=\"ex\">線分ABの終点x座標</param>\n            /// <param name=\"ey\">線分ABの終点y座標</param>\n            /// <param name=\"px\">地点Pのx座標</param>\n            /// <param name=\"py\">地点Pのy座標</param>\n            /// <returns></returns>\n            public static int RangeOfPointAndLineSegment(double sx, double sy, double ex, double ey, double px, double py)\n            {\n                Vector A = new Vector(sx, sy);\n                Vector B = new Vector(ex, ey);\n                Vector P = new Vector(px, py);\n                return (int)(P - CalcClosestPointOnLineSegment(A, B, P)).LengthSquared;\n            }\n\n            private static Vector CalcClosestPointOnLineSegment(Vector A, Vector B, Vector P)\n            {\n\n                Vector a = B - A;\n                Vector b = P - A;\n                double r = (a * b) / (a * a);\n\n                if (r <= 0) return A;\n                else if (r >= 1) return B;\n                else return A + r * a;\n            }\n\n\n            #endregion Public Methods\n\n            #region Public Operators\n\n            public static Vector operator -(Vector vector) { return new Vector(-vector._x, -vector._y); }\n            public void Negate() { _x = -_x; _y = -_y; }\n            public static Vector operator +(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n            public static Vector Add(Vector vector1, Vector vector2) { return new Vector(vector1._x + vector2._x, vector1._y + vector2._y); }\n            public static Vector operator -(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n            public static Vector Subtract(Vector vector1, Vector vector2) { return new Vector(vector1._x - vector2._x, vector1._y - vector2._y); }\n            public static Vector operator *(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n            public static Vector Multiply(Vector vector, double scalar) { return new Vector(vector._x * scalar, vector._y * scalar); }\n            public static Vector operator *(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n            public static Vector Multiply(double scalar, Vector vector) { return new Vector(vector._x * scalar, vector._y * scalar); }\n            public static Vector operator /(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n            public static Vector Divide(Vector vector, double scalar) { return vector * (1.0 / scalar); }\n            public static double operator *(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n            public static double Multiply(Vector vector1, Vector vector2) { return vector1._x * vector2._x + vector1._y * vector2._y; }\n            public static double Determinant(Vector vector1, Vector vector2) { return vector1._x * vector2._y - vector1._y * vector2._x; }\n\n            #endregion Public Operators\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                if (input.All(n => n == 0)) break;\n\n                Point a = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point b = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point c = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point p = new Point(input[0], input[1]);\n                double r = double.Parse(Console.ReadLine());\n\n                double pa = (a - p).Abs;\n                double pb = (b - p).Abs;\n                double pc = (c - p).Abs;\n\n                if (pa <= r && pb <= r && pc <= r)\n                {\n                    sb.AppendLine(\"b\");\n                }\n                else\n                {\n                    if (IsPInside(a, b, c, p))\n                    {\n                        sb.AppendLine(CheckPIn(a, b, c, p, r));\n                    }\n                    else\n                    {\n                        sb.AppendLine(CheckPOut(a, b, c, p, r));\n                    }\n                }\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsPInside(Point a, Point b, Point c, Point p)\n        {\n            double c1 = (b - a).Cross(p - b);\n            double c2 = (c - b).Cross(p - c);\n            double c3 = (a - c).Cross(p - a);\n\n            if (c1 > 0 && c2 > 0 && c3 > 0) return true;\n            if (c1 < 0 && c2 < 0 && c3 < 0) return true;\n            return false;\n        }\n\n        static string CheckPIn(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 >= r && lp2 >= r && lp3 >= r) return \"a\";\n            \n            return \"c\";\n        }\n\n        static string CheckPOut(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"d\";\n\n            return \"c\";\n        }\n\n        static double GetDistSP(Point a, Point b, Point p)\n        {\n            if ((b - a).Dot(p - a) < 0.0) return (p - a).Abs;\n            if ((a - b).Dot(p - b) < 0.0) return (p - b).Abs;\n            return GetDistLP(a, b, p);\n        }\n\n        static double GetDistLP(Point a, Point b, Point p)\n        {\n            return Math.Abs((b - a).Cross(p - a) / (b - a).Abs);\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    struct Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    struct Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                if (input.All(n => n == 0)) break;\n\n                Point a = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point b = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point c = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point p = new Point(input[0], input[1]);\n                double r = double.Parse(Console.ReadLine());\n\n                if (IsPInside(a, b, c, p))\n                {\n                    sb.AppendLine(CheckPIn(a, b, c, p, r));\n                }\n                else\n                {\n                    sb.AppendLine(CheckPOut(a, b, c, p, r));\n                }\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsPInside(Point a, Point b, Point c, Point p)\n        {\n            double c1 = (b - a).Cross(p - b);\n            double c2 = (c - b).Cross(p - c);\n            double c3 = (a - c).Cross(p - a);\n\n            if (c1 > EPS && c2 > EPS && c3 > EPS) return true;\n            if (c1 < -EPS && c2 < -EPS && c3 < -EPS) return true;\n            return false;\n        }\n\n        static string CheckPIn(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"a\";\n\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa <= r && pb <= r && pc <= r) return \"b\";\n\n            return \"c\";\n        }\n\n        static string CheckPOut(Point a, Point b, Point c, Point p, double r)\n        {\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa <= r && pb <= r && pc <= r) return \"b\";\n\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"d\";\n\n            return \"c\";\n        }\n\n        static double GetDistSP(Point a, Point b, Point p)\n        {\n            if ((b - a).Dot(p - a) < 0.0) return (p - a).Abs;\n            if ((a - b).Dot(p - b) < 0.0) return (p - b).Abs;\n            return GetDistLP(a, b, p);\n        }\n\n        static double GetDistLP(Point a, Point b, Point p)\n        {\n            return Math.Abs((b - a).Cross(p - a) / (b - a).Abs);\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    struct Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    struct Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                if (input.All(n => n == 0)) break;\n\n                Point a = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point b = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point c = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point p = new Point(input[0], input[1]);\n                double r = double.Parse(Console.ReadLine());\n\n                if (IsInside(a, b, c, p))\n                {\n                    sb.AppendLine(CheckPIn(a, b, c, p, r));\n                }\n                else\n                {\n                    sb.AppendLine(CheckPOut(a, b, c, p, r));\n                }\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsInside(Point a, Point b, Point c, Point p)\n        {\n            double c1 = (b - a).Cross(p - b);\n            double c2 = (c - b).Cross(p - c);\n            double c3 = (a - c).Cross(p - a);\n\n            if (c1 > 0 && c2 > 0 && c3 > 0) return true;\n            if (c1 < 0 && c2 < 0 && c3 < 0) return true;\n            return false;\n        }\n\n        static string CheckPIn(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"a\";\n\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa < r && pb < r && pc < r) return \"b\";\n\n            return \"c\";\n        }\n\n        static string CheckPOut(Point a, Point b, Point c, Point p, double r)\n        {\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa < r && pb < r && pc < r) return \"b\";\n            if (pa > r && pb > r && pc > r) return \"d\";\n\n            return \"c\";\n        }\n\n        static double GetDistSP(Point a, Point b, Point p)\n        {\n            if ((b - a).Dot(p - a) < 0.0) return (p - a).Abs;\n            if ((a - b).Dot(p - b) < 0.0) return (p - b).Abs;\n            return GetDistLP(a, b, p);\n        }\n\n        static double GetDistLP(Point a, Point b, Point p)\n        {\n            return Math.Abs((b - a).Cross(p - a) / (b - a).Abs);\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    struct Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    struct Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                if (input.All(n => n == 0)) break;\n\n                Point a = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point b = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point c = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point p = new Point(input[0], input[1]);\n                double r = double.Parse(Console.ReadLine());\n\n                if (IsPInside(a, b, c, p))\n                {\n                    sb.AppendLine(CheckPIn(a, b, c, p, r));\n                }\n                else\n                {\n                    sb.AppendLine(CheckPOut(a, b, c, p, r));\n                }\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsPInside(Point a, Point b, Point c, Point p)\n        {\n            double c1 = (b - a).Cross(p - b);\n            double c2 = (c - b).Cross(p - c);\n            double c3 = (a - c).Cross(p - a);\n\n            if (c1 > EPS && c2 > EPS && c3 > EPS) return true;\n            if (c1 < -EPS && c2 < -EPS && c3 < -EPS) return true;\n            return false;\n        }\n\n        static string CheckPIn(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"a\";\n\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa < r && pb < r && pc < r) return \"b\";\n\n            return \"c\";\n        }\n\n        static string CheckPOut(Point a, Point b, Point c, Point p, double r)\n        {\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa < r && pb < r && pc < r) return \"b\";\n\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"d\";\n\n            return \"c\";\n        }\n\n        static double GetDistSP(Point a, Point b, Point p)\n        {\n            if ((b - a).Dot(p - a) < 0.0) return (p - a).Abs;\n            if ((a - b).Dot(p - b) < 0.0) return (p - b).Abs;\n            return GetDistLP(a, b, p);\n        }\n\n        static double GetDistLP(Point a, Point b, Point p)\n        {\n            return Math.Abs((b - a).Cross(p - a) / (b - a).Abs);\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    struct Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    struct Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static readonly double EPS = 1E-10;\n\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                double[] input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n\n                if (input.All(n => n == 0)) break;\n\n                Point a = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point b = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point c = new Point(input[0], input[1]);\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), double.Parse);\n                Point p = new Point(input[0], input[1]);\n                double r = double.Parse(Console.ReadLine());\n\n                if (IsInside(a, b, c, p))\n                {\n                    sb.AppendLine(CheckPIn(a, b, c, p, r));\n                }\n                else\n                {\n                    sb.AppendLine(CheckPOut(a, b, c, p, r));\n                }\n            }\n            Console.Write(sb);\n        }\n\n        static bool IsInside(Point a, Point b, Point c, Point p)\n        {\n            double c1 = (b - a).Cross(p - b);\n            double c2 = (c - b).Cross(p - c);\n            double c3 = (a - c).Cross(p - a);\n\n            if (c1 > EPS && c2 > EPS && c3 > EPS) return true;\n            if (c1 < -EPS && c2 < -EPS && c3 < -EPS) return true;\n            return false;\n        }\n\n        static string CheckPIn(Point a, Point b, Point c, Point p, double r)\n        {\n            double lp1 = GetDistSP(a, b, p);\n            double lp2 = GetDistSP(b, c, p);\n            double lp3 = GetDistSP(c, a, p);\n\n            if (lp1 > r && lp2 > r && lp3 > r) return \"a\";\n\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa < r && pb < r && pc < r) return \"b\";\n\n            return \"c\";\n        }\n\n        static string CheckPOut(Point a, Point b, Point c, Point p, double r)\n        {\n            double pa = (a - p).Abs;\n            double pb = (b - p).Abs;\n            double pc = (c - p).Abs;\n\n            if (pa < r && pb < r && pc < r) return \"b\";\n            if (pa > r && pb > r && pc > r) return \"d\";\n\n            return \"c\";\n        }\n\n        static double GetDistSP(Point a, Point b, Point p)\n        {\n            if ((b - a).Dot(p - a) < 0.0) return (p - a).Abs;\n            if ((a - b).Dot(p - b) < 0.0) return (p - b).Abs;\n            return GetDistLP(a, b, p);\n        }\n\n        static double GetDistLP(Point a, Point b, Point p)\n        {\n            return Math.Abs((b - a).Cross(p - a) / (b - a).Abs);\n        }\n    }\n\n    struct Point : IComparable\n    {\n        static readonly double EPS = 1E-10;\n\n        internal double x, y;\n\n        public Point(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double Abs { get { return Math.Sqrt(Norm); } }\n        public double Norm { get { return x * x + y * y; } }\n\n        public double Dot(Point p) { return x * p.x + y * p.y; }\n        public double Cross(Point p) { return x * p.y - y * p.x; }\n        public double Distance(Point p) { return (this - p).Abs; }\n\n        public static Point operator +(Point a, Point b) { return new Point(a.x + b.x, a.y + b.y); }\n        public static Point operator -(Point a, Point b) { return new Point(a.x - b.x, a.y - b.y); }\n        public static Point operator *(Point p, double d) { return new Point(p.x * d, p.y * d); }\n        public static Point operator *(Point a, Point b) { return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n        public static Point operator /(Point p, double d) { return new Point(p.x / d, p.y / d); }\n        public static bool operator <(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x < b.x : a.y < b.y; }\n        public static bool operator >(Point a, Point b) { return Math.Abs(a.x - b.x) > EPS ? a.x > b.x : a.y > b.y; }\n        public static bool operator ==(Point a, Point b) { return Math.Abs(a.x - b.x) < EPS && Math.Abs(a.y - b.y) < EPS; }\n        public static bool operator !=(Point a, Point b) { return Math.Abs(a.x - b.x) >= EPS || Math.Abs(a.y - b.y) >= EPS; }\n\n        public int CompareTo(object obj)\n        {\n            var other = (Point)obj;\n            if (obj == null) return -1;\n\n            ComparerX compX = new ComparerX();\n            return compX.Compare(this, other);\n        }\n\n        public override bool Equals(object obj)\n        {\n            var other = (Point)obj;\n            return Math.Abs(x - other.x) < EPS && Math.Abs(y - other.y) < EPS;\n        }\n\n        public override int GetHashCode()\n        {\n            return x.GetHashCode() ^ y.GetHashCode();\n        }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0:f10} {1:f10}\", x, y);\n        }\n    }\n\n    class ComparerX : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            return 0;\n        }\n    }\n\n    class ComparerY : IComparer<Point>\n    {\n        static readonly double EPS = 1E-10;\n\n        public int Compare(Point a, Point b)\n        {\n            if (a.y - b.y < -EPS) return -1;\n            if (a.y - b.y > EPS) return 1;\n            if (a.x - b.x < -EPS) return -1;\n            if (a.x - b.x > EPS) return 1;\n            return 0;\n        }\n    }\n\n    struct Segment\n    {\n        internal Point p1, p2;\n\n        public Segment(Point p1, Point p2)\n        {\n            this.p1 = p1;\n            this.p2 = p2;\n        }\n    }\n\n    struct Circle\n    {\n        internal Point p;\n        internal double r;\n\n        public Circle(Point p, double r)\n        {\n            this.p = p;\n            this.r = r;\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "process.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(input){\n    primeGenerator();\n    var lines = input.trim().split('\\n');\n    var len = lines.length;\n    for(var t=0;t<len;++t){\n        var x1, y1, x2, y2, x3, y3, ox, oy, r;\n        var maxX=0, maxY=0, minX=10000, minY=10000, d1, d2, d3;\n        var dataset;\n        \n        dataset = lines[t].split(' ');\n        x1 = parseInt(dataset[0]);\n        y1 = parseInt(dataset[1]);\n        if( x1 === 0 && y1 === 0 ) break;\n        if( x1 > maxX ) maxX = x1;\n        if( y1 > maxY ) maxY = y1;\n        if( x1 < minX ) minX = x1;\n        if( y1 < minY ) minY = y1;\n        \n        dataset = lines[++t].split(' ');\n        x2 = parseInt(dataset[0]);\n        y2 = parseInt(dataset[1]);\n        if( x2 > maxX ) maxX = x2;\n        if( y2 > maxY ) maxY = y2;\n        if( x2 < minX ) minX = x2;\n        if( y2 < minY ) minY = y2;\n        dataset = lines[++t].split(' ');\n        x3 = parseInt(dataset[0]);\n        y3 = parseInt(dataset[1]);\n        if( x3 > maxX ) maxX = x3;\n        if( y3 > maxY ) maxY = y3;\n        if( x3 < minX ) minX = x3;\n        if( y3 < minY ) minY = y3;\n        dataset = lines[++t].split(' ');\n        ox = parseInt(dataset[0]);\n        oy = parseInt(dataset[1]);\n        r = parseInt(lines[t]);\n        r = r * r;\n        \n        d1 = (x1 - ox) * (x1 - ox) + (y1 - ox) * (y1 - ox);\n        d2 = (x2 - ox) * (x2 - ox) + (y2 - ox) * (y2 - ox);\n        d3 = (x3 - ox) * (x3 - ox) + (y3 - ox) * (y3 - ox);\n        \n        if( d1 <= r && d2 <= r && d3 <= r ){\n            console.log(\"b\");\n        }\n        else if( d1 > r && d2 > r && d3 > r ){\n            if( ox > minX && ox < maxX && oy > minY && oy < maxY ){\n                console.log(\"a\");\n            }\n            else{\n                console.log(\"d\");\n            }\n        }\n        else{\n            console.log(\"c\");\n        }\n    }\n});"
  },
  {
    "language": "JavaScript",
    "code": "\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(input){\n    var lines = input.trim().split(\"\\n\");\n    var len = lines.length;\n    for(var t=0;t<len;++t){\n        var x1, y1, x2, y2, x3, y3, ox, oy, r;\n        var maxX=0, maxY=0, minX=10000, minY=10000, d1, d2, d3;\n        var dataset;\n        \n        dataset = lines[t].trim().split(\" \");\n        x1 = parseInt(dataset[0]);\n        y1 = parseInt(dataset[1]);\n        if( x1 === 0 && y1 === 0 ) break;\n        if( x1 > maxX ) maxX = x1;\n        if( y1 > maxY ) maxY = y1;\n        if( x1 < minX ) minX = x1;\n        if( y1 < minY ) minY = y1;\n        \n        dataset = lines[++t].trim().split(\" \");\n        x2 = parseInt(dataset[0]);\n        y2 = parseInt(dataset[1]);\n        if( x2 > maxX ) maxX = x2;\n        if( y2 > maxY ) maxY = y2;\n        if( x2 < minX ) minX = x2;\n        if( y2 < minY ) minY = y2;\n        dataset = lines[++t].trim().split(\" \");\n        x3 = parseInt(dataset[0]);\n        y3 = parseInt(dataset[1]);\n        if( x3 > maxX ) maxX = x3;\n        if( y3 > maxY ) maxY = y3;\n        if( x3 < minX ) minX = x3;\n        if( y3 < minY ) minY = y3;\n        dataset = lines[++t].trim().split(\" \");\n        ox = parseInt(dataset[0]);\n        oy = parseInt(dataset[1]);\n        r = parseInt(lines[t].trim());\n        r = r * r;\n        \n        d1 = (x1 - ox) * (x1 - ox) + (y1 - ox) * (y1 - ox);\n        d2 = (x2 - ox) * (x2 - ox) + (y2 - ox) * (y2 - ox);\n        d3 = (x3 - ox) * (x3 - ox) + (y3 - ox) * (y3 - ox);\n        \n        if( d1 <= r && d2 <= r && d3 <= r ){\n            console.log(\"b\");\n        }\n        else if( d1 > r && d2 > r && d3 > r ){\n            if( ox > minX && ox < maxX && oy > minY && oy < maxY ){\n                console.log(\"a\");\n            }\n            else{\n                console.log(\"d\");\n            }\n        }\n        else{\n            console.log(\"c\");\n        }\n    }\n});"
  },
  {
    "language": "JavaScript",
    "code": "\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(input){\n    primeGenerator();\n    var lines = input.trim().split(\"\\n\");\n    var len = lines.length;\n    for(var t=0;t<len;++t){\n        var x1, y1, x2, y2, x3, y3, ox, oy, r;\n        var maxX=0, maxY=0, minX=10000, minY=10000, d1, d2, d3;\n        var dataset;\n        \n        dataset = lines[t].trim().split(\" \");\n        x1 = parseInt(dataset[0]);\n        y1 = parseInt(dataset[1]);\n        if( x1 === 0 && y1 === 0 ) break;\n        if( x1 > maxX ) maxX = x1;\n        if( y1 > maxY ) maxY = y1;\n        if( x1 < minX ) minX = x1;\n        if( y1 < minY ) minY = y1;\n        \n        dataset = lines[++t].trim().split(\" \");\n        x2 = parseInt(dataset[0]);\n        y2 = parseInt(dataset[1]);\n        if( x2 > maxX ) maxX = x2;\n        if( y2 > maxY ) maxY = y2;\n        if( x2 < minX ) minX = x2;\n        if( y2 < minY ) minY = y2;\n        dataset = lines[++t].trim().split(\" \");\n        x3 = parseInt(dataset[0]);\n        y3 = parseInt(dataset[1]);\n        if( x3 > maxX ) maxX = x3;\n        if( y3 > maxY ) maxY = y3;\n        if( x3 < minX ) minX = x3;\n        if( y3 < minY ) minY = y3;\n        dataset = lines[++t].trim().split(\" \");\n        ox = parseInt(dataset[0]);\n        oy = parseInt(dataset[1]);\n        r = parseInt(lines[t].trim());\n        r = r * r;\n        \n        d1 = (x1 - ox) * (x1 - ox) + (y1 - ox) * (y1 - ox);\n        d2 = (x2 - ox) * (x2 - ox) + (y2 - ox) * (y2 - ox);\n        d3 = (x3 - ox) * (x3 - ox) + (y3 - ox) * (y3 - ox);\n        \n        if( d1 <= r && d2 <= r && d3 <= r ){\n            console.log(\"b\");\n        }\n        else if( d1 > r && d2 > r && d3 > r ){\n            if( ox > minX && ox < maxX && oy > minY && oy < maxY ){\n                console.log(\"a\");\n            }\n            else{\n                console.log(\"d\");\n            }\n        }\n        else{\n            console.log(\"c\");\n        }\n    }\n});"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef oprod(x1, y1, x2, y2)\n  x1 * y2 - x2 * y1\nend\n\ndef p_in_tr?(x1, y1, x2, y2, x3, y3, xp, yp)\n  op12 = oprod(x2 - x1, y2 - y1, xp - x1, yp - y1)\n  op23 = oprod(x3 - x2, y3 - y2, xp - x2, yp - y2)\n  op31 = oprod(x1 - x3, y1 - y3, xp - x3, yp - y3)\n\n  (op12 >= 0 && op23 >= 0 && op31 >= 0) ||\n    (op12 <= 0 && op23 <= 0 && op31 <= 0)\nend\n\ndef dd_c_l(x1, y1, x2, y2, xc, yc)\n  vx = x2 - x1\n  vy = y2 - y1\n\n  # ([t*vx+x1,t*vy+y1]-[xp,yp]) * [vx,vp] = 0\n  # [t*vx+x1-xp,t*vy+y1-yp] * [vx,vp] = 0\n  # vx*(t*vx+x1-xp)+vy(t*vy+y1-yp) = 0\n  # t*vx^2+vx(x1-xp)+t*vy^2+vy(y1-yp) = 0\n  # t*(vx^2+vy^2) = vx*(xp-x1)+vy*(yp-y1)\n  # t = (vx*(xp-x1)+vy*(yp-y1)) / (vx^2+vy^2)\n\n  t = (vx * (xc - x1) + vy * (yc - y1)).to_f / (vx ** 2 + vy ** 2)\n  x = t * vx + x1\n  y = t * vy + y1\n  dd = (x - xc) ** 2 + (y - yc) ** 2\n\n  #p [\"cross_c_l\", x1, y1, x2, y2, xc, yc, rr, t, x, y, dd]\n  dd\nend\n\n### main\n\nwhile true\n  x1, y1 = gets.strip.split(' ').map{|s| s.to_i}\n  break if x1 == 0 && y1 == 0\n\n  x2, y2 = gets.strip.split(' ').map{|s| s.to_i}\n  x3, y3 = gets.strip.split(' ').map{|s| s.to_i}\n\n  xc, yc = gets.strip.split(' ').map{|s| s.to_i}\n  r = gets.strip.to_i\n  #p [[x1, y1], [x2, y2], [x3, y3], [xc, yc], r]\n\n  rr = r ** 2\n  dd1 = (x1 - xc) ** 2 + (y1 - yc) ** 2\n  dd2 = (x2 - xc) ** 2 + (y2 - yc) ** 2\n  dd3 = (x3 - xc) ** 2 + (y3 - yc) ** 2\n  #p \"dd1=#{dd1}, dd2=#{dd2}, dd3=#{dd3}, rr=#{rr}\"\n\n  rel = ''\n\n  if dd1 <= rr && dd2 <= rr && dd3 <= rr\n    rel = 'b'\n  else\n    dd12 = dd_c_l(x1, y1, x2, y2, xc, yc)\n    dd23 = dd_c_l(x2, y2, x3, y3, xc, yc)\n    dd31 = dd_c_l(x3, y3, x1, y1, xc, yc)\n\n    min_dd = [dd12, dd23, dd31].min\n\n    p_in_tr = p_in_tr?(x1, y1, x2, y2, x3, y3, xc, yc)\n\n    if p_in_tr && min_dd >= rr\n      rel = 'a'\n    elsif ! p_in_tr && min_dd > rr\n      rel = 'd'\n    else\n      rel = 'c'\n    end\n  end\n\n  puts rel\nend"
  },
  {
    "language": "Ruby",
    "code": "loop{*l,(m,n),(r,_)=(1..5).map{(gets||exit).split.map &:to_i}\nw=l.zip(l.rotate).map{|(x,y),(t,u)|[Math.hypot(a=t-x,b=u-y),a*(n-y)-(m-x)*b]}\nputs l.any?{|x,y|(x-m)**2+(y-n)**2>r*r}?w.any?{|_,j|j<0}&&w.any?{|_,j|j>0}||w.any?{|i,j|j.abs<r*i}?w.all?{|i,j|j.abs>r*i}??d:?c:?a:?b}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef oprod(x1, y1, x2, y2)\n  x1 * y2 - x2 * y1\nend\n\ndef p_in_tr?(x1, y1, x2, y2, x3, y3, xp, yp)\n  op12 = oprod(x2 - x1, y2 - y1, xp - x1, yp - y1)\n  op23 = oprod(x3 - x2, y3 - y2, xp - x2, yp - y2)\n  op31 = oprod(x1 - x3, y1 - y3, xp - x3, yp - y3)\n\n  (op12 >= 0 && op23 >= 0 && op31 >= 0) ||\n    (op12 <= 0 && op23 <= 0 && op31 <= 0)\nend\n\ndef dd_c_l(x1, y1, x2, y2, xc, yc)\n  vx = x2 - x1\n  vy = y2 - y1\n\n  # ([t*vx+x1,t*vy+y1]-[xp,yp]) * [vx,vp] = 0\n  # [t*vx+x1-xp,t*vy+y1-yp] * [vx,vp] = 0\n  # vx*(t*vx+x1-xp)+vy(t*vy+y1-yp) = 0\n  # t*vx^2+vx(x1-xp)+t*vy^2+vy(y1-yp) = 0\n  # t*(vx^2+vy^2) = vx*(xp-x1)+vy*(yp-y1)\n  # t = (vx*(xp-x1)+vy*(yp-y1)) / (vx^2+vy^2)\n\n  t = (vx * (xc - x1) + vy * (yc - y1)).to_f / (vx ** 2 + vy ** 2)\n  x = t * vx + x1\n  y = t * vy + y1\n  dd = (x - xc) ** 2 + (y - yc) ** 2\n\n  #p [\"cross_c_l\", x1, y1, x2, y2, xc, yc, rr, t, x, y, dd]\n  dd\nend\n\n### main\n\nwhile true\n  x1, y1 = gets.strip.split(' ').map{|s| s.to_i}\n  break if x1 == 0 && y1 == 0\n\n  x2, y2 = gets.strip.split(' ').map{|s| s.to_i}\n  x3, y3 = gets.strip.split(' ').map{|s| s.to_i}\n\n  xc, yc = gets.strip.split(' ').map{|s| s.to_i}\n  r = gets.strip.to_i\n  #p [[x1, y1], [x2, y2], [x3, y3], [xc, yc], r]\n\n  rr = r ** 2\n  dd1 = (x1 - xc) ** 2 + (y1 - yc) ** 2\n  dd2 = (x2 - xc) ** 2 + (y2 - yc) ** 2\n  dd3 = (x3 - xc) ** 2 + (y3 - yc) ** 2\n  #p \"dd1=#{dd1}, dd2=#{dd2}, dd3=#{dd3}, rr=#{rr}\"\n\n  rel = ''\n\n  if dd1 <= rr && dd2 <= rr && dd3 <= rr\n    #rel = 'b: tr in cir'\n    rel = 'b'\n  elsif dd1 > rr && dd2 > rr && dd3 > rr\n    op12_c = oprod(x2 - x1, y2 - y1, xc - x1, yc - y1)\n    op12_3 = oprod(x2 - x1, y2 - y1, x3 - x1, y3 - y1)\n    same_12 = (op12_c * op12_3 >= 0)\n    op23_c = oprod(x3 - x2, y3 - y2, xc - x2, yc - y2)\n    op23_1 = oprod(x3 - x2, y3 - y2, x1 - x2, y1 - y2)\n    same_23 = (op23_c * op23_1 >= 0)\n    op31_c = oprod(x1 - x3, y1 - y3, xc - x3, yc - y3)\n    op31_2 = oprod(x1 - x3, y1 - y3, x2 - x3, y2 - y3)\n    same_31 = (op31_c * op31_2 >= 0)\n\n    dd12_c = dd_c_l(x1, y1, x2, y2, xc, yc)\n    dd23_c = dd_c_l(x2, y2, x3, y3, xc, yc)\n    dd31_c = dd_c_l(x3, y3, x1, y1, xc, yc)\n\n    if same_12 && same_23 && same_31\n      if dd12_c >= rr && dd23_c >= rr && dd31_c >= rr\n        rel = 'a'\n      else\n        rel = 'c'\n      end\n    elsif ! same_12 && same_23 && same_31\n      if dd12_c > rr\n        rel = 'd'\n      else\n        rel = 'c'\n      end\n    elsif same_12 && ! same_23 && same_31\n      if dd23_c > rr\n        rel = 'd'\n      else\n        rel = 'c'\n      end\n    elsif same_12 && same_23 && ! same_31\n      if dd31_c > rr\n        rel = 'd'\n      else\n        rel = 'c'\n      end\n    else\n      rel = 'd'\n    end\n  else\n    #rel = 'c: intersection'\n    rel = 'c'\n  end\n\n  puts rel\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef oprod(x1, y1, x2, y2)\n  x1 * y2 - x2 * y1\nend\n\ndef p_in_tr?(x1, y1, x2, y2, x3, y3, xp, yp)\n  op12 = oprod(x2 - x1, y2 - y1, xp - x1, yp - y1)\n  op23 = oprod(x3 - x2, y3 - y2, xp - x2, yp - y2)\n  op31 = oprod(x1 - x3, y1 - y3, xp - x3, yp - y3)\n\n  (op12 >= 0 && op23 >= 0 && op31 >= 0) ||\n    (op12 <= 0 && op23 <= 0 && op31 <= 0)\nend\n\ndef dd_c_l(x1, y1, x2, y2, xc, yc)\n  vx = x2 - x1\n  vy = y2 - y1\n\n  # ([t*vx+x1,t*vy+y1]-[xp,yp]) * [vx,vy] = 0\n  # [t*vx+x1-xp,t*vy+y1-yp] * [vx,vy] = 0\n  # vx*(t*vx+x1-xp)+vy(t*vy+y1-yp) = 0\n  # t*vx^2+vx(x1-xp)+t*vy^2+vy(y1-yp) = 0\n  # t*(vx^2+vy^2) = vx*(xp-x1)+vy*(yp-y1)\n  # t = (vx*(xp-x1)+vy*(yp-y1)) / (vx^2+vy^2)\n\n  t = (vx * (xc - x1) + vy * (yc - y1)).to_f / (vx ** 2 + vy ** 2)\n  x = t * vx + x1\n  y = t * vy + y1\n  dd = (x - xc) ** 2 + (y - yc) ** 2\n\n  return dd if (t > 0 && t < 1)\n\n  dd1c = (x1 - xc) ** 2 + (y1 - yc) ** 2\n  dd2c = (x2 - xc) ** 2 + (y2 - yc) ** 2\n  [dd1c, dd2c].min\nend\n\n### main\n\nwhile true\n  x1, y1 = gets.strip.split(' ').map{|s| s.to_i}\n  break if x1 == 0 && y1 == 0\n\n  x2, y2 = gets.strip.split(' ').map{|s| s.to_i}\n  x3, y3 = gets.strip.split(' ').map{|s| s.to_i}\n\n  xc, yc = gets.strip.split(' ').map{|s| s.to_i}\n  r = gets.strip.to_i\n  #p [[x1, y1], [x2, y2], [x3, y3], [xc, yc], r]\n\n  rr = r ** 2\n  dd1 = (x1 - xc) ** 2 + (y1 - yc) ** 2\n  dd2 = (x2 - xc) ** 2 + (y2 - yc) ** 2\n  dd3 = (x3 - xc) ** 2 + (y3 - yc) ** 2\n  #p \"dd1=#{dd1}, dd2=#{dd2}, dd3=#{dd3}, rr=#{rr}\"\n\n  rel = ''\n\n  if dd1 <= rr && dd2 <= rr && dd3 <= rr\n    rel = 'b'\n  elsif dd1 > rr && dd2 > r && dd3 > rr\n    dd12 = dd_c_l(x1, y1, x2, y2, xc, yc)\n    dd23 = dd_c_l(x2, y2, x3, y3, xc, yc)\n    dd31 = dd_c_l(x3, y3, x1, y1, xc, yc)\n\n    min_dd = [dd12, dd23, dd31].min\n\n    p_in_tr = p_in_tr?(x1, y1, x2, y2, x3, y3, xc, yc)\n\n    if p_in_tr && min_dd >= rr\n      rel = 'a'\n    elsif ! p_in_tr && min_dd > rr\n      rel = 'd'\n    else\n      rel = 'c'\n    end\n  else\n    rel = 'c'\n  end\n\n  puts rel\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef oprod(x1, y1, x2, y2)\n  x1 * y2 - x2 * y1\nend\n\ndef p_in_tr?(x1, y1, x2, y2, x3, y3, xp, yp)\n  op12 = oprod(x2 - x1, y2 - y1, xp - x1, yp - y1)\n  op23 = oprod(x3 - x2, y3 - y2, xp - x2, yp - y2)\n  op31 = oprod(x1 - x3, y1 - y3, xp - x3, yp - y3)\n\n  (op12 >= 0 && op23 >= 0 && op31 >= 0) ||\n    (op12 <= 0 && op23 <= 0 && op31 <= 0)\nend\n\ndef cross_c_l(x1, y1, x2, y2, xc, yc, rr)\n  vx = x2 - x1\n  vy = y2 - y1\n\n  # ([t*vx+x1,t*vy+y1]-[xp,yp]) * [vx,vp] = 0\n  # [t*vx+x1-xp,t*vy+y1-yp] * [vx,vp] = 0\n  # vx*(t*vx+x1-xp)+vy(t*vy+y1-yp) = 0\n  # t*vx^2+vx(x1-xp)+t*vy^2+vy(y1-yp) = 0\n  # t*(vx^2+vy^2) = vx*(xp-x1)+vy*(yp-y1)\n  # t = (vx*(xp-x1)+vy*(yp-y1)) / (vx^2+vy^2)\n\n  t = (vx * (xc - x1) + vy * (yc - y1)).to_f / (vx ** 2 + vy ** 2)\n  x = t * vx + x1\n  y = t * vy + y1\n  dd = (x - xc) ** 2 + (y - yc) ** 2\n\n  tf = (t > 0 && t < 1 &&  dd < rr)\n  #p [\"cross_c_l\", x1, y1, x2, y2, xc, yc, rr, t, x, y, dd, tf]\n\n  tf\nend\n\n### main\n\nwhile true\n  x1, y1 = gets.strip.split(' ').map{|s| s.to_i}\n  break if x1 == 0 && y1 == 0\n\n  x2, y2 = gets.strip.split(' ').map{|s| s.to_i}\n  x3, y3 = gets.strip.split(' ').map{|s| s.to_i}\n\n  xc, yc = gets.strip.split(' ').map{|s| s.to_i}\n  r = gets.strip.to_i\n  #p [[x1, y1], [x2, y2], [x3, y3], [xc, yc], r]\n\n  rr = r ** 2\n  dd1 = (x1 - xc) ** 2 + (y1 - yc) ** 2\n  dd2 = (x2 - xc) ** 2 + (y2 - yc) ** 2\n  dd3 = (x3 - xc) ** 2 + (y3 - yc) ** 2\n  #p \"dd1=#{dd1}, dd2=#{dd2}, dd3=#{dd3}, rr=#{rr}\"\n\n  rel = ''\n\n  if dd1 <= rr && dd2 <= rr && dd3 <= rr\n    #rel = 'b: tr in cir'\n    rel = 'b'\n  elsif dd1 > rr && dd2 > rr && dd3 > rr\n    cl12 = cross_c_l(x1, y1, x2, y2, xc, yc, rr)\n    cl23 = cross_c_l(x2, y2, x3, y3, xc, yc, rr)\n    cl31 = cross_c_l(x3, y3, x1, y1, xc, yc, rr)\n    p_tr = p_in_tr?(x1, y1, x2, y2, x3, y3, xc, yc)\n    #p \"cl12=#{cl12}, cl23=#{cl23}, cl31=#{cl31}, p_tr=#{p_tr}\"\n    if cl12 || cl23 || cl31\n      #rel = 'c: intersection'\n      rel = 'c'\n    elsif p_tr\n      #rel = 'a: cir in tr'\n      rel = 'a'\n    else\n      #rel = 'd: no intersection'\n      rel = 'd'\n    end\n  else\n    #rel = 'c: intersection'\n    rel = 'c'\n  end\n\n  puts rel\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tbuf0 := strings.Split(scanner.Text(), \" \")\n\t\tinput0 := make([]int, 2)\n\t\tfor i := range input0 {\n\t\t\tinput0[i], _ = strconv.Atoi(buf0[i])\n\t\t}\n\t\tif input0[0] == 0 && input0[1] == 0 {\n\t\t\tbreak\n\t\t}\n\t\ta, b := input0[0], input0[1]\n\t\tscanner.Scan()\n\t\tbuf1 := strings.Split(scanner.Text(), \" \")\n\t\tinput1 := make([]int, 2)\n\t\tfor i := range input1 {\n\t\t\tinput1[i], _ = strconv.Atoi(buf1[i])\n\t\t}\n\t\tc, d := input1[0], input1[1]\n\t\tscanner.Scan()\n\t\tbuf2 := strings.Split(scanner.Text(), \" \")\n\t\tinput2 := make([]int, 2)\n\t\tfor i := range input2 {\n\t\t\tinput2[i], _ = strconv.Atoi(buf2[i])\n\t\t}\n\t\te, f := input2[0], input2[1]\n\t\tscanner.Scan()\n\t\tbuf3 := strings.Split(scanner.Text(), \" \")\n\t\tinput3 := make([]int, 2)\n\t\tfor i := range input3 {\n\t\t\tinput3[i], _ = strconv.Atoi(buf3[i])\n\t\t}\n\t\tg, h := input3[0], input3[1]\n\t\tscanner.Scan()\n\t\tr, _ := strconv.Atoi(scanner.Text())\n\t\tif (a-g)*(a-g)+(b-h)*(b-h) <= r*r && (c-g)*(c-g)+(d-h)*(d-h) <= r*r && (e-g)*(e-g)+(f-h)*(f-h) <= r*r {\n\t\t\tfmt.Println(\"b\")\n\t\t} else if dist(a, b, c, d, g, h) > float64(r)-0.000001 && dist(a, b, e, f, g, h) > float64(r)-0.000001 && dist(e, f, c, d, g, h) > float64(r)-0.000001 && inclusive(a, b, c, d, e, f, g, h) {\n\t\t\tfmt.Println(\"a\")\n\t\t} else if CL_intersect(a, b, c, d, g, h, r) || CL_intersect(a, b, e, f, g, h, r) || CL_intersect(e, f, c, d, g, h, r) {\n\t\t\tfmt.Println(\"c\")\n\t\t} else {\n\t\t\tfmt.Println(\"d\")\n\t\t}\n\t}\n}\n\nfunc CL_intersect(ax, ay, bx, by, cx, cy, r int) bool {\n\tacx := cx - ax\n\tacy := cy - ay\n\tbcx := cx - bx\n\tbcy := cy - by\n\tabx := bx - ax\n\taby := by - ay\n\tif acx*acx+acy*acy >= r*r || bcx*bcx+bcy*bcy >= r*r {\n\t\tif abx*acx+aby*acy < 0 {\n\t\t\tif acx*acx+acy*acy <= r*r {\n\t\t\t\treturn true\n\t\t\t}\n\t\t} else {\n\t\t\tif abx*acx+aby*acy > abx*abx+aby*aby {\n\t\t\t\tif bcx*bcx+bcy*bcy <= r*r {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t} else if acx*acx+acy*acy-(abx*acx+aby*acy)*(abx*acx+aby*acy)/(abx*abx+aby*aby) <= r*r {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc inclusive(ax, ay, bx, by, cx, cy, px, py int) bool {\n\tok1 := true\n\tok2 := true\n\tif (bx-ax)*(py-ay)-(px-ax)*(by-ay) < 0 {\n\t\tok1 = false\n\t}\n\tif (bx-ax)*(py-ay)-(px-ax)*(by-ay) > 0 {\n\t\tok2 = false\n\t}\n\tif (cx-bx)*(py-by)-(px-bx)*(cy-by) < 0 {\n\t\tok1 = false\n\t}\n\tif (cx-bx)*(py-by)-(px-bx)*(cy-by) > 0 {\n\t\tok2 = false\n\t}\n\tif (ax-cx)*(py-cy)-(px-cx)*(ay-cy) < 0 {\n\t\tok1 = false\n\t}\n\tif (ax-cx)*(py-cy)-(px-cx)*(ay-cy) > 0 {\n\t\tok2 = false\n\t}\n\treturn ok1 || ok2\n}\n\nfunc dist(ax, ay, bx, by, px, py int) float64 {\n\tdx := float64(bx - ax)\n\tdy := float64(by - ay)\n\tA := float64(dx*dx + dy*dy)\n\tB := dx*float64(ax-px) + dy*float64(ay-py)\n\tt := -B / A\n\tif t < 0 {\n\t\tt = 0\n\t}\n\tif t > 1 {\n\t\tt = 1\n\t}\n\ttx := float64(ax) + dx*t\n\tty := float64(ay) + dy*t\n\treturn math.Sqrt((float64(px)-tx)*(float64(px)-tx) + (float64(py)-ty)*(float64(py)-ty))\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-9;\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point p) const {\n        static if (op == \"+\") {\n            return Point(x + p.x, y + p.y);\n        } else if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n    Point opBinary(string op)(double a) const {\n        static if (op == \"*\") {\n            return Point(a * x, a * y);\n        } else if (op == \"/\") {\n            return Point(x / a, y / a);\n        }\n    }\n}\n\ndouble distance2(in Point a, in Point b) {\n    double dx = a.x - b.x, dy = a.y - b.y;\n    return dx * dx + dy * dy;\n}\ndouble norm2(in Point a) {\n    return (a.x * a.x) + (a.y * a.y);\n}\ndouble norm(in Point a) {\n    return sqrt(norm2(a));\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\nstatic int CCW(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // 反時計周り\n    if (cross(b, c) < -EPS) return -1;     // 時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (b.norm < c.norm) return -2;    // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\nPoint projection(in Segment s, in Point p) {\n    Point a = s.a, b = s.b;\n    Point u = b - a,\n          v = p - a;\n    double n = u.norm2;\n    return a + u * dot(u, v) / n;\n}\n\nstruct Segment {\n    Point a, b;\n}\n\nbool contains(in Segment s, in Point p) {\n    Point a = s.a, b = s.b;\n    if (a.x > b.x) swap(a, b);\n    if (! (a.x <= p.x && p.x <= b.x) ) return false;\n    if (a.y > b.y) swap(a, b);\n    return a.y <= p.y && p.y <= b.y;\n}\ndouble distance2(in Segment s, in Point p) {\n    if (s.contains(s.projection(p))) {\n        Point u = s.b - s.a,\n              v = p - s.a;\n        double x = cross(u, v),\n               y = distance2(s.a, s.b);\n        return (x * x / y);\n    } else {\n        return min(distance2(s.a, p), distance2(s.b, p));\n    }\n}\n \nvoid main() {\n    Point[] P = new Point[3];\n    Point C;\n    double R;\n    bool input() {\n        double x, y;\n        scanf(\"%lf %lf\\n\", &x, &y);\n        if (x == 0 && y == 0) return false;\n        P[0] = Point(x, y);\n        foreach (i; 1 .. 3) {\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P[i] = Point(x, y);\n        }\n        scanf(\"%lf %lf\\n\", &C.x, &C.y);\n        scanf(\"%lf\\n\", &R);\n        return true;\n    }\n    \n    void solve() {\n        bool CheckB() {\n            // 三角形が円に含まれる\n            foreach (i; 0 .. 3) {\n                Point p = P[i];\n                if (C.distance2(p) > R * R) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        bool CheckC() {\n            // 交点が存在\n            foreach (i; 0 .. 3) {\n                Point p = P[i], q = P[(i + 1) % 3];\n                if (Segment(p, q).distance2(C) <= R * R) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        bool CheckA() {\n            // 円が三角形に含まれる\n            int ccw = CCW(P[0], P[1], C);\n            foreach (i; 1 .. 3) {\n                Point p = P[i], q = P[(i + 1) % 3];\n                if (ccw != CCW(p, q, C)) return false;\n            }\n            foreach (i; 0 .. 3) {\n                Point p = P[i], q = P[(i + 1) % 3];\n                if (Segment(p, q).distance2(C) < R * R) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        if (CheckB) {\n            writeln(\"b\");\n        } else if (CheckA) {\n            writeln(\"a\");\n        } else if (CheckC) {\n            writeln(\"c\");\n        } else {\n            writeln(\"d\");\n        }\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nlong r2(long[] p1, long[] p2) {\n    long[] d = [p1[0]-p2[0], p1[1]-p2[1]];\n    return d[0]*d[0] + d[1]*d[1];\n}\n\nlong dot(long[] x1, long[] x2) {\n    return x1[0] * x2[0] + x1[1] * x2[1];\n}\n\nlong[] sub(long[] x1, long[] x2) {\n    return [x1[0]-x2[0], x1[1]-x2[1]];\n}\nlong[] add(long[] x1, long[] x2) {\n    return [x1[0]+x2[0], x1[1]+x2[1]];\n}\n\ndouble d2(long[] p1, long[] p2, long[] x) {\n    long[] p21 = sub(p2, p1);\n    long[] p1x = sub(p1, x);\n    return (dot(p21, p21)*dot(p1x,p1x) - pow(dot(p21, p1x), 2))/to!double(dot(p21,p21));\n}\n\nlong cross(long[] x, long[] y) {\n    return x[0]*y[1] - x[1]*y[0];\n}\n\nbool inTriangle(long[] p1, long[] p2, long[] p3, long[] x) {\n    auto u = sub(p1, x);\n    auto v = sub(p2, x);\n    auto w = sub(p3, x);\n    \n    auto a = cross(u, v);\n    auto b = cross(v, w);\n    auto c = cross(w, u);\n\n    return a*b > 0 && b*c > 0 && c*a > 0;\n}\n\nbool hasIntersection(long[] p1, long[] p2, long[] r0, long r) {\n    auto p21 = sub(p2, p1);\n    auto p1r = sub(p1, r0);\n    auto f0 = dot(p1r, p1r) - r*r;\n    auto f1 = dot(add(p21, p1r), add(p21, p1r)) - r*r;\n    if(f0 * f1 <= 0) {\n        return true;\n    }\n    if(f0 < 0 && f1 < 0) {\n        return false;\n    }\n    if(dot(p21, p1r) > 0 || abs(dot(p21, p1r)) > dot(p21, p21)) {\n        return false;\n    }\n    return -pow(dot(p21, p1r), 2) + dot(p1r, p1r) - r*r <= 0;\n}\n\nstring test(long[] p1, long[] p2, long[] p3, long[] p4, long r) {\n    if(inTriangle(p1, p2, p3, p4) && min(d2(p1, p2, p4), d2(p2, p3, p4), d2(p3, p1, p4)) >= r*r) {\n        return \"a\";\n    }\n    if(r2(p1, p4) <= r*r && r2(p2,p4) <= r*r && r2(p3,p4) <= r*r) {\n        return \"b\";\n    }\n    if(hasIntersection(p1, p2, p4, r) || hasIntersection(p2, p3 ,p4, r) || hasIntersection(p3, p1, p4, r)) {\n        return \"c\";\n    }\n    return \"d\";\n}\n\nvoid main(){\n    while(true) {\n        auto xy1 = readLongs();\n        if(xy1[0] == 0 && xy1[1] == 0) {\n            return;\n        }\n        auto xy2 = readLongs();\n        auto xy3 = readLongs();\n        auto xy4 = readLongs();\n        auto r = readLong();\n        writeln(test(xy1, xy2, xy3, xy4, r));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nlong r2(long[] p1, long[] p2) {\n    long[] d = [p1[0]-p2[0], p1[1]-p2[1]];\n    return d[0]*d[0] + d[1]*d[1];\n}\n\nlong dot(long[] x1, long[] x2) {\n    return x1[0] * x2[0] + x1[1] * x2[1];\n}\n\nlong[] sub(long[] x1, long[] x2) {\n    return [x1[0]-x2[0], x1[1]-x2[1]];\n}\nlong[] add(long[] x1, long[] x2) {\n    return [x1[0]+x2[0], x1[1]+x2[1]];\n}\n\ndouble d2(long[] p1, long[] p2, long[] x) {\n    long[] p21 = sub(p2, p1);\n    long[] p1x = sub(p1, x);\n    return (dot(p21, p21)*dot(p1x,p1x) - pow(dot(p21, p1x), 2))/to!double(dot(p21,p21));\n}\n\nlong cross(long[] x, long[] y) {\n    return x[0]*y[1] - x[1]*y[0];\n}\n\nbool inTriangle(long[] p1, long[] p2, long[] p3, long[] x) {\n    auto u = sub(p1, x);\n    auto v = sub(p2, x);\n    auto w = sub(p3, x);\n    \n    auto a = cross(u, v);\n    auto b = cross(v, w);\n    auto c = cross(w, u);\n\n    return a*b > 0 && b*c > 0 && c*a > 0;\n}\n\nbool hasIntersection(long[] p1, long[] p2, long[] r0, long r) {\n    auto p21 = sub(p2, p1);\n    auto p1r = sub(p1, r0);\n    auto f0 = dot(p1r, p1r) - r*r;\n    auto f1 = dot(add(p21, p1r), add(p21, p1r)) - r*r;\n    if(f0 * f1 <= 0) {\n        return true;\n    }\n    if(f0 < 0 && f1 < 0) {\n        return false;\n    }\n    if(dot(p21, p1r) > 0 || abs(dot(p21, p1r)) > dot(p21, p21)) {\n        return false;\n    }\n    return -pow(dot(p21, p1r), 2) + dot(p1r, p1r) - r*r <= 0;\n}\n\nstring test(long[] p1, long[] p2, long[] p3, long[] p4, long r) {\n    if(inTriangle(p1, p2, p3, p4) && min(d2(p1, p2, p4), d2(p2, p3, p4), d2(p3, p1, p4)) >= r*r) {\n        return \"a\";\n    }\n    if(r2(p1, p4) <= r*r && r2(p2,p4) <= r*r && r2(p3,p4) <= r*r) {\n        return \"b\";\n    }\n    if(hasIntersection(p1, p2, p4, r) || hasIntersection(p2, p3 ,p4, r) || hasIntersection(p3, p1, p4, r)) {\n        return \"c\";\n    }\n    return \"d\";\n}\n\nvoid main(){\n    while(true) {\n        auto xy1 = readLongs();\n        if(xy1[0] == 0 && xy1[1] == 0) {\n            return;\n        }\n        auto xy2 = readLongs();\n        auto xy3 = readLongs();\n        auto xy4 = readLongs();\n        auto r = readLong();\n        writeln(test(xy1, xy2, xy3, xy4, r));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nlong r2(long[] p1, long[] p2) {\n    long[] d = [p1[0]-p2[0], p1[1]-p2[1]];\n    return d[0]*d[0] + d[1]*d[1];\n}\n\nlong dot(long[] x1, long[] x2) {\n    return x1[0] * x2[0] + x1[1] * x2[1];\n}\n\nlong[] sub(long[] x1, long[] x2) {\n    return [x1[0]-x2[0], x1[1]-x2[1]];\n}\nlong[] add(long[] x1, long[] x2) {\n    return [x1[0]+x2[0], x1[1]+x2[1]];\n}\n\ndouble d2(long[] p1, long[] p2, long[] x) {\n    long[] p21 = sub(p2, p1);\n    long[] p1x = sub(p1, x);\n    return (dot(p21, p21)*dot(p1x,p1x) - pow(dot(p21, p1x), 2))/to!double(dot(p21,p21));\n}\n\nlong cross(long[] x, long[] y) {\n    return x[0]*y[1] - x[1]*y[0];\n}\n\nbool inTriangle(long[] p1, long[] p2, long[] p3, long[] x) {\n    auto u = sub(p1, x);\n    auto v = sub(p2, x);\n    auto w = sub(p3, x);\n    \n    auto a = cross(u, v);\n    auto b = cross(v, w);\n    auto c = cross(w, u);\n\n    return a*b > 0 && b*c > 0 && c*a > 0;\n}\n\nbool hasIntersection(long[] p1, long[] p2, long[] r0, long r) {\n    auto p21 = sub(p2, p1);\n    auto p1r = sub(p1, r0);\n    auto f0 = dot(p1r, p1r) - r*r;\n    auto f1 = dot(add(p21, p1r), add(p21, p1r)) - r*r;\n    if(f0 * f1 <= 0) {\n        return true;\n    }\n    if(f0 < 0 && f1 < 0) {\n        return false;\n    }\n    if(dot(p21, p1r) > 0 || abs(dot(p21, p1r)) > dot(p21, p21)) {\n        return false;\n    }\n    return -pow(dot(p21, p1r), 2) + dot(p1r, p1r)*dot(p21, p21) - r*r*dot(p21, p21) <= 0;\n}\n\nstring test(long[] p1, long[] p2, long[] p3, long[] p4, long r) {\n    if(inTriangle(p1, p2, p3, p4) && min(d2(p1, p2, p4), d2(p2, p3, p4), d2(p3, p1, p4)) >= r*r) {\n        return \"a\";\n    }\n    if(r2(p1, p4) <= r*r && r2(p2,p4) <= r*r && r2(p3,p4) <= r*r) {\n        return \"b\";\n    }\n    if(hasIntersection(p1, p2, p4, r) || hasIntersection(p2, p3 ,p4, r) || hasIntersection(p3, p1, p4, r)) {\n        return \"c\";\n    }\n    return \"d\";\n}\n\nvoid main(){\n    while(true) {\n        auto xy1 = readLongs();\n        if(xy1[0] == 0 && xy1[1] == 0) {\n            return;\n        }\n        auto xy2 = readLongs();\n        auto xy3 = readLongs();\n        auto xy4 = readLongs();\n        auto r = readLong();\n        writeln(test(xy1, xy2, xy3, xy4, r));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-9;\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point p) const {\n        static if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n}\n\ndouble distance2(in Point a, in Point b) {\n    double dx = a.x - b.x, dy = a.y - b.y;\n    return dx * dx + dy * dy;\n}\ndouble norm(in Point a) {\n    return sqrt((a.x * a.x) + (a.y * a.y));\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\nstatic int CCW(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // 反時計周り\n    if (cross(b, c) < -EPS) return -1;     // 時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (b.norm < c.norm) return -2;    // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\n\nstruct Segment {\n    Point a, b;\n}\n\ndouble distance2(in Segment s, in Point p) {\n    Point u = s.b - s.a,\n          v = p - s.a;\n    double x = cross(u, v),\n           y = distance2(s.a, s.b);\n    return (x * x / y);\n}\n \nvoid main() {\n    Point[] P = new Point[3];\n    Point C;\n    double R;\n    bool input() {\n        double x, y;\n        scanf(\"%lf %lf\\n\", &x, &y);\n        if (x == 0 && y == 0) return false;\n        P[0] = Point(x, y);\n        foreach (i; 1 .. 3) {\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P[i] = Point(x, y);\n        }\n        scanf(\"%lf %lf\\n\", &C.x, &C.y);\n        scanf(\"%lf\\n\", &R);\n        return true;\n    }\n    \n    void solve() {\n        bool CheckB() {\n            // 三角形が円に含まれる\n            foreach (i; 0 .. 3) {\n                Point p = P[i];\n                if (C.distance2(p) > R * R) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        bool CheckC() {\n            // 交点が存在\n            foreach (i; 0 .. 3) {\n                Point p = P[i], q = P[(i + 1) % 3];\n                if (Segment(p, q).distance2(C) <= R * R) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        bool CheckA() {\n            // 円が三角形に含まれる\n            int ccw = CCW(P[0], P[1], C);\n            foreach (i; 1 .. 3) {\n                Point p = P[i], q = P[(i + 1) % 3];\n                if (ccw != CCW(p, q, C)) return false;\n            }\n            return true;\n        }\n        if (CheckB) {\n            writeln(\"b\");\n        } else if (CheckC) {\n            writeln(\"c\");\n        } else if (CheckA) {\n            writeln(\"a\");\n        } else {\n            writeln(\"d\");\n        }\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nint r2(int[] p1, int[] p2) {\n    int[] d = [p1[0]-p2[0], p1[1]-p2[1]];\n    return d[0]*d[0] + d[1]*d[1];\n}\n\nint dot(int[] x1, int[] x2) {\n    return x1[0] * x2[0] + x1[1] * x2[1];\n}\n\nint[] sub(int[] x1, int[] x2) {\n    return [x1[0]-x2[0], x1[1]-x2[1]];\n}\nint[] add(int[] x1, int[] x2) {\n    return [x1[0]+x2[0], x1[1]+x2[1]];\n}\n\ndouble d2(int[] p1, int[] p2, int[] x) {\n    int[] p21 = sub(p2, p1);\n    int[] p1x = sub(p1, x);\n    return (dot(p21, p21)*dot(p1x,p1x) - pow(dot(p21, p1x), 2))/to!double(dot(p21,p21));\n}\n\nint cross(int[] x, int[] y) {\n    return x[0]*y[1] - x[1]*y[0];\n}\n\nbool inTriangle(int[] p1, int[] p2, int[] p3, int[] x) {\n    auto u = sub(p1, x);\n    auto v = sub(p2, x);\n    auto w = sub(p3, x);\n    \n    auto a = cross(u, v);\n    auto b = cross(v, w);\n    auto c = cross(w, u);\n\n    return a*b > 0 && b*c > 0 && c*a > 0;\n}\n\nbool hasIntersection(int[] p1, int[] p2, int[] r0, int r) {\n    auto p21 = sub(p2, p1);\n    auto p1r = sub(p1, r0);\n    auto f0 = dot(p1r, p1r) - r*r;\n    auto f1 = dot(add(p21, p1r), add(p21, p1r)) - r*r;\n    if(f0 * f1 < 0) {\n        return true;\n    }\n    if(f0 < 0 && f1 < 0) {\n        return false;\n    }\n    if(dot(p21, p1r) > 0 || abs(dot(p21, p1r)) > dot(p21, p21)) {\n        return false;\n    }\n    return -dot(p21, p1r) + 2*(dot(p1r, p1r) - r*r) < 0;\n}\n\nstring test(int[] p1, int[] p2, int[] p3, int[] p4, int r) {\n    if(inTriangle(p1, p2, p3, p4) && min(d2(p1, p2, p4), d2(p2, p3, p4), d2(p3, p1, p4)) >= r*r) {\n        return \"a\";\n    }\n    if(r2(p1, p4) <= r*r && r2(p2,p4) <= r*r && r2(p3,p4) <= r*r) {\n        return \"b\";\n    }\n    if(hasIntersection(p1, p2, p4, r) || hasIntersection(p2, p3 ,p4, r) || hasIntersection(p3, p1, p4, r)) {\n        return \"c\";\n    }\n    return \"d\";\n}\n\nvoid main(){\n    while(true) {\n        auto xy1 = readInts();\n        if(xy1[0] == 0 && xy1[1] == 0) {\n            return;\n        }\n        auto xy2 = readInts();\n        auto xy3 = readInts();\n        auto xy4 = readInts();\n        auto r = readInt();\n        writeln(test(xy1, xy2, xy3, xy4, r));\n    }\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.math;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.geo.primitive, dcomp.geo.circle, dcomp.geo.polygon;\n\nbool solve() {\n    alias P = Point2D!double;\n    alias L = Line2D!double;\n    alias C = Circre2D!double;\n    P[] pol = new P[3];\n    foreach (i; 0..3) {\n        double x, y;\n        if (sc.read(x, y) != 2) return false;\n        pol[i] = P(x, y);\n    }\n    C c;\n    double x, y, r;\n    sc.read(x, y, r);\n    c = C(P(x, y), r);\n\n    double ma = -1e9, mi = 1e9;\n    foreach (i; 0..3) {\n        ma = max(ma, (pol[i]-c.p).abs);\n        mi = min(mi, distSP(L(pol.at(i), pol.at(i+1)), c.p));\n    }\n    if (sgn(ma, c.r) != -1) {\n        writeln(\"b\");\n        return true;\n    }\n    if (contains(pol, c.p) != 0 && sgn(c.r, mi) != -1) {\n        writeln(\"a\");\n        return true;\n    }\n    if (sgn(mi, c.r) != -1) {\n        writeln(\"c\");\n        return true;\n    }\n    writeln(\"d\");\n    return true;\n}\n\nint main() {\n    EPS!double = 1e-10;\n    while (solve()) {}\n    return 0;\n}\n\n\nScanner sc;\nstatic this() {\n    sc = new Scanner(stdin);\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/geo/polygon.d */\n// module dcomp.geo.polygon;\n\n// import dcomp.geo.primitive;\n\ninout(Point2D!R) at(R)(inout Point2D!R[] pol, size_t i) {\n    return pol[i<pol.length?i:i-pol.length];\n}\n\n \nint contains(R)(Point2D!R[] pol, Point2D!R p) {\n    import std.algorithm : swap;\n    int res = -1;\n    foreach (i; 0..pol.length) {\n        auto a = pol.at(i) - p, b = pol.at(i+1) - p;\n        if (ccw(a, b, Point2D!R(0, 0)) == 0) return 1;\n        if (a.y > b.y) swap(a, b);\n        if (a.y <= 0 && 0 < b.y) {\n            if (cross(a, b) < 0) res *= -1;\n        }\n    }\n    return res+1;\n}\n\n \n\nR area2(R)(Point2D!R[] pol) {\n    R u = 0;\n    foreach (i; 0..pol.length) {\n        auto a = pol.at(i), b = pol.at(i+1);\n        u += cross(a, b);\n    }\n    return u;\n}\n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1;\n    v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/geo/circle.d */\n// module dcomp.geo.circle;\n\n// import dcomp.geo.primitive;\n\nstruct Circre2D(R) {\n    Point2D!R p;\n    R r;\n    this(Point2D!R p, R r) {\n        this.p = p;\n        this.r = r;\n    }\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/geo/primitive.d */\n// module dcomp.geo.primitive;\n\nimport std.traits;\n\ntemplate EPS(R) {\n    R EPS;\n}\n\nint sgn(R)(R a) {\n    static if (isFloatingPoint!R) {\n        import std.math : isNaN;\n        assert(!isNaN(EPS!R));\n    }\n    if (a < -EPS!R) return -1;\n    if (a > EPS!R) return 1;\n    return 0;\n}\nint sgn(R)(R a, R b) {\n    return sgn(b-a);\n}\n\nstruct Point2D(T) {\n    T[2] d;\n    this(T x, T y) {this.d = [x, y];}\n    this(T[2] d) {this.d = d;}\n    @property ref inout(T) x() inout {return d[0];}\n    @property ref inout(T) y() inout {return d[1];}\n    ref inout(T) opIndex(size_t i) inout {return d[i];}\n    auto opOpAssign(string op)(in Point2D r) {\n        return mixin(\"this=this\"~op~\"r\");\n    }\n    auto opBinary(string op:\"+\")(in Point2D r) const {return Point2D(x+r.x, y+r.y);}\n    auto opBinary(string op:\"-\")(in Point2D r) const {return Point2D(x-r.x, y-r.y);}\n    static if (isFloatingPoint!T) {\n        T abs() {\n            import std.math : sqrt;\n            return (x*x+y*y).sqrt;\n        }\n        T arg() {\n            import std.math : atan2;\n            return atan2(y, x);\n        }\n        Point2D rot(T ar) {\n            import std.math : cos, sin;\n            auto cosAr = cos(ar), sinAr = sin(ar);\n            return Point2D(x*cosAr - y*sinAr, x*sinAr + y*cosAr);\n        }\n    }\n}\n\nbool near(T)(Point2D!T a, Point2D!T b) if (isIntegral!T) {\n    return a == b;\n}\n\nbool near(T)(Point2D!T a, Point2D!T b) if (isFloatingPoint!T) {\n    return !sgn((a-b).abs);\n}\n\nT dot(T)(in Point2D!T l, in Point2D!T r) {\n    return l[0]*r[0] + l[1]*r[1];\n}\n\nT cross(T)(in Point2D!T l, in Point2D!T r) {\n    return l[0]*r[1] - l[1]*r[0];\n}\n\n\n \n\n\nint ccw(R)(Point2D!R a, Point2D!R b, Point2D!R c) {\n    import std.stdio;\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\n\nstruct Line2D(R) {\n    Point2D!R x, y;\n    this(Point2D!R x, Point2D!R y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point2D!R vec() const { return y-x; }\n}\n\nR distLP(R)(Line2D!R l, Point2D!R p) if (isFloatingPoint!R) {\n    import std.math : abs;\n    return abs(cross(l.vec, p-l.x) / l.vec.abs);\n}\nR distSP(R)(Line2D!R s, Point2D!R p) if (isFloatingPoint!R) {\n    import std.algorithm : min;\n    auto s2 = Point2D!R(-s.vec.y, s.vec.x);\n    if (ccw(s.x, s.x+s2, p) == 1) return (s.x-p).abs;\n    if (ccw(s.y, s.y+s2, p) == -1) return (s.y-p).abs;\n    return min((s.x-p).abs, (s.y-p).abs, distLP(s, p));\n}\n\n \n\n \n \nint argcmp(T)(Point2D!T l, Point2D!T r) if (isIntegral!T) {\n    int sgn(Point2D!T p) {\n        if (p[1] < 0) return -1;\n        if (p[1] > 0) return 1;\n        if (p[0] < 0) return 2;\n        return 0;\n    }\n    int lsgn = sgn(l);\n    int rsgn = sgn(r);\n    if (lsgn < rsgn) return -1;\n    if (lsgn > rsgn) return 1;\n\n    T x = cross(l, r);\n    if (x > 0) return -1;\n    if (x < 0) return 1;\n\n    return 0;\n}\n\n\n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nint r2(int[] p1, int[] p2) {\n    int[] d = [p1[0]-p2[0], p1[1]-p2[1]];\n    return d[0]*d[0] + d[1]*d[1];\n}\n\nint dot(int[] x1, int[] x2) {\n    return x1[0] * x2[0] + x1[1] * x2[1];\n}\n\nint[] sub(int[] x1, int[] x2) {\n    return [x1[0]-x2[0], x1[1]-x2[1]];\n}\nint[] add(int[] x1, int[] x2) {\n    return [x1[0]+x2[0], x1[1]+x2[1]];\n}\n\ndouble d2(int[] p1, int[] p2, int[] x) {\n    int[] p21 = sub(p2, p1);\n    int[] p1x = sub(p1, x);\n    return (dot(p21, p21)*dot(p1x,p1x) - pow(dot(p21, p1x), 2))/to!double(dot(p21,p21));\n}\n\nint cross(int[] x, int[] y) {\n    return x[0]*y[1] - x[1]*y[0];\n}\n\nbool inTriangle(int[] p1, int[] p2, int[] p3, int[] x) {\n    auto u = sub(p1, x);\n    auto v = sub(p2, x);\n    auto w = sub(p3, x);\n    \n    auto a = cross(u, v);\n    auto b = cross(v, w);\n    auto c = cross(w, u);\n\n    return a*b > 0 && b*c > 0 && c*a > 0;\n}\n\nbool hasIntersection(int[] p1, int[] p2, int[] r0, int r) {\n    auto p21 = sub(p2, p1);\n    auto p1r = sub(p1, r0);\n    auto f0 = dot(p1r, p1r) - r*r;\n    auto f1 = dot(add(p21, p1r), add(p21, p1r)) - r*r;\n    if(f0 * f1 <= 0) {\n        return true;\n    }\n    if(f0 < 0 && f1 < 0) {\n        return false;\n    }\n    if(dot(p21, p1r) > 0 || abs(dot(p21, p1r)) > dot(p21, p21)) {\n        return false;\n    }\n    return -dot(p21, p1r) + 2*(dot(p1r, p1r) - r*r) <= 0;\n}\n\nstring test(int[] p1, int[] p2, int[] p3, int[] p4, int r) {\n    if(inTriangle(p1, p2, p3, p4) && min(d2(p1, p2, p4), d2(p2, p3, p4), d2(p3, p1, p4)) >= r*r) {\n        return \"a\";\n    }\n    if(r2(p1, p4) <= r*r && r2(p2,p4) <= r*r && r2(p3,p4) <= r*r) {\n        return \"b\";\n    }\n    if(hasIntersection(p1, p2, p4, r) || hasIntersection(p2, p3 ,p4, r) || hasIntersection(p3, p1, p4, r)) {\n        return \"c\";\n    }\n    return \"d\";\n}\n\nvoid main(){\n    while(true) {\n        auto xy1 = readInts();\n        if(xy1[0] == 0 && xy1[1] == 0) {\n            return;\n        }\n        auto xy2 = readInts();\n        auto xy3 = readInts();\n        auto xy4 = readInts();\n        auto r = readInt();\n        writeln(test(xy1, xy2, xy3, xy4, r));\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst EPS = 1e-9;\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point p) const {\n        static if (op == \"+\") {\n            return Point(x + p.x, y + p.y);\n        } else if (op == \"-\") {\n            return Point(x - p.x, y - p.y);\n        }\n    }\n    Point opBinary(string op)(double a) const {\n        static if (op == \"*\") {\n            return Point(a * x, a * y);\n        } else if (op == \"/\") {\n            return Point(x / a, y / a);\n        }\n    }\n}\n\ndouble distance2(in Point a, in Point b) {\n    double dx = a.x - b.x, dy = a.y - b.y;\n    return dx * dx + dy * dy;\n}\ndouble norm2(in Point a) {\n    return (a.x * a.x) + (a.y * a.y);\n}\ndouble norm(in Point a) {\n    return sqrt(norm2(a));\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\nstatic int CCW(Point a, Point b, Point c){\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;      // 反時計周り\n    if (cross(b, c) < -EPS) return -1;     // 時計周り\n    if (dot(b, c) < 0) return +2;          // c--a--b 直線\n    if (b.norm < c.norm) return -2;    // a--b--c 直線\n    return 0;                              // a--c--b 直線\n}\n\nPoint projection(in Segment s, in Point p) {\n    Point a = s.a, b = s.b;\n    Point u = b - a,\n          v = p - a;\n    double n = u.norm2;\n    return a + u * dot(u, v) / n;\n}\n\nstruct Segment {\n    Point a, b;\n}\n\nbool contains(in Segment s, in Point p) {\n    Point a = s.a, b = s.b;\n    if (a.x > b.x) swap(a, b);\n    if (! (a.x <= p.x && p.x <= b.x) ) return false;\n    if (a.y > b.y) swap(a, b);\n    return a.y <= p.y && p.y <= b.y;\n}\ndouble distance2(in Segment s, in Point p) {\n    if (s.contains(s.projection(p))) {\n        Point u = s.b - s.a,\n              v = p - s.a;\n        double x = cross(u, v),\n               y = distance2(s.a, s.b);\n        return (x * x / y);\n    } else {\n        return min(distance2(s.a, p), distance2(s.b, p));\n    }\n}\n \nvoid main() {\n    Point[] P = new Point[3];\n    Point C;\n    double R;\n    bool input() {\n        double x, y;\n        scanf(\"%lf %lf\\n\", &x, &y);\n        if (x == 0 && y == 0) return false;\n        P[0] = Point(x, y);\n        foreach (i; 1 .. 3) {\n            scanf(\"%lf %lf\\n\", &x, &y);\n            P[i] = Point(x, y);\n        }\n        scanf(\"%lf %lf\\n\", &C.x, &C.y);\n        scanf(\"%lf\\n\", &R);\n        return true;\n    }\n    \n    void solve() {\n        bool CheckB() {\n            // 三角形が円に含まれる\n            foreach (i; 0 .. 3) {\n                Point p = P[i];\n                if (C.distance2(p) > R * R) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        bool CheckC() {\n            // 交点が存在\n            foreach (i; 0 .. 3) {\n                Point p = P[i], q = P[(i + 1) % 3];\n                if (Segment(p, q).distance2(C) <= R * R) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        bool CheckA() {\n            // 円が三角形に含まれる\n            int ccw = CCW(P[0], P[1], C);\n            foreach (i; 1 .. 3) {\n                Point p = P[i], q = P[(i + 1) % 3];\n                if (ccw != CCW(p, q, C)) return false;\n            }\n            return true;\n        }\n        if (CheckB) {\n            writeln(\"b\");\n        } else if (CheckC) {\n            writeln(\"c\");\n        } else if (CheckA) {\n            writeln(\"a\");\n        } else {\n            writeln(\"d\");\n        }\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nlong r2(long[] p1, long[] p2) {\n    long[] d = [p1[0]-p2[0], p1[1]-p2[1]];\n    return d[0]*d[0] + d[1]*d[1];\n}\n\nlong dot(long[] x1, long[] x2) {\n    return x1[0] * x2[0] + x1[1] * x2[1];\n}\n\nlong[] sub(long[] x1, long[] x2) {\n    return [x1[0]-x2[0], x1[1]-x2[1]];\n}\nlong[] add(long[] x1, long[] x2) {\n    return [x1[0]+x2[0], x1[1]+x2[1]];\n}\n\ndouble d2(long[] p1, long[] p2, long[] x) {\n    long[] p21 = sub(p2, p1);\n    long[] p1x = sub(p1, x);\n    return (dot(p21, p21)*dot(p1x,p1x) - pow(dot(p21, p1x), 2))/to!double(dot(p21,p21));\n}\n\nlong cross(long[] x, long[] y) {\n    return x[0]*y[1] - x[1]*y[0];\n}\n\nbool inTriangle(long[] p1, long[] p2, long[] p3, long[] x) {\n    auto u = sub(p1, x);\n    auto v = sub(p2, x);\n    auto w = sub(p3, x);\n    \n    auto a = cross(u, v);\n    auto b = cross(v, w);\n    auto c = cross(w, u);\n\n    return a*b > 0 && b*c > 0 && c*a > 0;\n}\n\nbool hasIntersection(long[] p1, long[] p2, long[] r0, long r) {\n    auto p21 = sub(p2, p1);\n    auto p1r = sub(p1, r0);\n    auto f0 = dot(p1r, p1r) - r*r;\n    auto f1 = dot(add(p21, p1r), add(p21, p1r)) - r*r;\n    if(f0 * f1 <= 0) {\n        return true;\n    }\n    if(f0 < 0 && f1 < 0) {\n        return false;\n    }\n    if(dot(p21, p1r) > 0 || abs(dot(p21, p1r)) > dot(p21, p21)) {\n        return false;\n    }\n    return -dot(p21, p1r) + 2*(dot(p1r, p1r) - r*r) <= 0;\n}\n\nstring test(long[] p1, long[] p2, long[] p3, long[] p4, long r) {\n    if(inTriangle(p1, p2, p3, p4) && min(d2(p1, p2, p4), d2(p2, p3, p4), d2(p3, p1, p4)) >= r*r) {\n        return \"a\";\n    }\n    if(r2(p1, p4) <= r*r && r2(p2,p4) <= r*r && r2(p3,p4) <= r*r) {\n        return \"b\";\n    }\n    if(hasIntersection(p1, p2, p4, r) || hasIntersection(p2, p3 ,p4, r) || hasIntersection(p3, p1, p4, r)) {\n        return \"c\";\n    }\n    return \"d\";\n}\n\nvoid main(){\n    while(true) {\n        auto xy1 = readLongs();\n        if(xy1[0] == 0 && xy1[1] == 0) {\n            return;\n        }\n        auto xy2 = readLongs();\n        auto xy3 = readLongs();\n        auto xy4 = readLongs();\n        auto r = readLong();\n        writeln(test(xy1, xy2, xy3, xy4, r));\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def In():\n  return map(int, raw_input().split())\n\ndef D(a, b): # diatance between a and b\n  return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** .5\n\ndef f(P, O): # make a vector from O to P\n  return P[0] - O[0], P[1] - O[1]\n\ndef dot(a, b): #inner product of vectors a and b\n  return a[0] * b[0] + a[1] * b[1]\n\ndef cross(a, b): #cross product of vectors a and b\n  return a[0] * b[1] - a[1] * b[0]\n\ndef ab2c(a, b, c): # distance from point c to segment a-b\n  if dot(f(c, a), f(b, a)) < 0:\n    return D(a, c)\n  if dot(f(c, b), f(a, b)) < 0:\n    return D(b, c)\n  return abs(cross(f(b, a), f(c, a))) / D(b, a)\n\ndef isIn(P, O, P1, P2): # check if point P is in triangle O-P1-P2\n  a11, a21 = f(P1, O)\n  a12, a22 = f(P2, O)\n  x0, y0 = f(P, O)\n  det = 1.0 * a11 * a22 - a12 * a21\n  x = (a22 * x0 - a12 * y0) / det\n  y = (-a21 * x0 + a11 * y0) / det\n  return 0 <= x <= 1 and 0 <= y <= 1 and 0 <= x + y <= 1\ndef check(P4, r, P1, P2, P3):\n  if max([D(P4, P1), D(P4, P2), D(P4, P3)]) <= r:\n    return 2\n  h1 = ab2c(P1, P2, P4)\n  h2 = ab2c(P2, P3, P4)\n  h3 = ab2c(P3, P1, P4)\n  if isIn(P4, P1, P2, P3):\n    if min([h1, h2, h3]) >= r:\n      return 1\n  elif min([h1, h2, h3]) > r:\n    return 0\n  return 3\n\nwhile 1:\n  P1 = In()\n  if P1[0] == P1[1] == 0:\n    break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  print 'dabc'[check(P4, r, P1, P2, P3)]"
  },
  {
    "language": "Python",
    "code": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef check(P4,r,P1,P2,P3):\n  f1 = isIn(P4,P1,P2,P3)\n  f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r]\n  if f1:\n    if all(f): return 1\n    elif sum(f)>0: return 3\n  f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]\n  if all(f): return 2\n  elif sum(f)>0: return 3\n  return 0\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  print 'dabc'[check(P4,r,P1,P2,P3)]"
  },
  {
    "language": "Python",
    "code": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c):\n  f = (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])\n  if f>0: return 1\n  elif f<0: return -1\n  else: return 0\ndef isIn(x,p0,p1,p2):\n  f = [side(p0,p1,x), side(p1,p2,x), side(p2,p0,x)]\n  return min(f)>=0 or max(f)<=0\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef check(P4,r,P1,P2,P3):\n  if all([D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]): return 2\n  h1 = H(P4,P1,P2)\n  h2 = H(P4,P2,P3)\n  h3 = H(P4,P3,P1)\n  if isIn(P4,P1,P2,P3):\n    if all([h1>=r, h2>=r, h3>=r]): return 1\n  else:\n    if all([h1>r, h2>r, h3>r]): return 0\n  return 3\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  print 'dabc'[check(P4,r,P1,P2,P3)]"
  },
  {
    "language": "Python",
    "code": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>=0\ndef isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef check(P4,r,P1,P2,P3):\n  if all([D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]): return 2\n  h1 = H(P4,P1,P2)\n  h2 = H(P4,P2,P3)\n  h3 = H(P4,P3,P1)\n  if isIn(P4,P1,P2,P3):\n    if all([h1>=r, h2>=r, h3>=r]): return 1\n  else:\n    if all([h1>r, h2>r, h3>r]): return 0\n  return 3\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  print 'dabc'[check(P4,r,P1,P2,P3)]"
  },
  {
    "language": "Python",
    "code": "def In(): return map(int, raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef f(P,O): return P[0]-O[0], P[1]-O[1]\ndef dot(a,b): return a[0]*b[0]+a[1]*b[1]\ndef cross(a,b): return a[0]*b[1]-a[1]*b[0]\n\ndef ab2c(a,b,c):\n  if dot(f(c,a),f(b,a))<0: return D(a,c)\n  if dot(f(c,b),f(a,b))<0: return D(b,c)\n  return abs(cross(f(b,a),f(c,a)))/D(b,a)\n\ndef isIn(P,O,P1,P2):\n  a11,a21 = f(P1,O)\n  a12,a22 = f(P2,O)\n  x0,y0 = f(P,O)\n  det = 1.0*a11*a22-a12*a21\n  x = (a22*x0-a12*y0)/det\n  y = (-a21*x0+a11*y0)/det\n  return 0<=x<=1 and 0<=y<=1 and 0<=x+y<=1\n\ndef check(P4,r,P1,P2,P3):\n  if max([D(P4,P1),D(P4,P2),D(P4,P3)])<=r: return 2\n  h1 = ab2c(P1,P2,P4)\n  h2 = ab2c(P2,P3,P4)\n  h3 = ab2c(P3,P1,P4)\n  if isIn(P4,P1,P2,P3):\n    if min([h1,h2,h3])>=r: return 1\n  elif min([h1,h2,h3])>r: return 0\n  return 3\n\nwhile 1:\n  P1 = In()\n  if P1[0]== P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  print 'dabc'[check(P4,r,P1,P2,P3)]"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport math\n\n\nclass Points(object):\n    pass\n\n\ndef sub_vector(a, b):\n    ret = Points()\n    ret.x = a.x - b.x\n    ret.y = a.y - b.y\n    return ret\n\n\ndef hittest_point_polygon(a, b, c, p):\n    ab = sub_vector(b, a)\n    bp = sub_vector(p, b)\n    bc = sub_vector(c, b)\n    cp = sub_vector(p, c)\n    ca = sub_vector(a, c)\n    ap = sub_vector(p, a)\n\n    #外積    Z成分だけ計算すればよいです\n    c1 = ab.x * bp.y - ab.y * bp.x\n    c2 = bc.x * cp.y - bc.y * cp.x\n    c3 = ca.x * ap.y - ca.y * ap.x\n\n    if (c1 > 0 and c2 > 0 and c3 > 0) or (c1 < 0 and c2 < 0 and c3 < 0):\n        #三角形の内側に点がある\n        return True\n    #三角形の外側に点がある\n    return False\n\n\ndef get_dist(a, b):\n    return math.sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2))\n\n\ndef naisetsu_r(p1, p2, p3):\n    a = get_dist(p1, p2)\n    b = get_dist(p1, p3)\n    c = get_dist(p2, p3)\n    s = (a + b + c) / 2\n    S = math.sqrt(s * (s-a) * (s-b) * (s-c))\n    return S / s\n\nf = lambda: map(int, raw_input().split())\nwhile True:\n    a, b, c, p = [Points() for i in range(4)]\n    a.x, a.y = f()\n    if a.x == a.y == 0: break\n    b.x, b.y = f()\n    c.x, c.y = f()\n    p.x, p.y = f()\n    r = input()\n    if hittest_point_polygon(a, b, c, p) and naisetsu_r(a, b, c) >= r:\n        print \"a\"\n    elif get_dist(p, a) <= r and get_dist(p, b) <= r and get_dist(p, c) <= r:\n        print \"b\"\n    elif get_dist(p, a) <= r or get_dist(p, b) <= r or get_dist(p, c) <= r:\n        print \"c\"\n    else:\n        print \"d\""
  },
  {
    "language": "Python",
    "code": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef check(P4,r,P1,P2,P3):\n  if all([D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]): return 2\n  h1 = H(P4,P1,P2)\n  h2 = H(P4,P2,P3)\n  h3 = H(P4,P3,P1)\n  if isIn(P4,P1,P2,P3):\n    if all([h1>=r, h2>=r, h3>=r]): return 1\n  else:\n    if all([h1>r, h2>r, h3>r]): return 0\n  return 3\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  print 'dabc'[check(P4,r,P1,P2,P3)]"
  },
  {
    "language": "Python",
    "code": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c):\n  f = (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])\n  if f>0: return 1\n  elif f<0: return -1\n  else return 0\ndef isIn(x,p0,p1,p2):\n  f1 = side(p0,p1,x)\n  f2 = side(p1,p2,x)\n  f3 = side(p2,p0,x)\n  return (f1>=0 and f2>=0 and f3>=0) or (f1<=0 and f2<=0 and f3<=0)\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef check(P4,r,P1,P2,P3):\n  if all([D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]): return 2\n  h1 = H(P4,P1,P2)\n  h2 = H(P4,P2,P3)\n  h3 = H(P4,P3,P1)\n  if isIn(P4,P1,P2,P3):\n    if all([h1>=r, h2>=r, h3>=r]): return 1\n  else:\n    if all([h1>r, h2>r, h3>r]): return 0\n  return 3\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  print 'dabc'[check(P4,r,P1,P2,P3)]"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport math\n\n\nclass Points(object):\n    pass\n\n\ndef sub_vector(a, b):\n    ret = Points()\n    ret.x = a.x - b.x\n    ret.y = a.y - b.y\n    return ret\n\n\ndef hittest_point_polygon(a, b, c, p):\n    ab = sub_vector(b, a)\n    bp = sub_vector(p, b)\n    bc = sub_vector(c, b)\n    cp = sub_vector(p, c)\n    ca = sub_vector(a, c)\n    ap = sub_vector(p, a)\n\n    #外積    Z成分だけ計算すればよいです\n    c1 = ab.x * bp.y - ab.y * bp.x\n    c2 = bc.x * cp.y - bc.y * cp.x\n    c3 = ca.x * ap.y - ca.y * ap.x\n\n    if (c1 > 0 and c2 > 0 and c3 > 0) or (c1 < 0 and c2 < 0 and c3 < 0):\n        #三角形の内側に点がある\n        return True\n    #三角形の外側に点がある\n    return False\n\n\ndef get_dist(a, b):\n    return math.sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2))\n\nf = lambda: map(int, raw_input().split())\nwhile True:\n    a, b, c, p = [Points() for i in range(4)]\n    a.x, a.y = f()\n    if a.x == a.y == 0: break\n    b.x, b.y = f()\n    c.x, c.y = f()\n    p.x, p.y = f()\n    r = input()\n    if hittest_point_polygon(a, b, c, p) and get_dist(p, a) > r and get_dist(p, b) > r and get_dist(p, c) > r:\n        print \"a\"\n    elif get_dist(p, a) < r and get_dist(p, b) < r and get_dist(p, c) < r:\n        print \"b\"\n    elif get_dist(p, a) < r or get_dist(p, b) < r or get_dist(p, c) < r:\n        print \"c\"\n    else:\n        print \"d\""
  },
  {
    "language": "Python",
    "code": "def contain(x, y, r):\n    return x**2 + y**2 <= r**2\ndef outer_p(x0, y0, x1, y1):\n    return (x0*y1 - y0*x1)\ndef line_segment_circle(x0, y0, x1, y1, r, border=True):\n    A = x0**2 + y0**2\n    B = x0*x1 + y0*y1\n    C = x1**2 + y1**2 - r**2\n    D = B**2 - A*C\n    if border:\n        if D < 0:\n            return 0\n        if B <= 0 and B**2 > D:\n            return 0\n        if B - A >= 0 and (B - A)**2 > D:\n            return 0\n    else:\n        if D <= 0:\n            return 0\n        if B <= 0 and B**2 >= D:\n            return 0\n        if B - A >= 0 and (B - A)**2 >= D:\n            return 0\n    return 1\n\nwhile 1:\n    x1, y1 = map(int, input().split())\n    if x1 == y1 == 0:\n        break\n    x2, y2 = map(int, input().split())\n    x3, y3 = map(int, input().split())\n\n    cx, cy = map(int, input().split())\n    r = int(input())\n\n    C1 = contain(x1-cx, y1-cy, r)\n    C2 = contain(x2-cx, y2-cy, r)\n    C3 = contain(x3-cx, y3-cy, r)\n    if C1 and C2 and C3:\n        print(\"b\")\n        continue\n    if C1 or C2 or C3:\n        print(\"c\")\n        continue\n    p1 = outer_p(x2-x1, y2-y1, cx-x1, cy-y1)\n    p2 = outer_p(x3-x2, y3-y2, cx-x2, cy-y2)\n    p3 = outer_p(x1-x3, y1-y3, cx-x3, cy-y3)\n    if 1 == (p1 < 0) == (p2 < 0) == (p3 < 0) or 1 == (p1 > 0) == (p2 > 0) == (p3 > 0):\n        p1 = line_segment_circle(x2-x1, y2-y1, cx-x1, cy-y1, r, False)\n        p2 = line_segment_circle(x3-x2, y3-y2, cx-x2, cy-y2, r, False)\n        p3 = line_segment_circle(x1-x3, y1-y3, cx-x3, cy-y3, r, False)\n        if p1 or p2 or p3:\n            print(\"c\")\n        else:\n            print(\"a\")\n        continue\n    p1 = line_segment_circle(x2-x1, y2-y1, cx-x1, cy-y1, r, True)\n    p2 = line_segment_circle(x3-x2, y3-y2, cx-x2, cy-y2, r, True)\n    p3 = line_segment_circle(x1-x3, y1-y3, cx-x3, cy-y3, r, True)\n    if p1 or p2 or p3:\n        print(\"c\")\n        continue\n    print(\"d\")\n"
  },
  {
    "language": "Python",
    "code": "def In(): return map(int,raw_input().split())\ndef D(a,b): return ((a[0]-b[0])**2+(a[1]-b[1])**2)**.5\ndef side(a, b, c): return (c[1]-a[1])*(b[0]-a[0])-(b[1]-a[1])*(c[0]-a[0])>0\ndef isIn(x,p0,p1,p2): return (side(p0,p1,x)==side(p1,p2,x)==side(p2,p0,x))\ndef S(a,b,c): return abs(a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2.0\ndef H(P1,P2,P3): return 2*S(P1,P2,P3)/D(P2,P3)\ndef CinT(P4,r,P1,P2,P3):\n  f1 = isIn(P4,P1,P2,P3)\n  f = [H(P4,P1,P2)>=r, H(P4,P2,P3)>=r, H(P4,P3,P1)>=r]\n  if f1:\n    if all(f): return 1\n    elif any(f): return 3\n  return 0\n\ndef TinC(P4,r,P1,P2,P3):\n  f = [D(P4,P1)<=r, D(P4,P2)<=r, D(P4,P3)<=r]\n  if all(f): return 2\n  elif any(f): return 3\n  return 0\n  \nwhile 1:\n  P1 = In()\n  if P1[0]==P1[1]==0: break\n  P2 = In()\n  P3 = In()\n  P4 = In()\n  r = int(raw_input())\n  f = CinT(P4,r,P1,P2,P3)\n  if not f: f = TinC(P4,r,P1,P2,P3)\n  print 'dabc'[f]"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport math\n\n\nclass Points(object):\n    pass\n\n\ndef sub_vector(a, b):\n    ret = Points()\n    ret.x = a.x - b.x\n    ret.y = a.y - b.y\n    return ret\n\n\ndef hittest_point_polygon(a, b, c, p):\n    ab = sub_vector(b, a)\n    bp = sub_vector(p, b)\n    bc = sub_vector(c, b)\n    cp = sub_vector(p, c)\n    ca = sub_vector(a, c)\n    ap = sub_vector(p, a)\n\n    #外積    Z成分だけ計算すればよいです\n    c1 = ab.x * bp.y - ab.y * bp.x\n    c2 = bc.x * cp.y - bc.y * cp.x\n    c3 = ca.x * ap.y - ca.y * ap.x\n\n    if (c1 > 0 and c2 > 0 and c3 > 0) or (c1 < 0 and c2 < 0 and c3 < 0):\n        #三角形の内側に点がある\n        return True\n    #三角形の外側に点がある\n    return False\n\n\ndef get_dist(a, b):\n    return math.sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2))\n\nf = lambda: map(int, raw_input().split())\nwhile True:\n    a, b, c, p = [Points() for i in range(4)]\n    a.x, a.y = f()\n    if a.x == a.y == 0: break\n    b.x, b.y = f()\n    c.x, c.y = f()\n    p.x, p.y = f()\n    r = input()\n    if hittest_point_polygon(a, b, c, p) and get_dist(p, a) >= r and get_dist(p, b) >= r and get_dist(p, c) >= r:\n        print \"a\"\n    elif get_dist(p, a) <= r and get_dist(p, b) <= r and get_dist(p, c) <= r:\n        print \"b\"\n    elif get_dist(p, a) <= r or get_dist(p, b) <= r or get_dist(p, c) <= r:\n        print \"c\"\n    else:\n        print \"d\""
  }
]