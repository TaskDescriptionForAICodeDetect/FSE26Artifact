[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nobject Main extends App {\n  import scala.io.StdIn._\n\n  val isChildOf = \"\"\"^(\\w+) is a child of (\\w+).$\"\"\".r\n  val isParentOf = \"\"\"^(\\w+) is the parent of (\\w+).$\"\"\".r\n  val isSiblingOf = \"\"\"^(\\w+) is a sibling of (\\w+).$\"\"\".r\n  val isDescendantOf = \"\"\"^(\\w+) is a descendant of (\\w+).$\"\"\".r\n  val isAncestorOf = \"\"\"^(\\w+) is an ancestor of (\\w+).$\"\"\".r\n  solve\n  def solve: Unit = {\n    val Array(personSize, querySize) = readLine.trim.split(' ').map(_.toInt)\n    if (personSize == 0) return\n    val persons = new ArrayBuffer[List[Person]]()\n    val map = new mutable.HashMap[String, Person]()\n    for (_ ← 0 until personSize){\n      readLine.span(_ == ' ') match {\n        case (k, name) ⇒\n          if (persons.size <= k.length) persons.append(Nil)\n          val p = if (k.length == 0) {\n            Person()\n          }else {\n            val p = Person()\n            p.ancestor = Some(persons(k.length - 1).head)\n            p\n          }\n          persons(k.length) ::= p\n          map.put(name, p)\n      }\n    }\n    for (_ ← 0 until querySize){\n      println(readLine.trim match {\n        case a isChildOf b ⇒\n          if (map(a).isChildOf(map(b))) \"True\"\n          else \"False\"\n        case a isParentOf b ⇒\n          if (map(a).isParentOf(map(b))) \"True\"\n          else \"False\"\n        case a isSiblingOf b ⇒\n          if (map(a).isSiblingOf(map(b))) \"True\"\n          else \"False\"\n        case a isDescendantOf b ⇒\n          if (map(a).isDescendantOf(map(b))) \"True\"\n          else \"False\"\n        case a isAncestorOf b ⇒\n          if (map(a).isAncestorOf(map(b))) \"True\"\n          else \"False\"\n        case _ ⇒ ???\n      })\n    }\n    println()\n    solve\n  }\n  object Person{\n    def apply(): Person = new Person()\n  }\n  class Person(var ancestor: Option[Person] = None) {\n    def isSiblingOf(that: Person): Boolean = {\n      ancestor.flatMap(person ⇒ that.ancestor.map(_ == person)).getOrElse(false)\n    }\n    def isChildOf(that: Person): Boolean = {\n      ancestor.contains(that)\n    }\n    def isParentOf(that: Person): Boolean = {\n      that.ancestor.contains(this)\n    }\n    def isDescendantOf(that: Person): Boolean = {\n      isChildOf(that) || ancestor.exists(_.isDescendantOf(that))\n    }\n    def isAncestorOf(that: Person): Boolean = {\n      that.isDescendantOf(this)\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\nint par[1010];\nint gen[1010];\nchar namex[99], namey[99], rel[99];\n\nbool parent(int x, int y){\n\treturn par[y] == x;\n}\n\nbool sibling(int x, int y){\n\treturn par[x] == par[y];\n}\n\nbool ancestor(int x, int y){\n\twhile(y != -1){\n\t\ty = par[y];\n\t\tif( x == y ) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n, m;\n\tstring str;\n\n\twhile( cin >> n >> m, n != 0 ){\n\t\tcin.ignore();\n\t\t\n\t\tmap<string,int> names;\n\t\tgen[0] = -1;\n\t\t\n\t\tint indent = 0;\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tgetline(cin, str);\n\t\t\tsscanf(str.c_str(), \" %n%s\", &indent, namex);\n\t\t\t\n\t\t\tint k = names.size();\n\t\t\tnames[namex] = k;\n\t\t\t\n\t\t\tpar[k] = gen[indent];\n\t\t\tgen[indent + 1] = k;\n\t\t}\n\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tgetline(cin, str);\n\t\t\tsscanf(str.c_str(), \"%s%*s%*s %s%*s %[^.]\", namex, rel, namey);\n\t\t\t\n\t\t\tint x = names[namex];\n\t\t\tint y = names[namey];\n\t\t\tbool f = false;\n\n\t\t\tswitch( rel[0] ){\n\t\t\t\tcase 'c':\n\t\t\t\t\tf = parent(y, x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tf = parent(x, y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tf = sibling(x, y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tf = ancestor(y, x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'a':\n\t\t\t\t\tf = ancestor(x, y);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tputs( f ? \"True\" : \"False\" );\n\t\t}\n\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\nchar str[128];\nchar in[128];\nint now[128];\nvector<int>g[1100];\nchar ps[6][128];\nint d[1100];\nint dfs(int a,int b){\n\tif(a==b)return 1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(dfs(g[a][i],b))return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)g[i].clear();\n\t\tgets(str);\n\t\tmap<string,int> m;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tgets(str);\n\t\t\tint dep=0;\n\t\t\tfor(int j=0;;j++){\n\t\t\t\tif(str[j]!=' ')break;dep++;\n\t\t\t}\n\t\t\td[i]=dep;\n\t\t\tsscanf(str,\"%s\",in);\n\t\t\tstring tmp=in;\n\t\t\tm[tmp]=i;\n\t\t\tnow[dep]=i;\n\t\t\tif(dep)g[now[dep-1]].push_back(i);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<6;j++)scanf(\"%s\",ps[j]);\n\t\t\tfor(int j=0;ps[5][j];j++){\n\t\t\t\tif(ps[5][j]=='.')ps[5][j]=0;\n\t\t\t}\n\t\t\tstring tmp=ps[0];\n\t\t\tint X=m[tmp];\n\t\t\ttmp=ps[5];\n\t\t\tint Y=m[tmp];\n\t\t\tbool ok=false;\n\t\t\tif(ps[3][0]=='c'){\n\t\t\t\tfor(int j=0;j<g[Y].size();j++)if(g[Y][j]==X)ok=true;\n\t\t\t}else if(ps[3][0]=='p'){\n\t\t\t\tfor(int j=0;j<g[X].size();j++)if(g[X][j]==Y)ok=true;\n\t\t\t}else if(ps[3][0]=='s'){\n\t\t\t\tif(d[X]||d[Y]){\n\t\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\t\tint x=0;int y=0;\n\t\t\t\t\t\tfor(int k=0;k<g[j].size();k++){\n\t\t\t\t\t\t\tif(g[j][k]==X)x=1;\n\t\t\t\t\t\t\tif(g[j][k]==Y)y=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x&&y){\n\t\t\t\t\t\t\tok=true;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else ok=true;\n\t\t\t}else if(ps[3][0]=='d'){\n\t\t\t\tif(dfs(Y,X))ok=true;\n\t\t\t}else if(ps[3][0]=='a'){\n\t\t\t\tif(dfs(X,Y))ok=true;\n\t\t\t}\n\t\t\tif(ok)printf(\"True\\n\");\n\t\t\telse printf(\"False\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap<string,int> mp;\nint ind[1001],par[1001];\nbool ko(int a,int b){\n  return par[a]==b;\n}\n\nbool sos(int a,int b){\n  while(a!=b&&a)\n    a=par[a];\n  return a==b;\n}\n\nint main(){\n  int n,m,T=0;\n  string s;\n  char c;\n  while(cin>>n>>m,n){\n    if(T++)cout<<endl;\n    scanf(\"%c\",&c);\n    memset(ind,0,sizeof(ind));\n    memset(par,0,sizeof(par));\n    mp.clear();\n    par[0]=-1;\n    for(int i=0;i<n;i++){\n      int k=0;\n      while(scanf(\"%c\",&c)&&c==' ')k++;\n      cin>>s;\n      s=c+s;\n      scanf(\"%c\",&c);\n      mp[s]=i;\n      ind[i]=k;\n      for(int j=i-1;j>=0;j--)\n\tif(ind[j]==k-1){par[i]=j;break;}\n    }\n\n    for(int i=0;i<m;i++){\n      string q[6];\n      for(int j=0;j<6;j++)cin>>q[j];\n      bool ans;\n      q[5]=q[5].substr(0,q[5].size()-1); \n      int a=mp[q[0]],b=mp[q[5]];\n      if(q[3]==\"child\")ans=ko(a,b);\n      if(q[3]==\"parent\")ans=ko(b,a);\n      if(q[3]==\"sibling\")ans=(par[a]==par[b]);\n      if(q[3]==\"descendant\")ans=sos(a,b);\n      if(q[3]==\"ancestor\")ans=sos(b,a);\n      if(ans)cout<<\"True\"<<endl;\n      else cout<<\"False\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1001\nusing namespace std;\nvector<int> T[N];\nint par[N];\nmap<string,int> M;\nstring mp[N];\nint n,m;\nint pos=0,used[N];\n\nint cnt(int i){\n  int sp=0;\n  while(mp[i][sp]==' ')sp++;  \n  return sp;\n}\n\nvoid mk_tree(){\n  int idx=pos;\n  int sp1=cnt(pos++);\n  while(pos<n){\n    int sp2=cnt(pos);\n    if(sp1<sp2){\n      T[idx].push_back(pos);\n      par[pos]=idx;\n      mk_tree();\n    }\n    else break;\n  }\n}\n\nbool check(int pos,int target){\n  if(pos==target) return 1;\n  for(int i=0;i<T[pos].size();i++)\n    if(check(T[pos][i],target))return 1;\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(n==0&&m==0)break;\n  \n  M.clear();\n  memset(used,0,sizeof(used));\n  memset(par,0,sizeof(par));\n  for(int i=0;i<N;i++)T[i].clear();\n  \n  getline(cin,mp[0]);\n  for(int i=0;i<n;i++){\n    getline(cin,mp[i]);\n    int j=0;\n    while(mp[i][j]==' ')j++;\n    M[mp[i].substr(j,mp[i].size()-j)] = i;\n  }\n  pos=0;\n  mk_tree();  \n\n  while(m--){\n    string name1,str,name2,tmp;\n    cin>>name1>>tmp>>tmp>>str>>tmp>>name2;\n    name2=name2.substr(0,name2.size()-1);\n    int ans=0;\n    if(str==\"child\"||str==\"parent\"){\n      if(str==\"child\")swap(name1,name2);\n      int idx=M[name1],target=M[name2];\n      for(int i=0;i<(int)T[idx].size();i++)if(T[idx][i]==target)ans=1;\n    }\n    if(str==\"ancestor\"||str==\"descendant\"){\n      if(str==\"descendant\")swap(name1,name2);\n      ans=check(M[name1],M[name2]);\n    }\n    if(str==\"sibling\") ans=par[M[name1]]==par[M[name2]];\n    cout<<(ans?\"True\":\"False\")<<endl;\n  \n  }\n  cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nstruct node{\n  string name;\n  vector<node *> childlen;\n  \n  node(string name):name(name){}\n};\n\nvoid add_child(node * p, string new_name, const vector<string> &path, int depth){\n  if( depth == (int)path.size() ){\n    p->childlen.push_back( new node(new_name) );\n    return ;\n  }\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( path[depth] == p->childlen[i]->name ){\n      add_child( p->childlen[i], new_name, path, depth+1 );\n    }\n  }\n  return ;\n}\n\nvoid print(node *p){\n  cout << p->name << endl;\n  cout << \"Childlen :\" << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    cout << p->childlen[i]->name << endl;\n  }\n  cout << \"-----\" << endl << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    print( p->childlen[i] );\n  }\n}\n\nbool judge(node * p, const string &a, const string &b, const string &rel, bool Xfnd){\n  if(p->name == b){\n    return Xfnd;\n  }\n\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    for(int j = i+1; j < (int)p->childlen.size(); ++j){\n      if( (p->childlen[i]->name == a && p->childlen[j]->name == b) ||\n          (p->childlen[i]->name == b && p->childlen[j]->name == a) ){\n        return true;\n      }\n    }\n  }\n  \n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( p->name==a && p->childlen[i]->name == b && rel == \"child\" ) return true;\n    if( judge(p->childlen[i], a, b, rel, p->name==a|Xfnd) && rel != \"child\" ) return true;\n  }\n  return false;\n}\n\nint main()\n{\n  while(true){\n    int n,m;\n    string dam;\n    cin >> n >> m;\n    if( n == 0  && m == 0 ) break;\n\n    getline(cin,dam);\n    node * root = new node(\"___ROOT\");\n\n    int spaces = -1;\n    vector<string> path;\n    for(int i = 0; i < n; ++i){\n      string s;\n      getline(cin,s);\n      \n      int csp = 0;\n      for(int j = 0; j < (int)s.length(); ++j){\n        if( s[j] == ' ' ) ++csp;\n        else break;\n      }\n      s = s.substr( csp );\n\n      if( csp < spaces ){\n        path.pop_back();\n        for(int j = 0; j < spaces - csp; ++j){\n          path.pop_back();\n        }\n        add_child(root, s, path, 0);\n        path.push_back(s);\n\n      }else if( csp == spaces ){\n        path.pop_back();\n        add_child(root, s, path, 0);\n        path.push_back(s);\n        \n      }else if( csp == spaces + 1 ){\n        add_child(root, s, path, 0);\n        path.push_back( s );\n      }\n\n      spaces = csp;\n    }\n    // print(root);\n    \n    for(int i = 0; i < m; ++i){\n      string X,Y,rel;\n      cin >> X >> dam >> dam >> rel >> dam >> Y;\n      Y = Y.substr(0, Y.length()-1);\n      if( rel == \"parent\" ){\n        rel = \"child\";\n        swap(X,Y);\n      }\n      if( rel == \"ancestor\" ){\n        rel = \"descendant\";\n        swap(X,Y);\n      }\n      \n      if( judge(root,Y,X,rel,false) ){\n        cout << \"True\" << endl;\n      }else{\n        cout <<\"False\"<<endl;\n      }\n      \n    }\n    cout << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint m,n;\n\nstruct nodeInfo{\n    int depth;\n};\n\nmap<string,int> id;\nvector<int> G[1010];\nnodeInfo nif[1010];\n\nint main(){\n    bool f=false;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        if(f)\n            cout<<endl;\n        f=true;\n        id.clear();\n        string str;\n        getline(cin,str);\n        for(int i = 0; i < 1010; i++)G[i].clear();\n        int depth=-1;\n        int cp=-1;\n        for(int i = 0; i < n; i++){\n            getline(cin,str);\n            int cnt=0;\n            for(int j = 0; ;j++){\n                if(str[j]==' ')continue;\n                else{\n                    str=str.substr(j);\n                    cnt=j;\n                    break;\n                }\n            }\n            id[str]=i;\n            // cntツづ個青板つセツつッツ親ツづ可姪淞づィツ、ツつサツつアツづ可ノツーツドツづーツ挿ツ禿シツつキツづゥ\n            if(cp==-1)\n                cp=i;\n            else if(depth<cnt){\n                G[cp].push_back(i);\n                G[i].push_back(cp);\n                cp=i;\n            }\n            else if(depth==cnt){\n                int back=G[cp][0];\n                G[back].push_back(i);\n                G[i].push_back(back);\n                cp=i;\n            }\n            else if(depth>cnt){\n                // ツ債キツ閉ェツづ個深ツつウツつセツつッツ親ツづ鳴姪淞づゥ\n                for(int j = 0; j <= depth-cnt; j++){\n                    int back=G[cp][0];\n                    cp=back;\n                }\n                G[cp].push_back(i);\n                G[i].push_back(cp);\n                cp=i;\n            }\n            depth=cnt;\n            nif[i].depth=depth;\n        }\n        for(int j = 0; j < m; j++){\n            string name1,name2;\n            string tmp;\n            string order;\n            cin>>name1>>tmp>>tmp>>order>>tmp>>name2;\n            name2=name2.substr(0,name2.size()-1);\n            int n1idx=id[name1];\n            int n2idx=id[name2];\n            bool match=false;\n            if(order==\"child\"){\n                for(int i = 0; i < G[n2idx].size(); i++){\n                    if(nif[G[n2idx][i]].depth>nif[n2idx].depth&&G[n2idx][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else if(order==\"ancestor\"){\n                int cnode=n2idx;\n                while(1){\n                    if(cnode==n1idx){\n                        match=true;\n                        break;\n                    }\n                    // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n                    if(cnode==0)\n                        break;\n                    else{\n                        for(int i = 0; i < G[cnode].size(); i++){\n                            if(nif[G[cnode][i]].depth<nif[depth].depth){\n                                cnode=G[cnode][i];\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            else if(order==\"sibling\"){\n                int cnode=n2idx;\n                // ツ暗ェツづつ親ツづ可姪淞づゥ\n                for(int i = 0; i < G[cnode].size(); i++){\n                    if(nif[G[cnode][i]].depth<nif[depth].depth){\n                        cnode=G[cnode][i];\n                        break;\n                    }\n                }\n                for(int i = 0; i < G[cnode].size(); i++){\n                    if(G[cnode][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else if(order==\"parent\"){\n                swap(n2idx,n1idx);\n                for(int i = 0; i < G[n2idx].size(); i++){\n                    if(nif[G[n2idx][i]].depth>nif[n2idx].depth&&G[n2idx][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else{\n                swap(n2idx,n1idx);\n                int cnode=n2idx;\n                while(1){\n                    if(cnode==n1idx){\n                        match=true;\n                        break;\n                    }\n                    // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n                    if(cnode==0)\n                        break;\n                    else{\n                        for(int i = 0; i < G[cnode].size(); i++){\n                            if(nif[G[cnode][i]].depth<nif[depth].depth){\n                                cnode=G[cnode][i];\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            if(match)\n                cout<<\"True\"<<endl;\n            else\n                cout<<\"False\"<<endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nstruct node{\n  string name;\n  vector<node *> childlen;\n  \n  node(string name):name(name){}\n};\n\nvoid add_child(node * p, string new_name, const vector<string> &path, int depth){\n  if( depth == (int)path.size() ){\n    p->childlen.push_back( new node(new_name) );\n    return ;\n  }\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( path[depth] == p->childlen[i]->name ){\n      add_child( p->childlen[i], new_name, path, depth+1 );\n    }\n  }\n  return ;\n}\n\nvoid print(node *p){\n  cout << p->name << endl;\n  cout << \"Childlen :\" << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    cout << p->childlen[i]->name << endl;\n  }\n  cout << \"-----\" << endl << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    print( p->childlen[i] );\n  }\n}\n\nbool judge(node * p, const string &a, const string &b, const string &rel, bool Xfnd){\n  if(p->name == b){\n    return Xfnd;\n  }\n\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    for(int j = i+1; j < (int)p->childlen.size(); ++j){\n      if( (p->childlen[i]->name == a && p->childlen[j]->name == b) ||\n          (p->childlen[i]->name == b && p->childlen[j]->name == a) ){\n        return true;\n      }\n    }\n  }\n  \n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    // cout << \"A\" << p->name << \"B\" << p->childlen[i]->name << \"C\" << a << \"D\" << b << endl;\n    if( p->name==a && p->childlen[i]->name == b && rel == \"child\" ) return true;\n    if( judge(p->childlen[i], a, b, rel, p->name==a|Xfnd) ) return true;\n  }\n  return false;\n}\n\nint main()\n{\n  while(true){\n    int n,m;\n    string dam;\n    cin >> n >> m;\n    if( n == 0  && m == 0 ) break;\n\n    getline(cin,dam);\n    node * root = new node(\"___ROOT\");\n\n    int spaces = -1;\n    vector<string> path;\n    for(int i = 0; i < n; ++i){\n      string s;\n      getline(cin,s);\n      \n      int csp = 0;\n      for(int j = 0; j < (int)s.length(); ++j){\n        if( s[j] == ' ' ) ++csp;\n        else break;\n      }\n      s = s.substr( csp );\n\n      if( csp < spaces ){\n        path.pop_back();\n        for(int j = 0; j < spaces - csp; ++j){\n          path.pop_back();\n        }\n        add_child(root, s, path, 0);\n        path.push_back(s);\n\n      }else if( csp == spaces ){\n        path.pop_back();\n        add_child(root, s, path, 0);\n        path.push_back(s);\n        \n      }else if( csp == spaces + 1 ){\n        add_child(root, s, path, 0);\n        path.push_back( s );\n      }\n\n      spaces = csp;\n    }\n    // print(root);\n    \n    for(int i = 0; i < m; ++i){\n      string X,Y,rel;\n      cin >> X >> dam >> dam >> rel >> dam >> Y;\n      Y = Y.substr(0, Y.length()-1);\n      if( rel == \"parent\" ){\n        rel = \"child\";\n        swap(X,Y);\n      }\n      if( rel == \"ancestor\" ){\n        rel = \"descendant\";\n        swap(X,Y);\n      }\n      \n      if( judge(root,Y,X,rel,false) ){\n        cout << \"True\" << endl;\n      }else{\n        cout <<\"False\"<<endl;\n      }\n      \n    }\n    cout << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint par[1010];\nint last[100];\nmap<string, int> name;\n\nbool check_ancestor(int a, int d){\n\tif (a < 0 || d < 0) return false;\n\tif (a == par[d]) return true;\n\treturn check_ancestor(a, par[d]);\n}\n\nint main(){\n\tint n, q;\n\twhile (cin >> n >> q, n|q){\n\t\tname.clear();\n\t\tMEMSET(last, -1);\n\t\tMEMSET(par, -1);\n\t\tcin.ignore();\n\t\trep(i, n){\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\t\t\tint cnt = count(ALL(s), ' ');\n\t\t\tlast[cnt] = i;\n\t\t\tname[s.substr(cnt)] = i;\n\t\t\tif (!cnt) continue;\n\t\t\tpar[i] = last[cnt - 1];\n\t\t}\n\t\twhile (q--){\n\t\t\tstring a, b, c, d, e, f;\n\t\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\t\t//cout << f.substr(0, f.size() - 1) << endl;\n\t\t\tint x = name[a], y = name[f.substr(0, f.size() - 1)];\n\t\t\tbool ok;\n\t\t\tswitch (d[0]){\n\t\t\tcase 'c':\n\t\t\t\tok = par[x] == y;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tok = check_ancestor(x, y);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tok = par[x] == par[y];\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tok = x == par[y];\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tok = check_ancestor(y, x);\n\t\t\t}\n\t\t\tcout << (ok ? \"True\" : \"False\") << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 1010\n\nstruct P{\n  int p,l;\n};\n\nP p[MAX_N];\nstring s[MAX_N];\nbool used[MAX_N];\nint N;\n\nvoid init(int N){\n  for(int i = 0 ; i < N ; i++){\n    p[i].p = i;\n  }\n}\n\nbool find(int x,int target){\n  if(p[x].p == target){\n    return true;\n  }\n  if(p[x].p == x){ return false; }\n  return find(p[x].p,target);\n}\n\nvoid make(int n,int parent,int root,int depth){\n  set<int> children;\n  if(used[n]){ return; }\n  used[n] = true;\n  p[n].p = parent; p[n].l = depth;\n  for(int i = n+1 ; i < N ; i++){\n    int len = s[i].size();\n    if(depth+1 >= len){ continue; }\n    if(s[i][depth] != '.'){ break; }\n    if(s[i][depth] == '.' && s[i][depth+1] != '.'){\n      children.insert(i);\n      make(i,n,root,depth+1);\n    }\n  }\n}\n\nint main(){\n  int M;\n  while(cin >> N >> M, N){\n    map<string,int> mp;\n    int cur = 0;\n    init(N); cin.ignore();\n    for(int i = 0 ; i < N ; i++){\n      getline(cin,s[i]);\n      for(int j = 0 ; j < (int)s[i].size() ; j++){\n        if(s[i][j] != ' '){\n          mp[s[i].substr(j)] = cur++;\n          break;\n        }\n        s[i][j] = '.';\n      }\n      used[i] = false;\n    }\n    for(int i = 0 ; i < N ; i++){\n      if(used[i]){ continue; }\n      if(s[i][0] != '.'){\n        make(i,i,i,0);\n      }\n    }\n    string ord,a,b,c;\n    for(int i = 0 ; i < M ; i++){\n      getline(cin,ord);\n      stringstream ss(ord);\n      ss >> a;\n      ss >> ord; ss >> ord;\n      ss >> c;\n      ss >> ord;\n      ss >> b;\n      b.resize(b.size()-1);\n      bool ans = false;\n      if(c == \"parent\"){\n        if(p[mp[b]].p == mp[a]){\n          ans = true;\n        }\n      }else if(c == \"child\"){\n        if(p[mp[a]].p == mp[b]){\n          ans = true;\n        }\n      }else if(c == \"ancestor\"){\n        if(p[mp[a]].l < p[mp[b]].l && find(mp[b],mp[a])){\n          ans = true;\n        }\n      }else if(c == \"descendant\"){\n        if(p[mp[a]].l > p[mp[b]].l && find(mp[a],mp[b])){\n          ans = true;\n        }\n      }else{\n        if(p[mp[a]].l == p[mp[b]].l && p[mp[a]].p == p[mp[b]].p){\n          ans = true;\n        }\n      }\n      cout << (ans ? \"True\" : \"False\") << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,m;\n  int nn = 0;\n  while(cin>>n>>m,n||m) {\n    if (nn) cout << endl;\n    else nn = 1;\n    cin.ignore();\n    int table[n];\n    map<string, int> mp;\n    int parent[n];\n    vector<int> children[n];\n    REP(i,n) {\n      string name;\n      getline(cin, name);\n\n      if (i==0) {\n        mp[name] = 0;\n        table[0] = 0;\n        parent[0] = -1;\n        continue;\n      }\n      \n      int space = 0;\n      while(name[space]==' ') space++;\n      name = name.substr(space);\n      \n      children[table[space-1]].push_back(i);\n      parent[i] = table[space-1];\n      table[space] = i;\n      mp[name] = i;\n    }\n    // FOR(it, mp)\n    //   cout << it->first<< \" \" <<it->second<<endl;\n\n    REP(i,m) {\n      string line;\n      getline(cin,line);\n      line[line.size()-1] = ' ';\n      stringstream ss(line);\n      string xx, s, tmp, yy;\n      ss >>xx>>tmp>>tmp>>s>>tmp>>yy;\n      int x = mp[xx], y = mp[yy];\n      bool f = 0;\n      if (s==\"child\") {\n        if (parent[x] == y)\n          f = 1;\n      } else if (s==\"parent\") {\n        if (parent[y] == x)\n          f= 1;\n      } else if (s==\"sibling\") {\n        if (binary_search(ALL(children[parent[x]]), y))\n          f = 1;\n      } else if (s==\"descendant\") {\n        while(parent[x]!=-1) {\n          x = parent[x];\n          if (x==y) {\n            f = 1;\n            break;\n          }\n        }\n      } else {\n        while(parent[y]!=-1) {\n          y = parent[y];\n          if (x==y) {\n            f = 1;\n            break;\n          }\n        }\n      }\n      if (f)\n        cout << \"True\" << endl;\n      else\n        cout << \"False\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k,l;\n  int n,m;\n  while(cin>>n>>m&&n+m){\n    string t;\n    getline(cin,t);\n    int a[1000];\n    memset(a,0,sizeof(a));\n    string s[1000];\n    for(i=0;i<n;i++){\n      string t;\n      getline(cin,t);\n      for(;t[0]==' ';a[i]++)\n\tt.erase(0,1);\n      s[i]=t;\n    }\n    for(i=0;i<m;i++){\n      string t,u,v;\n      cin>>t>>u>>u>>u>>v>>v;\n      v.erase(v.length()-1,1);\n      if(0){\n      }else if(u[0]=='c'){\n\tfor(j=0;s[j]!=t;j++);\n\tif(j==0)\n\t  cout<<\"False\"<<endl;\n\telse{\n\t  for(k=j;a[k]!=a[j]-1;k--);\n\t  if(s[k]==v)\n\t    cout<<\"True\"<<endl;\n\t  else\n\t    cout<<\"False\"<<endl;\n\t}\n      }else if(u[0]=='p'){\n\tfor(j=0;s[j]!=v;j++);\n\tif(j==0)\n\t  cout<<\"False\"<<endl;\n\telse{\n\t  for(k=j;a[k]!=a[j]-1;k--);\n\t  if(s[k]==t)\n\t    cout<<\"True\"<<endl;\n\t  else\n\t    cout<<\"False\"<<endl;\n\t}\t\n      }else if(u[0]=='s'){\n\tfor(j=0;s[j]!=t&&s[j]!=v;j++);\n\tfor(k=j+1;s[k]!=t&&s[k]!=v;k++);\n\tif(a[j]!=a[k])\n\t  cout<<\"False\"<<endl;\n\telse{\n\t  for(j++;j<k;j++){\n\t    if(a[j]<a[k])\n\t      break;\n\t  }\n\t  if(j==k)\n\t    cout<<\"True\"<<endl;\n\t  else\n\t    cout<<\"False\"<<endl;\n\t}\n      }else if(u[0]=='d'){\n\tfor(j=0;s[j]!=t;j++);\n\tl=a[j];\n\tfor(k=j-1;k>-1;k--){\n\t  if(a[k]<l){\n\t    if(s[k]==v)\n\t      break;\n\t    l=a[k];\n\t  }\n\t}\n\tif(k==-1)\n\t  cout<<\"False\"<<endl;\n\telse\n\t  cout<<\"True\"<<endl;\n      }else if(u[0]=='a'){\n\tfor(j=0;s[j]!=v;j++);\n\tl=a[j];\n\tfor(k=j-1;k>-1;k--){\n\t  if(a[k]<l){\n\t    if(s[k]==t)\n\t      break;\n\t    l=a[k];\n\t  }\n\t}\n\tif(k==-1)\n\t  cout<<\"False\"<<endl;\n\telse\n\t  cout<<\"True\"<<endl;\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint m,n;\n\nstruct nodeInfo{\n    int depth;\n};\n\nmap<string,int> id;\nvector<int> G[1010];\nnodeInfo nif[1010];\n\nint backNode(int cnode,int cnt){\n    for(int i = 0; i < cnt; i++){\n        for(int j = 0; j < G[cnode].size(); j++){\n            // ツ親ツノツーツドツづ個づ卍つ、ツつェツ深ツつウツつェツ静ウツつ「\n            if(nif[G[cnode][j]].depth<nif[cnode].depth){\n                cnode=G[cnode][j];\n                break;\n            }\n        }\n    }\n    return cnode;\n}\nbool isChild(int n1idx,int n2idx){\n    return n2idx==backNode(n1idx,1);\n}\nbool isAncestor(int n1idx,int n2idx){\n    int cnode=n2idx;\n    while(1){\n        if(cnode==n1idx)\n            return true;\n        // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n        if(cnode==0)\n            return false;\n        else\n            cnode=backNode(cnode,1);\n    }\n}\n\nint main(){\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        id.clear();\n        string str;\n        getline(cin,str);\n        for(int i = 0; i < 1010; i++)G[i].clear();\n        int depth=-1;\n        int cp=-1;\n        for(int i = 0; i < n; i++){\n            getline(cin,str);\n            int cnt=0;\n            for(int j = 0; ;j++){\n                if(str[j]==' ')\n                    continue;\n                else{\n                    str=str.substr(j);\n                    cnt=j;\n                    break;\n                }\n            }\n            id[str]=i;\n            // cntツづ個青板つセツつッツ親ツづ可姪淞づィツ、ツつサツつアツづ可ノツーツドツづーツ挿ツ禿シツつキツづゥ\n            if(cp!=-1){\n                if(depth<cnt){\n                    G[cp].push_back(i);\n                    G[i].push_back(cp);\n                }\n                else{\n                    int back=backNode(cp,depth-cnt+1);\n                    G[back].push_back(i);\n                    G[i].push_back(back);\n                }\n            }\n            cp=i;\n            depth=cnt;\n            nif[i].depth=depth;\n        }\n        for(int j = 0; j < m; j++){\n            string name1,name2,tmp,order;\n            cin>>name1>>tmp>>tmp>>order>>tmp>>name2;\n            name2=name2.substr(0,name2.size()-1);\n            int n1idx=id[name1];\n            int n2idx=id[name2];\n            bool match=false;\n            if(order==\"child\")\n                match=isChild(n1idx,n2idx);\n            else if(order==\"ancestor\")\n                match=isAncestor(n1idx,n2idx);\n            else if(order==\"sibling\"){\n                int cnode=backNode(n1idx,1);\n                for(int i = 0; i < G[cnode].size(); i++){\n                    int to=G[cnode][i];\n                    match=(nif[n1idx].depth==nif[to].depth&&to==n2idx);\n                    if(match)\n                        break;\n                }\n            }\n            else if(order==\"parent\")\n                match=isChild(n2idx,n1idx);\n            else\n                match=isAncestor(n2idx,n1idx);\n            if(match)\n                cout<<\"True\"<<endl;\n            else\n                cout<<\"False\"<<endl;\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        map<string, vector<int> > name;\n        int prev = -1;\n        vector<int> tmp;\n        cin.ignore();\n        for(int i=0; i<n; ++i){\n            string s;\n            getline(cin, s);\n            int j = s.find_first_not_of(' ');\n            s = s.substr(j);\n            if(j < prev){\n                while(j < prev){\n                    tmp.pop_back();\n                    -- prev;\n                }\n                ++ tmp.back();\n            }else if(j == prev){\n                ++ tmp.back();\n            }else{\n                tmp.push_back(0);\n                ++ prev;\n            }\n            name.insert(make_pair(s, tmp));\n        }\n\n        for(int i=0; i<m; ++i){\n            string x0, y0, s;\n            cin >> x0 >> s >> s >> s >> y0 >> y0;\n            y0.pop_back();\n\n            vector<int> x = name[x0];\n            vector<int> y = name[y0];\n\n            if(s == \"child\" || s == \"parent\"){\n                if(s == \"parent\")\n                    swap(x, y);\n                x.resize(x.size() - 1);\n            }else if(s == \"sibling\"){\n                x.resize(x.size() - 1);\n                y.resize(y.size() - 1);\n            }else{\n                if(s == \"ancestor\")\n                    swap(x, y);\n                if(x.size() > y.size())\n                    x.resize(y.size());\n            }\n\n            if(x == y)\n                cout << \"True\" << endl;\n            else\n                cout << \"False\" << endl;\n        }\n\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int uli;\n\nconst int mxl=100;\nconst int mx=1e3+10;\nmap<string,int>mp;\nchar s[mxl];\nint lyr[mx],p[mx];\nchar sx[mxl],sy[mxl],rel[mxl],op[mxl];\nint main(){\n//   freopen(\"data.in\",\"r\",stdin);\n   int n,m;\n   lyr[0]=0;\n   while(scanf(\"%d %d\",&n,&m)){\n      if(n==0 && m==0)break;\n      mp.clear();\n      int u=0;\n      lyr[u]=p[u]=0;\n      gets(s);\n      gets(s);\n      mp[string(s)]=0;\n      for(int i=1;i<n;i++){\n         gets(s);\n         int l=strlen(s);\n         int dep=0;\n         while(dep<l && s[dep]==' ')dep++;\n         string x(s+dep);\n         mp[x]=i;         \n         while(lyr[u]!=dep-1)u=p[u];\n         p[i]=u;\n         lyr[i]=lyr[u]+1;\n         u=i;\n      }\n      for(int i=0;i<m;i++){\n         scanf(\"%s is %s %s of %s\",sx,op,rel,sy);\n         string y=string(sy);\n         y=y.substr(0,int(y.size())-1);\n         int ix=mp[string(sx)];\n         int iy=mp[y];\n         bool ans=false;\n         if(rel[0]=='c'){\n            if(p[ix]==iy)ans=1;\n         }\n         else if(rel[0]=='p'){\n            if(p[iy]==ix)ans=1;\n         }\n         else if(rel[0]=='s'){\n            if(p[ix]==p[iy])ans=1;\n         }\n         else if(rel[0]=='d' || rel[0]=='a'){            \n            if(rel[0]=='a')swap(ix,iy);\n            for(;ix!=p[ix] && !ans;ix=p[ix]){\n               if(p[ix]==iy)\n                  ans=true;\n            }\n         }\n         if(ans)puts(\"True\");\n         else puts(\"False\");\n      }\n      puts(\"\");\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n};\n\n/** Problem1217 : Family Tree **/\n\nstruct S {\n\tstring name;\n\tint parent;\n\tvector<int> child;\n\tS(string s, int p, vector<int> c) : name(s), parent(p), child(c){}\n};\n\nvector<S> G;\n\nint main()\n{\n\tint N, M;\n\twhile (cin>>N>>M, N||M) {\n\t\tcin.ignore();\n\t\tG.clear();\n\t\t\n\t\tmap<string, int> list;\n\t\t\n\t\tint idx=0;\n\t\t\n\t\tvector<string> s(N);\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tgetline(cin, s[i]);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tint count = 0;\n\t\t\tint p=0;\n\t\t\t\n\t\t\twhile (s[i][p]==' ') {\n\t\t\t\tcount++;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\t\n\t\t\tstring n = s[i].substr(p);\n\t\t\tif (count==0) {\n\t\t\t\tG.push_back(S(n, -1, vector<int>()));\n\t\t\t\tlist[n] = idx++;\n\t\t\t} else {\n\t\t\t\tstring parent;\n\t\t\t\tfor (int j=i; j>=0; j--) {\n\t\t\t\t\tint cc=0;\n\t\t\t\t\twhile (s[j][cc]==' ') cc++;\n\t\t\t\t\tif (cc==count-1) {\n\t\t\t\t\t\tparent = s[j].substr(cc);\n\t\t\t\t\t\n\t\t\t\t\t\tG.push_back(S(n, list[parent], vector<int>()));\n\t\t\t\t\t\tlist[n] = idx++;\n\t\t\t\t\t\tG[list[parent]].child.push_back(list[n]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int z=0; z<M; z++) {\n\t\t\tstring t; getline(cin, t);\n\t\t\tt.erase(t.end()-1);\n\t\t\t\n\t\t\tistringstream ss(t);\n\t\t\tvector<string> tt(6);\n\t\t\tfor (int i=0; i<6; i++)\n\t\t\t\tss>>tt[i];\n\t\t\t\n\t\t\tstring X = tt[0], Y = tt[5];\n\t\t\t\n\t\t\tbool ans=false;\n\t\t\t\n\t\t\tif (tt[3][0]=='c') {\n\t\t\t\tswap(X, Y);\n\t\t\t\t\n\t\t\t\tif (list[X] == G[list[Y]].parent) {\n\t\t\t\t\tans = true;\n\t\t\t\t}\n\t\t\t} else if (tt[3][0]=='p') {\n\t\t\t\tif (list[X] == G[list[Y]].parent) {\n\t\t\t\t\tans = true;\n\t\t\t\t}\n\t\t\t} else if (tt[3][0]=='s') {\n\t\t\t\tif (G[list[X]].parent == G[list[Y]].parent && G[list[X]].parent!=-1)\n\t\t\t\t\tans = true;\n\t\t\t} else if (tt[3][0]=='d') {\n\t\t\t\tswap(X, Y);\n\t\t\t\t\n\t\t\t\tS now = G[list[Y]];\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (now.parent==-1) break;\n\t\t\t\t\tif (now.parent == list[X])\n\t\t\t\t\t\tans = true;\n\t\t\t\t\tnow = G[now.parent];\n\t\t\t\t}\n\t\t\t} else if (tt[3][0]=='a') {\n\t\t\t\tS now = G[list[Y]];\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (now.parent==-1) break;\n\t\t\t\t\tif (now.parent == list[X])\n\t\t\t\t\t\tans = true;\n\t\t\t\t\tnow = G[now.parent];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << (ans?\"True\":\"False\") << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nstruct node{\n  string name;\n  vector<node *> childlen;\n  \n  node(string name):name(name){}\n};\n\nvoid add_child(node * p, string new_name, const vector<string> &path, int depth){\n  if( depth == (int)path.size() ){\n    p->childlen.push_back( new node(new_name) );\n    return ;\n  }\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( path[depth] == p->childlen[i]->name ){\n      add_child( p->childlen[i], new_name, path, depth+1 );\n    }\n  }\n  return ;\n}\n\nvoid print(node *p){\n  cout << p->name << endl;\n  cout << \"Childlen :\" << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    cout << p->childlen[i]->name << endl;\n  }\n  cout << \"-----\" << endl << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    print( p->childlen[i] );\n  }\n}\n\nbool isChild;\nbool judge(node * p, const string &a, const string &b, const string &rel, bool Xfnd){\n  if(p->name == b){\n    return Xfnd;\n  }\n\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    for(int j = i+1; j < (int)p->childlen.size(); ++j){\n      if( rel==\"sibling\" ){\n        if( (p->childlen[i]->name == a && p->childlen[j]->name == b) ||\n            (p->childlen[i]->name == b && p->childlen[j]->name == a) ){\n          return true;\n        }\n      }\n    }\n  }\n  \n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( rel == \"child\" ){\n      if( p->name==a && p->childlen[i]->name == b && rel == \"child\" ){\n        isChild = true;\n        return true;\n      }\n    }\n    if( judge(p->childlen[i], a, b, rel, p->name==a|Xfnd) ){\n      return true;\n    }\n  }\n  return false;\n}\n\nint main()\n{\n  while(true){\n    int n,m;\n    string dam;\n    cin >> n >> m;\n    if( n == 0  && m == 0 ) break;\n\n    getline(cin,dam);\n    node * root = new node(\"___ROOT\");\n\n    int spaces = -1;\n    vector<string> path;\n    for(int i = 0; i < n; ++i){\n      string s;\n      getline(cin,s);\n      \n      int csp = 0;\n      for(int j = 0; j < (int)s.length(); ++j){\n        if( s[j] == ' ' ) ++csp;\n        else break;\n      }\n      s = s.substr( csp );\n\n      if( csp < spaces ){\n        path.pop_back();\n        for(int j = 0; j < spaces - csp; ++j){\n          path.pop_back();\n        }\n        add_child(root, s, path, 0);\n        path.push_back(s);\n\n      }else if( csp == spaces ){\n        path.pop_back();\n        add_child(root, s, path, 0);\n        path.push_back(s);\n        \n      }else if( csp == spaces + 1 ){\n        add_child(root, s, path, 0);\n        path.push_back( s );\n      }\n\n      spaces = csp;\n    }\n    // print(root);\n    \n    for(int i = 0; i < m; ++i){\n      string X,Y,rel;\n      cin >> X >> dam >> dam >> rel >> dam >> Y;\n      Y = Y.substr(0, Y.length()-1);\n      if( rel == \"parent\" ){\n        rel = \"child\";\n        swap(X,Y);\n      }\n      if( rel == \"ancestor\" ){\n        rel = \"descendant\";\n        swap(X,Y);\n      }\n      \n      isChild = false;\n      if( judge(root,Y,X,rel,false) ){\n        if( rel == \"child\" ){\n          if( isChild ){\n            cout << \"True\" << endl;\n          }else{\n            cout << \"False\" << endl;\n          }\n        }else{\n          cout <<\"True\"<<endl;\n        }\n      }else{\n        cout <<\"False\"<<endl;\n      }\n      \n    }\n    cout << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n \nint oldest,youngest;\n \nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n \n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n  oldest = min(oldest,space_cnt);\n  youngest = max(youngest,space_cnt);\n}\n \nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n  \n \n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n    goto skip;\n       \n      ope.push_back(mid);\n       \n    }\n \n skip:\n \n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i] == \"child\" || ope[i] == \"parent\" || ope[i] == \"sibling\" || ope[i] == \"descendant\" || ope[i] == \"ancestor\")\n    {\n      info.push_back(ope[i]);\n      break;\n    }\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n \n \n  assert(info.size() == 3);\n \n  string X,Y;\n  X = info[0],Y = info[2];\n \n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n \n      if(vec[Xindex].S <= vec[Yindex].S || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n    \n      int parent_level = vec[Yindex].S;\n \n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n    {\n \n      if(vec[i].F == X)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n \n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n \n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n \n      if(vec[Xindex].S >= vec[Yindex].S || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n \n      int parent_level = vec[Xindex].S;\n \n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n    {\n      if(vec[i].F == Y)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n \n      cout << \"False\" << endl;\n      return;\n \n \n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n \n      if(vec[Xindex].S != vec[Yindex].S || min(Xindex,Yindex)+1 >= vec.size())\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n      int sibling_level = vec[Xindex].S;\n \n      int Maxindex,Minindex;\n      string Maxname,Minname;\n \n      if(Xindex > Yindex)\n    {\n      Maxindex = Xindex,Minindex = Yindex;\n      Maxname = X,Minname = Y;\n    }\n      else\n    {\n      Maxindex = Yindex,Minindex = Xindex;\n      Maxname = Y,Minname = X;\n    }\n \n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n    {\n      if(Maxname == vec[i].F)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n      cout << \"False\" << endl;\n      return;\n \n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n \n      if(Yindex+1 >= vec.size() || vec[Xindex].S <= vec[Yindex].S)\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n      for(int i=Yindex+1;i<vec.size() && vec[i].S > vec[Yindex].S;i++)\n    {\n      if(vec[i].F == vec[Xindex].F)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n \n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(Xindex+1 >= vec.size()  || vec[Xindex].S >= vec[Yindex].S)\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n      for(int i=Xindex+1;i < vec.size() && vec[i].S > vec[Xindex].S;i++)\n    {\n      if(vec[i].F == vec[Yindex].F)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n \n      cout << \"False\" << endl;\n      return;\n    }\n  else\n    assert(false);\n   \n \n}\n \nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n    \n      if(!(n+m))\n    break;\n      oldest = (1<<28);\n      youngest = -1;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n    {\n      getline(cin,line);\n     \n      split(vec,line);\n    }\n \n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n    index_tree[vec[i].F] = i;\n \n      for(int i=0;i<m;i++)\n    {\n      getline(cin,line);\n      \n      ParseAndSolve(vec,index_tree,line.substr(0,line.size()-1));\n      \n    }\n \n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nint par[1001];\nint curr[1001];\n\nvoid init(){\n\tfor(int i=0;i<=1000;i++){\n\t\tpar[i] = i;\n\t\tcurr[i] = -1;\n\t}\n}\n\nbool isSat(string question,map<int,string>& name,map<string,int>& num){\n\tstring str;\n\tstringstream ss(question);\n\tvector<string> v;\n\twhile(ss >> str){\n\t\tv.push_back(str);\n\t}\n\n\tstring X = v[0];\n\tstring Y = v[5].substr(0,v[5].size()-1);\n\n\t//X is a child of Y.\n\t//X is the parent of Y.\n\t//X is a sibling of Y.\n\t//X is a descendant of Y.\n\t//X is an ancestor of Y.\n\n\tif(v[3] == \"child\"){\n\t\treturn (par[num[X]] == num[Y] && num[Y] != -1);\n\t}\n\telse if(v[3] == \"parent\"){\n\t\treturn (par[num[Y]] == num[X] && num[X] != -1);\n\t}\n\telse if(v[3] == \"sibling\"){\n\t\treturn (par[num[Y]] == par[num[X]] && par[num[X]] != -1);\n\t}\n\telse if(v[3] == \"ancestor\"){\n\t\twhile(par[num[Y]] != -1){\n\t\t\tY = name[par[num[Y]]];\n\t\t\tif(X == Y) return true;\n\t\t}\n\t\treturn false;\n\t}\n\telse if(v[3] == \"descendant\"){\n\t\twhile(par[num[X]] != -1){\n\t\t\tX = name[par[num[X]]];\n\t\t\tif(X == Y) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tstring str;\n\n\twhile(getline(cin,str)){\n\t\tinit();\n\t\tstringstream ss(str);\n\t\tss >> str;\n\t\tint n = atoi(str.c_str());\n\t\tss >> str;\n\t\tint m = atoi(str.c_str());\n\n\n\t\tif(n==0 && m==0) break;\n\n\t\tmap<int,string> name;\n\t\tmap<string,int> num;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\n\t\t\t\n\t\t\tint j=0;\n\t\t\twhile(str[j] == ' ') j++;\n\t\t\tname[i] = str.substr(j,str.size()-j);\n\t\t\tnum[str.substr(j,str.size()-j)] = i;\n\n\t\t\tif(j==0){\n\t\t\t\tpar[i] = -1;\n\t\t\t}\n\t\t\telse par[i] = curr[j-1];\n\t\t\t//cout << str << endl;\n\n\t\t\tcurr[j] = i;\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tgetline(cin,str);\n\t\t\tif(isSat(str,name,num)){\n\t\t\t\tprintf(\"True\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"False\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tX is a child of Y.@XÌeð²×Ä­B\n\tX is the parent of Y.@YÌeð²×Ä­\n\tX is a sibling of Y. XÆYÌ[³ª¯¶©mF·é\n\tX is a descendant of Y. XÌeðÄAIÉ\n\tX is an ancestor of Y.@YÌeðÄAIÉ\n*/\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <sstream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nmap<string,string> data;\nmap<string,int> dp;\n\nvector< pair<string,int> > rec;\n\nint n,m,I;\n\nvoid input(string parent,int depth){\n\twhile( I < n ){\n\t\n\t\tstring nstr = rec[I].first;\n\t\tint ndp = rec[I].second;\n\t\tdata[nstr] = parent;\n\t\tdp[nstr] = depth;\n\t\tI++;\n\t\tif(depth < ndp){\n\t\t\tinput(nstr,ndp);\n\t\t}else if(depth > ndp){\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool func(string a,string b){\n\tif(a==\"\")return false;\n\t\n\tif(a == b){\n\t\treturn true;\n\t}else{\n\t\treturn func(data[a],b);\n\t}\n}\nint main(){\n\tstring s;int C = 0;\n\twhile(scanf(\"%d %d\\n\",&n,&m) , n){\n\t\tif(C++)cout << endl;\n\t\tint prevCount=0,tmpCount;\n\t\tvector< pair<string,int> > in(n,make_pair(\"\",-1));\n\t\tdata.clear();dp.clear();\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,s);\n\t\t\tif(i){\n\t\t\t\tin[i-1].second = count(s.begin(),s.end(),' ');\n\t\t\t}\n\t\t\ts.erase(remove(s.begin(),s.end(),' '),s.end());\n\t\t\tin[i].first = s;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tcout << in[i].first << \" \" << in[i].second << endl;\n\t\t}*/\n\t\n\t\trec=in;I=0;\n\t\tinput(\"\",0);\n\t\t\n\t\tbool flag;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tvector<string> tmp;\n\t\t\tgetline(cin,s);\n\t\t\ts = s.substr(0,s.length()-1);\n\t\t\tstringstream ss(s);\t\n\t\t\twhile(ss >> s)tmp.push_back(s);\n\t\t\t//cout << tmp[0] << \" \" << tmp[5] << endl;\n\t\t\tstring X = tmp[0], Y = tmp[5] , type = tmp[3];\n\t\t\n\t\t\n\t\t\tif(type == \"child\")flag = (data[X] == Y);\n\t\t\tif(type == \"parent\")flag = (data[Y] == X);\n\t\t\tif(type == \"sibling\")flag = (dp[X] == dp[Y]);\n\t\t\tif(type == \"descendant\")flag = func(X,Y);\n\t\t\tif(type == \"ancestor\")flag = func(Y,X);\n\t\t\n\t\t\tcout << (flag?\"True\":\"False\") << endl;\n\t\t}\n\t\t/*for( map<string,string>::iterator it = data.begin(); it != data.end() ; ++it ){\n\t\t\tcout << (*it).first << \" ÌeÍ \" << (*it).second << endl;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef vector<string>VS;\nstruct S{string p;VS v;};\nmap<string,S>m;\nint A(string a,string n)\n{\n\tif(m[n].p.empty())return 0;\n\tif(m[n].p==a)return 1;\n\treturn A(a,m[n].p);\n}\nint main()\n{\n\tint N,M,i,c,f;\n\tstring s,t,x,y;\n\twhile(cin>>N>>M,N)\n\t{\n\t\tVS v;\n\t\tm.clear();\n\t\tgetline(cin,s);\n\t\tgetline(cin,s);\n\t\tm[s].p=\"\";\n\t\tv.push_back(s);\n\t\tfor(i=1;i<N;++i)\n\t\t{\n\t\t\tgetline(cin,s);\n\t\t\tc=count(s.begin(),s.end(),' ');\n\t\t\ts=s.substr(c);\n\t\t\twhile(v.size()>c)v.pop_back();\n\t\t\tm[s].p=v.back();\n\t\t\tm[v.back()].v.push_back(s);\n\t\t\tv.push_back(s);\n\t\t}\n\t\tfor(i=0;i<M;++i)\n\t\t{\n\t\t\tgetline(cin,s);\n\t\t\tv.clear();\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tc=s.find(' ');\n\t\t\t\tif(c==string::npos)break;\n\t\t\t\tv.push_back(s.substr(0,c));\n\t\t\t\ts=s.substr(c+1);\n\t\t\t}\n\t\t\tx=v[0];\n\t\t\ty=s;\n\t\t\ty.erase(y.size()-1);\n\t\t\tt=v[3];\n\t\t\tif(t==\"child\")f=(m[x].p==y);\n\t\t\tif(t==\"parent\")f=(m[y].p==x);\n\t\t\tif(t==\"sibling\")\n\t\t\t{\n\t\t\t\tv=m[m[x].p].v;\n\t\t\t\tf=(find(v.begin(),v.end(),y)!=v.end());\n\t\t\t}\n\t\t\tif(t==\"descendant\")f=A(y,x);\n\t\t\tif(t==\"ancestor\")f=A(x,y);\n\t\t\tcout<<(f?\"True\\n\":\"False\\n\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint n,m;\nvector<string> nm;\nint p[1000]; map<string,int> id;\n\nbool ck(int a,int b)\n{\n\tfor(;a>=0;a=p[a])if(a==b)return 1;\n\treturn 0;\n}\nint main()\n{\n\twhile(cin>>n>>m,n)\n\t{\n\t\tnm.clear(); id.clear();\n\t\tcin.ignore(); string str;\n\t\t\n\t\tint sp=0,psp=0,pa=-1;\n\t\trep(i,n)\n\t\t{\n\t\t\tgetline(cin,str);\n\t\t\tfor(sp=0;str[sp]==' ';sp++);\n\t\t\tnm.pb(str.substr(sp));\n\t\t\tid[nm[i]]=i;\n\t\t\t\n\t\t\tif(psp>sp)\n\t\t\t{\n\t\t\t\trep(j,psp-sp)pa=p[pa];\n\t\t\t\tp[i]=pa;\n\t\t\t}\n\t\t\telse if(psp==sp)p[i]=pa;\n\t\t\telse if(psp<sp)p[i]=i-1,pa=i,sp++;\n\t\t\tpsp=sp;\n\t\t}\n\t\t\n\t\trep(i,m)\n\t\t{\n\t\t\tgetline(cin,str);\n\t\t\tstringstream ss(str);\n\t\t\tstring n1,n2,t; ss>>n1>>str>>str>>t>>str>>n2;\n\t\t\tn2.erase(n2.end()-1);\n\t\t\t\n\t\t\tint a=id[n1],b=id[n2];\n\t\t\tbool ans=0;\n\t\t\tif(t==\"child\")ans=p[a]==b;\n\t\t\telse if(t==\"parent\")ans=p[b]==a;\n\t\t\telse if(t==\"sibling\")ans=p[a]==p[b];\n\t\t\telse if(t==\"ancestor\")ans=ck(b,a);\n\t\t\telse ans=ck(a,b);\n\t\t\t\n\t\t\tcout<<(ans?\"True\":\"False\")<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n  string name;\n  int parent;\n  vector<int> child;\n\n  node(string s=\"\"):name(s){ parent = -1; child.clear(); }\n\n  void set_par(int a){ parent = a; }\n  void add_child(int a){ child.push_back(a); }\n};\n\nvector<node> tree;\nmap<string,int> id;\n\ninline bool is_par(string my, string your){\n  int par = tree[id[my]].parent;\n  if(par<0)return false;\n  return tree[par].name == your;\n}\n\ninline bool is_child(string my, string your){\n  for(int c : tree[ id[my] ].child){\n    if(tree[c].name == your)return true;\n  }\n  return false;\n}\n\ninline bool is_sib(string my, string your){\n  int par = tree[id[my]].parent;\n  if(par<0)return false;\n  return is_child(tree[par].name, your);\n}\n\ninline bool is_anc(string my, string your){\n  if(my == your)return true;\n  int par = tree[id[my]].parent;\n  if(par<0)return false;\n  return is_anc(tree[par].name, your);\n}\n\ninline bool is_des(string my, string your){\n  if(my == your)return true;\n  for(int c : tree[ id[my] ].child){\n    if(is_des(tree[c].name,your))return true;\n  }\n  return false;  \n}\n\nint main(){\n  int n,m;\n  while(cin >> n >> m, n){\n    stack< pair<int,int> > s;\n    id.clear();\n    tree.resize(n);\n\n    cin.ignore();\n    for(int i=0;i<n;i++){\n      string name;\n      getline(cin,name);\n      //cout << name << endl;\n      int indent = 0;\n      while(name[indent]==' ')indent++;\n      name = name.substr(indent);\n      tree[i] = node(name);\n      id[name] = i;\n\n      while(s.size() && s.top().second+1 != indent)s.pop();\n      if(s.size()){\n\ttree[i].set_par( s.top().first );\n\ttree[s.top().first].add_child(i);\n      }\n      s.push( make_pair(i,indent) );\n    }\n\n    /*\n    for(int i=0;i<n;i++){\n      cout << tree[i].name << endl;\n      cout << tree[i].parent << endl;\n      for(int c : tree[i].child)cout << c << \" \"; cout << endl;\n    }\n    */\n\n    for(int i=0;i<m;i++){\n      string my,your,query,dummy;\n      cin >> your >> dummy >> dummy >> query >> dummy >> my;\n      my = my.substr(0,my.size()-1);\n\n      //cout << my << \" \" << your << \" \" << query << endl;\n\n      bool f = false;\n      if(query == \"child\")f = is_child(my,your);\n      else if(query == \"parent\")f = is_par(my,your);\n      else if(query == \"sibling\")f = is_sib(my,your);\n      else if(query == \"ancestor\")f = is_anc(my,your);\n      else f = is_des(my,your);\n\n      if(f)cout << \"True\" << endl;\n      else cout << \"False\" << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct person{\n\tvector<person> children;\n\tstring name;\n\tperson(string name):name(name){}\n\tint construct(vs &names,int indent,int index){\n\t\tFOR(i,index,names.size()){\n\t\t\tint next_indent=count(ALL(names[i]),' ');\n\t\t\tif(next_indent==indent+1){\n\t\t\t\tstring next_name=names[i];\n\t\t\t\tnext_name.erase(next_name.begin(),next_name.begin()+next_indent);\n\t\t\t\tchildren.push_back(person(next_name));\n\t\t\t}else if(next_indent>indent+1){\n\t\t\t\ti=children[children.size()-1].construct(names,indent+1,i)-1;\n\t\t\t}else{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn names.size();\n\t}\n\tbool is_child(string a,string b){\n\t\tif(name==b){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].name==a){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_child(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_descendant(string a,string b,bool flag=false){\n\t\tif(flag&&name==a){\n\t\t\treturn true;\n\t\t}\n\t\tif(name==b||flag){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].is_descendant(a,b,true)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_descendant(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_parent(string a,string b){\n\t\tif(name==a){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].name==b){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_parent(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_ancestor(string a,string b,bool flag=false){\n\t\tif(flag&&name==b){\n\t\t\treturn true;\n\t\t}\n\t\tif(name==a||flag){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].is_ancestor(a,b,true)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_ancestor(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_sibling(string a,string b){\n\t\tbool flag=false;\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].name==a||children[i].name==b){\n\t\t\t\tif(flag){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_sibling(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n&&m){\n\t\tstring name;\n\t\tgetline(cin,name);\n\t\tgetline(cin,name);\n\t\tperson root=person(name);\n\t\tvs names;\n\t\tREP(i,n-1){\n\t\t\tgetline(cin,name);\n\t\t\tnames.push_back(name);\n\t\t}\n\t\tint index=0;\n\t\troot.construct(names,0,index);\n\t\tREP(i,m){\n\t\t\tstring a,b,rel,trash;\n\t\t\tcin>>a>>trash>>trash>>rel>>trash>>b;\n\t\t\tbool ok;\n\t\t\tb.erase(b.end()-1,b.end());\n\t\t\tif(rel==\"child\"){\n\t\t\t\tok=root.is_child(a,b);\n\t\t\t}else if(rel==\"parent\"){\n\t\t\t\tok=root.is_parent(a,b);\n\t\t\t}else if(rel==\"ancestor\"){\n\t\t\t\tok=root.is_ancestor(a,b);\n\t\t\t}else if(rel==\"descendant\"){\n\t\t\t\tok=root.is_descendant(a,b);\n\t\t\t}else if(rel==\"sibling\"){\n\t\t\t\tok=root.is_sibling(a,b);\n\t\t\t}else{\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t\tcout<<(ok?\"True\":\"False\")<<endl;\n\t\t}\n\t\tcout<<endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nstruct node{\n  string name;\n  vector<node *> childlen;\n  \n  node(string name):name(name){}\n};\n\nvoid add_child(node * p, string new_name, const vector<string> &path, int depth){\n  if( depth == (int)path.size() ){\n    p->childlen.push_back( new node(new_name) );\n    return ;\n  }\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( path[depth] == p->childlen[i]->name ){\n      add_child( p->childlen[i], new_name, path, depth+1 );\n    }\n  }\n  return ;\n}\n\nvoid print(node *p){\n  cout << p->name << endl;\n  cout << \"Childlen :\" << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    cout << p->childlen[i]->name << endl;\n  }\n  cout << \"-----\" << endl << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    print( p->childlen[i] );\n  }\n}\n\nbool isChild;\nbool judge(node * p, const string &a, const string &b, const string &rel, bool Xfnd){\n  if(p->name == b){\n    return Xfnd;\n  }\n\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    for(int j = i+1; j < (int)p->childlen.size(); ++j){\n      if( rel==\"sibling\" ){\n        if( (p->childlen[i]->name == a && p->childlen[j]->name == b) ||\n            (p->childlen[i]->name == b && p->childlen[j]->name == a) ){\n          return true;\n        }\n      }\n    }\n  }\n  \n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( rel == \"child\" ){\n      if( p->name==a && p->childlen[i]->name == b && rel == \"child\" ){\n        isChild = true;\n        return true;\n      }\n    }\n    if( judge(p->childlen[i], a, b, rel, p->name==a|Xfnd) ){\n      return true;\n      //rel==\"descendant\";\n    }\n  }\n  return false;\n}\n\nint main()\n{\n  while(true){\n    int n,m;\n    string dam;\n    cin >> n >> m;\n    if( n == 0  && m == 0 ) break;\n\n    getline(cin,dam);\n    node * root = new node(\"___ROOT\");\n\n    int spaces = -1;\n    vector<string> path;\n    for(int i = 0; i < n; ++i){\n      string s;\n      getline(cin,s);\n      \n      int csp = 0;\n      for(int j = 0; j < (int)s.length(); ++j){\n        if( s[j] == ' ' ) ++csp;\n        else break;\n      }\n      s = s.substr( csp );\n\n      if( csp < spaces ){\n        path.pop_back();\n        for(int j = 0; j < spaces - csp; ++j){\n          path.pop_back();\n        }\n        add_child(root, s, path, 0);\n        path.push_back(s);\n\n      }else if( csp == spaces ){\n        path.pop_back();\n        add_child(root, s, path, 0);\n        path.push_back(s);\n        \n      }else if( csp == spaces + 1 ){\n        add_child(root, s, path, 0);\n        path.push_back( s );\n      }\n\n      spaces = csp;\n    }\n    // print(root);\n    \n    for(int i = 0; i < m; ++i){\n      string X,Y,rel;\n      cin >> X >> dam >> dam >> rel >> dam >> Y;\n      Y = Y.substr(0, Y.length()-1);\n      if( rel == \"parent\" ){\n        rel = \"child\";\n        swap(X,Y);\n      }\n      if( rel == \"ancestor\" ){\n        rel = \"descendant\";\n        swap(X,Y);\n      }\n      \n      isChild = false;\n      if( judge(root,Y,X,rel,false) || (rel==\"child\" && isChild)){\n        if( rel == \"child\" ){\n          if( isChild ){\n            cout << \"True\" << endl;\n          }else{\n            cout << \"False\" << endl;\n          }\n        }else{\n          cout <<\"True\"<<endl;\n        }\n      }else{\n        cout <<\"False\"<<endl;\n      }\n      \n    }\n    cout << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\ntypedef long long int ll;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\ntemplate<typename T>\nbool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false;}\ntemplate<typename T>\nbool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false;}\n// clang-format on\n\nint getDepth(string &name) {\n    int depth = 0;\n    while (name[depth] == ' ') {\n        depth++;\n    }\n    name = name.substr(depth);\n    return depth;\n}\n\n#include <map>\n\nvoid dfs(vector<vector<int>> &G, int v, vector<bool> &used) {\n    if (v == -1 || used[v]) return;\n    used[v] = true;\n    for (auto &vv : G[v]) {\n        dfs(G, vv, used);\n    }\n}\n\nvector<string> split(string s) {\n    s += \" \";\n    int prev = 0;\n    vector<string> res;\n    REP(i, 0, s.size()) {\n        if (s[i] == ' ') {\n            res.push_back(s.substr(prev, i - prev));\n            prev = i + 1;\n        }\n    }\n    return res;\n}\n\nstring P(bool f) {\n    return (f ? \"True\" : \"False\");\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    while (cin >> n >> m, n + m) {\n        vector<string> name(n);\n        vector<int> depth(n);\n        REP(i, 0, n) {\n            string in;\n            do {\n                getline(cin, in);\n            } while (in.size() == 0);\n            depth[i] = getDepth(in);\n            name[i] = in;\n        }\n        map<string, int> name2num;\n        REP(i, 0, n) {\n            name2num[name[i]] = i;\n        }\n        vector<vector<int>> Graph(n);\n        {\n            int prev = 0;\n            vector<int> stk;\n            Graph[0].push_back(-1);\n            REP(i, 1, n) {\n                if (depth[i - 1] < depth[i]) {\n                    REP (_, 0, depth[i] - depth[i - 1]) {\n                        stk.push_back(prev);\n                        prev = i - 1;\n                    }\n                } else if (depth[i - 1] > depth[i]) {\n                    REP (_, 0, depth[i -1] - depth[i]) {\n                        prev = stk.back();\n                        stk.pop_back();\n                    }\n                }\n                Graph[i].push_back(prev);\n            }\n        }\n        auto connected = make_v(n, n, false);\n        REP(i, 0, n) {\n            dfs(Graph, i, connected[i]);\n        }\n        REP(i, 0, m) {\n            string in;\n            do {\n                getline(cin, in);\n            } while (in.size() == 0);\n            auto parse = split(in);\n            string x = parse[0], y = parse.back();\n            y = y.substr(0, y.size() - 1);\n            string ob = parse[3];\n            int ix = name2num[x], iy = name2num[y];\n            if (ob == \"child\") {\n                cout << P(Graph[ix][0] == iy) << endl;\n            } else if (ob == \"parent\"){\n                cout << P(Graph[iy][0] == ix) << endl;\n            } else if (ob == \"sibling\") {\n                cout << P(Graph[ix][0] == Graph[iy][0]) << endl;\n            } else if (ob == \"descendant\") {\n                cout << P(connected[ix][iy]) << endl;\n            } else if (ob == \"ancestor\") {\n                cout << P(connected[iy][ix]) << endl;\n            } else {\n                dump(\"error\");\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//16\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nint cs(string s){\n  return count(s.begin(),s.end(),' ');\n}\n\nstring *fnd(string *a,string *b,string c){\n  for(;a!=b;a++){\n    if(a->substr(cs(*a))==c)break;\n  }\n  return a;\n}\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    cin.ignore();\n    string s[1000];\n    for(int i=0;i<n;i++){\n      getline(cin,s[i]);\n    }\n    for(int i=0;i<m;i++){\n      char a[99],b[99],c[99];\n      scanf(\"%s is %*s %s of %[^.].\",a,b,c);\n      int ax=fnd(s,s+n,string(a))-s;\n      int cx=fnd(s,s+n,string(c))-s;\n      bool r;\n      if(b[0]!='s'){\n\tif(b[0]=='p'||b[0]=='a'){\n\t  swap(ax,cx);\n\t}\n\tint i;\n\tint ps=cs(s[cx]);\n\tfor(i=cx+1;i<ax&&i<n;i++){\n\t  if(cs(s[i])<=ps)break;\n\t}\n\tr=cx<ax&&i==ax&&(((b[0]=='p'||b[0]=='c')&&cs(s[ax])==cs(s[cx])+1)||((b[0]=='a'||b[0]=='d')&&cs(s[ax])>cs(s[cx])));\n      }else{\n\tint l=min(ax,cx),h=max(ax,cx);\n\tint i;\n\tfor(i=l;i<h;i++){\n\t  if(cs(s[l])>cs(s[i]))break;\n\t}\n\tr=i==h&&cs(s[l])==cs(s[h]);\n      }\n      cout<<(r?\"True\":\"False\")<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\n#define Pint pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 1010;\n\nstring human[MAX_M][MAX_M];\nmap<string, Pint > human_map;\n\nbool tmpCheck(int y, int x){\n    if(y >= MAX_M) return false;\n    if(x >= MAX_M) return false;\n    if(y < 0) return false;\n    if(x < 0) return false;\n    return true;\n}\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ' && cnt < str.size()) cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nbool checkChild(string x, string y){\n    int now_y = human_map[y].first + 1, now_x = human_map[y].second + 1;\n    bool ret = false;\n    if(!tmpCheck(now_y, now_x)) return false;\n    while(human[now_y][now_x] != \"\"){\n        if(human[now_y][now_x] == x) ret = true;\n        now_y++;\n        if(!tmpCheck(now_y, now_x)) break;\n    }\n    return ret;\n}\n\nbool checkParent(string x, string y){\n    int now_y = human_map[y].first - 1, now_x = human_map[y].second - 1;\n    if(!tmpCheck(now_y, now_x)) return false;\n    while(human[now_y][now_x] == \"\"){\n        now_y++;\n        if(!tmpCheck(now_y, now_x)) break;\n    }\n    bool ret = (human[now_y][now_x] == x)? true : false;\n    return ret;\n}\n\nbool checkSibling(string x, string y){\n    int now_y = human_map[y].first, now_x = human_map[y].second;\n    int m = 1;\n    bool skip = false;\n    if(!tmpCheck(now_y + m, now_x)) skip = true;\n    bool ret = false;\n    while(human[now_y + m][now_x] != \"\" && !skip){\n        if(human[now_y + m][now_x] == x) ret = true;\n        m++;\n        if(!tmpCheck(now_y + m, now_x)) break;\n    }\n    now_y = human_map[y].first;\n    skip = false;\n    m = 1;\n    if(!tmpCheck(now_y - m, now_x)) skip = true;\n    while(human[now_y - m][now_x] != \"\" && !skip){\n        if(human[now_y - m][now_x] == x) ret = true;\n        m++;\n        if(!tmpCheck(now_y - m, now_x)) break;\n    }\n    return ret;\n}\n\nbool checkDescendant(string x, string y){\n    bool ret = false;\n    REP(i, human_map[x].first){\n        REP(j, human_map[x].second){\n            if(!tmpCheck(i, j)) break;\n            if(human[i][j] == y) ret = true;\n        }\n    }\n    return ret;\n}\n\nbool checkAncestor(string x, string y){\n    bool ret = false;\n    FOR(i, human_map[x].first + 1, MAX_M){\n        FOR(j, human_map[x].second + 1, MAX_M){\n            if(!tmpCheck(i, j)) break;\n            if(human[i][j] == y) ret = true;\n        }\n    }\n    return ret;\n}\n\nbool checkQ(string str){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    string y = vec[5].erase(vec[5].size() - 1);\n    if(vec[3] == \"child\") return checkChild(vec[0], y);\n    if(vec[3] == \"parent\") return checkParent(vec[0], y);\n    if(vec[3] == \"sibling\") return checkSibling(vec[0], y);\n    if(vec[3] == \"descendant\") return checkDescendant(vec[0], y);\n    if(vec[3] == \"ancestor\") return checkAncestor(vec[0], y);\n}\n\nint main(){\n    while(true){\n        int m, n;\n        string st;\n        getline(cin, st);\n        stringstream ss(st);\n        ss >>m >>n;\n        if(!n && !m) break;\n\n        REP(i, MAX_M) REP(j, MAX_M) human[i][j] = \"\";\n        human_map.clear();\n\n        REP(i, m){\n            string str;\n            getline(cin, str);\n            P tmp = cntSpace(str);\n            human[i][tmp.first] = tmp.second;\n            human_map[tmp.second] = Pint(i, tmp.first);\n        }\n\n        REP(i, n){\n            string str;\n            getline(cin, str);\n            if(checkQ(str) == true) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n        set <string> S;\n        for ( int i = 0; i < n; i++ ) {\n            int L = i+1;\n            while ( L < n ) {\n                if ( D[i] == D[L] ) break;\n                L++;\n            }\n            for ( int j = i+1; j < L; j++ ) {\n                if ( D[i] + 1 == D[j] ) {\n                    // i is j's child\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] - 1 == D[j] ) {\n                    // i is j's parent\n                    T[i][j] |= 1<<1;\n                    T[j][i] |= 1<<2;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    // sibling\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n                /*if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }*/\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    break;\n                } else if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else if ( D[i] > D[j] ) {\n                    T[i][j] |= 1<<5;\n                    T[j][i] |= 1<<4;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nint par[1001];\nint curr[1001];\n\nvoid init(){\n\tfor(int i=0;i<=1000;i++){\n\t\tpar[i] = i;\n\t\tcurr[i] = -1;\n\t}\n}\n\nbool isSat(string question,map<int,string>& name,map<string,int>& num){\n\tstring str;\n\tstringstream ss(question);\n\tvector<string> v;\n\twhile(ss >> str){\n\t\tv.push_back(str);\n\t}\n\n\tstring X = v[0];\n\tstring Y = v[5].substr(0,v[5].size()-1);\n\n\t//X is a child of Y.\n\t//X is the parent of Y.\n\t//X is a sibling of Y.\n\t//X is a descendant of Y.\n\t//X is an ancestor of Y.\n\n\tif(v[3] == \"child\"){\n\t\treturn (par[num[X]] == num[Y]);\n\t}\n\telse if(v[3] == \"parent\"){\n\t\treturn (par[num[Y]] == num[X]);\n\t}\n\telse if(v[3] == \"sibling\"){\n\t\treturn (par[num[Y]] == par[num[X]]);\n\t}\n\telse if(v[3] == \"ancestor\"){\n\t\twhile(par[num[Y]] != -1){\n\t\t\tif(X == Y) return true;\n\t\t\tY = name[par[num[Y]]];\t\t\n\t\t}\n\t\treturn false;\n\t}\n\telse if(v[3] == \"descendant\"){\n\t\twhile(par[num[X]] != -1){\n\t\t\tX = name[par[num[X]]];\n\t\t\tif(X == Y) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tstring str;\n\tbool isOut = false;\n\n\twhile(getline(cin,str)){\n\t\tinit();\n\t\tstringstream ss(str);\n\t\tss >> str;\n\t\tint n = atoi(str.c_str());\n\t\tss >> str;\n\t\tint m = atoi(str.c_str());\n\n\n\t\tif(n==0 && m==0) break;\n\n\t\tmap<int,string> name;\n\t\tmap<string,int> num;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\n\t\t\t\n\t\t\tint j=0;\n\t\t\twhile(str[j] == ' ') j++;\n\t\t\tname[i] = str.substr(j,str.size()-j);\n\t\t\tnum[str.substr(j,str.size()-j)] = i;\n\n\t\t\tif(j==0){\n\t\t\t\tpar[i] = -1;\n\t\t\t}\n\t\t\telse par[i] = curr[j-1];\n\t\t\t//cout << str << endl;\n\n\t\t\tcurr[j] = i;\n\t\t}\n\n\t\tif(isOut){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tgetline(cin,str);\n\t\t\tif(isSat(str,name,num)){\n\t\t\t\tprintf(\"True\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"False\\n\");\n\t\t\t}\n\t\t}\n\n\t\tisOut = true;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dep[100010];\nint par[100010][19];\nvector<int> g[100010];\nvoid dfs(int v,int u,int d){\n  dep[v]=d;\n  for(int i=0; i<g[v].size(); i++){\n    int w=g[v][i];if(w==u) continue;\n    par[w][0]=v;dfs(w,v,d+1);\n  }\n}\nint lcp(int a,int b){\n  if(dep[a]<dep[b]) swap(a,b);\n  for(int i=0; i<19; i++){\n    if((dep[a]-dep[b])&(1<<i)) a=par[a][i];\n  }\n  if(a==b) return a;\n  for(int i=18;i>=0;i--){\n    if(par[a][i]!=par[b][i]) a=par[a][i],b=par[b][i];\n  }\n  return par[a][0];\n}\nint n,m;\nvoid init() {\n  memset(par,0,sizeof(par));\n  dfs(0,-1,0);\n  for(int i=0; i<18; i++)for(int j=0; j<n; j++) par[j][i+1]=par[par[j][i]][i];\n}\n\nstring r[111111];\nint main() {\n  while(cin >> n >> m && n) {\n    for(int i=0; i<n; i++) g[i].clear();\n    string s;\n    getline(cin,s);\n    map<string,int> ma;\n    for(int i=0; i<n; i++) {\n      getline(cin,s);\n      stringstream ss;\n      string t;\n      ss << s;\n      ss >> t;\n      ma[t]=i;\n      int c=0;\n      for(int j=0; j<s.size(); j++) {\n        if(s[j]==' ') c++;\n        else break;\n      }\n      if(c) {\n        g[ma[t]].push_back(ma[r[c-1]]);\n        g[ma[r[c-1]]].push_back(ma[t]);\n      }\n      r[c]=t;\n    }\n    init();\n    while(m--) {\n      getline(cin,s);\n      stringstream ss;\n      ss << s;\n      string x,y,z;\n      ss >> x;\n      ss >> z;ss >> z;ss >> z;\n      ss >> y;ss >> y;\n      y=y.substr(0,y.size()-1);\n      int xx=ma[x],yy=ma[y];\n      bool f=0;\n      if(z==\"parent\") {\n        if(lcp(xx,yy)==xx&&dep[yy]-dep[xx]==1) f=1;\n      } else if(z==\"child\") {\n        if(lcp(xx,yy)==yy&&dep[xx]-dep[yy]==1) f=1;\n      } else if(z==\"sibling\") {\n        if(dep[xx]==dep[yy]&&dep[xx]-dep[lcp(xx,yy)]==1) f=1;\n      } else if(z==\"descendant\") {\n        if(lcp(xx,yy)==yy&&dep[xx]-dep[yy]>=1) f=1;\n      } else {\n        if(lcp(xx,yy)==xx&&dep[yy]-dep[xx]>=1) f=1;\n      }\n      if(f) cout << \"True\" << endl;\n      else cout << \"False\" << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <functional>\nusing namespace std;\ntypedef unordered_map<string,string> mss;\n\nunordered_map<string,function<bool(const string&,const string&,mss&)>>T={\n\t{\"child\",[](const string &x,const string &y,mss &parent){return parent[x]==y;}},\n\t{\"parent\",[](const string &x,const string &y,mss &parent){return parent[y]==x;}},\n\t{\"sibling\",[](const string &x,const string &y,mss &parent){return parent[x]==parent[y];}},\n\t{\"descendant\",[](const string &x,const string &y,mss &parent){\n\t\tstring z=parent[x];\n\t\tfor(;;){\n\t\t\tif(z==y)return true;\n\t\t\tif(parent[z]==\"\")return false;\n\t\t\tz=parent[z];\n\t\t}\n\t}},\n\t{\"ancestor\",[](const string &x,const string &y,mss &parent){\n\t\tstring z=parent[y];\n\t\tfor(;;){\n\t\t\tif(z==x)return true;\n\t\t\tif(parent[z]==\"\")return false;\n\t\t\tz=parent[z];\n\t\t}\n\t}},\n\n};\nint main(){\n\tint N,Q;\n\tstring line;\n\tfor(;cin>>N>>Q,N;){\n\t\tgetline(cin,line);\n\t\tmss parent;\n\t\tvector<string>stack;\n\t\tgetline(cin,line);\n\t\tparent[line]=\"\";\n\t\tstack.push_back(line);\n\t\tfor(int i=1;i<N;i++){\n\t\t\tgetline(cin,line);\n\t\t\tint idx=0;\n\t\t\tfor(;line[idx]==' ';idx++);\n\t\t\tstring name=line.substr(idx);\n\t\t\tif(idx>stack.size())return 1;\n\t\t\tfor(;idx<stack.size();stack.pop_back());\n\t\t\tparent[name]=stack[stack.size()-1];\n\t\t\tstack.push_back(name);\n\t\t}\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tgetline(cin,line);\n\t\t\tistringstream ss(line);\n\t\t\tstring x,z,y;\n\t\t\tss>>x>>y>>y>>z>>y>>y;\n\t\t\ty=y.substr(0,y.size()-1);\n\t\t\tcout<<(T[z](x,y,parent)?\"True\":\"False\")<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, m;\n\tbool f = false;\n\twhile(cin >> n >> m, n|m) {\n\t\tcin.ignore();\n\t\tvector<string> v(1000);\n\t\tmap<string, string> ma;\n\t\tREP(i, n) {\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\t\t\tint cnt = 0;\n\t\t\twhile(s[cnt] == ' ')\n\t\t\t\tcnt++;\n\t\t\ts = s.substr(cnt);\n\t\t\tif(!cnt)\n\t\t\t\tma[s] = \"\";\n\t\t\telse\n\t\t\t\tma[s] = v[cnt-1];\n\t\t\tv[cnt] = s;\n\t\t}\n\t\tif(f)\n\t\t\tcout << endl;\n\t\tf = true;\n\t\tREP(i, m) {\n\t\t\tstring in1, in2, in3;\n\t\t\tcin >> in1;\n\t\t\tcin >> in2 >> in2 >> in2;\n\t\t\tcin >> in3 >> in3;\n\t\t\tin3.erase(in3.end() - 1);\n\t\t\tbool ans = false;\n\t\t\tif(in2 == \"child\" && ma[in1] == in3)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"parent\" && ma[in3] == in1)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"sibling\" && ma[in1] == ma[in3])\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"descendant\") {\n\t\t\t\tstring s = ma[in1];\n\t\t\t\twhile(s != \"\") {\n\t\t\t\t\tif(s == in3)\n\t\t\t\t\t\tans = true;\n\t\t\t\t\ts = ma[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(in2 == \"ancestor\") {\n\t\t\t\tstring s = ma[in3];\n\t\t\t\twhile(s != \"\") {\n\t\t\t\t\tif(s == in1)\n\t\t\t\t\t\tans = true;\n\t\t\t\t\ts = ma[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans)\n\t\t\t\tcout << \"True\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"False\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n        set <string> S;\n        for ( int i = 0; i < n; i++ ) {\n            int L = i+1;\n            while ( L < n ) {\n                if ( D[i] == D[L] ) break;\n                L++;\n            }\n            for ( int j = i+1; j < L; j++ ) {\n                if ( D[i] + 1 == D[j] ) {\n                    // i is j's child\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] - 1 == D[j] ) {\n                    // i is j's parent\n                    T[i][j] |= 1<<1;\n                    T[j][i] |= 1<<2;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    // sibling\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] + 1 <= D[j] ) {\n                    // i is j's ancestor\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else if ( D[i] - 1 >= D[j] ) {\n                    // i is j's descendant\n                    T[i][j] |= 1<<5;\n                    T[j][i] |= 1<<4;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      /*\n      if(level_tree.find(mid) != level_tree.end())\n\tinfo.push_back(mid);\n      else if(mid == \"child\" || mid == \"parent\" || mid == \"sibling\" || mid == \"descendant\" || mid == \"ancestor\")\n\tinfo.pb(mid);\n      */\n      ope.push_back(mid);\n      //cout << \"ope = \" << mid << endl;\n    }\n\n skip:\n\n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i] == \"child\" || ope[i] == \"parent\" || ope[i] == \"sibling\" || ope[i] == \"descendant\" || ope[i] == \"ancestor\")\n\t{\n\t  info.push_back(ope[i]);\n\t  break;\n\t}\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n\n  //cout << info[0] << \" \" << info[1] <<\" \" << info[2] << endl; \n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n      //cout << \"Xindex = \" << Xindex << \" Yindex = \" << Yindex << endl;\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\t  //cout << \"vec : \" << vec[i].F << endl;\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || max(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      //cerr << n << \" \" << m << endl;\n      if(!(n+m))\n\tbreak;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  //cerr << line << endl;\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  //cerr << line << endl;\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nint par[1001];\nint curr[1001];\n\nvoid init(){\n\tfor(int i=0;i<=1000;i++){\n\t\tpar[i] = i;\n\t\tcurr[i] = -1;\n\t}\n}\n\nbool isSat(string question,map<int,string>& name,map<string,int>& num){\n\tstring str;\n\tstringstream ss(question);\n\tvector<string> v;\n\twhile(ss >> str){\n\t\tv.push_back(str);\n\t}\n\n\tstring X = v[0];\n\tstring Y = v[5].substr(0,v[5].size()-1);\n\n\t//X is a child of Y.\n\t//X is the parent of Y.\n\t//X is a sibling of Y.\n\t//X is a descendant of Y.\n\t//X is an ancestor of Y.\n\n\tif(v[3] == \"child\"){\n\t\treturn (par[num[X]] == num[Y] && num[Y] != -1);\n\t}\n\telse if(v[3] == \"parent\"){\n\t\treturn (par[num[Y]] == num[X] && num[X] != -1);\n\t}\n\telse if(v[3] == \"sibling\"){\n\t\treturn (par[num[Y]] == par[num[X]] && par[num[X]] != -1);\n\t}\n\telse if(v[3] == \"ancestor\"){\n\t\twhile(par[num[Y]] != -1){\n\t\t\tif(X == Y) return true;\n\t\t\tY = name[par[num[Y]]];\t\t\n\t\t}\n\t\treturn false;\n\t}\n\telse if(v[3] == \"descendant\"){\n\t\twhile(par[num[X]] != -1){\n\t\t\tX = name[par[num[X]]];\n\t\t\tif(X == Y) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tstring str;\n\n\twhile(getline(cin,str)){\n\t\tinit();\n\t\tstringstream ss(str);\n\t\tss >> str;\n\t\tint n = atoi(str.c_str());\n\t\tss >> str;\n\t\tint m = atoi(str.c_str());\n\n\n\t\tif(n==0 && m==0) break;\n\n\t\tmap<int,string> name;\n\t\tmap<string,int> num;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\n\t\t\t\n\t\t\tint j=0;\n\t\t\twhile(str[j] == ' ') j++;\n\t\t\tname[i] = str.substr(j,str.size()-j);\n\t\t\tnum[str.substr(j,str.size()-j)] = i;\n\n\t\t\tif(j==0){\n\t\t\t\tpar[i] = -1;\n\t\t\t}\n\t\t\telse par[i] = curr[j-1];\n\t\t\t//cout << str << endl;\n\n\t\t\tcurr[j] = i;\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tgetline(cin,str);\n\t\t\tif(isSat(str,name,num)){\n\t\t\t\tprintf(\"True\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"False\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n/*\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n*/\n        // child\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j]-1 ) {\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // sibling\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // descendant\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct person{\n\tvector<person> children;\n\tstring name;\n\tperson(string name):name(name){}\n\tint construct(vs &names,int indent,int index){\n\t\tFOR(i,index,names.size()){\n\t\t\tint next_indent=count(ALL(names[i]),' ');\n\t\t\tif(next_indent==indent+1){\n\t\t\t\tstring next_name=names[i];\n\t\t\t\tnext_name.erase(next_name.begin(),next_name.begin()+next_indent);\n\t\t\t\tchildren.push_back(person(next_name));\n\t\t\t}else if(next_indent>indent+1){\n\t\t\t\ti=children[children.size()-1].construct(names,indent+1,i)-1;\n\t\t\t}else{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn names.size();\n\t}\n\tbool is_child(string a,string b){\n\t\tif(name==b){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].name==a){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_child(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_descendant(string a,string b,bool flag=false){\n\t\tif(flag&&name==a){\n\t\t\treturn true;\n\t\t}\n\t\tif(name==b){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].is_descendant(a,b,true)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_descendant(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_parent(string a,string b){\n\t\tif(name==a){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].name==b){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_parent(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_ancestor(string a,string b,bool flag=false){\n\t\tif(flag&&name==b){\n\t\t\treturn true;\n\t\t}\n\t\tif(name==a){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].is_ancestor(a,b,true)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_ancestor(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_sibling(string a,string b){\n\t\tbool flag=false;\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].name==a||children[i].name==b){\n\t\t\t\tif(flag){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_sibling(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n&&m){\n\t\tstring name;\n\t\tgetline(cin,name);\n\t\tgetline(cin,name);\n\t\tperson root=person(name);\n\t\tvs names;\n\t\tREP(i,n-1){\n\t\t\tgetline(cin,name);\n\t\t\tnames.push_back(name);\n\t\t}\n\t\tint index=0;\n\t\troot.construct(names,0,index);\n\t\tREP(i,m){\n\t\t\tstring a,b,rel,trash;\n\t\t\tcin>>a>>trash>>trash>>rel>>trash>>b;\n\t\t\tbool ok;\n\t\t\tb.erase(b.end()-1,b.end());\n\t\t\tif(rel==\"child\"){\n\t\t\t\tok=root.is_child(a,b);\n\t\t\t}else if(rel==\"parent\"){\n\t\t\t\tok=root.is_parent(a,b);\n\t\t\t}else if(rel==\"ancestor\"){\n\t\t\t\tok=root.is_ancestor(a,b);\n\t\t\t}else if(rel==\"descendant\"){\n\t\t\t\tok=root.is_descendant(a,b);\n\t\t\t}else if(rel==\"sibling\"){\n\t\t\t\tok=root.is_sibling(a,b);\n\t\t\t}else{\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t\tcout<<(ok?\"True\":\"False\")<<endl;\n\t\t}\n\t\tcout<<endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n/*\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n*/\n        // child\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j]-1 ) {\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] >= D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // sibling\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // descendant\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << A << \", \" << B << \": \" << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tX is a child of Y.@XÌeð²×Ä­B\n\tX is the parent of Y.@YÌeð²×Ä­\n\tX is a sibling of Y. XÆYÌ[³ª¯¶©mF·é\n\tX is a descendant of Y. XÌeðÄAIÉ\n\tX is an ancestor of Y.@YÌeðÄAIÉ\n*/\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <sstream>\n#include <set>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nmap<string,string> data;\nmap<string,int> dp;\n\nvector< pair<string,int> > rec;\n\nint n,m,I,back;\n\nvoid input(string parent,int depth){\n\twhile( I < n ){\n\t\tstring nstr = rec[I].first;\n\t\tint ndp = rec[I].second;\n\t\tdata[nstr] = parent;\n\t\tdp[nstr] = depth;\n\t\tI++;\n\t\tif(depth < ndp){\n\t\t\tinput(nstr,ndp);\n\t\t\tif(back){\n\t\t\t\tback--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}else if(depth > ndp){\n\t\t\tback = depth-ndp-1;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool func(string a,string b){\n\tif(a == \"\")return false;\n\treturn a==b ? true : func(data[a],b);\n}\n\nint main(){\n\tstring s;\n\twhile(scanf(\"%d %d\\n\",&n,&m) , n){\n\t\tint prevCount=0,tmpCount;\n\t\tvector< pair<string,int> > in(n,make_pair(\"\",-1));\n\t\tdata.clear();dp.clear();\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,s);\n\t\t\tif(i){\n\t\t\t\tin[i-1].second = count(s.begin(),s.end(),' ');\n\t\t\t}\n\t\t\ts.erase(remove(s.begin(),s.end(),' '),s.end());\n\t\t\tin[i].first = s;\n\t\t}\n\t\trec=in;\n\t\tI = back = \t0;\n\t\tinput(\"\",0);\n\t\t\n\t\tbool flag;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tvector<string> tmp;\n\t\t\tgetline(cin,s);\n\t\t\ts = s.substr(0,s.length()-1);\n\t\t\tstringstream ss(s);\t\n\t\t\twhile(ss >> s)tmp.push_back(s);\n\t\t\tstring X = tmp[0], Y = tmp[5] , type = tmp[3];\n\t\t\n\t\t\n\t\t\tif(type == \"child\")flag = (data[X] == Y);\n\t\t\tif(type == \"parent\")flag = (data[Y] == X);\n\t\t\tif(type == \"sibling\")flag = (data[X] == data[Y]);\n\t\t\tif(type == \"descendant\")flag = (func(X,Y)) ;\n\t\t\tif(type == \"ancestor\")flag = (func(Y,X)) ;\n\t\t\t\n\t\t\tcout << (flag?\"True\":\"False\") << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    break;\n                } else if ( D[i] + 1 == D[j] ) {\n                    // i is j's parent\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] - 1 == D[j] ) {\n                    // i is j's child\n                    T[i][j] |= 1<<1;\n                    T[j][i] |= 1<<2;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    // sibling\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap<string,int> mp;\nint ind[1001],par[1001];\nbool ko(int a,int b){\n  return par[a]==b;\n}\n\nbool sos(int a,int b){\n  while(a!=b&&a)\n    a=par[a];\n  return a==b;\n}\n\nint main(){\n  int n,m,T=0;\n  string s;\n  while(cin>>n>>m,n){\n    getline(cin,s);\n    memset(ind,0,sizeof(ind));\n    memset(par,0,sizeof(par));\n    mp.clear();\n    par[0]=-1;\n    for(int i=0;i<n;i++){\n      int k;\n      getline(cin,s);\n      for(k=0;s[k]==' ';k++);\n      s=s.substr(k,s.size()-k);\n      mp[s]=i;\n      ind[i]=k;\n      for(int j=i-1;j>=0;j--)\n\tif(ind[j]<k){par[i]=j;break;}\n    }\n    for(int i=0;i<m;i++){\n      string q[6];\n      for(int j=0;j<6;j++)cin>>q[j];\n      bool ans;\n      q[5]=q[5].substr(0,q[5].size()-1); \n      int a=mp[q[0]],b=mp[q[5]];\n      if(q[3]==\"child\")ans=ko(a,b);\n      if(q[3]==\"parent\")ans=ko(b,a);\n      if(q[3]==\"sibling\")ans=(par[a]==par[b]);\n      if(q[3]==\"descendant\")ans=sos(a,b);\n      if(q[3]==\"ancestor\")ans=sos(b,a);\n      if(ans)cout<<\"True\"<<endl;\n      else cout<<\"False\"<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\n#include<cassert>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\n#define Pint pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 2000;\n\nstring human[MAX_M][MAX_M];\nmap<string, Pint > human_map;\n\nbool tmpCheck(int y, int x){\n    if(y >= MAX_M) return false;\n    if(x >= MAX_M) return false;\n    if(y < 0) return false;\n    if(x < 0) return false;\n    return true;\n}\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ' && cnt < str.size() - 1) cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nstring getParent(string x){\n\tint depth = human_map[x].second - 1, id = human_map[x].first - 1;\n\twhile(id >= 0 && depth >= 0){\n\t\tif(human[id][depth] != \"\") return human[id][depth];\n\t\tid--;\n\t}\n\treturn \"_\"; // FAILED\n}\n\nbool checkAncestor(string x, string y){\n\twhile(y != \"_\"){\n\t\tif(x == y) return true;\n\t\ty = getParent(y);\n\t}\n}\n\nbool checkParent(string x, string y){\n\treturn getParent(y) == x;\n}\n\nbool checkSibling(string x, string y){\n\tx = getParent(x);\n\ty = getParent(y);\n\t\n\tif(x == \"_\" || y == \"_\") return false;\n\treturn x == y;\n}\n\nbool checkQ(string str){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    string y = vec[5].erase(vec[5].size() - 1);\n    if(vec[3] == \"child\") return checkParent(y, vec[0]);\n    else if(vec[3] == \"parent\") return checkParent(vec[0], y);\n    else if(vec[3] == \"sibling\") return checkSibling(vec[0], y);\n    else if(vec[3] == \"descendant\") return checkAncestor(y, vec[0]);\n    else if(vec[3] == \"ancestor\") return checkAncestor(vec[0], y);\n\telse assert(0);\n}\n\nint main(){\n    while(true){\n        int m, n;\n        string st;\n        getline(cin, st);\n        stringstream ss(st);\n        ss >>m >>n;\n        if(!n && !m) break;\n\n        REP(i, MAX_M) REP(j, MAX_M) human[i][j] = \"\";\n        human_map.clear();\n\n        REP(i, m){\n            string str;\n            getline(cin, str);\n            P tmp = cntSpace(str);\n            human[i][tmp.first] = tmp.second;\n            human_map[tmp.second] = Pint(i, tmp.first);\n        }\n\n        REP(i, n){\n            string str;\n            getline(cin, str);\n            if(checkQ(str) == true) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1001\nusing namespace std;\nvector<int> T[N];\nint par[N];\nmap<string,int> M;\nstring mp[N];\nint n,m;\nint pos=0,used[N];\n\nint cnt(int i){\n  int sp=0;\n  while(mp[i][sp]==' ')sp++;  \n  return sp;\n}\n\nvoid mk_tree(){\n  int idx=pos;\n  int sp1=cnt(pos++);\n  while(pos<n){\n    int sp2=cnt(pos);\n    if(sp1<sp2){\n      T[idx].push_back(pos);\n      par[pos]=idx;\n      mk_tree();\n    }\n    else break;\n  }\n}\n\nbool check(int pos,int target){\n  if(pos==target) return 1;\n  for(int i=0;i<T[pos].size();i++)\n    if(check(T[pos][i],target))return 1;\n  return 0;\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(n==0&&m==0)break;\n  \n  M.clear();\n  memset(used,0,sizeof(used));\n  memset(par,0,sizeof(par));\n  for(int i=0;i<N;i++)T[i].clear();\n\n  n++;\n  mp[0]=\"#######\";\n  M[mp[0]]=0;\n  getline(cin,mp[0]);\n  for(int i=1;i<n;i++){\n    getline(cin,mp[i]);\n    mp[i]=\" \"+mp[i];\n    int j=0;\n    while(mp[i][j]==' ')j++;\n    M[mp[i].substr(j,mp[i].size()-j)] = i;\n  }\n  pos=0;\n  mk_tree();  \n\n  while(m--){\n    string name1,str,name2,tmp;\n    cin>>name1>>tmp>>tmp>>str>>tmp>>name2;\n    name2=name2.substr(0,name2.size()-1);\n    int ans=0;\n    if(str==\"child\"||str==\"parent\"){\n      if(str==\"child\")swap(name1,name2);\n      int idx=M[name1],target=M[name2];\n      for(int i=0;i<(int)T[idx].size();i++)if(T[idx][i]==target)ans=1;\n    }\n    if(str==\"ancestor\"||str==\"descendant\"){\n      if(str==\"descendant\")swap(name1,name2);\n      ans=check(M[name1],M[name2]);\n    }\n    if(str==\"sibling\") ans=par[M[name1]]==par[M[name2]];\n    cout<<(ans?\"True\":\"False\")<<endl;\n  \n  }\n  cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nint oldest,youngest;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n  oldest = min(oldest,space_cnt);\n  youngest = max(youngest,space_cnt);\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      \n      ope.push_back(mid);\n      \n    }\n\n skip:\n\n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i][0] == 'c' || ope[i][0] == 'p' || ope[i][0] == 's' || ope[i][0] == 'd' || ope[i][0] == 'a')\n\t{\n\t  info.push_back(ope[i]);\n\t  break;\n\t}\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n\n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n\n      if(vec[Xindex].S <= vec[Yindex].S || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S >= vec[Yindex].S || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || min(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(Yindex+1 >= vec.size() || vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      for(int i=Yindex+1;i<vec.size() && vec[i].S > vec[Yindex].S;i++)\n\t{\n\t  if(vec[i].F == vec[Xindex].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(Xindex+1 >= vec.size()  || vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      for(int i=Xindex+1;i < vec.size() && vec[i].S > vec[Xindex].S;i++)\n\t{\n\t  if(vec[i].F == vec[Yindex].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n   \n      if(!(n+m))\n\tbreak;\n      oldest = (1<<28);\n      youngest = -1;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t\n\t  split(vec,line);\n\t}\n\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\tindex_tree[vec[i].F] = i;\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t \n\t  ParseAndSolve(vec,index_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 1010;\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ') cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nbool isParent(int x, int y, vector<int> parent){\n    if(parent[y] == x) return true;\n    else return false;\n}\n\nbool checkQ(string str, map<string, int> list_i, vector<int> parent){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    int x = list_i[vec[0]];\n    int y = list_i[vec[5].erase(vec[5].size() - 1)];\n\n    if(vec[3] == \"child\") return isParent(y, x, parent);\n    if(vec[3] == \"parent\") return isParent(x, y, parent);\n    if(vec[3] == \"sibling\") return parent[x] == parent[y];\n    if(vec[3] == \"descendant\"){\n        int now_x = x;\n        while(parent[now_x] != -1){\n            if(isParent(y, now_x, parent) == true) return true;\n            now_x = parent[now_x];\n        }\n        return false;\n    }\n    if(vec[3] == \"ancestor\"){\n        int now_y = y;\n        while(parent[now_y] != -1){\n            if(isParent(x, now_y, parent) == true) return true;\n            now_y = parent[now_y];\n        }\n        return false;\n    }\n}\n\n\n\nint main(){\n    int m, n;\n    while(cin >>m >>n && (n && m)){\n        string name_line;\n        getline(cin, name_line);\n\n        vector<int> parent(m);\n        int current_parent_i[MAX_M];\n        map<string, int> list_i;\n\n        parent[0] = -1;\n\n        REP(i, m){\n            getline(cin, name_line);\n\n            P rank_and_name = cntSpace(name_line);\n            current_parent_i[rank_and_name.first + 1] = i;\n            list_i[rank_and_name.second] = i;\n\n            if(i != 0){\n                int now_parent = current_parent_i[rank_and_name.first];\n                parent[i] = now_parent;\n            }\n        }\n\n        REP(i, n){\n            string q;\n            getline(cin, q);\n            bool ans = checkQ(q, list_i, parent);\n            if(ans) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n        }\n\n        set <string> S;\n        for ( int i = 0; i < n; i++ ) {\n            int L = i+1;\n            while ( L < n ) {\n                if ( D[i] == D[L] ) break;\n                L++;\n            }\n            for ( int j = i+1; j < L; j++ ) {\n                ostringstream os;\n                if ( D[i] + 1 == D[j] ) {\n                    os << N[i] << \" is the parent of \" << N[j] << \".\";\n                    S.insert( os.str() );\n                    os.str(\"\");\n                    os << N[j] << \" is a child of \" << N[i] << \".\";\n                    S.insert( os.str() );\n                } else if ( D[i] == D[j] ) {\n                    os << N[i] << \" is a sibling of \" << N[j] << \".\";\n                    S.insert( os.str() );\n                    os.str(\"\");\n                    os << N[j] << \" is a sibling of \" << N[i] << \".\";\n                    S.insert( os.str() );\n                } else if ( D[i] - 1 == D[j] ) {\n                    os << N[i] << \" is a child of \" << N[j] << \".\";\n                    S.insert( os.str() );\n                    os.str(\"\");\n                    os << N[j] << \" is a parent of \" << N[i] << \".\";\n                    S.insert( os.str() );\n                } else if ( D[i] + 1 < D[j] ) {\n                    os << N[i] << \" is an ancestor of \" << N[j] << \".\";\n                    S.insert( os.str() );\n                    os.str(\"\");\n                    os << N[j] << \" is a descendant of \" << N[i] << \".\";\n                    S.insert( os.str() );\n                } else if ( D[i] + 1 > D[j] ) {\n                    os << N[i] << \" is a descendant of \" << N[j] << \".\";\n                    S.insert( os.str() );\n                    os.str(\"\");\n                    os << N[j] << \" is an ancestor of \" << N[i] << \".\";\n                    S.insert( os.str() );\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                ostringstream os;\n                if ( D[i] == D[j] ) {\n                    os << N[i] << \" is a sibling of \" << N[j] << \".\";\n                    S.insert( os.str() );\n                    os.str(\"\");\n                    os << N[j] << \" is a sibling of \" << N[i] << \".\";\n                    S.insert( os.str() );\n                } else if ( D[i] + 1 < D[j] ) {\n                    os << N[i] << \" is an ancestor of \" << N[j] << \".\";\n                    S.insert( os.str() );\n                    os.str(\"\");\n                    os << N[j] << \" is a descendant of \" << N[i] << \".\";\n                    S.insert( os.str() );\n                } else if ( D[i] + 1 > D[j] ) {\n                    os << N[i] << \" is a descendant of \" << N[j] << \".\";\n                    S.insert( os.str() );\n                    os.str(\"\");\n                    os << N[j] << \" is an ancestor of \" << N[i] << \".\";\n                    S.insert( os.str() );\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            cout << ( S.count( line ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;"
  },
  {
    "language": "C++",
    "code": "6 5\nJohn\n Robert\n  Frank\n  Andrew\n Nancy\n  David\nRobert is a child of John.\nRobert is an ancestor of Andrew.\nRobert is a sibling of Nancy.\nNancy is the parent of Frank.\nJohn is a descendant of Andrew.\n2 1\nabc\n xyz\nxyz is a child of abc.\n0 0"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct tree {\n\tstring name;\n\tint depth;\n\tvector<unique_ptr<tree>>childs;\n\ttree(const string _name,const int _depth) :name(_name),depth(_depth),childs() {\n\n\t}\n};\nunique_ptr<tree> maketree(vector<string>&sts, vector<int>&ns,int depth,int &a) {\n\tunique_ptr<tree> t(make_unique<tree>(sts[a],depth));\n\twhile (a+1!=sts.size()&&ns[a+1] > depth) {\n\t\ta++;\n\t\tt->childs.push_back(maketree(sts, ns, depth + 1, a));\n\t\t\n\t}\n\treturn t;\n}\n\nvector<string> split(const string &str, char delim) {\n\tvector<string> res;\n\tsize_t current = 0, found;\n\twhile ((found = str.find_first_of(delim, current)) != string::npos) {\n\t\tres.push_back(string(str, current, found - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str, current, str.size() - current));\n\treturn res;\n}\nint dfs(const unique_ptr<tree>&tp,int type,string a,string b,bool flag) {\n\t//a is parant of b\n\tif (type == 0) {\n\t\tif (a == tp->name) {\n\t\t\tfor (auto&& c : tp->childs) {\n\t\t\t\tif (c->name == b)return 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num=dfs(c, type, a, b,flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse if (type == 1) {\n\t\tif (flag) {\n\t\t\tif (tp->name == b)return 1;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tif (tp->name == a)flag = true;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\tif (flag)return 0;\n\t\t\telse return -1;\n\t\t}\n\t}\n\telse {\n\t\tint same = 0;\n\t\tfor (auto&&c : tp->childs) {\n\t\t\tif (c->name == a)same++;\n\t\t\tif (c->name == b)same++;\n\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\tif (num != -1)return num;\n\t\t}\n\t\tif (same == 2)return 1;\n\t\telse if (same == 1)return 0;\n\t\telse return -1;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tunique_ptr<tree> t;\n\t\t{\n\t\t\tvector<string>sts;\n\t\t\tvector<int>ns;\n\t\t\tstring st; getline(cin, st);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgetline(cin, st);\n\t\t\t\tint n = st.find_first_not_of(' ');\n\t\t\t\tsts.push_back(st.substr(n));\n\t\t\t\tns.push_back(n);\n\t\t\t}\n\n\t\t\tint a = 0;\n\t\t\tt = maketree(sts, ns, 0, a);\n\t\t}\n\t\t\n\t\twhile (M--) {\n\t\t\tstring st;\n\t\t\tgetline(cin, st);\n\t\t\tvector<string>sts(split(st, ' '));\n\t\t\tstring a = sts[0];\n\t\t\tstring b = sts[5].substr(0, sts[5].size() - 1);\n\t\t\tint ans;\n\t\t\tif (sts[3] == \"child\") {\n\t\t\t\tans = dfs(t, 0, b, a, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"ancestor\") {\n\t\t\t\tans = dfs(t,1, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"sibling\") {\n\t\t\t\tans = dfs(t, 2, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"parent\") {\n\t\t\t\tans = dfs(t, 0, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"descendant\") {\n\t\t\t\tans = dfs(t, 1, b, a, false);\n\t\t\t}\n\t\t\tif (ans == 1)cout << \"True\" << endl;\n\t\t\telse if (ans == 0)cout << \"False\" << endl;\n\t\t\telse assert(false);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct tree {\n\tstring name;\n\tint depth;\n\tvector<unique_ptr<tree>>childs;\n\ttree(const string _name,const int _depth) :name(_name),depth(_depth),childs() {\n\n\t}\n};\nunique_ptr<tree> maketree(vector<string>&sts, vector<int>&ns,int depth,int &a) {\n\tunique_ptr<tree> t(make_unique<tree>(sts[a],depth));\n\twhile (a+1!=sts.size()&&ns[a+1] > depth) {\n\t\ta++;\n\t\tt->childs.push_back(maketree(sts, ns, depth + 1, a));\n\t\t\n\t}\n\treturn t;\n}\n\nvector<string> split(const string &str, char delim) {\n\tvector<string> res;\n\tsize_t current = 0, found;\n\twhile ((found = str.find_first_of(delim, current)) != string::npos) {\n\t\tres.push_back(string(str, current, found - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str, current, str.size() - current));\n\treturn res;\n}\nint dfs(const unique_ptr<tree>&tp,int type,string a,string b,bool flag) {\n\t//a is parant of b\n\tif (type == 0) {\n\t\tif (a == tp->name) {\n\t\t\tfor (auto&& c : tp->childs) {\n\t\t\t\tif (c->name == b)return 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num=dfs(c, type, a, b,flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse if (type == 1) {\n\t\tif (flag) {\n\t\t\tif (tp->name == b)return 1;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tif (tp->name == a)flag = true;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tint same = 0;\n\t\tfor (auto&&c : tp->childs) {\n\t\t\tif (c->name == a)same++;\n\t\t\tif (c->name == b)same++;\n\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\tif (num != -1)return num;\n\t\t}\n\t\tif (same == 2)return 1;\n\t\telse if (same == 1)return 0;\n\t\telse return -1;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tunique_ptr<tree> t;\n\t\t{\n\t\t\tvector<string>sts;\n\t\t\tvector<int>ns;\n\t\t\tstring st; getline(cin, st);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgetline(cin, st);\n\t\t\t\tint n = st.find_first_not_of(' ');\n\t\t\t\tsts.push_back(st.substr(n));\n\t\t\t\tns.push_back(n);\n\t\t\t}\n\n\t\t\tint a = 0;\n\t\t\tt = maketree(sts, ns, 0, a);\n\t\t}\n\t\t\n\t\twhile (M--) {\n\t\t\tstring st;\n\t\t\tgetline(cin, st);\n\t\t\tvector<string>sts(split(st, ' '));\n\t\t\tstring a = sts[0];\n\t\t\tstring b = sts[5].substr(0, sts[5].size() - 1);\n\t\t\tint ans;\n\t\t\tif (sts[3] == \"child\") {\n\t\t\t\tans = dfs(t, 0, b, a, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"ancestor\") {\n\t\t\t\tans = dfs(t,1, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"sibling\") {\n\t\t\t\tans = dfs(t, 2, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"parent\") {\n\t\t\t\tans = dfs(t, 0, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"descendant\") {\n\t\t\t\tans = dfs(t, 1, b, a, false);\n\t\t\t}\n\t\t\tif (ans == 1)cout << \"True\" << endl;\n\t\t\telse if (ans == 0)cout << \"False\" << endl;\n\t\t\telse assert(false);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nstruct Person {\n  string name;\n  Person *parent;\n};\n\nconst int MAXN = 1005;\nint N, M;\nmap<string, Person*> conv;\nPerson root, person[MAXN];\n\nvoid init() {\n  conv.clear();\n  root.name = \"root\";\n  root.parent = NULL;\n}\n\nbool child(Person *a, Person *b) { // a is child of b\n  return a->parent == b;\n}\n\nbool sibling(Person *a, Person *b) {\n  return a->parent == b->parent;\n}\n\nbool descendant(Person *a, Person *b) { // a is descendant of b\n  while(a != NULL) {\n    if(a->parent == b) return true;\n    a = a->parent;\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    cin.ignore();\n    init();\n    Person *cp = &root;\n    int depth = -1;\n    for(int i = 0; i < N; ++i) {\n      string line;\n      getline(cin, line);\n      int sp = 0;\n      for(int j = 0; j < line.size() && line[j] == ' '; ++j, ++sp);\n\n      Person &c = person[i];\n      c.name = line.substr(sp);\n      conv[c.name] = &person[i];\n\n      if(sp > depth) {\n        c.parent = cp;\n      } else {\n        for(int j = 0; j < depth-sp; ++j) {\n          cp = cp->parent;\n        }\n        c.parent = cp->parent;\n      }\n      cp = &c;\n      depth = sp;\n    }\n\n    while(M--) {\n      string x, y, type;\n      string dumy;\n      cin >> x >> dumy >> dumy >> type >> dumy >> y;\n      y = y.substr(0, y.size()-1);\n      bool output = false;\n      if(0) {\n      } else if(type == \"child\") {\n        output = child(conv[x], conv[y]);\n      } else if(type == \"parent\") {\n        output = child(conv[y], conv[x]);\n      } else if(type == \"sibling\") {\n        output = sibling(conv[x], conv[y]);\n      } else if(type == \"descendant\") {\n        output = descendant(conv[x], conv[y]);\n      } else if(type == \"ancestor\") {\n        output = descendant(conv[y], conv[x]);\n      }\n      cout << (output ? \"True\" : \"False\") << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nvector<string> split(const string &str, const string& delimiter = \" \")\n{\n\tvector<string> res;\n\tstring::size_type i = 0, pos;\n\twhile ((pos = str.find(delimiter, i)) != string::npos)\n\t{\n\t\tres.push_back(str.substr(i, pos - i));\n\t\ti = pos + 1;\n\t}\n\tres.push_back(str.substr(i, str.size() - i));\n\treturn res;\n}\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n | m)\n\t{\n\t\tmap<string, string> parent;\n\t\tstring indent_to_name[1024];\n\n\n\t\tstring line;\n\t\tgetline(cin, line);\n\n\t\tgetline(cin, line);\n\t\tindent_to_name[0] = line;\n\t\trep (i, n - 1)\n\t\t{\n\t\t\tgetline(cin, line);\n\t\t\tint indent = line.find_first_not_of(' ');\n\t\t\tstring name = line.substr(indent);\n\t\t\tindent_to_name[indent] = name;\n\n\t\t\tparent[name] = indent_to_name[indent - 1];\n\t\t}\n\n\t\trep (i, m)\n\t\t{\n\t\t\tgetline(cin, line);\n\t\t\tvector<string> hoge = split(line);\n\t\t\tstring x = hoge[0], y = hoge.back();\n\t\t\ty.erase(y.size() - 1);\n\t\t\tstring query = hoge[3];\n\n\t\t\tif (query == \"descendant\")\n\t\t\t{\n\t\t\t\tquery = \"ancestor\";\n\t\t\t\tswap(x, y);\n\t\t\t}\n\t\t\telse if (query == \"child\")\n\t\t\t{\n\t\t\t\tquery = \"parent\";\n\t\t\t\tswap(x, y);\n\t\t\t}\n\n\t\t\tbool res = false;\n\t\t\tif (query == \"parent\")\n\t\t\t\tres = x == parent[y];\n\t\t\telse if (query == \"sibling\")\n\t\t\t\tres = parent[x] == parent[y];\n\t\t\telse if (query == \"ancestor\")\n\t\t\t{\n\t\t\t\twhile (parent.count(y))\n\t\t\t\t{\n\t\t\t\t\ty = parent[y];\n\t\t\t\t\tif (x == y)\n\t\t\t\t\t{\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << (res ? \"True\" : \"False\") << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\nstruct Node{\n  vector<Node*> child;\n  Node* parent;\n  string name;\n  Node():name(\"\"){}\n  Node(vector<Node*> c, Node* p, string s):child(c),parent(p),name(s){}\n\n  void init(){\n    for(int i = 0; i < (int)child.size(); i++)\n      child[i]->init();\n    child.clear();\n  }\n\n  bool isSibling(const string& A, const string& B){\n    if(child.size() == 0) return false;\n    int found = 0;\n    for(int i = 0; i < (int)child.size(); i++)\n      if(child[i]->name == A || child[i]->name == B) found++;\n    \n    if(found==2) return true;\n    if(found==1) return false;\n    for(int i = 0; i < (int)child.size(); i++) return child[i]->isSibling(A,B);\n  }\n\n  bool isChild(const string& A){\n    for(int i = 0; i < (int)child.size(); i++)\n      if(child[i]->name == A) return true;\n    return false;\n  }\n\n  bool isDecendant(const string& A){\n    for(int i = 0; i < (int)child.size(); i++)\n      if(child[i]->name == A) return true;\n    \n    bool res = false;\n    for(int i = 0; i < (int)child.size(); i++)\n      res = res||child[i]->isDecendant(A);\n    return res;\n  }\n\n  Node* find(const string& name){\n    for(int i = 0; i < (int)child.size(); i++)\n      if(child[i]->name == name) return child[i];\n\n    for(int i = 0; i < (int)child.size(); i++){\n      Node* tmp = child[i]->find(name);\n      if(tmp != NULL) return tmp;\n    }\n    return NULL;\n  }\n};\n\nint N,M;\nNode* top = new Node(vector<Node*>(), top, \"\");\n\nP devide(const string& s){\n  int blank = 0;\n  for(int i = 0; i < (int)s.length(); i++) if(s[i] == ' ') blank++;\n  return P(blank,s.substr(blank));\n}\n\nvoid input(){\n  cin.ignore();\n  \n  Node* now = top;\n  int depth = -1;\n\n  for(int i = 0; i < N; i++){\n    string s;\n    getline(cin,s);\n    P p = devide(s);\n\n    Node* nex = new Node(vector<Node*>(), now, p.second);\n    \n    if(p.first == depth){\n      now->child.push_back(nex);\n    }\n\n    if(p.first < depth){\n      // go up\n      int diff = depth-p.first+1;\n      for(int i = 0; i < diff; i++) now = now->parent;  \n      now->child.push_back(nex);\n      now = nex;\n      depth = p.first;\n    }\n    \n    if(p.first > depth){\n      // go down\n      now->child.push_back(nex);\n      now = nex;\n      depth = p.first;\n    }\n  }\n}\n\nvoid solve(){\n\n\n  for(int i = 0; i < M; i++){\n    string X,Y,Q,trash;\n    cin >> X >> trash >> trash >> Q >> trash >> Y;\n    bool ans = false;\n    Y = Y.substr(0,Y.length()-1);\n\n    // cout << X << \" \" << Y << \" \" << Q << endl;\n    if(Q[0]=='c') ans = (top->find(Y))->isChild(X);\n    if(Q[0]=='p') ans = (top->find(X))->isChild(Y);\n    if(Q[0]=='s') ans = top->isSibling(X,Y);\n    if(Q[0]=='d') ans = (top->find(Y))->isDecendant(X);\n    if(Q[0]=='a') ans = (top->find(X))->isDecendant(Y);\n    \n    cout << (ans?\"True\":\"False\") << endl;\n  }\n  cout << endl;\n}\n\nint main(){\n  \n  while(cin >> N >> M && N+M){\n    top->init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    cin.ignore();\n    int table[n];\n    map<string, int> mp;\n    int parent[n];\n    vector<int> children[n];\n    REP(i,n) {\n      string name;\n      getline(cin, name);\n\n      if (i==0) {\n        mp[name] = 0;\n        table[0] = 0;\n        parent[0] = -1;\n        continue;\n      }\n      \n      int space = 0;\n      while(name[space]==' ') space++;\n      name = name.substr(space);\n      \n      children[table[space-1]].push_back(i);\n      parent[i] = table[space-1];\n      table[space] = i;\n      mp[name] = i;\n    }\n    // FOR(it, mp)\n    //   cout << it->first<< \" \" <<it->second<<endl;\n\n    REP(i,m) {\n      string line;\n      getline(cin,line);\n      line[line.size()-1] = ' ';\n      stringstream ss(line);\n      string xx, s, tmp, yy;\n      ss >>xx>>tmp>>tmp>>s>>tmp>>yy;\n      int x = mp[xx], y = mp[yy];\n      bool f = 0;\n      if (s==\"child\") {\n        if (parent[x] == y)\n          f = 1;\n      } else if (s==\"parent\") {\n        if (parent[y] == x)\n          f= 1;\n      } else if (s==\"sibling\") {\n        if (binary_search(ALL(children[parent[x]]), y))\n          f = 1;\n      } else if (s==\"descendant\") {\n        while(parent[x]!=-1) {\n          x = parent[x];\n          if (x==y) {\n            f = 1;\n            break;\n          }\n        }\n      } else {\n        while(parent[y]!=-1) {\n          y = parent[y];\n          if (x==y) {\n            f = 1;\n            break;\n          }\n        }\n      }\n      if (f)\n        cout << \"True\" << endl;\n      else\n        cout << \"False\" << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      if(level_tree.find(mid) != level_tree.end())\n\tinfo.push_back(mid);\n      else if(mid == \"child\" || mid == \"parent\" || mid == \"sibling\" || mid == \"descendant\" || mid == \"ancestor\")\n\tinfo.pb(mid);\n    }\n\n skip:\n\n  \n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n      //cout << \"Xindex = \" << Xindex << \" Yindex = \" << Yindex << endl;\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\t  //cout << \"vec : \" << vec[i].F << endl;\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || max(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      cerr << n << \" \" << m << endl;\n      if(!(n+m))\n\tbreak;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  cerr << line << endl;\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  cerr << line << endl;\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nbool search(const vector<set<int> > &g, int now, int dist){\n  if(dist == now) return true;\n  FOR(it,g[now]) if(search(g, *it, dist)) return true;\n  return false;\n}\n\n\nint main(){\n  while(true){\n    int n,m;\n    string buff;\n\n    getline(cin, buff);\n    sscanf(buff.c_str(), \"%d%d\", &n, &m);\n    if(n + m == 0) break;\n\n    vector<set<int> > g(n);\n    vector<int> p(n);\n    map<string,int> name;\n\n    stack<int> st;\n\n    REP(i,n){\n      getline(cin, buff);\n      for(int j=0; ;j++){\n        if(buff[j] != ' '){\n\n          int next = name.size();\n          buff = buff.substr(j);\n          name[buff] = next;\n\n          while(j != st.size())\n            st.pop();\n\n          if(st.size()){\n            g[st.top()].insert(next);\n            p[next] = st.top();\n          }\n\n          st.push(next);\n          break;\n        }\n      }\n    }\n\n    REP(i,m){\n      string n1, b, a, r, o, n2;\n      getline(cin, buff);\n      stringstream ss(buff);\n      ss>>n1>>b>>a>>r>>o>>n2;\n\n      int aa = name[n1];\n      int bb = name[n2.substr(0, n2.size()-1)];\n\n      //cout << aa << \" \" <<r << \" \" << bb << \" \";\n\n      bool ans = false;\n      switch(r[0]){\n      case 'c':\n        if(g[bb].count(aa)) ans = true;\n        break;\n      case 'p':\n        if(g[aa].count(bb)) ans = true;\n        break;\n      case 's':\n        if(aa != 0 && g[p[aa]].count(bb)) ans = true;\n        break;\n      case 'd':\n        ans = search(g, bb, aa);\n        break;\n      case 'a':\n        ans = search(g, aa, bb);\n        break;\n      }\n      cout << (ans ? \"True\" : \"False\") << endl;\n    }\n\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint m,n;\n\nstruct nodeInfo{\n    int depth;\n};\n\nmap<string,int> id;\nvector<int> G[1010];\nnodeInfo nif[1010];\n\nint backNode(int cnode,int cnt){\n    for(int i = 0; i < cnt; i++){\n        for(int j = 0; j < G[cnode].size(); j++){\n            // ツ親ツノツーツドツづ個づ卍つ、ツつェツ深ツつウツつェツ静ウツつ「\n            if(nif[G[cnode][j]].depth<nif[cnode].depth){\n                cnode=G[cnode][j];\n                break;\n            }\n        }\n    }\n    return cnode;\n }\n\nbool isChild(int n1idx,int n2idx){\n    // ツ暗ェツづつ可コツづ鳴探ツ催オツづーツつゥツつッツづゥ\n    for(int i = 0; i < G[n2idx].size(); i++)\n        if(nif[G[n2idx][i]].depth>nif[n2idx].depth&&G[n2idx][i]==n1idx)\n            return true;\n    return false;\n}\nbool isAncestor(int n1idx,int n2idx){\n    int cnode=n2idx;\n    while(1){\n        if(cnode==n1idx)\n            return true;\n        // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n        if(cnode==0)\n            return false;\n        else\n            cnode=backNode(cnode,1);\n    }\n}\n\nint main(){\n    bool f=false;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        if(f)\n            cout<<endl;\n        f=true;\n        id.clear();\n        string str;\n        getline(cin,str);\n        for(int i = 0; i < 1010; i++)G[i].clear();\n        int depth=-1;\n        int cp=-1;\n        for(int i = 0; i < n; i++){\n            getline(cin,str);\n            int cnt=0;\n            for(int j = 0; ;j++){\n                if(str[j]==' ')continue;\n                else{\n                    str=str.substr(j);\n                    cnt=j;\n                    break;\n                }\n            }\n            id[str]=i;\n            // cntツづ個青板つセツつッツ親ツづ可姪淞づィツ、ツつサツつアツづ可ノツーツドツづーツ挿ツ禿シツつキツづゥ\n            if(cp==-1)\n                cp=i;\n            else if(depth<cnt){\n                G[cp].push_back(i);\n                G[i].push_back(cp);\n                cp=i;\n            }\n            else{\n                int back=backNode(cp,depth-cnt+1);\n                G[back].push_back(i);\n                G[i].push_back(back);\n                cp=i;\n            }\n            depth=cnt;\n            nif[i].depth=depth;\n        }\n        for(int j = 0; j < m; j++){\n            string name1,name2;\n            string tmp;\n            string order;\n            cin>>name1>>tmp>>tmp>>order>>tmp>>name2;\n            name2=name2.substr(0,name2.size()-1);\n            int n1idx=id[name1];\n            int n2idx=id[name2];\n            bool match=false;\n            if(order==\"child\")\n                match=isChild(n1idx,n2idx);\n            else if(order==\"ancestor\")\n                match=isAncestor(n1idx,n2idx);\n            else if(order==\"sibling\"){\n                int cnode=backNode(n1idx,1);\n                for(int i = 0; i < G[cnode].size(); i++){\n                    int to=G[cnode][i];\n                    match=(nif[n1idx].depth==nif[to].depth&&to==n2idx);\n                }\n            }\n            else if(order==\"parent\")\n                match=isChild(n2idx,n1idx);\n            else\n                match=isAncestor(n2idx,n1idx);\n            if(match)\n                cout<<\"True\"<<endl;\n            else\n                cout<<\"False\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\n\nstruct Person {\n  string name;\n  Person *parent;\n};\n\nconst int MAXN = 1005;\nint N, M;\nmap<string, Person*> conv;\nPerson root, person[MAXN];\n\nvoid init() {\n  conv.clear();\n  root.name = \"root\";\n  root.parent = NULL;\n}\n\nbool child(Person *a, Person *b) { // a is child of b\n  return a->parent == b;\n}\n\nbool sibling(Person *a, Person *b) {\n  return a->parent == b->parent;\n}\n\nbool descendant(Person *a, Person *b) { // a is descendant of b\n  while(a != NULL) {\n    if(a->parent == b) return true;\n    a = a->parent;\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    cin.ignore();\n    init();\n    Person *cp = &root;\n    int depth = -1;\n    for(int i = 0; i < N; ++i) {\n      string line;\n      getline(cin, line);\n      int sp = 0;\n      for(int j = 0; j < line.size() && line[j] == ' '; ++j, ++sp);\n\n      Person &c = person[i];\n      c.name = line.substr(sp);\n      conv[c.name] = &person[i];\n\n      if(sp > depth) {\n        c.parent = cp;\n      } else {\n        for(int j = 0; j < depth-sp; ++j) {\n          cp = cp->parent;\n        }\n        c.parent = cp->parent;\n      }\n      cp = &c;\n      depth = sp;\n    }\n\n    while(M--) {\n      string x, y, type;\n      string dumy;\n      cin >> x >> dumy >> dumy >> type >> dumy >> y;\n      y = y.substr(0, y.size()-1);\n      bool output = false;\n      if(0) {\n      } else if(type == \"child\") {\n        output = child(conv[x], conv[y]);\n      } else if(type == \"parent\") {\n        output = child(conv[y], conv[x]);\n      } else if(type == \"sibling\") {\n        output = sibling(conv[x], conv[y]);\n      } else if(type == \"descendant\") {\n        output = descendant(conv[x], conv[y]);\n      } else if(type == \"ancestor\") {\n        output = descendant(conv[y], conv[x]);\n      }\n      cout << (output ? \"TRUE\" : \"FALSE\") << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct tree {\n\tstring name;\n\tint depth;\n\tvector<unique_ptr<tree>>childs;\n\ttree(const string _name,const int _depth) :name(_name),depth(_depth),childs() {\n\n\t}\n};\nunique_ptr<tree> maketree(vector<string>&sts, vector<int>&ns,int depth,int &a) {\n\tunique_ptr<tree> t(std::make_unique<tree>(sts[a],depth));\n\twhile (a+1!=sts.size()&&ns[a+1] > depth) {\n\t\ta++;\n\t\tt->childs.push_back(maketree(sts, ns, depth + 1, a));\n\t\t\n\t}\n\treturn t;\n}\n\nvector<string> split(const string &str, char delim) {\n\tvector<string> res;\n\tsize_t current = 0, found;\n\twhile ((found = str.find_first_of(delim, current)) != string::npos) {\n\t\tres.push_back(string(str, current, found - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str, current, str.size() - current));\n\treturn res;\n}\nint dfs(const unique_ptr<tree>&tp,int type,string a,string b,bool flag) {\n\t//a is parant of b\n\tif (type == 0) {\n\t\tif (a == tp->name) {\n\t\t\tfor (auto&& c : tp->childs) {\n\t\t\t\tif (c->name == b)return 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num=dfs(c, type, a, b,flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse if (type == 1) {\n\t\tif (flag) {\n\t\t\tif (tp->name == b)return 1;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tif (tp->name == a)flag = true;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\tif (flag)return 0;\n\t\t\telse return -1;\n\t\t}\n\t}\n\telse {\n\t\tint same = 0;\n\t\tfor (auto&&c : tp->childs) {\n\t\t\tif (c->name == a)same++;\n\t\t\tif (c->name == b)same++;\n\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\tif (num != -1)return num;\n\t\t}\n\t\tif (same == 2)return 1;\n\t\telse if (same == 1)return 0;\n\t\telse return -1;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tunique_ptr<tree> t;\n\t\t{\n\t\t\tvector<string>sts;\n\t\t\tvector<int>ns;\n\t\t\tstring st; getline(cin, st);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgetline(cin, st);\n\t\t\t\tint n = st.find_first_not_of(' ');\n\t\t\t\tsts.push_back(st.substr(n));\n\t\t\t\tns.push_back(n);\n\t\t\t}\n\n\t\t\tint a = 0;\n\t\t\tt = maketree(sts, ns, 0, a);\n\t\t}\n\t\t\n\t\twhile (M--) {\n\t\t\tstring st;\n\t\t\tgetline(cin, st);\n\t\t\tvector<string>sts(split(st, ' '));\n\t\t\tstring a = sts[0];\n\t\t\tstring b = sts[5].substr(0, sts[5].size() - 1);\n\t\t\tint ans;\n\t\t\tif (sts[3] == \"child\") {\n\t\t\t\tans = dfs(t, 0, b, a, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"ancestor\") {\n\t\t\t\tans = dfs(t,1, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"sibling\") {\n\t\t\t\tans = dfs(t, 2, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"parent\") {\n\t\t\t\tans = dfs(t, 0, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"descendant\") {\n\t\t\t\tans = dfs(t, 1, b, a, false);\n\t\t\t}\n\t\t\tif (ans == 1)cout << \"True\" << endl;\n\t\t\telse if (ans == 0)cout << \"False\" << endl;\n\t\t\telse assert(false);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, string> P;\n\nmap<string, P> fam;\n\nvector<string> s;\nvector<string> name;\nint N, Q;\n\nvoid output(){\n  string op;\n  for(int i = 0 ; i < Q ; i++){\n    string relation, X, Y;\n    for(int j = 0 ; j < 6 ; j++){\n      cin >> op;\n      if(j == 0) X = op;\n      if(j == 3) relation = op;\n      if(j == 5) Y = op;\n    }\n    Y.erase(Y.end()-1);\n    \n    if(relation == \"parent\"){\n      relation = \"child\";\n      swap(X, Y);\n    }\n    if(relation == \"descendant\"){\n      relation = \"ancestor\";\n      swap(X, Y);\n    }\n    \n    bool ans = false;\n    \n    if(relation == \"child\"){\n      ans = fam[X].second == Y;\n    }\n    else if(relation == \"ancestor\"){\n      while(fam[Y].first != 0){\n\tif(fam[Y].second == X){\n\t  ans = true;\n\t  break;\n\t}\n\tY = fam[Y].second;\n      }\n    }\n    else if(relation == \"sibling\"){\n      int gen = fam[Y].first;\n      string par = fam[Y].second;\n      for(map<string, P>::iterator it = fam.begin() ; it != fam.end() ; it++){\n\tif(it->first == X){\n\t  if(it->second.first == gen && it->second.second == par){\n\t    ans = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    if(ans) cout << \"True\" << endl;\n    else cout << \"False\" << endl;\n  }\n}\n\nint main(){\n  while(cin >> N >> Q, N|Q){\n    fam.clear();\n    s.clear();\n    name.clear();\n    cin.ignore();\n    string tmp;\n    for(int i = 0 ; i < N ; i++){\n      getline(cin, tmp);\n      s.push_back(tmp);\n    }\n    \n    name = s;\n    \n    for(int i = 0 ; i < N ; i++){\n      while(name[i][0] == ' ') name[i].erase(name[i].begin());\n    }\n    \n    for(int i = 0 ; i < N ; i++){\n      int gen = 0;\n      for(int j = 0 ; j < (int)s[i].size() ; j++){\n\tif(s[i][j] != ' ') break;\n\tgen++;\n      }\n      for(int j = i ; j >= 0 ; j--){\n\tif(s[j][gen-1] != ' '){\n\t  fam[ name[i] ] = P(gen, name[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    output();\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "6 5\nJohn\n Robert\n  Frank\n  Andrew\n Nancy\n  David\nRobert is a child of John.\nRobert is an ancestor of Andrew.\nRobert is a sibling of Nancy.\nNancy is the parent of Frank.\nJohn is a descendant of Andrew.\n2 1\nabc\n xyz\nxyz is a child of abc.\n0 0"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct tree {\n\tstring name;\n\tint depth;\n\tvector<unique_ptr<tree>>childs;\n\ttree(const string _name,const int _depth) :name(_name),depth(_depth),childs() {\n\n\t}\n};\nunique_ptr<tree> maketree(vector<string>&sts, vector<int>&ns,int depth,int &a) {\n\tunique_ptr<tree> t(make_unique<tree>(sts[a],depth));\n\twhile (a+1!=sts.size()&&ns[a+1] > depth) {\n\t\ta++;\n\t\tt->childs.push_back(maketree(sts, ns, depth + 1, a));\n\t\t\n\t}\n\treturn t;\n}\n\nvector<string> split(const string &str, char delim) {\n\tvector<string> res;\n\tsize_t current = 0, found;\n\twhile ((found = str.find_first_of(delim, current)) != string::npos) {\n\t\tres.push_back(string(str, current, found - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str, current, str.size() - current));\n\treturn res;\n}\nint dfs(const unique_ptr<tree>&tp,int type,string a,string b,bool flag) {\n\t//a is parant of b\n\tif (type == 0) {\n\t\tif (a == tp->name) {\n\t\t\tfor (auto&& c : tp->childs) {\n\t\t\t\tif (c->name == b)return 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num=dfs(c, type, a, b,flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse if (type == 1) {\n\t\tif (flag) {\n\t\t\tif (tp->name == b)return 1;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tif (tp->name == a)flag = true;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\tif (flag)return 0;\n\t\t\telse return -1;\n\t\t}\n\t}\n\telse {\n\t\tint same = 0;\n\t\tfor (auto&&c : tp->childs) {\n\t\t\tif (c->name == a)same++;\n\t\t\tif (c->name == b)same++;\n\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\tif (num != -1)return num;\n\t\t}\n\t\tif (same == 2)return 1;\n\t\telse if (same == 1)return 0;\n\t\telse return -1;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tunique_ptr<tree> t;\n\t\t{\n\t\t\tvector<string>sts;\n\t\t\tvector<int>ns;\n\t\t\tstring st; getline(cin, st);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgetline(cin, st);\n\t\t\t\tint n = st.find_first_not_of(' ');\n\t\t\t\tsts.push_back(st.substr(n));\n\t\t\t\tns.push_back(n);\n\t\t\t}\n\n\t\t\tint a = 0;\n\t\t\tt = maketree(sts, ns, 0, a);\n\t\t}\n\t\t\n\t\twhile (M--) {\n\t\t\tstring st;\n\t\t\tgetline(cin, st);\n\t\t\tvector<string>sts(split(st, ' '));\n\t\t\tstring a = sts[0];\n\t\t\tstring b = sts[5].substr(0, sts[5].size() - 1);\n\t\t\tint ans;\n\t\t\tif (sts[3] == \"child\") {\n\t\t\t\tans = dfs(t, 0, b, a, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"ancestor\") {\n\t\t\t\tans = dfs(t,1, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"sibling\") {\n\t\t\t\tans = dfs(t, 2, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"parent\") {\n\t\t\t\tans = dfs(t, 0, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"descendant\") {\n\t\t\t\tans = dfs(t, 1, b, a, false);\n\t\t\t}\n\t\t\tif (ans == 1)cout << \"True\" << endl;\n\t\t\telse if (ans == 0)cout << \"False\" << endl;\n\t\t\telse assert(false);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool lint( string line ) {\n    if ( line[line.size()-1] != '.' ) return false;\n    istringstream is( line );\n    string tmp[6];\n    int cnt = 0;\n    while ( is >> tmp[cnt] ) {\n        cnt++;\n    }\n    if ( cnt != 6 ) return false;\n    string c;\n    for ( int i = 1; i < 5; i++ ) {\n        c += tmp[i];\n    }\n    if ( c == \"isachildof\" || c == \"istheparentof\" || c == \"isasiblingof\"\n        || c == \"isadescendantof\" || c == \"isanancestorof\" ) {\n        return true;\n    }\n    return false;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n/*\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n*/\n        // child\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j]-1 ) {\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] >= D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // sibling\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // descendant\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( A == B ) {\n                flag = false;\n            }\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            if ( !lint( line ) ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nint oldest,youngest;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n  oldest = min(oldest,space_cnt);\n  youngest = max(youngest,space_cnt);\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      \n      ope.push_back(mid);\n      \n    }\n\n skip:\n\n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i] == \"child\" || ope[i] == \"parent\" || ope[i] == \"sibling\" || ope[i] == \"descendant\" || ope[i] == \"ancestor\")\n\t{\n\t  info.push_back(ope[i]);\n\t  break;\n\t}\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n\n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || min(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(Yindex+1 >= vec.size() || vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      for(int i=Yindex+1;i<vec.size() && vec[i].S > vec[Yindex].S;i++)\n\t{\n\t  if(vec[i].F == vec[Xindex].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(Xindex+1 >= vec.size()  || vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      for(int i=Xindex+1;i < vec.size() && vec[i].S > vec[Xindex].S;i++)\n\t{\n\t  if(vec[i].F == vec[Yindex].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      //cerr << n << \" \" << m << endl;\n      if(!(n+m))\n\tbreak;\n      oldest = (1<<28);\n      youngest = -1;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  //cerr << line << endl;\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  //cerr << line << endl;\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstring>\n\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Node{\n\tchar name[32];\n\tNode *parent;\n\tvector<Node *> child;\n};\n\nbool isChild(Node *u,Node *v){\n\trep(i,v->child.size()) if(v->child[i]==u) return true;\n\treturn false;\n}\n\nbool isSibling(Node *u,Node *v){\n\treturn u!=v && u->parent==v->parent;\n}\n\nbool isDescendant(Node *u,Node *v){\n\tfor(;u->parent;u=u->parent) if(u->parent==v) return true;\n\treturn false;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tgetchar();\n\n\t\tNode root; root.parent=NULL;\n\t\tNode *target=&root;\n\t\tint sp_prev=-1;\n\t\tmap<string,Node *> f;\n\t\trep(i,n){\n\t\t\tchar s[256];\n\t\t\tfgets(s,256,stdin);\n\t\t\tint len=strlen(s);\n\t\t\ts[--len]='\\0';\n\n\t\t\tint sp=0;\n\t\t\trep(j,len) if(s[j]!=' ') {\n\t\t\t\tsp=j; break;\n\t\t\t}\n\n\t\t\tNode *u=new Node;\n\t\t\tstrcpy(u->name,s+sp);\n\t\t\tf[s+sp]=u;\n\t\t\tif(sp==sp_prev+1){\n\t\t\t\ttarget->child.pb(u);\n\t\t\t\tu->parent=target;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint back=sp_prev-sp;\n\t\t\t\trep(j,back) target=target->parent;\n\n\t\t\t\ttarget->parent->child.pb(u);\n\t\t\t\tu->parent=target->parent;\n\t\t\t}\n\n\t\t\tsp_prev=sp;\n\t\t\ttarget=u;\n\t\t}\n\n\t\trep(i,m){\n\t\t\tchar x[32],y[32],rel[32];\n\t\t\tscanf(\"%s is %*s %s of %s\",x,rel,y);\n\t\t\ty[strlen(y)-1]='\\0';\n\n\t\t\tbool res;\n\t\t\tif     (strcmp(rel,\"child\"     )==0) res=isChild(f[x],f[y]);\n\t\t\telse if(strcmp(rel,\"parent\"    )==0) res=isChild(f[y],f[x]);\n\t\t\telse if(strcmp(rel,\"sibling\"   )==0) res=isSibling(f[x],f[y]);\n\t\t\telse if(strcmp(rel,\"descendant\")==0) res=isDescendant(f[x],f[y]);\n\t\t\telse /*(strcmp(rel,\"ancestor\")==0)*/ res=isDescendant(f[y],f[x]);\n\t\t\tputs(res?\"True\":\"False\");\n\t\t}\n\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 1010;\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ') cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nbool isParent(int x, int y, vector<int> parent){\n    if(parent[y] == x) return true;\n    else return false;\n}\n\nbool checkQ(string str, map<string, int> list_i, vector<int> parent){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    int x = list_i[vec[0]];\n    int y = list_i[vec[5].erase(vec[5].size() - 1)];\n\n    if(vec[3] == \"child\") return isParent(y, x, parent);\n    if(vec[3] == \"parent\") return isParent(x, y, parent);\n    if(vec[3] == \"sibling\") return parent[x] == parent[y];\n    if(vec[3] == \"descendant\"){\n        int now_x = x;\n        while(parent[now_x] != -1){\n            if(isParent(y, now_x, parent) == true) return true;\n            now_x = parent[now_x];\n        }\n        return false;\n    }\n    if(vec[3] == \"ancestor\"){\n        int now_y = y;\n        while(parent[now_y] != -1){\n            if(isParent(x, now_y, parent) == true) return true;\n            now_y = parent[now_y];\n        }\n        return false;\n    }\n}\n\n\n\nint main(){\n    while(true){\n        string str_m_n;\n        getline(cin, str_m_n);\n        stringstream ss(str_m_n);\n        int m, n;\n        ss >>m >>n;\n        if(!m && !n) break;\n\n        vector<int> parent(m);\n        int current_parent_i[MAX_M];\n        map<string, int> list_i;\n\n        parent[0] = -1;\n\n        REP(i, m){\n            string name_line;\n            getline(cin, name_line);\n            stringstream ss(name_line);\n            P rank_and_name = cntSpace(name_line);\n            current_parent_i[rank_and_name.first + 1] = i;\n            list_i[rank_and_name.second] = i;\n            if(i != 0){\n                int now_parent = current_parent_i[rank_and_name.first];\n                parent[i] = now_parent;\n            }\n        }\n\n        REP(i, n){\n            string q;\n            getline(cin, q);\n            bool ans = checkQ(q, list_i, parent);\n            if(ans) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\n#define Pint pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 1010;\n\nstring human[MAX_M][MAX_M];\nmap<string, Pint > human_map;\n\nbool tmpCheck(int y, int x){\n    if(y >= MAX_M) return false;\n    if(x >= MAX_M) return false;\n    return true;\n}\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ') cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nbool checkChild(string x, string y){\n    int now_y = human_map[y].first + 1, now_x = human_map[y].second + 1;\n    bool ret = false;\n    while(human[now_y][now_x] != \"\"){\n        if(human[now_y][now_x] == x) ret = true;\n        now_y++;\n        if(!tmpCheck(now_y, now_x)) break;\n    }\n    return ret;\n}\n\nbool checkParent(string x, string y){\n    int now_y = human_map[y].first - 1, now_x = human_map[y].second - 1;\n    while(human[now_y][now_x] == \"\"){\n        now_y++;\n        if(!tmpCheck(now_y, now_x)) break;\n    }\n    bool ret = (human[now_y][now_x] == x)? true : false;\n    return ret;\n}\n\nbool checkSibling(string x, string y){\n    int now_y = human_map[y].first, now_x = human_map[y].second;\n    int m = 1;\n    bool ret = false;\n    while(human[now_y + m][now_x] != \"\"){\n        if(human[now_y + m][now_x] == x) ret = true;\n        m++;\n        if(!tmpCheck(now_y + m, now_x)) break;\n    }\n    m = 1;\n    now_y = human_map[y].first;\n    m = 1;\n    while(human[now_y - m][now_x] != \"\"){\n        if(human[now_y - m][now_x] == x) ret = true;\n        m++;\n        if(!tmpCheck(now_y - m, now_x)) break;\n    }\n    return ret;\n}\n\nbool checkDescendant(string x, string y){\n    bool ret = false;\n    REP(i, human_map[x].first){\n        REP(j, human_map[x].second){\n            if(human[i][j] == y) ret = true;\n            if(!tmpCheck(i, j)) break;\n        }\n    }\n    return ret;\n}\n\nbool checkAncestor(string x, string y){\n    bool ret = false;\n    FOR(i, human_map[x].first + 1, MAX_M){\n        FOR(j, human_map[x].second + 1, MAX_M){\n            if(human[i][j] == y) ret = true;\n            if(!tmpCheck(i, j)) break;\n        }\n    }\n    return ret;\n}\n\nbool checkQ(string str){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    string y = vec[5].erase(vec[5].size() - 1);\n    if(vec[3] == \"child\") return checkChild(vec[0], y);\n    if(vec[3] == \"parent\") return checkParent(vec[0], y);\n    if(vec[3] == \"sibling\") return checkSibling(vec[0], y);\n    if(vec[3] == \"descendant\") return checkDescendant(vec[0], y);\n    if(vec[3] == \"ancestor\") return checkAncestor(vec[0], y);\n}\n\nint main(){\n    while(true){\n        int m, n;\n        string st;\n        getline(cin, st);\n        stringstream ss(st);\n        ss >>m >>n;\n        if(!n && !m) break;\n\n        REP(i, MAX_M) REP(j, MAX_M) human[i][j] = \"\";\n        human_map.clear();\n\n        REP(i, m){\n            string str;\n            getline(cin, str);\n            P tmp = cntSpace(str);\n            human[i][tmp.first] = tmp.second;\n            human_map[tmp.second] = Pint(i, tmp.first);\n        }\n\n        REP(i, n){\n            string str;\n            getline(cin, str);\n            if(checkQ(str) == true) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\ntemplate<typename T,typename U>\nll FindErase(T &v,U tar){\n  ll cnt = 0;\n  for(auto it = v.begin(); it != v.end();){\n    if(*it == tar){\n      it = v.erase(it);\n      ++cnt;\n    }\n    else{\n      ++it;\n    }\n  }\n  return cnt;\n}\n\ntemplate<typename T>\nbool SuffixErase(T &v,size_t suf){\n  if(suf > v.size()) return false;\n  for(auto it = v.begin(); it != v.end();){\n    if(distance(v.begin(),it) == suf){\n      v.erase(it);\n      return true;\n    }\n    else{\n      ++it;\n    }\n  }\n  return false;\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nstruct Data{\n  string s;\n  int id;\n  int par;\n};\n\nvector<Data> d(1001);\nint tar;\nbool dfs(int k){\n  if(k == tar) return true;\n  if(k == 0) return false;\n  return dfs(d[k].par);\n}\nvoid Out(bool f){\n  if(f) cout << \"True\" << endl;\n  else cout << \"False\" << endl;\n}\nint main(){\n  string s;\n  int a,b;\n  while(cin >> a >> b && a + b){\n    cin.ignore();\n    d = vector<Data>(1001);\n    int tk = 1;\n    int par[1000] = {};\n    map<string,int> m;\n    rep(i,a){\n      getline(cin,s);\n      auto k = FindErase(s,' ')+1;\n      m[s] = i;\n      d[i] = {s,i};\n      if(tk == k){\n        d[i].par = par[k-1];\n        par[k] = i;\n      }\n      else if(tk < k){\n        d[i].par = par[tk];\n        par[k] = i;\n      }\n      else{\n        d[i].par = par[k-1];\n        par[k] = i;\n      }\n      tk = k;\n    }\n    string s2,s3,tmp;\n    rep(i,b){\n      cin >> s >> tmp >> tmp >> s2 >> tmp >> s3;\n      s3.resize(s3.size()-1);\n      if(s2 == \"child\"){\n        Out(d[m[s]].par == m[s3]);\n      }\n      else if(s2 == \"parent\"){\n        Out(d[m[s3]].par == m[s]);\n      }\n      else if(s2 == \"sibling\"){\n        Out(d[m[s]].par == d[m[s3]].par);\n      }\n      else if(s2 == \"ancestor\"){\n        tar = m[s];\n        Out(dfs(m[s3]));\n      }\n      else if(s2 == \"descendant\"){\n        tar = m[s3];\n        Out(dfs(m[s]));\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n        set <string> S;\n        for ( int i = 0; i < n; i++ ) {\n            int L = i+1;\n            while ( L < n ) {\n                if ( D[i] == D[L] ) break;\n                L++;\n            }\n            for ( int j = i+1; j < L; j++ ) {\n                if ( D[i] + 1 == D[j] ) {\n                    // i is j's child\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] - 1 == D[j] ) {\n                    // i is j's parent\n                    T[i][j] |= 1<<1;\n                    T[j][i] |= 1<<2;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    // sibling\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] - 1 <= D[j] ) {\n                    // i is j's ancestor\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else if ( D[i] + 1 >= D[j] ) {\n                    // i is j's descendant\n                    T[i][j] |= 1<<5;\n                    T[j][i] |= 1<<4;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n/*\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n*/\n        // child\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j]-1 ) {\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // sibling\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // descendant\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <string>\nusing namespace std;\n#define L(x) (1 << (x))\ntypedef long long ll;\n\nconst int Maxn = 1010;\nstruct Per\n{\n\tstring name;\n\tint deep;\n\tint fa;\n\tvoid out()\n\t{\n\t\tcout << name <<\" \" << deep <<\" \" << fa << endl;\n\t}\n}per[Maxn];\nint n, m;\nchar str[Maxn + 100];\nmap<string, int>mp;\npair<int, string> fenjie(char str[])\n{\n\tint ret1 = 0;\n\tfor (ret1 = 0; str[ret1] == ' '; ++ret1);\n\tstring ret2= \"\";\n\tfor (int i = ret1; str[i]; ++i)\n\t\tret2 += str[i];\n\treturn make_pair(ret1, ret2);\n}\nint id[Maxn];\nbool isChild(string a, string b)\n{\n\tint k1 = mp[a], k2 = mp[b];\n\treturn per[k1].fa == k2;\n}\nbool isAncestor(string a, string b)\n{\n//cout << a <<\" \" << b << endl;\n\tint k1 = mp[a], k2 = mp[b];\n\t//cout <<k1 <<\" \" << k2 << endl;\n\twhile (k2 != -1 && per[k2].deep >= per[k1].deep)\n\t{\n\t\n\t\tif (k1 == k2) return true;\n\t\tk2 = per[k2].fa;\n\t}\n\treturn false;\n}\nbool isSibling(string a, string b)\n{\n\tint k1 = mp[a], k2 = mp[b];\n\treturn per[k1].fa == per[k2].fa;\n}\nbool isParent(string a, string b)\n{\n\tint k1 = mp[a], k2 = mp[b];\n\treturn per[k2].fa == k1;\n}\nbool isDescendant(string a, string b)\n{\n\treturn isAncestor(b, a);\n}\n\nint main()\n{\n\twhile (scanf(\"%d%d\", &n, &m) != EOF)\n\t{\n\t\tif (n == 0 && m == 0) break;\n\t\tgets(str);\n\t\tmp.clear();\n\t\t\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tgets(str);\n\t\t\tpair<int, string> res = fenjie(str);\n\t\t\tif (res.first == 0) \n\t\t\t\tper[i].fa = -1;\n\t\t\telse per[i].fa = id[res.first - 1];\n\t\t\tid[res.first] = i;\n\t\t\tmp[res.second] = i;\n\t\t\tper[i].name = res.second;\n\t\t\tper[i].deep = res.first;\n\t\t//\tper[i].out();\n\t\t}\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tchar a[100], re[100], b[100];\n\t\t\tscanf(\"%s%*s%*s%s%*s%s\", a, re, b);\n\t\t\tb[strlen(b) - 1] = 0;\n\t\t\tbool ret;\n\t\t\tif (strcmp(re, \"child\") == 0)\n\t\t\t\tret = isChild(a, b);\n\t\t\telse if(strcmp(re, \"ancestor\") == 0)\n\t\t\t\tret = isAncestor(a, b);\n\t\t\telse if(strcmp(re, \"sibling\") == 0)\n\t\t\t\tret = isSibling(a, b);\n\t\t\telse if (strcmp(re, \"parent\") == 0)\n\t\t\t\tret = isParent(a, b);\n\t\t\telse if (strcmp(re, \"descendant\") == 0)\n\t\t\t\tret = isDescendant(a, b);\n\t\t\telse assert(0);\n\t\t\tputs(ret ? \"True\" : \"False\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nstruct Q {\n    string Relation, Name1, Name2;\n    Q(const string& Relation, const string& Name1, const string& Name2) \n        : Relation(Relation), Name1(Name1), Name2(Name2) {}\n};\nostream& operator<<(ostream& os, const Q& q) {\n    os << \"(\" << q.Relation << \", \" << q.Name1 << \", \" << q.Name2 << \")\";\n    return os;\n}\n\nint N, M;\nvector<int> Parent;\nvector<Q> Queries;\nmap<string, int> Id;\nvector<int> Prev;\n\nint CountPrefixSpaces(const string& s) {\n    int i;\n    for (i = 0; i < s.size() && s[i] == ' '; i++) ;\n    return i;\n}\n\nbool input() {\n    string l;\n    getline(cin, l);\n    istringstream is; is.str(l);\n    is >> N >> M;\n    is.clear();\n    if (N == 0 && M == 0) return false;\n    Parent.resize(N, -1);\n    Queries.clear();\n    Id.clear();\n    Prev.resize(N, -1);\n    for (int i = 0; i < N; i++) {\n        getline(cin, l);\n        is.str(l);\n        string Name;\n        is >> Name;\n        is.clear();\n        Id[Name] = i;\n        int C = CountPrefixSpaces(l);\n        Prev[C] = i;\n        if (C != 0) {\n            Parent[i] = Prev[C - 1];\n        }\n    }\n    for (int i = 0; i < M; i++) {\n        getline(cin, l);\n        is.str(l);\n        string Name1, Relation, Name2;\n        string _;\n        is >> Name1;\n        for (int k = 0; k < 2; k++) is >> _;\n        is >> Relation;\n        is >> _;\n        is >> Name2;\n        Name2 = Name2.substr(0, Name2.size() - 1);\n        is.clear();\n        Queries.push_back(Q(Relation, Name1, Name2));\n    }\n    return true;\n}\n\nvoid solve() {\n    for (int i = 0; i < M; i++) {\n        string& Relation = Queries[i].Relation,\n                Name1 = Queries[i].Name1,\n                Name2 = Queries[i].Name2;\n        int x = Id[Name1], y = Id[Name2];\n        if (Relation == \"child\") {\n            cout << (y == Parent[x] ? \"True\" : \"False\") << endl;\n        } else if (Relation == \"parent\") {\n            cout << (x == Parent[y] ? \"True\" : \"False\") << endl;\n        } else if (Relation == \"sibling\") {\n            cout << (Parent[x] == Parent[y] ? \"True\" : \"False\") << endl;\n        } else if (Relation == \"descendant\") {\n            while (x >= 0) {\n                if (y == x) {\n                    cout << \"True\" << endl;\n                    goto fin1;\n                }\n                x = Parent[x];\n            }\n            cout << \"False\" << endl;\n            fin1:;\n        } else if (Relation == \"ancestor\") {\n            while (y >= 0) {\n                if (y == x) {\n                    cout << \"True\" << endl;\n                    goto fin2;\n                }\n                y = Parent[y];\n            }\n            fin2:;\n        } else {\n            assert(0);\n        }\n    }\n    cout << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\n\n//char c[1005][100];\n\nchar s[200];\nmap<string,int>name;\nvector<int>ve[200];\nvector<int>ren[2005];\nmap<string,int>gx;\n\nint main ()\n{\n    int k=1;\n    int n,m;\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        if(n==0&&m==0)\n        {\n            break;\n        }\n        getchar ();\n        gx.insert(make_pair(string(\"child\"),1));\n        gx.insert(make_pair(string(\"parent\"),2));\n        gx.insert(make_pair(string(\"sibling\"),3));\n        gx.insert(make_pair(string(\"descendant\"),4));\n        gx.insert(make_pair(string(\"ancestor\"),5));\n\n\n\n\n\n        name.clear();\n        for(int i=0; i<105; i++)\n        {\n            ve[i].clear();\n        }\n        for(int i=0; i<=1500; i++)\n        {\n            ren[i].clear();\n        }\n        for(int i=0; i<n; i++)\n        {\n            int p=0;\n            gets(s);\n            while(s[p]==' ')p++;\n            name.insert(make_pair(string(&s[p]),i));\n\n            ve[p].push_back(i);\n\n            for(int j=0; j<=p; j++)\n            {\n                if(ve[j].size()-1 >=0)\n                ren[i].push_back(ve[j][ ve[j].size()-1 ]);\n            }\n        }\n//        for(int i=0; i<3; i++)\n//        {\n//            for(int j=0; j<ve[i].size(); j++)\n//            {\n//                printf(\"%d \",ve[i][j]);\n//            }\n//            printf(\"\\n\");\n//        }\n//        printf(\"\\n\");\n//        for(int i=0; i<6; i++)\n//        {\n//            for(int j=0; j<ren[i].size(); j++)\n//            {\n//                printf(\"%d \",ren[i][j]);\n//\n//            }\n//            printf(\"\\n\");\n//        }\n//        printf(\"\\n\");\n//        printf(\"%d****\\n \",m);\n        if(k!=1)printf(\"\\n\");\n        k++;\n        for(int p=0; p<m; p++)\n        {\n            scanf(\"%s\",s);\n            string name1(s);\n            scanf(\"%*s\");\n            scanf(\"%*s\");\n            scanf(\"%s\",s);\n            string name2(s);\n            scanf(\"%*s\");\n            scanf(\"%s\",s);\n            getchar();\n\n            s[strlen(s)-1]=0;\n            string name3(s);\n            int t1,t2,t3;\n            t1=name[name1];\n            t2=gx[name2];//1 2 3 4 5\n            t3=name[name3];\n//            printf(\"%d %d %d\\n\",t1,t2,t3);\n\n\n\n\n            bool boo=false;\n            if(t2==1)\n            {\n                if(ren[t1].size()-2>=0)\n                    if(ren[t1][ren[t1].size()-2]==t3)\n                    {\n                        boo=true;\n                    }\n            }\n            else if(t2==2)\n            {\n                if(ren[t3].size()-2>=0)\n                    if(ren[t3][ren[t3].size()-2]==t1)\n                    {\n                        boo=true;\n                    }\n            }\n            else if(t2==3)\n            {\n                if(ren[t1].size()==ren[t3].size())\n                {\n                    boo=true;\n                }\n            }\n            else if(t2==4)\n            {\n                if(ren[t1].size()>ren[t3].size())\n                {\n                    boo=true;\n                }\n            }\n            else if(t2==5)\n            {\n                if(ren[t1].size()<ren[t3].size())\n                {\n                    boo=true;\n                }\n            }\n\n\n            if(boo==false)\n                printf(\"False\\n\");\n            else\n                printf(\"True\\n\");\n        }\n\n    }\n}\n/*\n6 5\nJohn\n Robert\n  Frank\n  Andrew\n Nancy\n  David\nRobert is a child of John.\nRobert is an ancestor of Andrew.\nRobert is a sibling of Nancy.\nNancy is the parent of Frank.\nJohn is a descendant of Andrew.\n2 1\nabc\n xyz\nxyz is a child of abc.\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n/*\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n*/\n        // child\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j]-1 ) {\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // sibling\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // descendant\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] <= D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      if(level_tree.find(mid) != level_tree.end())\n\tinfo.push_back(mid);\n      else if(mid == \"child\" || mid == \"parent\" || mid == \"sibling\" || mid == \"descendant\" || mid == \"ancestor\")\n\tinfo.pb(mid);\n    }\n\n skip:\n\n  \n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n      //cout << \"Xindex = \" << Xindex << \" Yindex = \" << Yindex << endl;\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\t  //cout << \"vec : \" << vec[i].F << endl;\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || max(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      if(!(n+m))\n\tbreak;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\ntypedef pair<int,string> P;\n\n// family tree\nstruct Node{\n  vector<Node*> child;\n  Node* parent;\n  string name;\n  Node():name(\"\"){}\n  Node(vector<Node*> c, Node* p, string s):child(c),parent(p),name(s){}\n\n  void init(){\n    for(int i = 0; i < (int)child.size(); i++)\n      child[i]->init();\n    child.clear();\n  }\n\n  bool isSibling(const string& A, const string& B){\n    return find(A)->parent==find(B)->parent;\n  }\n\n  bool isChild(const string& A){\n    for(int i = 0; i < (int)child.size(); i++)\n      if(child[i]->name == A) return true;\n    return false;\n  }\n\n  bool isDecendant(const string& A){\n    for(int i = 0; i < (int)child.size(); i++)\n      if(child[i]->name == A) return true;\n    \n    bool res = false;\n    for(int i = 0; i < (int)child.size(); i++)\n      res = res||child[i]->isDecendant(A);\n    return res;\n  }\n\n  Node* find(const string& name){\n    for(int i = 0; i < (int)child.size(); i++)\n      if(child[i]->name == name) return child[i];\n\n    for(int i = 0; i < (int)child.size(); i++){\n      Node* tmp = child[i]->find(name);\n      if(tmp != NULL) return tmp;\n    }\n    return NULL;\n  }\n};\n\nint N,M;\nNode* top = new Node(vector<Node*>(), top, \"\");\n\nP devide(const string& s){\n  int blank = 0;\n  for(int i = 0; i < (int)s.length(); i++) if(s[i] == ' ') blank++;\n  return P(blank,s.substr(blank));\n}\n\nvoid input(){\n  cin.ignore();\n  \n  Node* now = top;\n  int depth = -1;\n\n  for(int i = 0; i < N; i++){\n    string s;\n    getline(cin,s);\n    P p = devide(s);\n    \n    if(p.first == depth){\n      Node* nex = new Node(vector<Node*>(), now->parent, p.second);\n      ((now->parent)->child).push_back(nex);\n      now = nex;\n    }\n\n    if(p.first < depth){\n      // go up\n      int diff = depth-p.first+1;\n      for(int i = 0; i < diff; i++) now = now->parent;\n      Node* nex = new Node(vector<Node*>(), now, p.second);\n      now->child.push_back(nex);\n      now = nex;\n      depth = p.first;\n    }\n    \n    if(p.first > depth){\n      // go down\n      Node* nex = new Node(vector<Node*>(), now, p.second);\n      now->child.push_back(nex);\n      now = nex;\n      depth = p.first;\n    }\n  }\n}\n\nvoid solve(){\n\n  for(int i = 0; i < M; i++){\n    string X,Y,Q,trash;\n    cin >> X >> trash >> trash >> Q >> trash >> Y;\n    bool ans = false;\n    Y = Y.substr(0,Y.length()-1);\n\n    if(Q[0]=='c') ans = (top->find(Y))->isChild(X);\n    if(Q[0]=='p') ans = (top->find(X))->isChild(Y);\n    if(Q[0]=='s') ans = top->isSibling(X,Y);\n    if(Q[0]=='d') ans = (top->find(Y))->isDecendant(X);\n    if(Q[0]=='a') ans = (top->find(X))->isDecendant(Y);\n    \n    cout << (ans?\"True\":\"False\") << endl;\n  }\n  cout << endl;\n}\n\nint main(){\n  \n  while(cin >> N >> M && N+M){\n    top->init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        ID.clear();\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n        // child\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j]-1 ) {\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] >= D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // sibling\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // descendant\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( A == B ) {\n                flag = false;\n            }\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUGLOCAL\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint parent[1111];\nint rank[1111];\nmap<string, int> name;\n\nint main() {\n\tint n,m;\n\tIL{\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0)break;\n\t\tname.clear();\n\t\tstring nm;\n\t\tgetline(cin,nm);\n\t\trep(i,n){\n\t\t\tgetline(cin,nm);\n\t\t\trep(j,sz(nm)){\n\t\t\t\tif(nm[j]!=' '){\n\t\t\t\t\trank[i]=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnm=nm.substr(rank[i],sz(nm)-rank[i]);\n\t\t\tif(rank[i]==0)parent[i]=-1;\n\t\t\telse{\n\t\t\t\trepd(j,i){\n\t\t\t\t\tif(rank[j]==rank[i]-1){\n\t\t\t\t\t\tparent[i]=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tname[nm]=i;\n\t\t}\n\t\trep(i,m){\n\t\t\tbool res=false;\n\t\t\tstring aa,b,c,d,e,ff;\n\t\t\tcin>>aa>>b>>c>>d>>e>>ff;\n\t\t\tff=ff.substr(0,sz(ff)-1);\n\t\t\tint a=name[aa],f=name[ff];\n\t\t\tif(d==\"child\"){\n\t\t\t\tres=parent[a]==f;\n\t\t\t}\n\t\t\tif(d==\"parent\"){\n\t\t\t\tres=parent[f]==a;\n\t\t\t}\n\t\t\tif(d==\"sibling\"){\n\t\t\t\tres=parent[a]==parent[f];\n\t\t\t}\n\t\t\tif(d==\"descendant\"){\n\t\t\t\twhile(parent[a]>-1){\n\t\t\t\t\ta=parent[a];\n\t\t\t\t\tif(a==f)res=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d==\"ancestor\"){\n\t\t\t\twhile(parent[f]>-1){\n\t\t\t\t\tf=parent[f];\n\t\t\t\t\tif(a==f)res=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<(res?\"True\":\"False\")<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nint par[1001];\nint curr[1001];\n\nvoid init(){\n\tfor(int i=0;i<=1000;i++){\n\t\tpar[i] = i;\n\t\tcurr[i] = -1;\n\t}\n}\n\nbool isSat(string question,map<int,string>& name,map<string,int>& num){\n\tstring str;\n\tstringstream ss(question);\n\tvector<string> v;\n\twhile(ss >> str){\n\t\tv.push_back(str);\n\t}\n\n\tstring X = v[0];\n\tstring Y = v[5].substr(0,v[5].size()-1);\n\n\t//X is a child of Y.\n\t//X is the parent of Y.\n\t//X is a sibling of Y.\n\t//X is a descendant of Y.\n\t//X is an ancestor of Y.\n\n\tif(v[3] == \"child\"){\n\t\treturn (par[num[X]] == num[Y] && num[Y] != -1);\n\t}\n\telse if(v[3] == \"parent\"){\n\t\treturn (par[num[Y]] == num[X] && num[X] != -1);\n\t}\n\telse if(v[3] == \"sibling\"){\n\t\treturn (par[num[Y]] == par[num[X]] && par[num[X]] != -1);\n\t}\n\telse if(v[3] == \"ancestor\"){\n\t\twhile(par[num[Y]] != -1){\n\t\t\tif(X == Y) return true;\n\t\t\tY = name[par[num[Y]]];\t\t\n\t\t}\n\t\treturn false;\n\t}\n\telse if(v[3] == \"descendant\"){\n\t\twhile(par[num[X]] != -1){\n\t\t\tX = name[par[num[X]]];\n\t\t\tif(X == Y) return true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nint main(){\n\tstring str;\n\tbool isOut = false;\n\n\twhile(getline(cin,str)){\n\t\tinit();\n\t\tstringstream ss(str);\n\t\tss >> str;\n\t\tint n = atoi(str.c_str());\n\t\tss >> str;\n\t\tint m = atoi(str.c_str());\n\n\n\t\tif(n==0 && m==0) break;\n\n\t\tmap<int,string> name;\n\t\tmap<string,int> num;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,str);\n\n\t\t\t\n\t\t\tint j=0;\n\t\t\twhile(str[j] == ' ') j++;\n\t\t\tname[i] = str.substr(j,str.size()-j);\n\t\t\tnum[str.substr(j,str.size()-j)] = i;\n\n\t\t\tif(j==0){\n\t\t\t\tpar[i] = -1;\n\t\t\t}\n\t\t\telse par[i] = curr[j-1];\n\t\t\t//cout << str << endl;\n\n\t\t\tcurr[j] = i;\n\t\t}\n\n\t\tif(isOut){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tgetline(cin,str);\n\t\t\tif(isSat(str,name,num)){\n\t\t\t\tprintf(\"True\\n\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"False\\n\");\n\t\t\t}\n\t\t}\n\n\t\tisOut = true;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n/*\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n*/\n        // child\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j]-1 ) {\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // sibling\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // descendant\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, m;\n\twhile(cin >> n >> m, n|m) {\n\t\tcin.ignore();\n\t\tvector<string> v(1000);\n\t\tmap<string, string> ma;\n\t\tREP(i, n) {\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\t\t\tint cnt = 0;\n\t\t\twhile(s[cnt] == ' ')\n\t\t\t\tcnt++;\n\t\t\ts = s.substr(cnt);\n\t\t\tif(!cnt)\n\t\t\t\tma[s] = \"\";\n\t\t\telse\n\t\t\t\tma[s] = v[cnt-1];\n\t\t\tv[cnt] = s;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tstring in1, in2, in3;\n\t\t\tcin >> in1;\n\t\t\tcin >> in2 >> in2 >> in2;\n\t\t\tcin >> in3 >> in3;\n\t\t\tin3.erase(in3.end() - 1);\n\t\t\tbool ans = false;\n\t\t\tif(in2 == \"child\" && ma[in1] == in3)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"parent\" && ma[in3] == in1)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"sibling\" && ma[in1] == ma[in3])\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"descendant\") {\n\t\t\t\tstring s = ma[in1];\n\t\t\t\twhile(s != \"\") {\n\t\t\t\t\tif(s == in3)\n\t\t\t\t\t\tans = true;\n\t\t\t\t\ts = ma[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(in2 == \"ancestor\") {\n\t\t\t\tstring s = ma[in3];\n\t\t\t\twhile(s != \"\") {\n\t\t\t\t\tif(s == in1)\n\t\t\t\t\t\tans = true;\n\t\t\t\t\ts = ma[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans)\n\t\t\t\tcout << \"true\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"False\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] + 1 == D[j] ) {\n                    // i is j's parent\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] - 1 == D[j] ) {\n                    // i is j's child\n                    T[i][j] |= 1<<1;\n                    T[j][i] |= 1<<2;\n                } else if ( D[i] >= D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    // sibling\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nbool search(const vector<set<int> > &g, int now, int dist){\n  if(dist == now) return true;\n  FOR(it,g[now]) if(search(g, *it, dist)) return true;\n  return false;\n}\n\n\nint main(){\n  int cc = 0;\n  while(true){\n    int n,m;\n    string buff;\n\n    getline(cin, buff);\n    sscanf(buff.c_str(), \"%d%d\", &n, &m);\n    if(n + m == 0) break;\n\n    if(cc++) cout << endl;\n\n    vector<set<int> > g(n);\n    vector<int> p(n);\n    map<string,int> name;\n\n    stack<int> st;\n\n    REP(i,n){\n      getline(cin, buff);\n      for(int j=0; ;j++){\n        if(buff[j] != ' '){\n\n          int next = name.size();\n          buff = buff.substr(j);\n          name[buff] = next;\n\n          while(j != st.size())\n            st.pop();\n\n          if(st.size()){\n            g[st.top()].insert(next);\n            p[next] = st.top();\n          }\n\n          st.push(next);\n          break;\n        }\n      }\n    }\n\n    REP(i,m){\n      string n1, b, a, r, o, n2;\n      getline(cin, buff);\n      stringstream ss(buff);\n      ss>>n1>>b>>a>>r>>o>>n2;\n\n      int aa = name[n1];\n      int bb = name[n2.substr(0, n2.size()-1)];\n\n      //cout << aa << \" \" <<r << \" \" << bb << \" \";\n\n      bool ans = false;\n      switch(r[0]){\n      case 'c':\n        if(g[bb].count(aa)) ans = true;\n        break;\n      case 'p':\n        if(g[aa].count(bb)) ans = true;\n        break;\n      case 's':\n        if(aa != 0 && g[p[aa]].count(bb)) ans = true;\n        break;\n      case 'd':\n        ans = search(g, bb, aa);\n        break;\n      case 'a':\n        ans = search(g, aa, bb);\n        break;\n      }\n      cout << (ans ? \"True\" : \"False\") << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<map>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nbool find_child(int my,vector<int> &child,int tar){\n  rep(i,child.size()){\n    if (  child[i]==tar)return true;\n  }\n  return false;\n}\n\nbool find_descendant(int my,vector<int> *edge,int tar){\n  if ( my == tar)return true;\n  rep(i,edge[my].size() ){\n    if ( find_descendant(edge[my][i],edge,tar) )return true;\n  }\n\n  return false;\n}\n\nvoid solve(int n,int q,map<string,int>&M,vector<int> *edge,vector<int> &p){\n  rep(i,q){\n    string a,b,c,d,e,f;\n    cin>>a>>b>>c>>d>>e>>f;\n    f.erase(f.size()-1);\n    int x = M[a],y=M[f];\n    bool flag=false;\n    if ( d == \"child\"){\n      flag=find_child(y,edge[y],x);\n    }else if ( d == \"parent\"){\n      flag=find_child(x,edge[x],y);\n    }else if (d == \"sibling\"){\n      flag = find_child(p[x],edge[p[x]],y);\n    }else if ( d == \"descendant\"){\n      flag = find_descendant(y,edge,x);\n    }else if ( d == \"ancestor\"){\n      flag = find_descendant(x,edge,y);\n    }\n    if ( flag)puts(\"True\");\n    else puts(\"False\");\n  }\n  puts(\"\");\n  return;\n}\n\n#define DUMMYNODE 0\n\nmain(){\n  int n,q;\n\n  while(cin>>n>>q && n){\n    string t;getline(cin,t);\n    vector<int> p;p.push_back(-1);\n    vector<int> edge[n+1];\n    map<string,int>M;\n    stack<int> Parent;\n    stack<int> Blank;\n\n    getline(cin,t);M[t]=1;Parent.push(M[t]);Blank.push(0);\n    p.push_back(0);\n\n    REP(i,2,n+1){\n      getline(cin,t);\n      int cnt=0;\n      rep(j,t.size())if ( t[j]==' ')cnt++;else break;\n      string ins=t.substr(cnt);M[ins]=i;\n\n      while(!Blank.empty() && cnt <=Blank.top()){\n\tBlank.pop();Parent.pop();\n      }\n      p.push_back(Parent.top());\n      edge[Parent.top()].push_back(i);\n      \n      Parent.push(i);\n      Blank.push(cnt);\n    }\n\n    /*\n    puts(\"DEBUG\");\n    for(int i=1;i<=n;i++){\n      cout <<i << \" parent is \" << p[i] << endl;\n      cout << \"childlen is \" ;\n      rep(j,edge[i].size())cout << edge[i][j]<< \" \";\n      cout << endl;\n    }\n    puts(\"DEBUGEND\");\n    */\n    solve(n,q,M,edge,p);\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap<string,int> mp;\nint ind[1001],par[1001];\nbool ko(int a,int b){\n  return par[a]==b;\n}\n\nbool sos(int a,int b){\n  while(a!=b&&a)\n    a=par[a];\n  return a==b;\n}\n\nint main(){\n  int n,m,T=0;\n  string s;\n  char c;\n  while(cin>>n>>m,n){\n    if(T++)cout<<endl;\n    scanf(\"%c\",&c);\n    memset(ind,0,sizeof(ind));\n    memset(par,0,sizeof(par));\n    mp.clear();\n    par[0]=-1;\n    for(int i=0;i<n;i++){\n      int k=0;\n      while(scanf(\"%c\",&c)&&c==' ')k++;\n      cin>>s;\n      s=c+s;\n      scanf(\"%c\",&c);\n      mp[s]=i;\n      ind[i]=k;\n      for(int j=i-1;j>=0;j--)\n\tif(ind[j]<k){par[i]=j;break;}\n    }\n\n    for(int i=0;i<m;i++){\n      string q[6];\n      for(int j=0;j<6;j++)cin>>q[j];\n      bool ans;\n      q[5]=q[5].substr(0,q[5].size()-1); \n      int a=mp[q[0]],b=mp[q[5]];\n      if(q[3]==\"child\")ans=ko(a,b);\n      if(q[3]==\"parent\")ans=ko(b,a);\n      if(q[3]==\"sibling\")ans=(par[a]==par[b]);\n      if(q[3]==\"descendant\")ans=sos(a,b);\n      if(q[3]==\"ancestor\")ans=sos(b,a);\n      if(ans)cout<<\"True\"<<endl;\n      else cout<<\"False\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap<string,int> mp;\nint ind[1001],par[1001];\nbool ko(int a,int b){\n  return par[a]==b;\n}\n\nbool sos(int a,int b){\n  while(a!=b&&a)\n    a=par[a];\n  return a==b;\n}\n\nint main(){\n  int n,m,T=0;\n  string s;\n  char c;\n  while(cin>>n>>m,n){\n    if(T++)cout<<endl;\n    scanf(\"%c\",&c);\n    memset(ind,0,sizeof(ind));\n    memset(par,0,sizeof(par));\n    mp.clear();\n    par[0]=-1;\n    for(int i=0;i<n;i++){\n      int k=0;\n      while(scanf(\"%c\",&c)&&c==' ')k++;\n      cin>>s;\n      s=c+s;\n      scanf(\"%c\",&c);\n      mp[s]=i;\n      ind[i]=k;\n      par[i]=-1;\n      for(int j=i-1;j>=0;j--)\n\tif(ind[j]<k){par[i]=j;break;}\n    }\n\n    for(int i=0;i<m;i++){\n      string q[6];\n      for(int j=0;j<6;j++)cin>>q[j];\n      bool ans;\n      q[5]=q[5].substr(0,q[5].size()-1); \n      int a=mp[q[0]],b=mp[q[5]];\n      if(q[3]==\"child\")ans=ko(a,b);\n      if(q[3]==\"parent\")ans=ko(b,a);\n      if(q[3]==\"sibling\")ans=(par[a]==par[b]);\n      if(q[3]==\"descendant\")ans=sos(a,b);\n      if(q[3]==\"ancestor\")ans=sos(b,a);\n      if(ans)cout<<\"True\"<<endl;\n      else cout<<\"False\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nstruct node{\n  string name;\n  vector<node *> childlen;\n  \n  node(string name):name(name){}\n};\n\nvoid add_child(node * p, string new_name, const vector<string> &path, int depth){\n  if( depth == (int)path.size() ){\n    p->childlen.push_back( new node(new_name) );\n    return ;\n  }\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( path[depth] == p->childlen[i]->name ){\n      add_child( p->childlen[i], new_name, path, depth+1 );\n    }\n  }\n  return ;\n}\n\nvoid print(node *p){\n  cout << \"Childlen :\" << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    cout << p->childlen[i]->name << endl;\n  }\n  cout << \"-----\" << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    print( p->childlen[i] );\n  }\n}\n\nbool judge(node * p, const string &a, const string &b, const string &rel, bool Xfnd){\n  // cout << a << ' ' << b << ' ' << p->name << endl;\n  if(p->name == b){\n    return Xfnd;\n  }\n\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    for(int j = i+1; j < (int)p->childlen.size(); ++j){\n      if( (p->childlen[i]->name == a && p->childlen[j]->name == b) ||\n          (p->childlen[i]->name == b && p->childlen[j]->name == a) ){\n        return true;\n      }\n    }\n  }\n  \n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( p->name==a && p->childlen[i]->name == b && rel == \"child\" ) return true;\n    if( judge(p->childlen[i], a, b, rel, p->name==a) ) return true;\n  }\n  return false;\n}\n\nint main()\n{\n  while(true){\n    int n,m;\n    string dam;\n    cin >> n >> m;\n    if( n == 0  && m == 0 ) break;\n\n    getline(cin,dam);\n    node * root = new node(\"_PARENT_\");\n\n    int spaces = -1;\n    string current_parent = \"---\";\n    vector<string> path;\n    for(int i = 0; i < n; ++i){\n      string s;\n      getline(cin,s);\n      \n      int csp = 0;\n      for(int j = 0; j < (int)s.length(); ++j){\n        if( s[j] == ' ' ) ++csp;\n        else break;\n      }\n      s = s.substr( csp );\n\n      /*\n      cout << current_parent << ' ' << s << ' ' << spaces << ' ' << csp << endl;\n      for(int j = 0; j < (int)path.size(); ++j){\n        cout << path[j] << endl;\n      }\n      cout << endl;\n      */\n\n      if( csp == spaces - 1 ){\n        path.pop_back();\n        path.pop_back();\n        add_child(root, s, path, 0);\n        path.push_back(s);\n\n      }else if( csp == spaces ){\n        path.pop_back();\n        add_child(root, s, path, 0);\n        path.push_back(s);\n        \n      }else if( csp == spaces + 1 ){\n        add_child(root, s, path, 0);\n        path.push_back( s );\n\n      }else assert(false);\n\n      spaces = csp;\n    }\n    \n    for(int i = 0; i < m; ++i){\n      string X,Y,rel;\n      cin >> X >> dam >> dam >> rel >> dam >> Y;\n      Y = Y.substr(0, Y.length()-1);\n      if( rel == \"parent\" ){\n        rel = \"child\";\n        swap(X,Y);\n      }\n      if( rel == \"ancestor\" ){\n        rel = \"descendant\";\n        swap(X,Y);\n      }\n      \n      if( judge(root,Y,X,rel,false) ){\n        cout << \"True\" << endl;\n      }else{\n        cout <<\"False\"<<endl;\n      }\n      \n    }\n    cout << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\n#define Pint pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 2000;\n\nstring human[MAX_M][MAX_M];\nmap<string, Pint > human_map;\n\nbool tmpCheck(int y, int x){\n    if(y >= MAX_M) return false;\n    if(x >= MAX_M) return false;\n    if(y < 0) return false;\n    if(x < 0) return false;\n    return true;\n}\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ' && cnt < str.size()) cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nbool checkChild(string x, string y){\n    int now_y = human_map[y].first + 1, now_x = human_map[y].second + 1;\n    bool ret = false;\n    if(!tmpCheck(now_y, now_x)) return false;\n    while(human[now_y][now_x] != \"\"){\n        if(human[now_y][now_x] == x) ret = true;\n        now_y++;\n        if(!tmpCheck(now_y, now_x)) break;\n    }\n    return ret;\n}\n\nbool checkParent(string x, string y){\n    int now_y = human_map[y].first - 1, now_x = human_map[y].second - 1;\n    if(!tmpCheck(now_y, now_x)) return false;\n    while(human[now_y][now_x] == \"\"){\n        now_y++;\n        if(!tmpCheck(now_y, now_x)) break;\n    }\n    bool ret = (human[now_y][now_x] == x)? true : false;\n    return ret;\n}\n\nbool checkSibling(string x, string y){\n    int now_y = human_map[y].first, now_x = human_map[y].second;\n    int m = 1;\n    bool skip = false;\n    if(!tmpCheck(now_y + m, now_x)) skip = true;\n    bool ret = false;\n    while(human[now_y + m][now_x] != \"\" && !skip){\n        if(human[now_y + m][now_x] == x) ret = true;\n        m++;\n        if(!tmpCheck(now_y + m, now_x)) break;\n    }\n    now_y = human_map[y].first;\n    skip = false;\n    m = 1;\n    if(!tmpCheck(now_y - m, now_x)) skip = true;\n    while(human[now_y - m][now_x] != \"\" && !skip){\n        if(human[now_y - m][now_x] == x) ret = true;\n        m++;\n        if(!tmpCheck(now_y - m, now_x)) break;\n    }\n    return ret;\n}\n\nbool checkDescendant(string x, string y){\n    bool ret = false;\n    REP(i, human_map[x].first){\n        REP(j, human_map[x].second){\n            if(!tmpCheck(i, j)) break;\n            if(human[i][j] == y) ret = true;\n        }\n    }\n    return ret;\n}\n\nbool checkAncestor(string x, string y){\n    bool ret = false;\n    FOR(i, human_map[x].first + 1, MAX_M){\n        FOR(j, human_map[x].second + 1, MAX_M){\n            if(!tmpCheck(i, j)) break;\n            if(human[i][j] == y) ret = true;\n        }\n    }\n    return ret;\n}\n\nbool checkQ(string str){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    string y = vec[5].erase(vec[5].size() - 1);\n    if(vec[3] == \"child\") return checkChild(vec[0], y);\n    if(vec[3] == \"parent\") return checkParent(vec[0], y);\n    if(vec[3] == \"sibling\") return checkSibling(vec[0], y);\n    if(vec[3] == \"descendant\") return checkDescendant(vec[0], y);\n    if(vec[3] == \"ancestor\") return checkAncestor(vec[0], y);\n}\n\nint main(){\n    while(true){\n        int m, n;\n        string st;\n        getline(cin, st);\n        stringstream ss(st);\n        ss >>m >>n;\n        if(!n && !m) break;\n\n        REP(i, MAX_M) REP(j, MAX_M) human[i][j] = \"\";\n        human_map.clear();\n\n        REP(i, m){\n            string str;\n            getline(cin, str);\n            P tmp = cntSpace(str);\n            human[i][tmp.first] = tmp.second;\n            human_map[tmp.second] = Pint(i, tmp.first);\n        }\n\n        REP(i, n){\n            string str;\n            getline(cin, str);\n            if(checkQ(str) == true) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nvector<string> split(const string &str, const string& delimiter = \" \")\n{\n\tvector<string> res;\n\tstring::size_type i = 0, pos;\n\twhile ((pos = str.find(delimiter, i)) != string::npos)\n\t{\n\t\tres.push_back(str.substr(i, pos - i));\n\t\ti = pos + 1;\n\t}\n\tres.push_back(str.substr(i, str.size() - i));\n\treturn res;\n}\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n | m)\n\t{\n\t\tmap<string, string> parent;\n\t\tstring indent_to_name[1024];\n\n\n\t\tstring line;\n\t\tgetline(cin, line);\n\n\t\tgetline(cin, line);\n\t\tindent_to_name[0] = line;\n\t\trep (i, n - 1)\n\t\t{\n\t\t\tgetline(cin, line);\n\t\t\tint indent = line.find_first_not_of(' ');\n\t\t\tstring name = line.substr(indent);\n\t\t\tindent_to_name[indent] = name;\n\n\t\t\tparent[name] = indent_to_name[indent - 1];\n\t\t}\n\n\t\trep (i, m)\n\t\t{\n\t\t\tgetline(cin, line);\n\t\t\tvector<string> hoge = split(line);\n\t\t\tstring x = hoge[0], y = hoge.back();\n\t\t\ty.erase(y.size() - 1);\n\t\t\tstring query = hoge[3];\n\n\t\t\tif (query == \"descendant\")\n\t\t\t{\n\t\t\t\tquery = \"ancestor\";\n\t\t\t\tswap(x, y);\n\t\t\t}\n\t\t\telse if (query == \"child\")\n\t\t\t{\n\t\t\t\tquery = \"parent\";\n\t\t\t\tswap(x, y);\n\t\t\t}\n\n\t\t\tbool res = false;\n\t\t\tif (query == \"parent\")\n\t\t\t\tres = x == parent[y];\n\t\t\telse if (query == \"sibling\")\n\t\t\t\tres = parent[x] == parent[y];\n\t\t\telse if (query == \"ancestor\")\n\t\t\t{\n\t\t\t\twhile (parent.count(y))\n\t\t\t\t{\n\t\t\t\t\tif (x == y)\n\t\t\t\t\t{\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ty = parent[y];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << (res ? \"True\" : \"False\") << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n\nclass Tree\n{\npublic:\n\tstring name;\n\tTree* parent;\n\tvector<Tree*> child;\n\t\n\tTree()\n\t:parent(NULL)\n\t{}\n\t\n\t~Tree()\n\t{\n\t\tREP(i,child.size()) delete child[i];\n\t}\n};\n\nTree* tree;\n\nTree* find(Tree* t, string name)\n{\n\tif(name==t->name) return t;\n\t\n\tREP(i, t->child.size())\n\t{\n\t\tTree* ret=find(t->child[i], name);\n\t\tif(ret!=NULL) return ret;\n\t}\n\treturn NULL;\n}\n\nbool isChild(Tree* t, string name)\n{\n\tREP(i, t->child.size())\n\t{\n\t\tif(t->child[i]->name==name) return true;\n\t}\n\t\n\treturn false;\n}\n\nbool isParent(Tree* t, string name)\n{\n\tif(t->parent->name == name) return true;\n\treturn false;\n}\n\nbool isSibling(Tree* t, string name)\n{\n\tTree* p=t->parent;\n\t\n\treturn isChild(p, name);\n}\n\nbool isDescendant(Tree* t, string name)\n{\n\tTree* ret=find(t, name);\n\tif(ret==NULL) return false;\n\t\n\treturn true;\n}\n\nbool isAncestor(Tree* t, string name)\n{\n\tif(t->name==name) return true;\n\tif(t->parent==NULL) return false;\n\t\n\treturn isAncestor(t->parent, name);\n}\n\nint main()\n{\n\tint n,q;\n\twhile(cin >> n >> q, (n||q))\n\t{\n\t\ttree = new Tree;\n\t\tTree* now = tree;\n\t\tTree* prev = tree;\n\t\tint sp=-1;\n\t\tcin.ignore();\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tstring str;\n\t\t\tgetline(cin,str);\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\tREP(j,str.size()) if(str[j]==' ') ++cnt;\n\t\t\tstring name(str.begin()+cnt, str.end());\n\t\t\t\n\t\t\tREP(j, (sp-cnt)+1)\n\t\t\t\tnow=now->parent;\n\n\t\t\tTree* nw= new Tree;\n\t\t\tnw->parent=now;\n\t\t\tnw->name=name;\n\t\t\t\n\t\t\tnow->child.push_back(nw);\n\t\t\tnow = nw;\n\t\t\tsp=cnt;\n\t\t}\n\t\t\n\t\tREP(i,q)\n\t\t{\n\t\t\tbool ret;\n\t\t\tstring a,b,c;\n\t\t\tcin >> a >> b >> b >> b >> c >> c;\n\t\t\t\n\t\t\tc=c.substr(0,c.size()-1);\n\t\t\t\n\t\t\tTree* s=find(tree, c);\n\t\t\tif(s==NULL) cout << \"False\" << endl;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(b[0]=='c') ret=isChild(s,a);\n\t\t\t\tif(b[0]=='p') ret=isParent(s,a);\n\t\t\t\tif(b[0]=='s') ret=isSibling(s,a);\n\t\t\t\tif(b[0]=='d') ret=isDescendant(s,a);\n\t\t\t\tif(b[0]=='a') ret=isAncestor(s,a);\n\t\t\t\t\n\t\t\t\tcout << (ret?\"True\":\"False\") << endl;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << endl;\n\t\t\n\t\tdelete tree;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "equire 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef Graph::get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef Graph::get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef make_layer_graph(s, t) #nodes:copy, edges:alias\n\t\tlg = Graph.new\n\t\tcorrespond = {}\n\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tcurrent_queue = [s]\n\n\t\tcorrespond[s] = lg.add_node\n\n\t\twhile 0\n\t\t\tnext_queue = []\n\t\t\twhile !current_queue.empty? \n\t\t\t\tu = current_queue.shift\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\tcorrespond[v] ||= lg.add_node \n\t\t\t\t\tcorrespond[e] = lg.add_edge(correspond[u], correspond[v])\n\n\t\t\t\t\tnext_queue << v unless reached.include?(v)\t\n\t\t\t\t}\n\t\t\tend\t\n\n\t\t\tbreak if next_queue.empty?\n\t\t\tnext_queue.each{|v| reached << v}\n\t\t\tcurrent_queue = next_queue\n\t\tend\n\n\t\tnil\n\tend\nend\n\ndef get_integers\n\tgets.split(\" \").map(&:to_i)\nend\n\nloop {\n\tn, m = get_integers\n\tbreak if n == 0\n\n\tg = Graph.new\n\n\tindent = -1\n\tstack = []\n\tname_to_node = {}\n\tn.times {\n\t\tgets =~ /^(\\s*)(\\w+)$/\n\t\tindent = $1.size\n\t\tstack.pop until stack.size <= indent\n\t\tv = g.add_node($2)\n\t\tg.add_edge(stack.last, v) if stack.size > 0\n\t\tstack << v\n\t\tname_to_node[v.label] = v\n\t}\n\n\tm.times {\n\t\tgets =~ /^(\\w+) is \\w+ (\\w+) of (\\w+)\\.$/\n\t\tu = name_to_node[$1]\n\t\trelation = $2\n\t\tv = name_to_node[$3]\n\t\t\n\t\tbool = false\n\t\tcase relation\n\t\twhen \"descendant\"\n\t\t\tbool = Graph::get_path_bfs(v, u)\n\t\twhen \"ancestor\"\n\t\t\tbool = Graph::get_path_bfs(u, v)\n\t\twhen \"child\"\n\t\t\tbool = !u.incomings.empty? && u.incomings.all?{|e| e.from == v}\n\t\twhen \"parent\"\n\t\t\tbool = !v.incomings.empty? && v.incomings.all?{|e| e.from == u}\n\t\twhen \"sibling\"\n\t\t\tbool = u.incomings == v.incomings\n\t\tend\n\t\tputs bool ? \"True\" : \"No\"\n\t}\n\tputs\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nvector<int> G[1111];\nbool used[1111];\nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<(int)G[v].size();i++) dfs(G[v][i]);\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    cin.ignore();\n    for(int i=0;i<1111;i++) G[i].clear();\n    string per[n];\n    int depth[n],rG[n];\n    rG[0]=-1;\n    depth[0]=0;\n    map<string,int> ms;\n    for(int i=0;i<n;i++) getline(cin,per[i]);\n    for(int i=0;i<n;i++){\n      int k=0;\n      while(per[i][k]==' ') k++;\n      depth[i]=k;\n      per[i]=per[i].substr(k,per[i].size()-k);\n      ms[per[i]]=i;\n    }\n    int p=0;\n    stack<int> st;\n    for(int i=1;i<n;i++){\n      G[p].push_back(i);\n      rG[i]=p;\n      if(i+1<n&&depth[i]<depth[i+1]){\n\tst.push(p);\n\tp=i;\n      }\n      if(i+1<n&&depth[i]>depth[i+1]){\n\tp=st.top();st.pop();\t\n      }\n    }\n    for(int i=0;i<m;i++){\n      string st[6];\n      for(int j=0;j<6;j++) cin>>st[j];\n      st[5]=st[5].substr(0,st[5].size()-1);\n      bool f=0;\n      if(st[3]==\"child\"){\n\tint v=ms[st[5]];\n\tfor(int j=0;j<(int)G[v].size();j++) f|=ms[st[0]]==G[v][j];\n      }\n      if(st[3]==\"parent\"){\n\tint v=ms[st[0]];\n\tfor(int j=0;j<(int)G[v].size();j++) f|=ms[st[5]]==G[v][j];\n      }\n      if(st[3]==\"sibling\"){\n\tint v=rG[ms[st[0]]];\n\tfor(int j=0;j<(int)G[v].size();j++) f|=ms[st[5]]==G[v][j];\n      }\n      if(st[3]==\"descendant\"){\n\tmemset(used,0,sizeof(used));\n\tdfs(ms[st[5]]);\n\tf=used[ms[st[0]]];\n      }\n      if(st[3]==\"ancestor\"){\n\tmemset(used,0,sizeof(used));\n\tdfs(ms[st[0]]);\n\tf=used[ms[st[5]]];\n      }\n      cout<<(f?\"True\":\"False\")<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 1010\n \nstruct P{\n    int p,l;\n};\n \nP p[MAX_N];\nstring s[MAX_N];\nbool used[MAX_N];\nint N;\n \nvoid init(int N){\n    for(int i = 0 ; i < N ; i++){\n\tp[i].p = i;\n    }\n}\n \nbool find(int x,int target){\n    if(p[x].p == target){\n\treturn true;\n    }\n    if(p[x].p == x) return false;\n    return find(p[x].p,target);\n}\n \nvoid make(int n,int parent,int root,int depth){\n    set<int> children;\n    if(used[n]){ return; }\n    used[n] = true;\n    p[n].p = parent; p[n].l = depth;\n    for(int i = n+1 ; i < N ; i++){\n\tint len = s[i].size();\n\tif(depth+1 >= len) continue;\n\tif(s[i][depth] != '.') break;\n\tif(s[i][depth] == '.' && s[i][depth+1] != '.'){\n\t    children.insert(i);\n\t    make(i,n,root,depth+1);\n\t}\n    }\n}\n \nint main(){\n    int M;\n    while(cin >> N >> M, N){\n\tmap<string,int> mp;\n\tint cur = 0;\n\tinit(N); cin.ignore();\n\tfor(int i = 0 ; i < N ; i++){\n\t    getline(cin,s[i]);\n\t    for(int j = 0 ; j < (int)s[i].size() ; j++){\n\t\tif(s[i][j] != ' '){\n\t\t    mp[s[i].substr(j)] = cur++;\n\t\t    break;\n\t\t}\n\t\ts[i][j] = '.';\n\t    }\n\t    used[i] = false;\n\t}\n\tfor(int i = 0 ; i < N ; i++){\n\t    if(used[i]) continue;\n\t    if(s[i][0] != '.'){\n\t\tmake(i,i,i,0);\n\t    }\n\t}\n\tstring ord,a,b,c;\n\tfor(int i = 0 ; i < M ; i++){\n\t    getline(cin,ord);\n\t    stringstream ss(ord);\n\t    ss >> a;\n\t    ss >> ord; ss >> ord;\n\t    ss >> c;\n\t    ss >> ord;\n\t    ss >> b;\n\t    b.resize(b.size()-1);\n\t    bool ans = false;\n\t    if(c == \"parent\"){\n\t\tif(p[mp[b]].p == mp[a]){\n\t\t    ans = true;\n\t\t}\n\t    }else if(c == \"child\"){\n\t\tif(p[mp[a]].p == mp[b]){\n\t\t    ans = true;\n\t\t}\n\t    }else if(c == \"ancestor\"){\n\t\tif(p[mp[a]].l < p[mp[b]].l && find(mp[b],mp[a])){\n\t\t    ans = true;\n\t\t}\n\t    }else if(c == \"descendant\"){\n\t\tif(p[mp[a]].l > p[mp[b]].l && find(mp[a],mp[b])){\n\t\t    ans = true;\n\t\t}\n\t    }else{\n\t\tif(p[mp[a]].l == p[mp[b]].l && p[mp[a]].p == p[mp[b]].p){\n\t\t    ans = true;\n\t\t}\n\t    }\n\t    cout << (ans ? \"True\" : \"False\") << endl;\n\t}\n\tcout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nstruct node{\n  string name;\n  vector<node *> childlen;\n  \n  node(string name):name(name){}\n};\n\nvoid add_child(node * p, string new_name, const vector<string> &path, int depth){\n  if( depth == (int)path.size() ){\n    p->childlen.push_back( new node(new_name) );\n    return ;\n  }\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( path[depth] == p->childlen[i]->name ){\n      add_child( p->childlen[i], new_name, path, depth+1 );\n    }\n  }\n  return ;\n}\n\nvoid print(node *p){\n  cout << p->name << endl;\n  cout << \"Childlen :\" << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    cout << p->childlen[i]->name << endl;\n  }\n  cout << \"-----\" << endl << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    print( p->childlen[i] );\n  }\n}\n\nbool isChild;\nbool isDescendant;\nbool isSibling;\nvoid judge(node * p, const string &a, const string &b, const string &rel, bool Xfnd){\n  if(p->name == b){\n    if( Xfnd ){ \n      isDescendant = true;\n    }\n    return ;\n  }\n\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    for(int j = i+1; j < (int)p->childlen.size(); ++j){\n      if( (p->childlen[i]->name == a && p->childlen[j]->name == b) ||\n          (p->childlen[i]->name == b && p->childlen[j]->name == a) ){\n        isSibling = true;\n      }\n    }\n  }\n  \n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( rel == \"child\" ){\n      if( p->name==a && p->childlen[i]->name == b && rel == \"child\" ){\n        isChild = true;\n        return ;\n      }\n    }\n    judge(p->childlen[i], a, b, rel, p->name==a|Xfnd);\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int n,m;\n    string dam;\n    cin >> n >> m;\n    if( n == 0  && m == 0 ) break;\n\n    getline(cin,dam);\n    node * root = new node(\"___ROOT\");\n\n    int spaces = -1;\n    vector<string> path;\n    for(int i = 0; i < n; ++i){\n      string s;\n      getline(cin,s);\n      \n      int csp = 0;\n      for(int j = 0; j < (int)s.length(); ++j){\n        if( s[j] == ' ' ) ++csp;\n        else break;\n      }\n      s = s.substr( csp );\n\n      if( csp < spaces ){\n        path.pop_back();\n        for(int j = 0; j < spaces - csp; ++j){\n          path.pop_back();\n        }\n        add_child(root, s, path, 0);\n        path.push_back(s);\n\n      }else if( csp == spaces ){\n        path.pop_back();\n        add_child(root, s, path, 0);\n        path.push_back(s);\n        \n      }else if( csp == spaces + 1 ){\n        add_child(root, s, path, 0);\n        path.push_back( s );\n      }\n\n      spaces = csp;\n    }\n    // print(root);\n    \n    for(int i = 0; i < m; ++i){\n      string X,Y,rel;\n      bool res = false;\n      cin >> X >> dam >> dam >> rel >> dam >> Y;\n      Y = Y.substr(0, Y.length()-1);\n      if( rel == \"parent\" ){\n        rel = \"child\";\n        swap(X,Y);\n      }\n      if( rel == \"ancestor\" ){\n        rel = \"descendant\";\n        swap(X,Y);\n      }\n\n      isDescendant = false;\n      isChild = false;\n      isSibling = false;\n      \n      judge(root,Y,X,rel,false);\n\n      if( rel == \"child\" ){\n        res = isChild;\n      }else if( rel == \"descendant\"){\n        res = isDescendant;\n      }else if( rel == \"sibling\" ){\n        res = isSibling;\n      }\n\n      if( res ){\n        cout << \"True\" << endl;\n      }else{\n        cout << \"False\" << endl;\n      }\n      \n    }\n    cout << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\nusing namespace std;\n \nstruct S {\n\tstring name;\n\tint parent;\n\tvector<int> child;\n\tS(string s, int p, vector<int> c) : name(s), parent(p), child(c){}\n};\n \nvector<S> G;\n \nint main()\n{\n\tint N, M;\n\twhile (cin>>N>>M, N||M) {\n\t\tcin.ignore();\n\t\t\n\t\tmap<string, int> list;\n\t\t\n\t\tint idx=0;\n\t\t\n\t\tvector<string> s(N);\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tgetline(cin, s[i]);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tint count = 0;\n\t\t\tint p=0;\n\t\t\t\n\t\t\twhile (s[i][p]==' ') {\n\t\t\t\tcount++;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\t\n\t\t\tstring n = s[i].substr(p);\n\t\t\tif (count==0) {\n\t\t\t\tG.push_back(S(n, -1, vector<int>()));\n\t\t\t\tlist[n] = idx++;\n\t\t\t} else {\n\t\t\t\tstring parent;\n\t\t\t\tfor (int j=i; i>=0; i--) {\n\t\t\t\t\tint cc=0;\n\t\t\t\t\twhile (s[j][cc]==' ') cc++;\n\t\t\t\t\tif (cc==count-1)\n\t\t\t\t\t\tparent = s[j].substr(cc);\n\t\t\t\t\t\n\t\t\t\t\tG.push_back(S(n, list[parent], vector<int>());\n\t\t\t\t\tlist[n] = idx++;\n\t\t\t\t\tG[list[parent]].cild.push_back(list[n]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int z=0; z<M; z++) {\n\t\t\tstring t; getline(cin, t);\n\t\t\tistringstream ss(t);\n\t\t\tvector<string> tt(6);\n\t\t\tfor (int i=0; i<6; i++) \n\t\t\t\tss>>tt[i];\n\t\t\t\n\t\t\tstring X = tt[0], Y = tt[5];\n\t\t\t\n\t\t\tbool ans=false;\n\t\t\t\n\t\t\tif (tt[3][0]=='c') {\n\t\t\t\tbool ok=false;\n\t\t\t\tfor (int i=0; i<G[list[Y]].size(); i++) {\t\n\t\t\t\t\tif (list[X] == G[list[Y]].child[i]) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << (ok?\"True\":\"False\") << endl;\n\t\t\t} else if (tt[3][0]=='p') {\n\t\t\t\tif (list[X] == G[list[Y]].parent) {\n\t\t\t\t\tans = true;\n\t\t\t\t}\n\t\t\t} else if (tt[3][0]=='s') {\n\t\t\t\tif (G[list[X]].parent == G[list[Y]].parent && G[list[X]].parent!=-1)\n\t\t\t\t\tans = true;\n\t\t\t} else if (tt[3][0]=='d') {\n\t\t\t\tswap(X, Y);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (G[list[Y]].parent==-1) break;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t} else if (tt[3][0]=='a') {\n\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      if(level_tree.find(mid) != level_tree.end())\n\tinfo.push_back(mid);\n      else if(mid == \"child\" || mid == \"parent\" || mid == \"sibling\" || mid == \"descendant\" || mid == \"ancestor\")\n\tinfo.pb(mid);\n    }\n\n skip:\n\n  \n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n      //cout << \"Xindex = \" << Xindex << \" Yindex = \" << Yindex << endl;\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\t  //cout << \"vec : \" << vec[i].F << endl;\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || max(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      cerr << n << \" \" << m << endl;\n      if(!(n+m))\n\tbreak;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  cerr << line << endl;\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\tX is a child of Y.@XÌeð²×Ä­B\n\tX is the parent of Y.@YÌeð²×Ä­\n\tX is a sibling of Y. XÆYÌ[³ª¯¶©mF·é\n\tX is a descendant of Y. XÌeðÄAIÉ\n\tX is an ancestor of Y.@YÌeðÄAIÉ\n*/\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <sstream>\n#include <set>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nmap<string,string> data;\nmap<string,int> dp;\n\nvector< pair<string,int> > rec;\n\nint n,m,I,back;\n\nvoid input(string parent,int depth){\n\twhile( I < n ){\n\t\n\t\tstring nstr = rec[I].first;\n\t\tint ndp = rec[I].second;\n\t\tdata[nstr] = parent;\n\t\tdp[nstr] = depth;\n\t\tI++;\n\t\tif(depth < ndp){\n\t\t\tinput(nstr,ndp);\n\t\t\tif(back){\n\t\t\t\tback--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}else if(depth > ndp){\n\t\t\tback = depth-ndp-1;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstring search(string a){\n\tstring s;\n\tif(a==\"\")return \"\";\n\t//cout << a << \" ÌeÍ \" << data[a] << \" , \";\n\ts += a + \" \" + search(data[a]) + \" \";\n\treturn s;\n}\n\nbool func(string a,string b){\n\n\tset<string> A;set<string> B;\n\tstring t;\n\tstringstream ss1( search(a) ),ss2( search(b) );\n\twhile(ss1 >> t)A.insert(t);\n\twhile(ss2 >> t)B.insert(t);\n\tint size = A.size()+B.size();\n\t\n\tfor(set<string>::iterator it = B.begin(); it != B.end() ; ++it){\n\t\tA.insert(*it);\n\t}\n\treturn (A.size()!=size && dp[a] > dp[b]);\n}\nint main(){\n\tstring s;int C = 0;\n\twhile(scanf(\"%d %d\\n\",&n,&m) , n){\n\t\tif(C++)cout << endl;\n\t\tint prevCount=0,tmpCount;\n\t\tvector< pair<string,int> > in(n,make_pair(\"\",-1));\n\t\tdata.clear();dp.clear();\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgetline(cin,s);\n\t\t\tif(i){\n\t\t\t\tin[i-1].second = count(s.begin(),s.end(),' ');\n\t\t\t}\n\t\t\ts.erase(remove(s.begin(),s.end(),' '),s.end());\n\t\t\tin[i].first = s;\n\t\t}\n\t\t/*for(int i=0;i<n;i++){\n\t\t\tcout << in[i].first << \" \" << in[i].second << endl;\n\t\t}*/\n\t\n\t\trec=in;\n\t\tI = back = \t0;\n\t\tinput(\"\",0);\n\t\t\n\t\tbool flag;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tvector<string> tmp;\n\t\t\tgetline(cin,s);\n\t\t\ts = s.substr(0,s.length()-1);\n\t\t\tstringstream ss(s);\t\n\t\t\twhile(ss >> s)tmp.push_back(s);\n\t\t\t//cout << tmp[0] << \" \" << tmp[5] << endl;\n\t\t\tstring X = tmp[0], Y = tmp[5] , type = tmp[3];\n\t\t\n\t\t\n\t\t\tif(type == \"child\")flag = (data[X] == Y);\n\t\t\tif(type == \"parent\")flag = (data[Y] == X);\n\t\t\tif(type == \"sibling\")flag = (data[X] == data[Y]);\n\t\t\tif(type == \"descendant\")flag = func(X,Y);\n\t\t\tif(type == \"ancestor\")flag = func(Y,X);\n\t\t\n\t\t\tcout << (flag?\"True\":\"False\") << endl;\n\t\t}\n\t\t/*for( map<string,string>::iterator it = data.begin(); it != data.end() ; ++it ){\n\t\t\tcout << (*it).first << \" ÌeÍ \" << (*it).second << endl;\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint par[1010];\nint last[100];\nmap<string, int> name;\n\nbool check_ancestor(int a, int d){\n\tif (a < 0 || d < 0) return false;\n\tif (a == par[d]) return true;\n\treturn check_ancestor(a, par[d]);\n}\n\nint main(){\n\tint n, q;\n\twhile (cin >> n >> q, n|q){\n\t\tname.clear();\n\t\tMEMSET(last, -1);\n\t\tMEMSET(par, -1);\n\t\tcin.ignore();\n\t\trep(i, n){\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\t\t\tint cnt = count(ALL(s), ' ');\n\t\t\tlast[cnt] = i;\n\t\t\tname[s.substr(cnt)] = i;\n\t\t\tif (!cnt) continue;\n\t\t\tpar[i] = last[cnt - 1];\n\t\t}\n\t\twhile (q--){\n\t\t\tstring a, b, c, d, e, f;\n\t\t\tcin >> a >> b >> c >> d >> e >> f;\n\t\t\tcout << f.substr(0, f.size() - 1) << endl;\n\t\t\tint x = name[a], y = name[f.substr(0, f.size() - 1)];\n\t\t\tbool ok;\n\t\t\tswitch (d[0]){\n\t\t\tcase 'c':\n\t\t\t\tok = par[x] == y;\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tok = check_ancestor(x, y);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tok = par[x] == par[y];\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tok = x == par[y];\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tok = check_ancestor(y, x);\n\t\t\t}\n\t\t\tcout << (ok ? \"True\" : \"False\") << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n/*\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n*/\n        // child\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j]-1 ) {\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] >= D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // sibling\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n            }\n        }\n\n        // descendant\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << A << \", \" << B << \": \" << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nbool des(string a, string b, map<string, string> &m) {\n\tstring s = a;\n\twhile(s != \"\") {\n\t\tif(s == b)\n\t\t\treturn true;;\n\t\ts = m[s];\n\t}\n\treturn false;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, m;\n\twhile(cin >> n >> m, n|m) {\n\t\tcin.ignore();\n\t\tvector<string> v(1000);\n\t\tmap<string, string> ma;\n\t\tREP(i, n) {\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\t\t\tint cnt = 0;\n\t\t\twhile(s[cnt] == ' ')\n\t\t\t\tcnt++;\n\t\t\ts = s.substr(cnt);\n\t\t\tma[s] = cnt ? v[cnt-1] : \"\";\n\t\t\tv[cnt] = s;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tstring in1, in2, in3;\n\t\t\tcin >> in1;\n\t\t\tcin >> in2 >> in2 >> in2;\n\t\t\tcin >> in3 >> in3;\n\t\t\tin3.erase(in3.end() - 1);\n\t\t\tbool ans = false;\n\t\t\tif(in2 == \"child\" && ma[in1] == in3)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"parent\" && ma[in3] == in1)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"sibling\" && ma[in1] == ma[in3])\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"descendant\")\n\t\t\t\tans = des(in1, in3, ma);\n\t\t\telse if(in2 == \"ancestor\")\n\t\t\t\tans = des(in3, in1, ma);\n\t\t\tcout << (ans ? \"True\" : \"False\") << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nmap <string, string> child_parent;\nstring lastname[2000];\n\nbool child(string a, string b){\n\tif (child_parent[a] == b) return true;\n\telse return false;\n}\n\nbool parent(string a, string b){\n\tif (a == child_parent[b]) return true;\n\telse return false;\n}\n\nbool sibling(string a, string b){\n\tif (child_parent[a] == child_parent[b]) return true;\n\telse return false;\n}\n\nbool ancestor(string a, string b){\n\tif (child_parent[b] == \"none\") return false;\n\telse if (parent(a, b)) return true;\n\telse return ancestor(a, child_parent[b]);\n}\n\nbool descendant(string a, string b){\n\treturn ancestor(b, a);\n}\n\nint main(void){\n\n\tint n, m;\n\n\twhile (cin >> n >> m, n, m){\n\n\t\tchild_parent.clear();\n\t\tcin.ignore();\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\n\t\t\tint count = 0;\n\t\t\tfor (int j = 0; j < s.size(); j++){\n\t\t\t\tif (s[j] == ' ') count++;\n\t\t\t}\n\n\t\t\tif (count == 0) child_parent[s] = \"none\";\n\t\t\telse child_parent[s.substr(count)] = lastname[count - 1];\n\n\t\t\tlastname[count] = s.substr(count);\n\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tstring a, b,relate, buff;\n\t\t\tcin >> a >> buff >> buff >> relate >> buff;\n\t\t\tchar bb[200];\n\t\t\tscanf(\" %[^.].\", &bb);\n\t\t\tb = bb;\n\n\t\t\tbool flag = false;\n\t\t\tif (relate == \"child\") flag = child(a, b);\n\t\t\telse if (relate == \"parent\") flag = parent(a, b);\n\t\t\telse if (relate == \"sibling\") flag = sibling(a, b);\n\t\t\telse if (relate == \"descendant\") flag = descendant(a, b);\n\t\t\telse if (relate == \"ancestor\") flag = ancestor(a, b);\n\n\t\t\tif (flag) cout << \"True\" << endl;\n\t\t\telse cout << \"False\" << endl;\n\t\t}\n\n\t\t\n\n\t\tcout << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 1010\n\nstruct P{\n  int p,l;\n};\n\nP p[MAX_N];\nstring s[MAX_N];\nbool used[MAX_N];\nint par[MAX_N],rank[MAX_N],N;\n\nvoid init(int N){\n  for(int i = 0 ; i < N ; i++){\n    par[i] = p[i].p = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y){ return; }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return (find(x) == find(y));\n}\n\nvoid make(int n,int parent,int root,int depth){\n  if(used[n]){ return; }\n  used[n] = true;\n  unite(root,n);\n  p[n].p = parent; p[n].l = depth;\n  for(int i = n+1 ; i < N ; i++){\n    int len = s[i].size();\n    if(depth+1 >= len){ continue; }\n    if(s[i][depth] != '.'){ break; }\n    if(s[i][depth] == '.' && s[i][depth+1] != '.'){\n      make(i,n,root,depth+1);\n    }\n  }\n}\n\nint main(){\n  int M;\n  while(cin >> N >> M, N){\n    map<string,int> mp;\n    int cur = 0;\n    init(N); cin.ignore();\n    for(int i = 0 ; i < N ; i++){\n      getline(cin,s[i]);\n      for(int j = 0 ; j < (int)s[i].size() ; j++){\n        if(s[i][j] != ' '){\n          mp[s[i].substr(j)] = cur++;\n          break;\n        }\n        s[i][j] = '.';\n      }\n      used[i] = false;\n    }\n    for(int i = 0 ; i < N ; i++){\n      if(used[i]){ continue; }\n      if(s[i][0] != '.'){\n        make(i,i,i,0);\n      }\n    }\n    string ord,a,b,c;\n    for(int i = 0 ; i < M ; i++){\n      getline(cin,ord);\n      stringstream ss(ord);\n      ss >> a;\n      ss >> ord; ss >> ord;\n      ss >> c;\n      ss >> ord;\n      ss >> b;\n      b.resize(b.size()-1);\n      bool ans = false;\n      if(c == \"parent\"){\n        if(p[mp[b]].p == mp[a]){\n          ans = true;\n        }\n      }else if(c == \"child\"){\n        if(p[mp[a]].p == mp[b]){\n          ans = true;\n        }\n      }else if(c == \"ancestor\"){\n        if(same(mp[a],mp[b]) && p[mp[a]].l < p[mp[b]].l){\n          ans = true;\n        }\n      }else if(c == \"descendant\"){\n        if(same(mp[a],mp[b]) && p[mp[a]].l > p[mp[b]].l){\n          ans = true;\n        }\n      }else{\n        if(same(mp[a],mp[b]) && p[mp[a]].l == p[mp[b]].l){\n          ans = true;\n        }\n      }\n      cout << (ans ? \"True\" : \"False\") << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, m;\n\twhile(cin >> n >> m, n|m) {\n\t\tcin.ignore();\n\t\tvector<string> v(1000);\n\t\tmap<string, string> ma;\n\t\tREP(i, n) {\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\t\t\tint cnt = 0;\n\t\t\twhile(s[cnt] == ' ')\n\t\t\t\tcnt++;\n\t\t\ts = s.substr(cnt);\n\t\t\tif(!cnt)\n\t\t\t\tma[s] = \"\";\n\t\t\telse\n\t\t\t\tma[s] = v[cnt-1];\n\t\t\tv[cnt] = s;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tstring in1, in2, in3;\n\t\t\tcin >> in1;\n\t\t\tcin >> in2 >> in2 >> in2;\n\t\t\tcin >> in3 >> in3;\n\t\t\tin3.erase(in3.end() - 1);\n\t\t\tbool ans = false;\n\t\t\tif(in2 == \"child\" && ma[in1] == in3)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"parent\" && ma[in3] == in1)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"sibling\" && ma[in1] == ma[in3])\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"descendant\") {\n\t\t\t\tstring s = ma[in1];\n\t\t\t\twhile(s != \"\") {\n\t\t\t\t\tif(s == in3)\n\t\t\t\t\t\tans = true;\n\t\t\t\t\ts = ma[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(in2 == \"ancestor\") {\n\t\t\t\tstring s = ma[in3];\n\t\t\t\twhile(s != \"\") {\n\t\t\t\t\tif(s == in1)\n\t\t\t\t\t\tans = true;\n\t\t\t\t\ts = ma[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans)\n\t\t\t\tcout << \"True\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"False\" << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint m,n;\n\nstruct nodeInfo{\n    int depth;\n};\n\nmap<string,int> id;\nvector<int> G[1010];\nnodeInfo nif[1010];\n\nint backNode(int cnode,int cnt){\n    for(int i = 0; i < cnt; i++){\n        for(int j = 0; j < G[cnode].size(); j++){\n            // ツ親ツノツーツドツづ個づ卍つ、ツつェツ深ツつウツつェツ静ウツつ「\n            if(nif[G[cnode][j]].depth<nif[cnode].depth){\n                cnode=G[cnode][j];\n                break;\n            }\n        }\n    }\n    return cnode;\n}\nbool isChild(int n1idx,int n2idx){\n    return n2idx==backNode(n1idx,1);\n}\nbool isAncestor(int n1idx,int n2idx){\n    int cnode=n2idx;\n    while(1){\n        if(cnode==n1idx)\n            return true;\n        // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n        if(cnode==0)\n            return false;\n        else\n            cnode=backNode(cnode,1);\n    }\n}\n\nint main(){\n    bool f=false;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        if(f)\n            cout<<endl;\n        f=true;\n        id.clear();\n        string str;\n        getline(cin,str);\n        for(int i = 0; i < 1010; i++)G[i].clear();\n        int depth=-1;\n        int cp=-1;\n        for(int i = 0; i < n; i++){\n            getline(cin,str);\n            int cnt=0;\n            for(int j = 0; ;j++){\n                if(str[j]==' ')\n                    continue;\n                else{\n                    str=str.substr(j);\n                    cnt=j;\n                    break;\n                }\n            }\n            id[str]=i;\n            // cntツづ個青板つセツつッツ親ツづ可姪淞づィツ、ツつサツつアツづ可ノツーツドツづーツ挿ツ禿シツつキツづゥ\n            if(cp!=-1){\n                if(depth<cnt){\n                    G[cp].push_back(i);\n                    G[i].push_back(cp);\n                }\n                else{\n                    int back=backNode(cp,depth-cnt+1);\n                    G[back].push_back(i);\n                    G[i].push_back(back);\n                }\n            }\n            cp=i;\n            depth=cnt;\n            nif[i].depth=depth;\n        }\n        for(int j = 0; j < m; j++){\n            string name1,name2,tmp,order;\n            cin>>name1>>tmp>>tmp>>order>>tmp>>name2;\n            name2=name2.substr(0,name2.size()-1);\n            int n1idx=id[name1];\n            int n2idx=id[name2];\n            bool match=false;\n            if(order==\"child\")\n                match=isChild(n1idx,n2idx);\n            else if(order==\"ancestor\")\n                match=isAncestor(n1idx,n2idx);\n            else if(order==\"sibling\"){\n                int cnode=backNode(n1idx,1);\n                for(int i = 0; i < G[cnode].size(); i++){\n                    int to=G[cnode][i];\n                    match=(nif[n1idx].depth==nif[to].depth&&to==n2idx);\n                    if(match)\n                        break;\n                }\n            }\n            else if(order==\"parent\")\n                match=isChild(n2idx,n1idx);\n            else\n                match=isAncestor(n2idx,n1idx);\n            if(match)\n                cout<<\"True\"<<endl;\n            else\n                cout<<\"False\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconstexpr long double EPS = 1e-15;\nconst long double PI = acos(-1);\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n//#define all(v) (v).begin(), (v).end()\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nclass Person{\npublic:\n    int id;\n    string name;\n    vector<Person> child;\n    int pid = -1;\n\n    Person(){}\n    Person(string _name, int _id, int p = -1) {\n        id = _id;\n        name = _name;\n        pid = p;\n    }\n    void addchild(Person c) {\n        child.push_back(c);\n    }\n    bool issibling(string s) {\n        REP(i,sz(child)) {\n            if (s == child[i].name) return 1;\n        }\n        return 0;\n    }\n    void showchild() {\n        for (int i = 0; i < child.size(); i++) {\n            cout << child[i].name << endl;\n        }\n    }\n};\n\nvoid solve() {\n\nwhile (1) {\n    string s;\n    getline(cin,s);\n    stringstream ss;\n    ss << s;\n    int n, m;\n    ss >> n >> m;\n    // cout << n << \" \" << m << endl;\n    if (n == 0 && m == 0) break;\n\n\n    map<string,int> id;\n    vector<Person> people;\n    stack<pair<string,int>> parents;\n\n    REP(i,n) {\n        getline(cin,s);\n        int indent = 0;\n        while (s[indent] == ' ') {\n            indent++;\n        }\n        string name = s.substr(indent, s.size() - indent);\n        // cout << name << endl;\n\n        if (indent == 0) {\n            parents.push({name,0});\n            people.push_back(Person(name,i));\n            id[name] = i;\n        } else {\n            pair<string,int> tp = parents.top();\n            while (indent <= tp.se) {\n                parents.pop();\n                tp = parents.top();\n            }\n            parents.push({name,indent});\n            people.push_back(Person(name,i,id[tp.fi]));\n            people[id[tp.fi]].addchild(people.back());\n            id[name] = i;\n        }\n    }\n\n    REP(i,m) {\n        stringstream tmp;\n        getline(cin,s);\n        tmp << s;\n        string n1,is,the,relation,of,n2;\n        tmp >> n1 >> is >> the >> relation >> of >> n2;\n        // cout << n1 << \" \" << is << \" \" << the << \" \" << relation << \" \" << of << \" \" << n2 << endl;\n        n2 = n2.substr(0,sz(n2)-1);\n        bool f = 0;\n        if (relation == \"child\") {\n            f = (people[id[n1]].pid == id[n2]);\n        } else if (relation == \"ancestor\") {\n            f = 0;\n            int tid = people[id[n2]].pid;\n            while (tid != -1) {\n                if (people[tid].name == n1) {\n                    f = 1;\n                    break;\n                }\n                tid = people[tid].pid;\n            }\n        } else if (relation == \"sibling\") {\n            f = 0;\n            int tid = people[id[n1]].pid;\n            if (tid == -1) f = 0;\n            else f = people[tid].issibling(n2);\n        } else if (relation == \"parent\") {\n            f = (people[id[n2]].pid == id[n1]);\n        } else if (relation == \"descendant\") {\n            f = 0;\n            int tid = people[id[n1]].pid;\n            while (tid != -1) {\n                if (people[tid].name == n2) {\n                    f = 1;\n                    break;\n                }\n                tid = people[tid].pid;\n            }\n        }\n        cout << (f?\"True\":\"False\") << endl;\n    }\n\n    cout << endl;\n}\n}\n\n\nint main(int argc, char *argv[]){\n\n    // /* Regular */\n    // int case_num = 1;\n    // if (argc > 1 && stoi(argv[1])) cin >> case_num;\n    // REP(case_no, case_num) {\n    //   cerr << endl << \"case \" << case_no + 1 << endl;\n    //   solve();\n    // }\n\n    /* AOJ */\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n \nint oldest,youngest;\n \nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n \n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n  oldest = min(oldest,space_cnt);\n  youngest = max(youngest,space_cnt);\n}\n \nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n  \n \n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n    goto skip;\n       \n      ope.push_back(mid);\n       \n    }\n \n skip:\n \n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i][0] == 'c' || ope[i][0] == 'p' || ope[i][0] == 's' || ope[i][0] == 'd' || ope[i][0] == 'a')\n    {\n      info.push_back(ope[i]);\n      break;\n    }\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n \n \n  assert(info.size() == 3);\n \n  string X,Y;\n  X = info[0],Y = info[2];\n \n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n \n      if(vec[Xindex].S <= vec[Yindex].S || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n    \n      int parent_level = vec[Yindex].S;\n \n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n    {\n \n      if(vec[i].F == X)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n \n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n \n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n \n      if(vec[Xindex].S >= vec[Yindex].S || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n \n      int parent_level = vec[Xindex].S;\n \n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n    {\n      if(vec[i].F == Y)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n \n      cout << \"False\" << endl;\n      return;\n \n \n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n \n      if(vec[Xindex].S != vec[Yindex].S || min(Xindex,Yindex)+1 >= vec.size())\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n      int sibling_level = vec[Xindex].S;\n \n      int Maxindex,Minindex;\n      string Maxname,Minname;\n \n      if(Xindex > Yindex)\n    {\n      Maxindex = Xindex,Minindex = Yindex;\n      Maxname = X,Minname = Y;\n    }\n      else\n    {\n      Maxindex = Yindex,Minindex = Xindex;\n      Maxname = Y,Minname = X;\n    }\n \n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n    {\n      if(Maxname == vec[i].F)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n      cout << \"False\" << endl;\n      return;\n \n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n \n      if(Yindex+1 >= vec.size() || vec[Xindex].S <= vec[Yindex].S)\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n      for(int i=Yindex+1;i<vec.size() && vec[i].S > vec[Yindex].S;i++)\n    {\n      if(vec[i].F == vec[Xindex].F)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n \n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(Xindex+1 >= vec.size()  || vec[Xindex].S >= vec[Yindex].S)\n    {\n      cout << \"False\" << endl;\n      return;\n    }\n \n      for(int i=Xindex+1;i < vec.size() && vec[i].S > vec[Xindex].S;i++)\n    {\n      if(vec[i].F == vec[Yindex].F)\n        {\n          cout << \"True\" << endl;\n          return;\n        }\n    }\n \n      cout << \"False\" << endl;\n      return;\n    }\n  else\n    assert(false);\n   \n \n}\n \nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n    \n      if(!(n+m))\n    break;\n      oldest = (1<<28);\n      youngest = -1;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n    {\n      getline(cin,line);\n     \n      split(vec,line);\n    }\n \n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n    index_tree[vec[i].F] = i;\n \n      for(int i=0;i<m;i++)\n    {\n      getline(cin,line);\n      \n      ParseAndSolve(vec,index_tree,line.substr(0,line.size()-1));\n      \n    }\n \n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nvector<int> G[1111];\nbool used[1111];\nvoid dfs(int v){\n  used[v]=1;\n  for(int i=0;i<(int)G[v].size();i++) dfs(G[v][i]);\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    cin.ignore();\n    for(int i=0;i<1111;i++) G[i].clear();\n    string per[n];\n    int depth[n],rG[n];\n    rG[0]=-1;\n    depth[0]=0;\n    map<string,int> ms;\n    for(int i=0;i<n;i++) getline(cin,per[i]);\n    for(int i=0;i<n;i++){\n      int k=0;\n      while(per[i][k]==' ') k++;\n      depth[i]=k;\n      per[i]=per[i].substr(k,per[i].size()-k);\n      ms[per[i]]=i;\n    }\n    int p=0;\n    stack<int> st;\n    for(int i=1;i<n;i++){\n      G[p].push_back(i);\n      rG[i]=p;\n      //cout<<per[p]<<\" \"<<per[i]<<endl;\n      if(i+1<n&&depth[i]<depth[i+1]){\n\tst.push(p);\n\tp=i;\n      }\n      if(i+1<n){\n\twhile(depth[i+1]<=(int)st.size()){\n\t  p=st.top();st.pop();\n\t}\t\n      }\n    }\n    for(int i=0;i<m;i++){\n      string st[6];\n      for(int j=0;j<6;j++) cin>>st[j];\n      st[5]=st[5].substr(0,st[5].size()-1);\n      //cout<<st[0]<<\" \"<<st[3]<<\" \"<<st[5]<<endl;\n      bool f=0;\n      if(st[3]==\"child\"){\n\tint v=ms[st[5]];\n\tfor(int j=0;j<(int)G[v].size();j++) f|=ms[st[0]]==G[v][j];\n      }\n      if(st[3]==\"parent\"){\n\tint v=ms[st[0]];\n\tif(~v) for(int j=0;j<(int)G[v].size();j++) f|=ms[st[5]]==G[v][j];\n      }\n      if(st[3]==\"sibling\"){\n\tint v=rG[ms[st[0]]];\n\tfor(int j=0;j<(int)G[v].size();j++) f|=ms[st[5]]==G[v][j];\n      }\n      if(st[3]==\"descendant\"){\n\tmemset(used,0,sizeof(used));\n\tdfs(ms[st[5]]);\n\tf=used[ms[st[0]]];\n      }\n      if(st[3]==\"ancestor\"){\n\tmemset(used,0,sizeof(used));\n\tdfs(ms[st[0]]);\n\tf=used[ms[st[5]]];\n      }\n      cout<<(f?\"True\":\"False\")<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define whole(xs) xs.begin(), xs.end()\n\nstruct Q {\n    string Relation, Name1, Name2;\n    Q(const string& Relation, const string& Name1, const string& Name2) \n        : Relation(Relation), Name1(Name1), Name2(Name2) {}\n};\nostream& operator<<(ostream& os, const Q& q) {\n    os << \"(\" << q.Relation << \", \" << q.Name1 << \", \" << q.Name2 << \")\";\n    return os;\n}\n\nint N, M;\nvector<int> Parent;\nvector<Q> Queries;\nmap<string, int> Id;\nvector<int> Prev;\n\nint CountPrefixSpaces(const string& s) {\n    int i;\n    for (i = 0; i < s.size() && s[i] == ' '; i++) ;\n    return i;\n}\n\nbool input() {\n    string l;\n    getline(cin, l);\n    istringstream is; is.str(l);\n    is >> N >> M;\n    is.clear();\n    if (N == 0 && M == 0) return false;\n    Parent.resize(N, -1);\n    Queries.clear();\n    Id.clear();\n    Prev.resize(N, -1);\n    for (int i = 0; i < N; i++) {\n        getline(cin, l);\n        is.str(l);\n        string Name;\n        is >> Name;\n        is.clear();\n        Id[Name] = i;\n        int C = CountPrefixSpaces(l);\n        Prev[C] = i;\n        if (C != 0) {\n            Parent[i] = Prev[C - 1];\n        }\n    }\n    for (int i = 0; i < M; i++) {\n        getline(cin, l);\n        is.str(l);\n        string Name1, Relation, Name2;\n        string _;\n        is >> Name1;\n        for (int k = 0; k < 2; k++) is >> _;\n        is >> Relation;\n        is >> _;\n        is >> Name2;\n        Name2 = Name2.substr(0, Name2.size() - 1);\n        is.clear();\n        Queries.push_back(Q(Relation, Name1, Name2));\n    }\n    return true;\n}\n\nvoid solve() {\n    for (int i = 0; i < M; i++) {\n        string& Relation = Queries[i].Relation,\n                Name1 = Queries[i].Name1,\n                Name2 = Queries[i].Name2;\n        int x = Id[Name1], y = Id[Name2];\n        if (Relation == \"child\") {\n            cout << (y == Parent[x] ? \"True\" : \"False\") << endl;\n        } else if (Relation == \"parent\") {\n            cout << (x == Parent[y] ? \"True\" : \"False\") << endl;\n        } else if (Relation == \"sibling\") {\n            cout << (Parent[x] == Parent[y] ? \"True\" : \"False\") << endl;\n        } else if (Relation == \"descendant\") {\n            while (x >= 0) {\n                if (y == x) {\n                    cout << \"True\" << endl;\n                    goto fin1;\n                }\n                x = Parent[x];\n            }\n            cout << \"False\" << endl;\n            fin1:;\n        } else if (Relation == \"ancestor\") {\n            while (y >= 0) {\n                if (y == x) {\n                    cout << \"True\" << endl;\n                    goto fin2;\n                }\n                y = Parent[y];\n            }\n            cout << \"False\" << endl;\n            fin2:;\n        } else {\n            assert(0);\n        }\n    }\n    cout << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint m,n;\n\nstruct nodeInfo{\n    int depth;\n};\n\nmap<string,int> id;\nvector<int> G[1010];\nnodeInfo nif[1010];\n\nint backNode(int cnode,int cnt){\n    for(int i = 0; i < cnt; i++){\n        for(int j = 0; j < G[cnode].size(); j++){\n            // ツ親ツノツーツドツづ個づ卍つ、ツつェツ深ツつウツつェツ静ウツつ「\n            if(nif[G[cnode][j]].depth<nif[cnode].depth){\n                cnode=G[cnode][j];\n                break;\n            }\n        }\n    }\n    return cnode;\n }\n\nbool isChild(int n1idx,int n2idx){\n    // ツ暗ェツづつ可コツづ鳴探ツ催オツづーツつゥツつッツづゥ\n    for(int i = 0; i < G[n2idx].size(); i++){\n        if(nif[G[n2idx][i]].depth>nif[n2idx].depth&&G[n2idx][i]==n1idx){\n            return true;\n        }\n    }\n    return false;\n}\nbool isAncestor(int n1idx,int n2idx){\n    int cnode=n2idx;\n    while(1){\n        if(cnode==n1idx)\n            return true;\n        // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n        if(cnode==0)\n            return false;\n        else{\n            for(int i = 0; i < G[cnode].size(); i++){\n                if(nif[G[cnode][i]].depth<nif[cnode].depth){\n                    cnode=G[cnode][i];\n                    break;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    bool f=false;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        if(f)\n            cout<<endl;\n        f=true;\n        id.clear();\n        string str;\n        getline(cin,str);\n        for(int i = 0; i < 1010; i++)G[i].clear();\n        int depth=-1;\n        int cp=-1;\n        for(int i = 0; i < n; i++){\n            getline(cin,str);\n            int cnt=0;\n            for(int j = 0; ;j++){\n                if(str[j]==' ')continue;\n                else{\n                    str=str.substr(j);\n                    cnt=j;\n                    break;\n                }\n            }\n            id[str]=i;\n            // cntツづ個青板つセツつッツ親ツづ可姪淞づィツ、ツつサツつアツづ可ノツーツドツづーツ挿ツ禿シツつキツづゥ\n            if(cp==-1)\n                cp=i;\n            else if(depth<cnt){\n                G[cp].push_back(i);\n                G[i].push_back(cp);\n                cp=i;\n            }\n            else{\n                int back=backNode(cp,depth-cnt+1);\n                G[back].push_back(i);\n                G[i].push_back(back);\n                cp=i;\n            }\n            depth=cnt;\n            nif[i].depth=depth;\n        }\n        for(int j = 0; j < m; j++){\n            string name1,name2;\n            string tmp;\n            string order;\n            cin>>name1>>tmp>>tmp>>order>>tmp>>name2;\n            name2=name2.substr(0,name2.size()-1);\n            int n1idx=id[name1];\n            int n2idx=id[name2];\n            bool match=false;\n            if(order==\"child\")\n                match=isChild(n1idx,n2idx);\n            else if(order==\"ancestor\")\n                match=isAncestor(n1idx,n2idx);\n            else if(order==\"sibling\")\n                int cnode=n2idx;\n            else if(order==\"parent\")\n                match=isChild(n2idx,n1idx);\n            else\n                match=isAncestor(n2idx,n1idx);\n            if(match)\n                cout<<\"True\"<<endl;\n            else\n                cout<<\"False\"<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      if(level_tree.find(mid) != level_tree.end())\n\tinfo.push_back(mid);\n      else if(mid == \"child\" || mid == \"parent\" || mid == \"sibling\" || mid == \"descendant\" || mid == \"ancestor\")\n\tinfo.pb(mid);\n    }\n\n skip:\n\n  \n\n  //assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n      //cout << \"Xindex = \" << Xindex << \" Yindex = \" << Yindex << endl;\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\t  //cout << \"vec : \" << vec[i].F << endl;\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || max(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      if(!(n+m))\n\tbreak;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct tree {\n\tstring name;\n\tint depth;\n\tvector<unique_ptr<tree>>childs;\n\ttree(const string _name,const int _depth) :name(_name),depth(_depth),childs() {\n\n\t}\n};\nunique_ptr<tree> maketree(vector<string>&sts, vector<int>&ns,int depth,int &a) {\n\tunique_ptr<tree> t(std::make_unique<tree>(sts[a],depth));\n\twhile (a+1!=sts.size()&&ns[a+1] > depth) {\n\t\ta++;\n\t\tt->childs.push_back(maketree(sts, ns, depth + 1, a));\n\t\t\n\t}\n\treturn t;\n}\n\nvector<string> split(const string &str, char delim) {\n\tvector<string> res;\n\tsize_t current = 0, found;\n\twhile ((found = str.find_first_of(delim, current)) != string::npos) {\n\t\tres.push_back(string(str, current, found - current));\n\t\tcurrent = found + 1;\n\t}\n\tres.push_back(string(str, current, str.size() - current));\n\treturn res;\n}\nint dfs(const unique_ptr<tree>&tp,int type,string a,string b,bool flag) {\n\t//a is parant of b\n\tif (type == 0) {\n\t\tif (a == tp->name) {\n\t\t\tfor (auto&& c : tp->childs) {\n\t\t\t\tif (c->name == b)return 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num=dfs(c, type, a, b,flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse if (type == 1) {\n\t\tif (flag) {\n\t\t\tif (tp->name == b)return 1;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tif (tp->name == a)flag = true;\n\t\t\tfor (auto &&c : tp->childs) {\n\t\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\t\tif (num != -1)return num;\n\t\t\t}\n\t\t\tif (flag)return 0;\n\t\t\telse return -1;\n\t\t}\n\t}\n\telse {\n\t\tint same = 0;\n\t\tfor (auto&&c : tp->childs) {\n\t\t\tif (c->name == a)same++;\n\t\t\tif (c->name == b)same++;\n\t\t\tint num = dfs(c, type, a, b, flag);\n\t\t\tif (num != -1)return num;\n\t\t}\n\t\tif (same == 2)return 1;\n\t\telse if (same == 1)return 0;\n\t\telse return -1;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tunique_ptr<tree> t;\n\t\t{\n\t\t\tvector<string>sts;\n\t\t\tvector<int>ns;\n\t\t\tstring st; getline(cin, st);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tgetline(cin, st);\n\t\t\t\tint n = st.find_first_not_of(' ');\n\t\t\t\tsts.push_back(st.substr(n));\n\t\t\t\tns.push_back(n);\n\t\t\t}\n\n\t\t\tint a = 0;\n\t\t\tt = maketree(sts, ns, 0, a);\n\t\t}\n\t\t\n\t\twhile (M--) {\n\t\t\tstring st;\n\t\t\tgetline(cin, st);\n\t\t\tvector<string>sts(split(st, ' '));\n\t\t\tstring a = sts[0];\n\t\t\tstring b = sts[5].substr(0, sts[5].size() - 1);\n\t\t\tint ans;\n\t\t\tif (sts[3] == \"child\") {\n\t\t\t\tans = dfs(t, 0, b, a, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"ancestor\") {\n\t\t\t\tans = dfs(t,1, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"sibling\") {\n\t\t\t\tans = dfs(t, 2, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"parent\") {\n\t\t\t\tans = dfs(t, 0, a, b, false);\n\t\t\t}\n\t\t\telse if (sts[3] == \"descendant\") {\n\t\t\t\tans = dfs(t, 1, b, a, false);\n\t\t\t}\n\t\t\tif (ans == 1)cout << \"True\" << endl;\n\t\t\telse if (ans == 0)cout << \"False\" << endl;\n\t\t\telse assert(false);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef vector<string>VS;\nstruct S{string p;VS v;};\nmap<string,S>m;\nint A(string a,string n)\n{\n\tif(m[n].p.empty())return 0;\n\tif(m[n].p==a)return 1;\n\treturn A(a,m[n].p);\n}\nint main()\n{\n\tint N,M,i,c,f;\n\tstring s,t,x,y;\n\twhile(cin>>N>>M,N)\n\t{\n\t\tVS v;\n\t\tm.clear();\n\t\tgetline(cin,s);\n\t\tgetline(cin,s);\n\t\tm[s].p=\"\";\n\t\tv.push_back(s);\n\t\tfor(i=1;i<N;++i)\n\t\t{\n\t\t\tgetline(cin,s);\n\t\t\tc=count(s.begin(),s.end(),' ');\n\t\t\ts=s.substr(c);\n\t\t\twhile(v.size()>c)v.pop_back();\n\t\t\tm[s].p=v.back();\n\t\t\tm[v.back()].v.push_back(s);\n\t\t\tv.push_back(s);\n\t\t}\n\t\tfor(i=0;i<M;++i)\n\t\t{\n\t\t\tgetline(cin,s);\n\t\t\tv.clear();\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tc=s.find(' ');\n\t\t\t\tif(c==string::npos)break;\n\t\t\t\tv.push_back(s.substr(0,c));\n\t\t\t\ts=s.substr(c+1);\n\t\t\t}\n\t\t\tx=v[0];\n\t\t\ty=s;\n\t\t\ty.erase(y.size()-1);\n\t\t\tt=v[3];\n\t\t\tif(t==\"child\")f=(m[x].p==y);\n\t\t\tif(t==\"parent\")f=(m[y].p==x);\n\t\t\tif(t==\"sibling\")\n\t\t\t{\n\t\t\t\tv=m[m[x].p].v;\n\t\t\t\tf=(find(v.begin(),v.end(),y)!=v.end());\n\t\t\t}\n\t\t\tif(t==\"descendant\")f=A(y,x);\n\t\t\tif(t==\"ancestor\")f=A(x,y);\n\t\t\tcout<<(f?\"True\\n\":\"False\\n\");\n\t\t}cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        map<string, vector<int> > name;\n        int prev = -1;\n        vector<int> tmp;\n        cin.ignore();\n        for(int i=0; i<n; ++i){\n            string s;\n            getline(cin, s);\n            int j = s.find_first_not_of(' ');\n            s = s.substr(j);\n            if(j < prev){\n                while(j < prev){\n                    tmp.pop_back();\n                    -- prev;\n                }\n                ++ tmp.back();\n            }else if(j == prev){\n                ++ tmp.back();\n            }else{\n                tmp.push_back(0);\n                ++ prev;\n            }\n            name.insert(make_pair(s, tmp));\n        }\n\n        for(int i=0; i<m; ++i){\n            string x0, y0, s;\n            cin >> x0 >> s >> s >> s >> y0 >> y0;\n            y0.resize(y0.size() - 1);\n\n            vector<int> x = name[x0];\n            vector<int> y = name[y0];\n\n            if(s == \"child\" || s == \"parent\"){\n                if(s == \"parent\")\n                    swap(x, y);\n                x.resize(x.size() - 1);\n            }else if(s == \"sibling\"){\n                x.resize(x.size() - 1);\n                y.resize(y.size() - 1);\n            }else{\n                if(s == \"ancestor\")\n                    swap(x, y);\n                if(x.size() > y.size())\n                    x.resize(y.size());\n            }\n\n            if(x == y)\n                cout << \"True\" << endl;\n            else\n                cout << \"False\" << endl;\n        }\n\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap<string,int> mp;\nint ind[1001],par[1001];\nbool ko(int a,int b){\n  return par[a]==b;\n}\n\nbool sos(int a,int b){\n  while(a!=b&&a!=-1)\n    a=par[a];\n  return a==b;\n}\n\nint main(){\n  int n,m,T=0;\n  string s;\n  char c;\n  while(cin>>n>>m,n){\n    if(T++)cout<<endl;\n    scanf(\"%c\",&c);\n    memset(ind,0,sizeof(ind));\n    memset(par,0,sizeof(par));\n    mp.clear();\n    par[0]=-1;\n    for(int i=0;i<n;i++){\n      int k=0;\n      while(scanf(\"%c\",&c)&&c==' ')k++;\n      cin>>s;\n      s=c+s;\n       scanf(\"%c\",&c);\n      mp[s]=i;\n      ind[i]=k;\n      for(int j=i-1;j>=0;j--)\n\tif(ind[j]==k-1){par[i]=j;break;}\n     }\n\n    for(int i=0;i<m;i++){\n      string q[6];\n      for(int j=0;j<6;j++)cin>>q[j];\n      bool ans;\n      q[5]=q[5].substr(0,q[5].size()-1); \n      int a=mp[q[0]],b=mp[q[5]];\n      if(q[3]==\"child\")ans=ko(a,b);\n      if(q[3]==\"parent\")ans=ko(b,a);\n      if(q[3]==\"sibling\")ans=(par[a]==par[b]);\n      if(q[3]==\"descendant\")ans=sos(a,b);\n      if(q[3]==\"ancestor\")ans=sos(b,a);\n      if(ans)cout<<\"True\"<<endl;\n      else cout<<\"False\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n        set <string> S;\n        for ( int i = 0; i < n; i++ ) {\n            int L = i+1;\n            while ( L < n ) {\n                if ( D[i] == D[L] ) break;\n                L++;\n            }\n            for ( int j = i+1; j < L; j++ ) {\n                if ( D[i] + 1 == D[j] ) {\n                    // i is j's child\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] - 1 == D[j] ) {\n                    // i is j's parent\n                    T[i][j] |= 1<<1;\n                    T[j][i] |= 1<<2;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    // sibling\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }\n                /*if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else if ( D[i] > D[j] ) {\n                    break;\n                }*/\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = i+1; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    break;\n                } else if ( D[i] < D[j] ) {\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<stack>\nusing namespace std;\n\nstruct LCA{\n    int n, bit; // n < 1<<bit\n    vector<int> depth;\n    vector<vector<int>> par, v;\n\n    LCA(int n) : n(n){\n        depth.resize(n, -1);\n        bit = 0;\n        while(1<<bit <= n)  bit++;\n        par.resize(bit);\n        for(int i = 0; i < bit; i++)    par[i].resize(n);\n        v.resize(n);\n    }\n\n    void add_edge(int a, int b){\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n\n    void dfs(int now, int p, int d){\n        par[0][now] = p;\n        depth[now] = d;\n        for(int child : v[now]){\n            if(child == p)  continue;\n            dfs(child, now, d+1);\n        }\n    }\n\n    void build(){\n        for(int i = 0; i < n; i++){\n            if(depth[i] == -1)    dfs(i, -1, 0);\n        }\n        for(int k = 0; k+1 < bit; k++){\n            for(int i = 0; i < n; i++){\n                if(par[k][i] < 0)   par[k+1][i] = -1;\n                else                par[k+1][i] = par[k][par[k][i]];\n            }\n        }\n    }\n\n    int lca(int a, int b){\n        // make b deeper\n        if(depth[a] > depth[b]) swap(a, b);\n        for(int k = 0; k < 30; k++){\n            // depth(b)-depth(a) is equal to or bigger than 2^k\n            if(((depth[b]-depth[a])>>k)&1){\n                b = par[k][b];\n            }\n        }\n        if(a == b)  return a;\n        for(int k = bit-1; k >= 0; k--){\n            if(par[k][a] != par[k][b]){\n                a = par[k][a];\n                b = par[k][b];\n            }\n        }\n        return par[0][a];\n    }\n\n    int dist(int a, int b){\n        int l = lca(a, b);\n        return depth[a]-depth[l] + depth[b]-depth[l];\n    }\n};\n\nint main(){\n    int n, m;\n    while(scanf(\"%d %d\\n\", &n, &m), n+m){\n        vector<string> name(n);\n        vector<int> depth(n);\n        map<string,int> id;\n        LCA l(n);\n        stack<pair<int,int>> his;\n        for(int i = 0; i < n; i++){\n            string s;\n            getline(cin, s);\n            int dep;\n            for(dep = 0; s[dep]==' '; dep++);\n            name[i] = s.substr(dep);\n            id[name[i]] = i;\n            depth[i] = dep;\n            while(!his.empty()&&his.top().second+1!=dep)    his.pop();\n            if(!his.empty())    l.add_edge(i, his.top().first);\n            his.push({i, dep});\n        }\n        l.build();\n        while(m--){\n            string a, b, c;\n            cin >> a >> b >> b >> b >> c >> c;\n            c.pop_back();\n            int x = id[a], y = id[c];\n            bool judge =    (b==\"child\" && l.lca(x,y)==y && depth[y]+1==depth[x]) || \n                            (b==\"parent\" && l.lca(x,y)==x && depth[x]+1==depth[y]) ||\n                            (b==\"sibling\" && depth[x]==depth[y] && depth[x]==depth[l.lca(x,y)]+1) ||\n                            (b==\"ancestor\" && l.lca(x,y)==x) || \n                            (b==\"descendant\" && l.lca(x,y)==y);\n            cout << (judge ? \"True\" : \"False\") << endl;\n        }\n        cout << endl;\n        cin.ignore(0);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef vector<string>VS;\nstruct S{string p;VS v;};\nmap<string,S>m;\nint A(string a,string n)\n{\n\tif(m[n].p.empty())return 0;\n\tif(m[n].p==a)return 1;\n\treturn A(a,m[n].p);\n}\nint main()\n{\n\tint N,M,i,c,f;\n\tstring s,t,x,y;\n\twhile(cin>>N>>M,N)\n\t{\n\t\tVS v;\n\t\tm.clear();\n\t\tgetline(cin,s);\n\t\tgetline(cin,s);\n\t\tm[s].p=\"\";\n\t\tv.push_back(s);\n\t\tfor(i=1;i<N;++i)\n\t\t{\n\t\t\tgetline(cin,s);\n\t\t\tc=count(s.begin(),s.end(),' ');\n\t\t\ts=s.substr(c);\n\t\t\twhile(v.size()>c)v.pop_back();\n\t\t\tm[s].p=v.back();\n\t\t\tm[v.back()].v.push_back(s);\n\t\t\tv.push_back(s);\n\t\t}\n\t\tfor(i=0;i<M;++i)\n\t\t{\n\t\t\tgetline(cin,s);\n\t\t\tv.clear();\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tc=s.find(' ');\n\t\t\t\tif(c==string::npos)break;\n\t\t\t\tv.push_back(s.substr(0,c));\n\t\t\t\ts=s.substr(c+1);\n\t\t\t}\n\t\t\tx=v[0];\n\t\t\ty=s;\n\t\t\ty.erase(y.size()-1);\n\t\t\tt=v[3];\n\t\t\tif(t==\"child\")f=(m[x].p==y);\n\t\t\tif(t==\"parent\")f=(m[y].p==x);\n\t\t\tif(t==\"sibling\")f=(m[x].p==m[y].p);\n\t\t\tif(t==\"descendant\")f=A(y,x);\n\t\t\tif(t==\"ancestor\")f=A(x,y);\n\t\t\tcout<<(f?\"True\\n\":\"False\\n\");\n\t\t}cout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      /*\n      if(level_tree.find(mid) != level_tree.end())\n\tinfo.push_back(mid);\n      else if(mid == \"child\" || mid == \"parent\" || mid == \"sibling\" || mid == \"descendant\" || mid == \"ancestor\")\n\tinfo.pb(mid);\n      */\n      ope.push_back(mid);\n      //cout << \"ope = \" << mid << endl;\n    }\n\n skip:\n\n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i] == \"child\" || ope[i] == \"parent\" || ope[i] == \"sibling\" || ope[i] == \"descendant\" || ope[i] == \"ancestor\")\n\t{\n\t  info.push_back(ope[i]);\n\t  break;\n\t}\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n\n  //cout << info[0] << \" \" << info[1] <<\" \" << info[2] << endl; \n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n      //cout << \"Xindex = \" << Xindex << \" Yindex = \" << Yindex << endl;\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\t  //cout << \"vec : \" << vec[i].F << endl;\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || max(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      cerr << n << \" \" << m << endl;\n      if(!(n+m))\n\tbreak;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  cerr << line << endl;\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  cerr << line << endl;\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nstruct node{\n  string name;\n  vector<node *> childlen;\n  \n  node(string name):name(name){}\n};\n\nvoid add_child(node * p, string new_name, const vector<string> &path, int depth){\n  if( depth == (int)path.size() ){\n    p->childlen.push_back( new node(new_name) );\n    return ;\n  }\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( path[depth] == p->childlen[i]->name ){\n      add_child( p->childlen[i], new_name, path, depth+1 );\n    }\n  }\n  return ;\n}\n\nvoid print(node *p){\n  cout << p->name << endl;\n  cout << \"Childlen :\" << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    cout << p->childlen[i]->name << endl;\n  }\n  cout << \"-----\" << endl << endl;\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    print( p->childlen[i] );\n  }\n}\n\nbool judge(node * p, const string &a, const string &b, const string &rel, bool Xfnd){\n  if(p->name == b){\n    return Xfnd;\n  }\n\n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    for(int j = i+1; j < (int)p->childlen.size(); ++j){\n      if( (p->childlen[i]->name == a && p->childlen[j]->name == b) ||\n          (p->childlen[i]->name == b && p->childlen[j]->name == a) ){\n        return rel == \"sibling\" && true;\n      }\n    }\n  }\n  \n  for(int i = 0; i < (int)p->childlen.size(); ++i){\n    if( p->name==a && p->childlen[i]->name == b && rel == \"child\" ) return true;\n    if( judge(p->childlen[i], a, b, rel, p->name==a|Xfnd) && rel != \"child\" ) return true;\n  }\n  return false;\n}\n\nint main()\n{\n  while(true){\n    int n,m;\n    string dam;\n    cin >> n >> m;\n    if( n == 0  && m == 0 ) break;\n\n    getline(cin,dam);\n    node * root = new node(\"___ROOT\");\n\n    int spaces = -1;\n    vector<string> path;\n    for(int i = 0; i < n; ++i){\n      string s;\n      getline(cin,s);\n      \n      int csp = 0;\n      for(int j = 0; j < (int)s.length(); ++j){\n        if( s[j] == ' ' ) ++csp;\n        else break;\n      }\n      s = s.substr( csp );\n\n      if( csp < spaces ){\n        path.pop_back();\n        for(int j = 0; j < spaces - csp; ++j){\n          path.pop_back();\n        }\n        add_child(root, s, path, 0);\n        path.push_back(s);\n\n      }else if( csp == spaces ){\n        path.pop_back();\n        add_child(root, s, path, 0);\n        path.push_back(s);\n        \n      }else if( csp == spaces + 1 ){\n        add_child(root, s, path, 0);\n        path.push_back( s );\n      }\n\n      spaces = csp;\n    }\n    // print(root);\n    \n    for(int i = 0; i < m; ++i){\n      string X,Y,rel;\n      cin >> X >> dam >> dam >> rel >> dam >> Y;\n      Y = Y.substr(0, Y.length()-1);\n      if( rel == \"parent\" ){\n        rel = \"child\";\n        swap(X,Y);\n      }\n      if( rel == \"ancestor\" ){\n        rel = \"descendant\";\n        swap(X,Y);\n      }\n      \n      if( judge(root,Y,X,rel,false) ){\n        cout << \"True\" << endl;\n      }else{\n        cout <<\"False\"<<endl;\n      }\n      \n    }\n    cout << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint m,n;\n\nstruct nodeInfo{\n    int depth;\n};\n\nmap<string,int> id;\nvector<int> G[1010];\nnodeInfo nif[1010];\n\nint main(){\n    bool f=false;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        if(f)\n            cout<<endl;\n        f=true;\n        id.clear();\n        string str;\n        getline(cin,str);\n        for(int i = 0; i < 1010; i++)G[i].clear();\n        int depth=-1;\n        int cp=-1;\n        for(int i = 0; i < n; i++){\n            getline(cin,str);\n            int cnt=0;\n            for(int j = 0; ;j++){\n                if(str[j]==' ')continue;\n                else{\n                    str=str.substr(j);\n                    cnt=j;\n                    break;\n                }\n            }\n            id[str]=i;\n            // cntツづ個青板つセツつッツ親ツづ可姪淞づィツ、ツつサツつアツづ可ノツーツドツづーツ挿ツ禿シツつキツづゥ\n            if(cp==-1)\n                cp=i;\n            else if(depth<cnt){\n                G[cp].push_back(i);\n                G[i].push_back(cp);\n                cp=i;\n            }\n            else if(depth==cnt){\n                int back=G[cp][0];\n                for(int j = 0; j < G[cp].size(); j++){\n                    if(nif[G[cp][j]].depth<nif[cp].depth){\n                        back=G[cp][j];\n                        break;\n                    }\n                }\n                G[back].push_back(i);\n                G[i].push_back(back);\n                cp=i;\n            }\n            else if(depth>cnt){\n                // ツ債キツ閉ェツづ個深ツつウツつセツつッツ親ツづ鳴姪淞づゥ\n                for(int k = 0; k <= depth-cnt; k++){\n                    for(int j = 0; j < G[cp].size(); j++){\n                        if(nif[G[cp][j]].depth<nif[cp].depth){\n                            cp=G[cp][j];\n                            break;\n                        }\n                    }\n                }\n                G[cp].push_back(i);\n                G[i].push_back(cp);\n                cp=i;\n            }\n            depth=cnt;\n            nif[i].depth=depth;\n        }\n        for(int j = 0; j < m; j++){\n            string name1,name2;\n            string tmp;\n            string order;\n            cin>>name1>>tmp>>tmp>>order>>tmp>>name2;\n            name2=name2.substr(0,name2.size()-1);\n            int n1idx=id[name1];\n            int n2idx=id[name2];\n            bool match=false;\n            if(order==\"child\"){\n                for(int i = 0; i < G[n2idx].size(); i++){\n                    if(nif[G[n2idx][i]].depth>nif[n2idx].depth&&G[n2idx][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else if(order==\"ancestor\"){\n                int cnode=n2idx;\n                while(1){\n                    if(cnode==n1idx){\n                        match=true;\n                        break;\n                    }\n                    // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n                    if(cnode==0)\n                        break;\n                    else{\n                        for(int i = 0; i < G[cnode].size(); i++){\n                            if(nif[G[cnode][i]].depth<nif[cnode].depth){\n                                cnode=G[cnode][i];\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            else if(order==\"sibling\"){\n                int cnode=n2idx;\n                // ツ暗ェツづつ親ツづ可姪淞づゥ\n                for(int i = 0; i < G[cnode].size(); i++){\n                    if(nif[G[cnode][i]].depth<nif[n2idx].depth){\n                        cnode=G[cnode][i];\n                        break;\n                    }\n                }\n                for(int i = 0; i < G[cnode].size(); i++){\n                    if(G[cnode][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else if(order==\"parent\"){\n                swap(n2idx,n1idx);\n                for(int i = 0; i < G[n2idx].size(); i++){\n                    if(nif[G[n2idx][i]].depth>nif[n2idx].depth&&G[n2idx][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else{\n                swap(n2idx,n1idx);\n                int cnode=n2idx;\n                while(1){\n                    if(cnode==n1idx){\n                        match=true;\n                        break;\n                    }\n                    // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n                    if(cnode==0)\n                        break;\n                    else{\n                        for(int i = 0; i < G[cnode].size(); i++){\n                            if(nif[G[cnode][i]].depth<nif[cnode].depth){\n                                cnode=G[cnode][i];\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            if(match)\n                cout<<\"True\"<<endl;\n            else\n                cout<<\"False\"<<endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nmap<string, int> id;\nint par[2000];\nint depth[2000];\n\nvoid input(int n){\n\tstring s, name;\n\tint cnt = 0;\n\tmemset(par, -1, sizeof(par));\n\tid.clear();\n\trep(i, n){\n\t\tcnt = 0;\n\t\tgetline(cin, s);\n\t\twhile(cnt < (int)s.size() && s[cnt] == ' ') cnt++;\n\t\tname = string(s.begin() + cnt, s.end());\n\t\tid[name] = i;\n\t\tdepth[i] = cnt;\n\n\t\tif(i != 0){\n\t\t\tint j = i;\n\t\t\twhile(depth[i] - 1 != depth[j]) j--;\n\t\t\tpar[i] = j;\n\t\t}\n\t}\n}\n\nbool xIsC(int x, int y){\n\treturn par[x] == y;\n}\n\nbool xIsS(int x, int y){\n\treturn par[x] == par[y];\n}\n\nbool xIsA(int x, int y){\n\twhile(par[y] != -1){\n\t\tif(par[y] == x) return true;\n\t\ty = par[y];\n\t}\n\treturn false;\n}\n\nbool solve(const string &s){\n\tistringstream in(s);\n\tstring X, Y, A, c;\n\tin >> X >> c >> c >> A >> c >> Y;\n\tY = string(Y.begin(), Y.end() - 1);\n\tint x = id[X];\n\tint y = id[Y];\n\tif(A == \"child\"){\n\t\treturn xIsC(x, y);\n\t}else if(A == \"parent\"){\n\t\treturn xIsC(y, x);\n\t}else if(A == \"sibling\"){\n\t\treturn xIsS(x, y);\n\t}else if(A == \"ancestor\"){\n\t\treturn xIsA(x, y);\n\t}else{\n\t\treturn xIsA(y, x);\n\t}\n}\n\nint main(){\n\tint n, m;\n\tstring s;\n\twhile(cin >> n >> m && (n || m)){\n\t\tgetline(cin, s);\n\t\tinput(n);\n\t\trep(i, m){\n\t\t\tgetline(cin, s);\n\t\t\tif(solve(s)) cout << \"True\" << endl;\n\t\t\telse cout << \"False\" << endl;\n\t\t}\n\t\tcout << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef pair <string, int> PSI;\ntypedef stack <PSI> Stack;\n\nconst int size = 1001;\nint n, m;\nint D[size];\nstring N[size];\nint T[size][size]; // type\nmap <string, int> ID;\nint IDC;\n\nvoid addName( string name ) {\n    if ( ID.find( name ) != ID.end() ) {\n        return;\n    }\n    ID[name] = IDC++;\n}\n\nint getIndex( string name ) {\n    if ( ID.find( name ) == ID.end() ) {\n        return -1;\n    }\n    return ID[name];\n}\n\nint getDepth( string line ) {\n    int depth = 0;\n    for ( string ::iterator it_i = line.begin(); it_i != line.end(); ++it_i ) {\n        if ( *it_i == ' ' ) {\n            depth += 1;\n        }\n    }\n    return depth;\n}\n\nstring getName( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameFirst( string line ) {\n    string name;\n    istringstream is( line );\n    is >> name;\n    return name;\n}\n\nstring getNameSecond( string line ) {\n    string name;\n    istringstream is( line );\n    for ( int i = 0; i < 5; i++ ) {\n        is >> name;\n    }\n    is >> name;\n    return name.substr( 0, name.size()-1 );\n}\n\nint getFindRelation( string line ) {\n    string relation;\n    istringstream is( line );\n    for ( int i = 0; i < 3; i++ ) {\n        is >> relation;\n    }\n    is >> relation;\n    if ( relation == \"child\" ) {\n        return 1;\n    } else if ( relation == \"parent\" ) {\n        return 2;\n    } else if ( relation == \"sibling\" ) {\n        return 3;\n    } else if ( relation == \"ancestor\" ) {\n        return 4;\n    } else if ( relation == \"descendant\" ) {\n        return 5;\n    }\n    return 0;\n}\n\nbool check( int a, int b, int c ) {\n    return ( T[a][b] & 1<<c ) != 0;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        cin.clear();\n        cin.ignore();\n        if ( n == 0 && m == 0 ) break;\n\n        // init\n        IDC = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                T[i][j] = 0;\n            }\n        }\n\n        // input\n        for ( int i = 0; i < n; i++ ) {\n            string line;\n            getline( cin, line );\n            D[i] = getDepth( line );\n            N[i] = getName( line );\n            addName( N[i] );\n        }\n\n        set <string> S;\n        for ( int i = 0; i < n; i++ ) {\n            int L = i+1;\n            while ( L < n ) {\n                if ( D[i] == D[L] ) break;\n                L++;\n            }\n            for ( int j = i+1; j < L; j++ ) {\n                if ( D[i] + 1 == D[j] ) {\n                    // i is j's child\n                    T[i][j] |= 1<<2;\n                    T[j][i] |= 1<<1;\n                } else if ( D[i] - 1 == D[j] ) {\n                    // i is j's parent\n                    T[i][j] |= 1<<1;\n                    T[j][i] |= 1<<2;\n                }\n            }\n        }\n\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( D[i] == D[j] ) {\n                    // sibling\n                    T[i][j] |= 1<<3;\n                    T[j][i] |= 1<<3;\n                } else if ( D[i] < D[j] ) {\n                    // i is j's ancestor\n                    T[i][j] |= 1<<4;\n                    T[j][i] |= 1<<5;\n                } else if ( D[i] > D[j] ) {\n                    // i is j's descendant\n                    T[i][j] |= 1<<5;\n                    T[j][i] |= 1<<4;\n                }\n            }\n        }\n\n        // questions\n        for ( int i = 0; i < m; i++ ) {\n            string line;\n            getline( cin, line );\n            string A = getNameFirst( line );\n            string B = getNameSecond( line );\n            int a = getIndex( A );\n            int b = getIndex( B );\n            int c = getFindRelation( line );\n            bool flag = true;\n            if ( a == -1 || b == -1 ) {\n                flag = false;\n            }\n            cout << ( flag && check( a, b, c ) ? \"True\" : \"False\" ) << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n\nusing namespace std;\n\nstruct Info{\n\tchar name[21];\n\tint parent;\n\tvector<int> children;\n};\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid func(int num_of_family,int num_of_statement){\n\tint index = 0,space_num,last_appeared[71],work_index;\n\tInfo info[num_of_family];\n\n\tchar line[100],work[21];\n\n\tscanf(\"%s\",line);\n\tstrcpy(info[0].name,line);\n\tinfo[0].parent = -1;\n\tlast_appeared[0] = 0;\n\tgetchar();\n\n\tfor(int loop = 1; loop < num_of_family;loop++){\n\t\tfgets(line,100,stdin);\n\t\tfor(space_num = 0; line[space_num] == ' ';space_num++);\n\n\t\tinfo[last_appeared[space_num-1]].children.push_back(++index);\n\t\tinfo[index].parent = last_appeared[space_num-1];\n\n\t\twork_index = 0;\n\t\tfor(int i = space_num; line[i] != '\\n' && line[i] != '\\0';i++){\n\t\t\twork[work_index++] = line[i];\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tstrcpy(info[index].name,work);\n\t\tlast_appeared[space_num] = index;\n\t}\n\n\tchar X[21],is[3],buf1[6],buf2[15],buf3[15],Y[22];\n\tbool FLG;\n\n\tfor(int loop = 0; loop < num_of_statement; loop++){\n\t\tscanf(\"%s %s %s %s %s %s\",X,is,buf1,buf2,buf3,Y);\n\n\t\tfor(int p = 0; Y[p] != '\\0';p++){\n\t\t\tif(Y[p] == '.'){\n\t\t\t\tY[p] = '\\0';\n\t\t\t}\n\t\t}\n\n\t\tFLG = false;\n\t\tswitch(buf2[0]){\n\t\tcase 'c':\n\t\t\tfor(int i = 0; i <= index; i++){\n\t\t\t\tif(strCmp(info[i].name,X)){\n\t\t\t\t\tif(info[i].parent != -1 && strCmp(info[info[i].parent].name,Y) == true){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'p': //X is the parent of Y\n\t\t\tfor(int i = 0; i <= index; i++){\n\t\t\t\tif(strCmp(info[i].name,Y)){\n\t\t\t\t\tif(info[i].parent != -1 && strCmp(info[info[i].parent].name,X) == true){\n\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 's': //X is a silbling of Y\n\t\t\tfor(int i = 0; i <= index; i++){\n\t\t\t\tif(strCmp(info[i].name,Y)){\n\t\t\t\t\tif(info[i].parent == -1)break;\n\n\t\t\t\t\tfor(int k = 0; k < info[info[i].parent].children.size();k++){\n\t\t\t\t\t\tif(strCmp(info[info[info[i].parent].children[k]].name,X)){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'd': //X is a descendant of Y\n\t\t\tfor(int i = 0; i <= index; i++){\n\t\t\t\tif(strCmp(info[i].name,X)){\n\t\t\t\t\tint t = info[i].parent;\n\n\t\t\t\t\twhile(t != -1){\n\t\t\t\t\t\tif(strCmp(info[t].name,Y)){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt = info[t].parent;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'a': //X is an ancestor of Y\n\t\t\tfor(int i = 0; i <= index; i++){\n\t\t\t\tif(strCmp(info[i].name,Y)){\n\t\t\t\t\tint t = info[i].parent;\n\n\t\t\t\t\twhile(t != -1){\n\t\t\t\t\t\tif(strCmp(info[t].name,X)){\n\t\t\t\t\t\t\tFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt = info[t].parent;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t}\n\t\tif(FLG){\n\t\t\tprintf(\"True\\n\");\n\t\t}else{\n\t\t\tprintf(\"False\\n\");\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n}\n\n\nint main(){\n\n\tint num_of_family,num_of_statement;\n\twhile(true){\n\t\tscanf(\"%d %d\",&num_of_family,&num_of_statement);\n\t\tif(num_of_family == 0 && num_of_statement == 0)break;\n\n\t\tfunc(num_of_family,num_of_statement);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h=0,i,j,k,l;\n  int n,m;\n  while(cin>>n>>m&&n+m){\n    if(h)\n      cout<<endl;\n    else\n      h=1;\n    string t;\n    getline(cin,t);\n    int a[1000];\n    memset(a,0,sizeof(a));\n    string s[1000];\n    for(i=0;i<n;i++){\n      string t;\n      getline(cin,t);\n      for(;t[0]==' ';a[i]++)\n\tt.erase(0,1);\n      s[i]=t;\n    }\n    for(i=0;i<m;i++){\n      string t,u,v;\n      cin>>t>>u>>u>>u>>v>>v;\n      v.erase(v.length()-1,1);\n      if(0){\n      }else if(u[0]=='c'){\n\tfor(j=0;s[j]!=t;j++);\n\tif(j==0)\n\t  cout<<\"False\"<<endl;\n\telse{\n\t  for(k=j;a[k]!=a[j]-1;k--);\n\t  if(s[k]==v)\n\t    cout<<\"True\"<<endl;\n\t  else\n\t    cout<<\"False\"<<endl;\n\t}\n      }else if(u[0]=='p'){\n\tfor(j=0;s[j]!=v;j++);\n\tif(j==0)\n\t  cout<<\"False\"<<endl;\n\telse{\n\t  for(k=j;a[k]!=a[j]-1;k--);\n\t  if(s[k]==t)\n\t    cout<<\"True\"<<endl;\n\t  else\n\t    cout<<\"False\"<<endl;\n\t}\t\n      }else if(u[0]=='s'){\n\tfor(j=0;s[j]!=t&&s[j]!=v;j++);\n\tfor(k=j+1;s[k]!=t&&s[k]!=v;k++);\n\tif(a[j]!=a[k])\n\t  cout<<\"False\"<<endl;\n\telse{\n\t  for(j++;j<k;j++){\n\t    if(a[j]<a[k])\n\t      break;\n\t  }\n\t  if(j==k)\n\t    cout<<\"True\"<<endl;\n\t  else\n\t    cout<<\"False\"<<endl;\n\t}\n      }else if(u[0]=='d'){\n\tfor(j=0;s[j]!=t;j++);\n\tl=a[j];\n\tfor(k=j-1;k>-1;k--){\n\t  if(a[k]<l){\n\t    if(s[k]==v)\n\t      break;\n\t    l=a[k];\n\t  }\n\t}\n\tif(k==-1)\n\t  cout<<\"False\"<<endl;\n\telse\n\t  cout<<\"True\"<<endl;\n      }else if(u[0]=='a'){\n\tfor(j=0;s[j]!=v;j++);\n\tl=a[j];\n\tfor(k=j-1;k>-1;k--){\n\t  if(a[k]<l){\n\t    if(s[k]==t)\n\t      break;\n\t    l=a[k];\n\t  }\n\t}\n\tif(k==-1)\n\t  cout<<\"False\"<<endl;\n\telse\n\t  cout<<\"True\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> P;\nstruct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n};\n\nstruct S {\n\tstring name;\n\tint parent;\n\tvector<int> child;\n\tS(string s, int p, vector<int> c) : name(s), parent(p), child(c){}\n};\n\nvector<S> G;\n\nint main()\n{\n\tint N, M;\n\twhile (cin>>N>>M, N||M) {\n\t\tcin.ignore();\n\t\t\n\t\tmap<string, int> list;\n\t\t\n\t\tint idx=0;\n\t\t\n\t\tvector<string> s(N);\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tgetline(cin, s[i]);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tint count = 0;\n\t\t\tint p=0;\n\t\t\t\n\t\t\twhile (s[i][p]==' ') {\n\t\t\t\tcount++;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\t\n\t\t\tstring n = s[i].substr(p);\n\t\t\tif (count==0) {\n\t\t\t\tG.push_back(S(n, -1, vector<int>()));\n\t\t\t\tlist[n] = idx++;\n\t\t\t} else {\n\t\t\t\tstring parent;\n\t\t\t\tfor (int j=i; j>=0; j--) {\n\t\t\t\t\tint cc=0;\n\t\t\t\t\twhile (s[j][cc]==' ') cc++;\n\t\t\t\t\tif (cc==count-1) {\n\t\t\t\t\t\tparent = s[j].substr(cc);\n\t\t\t\t\t\n\t\t\t\t\t\tG.push_back(S(n, list[parent], vector<int>()));\n\t\t\t\t\t\tlist[n] = idx++;\n\t\t\t\t\t\tG[list[parent]].child.push_back(list[n]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int z=0; z<M; z++) {\n\t\t\tstring t; getline(cin, t);\n\t\t\tt.erase(t.end()-1);\n\t\t\t\n\t\t\tistringstream ss(t);\n\t\t\tvector<string> tt(6);\n\t\t\tfor (int i=0; i<6; i++)\n\t\t\t\tss>>tt[i];\n\t\t\t\n\t\t\tstring X = tt[0], Y = tt[5];\n\t\t\t\n\t\t\tbool ans=false;\n\t\t\t\n\t\t\tif (tt[3][0]=='c') {\n\t\t\t\tbool ok=false;\n\t\t\t\tfor (int i=0; i<G[list[Y]].child.size(); i++) {\n\t\t\t\t\tif (list[X] == G[list[Y]].child[i]) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = ok;\n\t\t\t} else if (tt[3][0]=='p') {\n\t\t\t\tif (list[X] == G[list[Y]].parent) {\n\t\t\t\t\tans = true;\n\t\t\t\t}\n\t\t\t} else if (tt[3][0]=='s') {\n\t\t\t\tif (G[list[X]].parent == G[list[Y]].parent && G[list[X]].parent!=-1)\n\t\t\t\t\tans = true;\n\t\t\t} else if (tt[3][0]=='d') {\n\t\t\t\tswap(X, Y);\n\t\t\t\t\n\t\t\t\tS now = G[list[Y]];\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (now.parent==-1) break;\n\t\t\t\t\tif (now.parent == list[X])\n\t\t\t\t\t\tans = true;\n\t\t\t\t\tnow = G[now.parent];\n\t\t\t\t}\n\t\t\t} else if (tt[3][0]=='a') {\n\t\t\t\tS now = G[list[Y]];\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (now.parent==-1) break;\n\t\t\t\t\tif (now.parent == list[X])\n\t\t\t\t\t\tans = true;\n\t\t\t\t\tnow = G[now.parent];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << (ans?\"True\":\"False\") << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nint m,n;\n\nstruct nodeInfo{\n    int depth;\n};\n\nmap<string,int> id;\nvector<int> G[1010];\nnodeInfo nif[1010];\n\nint main(){\n    bool f=false;\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        if(f)\n            cout<<endl;\n        f=true;\n        id.clear();\n        string str;\n        getline(cin,str);\n        for(int i = 0; i < 1010; i++)G[i].clear();\n        int depth=-1;\n        int cp=-1;\n        for(int i = 0; i < n; i++){\n            getline(cin,str);\n            int cnt=0;\n            for(int j = 0; ;j++){\n                if(str[j]==' ')continue;\n                else{\n                    str=str.substr(j);\n                    cnt=j;\n                    break;\n                }\n            }\n            id[str]=i;\n            // cntツづ個青板つセツつッツ親ツづ可姪淞づィツ、ツつサツつアツづ可ノツーツドツづーツ挿ツ禿シツつキツづゥ\n            if(cp==-1)\n                cp=i;\n            else if(depth<cnt){\n                G[cp].push_back(i);\n                G[i].push_back(cp);\n                cp=i;\n            }\n            else if(depth==cnt){\n                int back=G[cp][0];\n                G[back].push_back(i);\n                G[i].push_back(back);\n                cp=i;\n            }\n            else if(depth>cnt){\n                // ツ債キツ閉ェツづ個深ツつウツつセツつッツ親ツづ鳴姪淞づゥ\n                for(int j = 0; j <= depth-cnt; j++){\n                    int back=G[cp][0];\n                    cp=back;\n                }\n                G[cp].push_back(i);\n                G[i].push_back(cp);\n                cp=i;\n            }\n            depth=cnt;\n            nif[i].depth=depth;\n        }\n        for(int j = 0; j < m; j++){\n            string name1,name2;\n            string tmp;\n            string order;\n            cin>>name1>>tmp>>tmp>>order>>tmp>>name2;\n            name2=name2.substr(0,name2.size()-1);\n            int n1idx=id[name1];\n            int n2idx=id[name2];\n            bool match=false;\n            if(order==\"child\"){\n                for(int i = 0; i < G[n2idx].size(); i++){\n                    if(nif[G[n2idx][i]].depth>nif[n2idx].depth&&G[n2idx][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else if(order==\"ancestor\"){\n                int cnode=n2idx;\n                while(1){\n                    if(cnode==n1idx){\n                        match=true;\n                        break;\n                    }\n                    // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n                    if(cnode==0)\n                        break;\n                    else{\n                        for(int i = 0; i < G[cnode].size(); i++){\n                            if(nif[G[cnode][i]].depth<nif[cnode].depth){\n                                cnode=G[cnode][i];\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            else if(order==\"sibling\"){\n                int cnode=n2idx;\n                // ツ暗ェツづつ親ツづ可姪淞づゥ\n                for(int i = 0; i < G[cnode].size(); i++){\n                    if(nif[G[cnode][i]].depth<nif[n2idx].depth){\n                        cnode=G[cnode][i];\n                        break;\n                    }\n                }\n                for(int i = 0; i < G[cnode].size(); i++){\n                    if(G[cnode][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else if(order==\"parent\"){\n                swap(n2idx,n1idx);\n                for(int i = 0; i < G[n2idx].size(); i++){\n                    if(nif[G[n2idx][i]].depth>nif[n2idx].depth&&G[n2idx][i]==n1idx){\n                        match=true;\n                        break;\n                    }\n                }\n            }\n            else{\n                swap(n2idx,n1idx);\n                int cnode=n2idx;\n                while(1){\n                    if(cnode==n1idx){\n                        match=true;\n                        break;\n                    }\n                    // ツ親ツづ可つウツつゥツづ個づ堋づゥ\n                    if(cnode==0)\n                        break;\n                    else{\n                        for(int i = 0; i < G[cnode].size(); i++){\n                            if(nif[G[cnode][i]].depth<nif[cnode].depth){\n                                cnode=G[cnode][i];\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            if(match)\n                cout<<\"True\"<<endl;\n            else\n                cout<<\"False\"<<endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmap<string,int> mp;\nint ind[1001],par[1001];\nbool ko(int a,int b){\n  return par[a]==b;\n}\n\nbool sos(int a,int b){\n  while(a!=b&&a)\n    a=par[a];\n  return a==b;\n}\n\nint main(){\n  int n,m,T=0;\n  string s;\n  while(cin>>n>>m,n){\n      getline(cin,s);\n    if(T++)cout<<endl;\n    memset(ind,0,sizeof(ind));\n    memset(par,0,sizeof(par));\n    mp.clear();\n    par[0]=-1;\n    for(int i=0;i<n;i++){\n      int k;\n      getline(cin,s);\n      for(k=0;s[k]==' ';k++);\n      s=s.substr(k,s.size()-k);\n       mp[s]=i;\n      ind[i]=k;\n      for(int j=i-1;j>=0;j--)\n\tif(ind[j]<k){par[i]=j;break;}\n    }\n    for(int i=0;i<m;i++){\n      string q[6];\n      for(int j=0;j<6;j++)cin>>q[j];\n      bool ans;\n      q[5]=q[5].substr(0,q[5].size()-1); \n      int a=mp[q[0]],b=mp[q[5]];\n      if(q[3]==\"child\")ans=ko(a,b);\n      if(q[3]==\"parent\")ans=ko(b,a);\n      if(q[3]==\"sibling\")ans=(par[a]==par[b]);\n      if(q[3]==\"descendant\")ans=sos(a,b);\n      if(q[3]==\"ancestor\")ans=sos(b,a);\n      if(ans)cout<<\"True\"<<endl;\n      else cout<<\"False\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\n#define Pint pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 1010;\n\nstring human[MAX_M][MAX_M];\nmap<string, Pint > human_map;\n\nbool tmpCheck(int y, int x){\n    if(y >= MAX_M) return false;\n    if(x >= MAX_M) return false;\n    if(x < 0) return false;\n    if(x < 0) return false;\n    return true;\n}\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ') cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nbool checkChild(string x, string y){\n    int now_y = human_map[y].first + 1, now_x = human_map[y].second + 1;\n    bool ret = false;\n    if(!tmpCheck(now_y, now_x)) return false;\n    while(human[now_y][now_x] != \"\"){\n        if(human[now_y][now_x] == x) ret = true;\n        now_y++;\n        if(!tmpCheck(now_y, now_x)) break;\n    }\n    return ret;\n}\n\nbool checkParent(string x, string y){\n    int now_y = human_map[y].first - 1, now_x = human_map[y].second - 1;\n    if(!tmpCheck(now_y, now_x)) return false;\n    while(human[now_y][now_x] == \"\"){\n        now_y++;\n        if(!tmpCheck(now_y, now_x)) break;\n    }\n    bool ret = (human[now_y][now_x] == x)? true : false;\n    return ret;\n}\n\nbool checkSibling(string x, string y){\n    int now_y = human_map[y].first, now_x = human_map[y].second;\n    int m = 1;\n    bool skip = false;\n    if(!tmpCheck(now_y + m, now_x)) skip = true;\n    bool ret = false;\n    while(human[now_y + m][now_x] != \"\" && !skip){\n        if(human[now_y + m][now_x] == x) ret = true;\n        m++;\n        if(!tmpCheck(now_y + m, now_x)) break;\n    }\n    now_y = human_map[y].first;\n    skip = false;\n    m = 1;\n    if(!tmpCheck(now_y - m, now_x)) skip = true;\n    while(human[now_y - m][now_x] != \"\" && !skip){\n        if(human[now_y - m][now_x] == x) ret = true;\n        m++;\n        if(!tmpCheck(now_y - m, now_x)) break;\n    }\n    return ret;\n}\n\nbool checkDescendant(string x, string y){\n    bool ret = false;\n    REP(i, human_map[x].first){\n        REP(j, human_map[x].second){\n            if(!tmpCheck(i, j)) break;\n            if(human[i][j] == y) ret = true;\n        }\n    }\n    return ret;\n}\n\nbool checkAncestor(string x, string y){\n    bool ret = false;\n    FOR(i, human_map[x].first + 1, MAX_M){\n        FOR(j, human_map[x].second + 1, MAX_M){\n            if(!tmpCheck(i, j)) break;\n            if(human[i][j] == y) ret = true;\n        }\n    }\n    return ret;\n}\n\nbool checkQ(string str){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    string y = vec[5].erase(vec[5].size() - 1);\n    if(vec[3] == \"child\") return checkChild(vec[0], y);\n    if(vec[3] == \"parent\") return checkParent(vec[0], y);\n    if(vec[3] == \"sibling\") return checkSibling(vec[0], y);\n    if(vec[3] == \"descendant\") return checkDescendant(vec[0], y);\n    if(vec[3] == \"ancestor\") return checkAncestor(vec[0], y);\n}\n\nint main(){\n    while(true){\n        int m, n;\n        string st;\n        getline(cin, st);\n        stringstream ss(st);\n        ss >>m >>n;\n        if(!n && !m) break;\n\n        REP(i, MAX_M) REP(j, MAX_M) human[i][j] = \"\";\n        human_map.clear();\n\n        REP(i, m){\n            string str;\n            getline(cin, str);\n            P tmp = cntSpace(str);\n            human[i][tmp.first] = tmp.second;\n            human_map[tmp.second] = Pint(i, tmp.first);\n        }\n\n        REP(i, n){\n            string str;\n            getline(cin, str);\n            if(checkQ(str) == true) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int uli;\n\nconst int mxl=100;\nconst int mx=1e3+10;\nmap<string,int>mp;\nchar s[mxl];\nint lyr[mx],p[mx];\nchar sx[mxl],sy[mxl],rel[mxl],op[mxl];\nint main(){\n   int n,m;\n   lyr[0]=0;\n   while(scanf(\"%d %d\",&n,&m)){\n      if(n==0 && m==0)break;\n      mp.clear();\n      int u=0;\n      lyr[u]=p[u]=0;\n      gets(s);\n      gets(s);\n      mp[string(s)]=0;\n      for(int i=1;i<n;i++){\n         gets(s);\n         int l=strlen(s);\n         int dep=0;\n         while(dep<l && s[dep]==' ')dep++;\n         string x(s+dep);\n         mp[x]=i;         \n         while(lyr[u]!=dep-1)u=p[u];\n         p[i]=u;\n         lyr[i]=lyr[u]+1;\n         u=i;\n      }\n      for(int i=0;i<m;i++){\n         scanf(\"%s is %s %s of %s\",sx,op,rel,sy);\n         string y=string(sy);\n         y=y.substr(0,int(y.size())-1);\n         int ix=mp[string(sx)];\n         int iy=mp[y];\n         bool ans=false;\n         if(rel[0]=='c'){\n            if(p[ix]==iy)ans=1;\n         }\n         else if(rel[0]=='p'){\n            if(p[iy]==ix)ans=1;\n         }\n         else if(rel[0]=='s'){\n            if(p[ix]==p[iy] && lyr[ix]==lyr[iy])ans=1;\n         }\n         else if(rel[0]=='d' || rel[0]=='a'){            \n            if(rel[0]=='a')swap(ix,iy);\n            ix=p[ix];\n            while(!ans){\n               if(ix==iy) ans=true;\n               if(ix==p[ix])break;\n               ix=p[ix];\n            }\n         }\n         if(ans)puts(\"True\");\n         else puts(\"False\");\n      }\n      puts(\"\");\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, string> P;\n\nmap<string, P> fam;\n\nvector<string> s;\nvector<string> name;\nint N, Q;\n\nvoid output(){\n  string op;\n  for(int i = 0 ; i < Q ; i++){\n    string relation, X, Y;\n    for(int j = 0 ; j < 6 ; j++){\n      cin >> op;\n      if(j == 0) X = op;\n      if(j == 3) relation = op;\n      if(j == 5) Y = op;\n    }\n    Y.erase(Y.end()-1);\n    \n    if(relation == \"parent\"){\n      relation = \"child\";\n      swap(X, Y);\n    }\n    if(relation == \"descendant\"){\n      relation = \"ancestor\";\n      swap(X, Y);\n    }\n    \n    bool ans = false;\n    \n    if(relation == \"child\"){\n      ans = fam[X].second == Y;\n    }\n    else if(relation == \"ancestor\"){\n      while(fam[Y].first != 0){\n\tif(fam[Y].second == X){\n\t  ans = true;\n\t  break;\n\t}\n\tY = fam[Y].second;\n      }\n    }\n    else if(relation == \"sibling\"){\n      int gen = fam[Y].first;\n      string par = fam[Y].second;\n      for(map<string, P>::iterator it = fam.begin() ; it != fam.end() ; it++){\n\tif(it->first == X){\n\t  if(it->second.first == gen && it->second.second == par){\n\t    ans = true;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    if(ans) cout << \"True\" << endl;\n    else cout << \"False\" << endl;\n  }\n}\n\nint main(){\n  while(cin >> N >> Q, N|Q){\n    fam.clear();\n    s.clear();\n    name.clear();\n    cin.ignore();\n    string tmp;\n    for(int i = 0 ; i < N ; i++){\n      getline(cin, tmp);\n      s.push_back(tmp);\n    }\n    \n    name = s;\n    \n    for(int i = 0 ; i < N ; i++){\n      while(name[i][0] == ' ') name[i].erase(name[i].begin());\n      /*\n      for(int j = 0 ; j < (int)name[i].size() ; j++){\n\tif(name[i][j] == ' ') name[i].erase(name[i].begin()+j);\n      }\n      */\n    }\n    \n    for(int i = 0 ; i < N ; i++){\n      int gen = 0;\n      for(int j = 0 ; j < (int)s[i].size() ; j++){\n\tif(s[i][j] != ' ') break;\n\tgen++;\n      }\n      for(int j = i ; j >= 0 ; j--){\n\tif(s[j][gen-1] != ' '){\n\t  fam[ name[i] ] = P(gen, name[j]);\n\t  break;\n\t}\n      }\n    }\n    \n    output();\n    cout << endl;\n    /*\n    for(map<string, P>::iterator it = fam.begin() ; it != fam.end() ; it++){\n      cout << it->first << ' ' << it->second.first << ' ' << it->second.second << endl;\n    }\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\n#define Pint pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 1010;\n\nstring human[MAX_M][MAX_M];\nmap<string, Pint > human_map;\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ') cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nbool checkChild(string x, string y){\n    int now_y = human_map[y].first + 1, now_x = human_map[y].second + 1;\n    bool ret = false;\n    while(human[now_y][now_x] != \"\"){\n        if(human[now_y][now_x] == x) ret = true;\n        now_y++;\n    }\n    return ret;\n}\n\nbool checkParent(string x, string y){\n    int now_y = human_map[y].first - 1, now_x = human_map[y].second - 1;\n    while(human[now_y][now_x] == \"\") now_y++;\n    bool ret = (human[now_y][now_x] == x)? true : false;\n    return ret;\n}\n\nbool checkSibling(string x, string y){\n    int now_y = human_map[y].first, now_x = human_map[y].second;\n    int m = 1;\n    bool ret = false;\n    while(human[now_y + m][now_x] != \"\" || human[now_y - m][now_x] != \"\"){\n        if(human[now_y + m][now_x] != \"\"){\n            if(human[now_y + m][now_x] == x) ret = true;\n        }\n        if(human[now_y - m][now_x] != \"\"){\n            if(human[now_y - m][now_x] == x) ret = true;\n        }\n        m++;\n    }\n    return ret;\n}\n\nbool checkDescendant(string x, string y){\n    bool ret = false;\n    REP(i, human_map[x].first){\n        REP(j, human_map[x].second){\n            if(human[i][j] == y) ret = true;\n        }\n    }\n    return ret;\n}\n\nbool checkAncestor(string x, string y){\n    bool ret = false;\n    FOR(i, human_map[x].first + 1, MAX_M){\n        FOR(j, human_map[x].second + 1, MAX_M){\n            if(human[i][j] == y) ret = true;\n        }\n    }\n    return ret;\n}\n\nbool checkQ(string str){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    string y = vec[5].erase(vec[5].size() - 1);\n    if(vec[3] == \"child\") return checkChild(vec[0], y);\n    if(vec[3] == \"parent\") return checkParent(vec[0], y);\n    if(vec[3] == \"sibling\") return checkSibling(vec[0], y);\n    if(vec[3] == \"descendant\") return checkDescendant(vec[0], y);\n    if(vec[3] == \"ancestor\") return checkAncestor(vec[0], y);\n}\n\nint main(){\n    while(true){\n        int m, n;\n        string st;\n        getline(cin, st);\n        stringstream ss(st);\n        ss >>m >>n;\n        if(!n && !m) break;\n\n        REP(i, MAX_M) REP(j, MAX_M) human[i][j] = \"\";\n        human_map.clear();\n\n        REP(i, m){\n            string str;\n            getline(cin, str);\n            P tmp = cntSpace(str);\n            human[i][tmp.first] = tmp.second;\n            human_map[tmp.second] = Pint(i, tmp.first);\n        }\n\n        REP(i, n){\n            string str;\n            getline(cin, str);\n            if(checkQ(str) == true) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nmap<string, int> names;\npair<int, string> tree[1010];\nchar buf[1024], X[1024], Y[1024], R[1024];\nint main()\n{\n\twhile (true) {\n\t\tchar* p = strtok(fgets(buf, 1024, stdin), \" \");\n\t\tint n = atoi(p);\n\t\tp = strtok(NULL, \" \");\n\t\tint m = atoi(p);\n\n\t\tif (n == 0 && m == 0) break;\n\n\t\trep(i, n) {\n\t\t\tfgets(buf, 1024, stdin); buf[strlen(buf)-1] = '\\0';\n\t\t\tint c = 0;\n\t\t\trep(j, strlen(buf)) { if (buf[j] != ' ') break; c++; }\n\t\t\tstring name = string(buf).substr(c);\n\t\t\ttree[i] = mp(c, name);\n\t\t\tnames[name] = i;\n\t\t}\n\t\trep(i, m) {\n\t\t\tfgets(buf, 1024, stdin); buf[strlen(buf)-2] = '\\0';\n\t\t\tsscanf(buf, \"%s %*s %*s %s of %s\", X, R, Y);\n\t\t\tstring x(X), y(Y);\n\t\t\tint nx = tree[names[x]].first;\n\t\t\tint ny = tree[names[y]].first;\n\t\t\tif (!strcmp(R, \"child\")) {\n\t\t\t\tif (nx != ny + 1) puts(\"False\");\n\t\t\t\telse {\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor (int j = names[x] - 1; j >= 0; --j) {\n\t\t\t\t\t\tif (tree[j].second != y && tree[j].first + 1 == nx)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (tree[j].second == y) { ok = true; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) puts(\"True\"); else puts(\"False\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(R, \"parent\")) {\n\t\t\t\tif (nx != ny - 1) puts(\"False\");\n\t\t\t\telse {\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor (int j = names[y] - 1; j >= 0; --j) {\n\t\t\t\t\t\tif (tree[j].second != x && tree[j].first + 1 == ny)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (tree[j].second == x) { ok = true; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) puts(\"True\"); else puts(\"False\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(R, \"ancestor\")) {\n\t\t\t\tif (nx >= ny) puts(\"False\");\n\t\t\t\telse {\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor (int j = names[x] + 1; j < n; ++j) {\n\t\t\t\t\t\tif (tree[j].first <= nx) break;\n\t\t\t\t\t\tif (tree[j].second == y) { ok = true; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) puts(\"True\"); else puts(\"False\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(R, \"descendant\")) {\n\t\t\t\tif (nx <= ny) puts(\"False\");\n\t\t\t\telse {\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor (int j = names[y] + 1; j < n; ++j) {\n\t\t\t\t\t\tif (tree[j].first <= ny) break;\n\t\t\t\t\t\tif (tree[j].second == x) { ok = true; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) puts(\"True\"); else puts(\"False\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(R, \"sibling\")) {\n\t\t\t\tif (nx != ny) puts(\"False\");\n\t\t\t\telse {\n\t\t\t\t\tbool ok = false;\n\t\t\t\t\tfor (int j = names[x] - 1; j >= 0; --j) {\n\t\t\t\t\t\tif (tree[j].first < nx) break;\n\t\t\t\t\t\tif (tree[j].second == y) { ok = true; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif (!ok) for (int j = names[x] + 1; j < n; ++j) {\n\t\t\t\t\t\tif (tree[j].first < nx) break;\n\t\t\t\t\t\tif (tree[j].second == y) { ok = true; break; }\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) puts(\"True\"); else puts(\"False\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct person{\n\tvector<person> children;\n\tstring name;\n\tperson(string name):name(name){}\n\tint construct(vs &names,int indent,int index){\n\t\tFOR(i,index,names.size()){\n\t\t\tint next_indent=count(ALL(names[i]),' ');\n\t\t\tif(next_indent==indent+1){\n\t\t\t\tstring next_name=names[i];\n\t\t\t\tnext_name.erase(next_name.begin(),next_name.begin()+next_indent);\n\t\t\t\tchildren.push_back(person(next_name));\n\t\t\t}else if(next_indent>indent+1){\n\t\t\t\ti=children[children.size()-1].construct(names,indent+1,i)-1;\n\t\t\t}else{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn names.size();\n\t}\n\tbool is_child(string a,string b){\n\t\tif(name==b){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].name==a){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_child(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_descendant(string a,string b,bool flag=false){\n\t\tif(flag&&name==a){\n\t\t\treturn true;\n\t\t}\n\t\tif(name==b){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].is_descendant(a,b,true)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_descendant(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_parent(string a,string b){\n\t\tif(name==a){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].name==b){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_parent(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_ancestor(string a,string b,bool flag=false){\n\t\tif(flag&&name==b){\n\t\t\treturn true;\n\t\t}\n\t\tif(name==a){\n\t\t\tREP(i,children.size()){\n\t\t\t\tif(children[i].is_ancestor(a,b,true)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_ancestor(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tbool is_sibling(string a,string b){\n\t\tbool flag=false;\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].name==a||children[i].name==b){\n\t\t\t\tif(flag){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tREP(i,children.size()){\n\t\t\tif(children[i].is_sibling(a,b)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n&&m){\n\t\tstring name;\n\t\tgetline(cin,name);\n\t\tgetline(cin,name);\n\t\tperson &root=person(name);\n\t\tvs names;\n\t\tREP(i,n-1){\n\t\t\tgetline(cin,name);\n\t\t\tnames.push_back(name);\n\t\t}\n\t\tint index=0;\n\t\troot.construct(names,0,index);\n\t\tREP(i,m){\n\t\t\tstring a,b,rel,trash;\n\t\t\tcin>>a>>trash>>trash>>rel>>trash>>b;\n\t\t\tbool ok;\n\t\t\tb.erase(b.end()-1,b.end());\n\t\t\tif(rel==\"child\"){\n\t\t\t\tok=root.is_child(a,b);\n\t\t\t}else if(rel==\"parent\"){\n\t\t\t\tok=root.is_parent(a,b);\n\t\t\t}else if(rel==\"ancestor\"){\n\t\t\t\tok=root.is_ancestor(a,b);\n\t\t\t}else if(rel==\"descendant\"){\n\t\t\t\tok=root.is_descendant(a,b);\n\t\t\t}else if(rel==\"sibling\"){\n\t\t\t\tok=root.is_sibling(a,b);\n\t\t\t}else{\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t\tcout<<(ok?\"True\":\"False\")<<endl;\n\t\t}\n\t\tcout<<endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      /*\n      if(level_tree.find(mid) != level_tree.end())\n\tinfo.push_back(mid);\n      else if(mid == \"child\" || mid == \"parent\" || mid == \"sibling\" || mid == \"descendant\" || mid == \"ancestor\")\n\tinfo.pb(mid);\n      */\n      ope.push_back(mid);\n      //cout << \"ope = \" << mid << endl;\n    }\n\n skip:\n\n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i] == \"child\" || ope[i] == \"parent\" || ope[i] == \"sibling\" || ope[i] == \"descendant\" || ope[i] == \"ancestor\")\n\t{\n\t  info.push_back(ope[i]);\n\t  break;\n\t}\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n\n  //cout << info[0] << \" \" << info[1] <<\" \" << info[2] << endl; \n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n      //cout << \"Xindex = \" << Xindex << \" Yindex = \" << Yindex << endl;\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\t  //cout << \"vec : \" << vec[i].F << endl;\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || min(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      cerr << n << \" \" << m << endl;\n      if(!(n+m))\n\tbreak;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  cerr << line << endl;\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  cerr << line << endl;\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\ntemplate<typename T>\nvoid Unique(vector<T> &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\ntemplate<typename T,typename U>\nll FindErase(T &v,U tar){\n  ll cnt = 0;\n  for(auto it = v.begin(); it != v.end();){\n    if(*it == tar){\n      it = v.erase(it);\n      ++cnt;\n    }\n    else{\n      ++it;\n    }\n  }\n  return cnt;\n}\n\ntemplate<typename T>\nbool SuffixErase(T &v,size_t suf){\n  if(suf > v.size()) return false;\n  for(auto it = v.begin(); it != v.end();){\n    if(distance(v.begin(),it) == suf){\n      v.erase(it);\n      return true;\n    }\n    else{\n      ++it;\n    }\n  }\n  return false;\n}\n\ntemplate<typename T>\nT ston(string& str, T n){\n  istringstream sin(str) ;\n  T num ;\n  sin >> num ;\n  return num ;\n}\n\nstruct Data{\n  string s;\n  int id;\n  int par;\n};\n\nvector<Data> d(1001);\nint tar;\nbool dfs(int k){\n  if(k == tar) return true;\n  if(d[k].id == 0) return false;\n  return dfs(d[k].par);\n}\nvoid Out(bool f){\n  if(f) cout << \"True\" << endl;\n  else cout << \"False\" << endl;\n}\nint main(){\n  string s;\n  int a,b;\n  while(cin >> a >> b && a + b){\n    cin.ignore();\n    d = vector<Data>(1500);\n    int tk = 1;\n    int par[1500] = {};\n    map<string,int> m;\n    REP(i,0,a){\n      getline(cin,s);\n      auto k = FindErase(s,' ')+1;\n      m[s] = i;\n      d[i] = {s,i};\n      if(tk == k){\n        d[i].par = par[k-1];\n        par[k] = i;\n      }\n      else if(tk < k){\n        d[i].par = par[tk];\n        par[k] = i;\n      }\n      else{\n        d[i].par = par[k-1];\n        par[k] = i;\n      }\n      tk = k;\n    }\n    d[0].par = 1001;\n//     rep(i,a){\n//       cout << d[i].s << \"'s parent \" << d[d[i].par].s<<endl;\n//     }\n    string s2,s3,tmp;\n    rep(i,b){\n      cin >> s >> tmp >> tmp >> s2 >> tmp >> s3;\n      s3.resize(s3.size()-1);\n      if(s2 == \"child\"){\n        Out(d[m[s]].par == m[s3]);\n      }\n      else if(s2 == \"parent\"){\n        Out(d[m[s3]].par == m[s]);\n      }\n      else if(s2 == \"sibling\"){\n        Out(d[m[s]].par == d[m[s3]].par);\n      }\n      else if(s2 == \"ancestor\"){\n        tar = m[s];\n        Out(dfs(m[s3]));\n      }\n      else if(s2 == \"descendant\"){\n        tar = m[s3];\n        Out(dfs(m[s]));\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<sstream>\n#include<map>\n#include<vector>\nusing namespace std;\n#define MAX 1000\n\nclass Node{\n    public:\n    int parent;\n    vector<int> children;\n    Node(){}\n};\n\nNode N[MAX];\nmap<string, int> N_I;\nint n;\nstring line;\n\nvoid makeTree(){\n    for ( int i = 0; i < n; i++ ) N[i] = Node();\n    string name;\n    int P[MAX], pr;\n    N[0].parent = -1;\n    for ( int i = 0; i < n; i++ ){\n\tgetline(cin, line);\n\tint ns = 0;\n\twhile( line[ns] == ' ') ns++;\n\tname = line.substr(ns, line.size()-ns);\n\tN_I[name] = i;\n\tP[ns] = i;\n\tif ( i == 0 ) continue;\n\tpr = P[ns-1];\n\tN[i].parent = pr;\n\tN[pr].children.push_back(i);\n    }\n}\n\nbool parse( int u, int target ){\n    if ( u == -1 ) return false;\n    if ( u == target ) return true;\n    if ( parse(N[u].parent, target) ) return true;\n    return false;\n}\n\nbool check(string s_str, string com, string t_str){\n    int s = N_I[s_str];\n    int t = N_I[t_str];\n    if ( com == \"child\" ) return N[s].parent == t;\n    else if ( com == \"parent\" )\treturn N[t].parent == s;\n    else if ( com == \"sibling\" ) return N[t].parent == N[s].parent;\n    else if ( com == \"ancestor\" ) return parse(t, s);\n    else if ( com == \"descendant\" ) return parse(s, t);\n}\n\nmain(){\n    int m;\n    string s, com, t, tmp;\n    while( cin >> n >> m && n && m){\n\tgetline(cin, line);\n\tmakeTree();\n\tfor ( int i = 0; i < m; i++ ) {\n\t    getline(cin, line);\n\t    stringstream sin(line);\n\t    sin >> s >> tmp >> tmp >> com >> tmp >> t;\n\t    t = t.substr(0, t.size()-1);\n\t    if ( check(s, com, t) ) cout << \"True\" << endl;\n\t    else cout << \"False\" << endl;\n\t}\n\tcout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, string>\nconst int INF = INT_MAX / 2;\nconst int MAX_M = 1010;\n\nP cntSpace(string str){\n    int cnt = 0;\n    while(str[cnt] == ' ') cnt++;\n    return P(cnt, str.substr(cnt));\n}\n\nbool searchParent(int x, int y, vector<int> parent){\n    if(parent[y] == x) return true;\n    else return false;\n}\n\nbool checkQ(string str, map<string, int> list_i, vector<int> parent){\n    stringstream ss(str);\n    vector<string> vec;\n    string tmp;\n    while(ss >>tmp) vec.push_back(tmp);\n\n    int x = list_i[vec[0]];\n    int y = list_i[vec[5].erase(vec[5].size() - 1)];\n\n    if(vec[3] == \"child\") return searchParent(y, x, parent);\n    if(vec[3] == \"parent\") return searchParent(x, y, parent);\n    if(vec[3] == \"sibling\") return parent[x] == parent[y];\n    if(vec[3] == \"descendant\"){\n        int now_y = y;\n        while(parent[now_y] != -1){\n            if(searchParent(now_y, x, parent) == true) return true;\n            now_y = parent[now_y];\n        }\n        return false;\n    }\n    if(vec[3] == \"ancestor\"){\n        int now_y = y;\n        while(parent[now_y] != -1){\n            if(searchParent(x, now_y, parent) == true) return true;\n            now_y = parent[now_y];\n        }\n        return false;\n    }\n}\n\n\n\nint main(){\n    while(true){\n        string str_m_n;\n        getline(cin, str_m_n);\n        stringstream ss(str_m_n);\n        int m, n;\n        ss >>m >>n;\n        if(!m && !n) break;\n\n        vector<int> parent(m);\n        int current_parent_i[MAX_M];\n        map<string, int> list_i;\n\n        parent[0] = -1;\n\n        REP(i, m){\n            string name_line;\n            getline(cin, name_line);\n            stringstream ss(name_line);\n            P rank_and_name = cntSpace(name_line);\n            current_parent_i[rank_and_name.first + 1] = i;\n            list_i[rank_and_name.second] = i;\n            if(i != 0){\n                int now_parent = current_parent_i[rank_and_name.first];\n                parent[i] = now_parent;\n            }\n        }\n\n        REP(i, n){\n            string q;\n            getline(cin, q);\n            bool ans = checkQ(q, list_i, parent);\n            if(ans) cout <<\"True\" <<endl;\n            else cout <<\"False\" <<endl;\n        }\n        cout <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nint oldest,youngest;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n  oldest = min(oldest,space_cnt);\n  youngest = max(youngest,space_cnt);\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      \n      ope.push_back(mid);\n      \n    }\n\n skip:\n\n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i] == \"child\" || ope[i] == \"parent\" || ope[i] == \"sibling\" || ope[i] == \"descendant\" || ope[i] == \"ancestor\")\n\t{\n\t  info.push_back(ope[i]);\n\t  break;\n\t}\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n\n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n\n      if(vec[Xindex].S <= vec[Yindex].S || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S >= vec[Yindex].S || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || min(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(Yindex+1 >= vec.size() || vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      for(int i=Yindex+1;i<vec.size() && vec[i].S > vec[Yindex].S;i++)\n\t{\n\t  if(vec[i].F == vec[Xindex].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(Xindex+1 >= vec.size()  || vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      for(int i=Xindex+1;i < vec.size() && vec[i].S > vec[Xindex].S;i++)\n\t{\n\t  if(vec[i].F == vec[Yindex].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n   \n      if(!(n+m))\n\tbreak;\n      oldest = (1<<28);\n      youngest = -1;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t\n\t  split(vec,line);\n\t}\n\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\tindex_tree[vec[i].F] = i;\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t \n\t  ParseAndSolve(vec,index_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\n\n//char c[1005][100];\n\nchar s[200];\nmap<string,int>name;\nvector<int>ve[200];\nvector<int>ren[2005];\nmap<string,int>gx;\n\nint main ()\n{\n    int k=1;\n    int n,m;\n    gx.insert(make_pair(string(\"child\"),1));\n    gx.insert(make_pair(string(\"parent\"),2));\n    gx.insert(make_pair(string(\"sibling\"),3));\n    gx.insert(make_pair(string(\"descendant\"),4));\n    gx.insert(make_pair(string(\"ancestor\"),5));\n\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        if(n==0&&m==0)\n        {\n            break;\n        }\n        getchar ();\n\n        name.clear();\n        for(int i=0; i<105; i++)\n        {\n            ve[i].clear();\n        }\n        for(int i=0; i<=1500; i++)\n        {\n            ren[i].clear();\n        }\n\n        for(int i=0; i<n; i++)\n        {\n            int p=0;\n            gets(s);\n            while(s[p]==' ')p++;\n            name.insert(make_pair(string(&s[p]),i));\n\n            ve[p].push_back(i);\n\n            for(int j=0; j<=p; j++)\n            {\n                if(ve[j].size()-1 >=0)\n                    ren[i].push_back(ve[j][ ve[j].size()-1 ]);\n            }\n        }\n//        for(int i=0; i<3; i++)\n//        {\n//            for(int j=0; j<ve[i].size(); j++)\n//            {\n//                printf(\"%d \",ve[i][j]);\n//            }\n//            printf(\"\\n\");\n//        }\n//        printf(\"\\n\");\n//        for(int i=0; i<6; i++)\n//        {\n//            for(int j=0; j<ren[i].size(); j++)\n//            {\n//                printf(\"%d \",ren[i][j]);\n//\n//            }\n//            printf(\"\\n\");\n//        }\n//        printf(\"\\n\");\n//        printf(\"%d****\\n \",m);\n        if(k!=1)printf(\"\\n\");\n        k++;\n        for(int p=0; p<m; p++)\n        {\n            scanf(\"%s\",s);\n            string name1(s);\n            scanf(\"%*s\");\n            scanf(\"%*s\");\n            scanf(\"%s\",s);\n            string name2(s);\n            scanf(\"%*s\");\n            scanf(\"%s\",s);\n            getchar();\n\n            s[strlen(s)-1]=0;\n            string name3(s);\n            int t1,t2,t3;\n            t1=name[name1];\n            t2=gx[name2];//1 2 3 4 5\n            t3=name[name3];\n//            printf(\"%d %d %d\\n\",t1,t2,t3);\n\n            bool boo=false;\n            if(t2==1)\n            {\n                if(ren[t1].size()-2>=0)\n                    if(ren[t1][ren[t1].size()-2]==t3)\n                    {\n                        boo=true;\n                    }\n            }\n            else if(t2==2)\n            {\n                if(ren[t3].size()-2>=0)\n                    if(ren[t3][ren[t3].size()-2]==t1)\n                    {\n                        boo=true;\n                    }\n            }\n            else if(t2==3)\n            {\n                if(ren[t1].size()-2>=0&&ren[t3].size()-2>=0)\n                    if(ren[t1][ren[t1].size()-2]==ren[t3][ren[t3].size()-2])\n                    {\n                        boo=true;\n                    }\n//                if(ren[t1].size()==ren[t3].size())\n//                {\n//                    boo=true;\n//                }\n            }\n            else if(t2==4)\n            {\n                for(int i=0; i<ren[t1].size()-1; i++)\n                {\n                    if(ren[t1][i]==t3)\n                    {\n                        boo=true;\n                        break;\n                    }\n                }\n//                if(ren[t1].size()>ren[t3].size())\n//                {\n//                    boo=true;\n//                }\n            }\n            else if(t2==5)\n            {\n//                bool ok=true;\n                for(int i=0; i<ren[t3].size()-1; i++)\n                {\n                    if(ren[t3][i]==t1)\n                    {\n                        boo=true;\n                        break;\n                    }\n                }\n//                if(ok) boo=true;\n////                if(ren[t1].size()<ren[t3].size())\n////                {\n////                    boo=true;\n////                }\n            }\n\n            if(boo==false)\n                printf(\"False\\n\");\n            else\n                printf(\"True\\n\");\n        }\n\n    }\n}\n/*\n6 5\nJohn\n Robert\n  Frank\n  Andrew\n Nancy\n  David\nRobert is a child of John.\nRobert is an ancestor of Andrew.\nRobert is a sibling of Nancy.\nNancy is the parent of Frank.\nJohn is a descendant of Andrew.\n2 1\nabc\n xyz\nxyz is a child of abc.\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h=0,i,j,k,l;\n  int n,m;\n  while(cin>>n>>m&&n+m){\n    if(h)\n      cout<<endl;\n    else\n      h=1;\n    string t;\n    getline(cin,t);\n    int a[1000];\n    memset(a,0,sizeof(a));\n    string s[1000];\n    for(i=0;i<n;i++){\n      string t;\n      getline(cin,t);\n      for(;t[0]==' ';a[i]++)\n\tt.erase(0,1);\n      s[i]=t;\n    }\n    for(i=0;i<m;i++){\n      string t,u,v;\n      cin>>t>>u>>u>>u>>v>>v;\n      v.erase(v.length()-1,1);\n      if(0){\n      }else if(u[0]=='c'){\n\tfor(j=0;s[j]!=t;j++);\n\tif(j==0)\n\t  cout<<\"False\"<<endl;\n\telse{\n\t  for(k=j;a[k]!=a[j]-1;k--);\n\t  if(s[k]==v)\n\t    cout<<\"True\"<<endl;\n\t  else\n\t    cout<<\"False\"<<endl;\n\t}\n      }else if(u[0]=='p'){\n\tfor(j=0;s[j]!=v;j++);\n\tif(j==0)\n\t  cout<<\"False\"<<endl;\n\telse{\n\t  for(k=j;a[k]!=a[j]-1;k--);\n\t  if(s[k]==t)\n\t    cout<<\"True\"<<endl;\n\t  else\n\t    cout<<\"False\"<<endl;\n\t}\t\n      }else if(u[0]=='s'){\n\tfor(j=0;s[j]!=t&&s[j]!=v;j++);\n\tfor(k=j+1;s[j]!=t&&s[j]!=v;k++);\n\tfor(j++;j<k;j++){\n\t  if(a[j]<a[k])\n\t    break;\n\t}\n\tif(j==k)\n\t  cout<<\"True\"<<endl;\n\telse\n\t  cout<<\"False\"<<endl;\n      }else if(u[0]=='d'){\n\tfor(j=0;s[j]!=t;j++);\n\tl=a[j];\n\tfor(k=j-1;k>-1;k--){\n\t  if(a[k]<l){\n\t    if(s[k]==v)\n\t      break;\n\t    l=a[k];\n\t  }\n\t}\n\tif(k==-1)\n\t  cout<<\"False\"<<endl;\n\telse\n\t  cout<<\"True\"<<endl;\n      }else if(u[0]=='a'){\n\tfor(j=0;s[j]!=v;j++);\n\tl=a[j];\n\tfor(k=j-1;k>-1;k--){\n\t  if(a[k]<l){\n\t    if(s[k]==t)\n\t      break;\n\t    l=a[k];\n\t  }\n\t}\n\tif(k==-1)\n\t  cout<<\"False\"<<endl;\n\telse\n\t  cout<<\"True\"<<endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<string> splitAll(string s, string t) {\n  vector<string> v;\n  for (int p = 0; (p = s.find(t)) != s.npos; ) {\n    v.push_back(s.substr(0, p));\n    s = s.substr(p + t.size());\n  }\n  v.push_back(s);\n  return v;\n}\n\nint main(){\n  int n, m;\n  while(cin>>n>>m && n){\n    int parent[1000];\n    memset(parent, -1, sizeof(parent));\n    int save[1000];\n    map<string, int> id;\n    cin.ignore();\n    REP(i, n){\n      string s; getline(cin, s);\n      int lev = 0;\n      while(s[lev] == ' ') lev++;\n      string name = s.substr(lev);\n      id[name] = i;\n      save[lev] = i;\n      if(lev != 0){\n        parent[i] = save[lev-1];\n      }\n    }\n    REP(i, m){\n      string query; getline(cin, query);\n      vector<string> words = splitAll(query, \" \");\n      string A = words[0];\n      string B = words[5].substr(0, words[5].size()-1);\n      bool ans = false;\n      if(words[3] == \"child\"){\n        ans = parent[id[A]] == id[B];\n      }else if(words[3] == \"parent\"){\n        ans = parent[id[B]] == id[A];\n      }else if(words[3] == \"sibling\"){\n        ans = parent[id[A]] == parent[id[B]];\n      }else if(words[3] == \"descendant\"){\n        int now = id[A];\n        while(now != -1){\n          if(now == id[B]) ans = true;\n          now = parent[now];\n        }\n      }else if(words[3] == \"ancestor\"){\n        int now = id[B];\n        while(now != -1){\n          if(now == id[A]) ans = true;\n          now = parent[now];\n        }\n      }\n      if(ans) cout<<\"True\"<<endl;\n      else cout<<\"False\"<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\n\nint n, m;\nint parent[1000];\t\t\t//親の番号\nint indent_table[1000];\t\t//そのインデントに対する、親の番号\nmap<string,int> names;\t\t//名前と番号の対応\n\n//XがYの親であるかどうかを判定。\nbool is_parent(int x_num, int y_num){\n\tif( x_num == parent[y_num] ){ return true; }\n\treturn false;\n}\n\n//XとYが兄弟であるか(すなわち、親が同じであるか)を判定。\nbool is_sibling(int x_num, int y_num){\n\tif( parent[x_num] == parent[y_num] ){ return true; }\n\treturn false;\n}\n\n//XがYの先祖であるかを判定。\n//Yの親を順に辿っていき、途中でXと等しくなったらtrueを返す。\nbool is_ancestor(int x_num, int y_num){\n\twhile( y_num >= 0 ){\n\t\tif( x_num == y_num ){ return true; }\n\t\ty_num = parent[y_num];\n\t}\n\treturn false;\n}\n\nint main(){\n\tstring person;\n\n\twhile(true){\n\t\tcin >> n >> m;\n\t\tif( m == 0 ) break;\n\n\t\tnames.clear();\n\n\t\tindent_table[0] = -1;\t//最初の人に親はいないので、-1としておく。\n\n\t\tcin.ignore();\t//改行が邪魔なので、一文字飛ばす\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tgetline(cin, person);\n\t\t\tint indent = person.find_first_not_of(\" \");\n\t\t\t\t//インデントを数える。\n\t\t\t\t//インデントを除いた person.substr(indent) が、実際の名前\n\n\t\t\tnames[person.substr(indent)] = i;\t//その人をi番とする。\n\t\t\tparent[i] = indent_table[indent];\t//親の番号を決定する。\n\t\t\tindent_table[indent + 1] = i;\t\t//子のためにテーブルを更新。\n\t\t}\n\t\t\n\t\tstring X, Y, rel;\t//X, Yおよびその関係\n\t\tstring ign;\t//無視する文字列\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tcin >> X >> ign >> ign >> rel >> ign >> Y;\n\t\t\t\t//is, (a/an/the), of は無視する。\n\t\t\tY.resize(Y.size() - 1);\t//最後に . が含まれるので、除去。\n\n\t\t\tint x_num = names[X];\n\t\t\tint y_num = names[Y];\t//XおよびYに対応する番号を取得\n\t\t\tbool ans = false;\n\t\t\t\n\t\t\tif( rel == \"child\" ){\n\t\t\t\tans = is_parent(y_num, x_num);\n\t\t\t}\n\t\t\telse if( rel == \"parent\" ){\n\t\t\t\tans = is_parent(x_num, y_num);\n\t\t\t}\n\t\t\telse if( rel == \"sibling\" ){\n\t\t\t\tans = is_sibling(x_num, y_num);\n\t\t\t}\n\t\t\telse if( rel == \"descendant\" ){\n\t\t\t\tans = is_ancestor(y_num, x_num);\n\t\t\t}\n\t\t\telse if( rel == \"ancestor\" ){\n\t\t\t\tans = is_ancestor(x_num, y_num);\n\t\t\t}\n\t\t\t\n\t\t\tif( ans ){ cout << \"True\\n\"; }\n\t\t\telse{ cout << \"False\\n\"; }\n\t\t}\n\t\t\n\t\tcout << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, m;\n\twhile(cin >> n >> m, n|m) {\n\t\tcin.ignore();\n\t\tvector<string> v(1000);\n\t\tmap<string, string> ma;\n\t\tREP(i, n) {\n\t\t\tstring s;\n\t\t\tgetline(cin, s);\n\t\t\tint cnt = 0;\n\t\t\twhile(s[cnt] == ' ')\n\t\t\t\tcnt++;\n\t\t\ts = s.substr(cnt);\n\t\t\tif(!cnt)\n\t\t\t\tma[s] = \"\";\n\t\t\telse\n\t\t\t\tma[s] = v[cnt-1];\n\t\t\tv[cnt] = s;\n\t\t}\n\t\tREP(i, m) {\n\t\t\tstring in1, in2, in3;\n\t\t\tcin >> in1;\n\t\t\tcin >> in2 >> in2 >> in2;\n\t\t\tcin >> in3 >> in3;\n\t\t\tin3.erase(in3.end() - 1);\n\t\t\tbool ans = false;\n\t\t\tif(in2 == \"child\" && ma[in1] == in3)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"parent\" && ma[in3] == in1)\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"sibling\" && ma[in1] == ma[in3])\n\t\t\t\tans = true;\n\t\t\telse if(in2 == \"descendant\") {\n\t\t\t\tstring s = ma[in1];\n\t\t\t\twhile(s != \"\") {\n\t\t\t\t\tif(s == in3)\n\t\t\t\t\t\tans = true;\n\t\t\t\t\ts = ma[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(in2 == \"ancestor\") {\n\t\t\t\tstring s = ma[in3];\n\t\t\t\twhile(s != \"\") {\n\t\t\t\t\tif(s == in1)\n\t\t\t\t\t\tans = true;\n\t\t\t\t\ts = ma[s];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans)\n\t\t\t\tcout << \"True\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"False\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<sstream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cassert>\n#define F first\n#define S second\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<string,int> SI;\n\nvoid split(vector<SI>& vec,string line)\n{\n  int space_cnt = 0;\n  for(int i=0;line[i] == ' ';i++,space_cnt++){}\n\n  vec.push_back(SI(line.substr(space_cnt,line.size()-space_cnt),space_cnt));\n}\n\nvoid ParseAndSolve(vector<SI>& vec,map<string,int>& index_tree,map<int,vector<string> >& space_tree,map<string,int>& level_tree,string line)\n{\n  vector<string> info;\n  stringstream ss(line);\n  string mid;\n  vector<string> ope; \n \n\n  for(int i=0;i<ss.str().size();i++)\n    {\n      if((ss >> mid).fail())\n\tgoto skip;\n      /*\n      if(level_tree.find(mid) != level_tree.end())\n\tinfo.push_back(mid);\n      else if(mid == \"child\" || mid == \"parent\" || mid == \"sibling\" || mid == \"descendant\" || mid == \"ancestor\")\n\tinfo.pb(mid);\n      */\n      ope.push_back(mid);\n      //cout << \"ope = \" << mid << endl;\n    }\n\n skip:\n\n  info.push_back(ope[0]);\n  for(int i=1;i<ope.size()-1;i++)\n    {\n      if(ope[i] == \"child\" || ope[i] == \"parent\" || ope[i] == \"sibling\" || ope[i] == \"descendant\" || ope[i] == \"ancestor\")\n\t{\n\t  info.push_back(ope[i]);\n\t  break;\n\t}\n    }\n  info.push_back(ope[ope.size()-1].substr(0,ope[ope.size()-1].size()));\n\n  //cout << info[0] << \" \" << info[1] <<\" \" << info[2] << endl; \n\n  assert(info.size() == 3);\n\n  string X,Y;\n  X = info[0],Y = info[2];\n\n  if(info[1][0] == 'c')\n    {\n      int Yindex = index_tree[Y];     \n      int Xindex = index_tree[X];\n      //cout << \"Xindex = \" << Xindex << \" Yindex = \" << Yindex << endl;\n      if(level_tree[X] <= level_tree[Y] || Yindex+1 >= vec.size() || vec[Yindex+1].S != vec[Xindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n   \n      int parent_level = vec[Yindex].S;\n\n      for(int i=Yindex+1;parent_level < vec[i].S && i < vec.size();i++)\n\t{\n\t  //cout << \"vec : \" << vec[i].F << endl;\n\t  if(vec[i].F == X)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'p')\n    {\n\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(level_tree[X] >= level_tree[Y] || Xindex+1 >= vec.size() || vec[Xindex+1].S != vec[Yindex].S )\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n\n      int parent_level = vec[Xindex].S;\n\n      for(int i=Xindex+1;parent_level < vec[i].S && i < vec.size();i++ )\n\t{\n\t  if(vec[i].F == Y)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n\n      cout << \"False\" << endl;\n      return;\n\n\n    }\n  else if(info[1][0] == 's')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n\n      if(vec[Xindex].S != vec[Yindex].S || min(Xindex,Yindex)+1 >= vec.size())\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n\n      int sibling_level = vec[Xindex].S;\n\n      int Maxindex,Minindex;\n      string Maxname,Minname;\n\n      if(Xindex > Yindex)\n\t{\n\t  Maxindex = Xindex,Minindex = Yindex;\n\t  Maxname = X,Minname = Y;\n\t}\n      else \n\t{\n\t  Maxindex = Yindex,Minindex = Xindex;\n\t  Maxname = Y,Minname = X;\n\t}\n\n      for(int i=Minindex+1;i<vec.size() && sibling_level <= vec[i].S;i++)\n\t{\n\t  if(Maxname == vec[i].F)\n\t    {\n\t      cout << \"True\" << endl;\n\t      return;\n\t    }\n\t}\n      cout << \"False\" << endl;\n      return;\n\n    }\n  else if(info[1][0] == 'd')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S <= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else if(info[1][0] == 'a')\n    {\n      int Xindex = index_tree[X];\n      int Yindex = index_tree[Y];\n      if(vec[Xindex].S >= vec[Yindex].S)\n\t{\n\t  cout << \"False\" << endl;\n\t  return;\n\t}\n      cout << \"True\" << endl;\n      return;\n    }\n  else \n    assert(false);\n  \n\n}\n\nint main()\n{\n  int n,m;\n  while(true)\n    {\n      cin >> n >> m;\n      //cerr << n << \" \" << m << endl;\n      if(!(n+m))\n\tbreak;\n      cin.ignore();\n      string line;\n      vector<SI> vec;\n      for(int i=0;i<n;i++)\n\t{\n\t  getline(cin,line);\n\t  //cerr << line << endl;\n\t  split(vec,line);\n\t}\n\n      map<int,vector<string> > space_tree;\n      map<string,int> level_tree;\n      map<string,int> index_tree;\n      for(int i=0;i<n;i++)\n\t{\n\t  index_tree[vec[i].F] = i;\n\t  level_tree[vec[i].F] = vec[i].S;\n\t  space_tree[vec[i].S].pb(vec[i].F);\n\t}\n\n      for(int i=0;i<m;i++)\n\t{\n\t  getline(cin,line);\n\t  //cerr << line << endl;\n\t  ParseAndSolve(vec,index_tree,space_tree,level_tree,line.substr(0,line.size()-1));\n\t \n\t}\n\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s1[70],s2[70],s3[70],na[1000][70],s[71];\n  int st[1010],n,m,i,j,r,p[1010]={-1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    scanf(\"\\n\");\n    st[0]=-1;\n    for(j=0;j<n;j++){\n      fgets(s,71,stdin);\n      for(i=0;s[i]==' ';i++);\n      st[i+1]=j;\n      p[j]=st[i];//printf(\"%s\\n\",s+i);\n      for(r=0;s[i]-10;i++)na[j][r++]=s[i];\n      na[j][r]=0;\n    }//printf(\"a\\n\");\n    for(i=0;i<n;i++)printf(\"%d\\n\",p[i]);\n    while(m--){\n      scanf(\"%s %*s %*s %s %*s %s\",s1,s2,s3);//printf(\"%s\\n\",s3);\n      s3[strlen(s3)-1]=0;\n      for(i=0;strcmp(na[i],s1);i++);//printf(\"%d\\n\",i);\n      for(j=0;strcmp(na[j],s3);j++);//printf(\"%d\\n\",j);\n      if(s2[0]=='c'){\n\tif(j==p[i])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='a'){\n\tfor(;j+1;j=p[j]){\n\t  if(i==j)break;\n\t}\n\tif(i==j)printf(\"True\\n\");\n\telse    printf(\"False\\n\");\n      }\n      if(s2[0]=='s'){\n\tif(p[i]==p[j])printf(\"True\\n\");\n\telse          printf(\"False\\n\");\n      }\n      if(s2[0]=='p'){\n\tif(i==p[j])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='d'){\n\tfor(;i+1;i=p[i]){\n\t  if(i==j)break;\n\t}\n\tif(i==j)printf(\"True\\n\");\n\telse    printf(\"False\\n\");\n      }\n    }\n    printf(\"\\n\");  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1217\nTitle\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n,m;\nstruct p_str\n{\n        char name[21];\n        int  parent;\n        int  level;       //no of indent\n} person[100];\nint person_ptr;\nchar query[71];\nchar readbuffer[71];\n//\nint c_sp(char *s)\n{\n        int i;\n        int cnt;\n\n        for(i=0;s[i];i++)\n                if(s[i]!=' ')\n                        break;\n        return(i);\n}\nvoid print_tree()\n{\n        int i;\n        printf(\"----------------------\\n\");\n        for(i=0;i<person_ptr;i++)\n        {\n                printf(\"%d %s\",person[i].level,person[i].name);\n                if(i)\n                        printf(\"(%s)\",person[person[i].parent].name);\n                printf(\"\\n\");\n        }\n}\nint name2sno(char * name)\n{\n        int i;\n        for(i=0;i<person_ptr;i++)\n                if(0==strcmp(name,person[i].name))\n                        return(i);\n        return(-1);\n}\nint check_relation(char * sub,char * rel,char *obj)\n{\n        int sn,on;\n        sn=name2sno(sub);\n        on=name2sno(obj);\n        if(0==strcmp(rel,\"parent\"))\n                return(person[on].parent == sn);\n        if(0==strcmp(rel,\"child\"))\n        {\n                return(person[sn].parent == on);\n        }\n        if(0==strcmp(rel,\"sibling\"))\n        {\n                return(person[sn].parent == person[on].parent);\n        }\n        if(0==strcmp(rel,\"ancestor\"))\n        {\n        LOOP:\n                if(person[on].parent < 0)\n                        return(0);\n                if(sn== person[on].parent)\n                        return(-1);\n                on=person[on].parent;\n                goto LOOP;\n        }\n        if(0==strcmp(rel,\"descendant\"))\n        {\n        LOOP2:\n                if(person[sn].parent < 0)\n                        return(0);\n                if(on== person[sn].parent)\n                        return(-1);\n                sn=person[sn].parent;\n                goto LOOP2;\n        }\n\n        return(0);\n}\nmain()\n{\n        int i,j;\n        int nsp;  // no of leading space\n        char *subject;\n        char *object;\n        char *relation;\n        while(EOF!=scanf(\"%d %d\\n\",&n,&m) && (n||m))\n        {       \n                //printf(\"NM %d %d \\n\",n,m);        \n                person_ptr=0;\n                for(i=0;i<n;i++)\n                {\n                        fgets(readbuffer,71,stdin);\n                        readbuffer[strlen(readbuffer)-1]='\\0';\n                        nsp=c_sp(readbuffer);\n                        //printf(\"msp:%d %s\\n\",nsp,readbuffer);\n                        strcpy(&person[person_ptr].name[0],&readbuffer[nsp]);\n                        person[person_ptr].level=nsp;       \n                        if(person_ptr==0)\n                                person[person_ptr].parent=-1;  //root\n                        else\n                                for(j=person_ptr-1;j>=0;j--)\n                                        if(person[j].level==nsp-1)\n                                        {\n                                                person[person_ptr].parent=j;\n                                                //printf(\"%d 's parent is %d\",person_ptr,j);\n                                                break;\n                                        }\n                        person_ptr++;\n                }\n#ifdef DEBUG\n                print_tree();\n#endif\n                for(i=0;i<m;i++)\n                {\n                        fgets(readbuffer,71,stdin);\n                        subject=strtok(readbuffer,\" \");\n                        (void)strtok(NULL,\" \");         // is \n                        (void)strtok(NULL,\" \");         // kansi\n                        relation=strtok(NULL,\" \");\n                        (void)strtok(NULL,\" \");         // of\n                        object=strtok(NULL,\".\");\n#ifdef DEBUG\n                        printf(\"%s %s %s\\n\",subject,relation,object);\n#endif\n                        printf(\"%s\\n\",check_relation(subject,relation,object)?\"True\":\"False\");\n                }\n        }\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1217\n  Title:Family Tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\nint n,m;\nchar person[1000][21];\nint level_table[1000];\nint level2space[1000];\nint parent[1000];\nint name2int(char name[])\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(0==strcmp(name,&person[i][0]))\n      return(i);\n  return(-1);\n}\nint is_child(int n1,int n2)\n{\n  if(parent[n1]==n2)\n    return(-1);\n  else\n    return(0);\n}\nint is_parent(int n1,int n2)\n{\n  return(is_child(n2,n1));\n}\nint is_descendant(int n1,int n2)\n{\n  int i,step;\n  step=level_table[n1];\n  for(i=0;i<step;i++)\n    {\n      if(parent[n1]==n2)\n\treturn(-1);\n      n1=parent[n1];\n    }\n  return(0);\n}\nint is_ancestor(int n1,int n2)\n{\n  return(is_descendant( n2, n1));\n}\nint is_sibring(int n1,int n2)\n{\n  if(parent[n1]==parent[n2])\n    return(-1);\n  else\n    return(0);\n}\nint hanbetu(char person1[],char person2[],char relation[])\n{\n  int n1,n2;\n  n1=name2int(person1);\n  n2=name2int(person2);\n  if(0==strcmp(relation,\"child\"))\n     return(is_child(n1,n2));\n  if(0==strcmp(relation,\"parent\"))\n     return(is_parent(n1,n2));\n  if(0==strcmp(relation,\"ancestor\"))\n     return(is_ancestor(n1,n2));\n  if(0==strcmp(relation,\"sibling\"))\n     return(is_sibring(n1,n2));\n  if(0==strcmp(relation,\"descendant\"))\n     return(is_descendant(n1,n2));\n}\nvoid bunkai(char buf[],char person1[],char person2[],char relation[])\n{\n  char *p;\n  p=strtok(buf,\" \");\n  strcpy(person1,p);\n  p=strtok(NULL,\" \");  // is\n  p=strtok(NULL,\" \");  // kansi\n  p=strtok(NULL,\" \");\n  strcpy(relation,p);\n  p=strtok(NULL,\" \");   // of\n  p=strtok(NULL,\".\");\n  strcpy(person2,p);\n}\nint count_space(char * ptr)\n{\n  int ret=0;\n  while(*ptr==' ')\n    {\n      ptr++;\n      ret++;\n    }\n  return(ret);\n}\nint maxlevel;\nvoid dump()\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d)[%d]:%s[%d]\\n\",i,level_table[i],&person[i][0],parent[i]);\n  for(i=0;i<maxlevel;i++)\n    printf(\"[lv=%d]sp=%d\\n\",i,level2space[i]);\n}\nmain()\n{\n  int i,j,first,level,spaces,oldspaces,oldlevel,mylevel,ret;\n  char buf[70],person1[12],person2[12],relation[11];\n  first=1;\n  while(scanf(\"%d %d \",&n,&m) && (n||m))\n    {\n      spaces=level=oldspaces=maxlevel=0;\n      parent[0]=-1;\n      for(i=0;i<n;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  buf[strlen(buf)-1]='\\0';\n\t  spaces=count_space(buf);\n\t  if(spaces>oldspaces)\n\t    {\n\t      level++;\n\t      maxlevel=max(maxlevel,level);\n\t    }\n\t  else if(spaces<oldspaces)\n\t    for(j=0;j<maxlevel;j++)\n\t      if(level2space[j]<spaces && spaces <=level2space[j+1])\n\t\t{\n\t\tlevel=j+1;\n\t\t//printf(\"lvup=%d\\n\",level);\n\t\t}\n\t  level2space[level]=spaces;\t\n\t  level_table[i]=level;\n\t  strcpy(&person[i][0],&buf[spaces]);\n\t  mylevel=level_table[i];\n\t  if(i>0 || mylevel==0)\n\t    {\n\t      for(j=i-1;j>=0;j--)\n\t\tif(level_table[j]==mylevel-1)\n\t\t  {\n\t\t    parent[i]=j;\n\t\t    break;\n\t\t  }\n\t    }\n\t  oldspaces=spaces;\n\t}\n#ifdef DEBUG      \n      dump();\n#else\n    \n      for(i=0;i<m;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  bunkai(buf,person1,person2,relation);\n\t  ret=hanbetu(person1,person2,relation);\n\t  printf(\"%s\\n\",(ret?\"True\":\"False\"));\n\t}\n      printf(\"\\n\");\n#endif\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1217\n  Title:Family Tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint n,m;\nchar person[1000][21];\nint level_table[1000];\nint space2level[70];\nint parent[1000];\nint name2int(char name[])\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(0==strcmp(name,&person[i][0]))\n      return(i);\n  return(-1);\n}\nint is_child(int n1,int n2)\n{\n  if(parent[n1]==n2)\n    return(-1);\n  else\n    return(0);\n}\nint is_parent(int n1,int n2)\n{\n  return(is_child(n2,n1));\n}\nint is_descendant(int n1,int n2)\n{\n  int i,step;\n  step=level_table[n1];\n  for(i=0;i<step;i++)\n    {\n      if(parent[n1]==n2)\n\treturn(-1);\n      n1=parent[n1];\n    }\n  return(0);\n}\nint is_ancestor(int n1,int n2)\n{\n  return(is_descendant( n2, n1));\n}\nint is_sibring(int n1,int n2)\n{\n  if(parent[n1]==parent[n2])\n    return(-1);\n  else\n    return(0);\n}\nint hanbetu(char person1[],char person2[],char relation[])\n{\n  int n1,n2;\n  n1=name2int(person1);\n  n2=name2int(person2);\n  if(0==strcmp(relation,\"child\"))\n     return(is_child(n1,n2));\n  if(0==strcmp(relation,\"parent\"))\n     return(is_parent(n1,n2));\n  if(0==strcmp(relation,\"ancestor\"))\n     return(is_ancestor(n1,n2));\n  if(0==strcmp(relation,\"sibling\"))\n     return(is_sibring(n1,n2));\n  if(0==strcmp(relation,\"descendant\"))\n     return(is_descendant(n1,n2));\n}\nvoid bunkai(char buf[],char person1[],char person2[],char relation[])\n{\n  char *p;\n  p=strtok(buf,\" \");\n  strcpy(person1,p);\n  p=strtok(NULL,\" \");  // is\n  p=strtok(NULL,\" \");  // kansi\n  p=strtok(NULL,\" \");\n  strcpy(relation,p);\n  p=strtok(NULL,\" \");   // of\n  p=strtok(NULL,\".\");\n  strcpy(person2,p);\n}\nint count_space(char * ptr)\n{\n  int ret=0;\n  while(*ptr==' ')\n    {\n      ptr++;\n      ret++;\n    }\n  return(ret);\n}\nvoid dump()\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d)[%d]:%s[%d]\\n\",i,level_table[i],&person[i][0],parent[i]);\n}\nmain()\n{\n  int i,j,first,level,spaces,oldspaces,oldlevel,mylevel,ret;\n  char buf[70],person1[12],person2[12],relation[11];\n  first=1;\n  while(scanf(\"%d %d \",&n,&m) && (n||m))\n    {\n      spaces=level=oldspaces=0;\n      parent[0]=-1;\n      for(i=0;i<n;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  buf[strlen(buf)-1]='\\0';\n\t  spaces=count_space(buf);\n\t  if(spaces>oldspaces)\n\t    level++;\n\t  else if(spaces<oldspaces)\n\t    level=space2level[spaces];\t\n\t  if(spaces>=oldspaces)\n\t    space2level[spaces]=level;\t\n\t  level_table[i]=level;\n\t  strcpy(&person[i][0],&buf[spaces]);\n\t  mylevel=level_table[i];\n\t  if(i>0 || mylevel==0)\n\t    {\n\t      for(j=i-1;j>=0;j--)\n\t\tif(level_table[j]==mylevel-1)\n\t\t  {\n\t\t    parent[i]=j;\n\t\t    break;\n\t\t  }\n\t    }\n\t  oldspaces=spaces;\n\t}\n      \n      dump();\n      \n      for(i=0;i<m;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  bunkai(buf,person1,person2,relation);\n\t  ret=hanbetu(person1,person2,relation);\n\t  printf(\"%s\\n\",(ret?\"True\":\"False\"));\n\t}\n      printf(\"\\n\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s1[70],s2[70],s3[70],na[1000][70],s[71];\n  int st[1010],n,m,i,j,r,p[1010]={-1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    scanf(\"\\n\");\n    st[0]=-1;\n    for(j=0;j<n;j++){\n      fgets(s,71,stdin);\n      for(i=0;s[i]==' ';i++);\n      st[i+1]=j;\n      p[j]=st[i];//printf(\"%s\\n\",s+i);\n      for(r=0;s[i]-10;i++)na[j][r++]=s[i];\n      na[j][r]=0;\n    }//printf(\"a\\n\");\n    //for(i=0;i<n;i++)printf(\"%d\\n\",p[i]);\n    while(m--){\n      scanf(\"%s %*s %*s %s %*s %s\",s1,s2,s3);//printf(\"%s\\n\",s3);\n      s3[strlen(s3)-1]=0;\n      for(i=0;strcmp(na[i],s1);i++);//printf(\"%d\\n\",i);\n      for(j=0;strcmp(na[j],s3);j++);//printf(\"%d\\n\",j);\n      if(s2[0]=='c'){\n\tif(j==p[i])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='a'){\n\tfor(;j+1;j=p[j]){\n\t  if(i==j)break;\n\t}\n\tif(i==j)printf(\"True\\n\");\n\telse    printf(\"False\\n\");\n      }\n      if(s2[0]=='s'){\n\tif(p[i]==p[j])printf(\"True\\n\");\n\telse          printf(\"False\\n\");\n      }\n      if(s2[0]=='p'){\n\tif(i==p[j])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='d'){\n\tfor(;i+1;i=p[i]){\n\t  if(i==j)break;\n\t}\n\tif(i==j)printf(\"True\\n\");\n\telse    printf(\"False\\n\");\n      }\n    }\n    printf(\"\\n\");  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1217\n  Title:Family Tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\nint n,m;\nchar person[1000][21];\nint level_table[1000];\nint level2space[1000];\nint parent[1000];\nint maxlevel;\n\nvoid dump()\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d)[%d]:%s[%d]\\n\",i,level_table[i],&person[i][0],parent[i]);\n  for(i=0;i<maxlevel;i++)\n    printf(\"[lv=%d]sp=%d\\n\",i,level2space[i]);\n}\n\nint name2int(char name[])\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(0==strcmp(name,&person[i][0]))\n      return(i);\n  return(-1);\n}\nint is_child(int n1,int n2)\n{\n  if(parent[n1]==n2)\n    return(-1);\n  else\n    return(0);\n}\nint is_parent(int n1,int n2)\n{\n  return(is_child(n2,n1));\n}\nint is_descendant(int n1,int n2)\n{\n  int i,step;\n  //printf(\"des:%d %d\\n\",n1,n2);\n  step=level_table[n1];\n  for(i=0;i<step;i++)\n    { \n      if(parent[n1]==n2)\n\treturn(-1);\n      n1=parent[n1];\n      //printf(\"pa;=%d\\n\",n1);\n    }\n  return(0);\n}\nint is_ancestor(int n1,int n2)\n{\n  return(is_descendant( n2, n1));\n}\nint is_sibring(int n1,int n2)\n{\n#ifdef DEBUG\n    printf(\"%d %d pa:%d %d\\n\",n1,n2,parent[n1],parent[n2]);\n#endif\n\n  if(parent[n1]==parent[n2])\n    return(-1);\n  else\n    return(0);\n}\nint hanbetu(char person1[],char person2[],char relation[])\n{\n  int n1,n2;\n  n1=name2int(person1);\n  n2=name2int(person2);\n  if(0==strcmp(relation,\"child\"))\n     return(is_child(n1,n2));\n  if(0==strcmp(relation,\"parent\"))\n     return(is_parent(n1,n2));\n  if(0==strcmp(relation,\"ancestor\"))\n     return(is_ancestor(n1,n2));\n  if(0==strcmp(relation,\"sibling\"))\n     return(is_sibring(n1,n2));\n  if(0==strcmp(relation,\"descendant\"))\n     return(is_descendant(n1,n2));\n}\nvoid bunkai(char buf[],char person1[],char person2[],char relation[])\n{\n  char *p;\n  p=strtok(buf,\" \");\n  strcpy(person1,p);\n  p=strtok(NULL,\" \");  // is\n  p=strtok(NULL,\" \");  // kansi\n  p=strtok(NULL,\" \");\n  strcpy(relation,p);\n  p=strtok(NULL,\" \");   // of\n  p=strtok(NULL,\".\");\n  strcpy(person2,p);\n}\nint count_space(char * ptr)\n{\n  int ret=0;\n  while(*ptr==' ')\n    {\n      ptr++;\n      ret++;\n    }\n  return(ret);\n}\n\nmain()\n{\n  int i,j,first,level,spaces,oldspaces,oldlevel,mylevel,ret;\n  char buf[70],person1[12],person2[12],relation[11];\n  first=1;\n  while(scanf(\"%d %d \",&n,&m) && (n||m))\n    {\n      spaces=level=oldspaces=maxlevel=0;\n      parent[0]=-1;\n      for(i=0;i<n;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  buf[strlen(buf)-1]='\\0';\n\t  spaces=count_space(buf);\n\t  if(spaces>oldspaces)\n\t    {\n\t      level++;\n\t      maxlevel=max(maxlevel,level);\n\t    }\n\t  else if(spaces<oldspaces)\n\t    for(j=0;j<maxlevel;j++)\n\t      if(level2space[j]<spaces && spaces <=level2space[j+1])\n\t\t{\n\t\tlevel=j+1;\n\t\t//printf(\"lvup=%d\\n\",level);\n\t\t}\n\t  level2space[level]=spaces;\t\n\t  level_table[i]=level;\n\t  strcpy(&person[i][0],&buf[spaces]);\n\t  mylevel=level_table[i];\n\t  if(i>0 || mylevel==0)\n\t    {\n\t      for(j=i-1;j>=0;j--)\n\t\tif(level_table[j]==mylevel-1)\n\t\t  {\n\t\t    parent[i]=j;\n\t\t    break;\n\t\t  }\n\t    }\n\t  oldspaces=spaces;\n\t}\n#ifdef DEBUG      \n      dump();\n#else\n    \n      for(i=0;i<m;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  bunkai(buf,person1,person2,relation);\n\n\t  //printf(\"p1 p2 = %s : %s [%s]\\n\",person1,person2,relation);\n#ifdef DEBUG\n\t  printf(\"p1 p2 = %d : %d\\n\",name2int(person1),name2int(person2));\n#endif\n\t  ret=hanbetu(person1,person2,relation);\n\t  printf(\"%s\\n\",(ret?\"True\":\"False\"));\n\t}\n      printf(\"\\n\");\n#endif\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1217\n  Title:Family Tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint n,m;\nchar person[1000][21];\nint level_table[1000];\nint space2level[70];\nint parent[1000];\nint name2int(char name[])\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(0==strcmp(name,&person[i][0]))\n      return(i);\n  return(-1);\n}\nint is_child(int n1,int n2)\n{\n  if(parent[n1]==n2)\n    return(-1);\n  else\n    return(0);\n}\nint is_parent(int n1,int n2)\n{\n  return(is_child(n2,n1));\n}\nint is_descendant(int n1,int n2)\n{\n  int i,step;\n  step=level_table[n1];\n  for(i=0;i<step;i++)\n    {\n      if(parent[n1]==n2)\n\treturn(-1);\n      n1=parent[n1];\n    }\n  return(0);\n}\nint is_ancestor(int n1,int n2)\n{\n  return(is_descendant( n2, n1));\n}\nint is_sibring(int n1,int n2)\n{\n  if(parent[n1]==parent[n2])\n    return(-1);\n  else\n    return(0);\n}\nint hanbetu(char person1[],char person2[],char relation[])\n{\n  int n1,n2;\n  n1=name2int(person1);\n  n2=name2int(person2);\n  if(0==strcmp(relation,\"child\"))\n     return(is_child(n1,n2));\n  if(0==strcmp(relation,\"parent\"))\n     return(is_parent(n1,n2));\n  if(0==strcmp(relation,\"ancestor\"))\n     return(is_ancestor(n1,n2));\n  if(0==strcmp(relation,\"sibling\"))\n     return(is_sibring(n1,n2));\n  if(0==strcmp(relation,\"descendant\"))\n     return(is_descendant(n1,n2));\n}\nvoid bunkai(char buf[],char person1[],char person2[],char relation[])\n{\n  char *p;\n  p=strtok(buf,\" \");\n  strcpy(person1,p);\n  p=strtok(NULL,\" \");  // is\n  p=strtok(NULL,\" \");  // kansi\n  p=strtok(NULL,\" \");\n  strcpy(relation,p);\n  p=strtok(NULL,\" \");   // of\n  p=strtok(NULL,\".\");\n  strcpy(person2,p);\n}\nint count_space(char * ptr)\n{\n  int ret=0;\n  while(*ptr==' ')\n    {\n      ptr++;\n      ret++;\n    }\n  return(ret);\n}\nvoid dump()\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d)[%d]:%s[%d]\\n\",i,level_table[i],&person[i][0],parent[i]);\n}\nmain()\n{\n  int i,j,first,level,spaces,oldspaces,oldlevel,mylevel,ret;\n  char buf[70],person1[12],person2[12],relation[11];\n  first=1;\n  while(scanf(\"%d %d \",&n,&m) && (n||m))\n    {\n      spaces=level=oldspaces=0;\n      for(i=0;i<n;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  buf[strlen(buf)-1]='\\0';\n\t  spaces=count_space(buf);\n\t  if(spaces>oldspaces)\n\t    level++;\n\t  else if(spaces<oldspaces)\n\t    level=space2level[spaces];\t\n\t  if(spaces>=oldspaces)\n\t    space2level[spaces]=level;\t\n\t  level_table[i]=level;\n\t  strcpy(&person[i][0],&buf[spaces]);\n\t  mylevel=level_table[i];\n\t  if(i>0 || mylevel==0)\n\t    {\n\t      for(j=i-1;j>=0;j--)\n\t\tif(level_table[j]==mylevel-1)\n\t\t  {\n\t\t    parent[i]=j;\n\t\t    break;\n\t\t  }\n\t    }\n\t  oldspaces=spaces;\n\t}\n      \n      //dump();\n      \n      if(!first)\n\tprintf(\"\\n\");\n      else\n\tfirst=0;\n\n      \n      for(i=0;i<m;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  bunkai(buf,person1,person2,relation);\n\t  ret=hanbetu(person1,person2,relation);\n\t  printf(\"%s\\n\",(ret?\"True\":\"False\"));\n\t}\n      \n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s1[70],s2[70],s3[70],na[1000][70],s[71];\n  int st[1010],n,m,i,j,r,p[1010]={-1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    scanf(\"\\n\");\n    st[0]=-1;\n    for(j=0;j<n;j++){\n      fgets(s,71,stdin);\n      for(i=0;s[i]==' ';i++);\n      st[i+1]=j;\n      p[j]=st[i];//printf(\"%s\\n\",s+i);\n      for(r=0;s[i]-10;i++)na[j][r++]=s[i];\n      na[j][r]=0;\n    }//printf(\"a\\n\");\n    //for(i=0;i<n;i++)printf(\"%d\\n\",p[i]);\n    while(m--){\n      scanf(\"%s %*s %*s %s %*s %s\",s1,s2,s3);//printf(\"%s\\n\",s3);\n      s3[strlen(s3)-1]=0;\n      for(i=0;strcmp(na[i],s1);i++);//printf(\"%d\\n\",i);\n      for(j=0;strcmp(na[j],s3);j++);//printf(\"%d\\n\",j);\n      if(s2[0]=='c'){\n\tif(j==p[i])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='a'){\n\tfor(;j;j=p[j]){\n\t  if(i==j)break;\n\t}\n\tif(j)printf(\"True\\n\");\n\telse printf(\"False\\n\");\n      }\n      if(s2[0]=='s'){\n\tif(p[i]==p[j])printf(\"True\\n\");\n\telse          printf(\"False\\n\");\n      }\n      if(s2[0]=='p'){\n\tif(i==p[j])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='d'){\n\tfor(;i;i=p[i]){\n\t  if(i==j)break;\n\t}\n\tif(i)printf(\"True\\n\");\n\telse printf(\"False\\n\");\n      }\n    }\n    printf(\"\\n\");  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s1[70],s2[70],s3[70],na[1000][70],s[71];\n  int st[1000],n,m,i,j,r,p[1000]={-1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    scanf(\"\\n\");\n    for(j=st[0]=0;j<n;j++){\n      fgets(s,71,stdin);\n      for(i=0;s[i]==' ';i++);\n      st[i+1]=j;\n      p[j]=st[i];//printf(\"%s\\n\",s+i);\n      for(r=0;s[i]-10;i++)na[j][r++]=s[i];\n      na[j][r]=0;\n    }//printf(\"a\\n\");\n    //for(i=0;i<n;i++)printf(\"%d\\n\",p[i]);\n    while(m--){\n      scanf(\"%s %*s %*s %s %*s %s\",s1,s2,s3);//printf(\"%s\\n\",s3);\n      s3[strlen(s3)-1]=0;\n      for(i=0;strcmp(na[i],s1);i++);//printf(\"%d\\n\",i);\n      for(j=0;strcmp(na[j],s3);j++);//printf(\"%d\\n\",j);\n      if(s2[0]=='c'){\n\tif(j==p[i])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='a'){\n\tfor(;j;j=p[j]){\n\t  if(i==j)break;\n\t}\n\tif(j)printf(\"True\\n\");\n\telse printf(\"False\\n\");\n      }\n      if(s2[0]=='s'){\n\tif(p[i]==p[j])printf(\"True\\n\");\n\telse          printf(\"False\\n\");\n      }\n      if(s2[0]=='p'){\n\tif(i==p[j])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='d'){\n\tfor(;i;i=p[i]){\n\t  if(i==j)break;\n\t}\n\tif(i)printf(\"True\\n\");\n\telse printf(\"False\\n\");\n      }\n    }\n    printf(\"\\n\");  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1217\n  Title:Family Tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\nint n,m;\nchar person[1000][21];\nint level_table[1000];\nint level2space[1000];\nint parent[1000];\nint name2int(char name[])\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(0==strcmp(name,&person[i][0]))\n      return(i);\n  return(-1);\n}\nint is_child(int n1,int n2)\n{\n  if(parent[n1]==n2)\n    return(-1);\n  else\n    return(0);\n}\nint is_parent(int n1,int n2)\n{\n  return(is_child(n2,n1));\n}\nint is_descendant(int n1,int n2)\n{\n  int i,step;\n  step=level_table[n1];\n  for(i=0;i<step;i++)\n    {\n      if(parent[n1]==n2)\n\treturn(-1);\n      n1=parent[n1];\n    }\n  return(0);\n}\nint is_ancestor(int n1,int n2)\n{\n  return(is_descendant( n2, n1));\n}\nint is_sibring(int n1,int n2)\n{\n  if(parent[n1]==parent[n2])\n    return(-1);\n  else\n    return(0);\n}\nint hanbetu(char person1[],char person2[],char relation[])\n{\n  int n1,n2;\n  n1=name2int(person1);\n  n2=name2int(person2);\n  if(0==strcmp(relation,\"child\"))\n     return(is_child(n1,n2));\n  if(0==strcmp(relation,\"parent\"))\n     return(is_parent(n1,n2));\n  if(0==strcmp(relation,\"ancestor\"))\n     return(is_ancestor(n1,n2));\n  if(0==strcmp(relation,\"sibling\"))\n     return(is_sibring(n1,n2));\n  if(0==strcmp(relation,\"descendant\"))\n     return(is_descendant(n1,n2));\n}\nvoid bunkai(char buf[],char person1[],char person2[],char relation[])\n{\n  char *p;\n  p=strtok(buf,\" \");\n  strcpy(person1,p);\n  p=strtok(NULL,\" \");  // is\n  p=strtok(NULL,\" \");  // kansi\n  p=strtok(NULL,\" \");\n  strcpy(relation,p);\n  p=strtok(NULL,\" \");   // of\n  p=strtok(NULL,\".\");\n  strcpy(person2,p);\n}\nint count_space(char * ptr)\n{\n  int ret=0;\n  while(*ptr==' ')\n    {\n      ptr++;\n      ret++;\n    }\n  return(ret);\n}\nint maxlevel;\nvoid dump()\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d)[%d]:%s[%d]\\n\",i,level_table[i],&person[i][0],parent[i]);\n  for(i=0;i<maxlevel;i++)\n    printf(\"[lv=%d]sp=%d\\n\",i,level2space[i]);\n}\nmain()\n{\n  int i,j,first,level,spaces,oldspaces,oldlevel,mylevel,ret;\n  char buf[70],person1[12],person2[12],relation[11];\n  first=1;\n  while(scanf(\"%d %d \",&n,&m) && (n||m))\n    {\n      spaces=level=oldspaces=maxlevel=0;\n      parent[0]=-1;\n      for(i=0;i<n;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  buf[strlen(buf)-1]='\\0';\n\t  spaces=count_space(buf);\n\t  if(spaces>oldspaces)\n\t    {\n\t      level++;\n\t      maxlevel=max(maxlevel,level);\n\t    }\n\t  else if(spaces<oldspaces)\n\t    for(j=0;j<maxlevel;j++)\n\t      if(level2space[j]<=spaces && spaces <level2space[j+1])\n\t\t{\n\t\tlevel=j+1;\n\t\t//printf(\"lvup=%d\\n\",level);\n\t\t}\n\t  level2space[level]=spaces;\t\n\t  level_table[i]=level;\n\t  strcpy(&person[i][0],&buf[spaces]);\n\t  mylevel=level_table[i];\n\t  if(i>0 || mylevel==0)\n\t    {\n\t      for(j=i-1;j>=0;j--)\n\t\tif(level_table[j]==mylevel-1)\n\t\t  {\n\t\t    parent[i]=j;\n\t\t    break;\n\t\t  }\n\t    }\n\t  oldspaces=spaces;\n\t}\n#ifdef DEBUG      \n      dump();\n#else\n    \n      for(i=0;i<m;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  bunkai(buf,person1,person2,relation);\n\t  ret=hanbetu(person1,person2,relation);\n\t  printf(\"%s\\n\",(ret?\"True\":\"False\"));\n\t}\n      printf(\"\\n\");\n#endif\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s1[70],s2[70],s3[70],na[1000][70],s[71];\n  int st[1000],n,m,i,j,r,p[1000]={-1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    scanf(\"\\n\");\n    st[0]=-1;\n    for(j=0;j<n;j++){\n      fgets(s,71,stdin);\n      for(i=0;s[i]==' ';i++);\n      st[i+1]=j;\n      p[j]=st[i];//printf(\"%s\\n\",s+i);\n      for(r=0;s[i]-10;i++)na[j][r++]=s[i];\n      na[j][r]=0;\n    }//printf(\"a\\n\");\n    //for(i=0;i<n;i++)printf(\"%d\\n\",p[i]);\n    while(m--){\n      scanf(\"%s %*s %*s %s %*s %s\",s1,s2,s3);//printf(\"%s\\n\",s3);\n      s3[strlen(s3)-1]=0;\n      for(i=0;strcmp(na[i],s1);i++);//printf(\"%d\\n\",i);\n      for(j=0;strcmp(na[j],s3);j++);//printf(\"%d\\n\",j);\n      if(s2[0]=='c'){\n\tif(j==p[i])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='a'){\n\tfor(;j;j=p[j]){\n\t  if(i==j)break;\n\t}\n\tif(j)printf(\"True\\n\");\n\telse printf(\"False\\n\");\n      }\n      if(s2[0]=='s'){\n\tif(p[i]==p[j])printf(\"True\\n\");\n\telse          printf(\"False\\n\");\n      }\n      if(s2[0]=='p'){\n\tif(i==p[j])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='d'){\n\tfor(;i;i=p[i]){\n\t  if(i==j)break;\n\t}\n\tif(i)printf(\"True\\n\");\n\telse printf(\"False\\n\");\n      }\n    }\n    printf(\"\\n\");  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1217\n  Title:Family Tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\nint n,m;\nchar person[1000][21];\nint level_table[1000];\nint level2space[1000];\nint parent[1000];\nint maxlevel;\n\nint name2int(char name[])\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(0==strcmp(name,&person[i][0]))\n      return(i);\n  return(-1);\n}\nint is_child(int n1,int n2)\n{\n  if(parent[n1]==n2)\n    return(-1);\n  else\n    return(0);\n}\nint is_parent(int n1,int n2)\n{\n  return(is_child(n2,n1));\n}\nint is_descendant(int n1,int n2)\n{\n  int i,step;\n  //printf(\"des:%d %d\\n\",n1,n2);\n  step=level_table[n1];\n  for(i=0;i<step;i++)\n    { \n      if(parent[n1]==n2)\n\treturn(-1);\n      n1=parent[n1];\n      //printf(\"pa;=%d\\n\",n1);\n    }\n  return(0);\n}\nint is_ancestor(int n1,int n2)\n{\n  return(is_descendant( n2, n1));\n}\nint is_sibring(int n1,int n2)\n{\n#ifdef DEBUG\n    printf(\"%d %d pa:%d %d\\n\",n1,n2,parent[n1],parent[n2]);\n#endif\n\n  if(parent[n1]==parent[n2])\n    return(-1);\n  else\n    return(0);\n}\nint hanbetu(char person1[],char person2[],char relation[])\n{\n  int n1,n2;\n  n1=name2int(person1);\n  n2=name2int(person2);\n  if(0==strcmp(relation,\"child\"))\n     return(is_child(n1,n2));\n  if(0==strcmp(relation,\"parent\"))\n     return(is_parent(n1,n2));\n  if(0==strcmp(relation,\"ancestor\"))\n     return(is_ancestor(n1,n2));\n  if(0==strcmp(relation,\"sibling\"))\n     return(is_sibring(n1,n2));\n  if(0==strcmp(relation,\"descendant\"))\n     return(is_descendant(n1,n2));\n}\nvoid bunkai(char buf[],char person1[],char person2[],char relation[])\n{\n  char *p;\n  p=strtok(buf,\" \");\n  strcpy(person1,p);\n  p=strtok(NULL,\" \");  // is\n  p=strtok(NULL,\" \");  // kansi\n  p=strtok(NULL,\" \");\n  strcpy(relation,p);\n  p=strtok(NULL,\" \");   // of\n  p=strtok(NULL,\".\");\n  strcpy(person2,p);\n}\nint count_space(char * ptr)\n{\n  int ret=0;\n  while(*ptr==' ')\n    {\n      ptr++;\n      ret++;\n    }\n  return(ret);\n}\n\nmain()\n{\n  int i,j,first,level,spaces,oldspaces,oldlevel,mylevel,ret;\n  char buf[70],person1[20],person2[20],relation[11];\n  first=1;\n  while(scanf(\"%d %d \",&n,&m) && (n||m))\n    {\n      spaces=level=oldspaces=maxlevel=0;\n\n      memset(person,0,1000*21);\n      memset(parent,-1,sizeof(int)*1000);\n      memset(level_table,0,sizeof(int)*1000);\n      memset(level2space,-1,sizeof(int)*1000);\n      for(i=0;i<n;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  buf[strlen(buf)-1]='\\0';\n\t  spaces=count_space(buf);\n\t  if(spaces>oldspaces)\n\t    {\n\t      level++;\n\t      maxlevel=max(maxlevel,level);\n\t    }\n\t  else if(spaces<oldspaces)\n\t    for(j=0;j<maxlevel;j++)\n\t      if(level2space[j]<spaces && spaces <=level2space[j+1])\n\t\t{\n\t\tlevel=j+1;\n\t\t//printf(\"lvup=%d\\n\",level);\n\t\t}\n\t  level2space[level]=spaces;\t\n\t  level_table[i]=level;\n\t  strcpy(&person[i][0],&buf[spaces]);\n\t  mylevel=level_table[i];\n\t  if(i>0 || mylevel==0)\n\t    {\n\t      for(j=i-1;j>=0;j--)\n\t\tif(level_table[j]==mylevel-1)\n\t\t  {\n\t\t    parent[i]=j;\n\t\t    break;\n\t\t  }\n\t    }\n\t  oldspaces=spaces;\n\t}\n    \n      for(i=0;i<m;i++)\n\t{\n\t  memset(buf,0,70);\n\t  fgets(buf,70,stdin);\n\t  bunkai(buf,person1,person2,relation);\n\n\t  ret=hanbetu(person1,person2,relation);\n\n\t  printf(\"%s\\n\",(ret?\"True\":\"False\"));\n\t}\n      printf(\"\\n\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1217: Family Tree\n// 2017.10.15\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define HASHSIZ 2003\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\n\nint insert(char *s, int w, int id)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nint lookup(char *s, int w)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\ntypedef struct { char nm[21]; int p; } T;\nT t[1002]; int sz;\n\nchar buf[101], *p;\nint n;\n\nint parse(int w, int par)\n{\n\tint l, k, nd, w2;\n\n\tp = buf; l = 0; while (isspace(*p)) p++, l++;\n\twhile (1) {\n\t\tp = buf, w2 = 0; while (isspace(*p)) p++, w2++;\n\t\tif (w2 == l) {\n\t\t\tk = strlen(p) - 1; p[k] = 0;\n\t\t\tnd = sz++;\n\t\t\tstrcpy(t[nd].nm, p); t[nd].p = par; insert(t[nd].nm, k, nd);\n\t\t} else if (w2 < l) return 1;\n\t\tif (n == 0) return 0;\n\t\tfgets(p=buf, 100, stdin), n--;\n\t\tw2 = 0; while (isspace(*p)) p++, w2++;\n\t\tif (w2 == l) continue;\n\t\tif (w2 < l) return 1;\n\t\tif (!parse(l, nd)) return 0;\n\t}\n\treturn 0;\n}\n\nint seek(int par, int chi)\n{\n\tif (t[chi].p == par) return 1;\n\tif (t[chi].p == 0) return 0;\n\treturn seek(par, t[chi].p);\n}\n\nchar *next(char *p, int skipsps)\n{\n\twhile (isspace(*p)) p++;\n\tif (!skipsps) while (isalpha(*p)) p++;\n\twhile (isspace(*p)) p++;\n\treturn p;\n}\n\nint main()\n{\n\tint m, a, b, ans;\n\tchar *q, rel, *msg[] = { \"False\", \"True\" };\n\n\twhile (fgets(p=buf, 100, stdin) && *buf != '0') {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tn = atoi(p); while (*p >= '0') p++; m = atoi(p);\n\n\t\tsz = 1; fgets(buf, 100, stdin); n--;\n\t\tparse(0, 0);\n\n\t\twhile (m-- > 0) {\n\t\t\tfgets(buf, 100, stdin); p = next(buf, 1);\n\t\t\tq = p; while (isalpha(*p)) p++; *p = 0;\n\t\t\ta = lookup(q, p-q); p++;\n\t\t\tp = next(p, 0); p = next(p, 0);  // skip is a/an\n\t\t\trel = *p++;\n\t\t\tp = next(p, 0); p = next(p, 0);  // skip rel.. of \n\t\t\tq = p; while (isalpha(*p)) p++; *p = 0;\n\t\t\tb = lookup(q, p-q);\n\n\t\t\tif      (rel == 'c') ans = (t[a].p == b);\n\t\t\telse if (rel == 'p') ans = (t[b].p == a);\n\t\t\telse if (rel == 's') ans = (t[a].p == t[b].p);\n\t\t\telse if (rel == 'd') ans = seek(b, a);\n\t\t\telse                 ans = seek(a, b);\n\t\t\tputs(msg[ans]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s1[70],s2[70],s3[70],na[1000][70],s[71];\n  int st[1010],n,m,i,j,r,p[1010]={-1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    scanf(\"\\n\");\n    st[0]=-1;\n    for(j=0;j<n;j++){\n      fgets(s,71,stdin);\n      for(i=0;s[i]==' ';i++);\n      st[i+1]=j;\n      p[j]=st[i];//printf(\"%s\\n\",s+i);\n      for(r=0;s[i]-10;i++)na[j][r++]=s[i];\n      na[j][r]=0;\n    }//printf(\"a\\n\");\n    //for(i=0;i<n;i++)printf(\"%d\\n\",p[i]);\n    while(m--){\n      scanf(\"%s %*s %*s %s %*s %s\",s1,s2,s3);//printf(\"%s\\n\",s3);\n      s3[strlen(s3)-1]=0;\n      for(i=0;strcmp(na[i],s1);i++);//printf(\"%d\\n\",i);\n      for(j=0;strcmp(na[j],s3);j++);//printf(\"%d\\n\",j);\n      if(s2[0]=='c'){\n\tif(j==p[i])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='a'){\n\tfor(;j+1;j=p[j]){\n\t  if(i==j)break;\n\t}\n\tif(j)printf(\"True\\n\");\n\telse printf(\"False\\n\");\n      }\n      if(s2[0]=='s'){\n\tif(p[i]==p[j])printf(\"True\\n\");\n\telse          printf(\"False\\n\");\n      }\n      if(s2[0]=='p'){\n\tif(i==p[j])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='d'){\n\tfor(;i+1;i=p[i]){\n\t  if(i==j)break;\n\t}\n\tif(i)printf(\"True\\n\");\n\telse printf(\"False\\n\");\n      }\n    }\n    printf(\"\\n\");  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1217\nTitle Family tree\nRE\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n,m;\nstruct p_str\n{\n        char name[21];\n        int  parent;\n        int  level;       //no of indent\n} person[1001];\nint person_ptr;\nchar query[71];\nchar readbuffer[71];\n//\nint c_sp(char *s)\n{\n        int i;\n        int cnt;\n\n        for(i=0;s[i];i++)\n                if(s[i]!=' ')\n                        break;\n        return(i);\n}\nvoid print_tree()\n{\n        int i;\n        printf(\"----------------------\\n\");\n        for(i=0;i<person_ptr;i++)\n        {\n                printf(\"%d %s\",person[i].level,person[i].name);\n                if(i)\n                        printf(\"(%s)\",person[person[i].parent].name);\n                printf(\"\\n\");\n        }\n}\nint name2sno(char * name)\n{\n        int i;\n        for(i=0;i<person_ptr;i++)\n                if(0==strcmp(name,person[i].name))\n                        return(i);\n        return(-1);\n}\nint check_relation(char * sub,char * rel,char *obj)\n{\n        int sn,on;\n        sn=name2sno(sub);\n        on=name2sno(obj);\n        if(0==strcmp(rel,\"parent\"))\n                return(person[on].parent == sn);\n        if(0==strcmp(rel,\"child\"))\n        {\n                return(person[sn].parent == on);\n        }\n        if(0==strcmp(rel,\"sibling\"))\n        {\n                return(person[sn].parent == person[on].parent);\n        }\n        if(0==strcmp(rel,\"ancestor\"))\n        {\n        LOOP:\n                if(person[on].parent < 0)\n                        return(0);\n                if(sn== person[on].parent)\n                        return(-1);\n                on=person[on].parent;\n                goto LOOP;\n        }\n        if(0==strcmp(rel,\"descendant\"))\n        {\n        LOOP2:\n                if(person[sn].parent < 0)\n                        return(0);\n                if(on== person[sn].parent)\n                        return(-1);\n                sn=person[sn].parent;\n                goto LOOP2;\n        }\n\n        return(0);\n}\nmain()\n{\n        int i,j,first;;\n        int nsp;  // no of leading space\n        char *subject;\n        char *object;\n        char *relation;\n\n        first=0;\n        while(EOF!=scanf(\"%d %d\\n\",&n,&m) && (n||m))\n        {       \n                //printf(\"NM %d %d \\n\",n,m);        \n                person_ptr=0;\n                for(i=0;i<n;i++)\n                {\n                        fgets(readbuffer,71,stdin);\n                        if(readbuffer[strlen(readbuffer)-1]=='\\n')\n                                readbuffer[strlen(readbuffer)-1]='\\0';\n                        nsp=c_sp(readbuffer);\n                        //printf(\"msp:%d %s\\n\",nsp,readbuffer);\n                        strcpy(&person[person_ptr].name[0],&readbuffer[nsp]);\n                        person[person_ptr].level=nsp;       \n                        if(person_ptr==0)\n                                person[person_ptr].parent=-1;  //root\n                        else\n                                for(j=person_ptr-1;j>=0;j--)\n                                        if(person[j].level==nsp-1)\n                                        {\n                                                person[person_ptr].parent=j;\n                                                //printf(\"%d 's parent is %d\",person_ptr,j);\n                                                break;\n                                        }\n                        person_ptr++;\n                }\n#ifdef DEBUG\n                print_tree();\n#endif\n                for(i=0;i<m;i++)\n                {\n                        fgets(readbuffer,71,stdin);\n                        subject=strtok(readbuffer,\" \");\n                        (void)strtok(NULL,\" \");         // is \n                        (void)strtok(NULL,\" \");         // kansi\n                        relation=strtok(NULL,\" \");\n                        (void)strtok(NULL,\" \");         // of\n                        object=strtok(NULL,\".\");\n#ifdef DEBUG\n                        printf(\"%s %s %s\\n\",subject,relation,object);\n#endif\n                        printf(\"%s\\n\",check_relation(subject,relation,object)?\"True\":\"False\");\n                }\n                if(first==0)\n                        printf(\"\\n\");\n                first=-1;\n        }\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1217\n  Title:Family Tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint n,m;\nchar person[1000][21];\nint level_table[1000];\nint space2level[70];\nint parent[1000];\nint name2int(char name[])\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(0==strcmp(name,&person[i][0]))\n      return(i);\n  return(-1);\n}\nint is_child(int n1,int n2)\n{\n  if(parent[n1]==n2)\n    return(-1);\n  else\n    return(0);\n}\nint is_parent(int n1,int n2)\n{\n  return(is_child(n2,n1));\n}\nint is_descendant(int n1,int n2)\n{\n  int i,step;\n  step=level_table[n1];\n  for(i=0;i<step;i++)\n    {\n      if(parent[n1]==n2)\n\treturn(-1);\n      n1=parent[n1];\n    }\n  return(0);\n}\nint is_ancestor(int n1,int n2)\n{\n  return(is_descendant( n2, n1));\n}\nint is_sibring(int n1,int n2)\n{\n  if(parent[n1]==parent[n2])\n    return(-1);\n  else\n    return(0);\n}\nint hanbetu(char person1[],char person2[],char relation[])\n{\n  int n1,n2;\n  n1=name2int(person1);\n  n2=name2int(person2);\n  if(0==strcmp(relation,\"child\"))\n     return(is_child(n1,n2));\n  if(0==strcmp(relation,\"parent\"))\n     return(is_parent(n1,n2));\n  if(0==strcmp(relation,\"ancestor\"))\n     return(is_ancestor(n1,n2));\n  if(0==strcmp(relation,\"sibling\"))\n     return(is_sibring(n1,n2));\n  if(0==strcmp(relation,\"descendant\"))\n     return(is_descendant(n1,n2));\n}\nvoid bunkai(char buf[],char person1[],char person2[],char relation[])\n{\n  char *p;\n  p=strtok(buf,\" \");\n  strcpy(person1,p);\n  p=strtok(NULL,\" \");  // is\n  p=strtok(NULL,\" \");  // kansi\n  p=strtok(NULL,\" \");\n  strcpy(relation,p);\n  p=strtok(NULL,\" \");   // of\n  p=strtok(NULL,\".\");\n  strcpy(person2,p);\n}\nint count_space(char * ptr)\n{\n  int ret=0;\n  while(*ptr==' ')\n    {\n      ptr++;\n      ret++;\n    }\n  return(ret);\n}\nvoid dump()\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d)[%d]:%s[%d]\\n\",i,level_table[i],&person[i][0],parent[i]);\n}\nmain()\n{\n  int i,j,first,level,spaces,oldspaces,oldlevel,mylevel,ret;\n  char buf[70],person1[12],person2[12],relation[11];\n  first=1;\n  while(scanf(\"%d %d \",&n,&m) && (n||m))\n    {\n      spaces=level=oldspaces=0;\n      for(i=0;i<n;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  buf[strlen(buf)-1]='\\0';\n\t  spaces=count_space(buf);\n\t  if(spaces>oldspaces)\n\t    level++;\n\t  else if(spaces<oldspaces)\n\t    level=space2level[spaces];\t\n\t  if(spaces>=oldspaces)\n\t    space2level[spaces]=level;\t\n\t  level_table[i]=level;\n\t  strcpy(&person[i][0],&buf[spaces]);\n\t  mylevel=level_table[i];\n\t  if(i>0 || mylevel==0)\n\t    {\n\t      for(j=i-1;j>=0;j--)\n\t\tif(level_table[j]==mylevel-1)\n\t\t  {\n\t\t    parent[i]=j;\n\t\t    break;\n\t\t  }\n\t    }\n\t  oldspaces=spaces;\n\t}\n      \n      //dump();\n      \n      for(i=0;i<m;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  bunkai(buf,person1,person2,relation);\n\t  ret=hanbetu(person1,person2,relation);\n\t  printf(\"%s\\n\",(ret?\"True\":\"False\"));\n\t}\n      printf(\"\\n\");\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1217: Family Tree\n// 2017.10.15\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define HASHSIZ 2003\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\t\t\t// Hash table\n\nint insert(char *s, int w, int id)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\nint lookup(char *s, int w)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\ntypedef struct { char nm[21]; int p; } T;\nT t[1002]; int sz;\n\nchar buf[101], *p;\nint n;\n\nint parse(int w, int par)\n{\n\tint l, k, nd, w2;\n\n\tp = buf; l = 0; while (isspace(*p)) p++, l++;\n\twhile (1) {\n\t\tk = strlen(p) - 1; p[k] = 0;\n\t\tnd = sz++;\n\t\tstrcpy(t[nd].nm, p); t[nd].p = par; insert(t[nd].nm, k, nd);\n\t\tif (n == 0) return 0;\n\t\tfgets(p=buf, 100, stdin), n--;\n\t\tw2 = 0; while (isspace(*p)) p++, w2++;\n\t\tif (w2 == l) continue;\n\t\tif (w2 < l) return 1;\n\t\tif (!parse(l, nd)) return 0;\n\t}\n\treturn 0;\n}\n\nint seek(int par, int chi)\n{\n\tif (t[chi].p == par) return 1;\n\tif (t[chi].p == 0) return 0;\n\treturn seek(par, t[chi].p);\n}\n\nchar *next(char *p, int skipsps)\n{\n\twhile (isspace(*p)) p++;\n\tif (!skipsps) while (isalpha(*p)) p++;\n\twhile (isspace(*p)) p++;\n\treturn p;\n}\n\nint main()\n{\n\tint m, a, b, ans;\n\tchar *q, rel, *msg[] = { \"False\", \"True\" };\n\n\twhile (fgets(p=buf, 100, stdin) && *buf != '0') {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tn = atoi(p); while (*p >= '0') p++; m = atoi(p);\n\n\t\tsz = 1; fgets(buf, 100, stdin); n--;\n\t\tparse(0, 0);\n\n\t\twhile (m-- > 0) {\n\t\t\tfgets(buf, 100, stdin); p = next(buf, 1);\n\t\t\tq = p; while (isalpha(*p)) p++; *p = 0;\n\t\t\ta = lookup(q, p-q); p++;\n\t\t\tp = next(p, 0); p = next(p, 0);  // skip is a/an\n\t\t\trel = *p++;\n\t\t\tp = next(p, 0); p = next(p, 0);  // skip rel.. of \n\t\t\tq = p; while (isalpha(*p)) p++; *p = 0;\n\t\t\tb = lookup(q, p-q);\n\t\t\tif      (rel == 'c') ans = (t[a].p == b);\n\t\t\telse if (rel == 'p') ans = (t[b].p == a);\n\t\t\telse if (rel == 's') ans = (t[a].p == t[b].p);\n\t\t\telse if (rel == 'd') ans = seek(b, a);\n\t\t\telse                 ans = seek(a, b);\n\t\t\tputs(msg[ans]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1217\nTitle Family tree\nRE\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n,m;\nstruct p_str\n{\n        char name[21];\n        int  parent;\n        int  level;       //no of indent\n} person[1001];\nint person_ptr;\nchar query[71];\nchar readbuffer[71];\n//\nint c_sp(char *s)\n{\n        int i;\n        int cnt;\n\n        for(i=0;s[i];i++)\n                if(s[i]!=' ')\n                        break;\n        return(i);\n}\nvoid print_tree()\n{\n        int i;\n        printf(\"----------------------\\n\");\n        for(i=0;i<person_ptr;i++)\n        {\n                printf(\"%d %s\",person[i].level,person[i].name);\n                if(i)\n                        printf(\"(%s)\",person[person[i].parent].name);\n                printf(\"\\n\");\n        }\n}\nint name2sno(char * name)\n{\n        int i;\n        for(i=0;i<person_ptr;i++)\n                if(0==strcmp(name,person[i].name))\n                        return(i);\n        return(-1);\n}\nint check_relation(char * sub,char * rel,char *obj)\n{\n        int sn,on;\n        sn=name2sno(sub);\n        on=name2sno(obj);\n        if(0==strcmp(rel,\"parent\"))\n                return(person[on].parent == sn);\n        if(0==strcmp(rel,\"child\"))\n        {\n                return(person[sn].parent == on);\n        }\n        if(0==strcmp(rel,\"sibling\"))\n        {\n                return(person[sn].parent == person[on].parent);\n        }\n        if(0==strcmp(rel,\"ancestor\"))\n        {\n        LOOP:\n                if(person[on].parent < 0)\n                        return(0);\n                if(sn== person[on].parent)\n                        return(-1);\n                on=person[on].parent;\n                goto LOOP;\n        }\n        if(0==strcmp(rel,\"descendant\"))\n        {\n        LOOP2:\n                if(person[sn].parent < 0)\n                        return(0);\n                if(on== person[sn].parent)\n                        return(-1);\n                sn=person[sn].parent;\n                goto LOOP2;\n        }\n\n        return(0);\n}\nmain()\n{\n        int i,j;\n        int nsp;  // no of leading space\n        char *subject;\n        char *object;\n        char *relation;\n        while(EOF!=scanf(\"%d %d\\n\",&n,&m) && (n||m))\n        {       \n                //printf(\"NM %d %d \\n\",n,m);        \n                person_ptr=0;\n                for(i=0;i<n;i++)\n                {\n                        fgets(readbuffer,71,stdin);\n                        if(readbuffer[strlen(readbuffer)-1]=='\\n')\n                                readbuffer[strlen(readbuffer)-1]='\\0';\n                        nsp=c_sp(readbuffer);\n                        //printf(\"msp:%d %s\\n\",nsp,readbuffer);\n                        strcpy(&person[person_ptr].name[0],&readbuffer[nsp]);\n                        person[person_ptr].level=nsp;       \n                        if(person_ptr==0)\n                                person[person_ptr].parent=-1;  //root\n                        else\n                                for(j=person_ptr-1;j>=0;j--)\n                                        if(person[j].level==nsp-1)\n                                        {\n                                                person[person_ptr].parent=j;\n                                                //printf(\"%d 's parent is %d\",person_ptr,j);\n                                                break;\n                                        }\n                        person_ptr++;\n                }\n#ifdef DEBUG\n                print_tree();\n#endif\n                for(i=0;i<m;i++)\n                {\n                        fgets(readbuffer,71,stdin);\n                        subject=strtok(readbuffer,\" \");\n                        (void)strtok(NULL,\" \");         // is \n                        (void)strtok(NULL,\" \");         // kansi\n                        relation=strtok(NULL,\" \");\n                        (void)strtok(NULL,\" \");         // of\n                        object=strtok(NULL,\".\");\n#ifdef DEBUG\n                        printf(\"%s %s %s\\n\",subject,relation,object);\n#endif\n                        printf(\"%s\\n\",check_relation(subject,relation,object)?\"True\":\"False\");\n                }\n        }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n  char s1[70],s2[70],s3[70],na[1000][70],s[71];\n  int st[1010],n,m,i,j,r,p[1010]={-1};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    scanf(\"\\n\");\n    st[0]=-1;\n    for(j=0;j<n;j++){\n      fgets(s,71,stdin);\n      for(i=0;s[i]==' ';i++);\n      st[i+1]=j;\n      p[j]=st[i];//printf(\"%s\\n\",s+i);\n      for(r=0;s[i]-10;i++)na[j][r++]=s[i];\n      na[j][r]=0;\n    }//printf(\"a\\n\");\n    //for(i=0;i<n;i++)printf(\"%d\\n\",p[i]);\n    while(m--){\n      scanf(\"%s %*s %*s %s %*s %s\",s1,s2,s3);//printf(\"%s\\n\",s3);\n      s3[strlen(s3)-1]=0;\n      for(i=0;strcmp(na[i],s1);i++);//printf(\"%d\\n\",i);\n      for(j=0;strcmp(na[j],s3);j++);//printf(\"%d\\n\",j);\n      if(s2[0]=='c'){\n\tif(j==p[i])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='a'){\n\tfor(;j+1;j=p[j]){\n\t  if(i==j)break;\n\t}\n\tif(i==j)printf(\"True\\n\");\n\telse    printf(\"False\\n\");\n      }\n      if(s2[0]=='s'){\n\tif(p[i]==p[j])printf(\"True\\n\");\n\telse          printf(\"False\\n\");\n      }\n      if(s2[0]=='p'){\n\tif(i==p[j])printf(\"True\\n\");\n\telse       printf(\"False\\n\");\n      }\n      if(s2[0]=='d'){\n\tfor(;i+1;i=p[i]){\n\t  if(i==j)break;\n\t}\n\tif(i==j)printf(\"True\\n\");\n\telse    printf(\"False\\n\");\n      }\n    }\n    printf(\"\\n\");  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1217\nTitle Family tree\nRE\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n,m;\nstruct p_str\n{\n        char name[21];\n        int  parent;\n        int  level;       //no of indent\n} person[1000];\nint person_ptr;\nchar query[71];\nchar readbuffer[71];\n//\nint c_sp(char *s)\n{\n        int i;\n        int cnt;\n\n        for(i=0;s[i];i++)\n                if(s[i]!=' ')\n                        break;\n        return(i);\n}\nvoid print_tree()\n{\n        int i;\n        printf(\"----------------------\\n\");\n        for(i=0;i<person_ptr;i++)\n        {\n                printf(\"%d %s\",person[i].level,person[i].name);\n                if(i)\n                        printf(\"(%s)\",person[person[i].parent].name);\n                printf(\"\\n\");\n        }\n}\nint name2sno(char * name)\n{\n        int i;\n        for(i=0;i<person_ptr;i++)\n                if(0==strcmp(name,person[i].name))\n                        return(i);\n        return(-1);\n}\nint check_relation(char * sub,char * rel,char *obj)\n{\n        int sn,on;\n        sn=name2sno(sub);\n        on=name2sno(obj);\n        if(0==strcmp(rel,\"parent\"))\n                return(person[on].parent == sn);\n        if(0==strcmp(rel,\"child\"))\n        {\n                return(person[sn].parent == on);\n        }\n        if(0==strcmp(rel,\"sibling\"))\n        {\n                return(person[sn].parent == person[on].parent);\n        }\n        if(0==strcmp(rel,\"ancestor\"))\n        {\n        LOOP:\n                if(person[on].parent < 0)\n                        return(0);\n                if(sn== person[on].parent)\n                        return(-1);\n                on=person[on].parent;\n                goto LOOP;\n        }\n        if(0==strcmp(rel,\"descendant\"))\n        {\n        LOOP2:\n                if(person[sn].parent < 0)\n                        return(0);\n                if(on== person[sn].parent)\n                        return(-1);\n                sn=person[sn].parent;\n                goto LOOP2;\n        }\n\n        return(0);\n}\nmain()\n{\n        int i,j;\n        int nsp;  // no of leading space\n        char *subject;\n        char *object;\n        char *relation;\n        while(EOF!=scanf(\"%d %d\\n\",&n,&m) && (n||m))\n        {       \n                //printf(\"NM %d %d \\n\",n,m);        \n                person_ptr=0;\n                for(i=0;i<n;i++)\n                {\n                        fgets(readbuffer,71,stdin);\n                        readbuffer[strlen(readbuffer)-1]='\\0';\n                        nsp=c_sp(readbuffer);\n                        //printf(\"msp:%d %s\\n\",nsp,readbuffer);\n                        strcpy(&person[person_ptr].name[0],&readbuffer[nsp]);\n                        person[person_ptr].level=nsp;       \n                        if(person_ptr==0)\n                                person[person_ptr].parent=-1;  //root\n                        else\n                                for(j=person_ptr-1;j>=0;j--)\n                                        if(person[j].level==nsp-1)\n                                        {\n                                                person[person_ptr].parent=j;\n                                                //printf(\"%d 's parent is %d\",person_ptr,j);\n                                                break;\n                                        }\n                        person_ptr++;\n                }\n#ifdef DEBUG\n                print_tree();\n#endif\n                for(i=0;i<m;i++)\n                {\n                        fgets(readbuffer,71,stdin);\n                        subject=strtok(readbuffer,\" \");\n                        (void)strtok(NULL,\" \");         // is \n                        (void)strtok(NULL,\" \");         // kansi\n                        relation=strtok(NULL,\" \");\n                        (void)strtok(NULL,\" \");         // of\n                        object=strtok(NULL,\".\");\n#ifdef DEBUG\n                        printf(\"%s %s %s\\n\",subject,relation,object);\n#endif\n                        printf(\"%s\\n\",check_relation(subject,relation,object)?\"True\":\"False\");\n                }\n        }\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1217\nTitle Family tree\nRE\n*/\n#include <stdio.h>\n// Select Below\n//#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\nint n,m;\nstruct p_str\n{\n        char name[21];\n        int  parent;\n        int  level;       //no of indent\n} person[1001];\nint person_ptr;\nchar readbuffer[72];\n//\nint c_sp(char *s)\n{\n        int i;\n        int cnt;\n\n        for(i=0;s[i];i++)\n                if(s[i]!=' ')\n                        break;\n        return(i);\n}\nvoid print_tree()\n{\n        int i;\n        printf(\"----------------------\\n\");\n        for(i=0;i<person_ptr;i++)\n        {\n                printf(\"%d %s\",person[i].level,person[i].name);\n                if(i)\n                        printf(\"(%s)\",person[person[i].parent].name);\n                printf(\"\\n\");\n        }\n}\nint name2sno(char * name)\n{\n        int i;\n        for(i=0;i<person_ptr;i++)\n                if(0==strcmp(name,person[i].name))\n                        return(i);\n        return(-1);\n}\nint check_relation(char * sub,char * rel,char *obj)\n{\n        int sn,on;\n        sn=name2sno(sub);\n        on=name2sno(obj);\n        if(0==strcmp(rel,\"parent\"))\n                return(person[on].parent == sn);\n        if(0==strcmp(rel,\"child\"))\n        {\n                return(person[sn].parent == on);\n        }\n        if(0==strcmp(rel,\"sibling\"))\n        {\n                return(person[sn].parent == person[on].parent);\n        }\n        if(0==strcmp(rel,\"ancestor\"))\n        {\n        LOOP:\n                if(person[on].parent < 0)\n                        return(0);\n                if(sn== person[on].parent)\n                        return(-1);\n                on=person[on].parent;\n                goto LOOP;\n        }\n        if(0==strcmp(rel,\"descendant\"))\n        {\n        LOOP2:\n                if(person[sn].parent < 0)\n                        return(0);\n                if(on== person[sn].parent)\n                        return(-1);\n                sn=person[sn].parent;\n                goto LOOP2;\n        }\n\n        return(0);\n}\nmain()\n{\n        int i,j;\n        int nsp;  // no of leading space\n        char *subject;\n        char *object;\n        char *relation;\n\n        while(EOF!=scanf(\"%d %d\\n\",&n,&m) && (n||m))\n        {       \n                //printf(\"NM %d %d \\n\",n,m);        \n                person_ptr=0;\n                for(i=0;i<n;i++)\n                {\n                        fgets(readbuffer,sizeof(readbuffer),stdin);\n                        if(readbuffer[strlen(readbuffer)-1]=='\\n')\n                                readbuffer[strlen(readbuffer)-1]='\\0';\n                        nsp=c_sp(readbuffer);\n                        //printf(\"msp:%d %s\\n\",nsp,readbuffer);\n                        strcpy(&person[person_ptr].name[0],&readbuffer[nsp]);\n                        person[person_ptr].level=nsp;       \n                        if(person_ptr==0)\n                                person[person_ptr].parent=-1;  //root\n                        else\n                                for(j=person_ptr-1;j>=0;j--)\n                                        if(person[j].level==nsp-1)\n                                        {\n                                                person[person_ptr].parent=j;\n                                                break;\n                                        }\n                        person_ptr++;\n                }\n#ifdef DEBUG\n                print_tree();\n#endif\n                for(i=0;i<m;i++)\n                {\n                        fgets(readbuffer,sizeof(readbuffer),stdin);\n                        subject=strtok(readbuffer,\" \");\n                        (void)strtok(NULL,\" \");         // is \n                        (void)strtok(NULL,\" \");         // kansi\n                        relation=strtok(NULL,\" \");\n                        (void)strtok(NULL,\" \");         // of\n                        object=strtok(NULL,\".\");\n#ifdef DEBUG\n                        printf(\"%s %s %s\\n\",subject,relation,object);\n#endif\n                        printf(\"%s\\n\",check_relation(subject,relation,object)?\"True\":\"False\");\n                }\n                printf(\"\\n\");\n        }\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1217\n  Title:Family Tree\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\nint n,m;\nchar person[1000][21];\nint level_table[1000];\nint level2space[1000];\nint parent[1000];\nint name2int(char name[])\n{\n  int i;\n\n  for(i=0;i<n;i++)\n    if(0==strcmp(name,&person[i][0]))\n      return(i);\n  return(-1);\n}\nint is_child(int n1,int n2)\n{\n  if(parent[n1]==n2)\n    return(-1);\n  else\n    return(0);\n}\nint is_parent(int n1,int n2)\n{\n  return(is_child(n2,n1));\n}\nint is_descendant(int n1,int n2)\n{\n  int i,step;\n  step=level_table[n1];\n  for(i=0;i<step;i++)\n    {\n      if(parent[n1]==n2)\n\treturn(-1);\n      n1=parent[n1];\n    }\n  return(0);\n}\nint is_ancestor(int n1,int n2)\n{\n  return(is_descendant( n2, n1));\n}\nint is_sibring(int n1,int n2)\n{\n  if(parent[n1]==parent[n2])\n    return(-1);\n  else\n    return(0);\n}\nint hanbetu(char person1[],char person2[],char relation[])\n{\n  int n1,n2;\n  n1=name2int(person1);\n  n2=name2int(person2);\n  if(0==strcmp(relation,\"child\"))\n     return(is_child(n1,n2));\n  if(0==strcmp(relation,\"parent\"))\n     return(is_parent(n1,n2));\n  if(0==strcmp(relation,\"ancestor\"))\n     return(is_ancestor(n1,n2));\n  if(0==strcmp(relation,\"sibling\"))\n     return(is_sibring(n1,n2));\n  if(0==strcmp(relation,\"descendant\"))\n     return(is_descendant(n1,n2));\n}\nvoid bunkai(char buf[],char person1[],char person2[],char relation[])\n{\n  char *p;\n  p=strtok(buf,\" \");\n  strcpy(person1,p);\n  p=strtok(NULL,\" \");  // is\n  p=strtok(NULL,\" \");  // kansi\n  p=strtok(NULL,\" \");\n  strcpy(relation,p);\n  p=strtok(NULL,\" \");   // of\n  p=strtok(NULL,\".\");\n  strcpy(person2,p);\n}\nint count_space(char * ptr)\n{\n  int ret=0;\n  while(*ptr==' ')\n    {\n      ptr++;\n      ret++;\n    }\n  return(ret);\n}\nint maxlevel;\nvoid dump()\n{\n  int i;\n  for(i=0;i<n;i++)\n    printf(\"%d)[%d]:%s[%d]\\n\",i,level_table[i],&person[i][0],parent[i]);\n  for(i=0;i<maxlevel;i++)\n    printf(\"[lv=%d]sp=%d\\n\",i,level2space[i]);\n}\nmain()\n{\n  int i,j,first,level,spaces,oldspaces,oldlevel,mylevel,ret;\n  char buf[70],person1[12],person2[12],relation[11];\n  first=1;\n  while(scanf(\"%d %d \",&n,&m) && (n||m))\n    {\n      spaces=level=oldspaces=maxlevel=0;\n      parent[0]=-1;\n      for(i=0;i<n;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  buf[strlen(buf)-1]='\\0';\n\t  spaces=count_space(buf);\n\t  if(spaces>oldspaces)\n\t    {\n\t      level++;\n\t      maxlevel=max(maxlevel,level);\n\t    }\n\t  else if(spaces<oldspaces)\n\t    for(j=0;j<maxlevel;j++)\n\t      if(level2space[j]<spaces && spaces <=level2space[j+1])\n\t\t{\n\t\tlevel=j+1;\n\t\t//printf(\"lvup=%d\\n\",level);\n\t\t}\n\t  level2space[level]=spaces;\t\n\t  level_table[i]=level;\n\t  strcpy(&person[i][0],&buf[spaces]);\n\t  mylevel=level_table[i];\n\t  if(i>0 || mylevel==0)\n\t    {\n\t      for(j=i-1;j>=0;j--)\n\t\tif(level_table[j]==mylevel-1)\n\t\t  {\n\t\t    parent[i]=j;\n\t\t    break;\n\t\t  }\n\t    }\n\t  oldspaces=spaces;\n\t}\n#ifdef DEBUG      \n      dump();\n#else\n    \n      for(i=0;i<m;i++)\n\t{\n\t  fgets(buf,70,stdin);\n\t  bunkai(buf,person1,person2,relation);\n\t  ret=hanbetu(person1,person2,relation);\n\t  printf(\"%s\\n\",(ret?\"True\":\"False\"));\n\t}\n      printf(\"\\n\");\n#endif\n    }\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new AOJ1217(), \"RUN!\", STACK_SIZE).start();\n\t}\n\t\n\tclass AOJ1217 implements Runnable{\n\t\tAOJ1217(){}\n\t\t\n\t\tint N,M;\n\t\t\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tN=sc.nextInt();\n\t\t\t\tM=sc.nextInt();\n\t\t\t\tif((N|M)==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tPerson[] a;\n\t\tHashMap<String,Integer> dic;\n\t\t\n\t\tvoid solve(){\n\t\t\ta=new Person[N];\n\t\t\tdic=new HashMap<String, Integer>();\n\t\t\tint p=-1;\n\t\t\tsc.nextLine();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tStringBuilder line=new StringBuilder(sc.nextLine());\n\t\t\t\tint j=0;\n\t\t\t\twhile(line.charAt(j)==' ')\t++j;\n\t\t\t\tfor(int k=i-1; k>=0; k--){\n\t\t\t\t\tif(a[k].n==j-1){\n\t\t\t\t\t\tp=k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j>0){\n\t\t\t\t\tif(p<0)\tthrow new RuntimeException(\"parent not found\");\n\t\t\t\t\ta[p].child.add(i);\n\t\t\t\t}\n\t\t\t\tString name=line.toString().replaceAll(\" \", \"\");\n\t\t\t\ta[i]=new Person(name, p,j);\n\t\t\t\tdic.put(name, i);\n\t\t\t\tp=-1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString line=sc.nextLine().replaceAll(\"\\\\.\", \"\");\n\t\t\t\tString[] q=line.split(\" \");\n\t\t\t\tboolean ans=false;\n\t\t\t\tif(q[3].equals(\"child\")){\n\t\t\t\t\tint now=dic.get(q[5]);\n\t\t\t\t\tfor(int j:a[now].child){\n\t\t\t\t\t\tif(a[j].name.equals(q[0])){\n\t\t\t\t\t\t\tans=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(q[3].equals(\"parent\")){\n\t\t\t\t\tint tmp=a[dic.get(q[5])].parent;\n\t\t\t\t\tans=(tmp>=0 && a[tmp].name.equals(q[0]));\n\t\t\t\t}else if(q[3].equals(\"sibling\")){\n\t\t\t\t\tint now=a[dic.get(q[5])].parent;\n\t\t\t\t\tif(now>=0){\n\t\t\t\t\t\tfor(int j:a[now].child){\n\t\t\t\t\t\t\tif(a[j].name.equals(q[0])){\n\t\t\t\t\t\t\t\tans=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(q[3].equals(\"descendant\")){\n\t\t\t\t\tans=findChild(dic.get(q[5]),q[0]);\n\t\t\t\t}else if(q[3].equals(\"ancestor\")){\n\t\t\t\t\tint now=dic.get(q[5]);\n\t\t\t\t\twhile(a[now].parent>=0){\n\t\t\t\t\t\tnow=a[now].parent;\n\t\t\t\t\t\tif(a[now].name.equals(q[0])){\n\t\t\t\t\t\t\tans=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans?\"True\":\"False\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean findChild(int now,String target){\n\t\t\tif(a[now].name.equals(target))\treturn true;\n\t\t\tfor(int i:a[now].child){\n\t\t\t\tif(findChild(i,target))\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tclass Person{\n\t\t\tint parent,n;\n\t\t\tArrayList<Integer> child;\n\t\t\tString name;\n\t\t\tPerson(String name,int parent,int n){\n\t\t\t\tthis.name=name;\n\t\t\t\tthis.parent=parent;\n\t\t\t\tthis.n=n;\n\t\t\t\tthis.child=new ArrayList<Integer>();\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn name+\" P:\"+parent+\" C:\"+child+\" N:\"+n;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m;\n\tHashMap<String, String> parent;\n\tHashMap<String, LinkedList<String>> children;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tm=sc.nextInt();\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tparent=new HashMap<String, String>();\n\t\t\tchildren=new HashMap<String, LinkedList<String>>();\n\t\t\tsc.nextLine();\n\t\t\tString p=\"\", r=\"\"; // ツ親ツ，1ツづつ前\n\t\t\tchildren.put(p, new LinkedList<String>());\n\t\t\tint x=-1;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString s=sc.nextLine();\n\t\t\t\tint y=s.length()-s.replaceAll(\" \", \"\").length();\n\t\t\t\ts=s.replaceAll(\" \", \"\");\n\t\t\t\tdebug(s, r, p);\n\t\t\t\tif(y>x){\n\t\t\t\t\t// 1ツづつ可慊づ個階ツ層\n\t\t\t\t\tdebug(\"->\");\n\t\t\t\t\tp=r;\n\t\t\t\t\t// parent.put(s, p);\n\t\t\t\t\t// children.get(p).add(s);\n\t\t\t\t\t// children.put(s, new LinkedList<String>());\n\t\t\t\t}else if(y<x){\n\t\t\t\t\tdebug(\"<-\");\n\t\t\t\t\tfor(int i=y; i<x; i++){\n\t\t\t\t\t\tp=parent.get(p);\n\t\t\t\t\t}\n\t\t\t\t\t// parent.put(s, p);\n\t\t\t\t\t// children.get(p).add(s);\n\t\t\t\t\t// children.put(s, new LinkedList<String>());\n\t\t\t\t}else{\n\t\t\t\t\tdebug(\"-\");\n\t\t\t\t\t// parent.put(s, p);\n\t\t\t\t\t// children.get(p).add(s);\n\t\t\t\t\t// children.put(s, new LinkedList<String>());\n\t\t\t\t}\n\t\t\t\tparent.put(s, p);\n\t\t\t\tchildren.get(p).add(s);\n\t\t\t\tchildren.put(s, new LinkedList<String>());\n\t\t\t\tx=y;\n\t\t\t\tr=s;\n\t\t\t}\n\t\t\tdebug();\n\t\t\tdfs(\"\", \"\");\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tString s=sc.next();\n\t\t\t\tsc.next();\n\t\t\t\tsc.next();\n\t\t\t\tchar c=sc.next().charAt(0);\n\t\t\t\tsc.next();\n\t\t\t\tString t=sc.next();\n\t\t\t\tt=t.substring(0, t.length()-1);\n\t\t\t\tboolean f=false;\n\t\t\t\tdebug(s, t);\n\t\t\t\tswitch(c){\n\t\t\t\tcase 'c':\n\t\t\t\t\tf=parent.containsKey(s)&&parent.get(s).equals(t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tf=parent.containsKey(t)&&parent.get(t).equals(s);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tf=parent.containsKey(s)&&parent.containsKey(t)\n\t\t\t\t\t\t\t&&parent.get(s).equals(parent.get(t));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tfor(s=parent.get(s); s!=null; s=parent.get(s)){\n\t\t\t\t\t\tf|=s.equals(t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'a':\n\t\t\t\t\tfor(t=parent.get(t); t!=null; t=parent.get(t)){\n\t\t\t\t\t\tf|=t.equals(s);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintln(f?\"True\":\"False\");\n\t\t\t}\n\t\t\tprintln(\"\");\n\t\t\t// child:ツ子\n\t\t\t// parent:ツ親\n\t\t\t// sibling:ツ兄ツ津ュ\n\t\t\t// descendant:ツ子ツ堕キ\n\t\t\t// ancestor:ツ静ヲツ祖\n\t\t}\n\t}\n\n\tvoid dfs(String s, String tab){\n\t\tfor(String t : children.get(s)){\n\t\t\tdebug(tab, t, parent.get(t));\n\t\t\tdfs(t, tab+\"\\t\");\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\t// System.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint n;\n\tint [] data;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m) == 0) break;\n\t\t\tsc.nextLine();\n\t\t\tdata = new int[n];\n\t\t\tHashMap<String, Integer> nametoind = new HashMap<String, Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString input = sc.nextLine();\n\t\t\t\tString [] inputarray = input.split(\" \");\n\t\t\t\tdata[i] = inputarray.length -1;\n\t\t\t\tnametoind.put(inputarray[inputarray.length - 1], nametoind.size());\n\t\t\t}\n\t\t\tfor(int i =0; i < m; i++){\n\t\t\t\tString input = sc.nextLine();\n\t\t\t\tString [] inputarray = input.split(\"[ .]\");\n\t\t\t\tint x = nametoind.get(inputarray[0]);\n\t\t\t\tString op = inputarray[3];\n\t\t\t\tint y = nametoind.get(inputarray[5]);\n\t\t\t\tboolean ans = true;\n\t\t\t\tswitch(op.charAt(0)){\n\t\t\t\tcase 'c':\n\t\t\t\t\tans = isChild(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\tans = isChild(y,x);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tans = isSib(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tans = isDes(x,y);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'a':\n\t\t\t\t\tans = isDes(y,x);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans ? \"True\" : \"False\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate boolean isDes(int x, int y) {\n\t\tfor(int i = y + 1; i < n; i++){\n\t\t\tif(data[i] <= data[y]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(i == x){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isSib(int x, int y) {\n\t\tif(data[x] != data[y]){\n\t\t\treturn false;\n\t\t}\n\t\tint min = Math.min(x,y);\n\t\tint max = Math.max(x,y);\n\t\tfor(int i = min + 1; i < n; i++){\n\t\t\tif(data[i] < data[x]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(i == max){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isChild(int child, int parent) {\n\t\tif(data[parent] + 1 != data[child]){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = parent + 1; i < n; i++){\n\t\t\tif(data[i] <= data[parent]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(i == child){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Family Tree\npublic class Main{\n\n\tclass V{\n\t\tint id;\n\t\tString name;\n\t\tV parent;\n\t\tList<V> adj;\n\t\tpublic V(int id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t\tparent = null;\n\t\t\tadj = new ArrayList<V>();\n\t\t}\n\t\tvoid add(int depth, String name, int id){\n\t\t\tif(depth==0){\n\t\t\t\tV t = new V(id, name);\n\t\t\t\tt.parent = this;\n\t\t\t\tadj.add(t);\n\t\t\t\tv[id] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tadj.get(adj.size()-1).add(depth-1, name, id);\n\t\t\t}\n\t\t}\n\t\tboolean isChild(String s){\n\t\t\tfor(V t:adj)if(t.name.equals(s))return true;\n\t\t\treturn false;\n\t\t}\n\t\tboolean isParent(String s){\n\t\t\tif(parent==null)return false;\n\t\t\treturn parent.name.equals(s);\n\t\t}\n\t\tboolean isSibling(String s){\n\t\t\tif(parent==null)return false;\n\t\t\tfor(V t:parent.adj)if(t.name.equals(s))return true;\n\t\t\treturn false;\n\t\t}\n\t\tboolean isDesc(String s){\n\t\t\tfor(V t:adj){\n\t\t\t\tif(t.name.equals(s))return true;\n\t\t\t\tif(t.isDesc(s))return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tboolean isAnc(String s){\n\t\t\tif(parent==null)return false;\n\t\t\tif(parent.name.equals(s))return true;\n\t\t\treturn parent.isAnc(s);\n\t\t}\n\t}\n\t\n\tV[] v;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tboolean head = true;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tv = new V[n+1];\n\t\t\tv[0] = new V(0, \"\");\n\t\t\tsc.nextLine();\n\t\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tint depth = 0;\n\t\t\t\twhile(s.charAt(depth)==' ')depth++;\n\t\t\t\tString name = s.substring(depth, s.length());\n\t\t\t\tv[0].add(depth, name, i);\n\t\t\t\tref.put(name, i);\n\t\t\t}\n\t\t\tif(!head)System.out.println();\n\t\t\thead = false;\n\t\t\twhile(m--!=0){\n\t\t\t\tString[] s = sc.nextLine().split(\" \");\n\t\t\t\tString a = s[0];\n\t\t\t\tString cmd = s[3];\n\t\t\t\tString b = s[5].substring(0, s[5].length()-1);\n\t\t\t\tboolean f;\n\t\t\t\tif(\"child\".equals(cmd))f = v[ref.get(b)].isChild(a);\n\t\t\t\telse if(\"parent\".equals(cmd))f = v[ref.get(b)].isParent(a);\n\t\t\t\telse if(\"sibling\".equals(cmd))f = v[ref.get(b)].isSibling(a);\n\t\t\t\telse if(\"descendant\".equals(cmd))f = v[ref.get(b)].isDesc(a);\n\t\t\t\telse f = v[ref.get(b)].isAnc(a);\n\t\t\t\tSystem.out.println(f?\"True\":\"False\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean first = true;\n\t\twhile(true){\n\t\t\tString input[] = sc.nextLine().split(\" \");\n\t\t\t\n\t\t\tfinal int n = Integer.parseInt(input[0]);\n\t\t\tfinal int m = Integer.parseInt(input[1]);\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(!first){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tHashMap<String, Integer> dict = new HashMap<String, Integer>();\n\t\t\tint[] parent = new int[n];\n\t\t\tboolean[][] child = new boolean[n][n];\n\t\t\t\n\t\t\tint[] stack = new int[n];\n\t\t\tArrays.fill(parent, -1);\n\t\t\t\n\t\t\tint number_count = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tString name = line.replaceAll(\" \", \"\");\n\t\t\t\t\n\t\t\t\tif(!dict.containsKey(name)){\n\t\t\t\t\tdict.put(name, number_count);\n\t\t\t\t\tnumber_count++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int cur_number = dict.get(name);\n\t\t\t\t\n\t\t\t\tint high = 0;\n\t\t\t\twhile(line.charAt(high) == ' '){\n\t\t\t\t\thigh++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(high != 0){\n\t\t\t\t\tparent[cur_number] = stack[high - 1];\n\t\t\t\t\tchild[stack[high-1]][cur_number] = true;\n\t\t\t\t}\n\t\t\t\tstack[high] = cur_number;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//System.out.println(dict);\n\t\t\t\t//System.out.println(Arrays.toString(stack));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString[] inputs = sc.nextLine().split(\" \");\n\t\t\t\t\n\t\t\t\tfinal int arg1 = dict.get(inputs[0]);\n\t\t\t\tString ops = inputs[3];\n\t\t\t\tfinal int arg2 = dict.get(inputs[5].substring(0, inputs[5].length() - 1));\n\t\t\t\t\n\t\t\t\t//System.out.println(arg1 + \" \" + ops + \" \" + arg2);\n\t\t\t\t\n\t\t\t\tif(\"child\".equals(ops)){\n\t\t\t\t\tSystem.out.println(child[arg2][arg1] ? \"True\" : \"False\");\n\t\t\t\t}else if(\"parent\".equals(ops)){\n\t\t\t\t\tSystem.out.println(parent[arg2] == arg1 ? \"True\" : \"False\");\n\t\t\t\t}else if(\"sibling\".equals(ops)){\n\t\t\t\t\tfinal int p_num= parent[arg2];\n\t\t\t\t\t\n\t\t\t\t\tif(p_num >= 0){\n\t\t\t\t\t\tSystem.out.println(child[p_num][arg1] ? \"True\" : \"False\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(\"False\");\n\t\t\t\t\t}\n\t\t\t\t}else if(\"ancestor\".equals(ops)){\n\t\t\t\t\tint p_num = parent[arg2];\n\t\t\t\t\t\n\t\t\t\t\twhile(p_num >= 0 && p_num != arg1){\n\t\t\t\t\t\tp_num = parent[p_num];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tSystem.out.println(p_num >= 0 ? \"True\" : \"False\");\n\t\t\t\t}else if(\"descendant\".equals(ops)){\n\t\t\t\t\tint p_num = parent[arg1];\n\t\t\t\t\t\n\t\t\t\t\twhile(p_num >= 0 && p_num != arg2){\n\t\t\t\t\t\tp_num = parent[p_num];\n\t\t\t\t\t\t//System.out.println(p_num + \" \" + parent[p_num]);\n\t\t\t\t\t\t//sc.next();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tSystem.out.println(p_num >= 0 ? \"True\" : \"False\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(first){\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic double[] x, y, z;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tint M = sc.nextInt();\n\t\t\tHashMap<String, Node> map = new HashMap<String, Node>();\n\t\t\tNode cur = new Node(null);\n\t\t\tmap.put(sc.next(), cur);\n\t\t\tint depth = 0;\n\t\t\tsc.nextLine();\n\t\t\tfor (int i = 1; i < N; ++i) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tint d = 0;\n\t\t\t\twhile (line.charAt(d) == ' ') {\n\t\t\t\t\t++d;\n\t\t\t\t}\n\t\t\t\tString name = line.substring(d);\n\t\t\t\tfor (int j = 0; j <= depth - d; ++j) {\n\t\t\t\t\tcur = cur.parent;\n\t\t\t\t}\n\t\t\t\tNode node = new Node(cur);\n\t\t\t\tmap.put(name, node);\n\t\t\t\tcur = node;\n\t\t\t\tdepth = d;\n\t\t\t}\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tString X = sc.next();\n\t\t\t\tsc.next();\n\t\t\t\tsc.next();\n\t\t\t\tchar query = sc.next().charAt(0);\n\t\t\t\tsc.next();\n\t\t\t\tString Y = sc.next();\n\t\t\t\tY = Y.substring(0, Y.length() - 1);\n\t\t\t\tNode xn = map.get(X);\n\t\t\t\tNode yn = map.get(Y);\n\t\t\t\tboolean yes = false;\n\t\t\t\tif (query == 'c') {\n\t\t\t\t\tyes = xn.parent == yn;\n\t\t\t\t} else if (query == 'p') {\n\t\t\t\t\tyes = yn.parent == xn;\n\t\t\t\t} else if (query == 's') {\n\t\t\t\t\tyes = xn.parent == yn.parent;\n\t\t\t\t} else if (query == 'd') {\n\t\t\t\t\tNode node = xn;\n\t\t\t\t\twhile (node != null) {\n\t\t\t\t\t\tif (node == yn) {\n\t\t\t\t\t\t\tyes = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode = node.parent;\n\t\t\t\t\t}\n\t\t\t\t} else if (query == 'a') {\n\t\t\t\t\tNode node = yn;\n\t\t\t\t\twhile (node != null) {\n\t\t\t\t\t\tif (node == xn) {\n\t\t\t\t\t\t\tyes = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode = node.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(yes ? \"True\" : \"False\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic class Node {\n\t\tNode parent;\n\n\t\tNode(Node parent) {\n\t\t\tthis.parent = parent;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n   \n    public static void main(String[] args) {\n        new Main(); \n    }\n   \n    public Main() {\n        new aoj1217().doIt();\n    }\n    class aoj1217{\n    \tString str[] = new String[1001];\n    \tint array[] = new int[1001];\n    \tint parent[] = new int[1001];\n    \tvoid clear(){\n    \t\tfor(int i = 0;i < 1001;i++){\n    \t\t\tstr[i] = null;\n    \t\t\tarray[i] = 0;\n    \t\t\tparent[i] = 0;\n    \t\t}\n    \t}\n    \tvoid parents(int n){\n    \t\tfor(int i = n-1;i > 0;i--){\n    \t\t\tfor(int j = i;j >= 0;j--){\n    \t\t\t\tif(array[i] > array[j]){\n    \t\t\t\t\tparent[i] = j;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tparent[0] = -1;\n    \t}\n    \tvoid check(int n){\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tSystem.out.println(str[i]+\" \"+array[i]+\" \"+parent[i]);\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tclear();\n    \t\t\tint n = sc.nextInt();\n    \t\t\tint m = sc.nextInt();\n    \t\t\tif(n + m == 0)break;\n    \t\t\tString s = sc.nextLine();\n    \t\t\tfor(int i = 0;i < n;i++){\n    \t\t\t\tstr[i] = sc.nextLine();\n    \t\t\t\tfor(int j = 0;j < 1001;j++){\n    \t\t\t\t\tif(str[i].charAt(j) == ' ')array[i]++;\n    \t\t\t\t\telse break;\n    \t\t\t\t}\n    \t\t\t\tstr[i] = str[i].trim();\n//    \t\t\t\tSystem.out.println(str[i]+\" \"+array[i]);\n    \t\t\t}\n    \t\t\tparents(n);\n//    \t\t\tcheck(n);\n    \t\t\t\n    \t\t\tfor(int i = 0;i < m;i++){\n    \t\t\t\tString spl[] = sc.nextLine().split(\" \");\n    \t\t\t\tspl[5] = spl[5].replace(\".\", \"\");\n    \t\t\t\tif(spl[3].equals(\"child\")){\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[0])){\n//    \t\t\t\t\t\t\tSystem.out.println(str[j]+\" \"+str[parent[j]]+\" \"+spl[5]);\n    \t\t\t\t\t\t\tif(str[parent[j]].equals(spl[5])){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\t}else{\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"parent\")){\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5])){\n//    \t\t\t\t\t\t\tSystem.out.println(str[j]+\" \"+str[parent[j]]+\" \"+spl[5]);\n    \t\t\t\t\t\t\tif(str[parent[j]].equals(spl[0])){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\t}else{\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"sibling\")){\n    \t\t\t\t\tString ss = \"\";\n    \t\t\t\t\tString ss2 = \"\";\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5])){\n    \t\t\t\t\t\t\tss = str[parent[j]];\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif(str[j].equals(spl[0])){\n    \t\t\t\t\t\t\tss2 = str[parent[j]];\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\tif(ss.equals(ss2))System.out.println(\"True\");\n    \t\t\t\t\telse System.out.println(\"False\");\n    \t\t\t\t}else if(spl[3].equals(\"descendant\")){\n    \t\t\t\t\tString ss = \"\";\n    \t\t\t\t\tint num = 0;\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[0])){\n    \t\t\t\t\t\t\tss = str[j];\n    \t\t\t\t\t\t\tnum = j;\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\twhile(true){\n//    \t\t\t\t\t\tSystem.out.println(parent[num]);\n    \t\t\t\t\t\tif(parent[num] == -1){\n    \t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif(ss.equals(spl[5])){\n    \t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tnum = parent[num];\n    \t\t\t\t\t\tss = str[num];\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"ancestor\")){\n    \t\t\t\t\tString ss = \"\";\n    \t\t\t\t\tint num = 0;\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5])){\n    \t\t\t\t\t\t\tss = str[j];\n    \t\t\t\t\t\t\tnum = j;\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\twhile(true){\n    \t\t\t\t\t\tif(parent[num] == -1){\n    \t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif(ss.equals(spl[0])){\n    \t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tnum = parent[num];\n    \t\t\t\t\t\tss = str[num];\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tSystem.out.println();\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\n\t\t\tString[] s = new String[100];\n\t\t\tmap = new HashMap<String,String>();\n\n\t\t\tsc.nextLine();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tString name = sc.nextLine();\n\t\t\t\tint len = 0;\n\n\t\t\t\tfor(;name.charAt(len)==' ';len++);\n\t\t\t\tname = name.trim();\n\t\t\t\ts[len] = name;\n\t\t\t\tif(len != 0){\n\t\t\t\t\tmap.put(name,s[len-1]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(m-- > 0){\n\t\t\t\tString X = sc.next();\n\t\t\t\tsc.next(); sc.next();\n\t\t\t\tString op = sc.next();\n\t\t\t\tsc.next();\n\t\t\t\tString Y = sc.nextLine();\n\t\t\t\tY = Y.substring(1,Y.length()-1);\n\n\t\t\t\tboolean flg = false;\n\n\t\t\t\tif(op.equals(\"child\")) flg = map.get(X) != null && map.get(X).equals(Y);\n\t\t\t\telse if(op.equals(\"parent\")) flg = map.get(Y) != null && map.get(Y).equals(X);\n\t\t\t\telse if(op.equals(\"sibling\")) flg = map.get(X) != null && map.get(Y) != null && map.get(X).equals(map.get(Y));\n\t\t\t\telse if(op.equals(\"descendant\")) flg = solve(X,Y);\n\t\t\t\telse if(op.equals(\"ancestor\")) flg = solve(Y,X);\n\n\t\t\t\tSystem.out.println(flg ? \"True\" : \"False\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate static HashMap<String,String> map;\n\n\tprivate static boolean solve(String from,String to){\n\t\tif(from.equals(to)) return true;\n\t\tif(map.get(from) == null) return false;\n\n\t\treturn solve(map.get(from),to);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n   \n    public static void main(String[] args) {\n        new Main(); \n    }\n   \n    public Main() {\n        new aoj1217().doIt();\n    }\n    class aoj1217{\n    \tString str[] = new String[1001];\n    \tint array[] = new int[1001];\n    \tint parent[] = new int[1001];\n    \tvoid clear(){\n    \t\tfor(int i = 0;i < 1001;i++){\n    \t\t\tstr[i] = null;\n    \t\t\tarray[i] = 0;\n    \t\t\tparent[i] = 0;\n    \t\t}\n    \t}\n    \tvoid parents(int n){\n    \t\tfor(int i = n-1;i > 0;i--){\n    \t\t\tfor(int j = i;j >= 0;j--){\n    \t\t\t\tif(array[i] > array[j]){\n    \t\t\t\t\tparent[i] = j;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tparent[0] = -1;\n    \t}\n    \tvoid check(int n){\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tSystem.out.println(str[i]+\" \"+array[i]+\" \"+parent[i]);\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tclear();\n    \t\t\tint n = sc.nextInt();\n    \t\t\tint m = sc.nextInt();\n    \t\t\tif(n + m == 0)break;\n    \t\t\tString s = sc.nextLine();\n    \t\t\tfor(int i = 0;i < n;i++){\n    \t\t\t\tstr[i] = sc.nextLine();\n    \t\t\t\tfor(int j = 0;j < 1001;j++){\n    \t\t\t\t\tif(str[i].charAt(j) == ' ')array[i]++;\n    \t\t\t\t\telse break;\n    \t\t\t\t}\n    \t\t\t\tstr[i] = str[i].trim();\n//    \t\t\t\tSystem.out.println(str[i]+\" \"+array[i]);\n    \t\t\t}\n    \t\t\tparents(n);\n//    \t\t\tcheck(n);\n    \t\t\t\n    \t\t\tfor(int i = 0;i < m;i++){\n    \t\t\t\tString spl[] = sc.nextLine().split(\" \");\n    \t\t\t\tspl[5] = spl[5].replace(\".\", \"\");\n    \t\t\t\tif(spl[3].equals(\"child\")){\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[0])){\n//    \t\t\t\t\t\t\tSystem.out.println(str[j]+\" \"+str[parent[j]]+\" \"+spl[5]);\n    \t\t\t\t\t\t\tif(parent[j] == -1){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tif(str[parent[j]].equals(spl[5])){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\t}else{\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"parent\")){\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5])){\n//    \t\t\t\t\t\t\tSystem.out.println(str[j]+\" \"+str[parent[j]]+\" \"+spl[5]);\n    \t\t\t\t\t\t\tif(parent[j] == -1){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tif(str[parent[j]].equals(spl[0])){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\t}else{\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"sibling\")){\n    \t\t\t\t\tString ss = \"\";\n    \t\t\t\t\tString ss2 = \"\";\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5])){\n    \t\t\t\t\t\t\tif(parent[j] == -1){\n    \t\t\t\t\t\t\t\tss = \"hfaidjfoadjsiofjioasjfioa\";\n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tss = str[parent[j]];\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif(str[j].equals(spl[0])){\n    \t\t\t\t\t\t\tif(parent[j] == -1){\n    \t\t\t\t\t\t\t\tss2 = \"hfaidjfoadjsiofjioasjfioa\";\n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tss2 = str[parent[j]];\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\tif(ss.equals(ss2))System.out.println(\"True\");\n    \t\t\t\t\telse System.out.println(\"False\");\n    \t\t\t\t}else if(spl[3].equals(\"descendant\")){\n    \t\t\t\t\tString ss = \"\";\n    \t\t\t\t\tint num = 0;\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[0])){\n    \t\t\t\t\t\t\tss = str[j];\n    \t\t\t\t\t\t\tnum = j;\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\twhile(true){\n//    \t\t\t\t\t\tSystem.out.println(parent[num]);\n    \t\t\t\t\t\tif(parent[num] == -1){\n    \t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif(ss.equals(spl[5])){\n    \t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tnum = parent[num];\n    \t\t\t\t\t\tss = str[num];\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"ancestor\")){\n    \t\t\t\t\tString ss = \"\";\n    \t\t\t\t\tint num = 0;\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5])){\n    \t\t\t\t\t\t\tss = str[j];\n    \t\t\t\t\t\t\tnum = j;\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\twhile(true){\n    \t\t\t\t\t\tif(parent[num] == -1){\n    \t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tif(ss.equals(spl[0])){\n    \t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tnum = parent[num];\n    \t\t\t\t\t\tss = str[num];\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tSystem.out.println();\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n   \n    public static void main(String[] args) {\n        new Main(); \n    }\n   \n    public Main() {\n        new aoj1217().doIt();\n    }\n    class aoj1217{\n    \tString str[] = new String[1001];\n    \tint array[] = new int[1001];\n    \tint parent[] = new int[1001];\n    \tvoid clear(){\n    \t\tfor(int i = 0;i < 1001;i++){\n    \t\t\tstr[i] = null;\n    \t\t\tarray[i] = 0;\n    \t\t\tparent[i] = 0;\n    \t\t}\n    \t}\n    \tvoid parents(int n){\n    \t\tfor(int i = n-1;i > 0;i--){\n    \t\t\tfor(int j = i;j >= 0;j--){\n    \t\t\t\tif(array[i] > array[j]){\n    \t\t\t\t\tparent[i] = j;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tparent[0] = -1;\n    \t}\n    \tvoid check(int n){\n    \t\tfor(int i = 0;i < n;i++){\n    \t\t\tSystem.out.println(str[i]+\" \"+array[i]+\" \"+parent[i]);\n    \t\t}\n    \t}\n    \tvoid doIt(){\n    \t\twhile(true){\n    \t\t\tclear();\n    \t\t\tint n = sc.nextInt();\n    \t\t\tint m = sc.nextInt();\n    \t\t\tif(n + m == 0)break;\n    \t\t\tString s = sc.nextLine();\n    \t\t\tfor(int i = 0;i < n;i++){\n    \t\t\t\tstr[i] = sc.nextLine();\n    \t\t\t\tfor(int j = 0;j < 1001;j++){\n    \t\t\t\t\tif(str[i].charAt(j) == ' ')array[i]++;\n    \t\t\t\t\telse break;\n    \t\t\t\t}\n    \t\t\t\tstr[i] = str[i].trim();\n//    \t\t\t\tSystem.out.println(str[i]+\" \"+array[i]);\n    \t\t\t}\n    \t\t\tparents(n);\n//    \t\t\tcheck(n);\n    \t\t\t\n    \t\t\tfor(int i = 0;i < m;i++){\n    \t\t\t\tString spl[] = sc.nextLine().split(\" \");\n    \t\t\t\tspl[5] = spl[5].replace(\".\", \"\");\n    \t\t\t\tif(spl[3].equals(\"child\")){\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[0])){\n//    \t\t\t\t\t\t\tSystem.out.println(str[j]+\" \"+str[parent[j]]+\" \"+spl[5]);\n    \t\t\t\t\t\t\tif(parent[j] == -1){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tif(str[parent[j]].equals(spl[5])){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\t}else{\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"parent\")){\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5])){\n//    \t\t\t\t\t\t\tSystem.out.println(str[j]+\" \"+str[parent[j]]+\" \"+spl[5]);\n    \t\t\t\t\t\t\tif(parent[j] == -1){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tif(str[parent[j]].equals(spl[0])){\n    \t\t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\t}else{\n    \t\t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"sibling\")){\n    \t\t\t\t\tint num = 10000;\n    \t\t\t\t\tint num2 = 10001;\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5]))num = parent[j];\n    \t\t\t\t\t\tif(str[j].equals(spl[0]))num2 = parent[j];\n    \t\t\t\t\t}\n//    \t\t\t\t\tSystem.out.println(num+\" \"+num2);\n    \t\t\t\t\tif(num == num2)System.out.println(\"True\");\n    \t\t\t\t\telse System.out.println(\"False\");\n    \t\t\t\t}else if(spl[3].equals(\"descendant\")){\n    \t\t\t\t\tString ss = \"\";\n    \t\t\t\t\tint num = 0;\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[0])){\n    \t\t\t\t\t\t\tss = str[j];\n    \t\t\t\t\t\t\tnum = j;\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\twhile(true){\n//    \t\t\t\t\t\tSystem.out.println(ss+\" \"+num);\n    \t\t\t\t\t\tif(num == -1 || spl[0].equals(spl[5])){\n    \t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tss = str[num];\n    \t\t\t\t\t\tnum = parent[num];\n    \t\t\t\t\t\tif(ss.equals(spl[5])){\n    \t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}else if(spl[3].equals(\"ancestor\")){\n    \t\t\t\t\tString ss = \"\";\n    \t\t\t\t\tint num = 0;\n    \t\t\t\t\tfor(int j = 0;j < n;j++){\n    \t\t\t\t\t\tif(str[j].equals(spl[5])){\n    \t\t\t\t\t\t\tss = str[j];\n    \t\t\t\t\t\t\tnum = j;\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t\twhile(true){\n//    \t\t\t\t\t\tSystem.out.println(ss+\" \"+num);\n    \t\t\t\t\t\tif(num == -1 || spl[0].equals(spl[5])){\n    \t\t\t\t\t\t\tSystem.out.println(\"False\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tss = str[num];\n    \t\t\t\t\t\tnum = parent[num];\n    \t\t\t\t\t\tif(ss.equals(spl[0])){\n    \t\t\t\t\t\t\tSystem.out.println(\"True\");\n    \t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\tSystem.out.println();\n    \t\t}\n    \t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean first = true;\n\t\twhile(true){\n\t\t\tString input[] = sc.nextLine().split(\" \");\n\t\t\t\n\t\t\tfinal int n = Integer.parseInt(input[0]);\n\t\t\tfinal int m = Integer.parseInt(input[1]);\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(!first){\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tHashMap<String, Integer> dict = new HashMap<String, Integer>();\n\t\t\tint[] parent = new int[n];\n\t\t\tboolean[][] child = new boolean[n][n];\n\t\t\t\n\t\t\tint[] stack = new int[n];\n\t\t\tArrays.fill(parent, -1);\n\t\t\t\n\t\t\tint number_count = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tString name = line.replaceAll(\" \", \"\");\n\t\t\t\t\n\t\t\t\tif(!dict.containsKey(name)){\n\t\t\t\t\tdict.put(name, number_count);\n\t\t\t\t\tnumber_count++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int cur_number = dict.get(name);\n\t\t\t\t\n\t\t\t\tint high = 0;\n\t\t\t\twhile(line.charAt(high) == ' '){\n\t\t\t\t\thigh++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(high != 0){\n\t\t\t\t\tparent[cur_number] = stack[high - 1];\n\t\t\t\t\tchild[stack[high-1]][cur_number] = true;\n\t\t\t\t}\n\t\t\t\tstack[high] = cur_number;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//System.out.println(dict);\n\t\t\t\t//System.out.println(Arrays.toString(stack));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString[] inputs = sc.nextLine().split(\" \");\n\t\t\t\t\n\t\t\t\tfinal int arg1 = dict.get(inputs[0]);\n\t\t\t\tString ops = inputs[3];\n\t\t\t\tfinal int arg2 = dict.get(inputs[5].substring(0, inputs[5].length() - 1));\n\t\t\t\t\n\t\t\t\t//System.out.println(arg1 + \" \" + ops + \" \" + arg2);\n\t\t\t\t\n\t\t\t\tif(\"child\".equals(ops)){\n\t\t\t\t\tSystem.out.println(child[arg2][arg1] ? \"True\" : \"False\");\n\t\t\t\t}else if(\"parent\".equals(ops)){\n\t\t\t\t\tSystem.out.println(parent[arg2] == arg1 ? \"True\" : \"False\");\n\t\t\t\t}else if(\"sibling\".equals(ops)){\n\t\t\t\t\tfinal int p_num= parent[arg2];\n\t\t\t\t\t\n\t\t\t\t\tif(p_num >= 0){\n\t\t\t\t\t\tSystem.out.println(child[p_num][arg1] ? \"True\" : \"False\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(\"False\");\n\t\t\t\t\t}\n\t\t\t\t}else if(\"ancestor\".equals(ops)){\n\t\t\t\t\tint p_num = parent[arg2];\n\t\t\t\t\t\n\t\t\t\t\twhile(p_num >= 0 && p_num != arg1){\n\t\t\t\t\t\tp_num = parent[p_num];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tSystem.out.println(p_num >= 0 ? \"True\" : \"False\");\n\t\t\t\t}else if(\"descendant\".equals(ops)){\n\t\t\t\t\tint p_num = parent[arg1];\n\t\t\t\t\t\n\t\t\t\t\twhile(p_num >= 0 && p_num != arg2){\n\t\t\t\t\t\tp_num = parent[p_num];\n\t\t\t\t\t\t//System.out.println(p_num + \" \" + parent[p_num]);\n\t\t\t\t\t\t//sc.next();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tSystem.out.println(p_num >= 0 ? \"True\" : \"False\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(first){\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays; \nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean first = true;\n\t\twhile(true){\n\t\t\tString input[] = sc.nextLine().split(\" \");\n\t\t\t\n\t\t\tfinal int n = Integer.parseInt(input[0]);\n\t\t\tfinal int m = Integer.parseInt(input[1]);\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tHashMap<String, Integer> dict = new HashMap<String, Integer>();\n\t\t\tint[] parent = new int[n];\n\t\t\tboolean[][] child = new boolean[n][n];\n\t\t\t\n\t\t\tint[] stack = new int[n];\n\t\t\tArrays.fill(parent, -1);\n\t\t\t\n\t\t\tint number_count = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tString name = line.replaceAll(\" \", \"\");\n\t\t\t\t\n\t\t\t\tif(!dict.containsKey(name)){\n\t\t\t\t\tdict.put(name, number_count);\n\t\t\t\t\tnumber_count++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int cur_number = dict.get(name);\n\t\t\t\t\n\t\t\t\tint high = 0;\n\t\t\t\twhile(line.charAt(high) == ' '){\n\t\t\t\t\thigh++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(high != 0){\n\t\t\t\t\tparent[cur_number] = stack[high - 1];\n\t\t\t\t\tchild[stack[high-1]][cur_number] = true;\n\t\t\t\t}\n\t\t\t\tstack[high] = cur_number;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//System.out.println(dict);\n\t\t\t\t//System.out.println(Arrays.toString(stack));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString[] inputs = sc.nextLine().split(\" \");\n\t\t\t\t\n\t\t\t\tfinal int arg1 = dict.get(inputs[0]);\n\t\t\t\tString ops = inputs[3];\n\t\t\t\tfinal int arg2 = dict.get(inputs[5].substring(0, inputs[5].length() - 1));\n\t\t\t\t\n\t\t\t\t//System.out.println(arg1 + \" \" + ops + \" \" + arg2);\n\t\t\t\t\n\t\t\t\tif(\"child\".equals(ops)){\n\t\t\t\t\tSystem.out.println(child[arg2][arg1] ? \"True\" : \"False\");\n\t\t\t\t}else if(\"parent\".equals(ops)){\n\t\t\t\t\tSystem.out.println(parent[arg2] == arg1 ? \"True\" : \"False\");\n\t\t\t\t}else if(\"sibling\".equals(ops)){\n\t\t\t\t\tfinal int p_num= parent[arg2];\n\t\t\t\t\t\n\t\t\t\t\tif(p_num >= 0){\n\t\t\t\t\t\tSystem.out.println(child[p_num][arg1] ? \"True\" : \"False\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tSystem.out.println(\"False\");\n\t\t\t\t\t}\n\t\t\t\t}else if(\"ancestor\".equals(ops)){\n\t\t\t\t\tint p_num = parent[arg2];\n\t\t\t\t\t\n\t\t\t\t\twhile(p_num >= 0 && p_num != arg1){\n\t\t\t\t\t\tp_num = parent[p_num];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tSystem.out.println(p_num >= 0 ? \"True\" : \"False\");\n\t\t\t\t}else if(\"descendant\".equals(ops)){\n\t\t\t\t\tint p_num = parent[arg1];\n\t\t\t\t\t\n\t\t\t\t\twhile(p_num >= 0 && p_num != arg2){\n\t\t\t\t\t\tp_num = parent[p_num];\n\t\t\t\t\t\t//System.out.println(p_num + \" \" + parent[p_num]);\n\t\t\t\t\t\t//sc.next();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tSystem.out.println(p_num >= 0 ? \"True\" : \"False\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Family Tree\npublic class Main{\n\n\tclass V{\n\t\tint id;\n\t\tString name;\n\t\tV parent;\n\t\tList<V> adj;\n\t\tpublic V(int id, String name) {\n\t\t\tthis.id = id;\n\t\t\tthis.name = name;\n\t\t\tparent = null;\n\t\t\tadj = new ArrayList<V>();\n\t\t}\n\t\tvoid add(int depth, String name, int id){\n\t\t\tif(depth==0){\n\t\t\t\tV t = new V(id, name);\n\t\t\t\tt.parent = this;\n\t\t\t\tadj.add(t);\n\t\t\t\tv[id] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tadj.get(adj.size()-1).add(depth-1, name, id);\n\t\t\t}\n\t\t}\n\t\tboolean isChild(String s){\n\t\t\tfor(V t:adj)if(t.name.equals(s))return true;\n\t\t\treturn false;\n\t\t}\n\t\tboolean isParent(String s){\n\t\t\tif(parent==null)return false;\n\t\t\treturn parent.name.equals(s);\n\t\t}\n\t\tboolean isSibling(String s){\n\t\t\tif(parent==null)return false;\n\t\t\tfor(V t:parent.adj)if(t.name.equals(s))return true;\n\t\t\treturn false;\n\t\t}\n\t\tboolean isDesc(String s){\n\t\t\tfor(V t:adj){\n\t\t\t\tif(t.name.equals(s))return true;\n\t\t\t\tif(t.isDesc(s))return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tboolean isAnc(String s){\n\t\t\tif(parent==null)return false;\n\t\t\tif(parent.name.equals(s))return true;\n\t\t\treturn parent.isAnc(s);\n\t\t}\n\t}\n\t\n\tV[] v;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tv = new V[n+1];\n\t\t\tv[0] = new V(0, \"\");\n\t\t\tsc.nextLine();\n\t\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tint depth = 0;\n\t\t\t\twhile(s.charAt(depth)==' ')depth++;\n\t\t\t\tString name = s.substring(depth, s.length());\n\t\t\t\tv[0].add(depth, name, i);\n\t\t\t\tref.put(name, i);\n\t\t\t}\n\t\t\twhile(m--!=0){\n\t\t\t\tString[] s = sc.nextLine().split(\" \");\n\t\t\t\tString a = s[0];\n\t\t\t\tString cmd = s[3];\n\t\t\t\tString b = s[5].substring(0, s[5].length()-1);\n\t\t\t\tboolean f;\n\t\t\t\tif(\"child\".equals(cmd))f = v[ref.get(b)].isChild(a);\n\t\t\t\telse if(\"parent\".equals(cmd))f = v[ref.get(b)].isParent(a);\n\t\t\t\telse if(\"sibling\".equals(cmd))f = v[ref.get(b)].isSibling(a);\n\t\t\t\telse if(\"descendant\".equals(cmd))f = v[ref.get(b)].isDesc(a);\n\t\t\t\telse f = v[ref.get(b)].isAnc(a);\n\t\t\t\tSystem.out.println(f?\"True\":\"False\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public string parent { get; set; }\n    public List<string> child { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var n = int.Parse(line[0]);\n            var m = int.Parse(line[1]);\n            if (n == 0 && m == 0) break;\n            var a = new string[m];\n            var pp = new string[n];\n            var ppp = 0;\n            var d = new Dictionary<string, P>();\n            for (int i = 0; i < n; i++)\n            {\n                var s = Console.ReadLine();\n                var sp = s.Length - s.Replace(\" \", \"\").Length;\n                ppp = sp;\n                s = s.Trim();\n                pp[ppp] = s;\n                if (sp >= 1)\n                {\n                    d[pp[sp - 1]].child.Add(s);\n                    d[s] = new P { parent = pp[sp - 1], child = new List<string>() };\n                }\n                else d[s] = new P { parent = \"no\", child = new List<string>() };\n            }\n            var t = new string[3];\n            for (int i = 0; i < m; i++)\n            {\n                line = Console.ReadLine().Trim().Split(' ');\n                var a1 = line[0];\n                var a2 = line[3];\n                var a3 = line[5].Replace(\".\", \"\");\n                Console.WriteLine(getAns(d, a1, a2, a3) ? \"True\" : \"False\");\n            }\n            Console.WriteLine();\n        }\n    }\n    static bool IsAncestor(Dictionary<string, P> d, string a1, string a3)\n    {\n        var nt = a3;\n        while (true)\n        {\n            var np = d[nt].parent;\n            if (np == a1) return true;\n            else if (np == \"no\") return false;\n            nt = np;\n        }\n    }\n    static bool getAns(Dictionary<string, P> d, string a1, string a2, string a3)\n    {\n        if (a2 == \"child\") return d[a3].child.Contains(a1);\n        if (a2 == \"parent\") return d[a3].parent == a1;\n        if (a2 == \"sibling\") return d[a1].parent == d[a3].parent;\n        if (a2 == \"ancestor\") return IsAncestor(d, a1, a3);\n        else return IsAncestor(d, a3, a1);\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef Graph::get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef Graph::get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef make_layer_graph(s, t) #nodes:copy, edges:alias\n\t\tlg = Graph.new\n\t\tcorrespond = {}\n\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tcurrent_queue = [s]\n\n\t\tcorrespond[s] = lg.add_node\n\n\t\twhile 0\n\t\t\tnext_queue = []\n\t\t\twhile !current_queue.empty? \n\t\t\t\tu = current_queue.shift\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\tcorrespond[v] ||= lg.add_node \n\t\t\t\t\tcorrespond[e] = lg.add_edge(correspond[u], correspond[v])\n\n\t\t\t\t\tnext_queue << v unless reached.include?(v)\t\n\t\t\t\t}\n\t\t\tend\t\n\n\t\t\tbreak if next_queue.empty?\n\t\t\tnext_queue.each{|v| reached << v}\n\t\t\tcurrent_queue = next_queue\n\t\tend\n\n\t\tnil\n\tend\nend\n\ndef get_integers\n\tgets.split(\" \").map(&:to_i)\nend\n\nn, m = get_integers\nloop {\n\n\tg = Graph.new\n\n\tindent = -1\n\tstack = []\n\tname_to_node = {}\n\tn.times {\n\t\tgets =~ /^(\\s*)(\\w+)$/\n\t\tindent = $1.size\n\t\tstack.pop until stack.size <= indent\n\t\tv = g.add_node($2)\n\t\tg.add_edge(stack.last, v) if stack.size > 0\n\t\tstack << v\n\t\tname_to_node[v.label] = v\n\t}\n\n\tm.times {\n\t\tgets =~ /^(\\w+) is \\w+ (\\w+) of (\\w+)\\.$/\n\t\tu = name_to_node[$1]\n\t\trelation = $2\n\t\tv = name_to_node[$3]\n\t\t\n\t\tbool = false\n\t\tcase relation\n\t\twhen \"descendant\"\n\t\t\tbool = Graph::get_path_bfs(v, u)\n\t\twhen \"ancestor\"\n\t\t\tbool = Graph::get_path_bfs(u, v)\n\t\twhen \"child\"\n\t\t\tbool = !u.incomings.empty? && u.incomings.all?{|e| e.from == v}\n\t\twhen \"parent\"\n\t\t\tbool = !v.incomings.empty? && v.incomings.all?{|e| e.from == u}\n\t\twhen \"sibling\"\n\t\t\tbool = u.incomings == v.incomings\n\t\tend\n\t\tputs bool ? \"True\" : \"False\"\n\t}\n\n\tn, m = get_integers\n\tbreak if n == 0\n\tputs\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef Graph::get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef Graph::get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef make_layer_graph(s, t) #nodes:copy, edges:alias\n\t\tlg = Graph.new\n\t\tcorrespond = {}\n\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tcurrent_queue = [s]\n\n\t\tcorrespond[s] = lg.add_node\n\n\t\twhile 0\n\t\t\tnext_queue = []\n\t\t\twhile !current_queue.empty? \n\t\t\t\tu = current_queue.shift\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\tcorrespond[v] ||= lg.add_node \n\t\t\t\t\tcorrespond[e] = lg.add_edge(correspond[u], correspond[v])\n\n\t\t\t\t\tnext_queue << v unless reached.include?(v)\t\n\t\t\t\t}\n\t\t\tend\t\n\n\t\t\tbreak if next_queue.empty?\n\t\t\tnext_queue.each{|v| reached << v}\n\t\t\tcurrent_queue = next_queue\n\t\tend\n\n\t\tnil\n\tend\nend\n\ndef get_integers\n\tgets.split(\" \").map(&:to_i)\nend\n\nn, m = get_integers\nloop {\n\n\tg = Graph.new\n\n\tindent = -1\n\tstack = []\n\tname_to_node = {}\n\tn.times {\n\t\tgets =~ /^(\\s*)(\\w+)$/\n\t\tindent = $1.size\n\t\tstack.pop until stack.size <= indent\n\t\tv = g.add_node($2)\n\t\tg.add_edge(stack.last, v) if stack.size > 0\n\t\tstack << v\n\t\tname_to_node[v.label] = v\n\t}\n\n\tm.times {\n\t\tgets =~ /^(\\w+) is \\w+ (\\w+) of (\\w+)\\.$/\n\t\tu = name_to_node[$1]\n\t\trelation = $2\n\t\tv = name_to_node[$3]\n\t\t\n\t\tbool = false\n\t\tcase relation\n\t\twhen \"descendant\"\n\t\t\tbool = Graph::get_path_bfs(v, u)\n\t\twhen \"ancestor\"\n\t\t\tbool = Graph::get_path_bfs(u, v)\n\t\twhen \"child\"\n\t\t\tbool = !u.incomings.empty? && u.incomings.all?{|e| e.from == v}\n\t\twhen \"parent\"\n\t\t\tbool = !v.incomings.empty? && v.incomings.all?{|e| e.from == u}\n\t\twhen \"sibling\"\n\t\t\tbool = u.incomings == v.incomings\n\t\tend\n\t\tputs bool ? \"True\" : \"No\"\n\t}\n\n\tn, m = get_integers\n\tbreak if n == 0\n\tputs\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef Graph::get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef Graph::get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef make_layer_graph(s, t) #nodes:copy, edges:alias\n\t\tlg = Graph.new\n\t\tcorrespond = {}\n\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tcurrent_queue = [s]\n\n\t\tcorrespond[s] = lg.add_node\n\n\t\twhile 0\n\t\t\tnext_queue = []\n\t\t\twhile !current_queue.empty? \n\t\t\t\tu = current_queue.shift\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\tcorrespond[v] ||= lg.add_node \n\t\t\t\t\tcorrespond[e] = lg.add_edge(correspond[u], correspond[v])\n\n\t\t\t\t\tnext_queue << v unless reached.include?(v)\t\n\t\t\t\t}\n\t\t\tend\t\n\n\t\t\tbreak if next_queue.empty?\n\t\t\tnext_queue.each{|v| reached << v}\n\t\t\tcurrent_queue = next_queue\n\t\tend\n\n\t\tnil\n\tend\nend\n\ndef get_integers\n\tgets.split(\" \").map(&:to_i)\nend\n\nn, m = get_integers\nloop {\n\n\tg = Graph.new\n\n\tindent = -1\n\tstack = []\n\tname_to_node = {}\n\tn.times {\n\t\tgets =~ /^(\\s*)(\\w+)$/\n\t\tindent = $1.size\n\t\tstack.pop until stack.size <= indent\n\t\tv = g.add_node($2)\n\t\tg.add_edge(stack.last, v) if stack.size > 0\n\t\tstack << v\n\t\tname_to_node[v.label] = v\n\t}\n\n\tm.times {\n\t\tgets =~ /^(\\w+) is \\w+ (\\w+) of (\\w+)\\.$/\n\t\tu = name_to_node[$1]\n\t\trelation = $2\n\t\tv = name_to_node[$3]\n\t\t\n\t\tbool = false\n\t\tcase relation\n\t\twhen \"descendant\"\n\t\t\tbool = Graph::get_path_bfs(v, u)\n\t\twhen \"ancestor\"\n\t\t\tbool = Graph::get_path_bfs(u, v)\n\t\twhen \"child\"\n\t\t\tbool = !u.incomings.empty? && u.incomings.all?{|e| e.from == v}\n\t\twhen \"parent\"\n\t\t\tbool = !v.incomings.empty? && v.incomings.all?{|e| e.from == u}\n\t\twhen \"sibling\"\n\t\t\tbool = (!u.incomings.empty? && u.incomings == v.incomings)\n\t\tend\n\t\tputs bool ? \"True\" : \"False\"\n\t}\n\n\tn, m = get_integers\n\tbreak if n == 0\n\tputs\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef check_relation(prts, a, b, rel)\t# check if 'a is rel of b' is true\n  case rel\n  when 'child'\n    return (prts[a] == b)\n  when 'parent'\n    return (prts[b] == a)\n  when 'ancestor'\n    while prts[b]\n      return true if (prts[b] == a)\n      b = prts[b]\n    end\n    return false\n  when 'descendant'\n    while prts[a]\n      return true if (prts[a] == b)\n      a = prts[a]\n    end\n    return false\n  when 'sibling'\n    return (prts[a] == prts[b])\n  else\n    puts \"undefined relation: #{rel}\"\n  end\n  nil\nend\n\n### main\n\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if (n | m) == 0\n\n  prts = {}\n  prt = cur = nil\n  idt = 0\n  \n  n.times do\n    line = gets.rstrip\n    name = line.lstrip\n    i = line.index(/[^ ]/)\n    #p [name, i, prt, idt]\n\n    if idt < i\n      idt = i\n      prt = cur\n    elsif idt > i\n      idt = i\n      prt = prts[prt]\n    end\n\n    prts[name] = prt\n    cur = name\n  end\n  #p prts\n\n  m.times do\n    cols = gets.strip.split\n    aname = cols[0]\n    bname = cols[5].delete('.')\n    rel = cols[3]\n    #p [aname, bname, rel]\n\n    puts (check_relation(prts, aname, bname, rel) ? 'True' : 'False')\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef Graph::get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef Graph::get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef make_layer_graph(s, t) #nodes:copy, edges:alias\n\t\tlg = Graph.new\n\t\tcorrespond = {}\n\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tcurrent_queue = [s]\n\n\t\tcorrespond[s] = lg.add_node\n\n\t\twhile 0\n\t\t\tnext_queue = []\n\t\t\twhile !current_queue.empty? \n\t\t\t\tu = current_queue.shift\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\tcorrespond[v] ||= lg.add_node \n\t\t\t\t\tcorrespond[e] = lg.add_edge(correspond[u], correspond[v])\n\n\t\t\t\t\tnext_queue << v unless reached.include?(v)\t\n\t\t\t\t}\n\t\t\tend\t\n\n\t\t\tbreak if next_queue.empty?\n\t\t\tnext_queue.each{|v| reached << v}\n\t\t\tcurrent_queue = next_queue\n\t\tend\n\n\t\tnil\n\tend\nend\n\ndef get_integers\n\tgets.split(\" \").map(&:to_i)\nend\n\nn, m = get_integers\nloop {\n\n\tg = Graph.new\n\n\tindent = -1\n\tstack = []\n\tname_to_node = {}\n\tn.times {\n\t\tgets =~ /^(\\s*)(\\w+)$/\n\t\tindent = $1.size\n\t\tstack.pop until stack.size <= indent\n\t\tv = g.add_node($2)\n\t\tg.add_edge(stack.last, v) if stack.size > 0\n\t\tstack << v\n\t\tname_to_node[v.label] = v\n\t}\n\n\tm.times {\n\t\tgets =~ /^(\\w+) is \\w+ (\\w+) of (\\w+)\\.$/\n\t\tu = name_to_node[$1]\n\t\trelation = $2\n\t\tv = name_to_node[$3]\n\t\t\n\t\tbool = false\n\t\tcase relation\n\t\twhen \"descendant\"\n\t\t\tbool = Graph::get_path_bfs(v, u)\n\t\twhen \"ancestor\"\n\t\t\tbool = Graph::get_path_bfs(u, v)\n\t\twhen \"child\"\n\t\t\tbool = !u.incomings.empty? && u.incomings.all?{|e| e.from == v}\n\t\twhen \"parent\"\n\t\t\tbool = !v.incomings.empty? && v.incomings.all?{|e| e.from == u}\n\t\twhen \"sibling\"\n\t\t\tbool = (!u.incomings.empty? && u.incomings.map(&:from) == v.incomings.map(&:from))\n\t\tend\n\t\tputs bool ? \"True\" : \"False\"\n\t}\n\n\tn, m = get_integers\n\tbreak if n == 0\n\tputs\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef Graph::get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\nend\n\nclass Forest < Graph\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\traise \"multiple in-edge\" unless v.incomings.empty?\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef parent\n\t\t\ta = incomings.to_a.map(&:from)\n\t\t\ta.empty? ? nil : a[0]\n\t\tend\n\tend\n\n\tclass Edge < Graph::Edge\n\tend\nend\n\nloop {\n\tn, m = gets.split(\" \").map(&:to_i)\n\tbreak if n == 0\n\n\tg = Forest.new\n\tstack = []\n\tname_to_node = {}\n\n\tn.times {\n\t\tgets =~ /^(\\s*)(\\w+)$/\n\t\tstack.pop until stack.size <= $1.size\n\t\tv = g.add_node($2)\n\t\tg.add_edge(stack.last, v) unless stack.empty?\n\t\tstack << v\n\t\tname_to_node[v.label] = v\n\t}\n\n\tm.times {\n\t\tgets =~ /^(\\w+) is \\w+ (\\w+) of (\\w+)\\.$/\n\t\tu = name_to_node[$1]\n\t\trelation = $2\n\t\tv = name_to_node[$3]\n\t\t\n\t\tbool = false\n\t\tcase relation\n\t\twhen \"descendant\"\n\t\t\tbool = Graph::get_path_dfs(v, u)\n\t\twhen \"ancestor\"\n\t\t\tbool = Graph::get_path_dfs(u, v)\n\t\twhen \"child\"\n\t\t\tbool = u.parent == v\n\t\twhen \"parent\"\n\t\t\tbool = v.parent == u\n\t\twhen \"sibling\"\n\t\t\tbool = u.parent == v.parent\n\t\tend\n\t\tputs bool ? \"True\" : \"False\"\n\t}\n\n\tputs\n}"
  },
  {
    "language": "Ruby",
    "code": "def is_ancestor?(name1, name2)\n  return true if name2 == @top\n  p = name1\n  while p != @top\n    p = @parent[p]\n    return true if p == name2\n  end\n  false\nend\n\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  @parent = {}\n  cur_gen = 0\n  @top = gets.chomp\n  current = [@top]\n  (n-1).times do\n    name = gets.chomp\n    gen = name.count(' ')\n    name.delete!(' ')\n    @parent[name] = current[gen - 1]\n    current[gen] = name\n    cur_gen = gen\n  end\n\n  m.times do\n    s = gets.chomp.chop.split\n    case s[3]\n    when 'child'\n      puts @parent[s[0]] == s[5] ? 'True' : 'False'\n    when 'parent'\n      puts @parent[s[5]] == s[0] ? 'True' : 'False'\n    when 'sibling'\n      puts @parent[s[0]] == @parent[s[5]] ? 'True' : 'False'\n    when 'descendant'\n      puts is_ancestor?(s[0], s[5]) ? 'True' : 'False'\n    when 'ancestor'\n      puts is_ancestor?(s[5], s[0]) ? 'True' : 'False'\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "def is_ancestor?(name1, name2)\n  return true if name2 == @top\n  p = name1\n  while p != @top\n    p = @parent[p]\n    return true if p == name2\n  end\n  false\nend\n\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  @parent = {}\n  cur_gen = 0\n  @top = gets.chomp\n  current = [@top]\n  (n-1).times do\n    name = gets.chomp\n    gen = name.count(' ')\n    name.delete!(' ')\n    @parent[name] = current[gen - 1]\n    if gen != cur_gen\n      current[gen] = name\n      cur_gen = gen\n    end\n  end\n\n  m.times do\n    s = gets.chomp.chop.split\n    case s[3]\n    when 'child'\n      puts @parent[s[0]] == s[5] ? 'True' : 'False'\n    when 'parent'\n      puts @parent[s[5]] == s[0] ? 'True' : 'False'\n    when 'sibling'\n      puts @parent[s[0]] == @parent[s[5]] ? 'True' : 'False'\n    when 'descendant'\n      puts is_ancestor?(s[0], s[5]) ? 'True' : 'False'\n    when 'ancestor'\n      puts is_ancestor?(s[5], s[0]) ? 'True' : 'False'\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "equire 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef Graph::get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef Graph::get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef make_layer_graph(s, t) #nodes:copy, edges:alias\n\t\tlg = Graph.new\n\t\tcorrespond = {}\n\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tcurrent_queue = [s]\n\n\t\tcorrespond[s] = lg.add_node\n\n\t\twhile 0\n\t\t\tnext_queue = []\n\t\t\twhile !current_queue.empty? \n\t\t\t\tu = current_queue.shift\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\tcorrespond[v] ||= lg.add_node \n\t\t\t\t\tcorrespond[e] = lg.add_edge(correspond[u], correspond[v])\n\n\t\t\t\t\tnext_queue << v unless reached.include?(v)\t\n\t\t\t\t}\n\t\t\tend\t\n\n\t\t\tbreak if next_queue.empty?\n\t\t\tnext_queue.each{|v| reached << v}\n\t\t\tcurrent_queue = next_queue\n\t\tend\n\n\t\tnil\n\tend\nend\n\ndef get_integers\n\tgets.split(\" \").map(&:to_i)\nend\n\nloop {\n\tn, m = get_integers\n\tbreak if n == 0\n\n\tg = Graph.new\n\n\tindent = -1\n\tstack = []\n\tname_to_node = {}\n\tn.times {\n\t\tgets =~ /^(\\s*)(\\w+)$/\n\t\tindent = $1.size\n\t\tstack.pop until stack.size <= indent\n\t\tv = g.add_node($2)\n\t\tg.add_edge(stack.last, v) if stack.size > 0\n\t\tstack << v\n\t\tname_to_node[v.label] = v\n\t}\n\n\tm.times {\n\t\tgets =~ /^(\\w+) is \\w+ (\\w+) of (\\w+)\\.$/\n\t\tu = name_to_node[$1]\n\t\trelation = $2\n\t\tv = name_to_node[$3]\n\t\t\n\t\tbool = false\n\t\tcase relation\n\t\twhen \"descendant\"\n\t\t\tbool = Graph::get_path_bfs(v, u)\n\t\twhen \"ancestor\"\n\t\t\tbool = Graph::get_path_bfs(u, v)\n\t\twhen \"child\"\n\t\t\tbool = !u.incomings.empty? && u.incomings.all?{|e| e.from == v}\n\t\twhen \"parent\"\n\t\t\tbool = !v.incomings.empty? && v.incomings.all?{|e| e.from == u}\n\t\twhen \"sibling\"\n\t\t\tbool = u.incomings == v.incomings\n\t\tend\n\t\tputs bool ? \"True\" : \"No\"\n\t}\n\tputs\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Graph\n\tdef initialize\n\t\t@nodes = Set.new\n\t\t@edges = Set.new\n\tend\n\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v)\n\t\te = Edge.new(u, v)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\t\t\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\tend\n\t\tattr_reader :from, :to\n\tend\n\n\tdef Graph::get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef Graph::get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef make_layer_graph(s, t) #nodes:copy, edges:alias\n\t\tlg = Graph.new\n\t\tcorrespond = {}\n\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tcurrent_queue = [s]\n\n\t\tcorrespond[s] = lg.add_node\n\n\t\twhile 0\n\t\t\tnext_queue = []\n\t\t\twhile !current_queue.empty? \n\t\t\t\tu = current_queue.shift\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\tnext if reached.include?(v)\n\n\t\t\t\t\tcorrespond[v] ||= lg.add_node \n\t\t\t\t\tcorrespond[e] = lg.add_edge(correspond[u], correspond[v])\n\n\t\t\t\t\tnext_queue << v unless reached.include?(v)\t\n\t\t\t\t}\n\t\t\tend\t\n\n\t\t\tbreak if next_queue.empty?\n\t\t\tnext_queue.each{|v| reached << v}\n\t\t\tcurrent_queue = next_queue\n\t\tend\n\n\t\tnil\n\tend\nend\n\ndef get_integers\n\tgets.split(\" \").map(&:to_i)\nend\n\nloop {\n\tn, m = get_integers\n\tbreak if n == 0\n\n\tg = Graph.new\n\n\tindent = -1\n\tstack = []\n\tname_to_node = {}\n\tn.times {\n\t\tgets =~ /^(\\s*)(\\w+)$/\n\t\tindent = $1.size\n\t\tstack.pop until stack.size <= indent\n\t\tv = g.add_node($2)\n\t\tg.add_edge(stack.last, v) if stack.size > 0\n\t\tstack << v\n\t\tname_to_node[v.label] = v\n\t}\n\n\tm.times {\n\t\tgets =~ /^(\\w+) is \\w+ (\\w+) of (\\w+)\\.$/\n\t\tu = name_to_node[$1]\n\t\trelation = $2\n\t\tv = name_to_node[$3]\n\t\t\n\t\tbool = false\n\t\tcase relation\n\t\twhen \"descendant\"\n\t\t\tbool = Graph::get_path_bfs(v, u)\n\t\twhen \"ancestor\"\n\t\t\tbool = Graph::get_path_bfs(u, v)\n\t\twhen \"child\"\n\t\t\tbool = !u.incomings.empty? && u.incomings.all?{|e| e.from == v}\n\t\twhen \"parent\"\n\t\t\tbool = !v.incomings.empty? && v.incomings.all?{|e| e.from == u}\n\t\twhen \"sibling\"\n\t\t\tbool = (!u.incomings.empty? && u.incomings.map(&:from) == v.incomings.map(&:from))\n\t\tend\n\t\tputs bool ? \"True\" : \"False\"\n\t}\n\n\tputs\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef check_relation(prts, a, b, rel)\t# check if 'a is rel of b' is true\n  return false if a == b\n  \n  case rel\n  when 'child'\n    return (prts[a] == b)\n  when 'parent'\n    return (prts[b] == a)\n  when 'ancestor'\n    while prts[b]\n      return true if (prts[b] == a)\n      b = prts[b]\n    end\n    return false\n  when 'descendant'\n    while prts[a]\n      return true if (prts[a] == b)\n      a = prts[a]\n    end\n    return false\n  when 'sibling'\n    return (prts[a] == prts[b])\n  else\n    puts \"undefined relation: #{rel}\"\n  end\n  nil\nend\n\n### main\n\nloop do\n  n, m = gets.split.map(&:to_i)\n  break if (n | m) == 0\n\n  prts = {}\n  ancs = []\n  cur = nil\n  idt = 0\n  \n  n.times do\n    line = gets.rstrip\n    name = line.lstrip\n    i = line.index(/[^ ]/)\n    #p [name, i, prt, idt]\n\n    if idt < i\n      ancs << cur\n      idt = i\n    elsif idt > i\n      ancs.pop(idt - i)\n      idt = i\n    end\n\n    prts[name] = ancs.last\n    cur = name\n  end\n  #p prts\n\n  m.times do\n    cols = gets.strip.split\n    aname = cols[0]\n    bname = cols[5].delete('.')\n    rel = cols[3]\n    #p [aname, bname, rel]\n\n    puts (check_relation(prts, aname, bname, rel) ? 'True' : 'False')\n  end\n  puts\nend"
  },
  {
    "language": "Python",
    "code": "while(1):\n    [n,m]=[int(x) for x in raw_input().split()]\n    if n==0:\n        break\n    else:\n        familymatrix=[[-100000 for x in range(n)] for y in range(n)]\n        for i in range(n):\n            familymatrix[i][i]=0\n        namedic={}\n        returned=[0 for x in range(n)]\n        spacenum=0\n        spacenumold=0\n        for i in range(n):\n            indata=raw_input()\n            name=indata.strip()\n            spacenum=len(indata)-len(name)\n            namedic[name]=i\n            for j in range(i):\n                familymatrix[j][i]=familymatrix[j][i-1]+(spacenum-spacenumold)\n                #if familymatrix[j][i]<0:\n                #    familymatrix[j][i]=-1000000\n                #if familymatrix[j][i]>0 and returned[j]:\n                #    familymatrix[j][i]=-1000000\n            spacenumold=spacenum\n        for i in range(n):\n            for j in range(i):\n                if familymatrix[j][i]==0 and returned[j]==0:\n                    returned[j]=1\n                elif familymatrix[j][i]<0:\n                    returned[j]=2\n                if familymatrix[j][i]>0 and returned[j]==1:\n                    familymatrix[j][i]=-1\n                elif returned[j]==2:\n                    familymatrix[j][i]=-1\n        #for i in range(n):\n        #    print familymatrix[i]\n        for i in range(m):\n            query=raw_input().split()\n            X=namedic[query[0]]\n            Y=namedic[query[-1][:-1]]\n            question=' '.join(query[1:-1])\n            if question == 'is a child of':\n                print familymatrix[Y][X]==1\n            elif question == 'is the parent of':\n                print familymatrix[X][Y]==1\n            elif question == 'is a sibling of':\n                print (familymatrix[X][Y]==0) or (familymatrix[Y][X]==0)\n            elif question == 'is a descendant of':\n                print familymatrix[Y][X]>0\n            elif question == 'is an ancestor of':\n                print familymatrix[X][Y]>0\n        print ''\n        "
  },
  {
    "language": "Python",
    "code": "while(1):\n    [n,m]=[int(x) for x in raw_input().split()]\n    if n==0:\n        break\n    else:\n        familymatrix=[[-100000 for x in range(n)] for y in range(n)]\n        for i in range(n):\n            familymatrix[i][i]=0\n        namedic={}\n        spacenum=0\n        spacenumold=0\n        for i in range(n):\n            indata=raw_input()\n            name=indata.strip()\n            spacenum=len(indata)-len(name)\n            namedic[name]=i\n            for j in range(i):\n                if familymatrix[j][i-1]==0 and familymatrix[j][i-2]>0:\n                    familymatrix[j][i]=-1000000\n                else:\n                    familymatrix[j][i]=familymatrix[j][i-1]+(spacenum-spacenumold)\n                    if familymatrix[j][i]<0:\n                        familymatrix[j][i]=-1000000\n            spacenumold=spacenum\n        #for i in range(n):\n        #    print familymatrix[i]\n        for i in range(m):\n            query=raw_input().split()\n            X=namedic[query[0]]\n            Y=namedic[query[-1][:-1]]\n            question=' '.join(query[1:-1])\n            if question == 'is a child of':\n                print familymatrix[Y][X]==1\n            elif question == 'is the parent of':\n                print familymatrix[X][Y]==1\n            elif question == 'is a sibling of':\n                print (familymatrix[X][Y]==0) or (familymatrix[Y][X]==0)\n            elif question == 'is a descendant of':\n                print familymatrix[Y][X]>0\n            elif question == 'is an ancestor of':\n                print familymatrix[X][Y]>0\n        print ''\n        "
  }
]