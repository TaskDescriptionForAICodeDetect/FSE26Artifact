[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LINE_LENGTH 1024\n#define MAX_NAME_LENGTH 256\n\ntypedef struct Person {\n    char name[MAX_NAME_LENGTH];\n    struct Person *parent;\n    struct Person *children;\n    struct Person *next;\n} Person;\n\nPerson *create_person(const char *name) {\n    Person *p = (Person *)malloc(sizeof(Person));\n    strcpy(p->name, name);\n    p->parent = NULL;\n    p->children = NULL;\n    p->next = NULL;\n    return p;\n}\n\nvoid add_child(Person *parent, Person *child) {\n    child->parent = parent;\n    child->next = parent->children;\n    parent->children = child;\n}\n\nPerson *find_person(Person *root, const char *name) {\n    if (root == NULL) return NULL;\n    if (strcmp(root->name, name) == 0) return root;\n    Person *child = root->children;\n    while (child != NULL) {\n        Person *found = find_person(child, name);\n        if (found != NULL) return found;\n        child = child->next;\n    }\n    return NULL;\n}\n\nbool is_ancestor(Person *ancestor, Person *descendant) {\n    if (ancestor == NULL || descendant == NULL) return false;\n    Person *parent = descendant->parent;\n    while (parent != NULL) {\n        if (parent == ancestor) return true;\n        parent = parent->parent;\n    }\n    return false;\n}\n\nbool is_sibling(Person *a, Person *b) {\n    if (a == NULL || b == NULL) return false;\n    return a->parent != NULL && a->parent == b->parent;\n}\n\nbool is_cousin(Person *a, Person *b) {\n    if (a == NULL || b == NULL) return false;\n    Person *pa = a->parent;\n    Person *pb = b->parent;\n    if (pa == NULL || pb == NULL) return false;\n    return pa != pb && !is_ancestor(pa, pb) && !is_ancestor(pb, pa);\n}\n\nvoid free_tree(Person *root) {\n    if (root == NULL) return;\n    Person *child = root->children;\n    while (child != NULL) {\n        Person *next = child->next;\n        free_tree(child);\n        child = next;\n    }\n    free(root);\n}\n\nint main() {\n    char line[MAX_LINE_LENGTH];\n    int dataset = 1;\n\n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n') continue;\n\n        Person *root = NULL;\n        Person *current_parent = NULL;\n        int current_indent = 0;\n\n        while (line[0] != '\\n' && line[0] != '\\0') {\n            int indent = 0;\n            while (line[indent] == ' ') indent++;\n            char name[MAX_NAME_LENGTH];\n            sscanf(line + indent, \"%s\", name);\n\n            Person *p = create_person(name);\n            if (indent == 0) {\n                root = p;\n                current_parent = p;\n                current_indent = 0;\n            } else {\n                while (current_indent >= indent) {\n                    current_parent = current_parent->parent;\n                    current_indent--;\n                }\n                add_child(current_parent, p);\n                current_parent = p;\n                current_indent = indent;\n            }\n\n            if (!fgets(line, sizeof(line), stdin)) break;\n        }\n\n        while (fgets(line, sizeof(line), stdin)) {\n            if (line[0] == '\\n') break;\n            char name1[MAX_NAME_LENGTH], name2[MAX_NAME_LENGTH], relation[MAX_NAME_LENGTH];\n            sscanf(line, \"%s is the %s of %s\", name1, relation, name2);\n\n            Person *p1 = find_person(root, name1);\n            Person *p2 = find_person(root, name2);\n\n            bool result = false;\n            if (strcmp(relation, \"parent\") == 0) {\n                result = p2 != NULL && p2->parent == p1;\n            } else if (strcmp(relation, \"child\") == 0) {\n                result = p1 != NULL && p1->parent == p2;\n            } else if (strcmp(relation, \"sibling\") == 0) {\n                result = is_sibling(p1, p2);\n            } else if (strcmp(relation, \"ancestor\") == 0) {\n                result = is_ancestor(p1, p2);\n            } else if (strcmp(relation, \"descendant\") == 0) {\n                result = is_ancestor(p2, p1);\n            } else if (strcmp(relation, \"cousin\") == 0) {\n                result = is_cousin(p1, p2);\n            }\n\n            printf(\"%s\\n\", result ? \"True\" : \"False\");\n        }\n\n        free_tree(root);\n        dataset++;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:14:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FamilyTreeChecker {\n    static class Person {\n        String name;\n        Person parent;\n        List<Person> children;\n\n        Person(String name) {\n            this.name = name;\n            this.children = new ArrayList<>();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        scanner.nextLine();\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            Map<String, Person> familyTree = new HashMap<>();\n            Person root = null;\n\n            // Read family tree\n            int lines = scanner.nextInt();\n            scanner.nextLine();\n\n            for (int i = 0; i < lines; i++) {\n                String line = scanner.nextLine();\n                int indent = line.lastIndexOf(' ') + 1;\n                String name = line.trim();\n\n                Person person = familyTree.computeIfAbsent(name, Person::new);\n\n                if (indent == 0) {\n                    root = person;\n                } else {\n                    String parentName = line.substring(0, indent - 1).trim();\n                    Person parent = familyTree.get(parentName);\n                    person.parent = parent;\n                    parent.children.add(person);\n                }\n            }\n\n            // Read and evaluate statements\n            int statements = scanner.nextInt();\n            scanner.nextLine();\n\n            for (int i = 0; i < statements; i++) {\n                String statement = scanner.nextLine();\n                String[] parts = statement.split(\" \");\n                String relation = parts[1];\n                String person1 = parts[0];\n                String person2 = parts[2];\n\n                boolean result = evaluateRelation(familyTree.get(person1), familyTree.get(person2), relation);\n                System.out.println(result);\n            }\n        }\n    }\n\n    static boolean evaluateRelation(Person p1, Person p2, String relation) {\n        switch (relation) {\n            case \"parent\":\n                return p1.children.contains(p2);\n            case \"child\":\n                return p2.children.contains(p1);\n            case \"sibling\":\n                return p1.parent != null && p2.parent != null && p1.parent == p2.parent;\n            case \"ancestor\":\n                return isAncestor(p1, p2);\n            case \"descendant\":\n                return isAncestor(p2, p1);\n            default:\n                return false;\n        }\n    }\n\n    static boolean isAncestor(Person ancestor, Person descendant) {\n        Person current = descendant;\n        while (current != null) {\n            if (current == ancestor) return true;\n            current = current.parent;\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 19:14:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Person {\n    string name;\n    vector<Person*> children;\n    Person* parent;\n};\n\nmap<string, Person*> people;\n\nvoid buildTree(const vector<string>& lines, int& index, Person* parent, int indent) {\n    while (index < lines.size()) {\n        string line = lines[index];\n        int currentIndent = 0;\n        while (currentIndent < line.size() && line[currentIndent] == ' ') {\n            currentIndent++;\n        }\n        if (currentIndent < indent) {\n            return;\n        }\n        if (currentIndent > indent) {\n            index++;\n            continue;\n        }\n        string name = line.substr(currentIndent);\n        Person* person = new Person{name, {}, parent};\n        people[name] = person;\n        if (parent != nullptr) {\n            parent->children.push_back(person);\n        }\n        index++;\n        buildTree(lines, index, person, indent + 1);\n    }\n}\n\nbool isAncestor(Person* ancestor, Person* descendant) {\n    while (descendant != nullptr) {\n        if (descendant == ancestor) {\n            return true;\n        }\n        descendant = descendant->parent;\n    }\n    return false;\n}\n\nbool isSibling(Person* a, Person* b) {\n    return a != nullptr && b != nullptr && a->parent != nullptr && a->parent == b->parent;\n}\n\nbool isCousin(Person* a, Person* b) {\n    if (a == nullptr || b == nullptr || a == b) {\n        return false;\n    }\n    int aDepth = 0, bDepth = 0;\n    Person* aAncestor = a;\n    while (aAncestor->parent != nullptr) {\n        aAncestor = aAncestor->parent;\n        aDepth++;\n    }\n    Person* bAncestor = b;\n    while (bAncestor->parent != nullptr) {\n        bAncestor = bAncestor->parent;\n        bDepth++;\n    }\n    if (aAncestor != bAncestor) {\n        return false;\n    }\n    while (aDepth > bDepth) {\n        a = a->parent;\n        aDepth--;\n    }\n    while (bDepth > aDepth) {\n        b = b->parent;\n        bDepth--;\n    }\n    while (a != b) {\n        a = a->parent;\n        b = b->parent;\n    }\n    return aDepth >= 1 && bDepth >= 1;\n}\n\nbool isUnrelated(Person* a, Person* b) {\n    if (a == nullptr || b == nullptr) {\n        return false;\n    }\n    Person* aAncestor = a;\n    while (aAncestor->parent != nullptr) {\n        aAncestor = aAncestor->parent;\n    }\n    Person* bAncestor = b;\n    while (bAncestor->parent != nullptr) {\n        bAncestor = bAncestor->parent;\n    }\n    return aAncestor != bAncestor;\n}\n\nvoid processStatement(const string& statement) {\n    istringstream iss(statement);\n    string name1, relation, name2;\n    iss >> name1 >> relation >> name2;\n    \n    Person* p1 = people[name1];\n    Person* p2 = people[name2];\n    \n    bool result = false;\n    if (relation == \"child\") {\n        result = p2 != nullptr && p1 != nullptr && p1->parent == p2;\n    } else if (relation == \"parent\") {\n        result = p1 != nullptr && p2 != nullptr && p2->parent == p1;\n    } else if (relation == \"sibling\") {\n        result = isSibling(p1, p2);\n    } else if (relation == \"ancestor\") {\n        result = isAncestor(p1, p2);\n    } else if (relation == \"descendant\") {\n        result = isAncestor(p2, p1);\n    } else if (relation == \"cousin\") {\n        result = isCousin(p1, p2);\n    } else if (relation == \"unrelated\") {\n        result = isUnrelated(p1, p2);\n    }\n    \n    cout << (result ? \"True\" : \"False\") << endl;\n}\n\nint main() {\n    string line;\n    vector<string> lines;\n    while (getline(cin, line)) {\n        if (line.empty()) {\n            break;\n        }\n        lines.push_back(line);\n    }\n    \n    int index = 0;\n    buildTree(lines, index, nullptr, 0);\n    \n    while (getline(cin, line)) {\n        if (line.empty()) {\n            break;\n        }\n        processStatement(line);\n    }\n    \n    for (auto& p : people) {\n        delete p.second;\n    }\n    people.clear();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:15:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_NAME_LENGTH 50\n#define MAX_FAMILY_MEMBERS 1000\n#define MAX_DEPTH 100\n\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    int depth;\n    char parent[MAX_NAME_LENGTH];\n} FamilyMember;\n\nFamilyMember family[MAX_FAMILY_MEMBERS];\nint familySize = 0;\n\nvoid resetFamily() {\n    familySize = 0;\n}\n\nvoid addFamilyMember(const char* name, int depth, const char* parent) {\n    strcpy(family[familySize].name, name);\n    family[familySize].depth = depth;\n    strcpy(family[familySize].parent, parent);\n    familySize++;\n}\n\nchar* findParent(const char* name) {\n    for (int i = 0; i < familySize; i++) {\n        if (strcmp(family[i].name, name) == 0) {\n            return family[i].parent;\n        }\n    }\n    return NULL;\n}\n\nbool isDescendant(const char* descendant, const char* ancestor) {\n    char* current = findParent(descendant);\n    while (current != NULL) {\n        if (strcmp(current, ancestor) == 0) {\n            return true;\n        }\n        current = findParent(current);\n    }\n    return false;\n}\n\nbool areSiblings(const char* person1, const char* person2) {\n    char* parent1 = findParent(person1);\n    char* parent2 = findParent(person2);\n    \n    if (parent1 == NULL || parent2 == NULL) {\n        return false;\n    }\n    \n    return strcmp(parent1, parent2) == 0;\n}\n\nvoid parseFamilyTree() {\n    char line[MAX_NAME_LENGTH];\n    char currentParent[MAX_NAME_LENGTH] = \"\";\n    int lastDepth = -1;\n\n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n') break;\n\n        int depth = 0;\n        while (line[depth] == ' ') depth++;\n\n        char* name = line + depth;\n        name[strcspn(name, \"\\n\")] = 0;\n\n        if (depth == 0) {\n            strcpy(currentParent, name);\n            addFamilyMember(name, depth, \"\");\n        } else {\n            if (depth > lastDepth) {\n                addFamilyMember(name, depth, currentParent);\n                strcpy(currentParent, name);\n            } else {\n                char* parentName = findParent(currentParent);\n                addFamilyMember(name, depth, parentName ? parentName : \"\");\n            }\n        }\n        lastDepth = depth;\n    }\n}\n\nvoid processStatements() {\n    char statement[MAX_NAME_LENGTH * 3];\n    \n    while (fgets(statement, sizeof(statement), stdin)) {\n        if (statement[0] == '\\n') break;\n\n        statement[strcspn(statement, \"\\n\")] = 0;\n        char* token = strtok(statement, \" \");\n        \n        if (strcmp(token, \"descendant\") == 0) {\n            char* descendant = strtok(NULL, \" \");\n            char* ancestor = strtok(NULL, \" \");\n            printf(\"%s\\n\", isDescendant(descendant, ancestor) ? \"True\" : \"False\");\n        } else if (strcmp(token, \"siblings\") == 0) {\n            char* person1 = strtok(NULL, \" \");\n            char* person2 = strtok(NULL, \" \");\n            printf(\"%s\\n\", areSiblings(person1, person2) ? \"True\" : \"False\");\n        }\n    }\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\\n\", &datasets);\n\n    for (int i = 0; i < datasets; i++) {\n        resetFamily();\n        parseFamilyTree();\n        processStatements();\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:15:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nclass FamilyTree {\nprivate:\n    std::map<std::string, std::vector<std::string>> parentToChildren;\n    std::map<std::string, std::string> childToParent;\n\n    bool isDescendant(const std::string& ancestor, const std::string& descendant) {\n        if (ancestor == descendant) return false;\n        \n        std::string current = descendant;\n        while (childToParent.count(current)) {\n            current = childToParent[current];\n            if (current == ancestor) return true;\n        }\n        return false;\n    }\n\npublic:\n    void addRelation(const std::string& parent, const std::string& child) {\n        parentToChildren[parent].push_back(child);\n        childToParent[child] = parent;\n    }\n\n    bool checkRelation(const std::string& person1, const std::string& person2, const std::string& relation) {\n        if (relation == \"parent\") {\n            return childToParent.count(person2) && childToParent[person2] == person1;\n        }\n        if (relation == \"child\") {\n            return childToParent.count(person1) && childToParent[person1] == person2;\n        }\n        if (relation == \"sibling\") {\n            if (!childToParent.count(person1) || !childToParent.count(person2)) return false;\n            return childToParent[person1] == childToParent[person2];\n        }\n        if (relation == \"descendant\") {\n            return isDescendant(person1, person2);\n        }\n        if (relation == \"ancestor\") {\n            return isDescendant(person2, person1);\n        }\n        return false;\n    }\n};\n\nFamilyTree parseFamilyTree(std::istream& input) {\n    FamilyTree tree;\n    std::vector<std::pair<int, std::string>> hierarchy;\n    std::string line;\n\n    while (std::getline(input, line) && !line.empty()) {\n        int depth = 0;\n        while (line[depth] == '\\t') depth++;\n        std::string name = line.substr(depth);\n\n        while (!hierarchy.empty() && hierarchy.back().first >= depth) {\n            hierarchy.pop_back();\n        }\n\n        if (!hierarchy.empty()) {\n            tree.addRelation(hierarchy.back().second, name);\n        }\n\n        hierarchy.push_back({depth, name});\n    }\n\n    return tree;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int datasets;\n    std::cin >> datasets;\n    std::cin.ignore();\n\n    for (int dataset = 0; dataset < datasets; dataset++) {\n        FamilyTree tree = parseFamilyTree(std::cin);\n\n        std::string statementLine;\n        while (std::getline(std::cin, statementLine) && !statementLine.empty()) {\n            std::istringstream iss(statementLine);\n            std::string person1, relation, person2;\n            iss >> person1 >> relation >> person2;\n\n            std::cout << (tree.checkRelation(person1, person2, relation) ? \"True\" : \"False\") << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:15:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class FamilyTree {\n    static class Person {\n        String name;\n        Person parent;\n        List<Person> children;\n\n        Person(String name) {\n            this.name = name;\n            this.children = new ArrayList<>();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null) {\n            if (line.isEmpty()) continue;\n            int n = Integer.parseInt(line);\n            if (n == 0) break;\n\n            Map<String, Person> people = new HashMap<>();\n            Person root = null;\n            Deque<Person> stack = new ArrayDeque<>();\n\n            for (int i = 0; i < n; i++) {\n                line = br.readLine();\n                int indent = line.indexOf(line.trim());\n                String name = line.trim();\n                Person person = new Person(name);\n                people.put(name, person);\n\n                if (indent == 0) {\n                    root = person;\n                    stack.clear();\n                    stack.push(person);\n                } else {\n                    while (stack.size() > indent) {\n                        stack.pop();\n                    }\n                    Person parent = stack.peek();\n                    parent.children.add(person);\n                    person.parent = parent;\n                    stack.push(person);\n                }\n            }\n\n            int m = Integer.parseInt(br.readLine());\n            for (int i = 0; i < m; i++) {\n                line = br.readLine();\n                String[] parts = line.split(\" \");\n                String name1 = parts[0];\n                String relation = parts[1];\n                String name2 = parts[2];\n\n                Person p1 = people.get(name1);\n                Person p2 = people.get(name2);\n\n                boolean result = false;\n                switch (relation) {\n                    case \"child\":\n                        result = p1.parent == p2;\n                        break;\n                    case \"parent\":\n                        result = p2.parent == p1;\n                        break;\n                    case \"sibling\":\n                        result = p1.parent != null && p2.parent != null && p1.parent == p2.parent;\n                        break;\n                    case \"ancestor\":\n                        result = isAncestor(p1, p2);\n                        break;\n                    case \"descendant\":\n                        result = isAncestor(p2, p1);\n                        break;\n                }\n                System.out.println(result ? \"True\" : \"False\");\n            }\n        }\n    }\n\n    private static boolean isAncestor(Person ancestor, Person descendant) {\n        Person current = descendant;\n        while (current != null) {\n            if (current == ancestor) {\n                return true;\n            }\n            current = current.parent;\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 19:16:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_family_tree(tree_lines):\n    family_tree = {}\n    stack = [(None, -1)]\n\n    for line in tree_lines:\n        indent_level = len(line) - len(line.lstrip(' '))\n        person = line.strip()\n\n        while stack[-1][1] >= indent_level:\n            stack.pop()\n\n        if stack[-1][0] is not None:\n            parent = stack[-1][0]\n            if parent not in family_tree:\n                family_tree[parent] = []\n            family_tree[parent].append(person)\n        else:\n            family_tree[person] = []\n\n        stack.append((person, indent_level))\n\n    return family_tree\n\ndef find_ancestors(family_tree, person):\n    ancestors = set()\n    for parent, children in family_tree.items():\n        if person in children:\n            ancestors.add(parent)\n            ancestors.update(find_ancestors(family_tree, parent))\n    return ancestors\n\ndef evaluate_statements(family_tree, statements):\n    results = []\n    for statement in statements:\n        relation, person_a, person_b = statement.split()\n        if relation == \"is_parent_of\":\n            result = person_b in family_tree.get(person_a, [])\n        elif relation == \"is_child_of\":\n            result = person_a in family_tree.get(person_b, [])\n        elif relation == \"is_ancestor_of\":\n            result = person_b in find_ancestors(family_tree, person_a)\n        elif relation == \"is_descendant_of\":\n            result = person_a in find_ancestors(family_tree, person_b)\n        else:\n            result = False\n        results.append(result)\n    return results\n\ndef process_dataset(dataset):\n    sections = ''.join(dataset).split('\\n\\n')\n    tree_lines = sections[0].strip().split('\\n')\n    statements = sections[1].strip().split('\\n')\n    \n    family_tree = parse_family_tree(tree_lines)\n    results = evaluate_statements(family_tree, statements)\n    return results\n\ndef main():\n    import sys\n    input_data = sys.stdin.read().strip()\n    datasets = input_data.strip().split('\\n\\n\\n')\n    \n    for dataset in datasets:\n        results = process_dataset(dataset.strip().split('\\n'))\n        for result in results:\n            print(\"True\" if result else \"False\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:04:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class FamilyTreeEvaluator {\n    private static class Node {\n        String name;\n        List<Node> children = new ArrayList<>();\n\n        Node(String name) {\n            this.name = name;\n        }\n    }\n\n    private static Map<String, Node> buildFamilyTree(BufferedReader reader) throws IOException {\n        Map<String, Node> nodes = new HashMap<>();\n        Stack<Tuple<Node, Integer>> stack = new Stack<>();\n\n        String line;\n        while ((line = reader.readLine()) != null && !line.isEmpty()) {\n            int indentation = 0;\n            while (indentation < line.length() && line.charAt(indentation) == ' ') {\n                indentation++;\n            }\n            String name = line.substring(indentation);\n            Node node = nodes.computeIfAbsent(name, Node::new);\n\n            while (!stack.isEmpty() && stack.peek().indent >= indentation) {\n                stack.pop();\n            }\n            if (!stack.isEmpty()) {\n                stack.peek().node.children.add(node);\n            }\n            stack.push(new Tuple<>(node, indentation));\n        }\n\n        return nodes;\n    }\n\n    private static boolean isDescendant(Node ancestor, String descendantName) {\n        if (ancestor.name.equals(descendantName)) {\n            return true;\n        }\n        for (Node child : ancestor.children) {\n            if (isDescendant(child, descendantName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean evaluateStatement(Map<String, Node> nodes, String statement) {\n        String[] parts = statement.split(\" \");\n        if (parts.length != 3 || !\"is\".equals(parts[1]) || !\"parent\".equals(parts[2])) {\n            return false;\n        }\n        String parentName = parts[0];\n        String childName = parts[2];\n\n        Node parent = nodes.get(parentName);\n        return parent != null && isDescendant(parent, childName);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String datasetLine;\n        while ((datasetLine = reader.readLine()) != null) {\n            if (datasetLine.trim().isEmpty()) continue;\n            if (datasetLine.equals(\"*\")) break;\n\n            Map<String, Node> nodes = buildFamilyTree(reader);\n\n            // Reading statements\n            String statement;\n            while ((statement = reader.readLine()) != null && !statement.trim().isEmpty()) {\n                System.out.println(evaluateStatement(nodes, statement) ? \"True\" : \"False\");\n            }\n        }\n    }\n\n    private static class Tuple<T, U> {\n        T node;\n        U indent;\n\n        Tuple(T node, U indent) {\n            this.node = node;\n            this.indent = indent;\n        }\n    }\n}",
    "timestamp": "2025-08-13 03:04:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NAME_LENGTH 100\n#define MAX_CHILDREN 100\n\ntypedef struct Person {\n    char name[MAX_NAME_LENGTH];\n    struct Person* parent;\n    struct Person* children[MAX_CHILDREN];\n    int child_count;\n} Person;\n\ntypedef struct {\n    Person* people[MAX_CHILDREN * 10];\n    int count;\n} FamilyTree;\n\nPerson* findOrCreatePerson(FamilyTree* family, char* name) {\n    for(int i = 0; i < family->count; i++) {\n        if(strcmp(family->people[i]->name, name) == 0) {\n            return family->people[i];\n        }\n    }\n    Person* new_person = (Person*)malloc(sizeof(Person));\n    strcpy(new_person->name, name);\n    new_person->parent = NULL;\n    new_person->child_count = 0;\n    family->people[family->count++] = new_person;\n    return new_person;\n}\n\nvoid addChild(Person* parent, Person* child) {\n    if(parent) {\n        parent->children[parent->child_count++] = child;\n        child->parent = parent;\n    }\n}\n\nint isAncestor(Person* ancestor, Person* descendent) {\n    while(descendent) {\n        if(descendent == ancestor) return 1;\n        descendent = descendent->parent;\n    }\n    return 0;\n}\n\nint processStatement(FamilyTree* family, char* ancestor_name, char* descendent_name) {\n    Person* ancestor = findOrCreatePerson(family, ancestor_name);\n    Person* descendent = findOrCreatePerson(family, descendent_name);\n    return isAncestor(ancestor, descendent);\n}\n\nvoid processFamilyTreeAndStatements(FILE* fp) {\n    FamilyTree family = {.count = 0};\n    char line[256];\n    char* last_indentation = NULL;\n    int last_indent_level = -1;\n    Person* last_person_at_level[256] = {NULL};\n\n    while(fgets(line, sizeof(line), fp)) {\n        if(line[0] == '#') break;  // Statements start\n\n        int indent_level = 0;\n        while(line[indent_level] == ' ') indent_level++;\n\n        char* name = line + indent_level;\n        name[strcspn(name, \"\\n\")] = 0; // Remove newline\n        Person* current_person = findOrCreatePerson(&family, name);\n\n        if(indent_level > 0) {\n            Person* parent = last_person_at_level[indent_level - 1];\n            addChild(parent, current_person);\n        }\n        last_person_at_level[indent_level] = current_person;\n        last_indent_level = indent_level;\n    }\n\n    while(fgets(line, sizeof(line), fp)) {\n        char ancestor_name[MAX_NAME_LENGTH], descendent_name[MAX_NAME_LENGTH];\n        sscanf(line, \"%s %*s %s\", ancestor_name, descendent_name);  // format: \"A isAncestor B\"\n        printf(\"%s\\n\", processStatement(&family, ancestor_name, descendent_name) ? \"True\" : \"False\");\n    }\n\n    for(int i = 0; i < family.count; i++) {\n        free(family.people[i]);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if(argc < 2) {\n        fprintf(stderr, \"Please provide an input file\\n\");\n        return 1;\n    }\n    FILE* fp = fopen(argv[1], \"r\");\n    if(!fp) {\n        fprintf(stderr, \"Failed to open file\\n\");\n        return 1;\n    }\n    processFamilyTreeAndStatements(fp);\n    fclose(fp);\n    return 0;\n}",
    "timestamp": "2025-08-13 03:05:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_family_tree(lines):\n    family_tree = {}\n    stack = []\n    \n    for line in lines:\n        depth = len(line) - len(line.lstrip())\n        name = line.strip()\n        \n        while stack and stack[-1][0] >= depth:\n            stack.pop()\n        \n        if stack:\n            parent = stack[-1][1]\n            if parent not in family_tree:\n                family_tree[parent] = []\n            family_tree[parent].append(name)\n        \n        stack.append((depth, name))\n        if name not in family_tree:\n            family_tree[name] = []\n    \n    return family_tree\n\ndef is_ancestor(family_tree, person1, person2):\n    if person1 not in family_tree or person2 not in family_tree:\n        return False\n    \n    def dfs(current, target):\n        if current == target:\n            return True\n        for child in family_tree.get(current, []):\n            if dfs(child, target):\n                return True\n        return False\n    \n    return dfs(person1, person2)\n\ndef solve_dataset(family_tree_lines, statements):\n    family_tree = parse_family_tree(family_tree_lines)\n    results = []\n    \n    for statement in statements:\n        relation, person1, person2 = statement.split()\n        \n        if relation == 'parent':\n            results.append(str(person2 in family_tree.get(person1, [])))\n        elif relation == 'ancestor':\n            results.append(str(is_ancestor(family_tree, person1, person2)))\n    \n    return results\n\ndef main():\n    num_datasets = int(input())\n    \n    for _ in range(num_datasets):\n        num_family_lines = int(input())\n        family_tree_lines = [input() for _ in range(num_family_lines)]\n        \n        num_statements = int(input())\n        statements = [input() for _ in range(num_statements)]\n        \n        results = solve_dataset(family_tree_lines, statements)\n        print('\\n'.join(results))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 03:05:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef process_tree(lines):\n    tree = {}\n    parent_stack = []\n    for line in lines:\n        indent = 0\n        while line.startswith(' '):\n            indent += 1\n            line = line[1:]\n        name = line.strip()\n        while len(parent_stack) > indent:\n            parent_stack.pop()\n        if parent_stack:\n            tree[name] = parent_stack[-1]\n        else:\n            tree[name] = None\n        parent_stack.append(name)\n    return tree\n\ndef is_ancestor(tree, a, b):\n    current = b\n    while current is not None:\n        if current == a:\n            return True\n        current = tree.get(current, None)\n    return False\n\ndef solve():\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        n, m = map(int, line.strip().split())\n        tree_lines = []\n        for _ in range(n):\n            tree_lines.append(sys.stdin.readline().rstrip('\\n'))\n        tree = process_tree(tree_lines)\n        for _ in range(m):\n            stmt = sys.stdin.readline().strip()\n            parts = stmt.split()\n            a = parts[0]\n            rel = parts[1]\n            b = parts[2]\n            if rel == 'child':\n                res = tree.get(a, None) == b\n            elif rel == 'parent':\n                res = tree.get(b, None) == a\n            elif rel == 'sibling':\n                res = tree.get(a, None) is not None and tree.get(a, None) == tree.get(b, None)\n            elif rel == 'ancestor':\n                res = is_ancestor(tree, a, b)\n            elif rel == 'descendant':\n                res = is_ancestor(tree, b, a)\n            else:\n                res = False\n            print('True' if res else 'False')\n\nif __name__ == '__main__':\n    solve()",
    "timestamp": "2025-08-13 03:05:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n// A Node representing a person in the family tree\nstruct Node {\n    string name;\n    vector<Node*> children;\n};\n\n// Parse the family tree from input\nNode* parseFamilyTree(istream& input) {\n    string line;\n    unordered_map<int, Node*> lastAtIndents;\n    Node* root = nullptr;\n    \n    while (getline(input, line)) {\n        // Find the current level of indentation\n        int indentLevel = 0;\n        while (indentLevel < line.size() && line[indentLevel] == ' ') {\n            indentLevel++;\n        }\n        \n        // Extract the name by trimming spaces\n        string name = line.substr(indentLevel);\n        \n        // Create a new node\n        Node* node = new Node{name, {}};\n        \n        if (indentLevel == 0) {\n            root = node;\n        } else {\n            Node* parent = lastAtIndents[indentLevel - 1];\n            parent->children.push_back(node);\n        }\n        \n        lastAtIndents[indentLevel] = node;\n        \n        // Remove nodes that are no longer part of the current path\n        auto it = lastAtIndents.find(indentLevel + 1);\n        while (it != lastAtIndents.end()) {\n            lastAtIndents.erase(it++);\n        }\n    }\n    \n    return root;\n}\n\n// Find a person in the family tree\nNode* findPerson(Node* root, const string& name) {\n    if (!root) return nullptr;\n    \n    stack<Node*> stk;\n    stk.push(root);\n    \n    while (!stk.empty()) {\n        Node* current = stk.top();\n        stk.pop();\n        \n        if (current->name == name) {\n            return current;\n        }\n        \n        for (Node* child : current->children) {\n            stk.push(child);\n        }\n    }\n    \n    return nullptr;\n}\n\n// Check relationship recursively\nbool isDescendant(Node* ancestor, const string& descendantName) {\n    if (!ancestor) return false;\n    for (Node* child : ancestor->children) {\n        if (child->name == descendantName || isDescendant(child, descendantName)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Evaluate statements\nvoid evaluateStatements(Node* root, istream& input) {\n    string line;\n    \n    while (getline(input, line)) {\n        // Statement format: \"person1 is an ancestor of person2\"\n        istringstream ss(line);\n        string person1, mid, relation, aux, person2;\n        ss >> person1 >> mid >> relation >> aux >> person2;\n        \n        Node* person1Node = findPerson(root, person1);\n        Node* person2Node = findPerson(root, person2);\n        \n        if (!person1Node || !person2Node) {\n            cout << \"False\" << endl;\n        } else if (relation == \"ancestor\") {\n            cout << (isDescendant(person1Node, person2) ? \"True\" : \"False\") << endl;\n        }\n    }\n}\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n    \n    for (int dataset = 0; dataset < numDatasets; ++dataset) {\n        int numLines;\n        cin >> numLines;\n        cin.ignore(); // Ignore the remaining newline\n        \n        // Parse family tree\n        istringstream familyTreeInput;\n        for (int i = 0; i < numLines; ++i) {\n            string line;\n            getline(cin, line);\n            familyTreeInput.str(familyTreeInput.str() + line + \"\\n\");\n        }\n        \n        Node* root = parseFamilyTree(familyTreeInput);\n        \n        // Parse and evaluate statements\n        int numStatements;\n        cin >> numStatements;\n        cin.ignore();\n        \n        for (int j = 0; j < numStatements; ++j) {\n            string statement;\n            getline(cin, statement);\n            \n            istringstream statementInput(statement);\n            evaluateStatements(root, statementInput);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:09:56"
  }
]