[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int x;\n    int y;\n    char direction;\n} Robot;\n\nvoid moveRobot(Robot *robot, int steps, char maze[10][10]) {\n    int dx = 0, dy = 0;\n    for (int i = 0; i < steps; ++i) {\n        switch (robot->direction) {\n            case 'N': dx = -1; dy = 0; break;\n            case 'S': dx = 1; dy = 0; break;\n            case 'E': dx = 0; dy = 1; break;\n            case 'W': dx = 0; dy = -1; break;\n        }\n        int newX = robot->x + dx;\n        int newY = robot->y + dy;\n        if (newX < 0 || newX >= 10 || newY < 0 || newY >= 10 || maze[newX][newY] == '#') {\n            switch (robot->direction) {\n                case 'N': robot->direction = 'E'; break;\n                case 'E': robot->direction = 'S'; break;\n                case 'S': robot->direction = 'W'; break;\n                case 'W': robot->direction = 'N'; break;\n            }\n        } else {\n            robot->x = newX;\n            robot->y = newY;\n        }\n    }\n}\n\nint main() {\n    Robot robot;\n    char maze[10][10];\n    int steps;\n\n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            scanf(\" %c\", &maze[i][j]);\n        }\n    }\n    scanf(\"%d %d %c\", &robot.x, &robot.y, &robot.direction);\n    scanf(\"%d\", &steps);\n\n    moveRobot(&robot, steps, maze);\n\n    printf(\"%d %d %c\\n\", robot.x, robot.y, robot.direction);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:24:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Position {\n    int x, y;\n    char dir;\n};\n\nPosition calculateFinalPosition(const vector<string>& maze, Position initial, int steps) {\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {-1, 0, 1, 0};\n    char directions[] = {'N', 'E', 'S', 'W'};\n    int dirIndex = 0;\n\n    for (int i = 0; i < 4; ++i) {\n        if (initial.dir == directions[i]) {\n            dirIndex = i;\n            break;\n        }\n    }\n\n    Position current = initial;\n    int n = maze.size();\n    int m = maze[0].size();\n\n    for (int step = 0; step < steps; ++step) {\n        int nx = current.x + dx[dirIndex];\n        int ny = current.y + dy[dirIndex];\n\n        if (nx >= 0 && nx < m && ny >= 0 && ny < n && maze[ny][nx] == ' ') {\n            current.x = nx;\n            current.y = ny;\n        } else {\n            dirIndex = (dirIndex + 1) % 4;\n            current.dir = directions[dirIndex];\n        }\n    }\n\n    return current;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    cin.ignore();\n\n    vector<string> maze(n);\n    for (int i = 0; i < n; ++i) {\n        getline(cin, maze[i]);\n    }\n\n    Position initial;\n    cin >> initial.y >> initial.x >> initial.dir;\n    int steps;\n    cin >> steps;\n\n    Position final = calculateFinalPosition(maze, initial, steps);\n    cout << final.y << \" \" << final.x << \" \" << final.dir << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:25:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RobotMaze {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n        char[][] maze = new char[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < cols; j++) {\n                maze[i][j] = line.charAt(j);\n            }\n        }\n        int startX = scanner.nextInt();\n        int startY = scanner.nextInt();\n        char startDir = scanner.next().charAt(0);\n        int steps = scanner.nextInt();\n        \n        int x = startX;\n        int y = startY;\n        char dir = startDir;\n        \n        for (int i = 0; i < steps; i++) {\n            int nextX = x;\n            int nextY = y;\n            switch (dir) {\n                case 'N': nextX--; break;\n                case 'S': nextX++; break;\n                case 'E': nextY++; break;\n                case 'W': nextY--; break;\n            }\n            \n            if (nextX < 0 || nextX >= rows || nextY < 0 || nextY >= cols || maze[nextX][nextY] == '#') {\n                switch (dir) {\n                    case 'N': dir = 'E'; break;\n                    case 'E': dir = 'S'; break;\n                    case 'S': dir = 'W'; break;\n                    case 'W': dir = 'N'; break;\n                }\n            } else {\n                x = nextX;\n                y = nextY;\n            }\n        }\n        \n        System.out.println(x + \" \" + y + \" \" + dir);\n    }\n}",
    "timestamp": "2025-08-05 21:25:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "public class RobotMaze {\n    public static int[] moveRobot(int[][] maze, int startRow, int startCol, char startDirection, int steps) {\n        int rows = maze.length;\n        int cols = maze[0].length;\n        int[] dx = {-1, 0, 1, 0};\n        int[] dy = {0, 1, 0, -1};\n        int directionIndex = getDirectionIndex(startDirection);\n\n        int currentRow = startRow;\n        int currentCol = startCol;\n\n        for (int i = 0; i < steps; i++) {\n            int newRow = currentRow + dx[directionIndex];\n            int newCol = currentCol + dy[directionIndex];\n\n            if (newRow < 0 || newRow >= rows || newCol < 0 || newCol >= cols || maze[newRow][newCol] == 1) {\n                directionIndex = (directionIndex + 1) % 4;\n            } else {\n                currentRow = newRow;\n                currentCol = newCol;\n            }\n        }\n\n        return new int[]{currentRow, currentCol, getDirectionChar(directionIndex)};\n    }\n\n    private static int getDirectionIndex(char direction) {\n        switch (direction) {\n            case 'N': return 0;\n            case 'E': return 1;\n            case 'S': return 2;\n            case 'W': return 3;\n            default: return 0;\n        }\n    }\n\n    private static char getDirectionChar(int directionIndex) {\n        char[] directions = {'N', 'E', 'S', 'W'};\n        return directions[directionIndex];\n    }\n}",
    "timestamp": "2025-08-05 21:25:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n\ntypedef enum {\n    NORTH,\n    EAST,\n    SOUTH,\n    WEST\n} Direction;\n\nint move_robot(char maze[MAX_ROWS][MAX_COLS], int rows, int cols, int start_row, int start_col, Direction start_dir, int steps) {\n    int current_row = start_row;\n    int current_col = start_col;\n    Direction current_dir = start_dir;\n\n    for (int i = 0; i < steps; i++) {\n        int next_row = current_row;\n        int next_col = current_col;\n\n        switch (current_dir) {\n            case NORTH: next_row--; break;\n            case EAST:  next_col++; break;\n            case SOUTH: next_row++; break;\n            case WEST:  next_col--; break;\n        }\n\n        if (next_row < 0 || next_row >= rows || next_col < 0 || next_col >= cols || maze[next_row][next_col] == '#') {\n            current_dir = (current_dir + 1) % 4;\n        } else {\n            current_row = next_row;\n            current_col = next_col;\n        }\n    }\n\n    printf(\"Final position: (%d, %d)\\n\", current_row, current_col);\n    printf(\"Final direction: %d\\n\", current_dir);\n\n    return 0;\n}\n\nint main() {\n    char maze[MAX_ROWS][MAX_COLS] = {\n        {'.','.','.','.'},\n        {'.','.','#','.'},\n        {'.','.','.','.'}\n    };\n    int rows = 3;\n    int cols = 4;\n    int start_row = 1;\n    int start_col = 1;\n    Direction start_dir = NORTH;\n    int steps = 3;\n\n    move_robot(maze, rows, cols, start_row, start_col, start_dir, steps);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:25:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nclass Robot {\nprivate:\n    int x, y;\n    int dx, dy;\n    std::vector<std::vector<char>> maze;\n\n    void rotate() {\n        if (dx == 1 && dy == 0) { dx = 0; dy = -1; }\n        else if (dx == 0 && dy == -1) { dx = -1; dy = 0; }\n        else if (dx == -1 && dy == 0) { dx = 0; dy = 1; }\n        else if (dx == 0 && dy == 1) { dx = 1; dy = 0; }\n    }\n\n    bool isValidMove(int newX, int newY) {\n        return newX >= 0 && newX < maze[0].size() && \n               newY >= 0 && newY < maze.size() && \n               maze[newY][newX] == '.';\n    }\n\npublic:\n    Robot(std::vector<std::vector<char>>& maze, int startX, int startY) \n        : x(startX), y(startY), dx(1), dy(0), maze(maze) {}\n\n    void move(int steps) {\n        for (int i = 0; i < steps; ++i) {\n            int newX = x + dx;\n            int newY = y + dy;\n\n            if (!isValidMove(newX, newY)) {\n                rotate();\n                newX = x + dx;\n                newY = y + dy;\n            }\n\n            x = newX;\n            y = newY;\n        }\n    }\n\n    std::pair<int, int> getPosition() {\n        return {x, y};\n    }\n\n    std::pair<int, int> getDirection() {\n        return {dx, dy};\n    }\n};\n\nint main() {\n    std::vector<std::vector<char>> maze = {\n        {'.', '.', '.', '.', '.'},\n        {'.', '#', '#', '#', '.'},\n        {'.', '.', '.', '.', '.'}\n    };\n\n    Robot robot(maze, 0, 0);\n    robot.move(7);\n\n    auto [finalX, finalY] = robot.getPosition();\n    std::cout << \"Final Position: (\" << finalX << \", \" << finalY << \")\" << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:25:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def final_position_and_direction(n, m, x, y, direction, steps, maze):\n    # Define movement vectors for N, E, S, W\n    dx = [0, 1, 0, -1]\n    dy = [-1, 0, 1, 0]\n    \n    # Directions: 0 = N, 1 = E, 2 = S, 3 = W\n    directions = {'N': 0, 'E': 1, 'S': 2, 'W': 3}\n    reverse_directions = {0: 'N', 1: 'E', 2: 'S', 3: 'W'}\n    \n    # Current direction\n    d = directions[direction]\n    \n    for _ in range(steps):\n        new_x = x + dx[d]\n        new_y = y + dy[d]\n        \n        # Check boundaries and walls\n        if 0 <= new_x < n and 0 <= new_y < m and maze[new_y][new_x] == 0:\n            x, y = new_x, new_y\n        else:\n            # Rotate 90 degrees to the right\n            d = (d + 1) % 4\n    \n    # Return the final position and direction\n    return x, y, reverse_directions[d]\n\n# Example usage:\n# Define the maze\n# 0 - empty space, 1 - wall\nmaze = [\n    [0, 0, 0, 1],\n    [0, 1, 0, 0],\n    [0, 0, 0, 0],\n    [1, 0, 0, 0]\n]\n\n# Parameters: n, m, initial_x, initial_y, initial_direction, steps, maze\nprint(final_position_and_direction(4, 4, 0, 0, 'E', 10, maze))",
    "timestamp": "2025-08-13 06:23:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class RobotMaze {\n    private static final char EMPTY = '.';\n    private static final char WALL = '#';\n\n    public static int[] findFinalPosition(char[][] maze, int startX, int startY, int steps, char startDirection) {\n        int m = maze.length;\n        int n = maze[0].length;\n        int xPos = startX;\n        int yPos = startY;\n        int direction = getDirectionIndex(startDirection);\n\n        // Directions: 0 - North, 1 - East, 2 - South, 3 - West\n        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\n        for (int i = 0; i < steps; i++) {\n            int nextX = xPos + directions[direction][0];\n            int nextY = yPos + directions[direction][1];\n\n            if (isValidMove(maze, nextX, nextY)) {\n                xPos = nextX;\n                yPos = nextY;\n            } else {\n                direction = (direction + 1) % 4;\n            }\n        }\n\n        return new int[]{xPos, yPos, directionToChar(direction)};\n    }\n\n    private static boolean isValidMove(char[][] maze, int x, int y) {\n        return x >= 0 && x < maze.length && y >= 0 && y < maze[0].length && maze[x][y] == EMPTY;\n    }\n\n    private static int getDirectionIndex(char direction) {\n        switch (direction) {\n            case 'N': return 0;\n            case 'E': return 1;\n            case 'S': return 2;\n            case 'W': return 3;\n            default: throw new IllegalArgumentException(\"Invalid direction\");\n        }\n    }\n\n    private static char directionToChar(int direction) {\n        switch (direction) {\n            case 0: return 'N';\n            case 1: return 'E';\n            case 2: return 'S';\n            case 3: return 'W';\n            default: throw new IllegalArgumentException(\"Invalid direction index\");\n        }\n    }\n\n    public static void main(String[] args) {\n        char[][] maze = {\n            {'.', '.', '.', '#'},\n            {'.', '#', '.', '.'},\n            {'.', '.', '.', '.'},\n            {'#', '.', '#', '.'}\n        };\n        int startX = 0;\n        int startY = 0;\n        int steps = 10;\n        char startDirection = 'E';\n\n        int[] result = findFinalPosition(maze, startX, startY, steps, startDirection);\n        System.out.printf(\"Final Position: (%d, %d) Facing: %c\\n\", result[0], result[1], (char) result[2]);\n    }\n}",
    "timestamp": "2025-08-13 06:23:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define EMPTY '.'\n#define WALL '#'\n\n// Directions: 0 = North, 1 = East, 2 = South, 3 = West\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\n// Forward declarations\nvoid moveRobot(char **maze, int rows, int cols, int *x, int *y, int *direction, int steps);\n\nint main() {\n    int rows = 5;  // Example of maze size\n    int cols = 5;\n    char *maze[] = {\n        \"#####\",\n        \"#...#\",\n        \"#.#.#\",\n        \"#...#\",\n        \"#####\"\n    };\n    \n    int x = 2;  // Initial row position\n    int y = 2;  // Initial column position\n    int direction = 0;  // Initial direction, 0 means North\n    int steps = 7;  // Number of steps to move\n\n    moveRobot(maze, rows, cols, &x, &y, &direction, steps);\n\n    printf(\"Final Position: (%d, %d)\\n\", x, y);\n    printf(\"Final Direction: %d\\n\", direction);\n\n    return 0;\n}\n\nvoid moveRobot(char **maze, int rows, int cols, int *x, int *y, int *direction, int steps) {\n    for (int i = 0; i < steps; ++i) {\n        int nx = *x + dx[*direction];\n        int ny = *y + dy[*direction];\n\n        if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && maze[nx][ny] == EMPTY) {\n            *x = nx;\n            *y = ny;\n        } else {\n            *direction = (*direction + 1) % 4;\n        }\n    }\n}",
    "timestamp": "2025-08-13 06:23:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def robot_navigation(maze, start_row, start_col, start_direction, steps):\n    # Directions: 0 = North, 1 = East, 2 = South, 3 = West\n    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    rows, cols = len(maze), len(maze[0])\n    current_row, current_col = start_row, start_col\n    current_direction = start_direction\n\n    for _ in range(steps):\n        dx, dy = directions[current_direction]\n        next_row, next_col = current_row + dx, current_col + dy\n\n        # Check if next move is out of bounds or blocked by wall\n        if (next_row < 0 or next_row >= rows or \n            next_col < 0 or next_col >= cols or \n            maze[next_row][next_col] == '#'):\n            current_direction = (current_direction + 1) % 4\n        else:\n            current_row, current_col = next_row, next_col\n\n    return current_row, current_col, current_direction",
    "timestamp": "2025-08-13 06:24:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def robot_maze(initial_position, initial_direction, steps, maze):\n    x, y = initial_position\n    direction = initial_direction\n    directions = ['N', 'E', 'S', 'W']  # Clockwise order\n    \n    for _ in range(steps):\n        # Determine next position based on current direction\n        next_x, next_y = x, y\n        if direction == 'N':\n            next_y -= 1\n        elif direction == 'E':\n            next_x += 1\n        elif direction == 'S':\n            next_y += 1\n        elif direction == 'W':\n            next_x -= 1\n        \n        # Check if next position is valid\n        if 0 <= next_x < len(maze[0]) and 0 <= next_y < len(maze) and maze[next_y][next_x] == 0:\n            x, y = next_x, next_y\n        else:\n            # Rotate 90 degrees right\n            current_idx = directions.index(direction)\n            direction = directions[(current_idx + 1) % 4]\n    \n    return (x, y), direction",
    "timestamp": "2025-08-13 06:24:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nenum Direction { NORTH = 0, EAST = 1, SOUTH = 2, WEST = 3 };\n\n// Function to rotate the robot 90 degrees to the right\nDirection rotateRight(Direction dir) {\n    return static_cast<Direction>((dir + 1) % 4);\n}\n\n// Function to attempt to move the robot forward\nbool moveForward(vector<vector<char>>& maze, int& x, int& y, Direction dir) {\n    int newX = x, newY = y;\n    switch(dir) {\n        case NORTH: newX = x - 1; break;\n        case EAST: newY = y + 1; break;\n        case SOUTH: newX = x + 1; break;\n        case WEST: newY = y - 1; break;\n    }\n    if (newX >= 0 && newX < maze.size() && newY >= 0 && newY < maze[0].size() && maze[newX][newY] == ' ') {\n        x = newX;\n        y = newY;\n        return true;\n    }\n    return false;\n}\n\n// Function to calculate the final position and direction of the robot\nvoid navigateRobot(vector<vector<char>>& maze, int startX, int startY, Direction startDir, int steps) {\n    int x = startX, y = startY;\n    Direction dir = startDir;\n    \n    for (int i = 0; i < steps; ++i) {\n        if (!moveForward(maze, x, y, dir)) {\n            dir = rotateRight(dir);\n        }\n    }\n    \n    cout << \"Final Position: (\" << x << \", \" << y << \")\" << endl;\n    cout << \"Final Direction: \";\n    \n    switch(dir) {\n        case NORTH: cout << \"North\"; break;\n        case EAST: cout << \"East\"; break;\n        case SOUTH: cout << \"South\"; break;\n        case WEST: cout << \"West\"; break;\n    }\n    cout << endl;\n}\n\nint main() {\n    vector<vector<char>> maze = {\n        {' ', ' ', ' ', 'X'},\n        {' ', 'X', ' ', 'X'},\n        {' ', ' ', ' ', ' '},\n        {'X', ' ', 'X', ' '}\n    };\n    int startX = 0, startY = 0;\n    Direction startDir = NORTH;\n    int steps = 10;\n    \n    navigateRobot(maze, startX, startY, startDir, steps);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:31:50"
  }
]