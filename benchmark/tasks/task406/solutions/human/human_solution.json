[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[100][100];\nint visited[100][100][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nint main()\n{\n  int H,W,L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      int phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {\n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }\t  \n\n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint cost[128][128][4];\nint field[128][128];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nchar NEWS[4]={'N','E','S','W'};\nint main(void)\n{\n  for(;;){\n    LL h,w,l;\n    cin >> h >> w >> l;\n    if(!h&&!w&&!l) return 0;\n    REP(i,h+2) REP(j,w+2) REP(k,4) cost[i][j][k]=0;\n    REP(i,h+2) REP(j,w+2) field[i][j]=0;\n    int robox,roboy,robodi;\n    REP(i,h){\n      string tmp;\n      cin >> tmp;\n      REP(j,tmp.size()) if(tmp[j]!='#') field[i+1][j+1]=1;\n      REP(j,tmp.size()) if(tmp[j]!='#' && tmp[j]!='.') {\n\troboy=i+1;\n\trobox=j+1;\n\tif(tmp[j]=='N') robodi=0;\n\tif(tmp[j]=='E') robodi=1;\n\tif(tmp[j]=='W') robodi=3;\n\tif(tmp[j]=='S') robodi=2;\n      }\n    }\n    for(LL c=0;;++c){\n      if(cost[roboy][robox][robodi]) l=(l-c)%(c-cost[roboy][robox][robodi])+c;\n      else cost[roboy][robox][robodi]=c;\n      if(c==l) break;\n      while(!field[roboy+dy[robodi]][robox+dx[robodi]]) robodi=(robodi+1)%4;\n      robox+=dx[robodi];\n      roboy+=dy[robodi];\n    }\n    cout << roboy << ' ' << robox << ' ' << NEWS[robodi] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n\ntypedef long long ll;\n\nint H, W;\nll L;\nchar c[128][128];\nint dist[4][128][128]; // N E S W\nint dy[]={-1,0,1,0}, dx[]={0,1,0,-1};\n\nint convert(char ch){ return ch=='N'?0:ch=='E'?1:ch=='S'?2:3; }\nchar reconvert(int n){ return n==0?'N':n==1?'E':n==2?'S':'W'; }\n\nvoid solve(int sy, int sx, int sd){\n  int y=sy,x=sx,dir=sd;\n  dist[dir][y][x] = 0;\n  for(int step=1;;step++){\n    int nd = dir;\n    int ny = y+dy[nd], nx = x+dx[nd];\n    while(ny<0||ny>=H||nx<0||nx>=W||c[ny][nx]=='#'){\n      nd = (nd+1)%4;\n      ny = y+dy[nd], nx = x+dx[nd];\n    }\n\n    if(dist[nd][ny][nx]!=-1){\n      ll l = L-dist[nd][ny][nx];\n      l %= (dist[dir][y][x] - dist[nd][ny][nx] + 1);\n      rep(i,4) rep(j,128) rep(k,128){\n\tif(dist[i][j][k] != l + dist[nd][ny][nx]) continue;\n\tprintf(\"%d %d %c\\n\", j+1, k+1, reconvert(i));\n\treturn;\n      }\n    }\n    y = ny, x = nx, dir = nd;\n    dist[dir][y][x] = step;\n    if(step==L){\n      printf(\"%d %d %c\\n\", y+1, x+1, reconvert(dir));\n      return;\n    }    \n  }\n}\n\nint main(){\n  while(scanf(\"%d%d%lld\", &H,&W, &L) && H+W+L){\n    int sy, sx, sd;\n    memset(dist, -1, sizeof(dist));\n    rep(i,H){\n      scanf(\"%s\", c[i]);\n      rep(j,W){\n\tif(c[i][j]=='#'||c[i][j]=='.') continue;\n\tsy = i, sx = j,\tsd = convert(c[i][j]);\n\tc[i][j] = '.';\n      }\n    }\n    solve(sy, sx, sd);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) lps(i,0,n)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define FDST int hogehogehoge;cin>>hogehogehoge\n#define MAX_V 110\n#define   int long long\n\nint H, W, L;\nstring str[MAX_V];\nchar foo(char temp){\n   if(temp == 'S'){\n     temp = 'W';\n   } else if(temp == 'N'){\n     temp = 'E';\n   } else if(temp == 'E'){\n     temp = 'S';\n   } else if(temp == 'W'){\n     temp = 'N';\n   }\n   return temp;\n}\n\nsigned  main(){\n  while(true){\n    int xy[2];\n    int dp[MAX_V][MAX_V][30] = {}, used[MAX_V][MAX_V] = {};\n    char temp;\n    cin>>H>>W>>L;\n\n    if(!H&&!W&&!L) break;\n    \n    for(int i = 0; i < H; i++){\n      cin>>str[i];\n      for(int j = 0; j < W; j++){\n\tif(str[i][j] != '.' && str[i][j] != '#'){\n\t  xy[0] = i; xy[1] = j;\n\t  temp = str[i][j];\n\t}\n      }\n    }\n\n    for(int i = 1; i <= L;){\n      int x = xy[1], y = xy[0];\n      // char tt  = temp;\n      //int xx= x, yy = y;\n      //cout<<i<<\" \"<<x<<\" \"<<y<<\" \"<<temp<<endl;\n      if(temp == 'S'){\n\ty++;\n      } else if(temp == 'N'){\n\ty--;\n      } else if(temp == 'E'){\n\tx++;\n      } else if(temp == 'W'){\n\tx--;\n      }\n      if(0 <= y && y < H && 0 <= x && x < W){\n\tif(str[y][x] == '#'){\n\t  temp = foo(temp);\n\t  dp[y][x][temp-'A'] = i;\n\t} else {\n\t  if(dp[y][x][temp-'A']){\n\t    if((L-i)/(i-dp[y][x][temp-'A'])){\n\t      i = L-(L-i)%(i-dp[y][x][temp-'A']);\n\t    } else {\n\t      xy[0] = y, xy[1] = x;\n\t      i++;\n\t    }\n\t  } else {\n\t    xy[0] = y, xy[1] = x;\n\t    dp[y][x][temp-'A'] = i;\n\t    i++;\n\t  }\n\t}\n\t\n      } else {\n\ttemp = foo(temp);\n\tdp[y][x][temp-'A'] = i;\n      }\n    }\n    cout<<xy[0]+1<<\" \"<<xy[1]+1<<\" \"<<temp<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Stat{ int x,y,dir,t; };\n\nint main(){\n\tchar DIR[]=\"ENWS\";\n\tint DIRR[128]; rep(k,4) DIRR[DIR[k]]=k;\n\n\tint h,w;\n\tfor(ll l;scanf(\"%d%d%lld\",&h,&w,&l),h;){\n\t\tstatic char B[100][101];\n\t\tint x,y,dir;\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",B[i]);\n\t\t\trep(j,w) if(isalpha(B[i][j])) x=j, y=i, dir=DIRR[B[i][j]];\n\t\t}\n\n\t\tint T[100][100][4];\n\t\trep(i,h) rep(j,w) rep(k,4) T[i][j][k]=-1;\n\n\t\tll t=0;\n\t\twhile(l>0){\n\t\t\tif(~T[y][x][dir]){\n\t\t\t\tll dif=t-T[y][x][dir];\n\t\t\t\tt+=(l-1)/dif*dif;\n\t\t\t\tl-=(l-1)/dif*dif;\n\t\t\t}\n\t\t\tT[y][x][dir]=t;\n\n\t\t\tint xx=x+dx[dir],yy=y+dy[dir];\n\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && B[yy][xx]!='#'){\n\t\t\t\tt++;\n\t\t\t\tl--;\n\t\t\t\tx=xx;\n\t\t\t\ty=yy;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir=(dir+3)%4;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d %c\\n\",y+1,x+1,DIR[dir]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a*b/gcd(a,b);\n}\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nstring t = \"ESWN\";\nsigned main(void) {\n    int i,j;\n    int h,w,l;\n    while(cin >> h >> w >> l, h){\n        vs s(h);\n        rep(i,h)cin >> s[i];\n        vector<vi> dp(70,vi(100*100*10,-1));\n        int sx,sy,d;\n        rep(i,h)rep(j,w)rep(k,4){\n            rep(p,4)if(s[i][j] == t[p]){\n                sx = i;\n                sy = j;\n                d = p;\n            }\n            rep(p,4){\n                int x = i + dx[(k+p)%4];\n                int y = j + dy[(k+p)%4];\n                if(x < 0 || x >= h || y < 0 || y >= w)continue;\n                if(s[x][y] == '#')continue;\n                dp[0][(i*100+j)*10 + k] = (x*100+y)*10 + (k+p)%4;\n                break;\n            }\n        }\n        rep(j,log2(l))rep(i,100*100*10)if(dp[j][i] >= 0){\n            dp[j+1][i] = dp[j][dp[j][i]];\n        }\n        int ans = sx*1000 + sy*10 + d;\n        rep(i,log2(l)+1){\n            if((l>>i & 1)){\n                ans = dp[i][ans];\n            }\n        }\n        int x = ans/1000;\n        ans %= 1000;\n        int y = ans/10;\n        int z = ans % 10;\n        cout << x+1 << \" \" << y+1 << \" \" << t[z] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        int count = 0;\n        string wall = \"\";\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n            }\n        }\n\n        int sx, sy;\n        sx = x;\n        sy = y;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n                if (x == sx && y == sy) {\n                    l %= count;\n                }\n            }\n            else\n                dir = (dir+1) % 4;\n        }\n        cout << x << \" \" << y << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint dist[110][110][4];\nchar v[110][110];\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { -1, 0, 1, 0 };\n\nint main(){\n\tll n, m, L;\n\twhile (cin >> n >> m >> L, n){\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1) cin >> v[i][j];\n\t\tint r, c, d;\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1){\n\t\t\tif (v[i][j] != '.' && v[i][j] != '#'){\n\t\t\t\trep(dir, 4) if (v[i][j] == \"NESW\"[dir]) tie(r, c, d) = MT(i, j, dir);\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\n\t\tMEMSET(dist, -1);\n\t\tint x = 0;\n\t\tdist[r][c][d] = x++;\n\t\tbool loop = true;\n\t\twhile (L){\n\t\t\tr += dy[d], c += dx[d];\n\t\t\twhile (v[r + dy[d]][c + dx[d]] != '.') d = (d + 1) % 4;\n\t\t\tdist[r][c][d] = x++, L--;\n\t\t\tif (loop && dist[r][c][d] >= 0) L %= (x - dist[r][c][d]), loop = false;\n\t\t}\n\t\tcout << r << ' ' << c << ' ' << \"NESW\"[d] << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w, l, y, x, d, c;\nchar data[100][100];\nint vis[100][100][4];\nchar fd[100][100];\nstring dir = \"NESW\";\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return data[y][x] != '#';\n}\n\nvoid solve(){\n  int m, o;\n  bool f;\n  fill(vis[0][0], vis[100][0], -1);\n  for(;;){\n    if(vis[y][x][d] != -1){\n      if(vis[y][x][d]){\n        if(f){\n          o = vis[y][x][d] - 1;\n          m = c - vis[y][x][d];\n        }else{\n          o = vis[y][x][d] - 1;\n          m = c - vis[y][x][d] - 1;\n        }\n      }else{\n        if(f){\n          o = 0;\n          m = c;\n        }else{\n          o = 0;\n          m = c;\n        }\n      }\n      break;\n    }\n    //cout << y+1 << ' ' << x+1 << ' ' << dir[d] << ' ' << c << endl;\n    vis[y][x][d] = c;\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    if(!check(ny, nx)){\n      d = (d+1) % 4;\n      f = false;\n    }\n    else{\n      y = ny;\n      x = nx;\n      c++;\n      if(l == c){\n        cout << y+1 << ' ' << x+1 << ' ' << dir[d] << endl;\n        return;\n      }\n      f = true;\n    }\n  }\n  while(1){\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    if(check(ny, nx)){\n      y = ny;\n      x = nx;\n      break;\n    }else{\n      d = (d+1) % 4;\n    }\n  }\n  fill(fd[0], fd[100], ' ');\n  bool visited[100][100][4];\n  fill(visited[0][0], visited[100][0], false);\n  for(;;){\n    //cout << y << ' ' << x << ' ' << d << endl;\n    if(visited[y][x][d]) break;\n    visited[y][x][d] = true;\n    if(fd[y][x] == ' ') fd[y][x] = dir[d];\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    if(!check(ny, nx)) d = (d+1) % 4;\n    else{\n      y = ny;\n      x = nx;\n      c++;\n    }\n  }\n  int t = l % m + o;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<4;k++){\n        if(vis[i][j][k] == t){\n          cout << i+1 << ' ' << j+1 << ' ' << fd[i][j] << endl;\n          return;\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> h >> w >> l && (h|w|l)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        for(int k=0;k<4;k++){\n          if(data[i][j] == dir[k]){\n            data[i][j] = '.';\n            y = i;\n            x = j;\n            d = k;\n            c = 0;\n          }\n        }\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\n#define REP(i, x, y) for(ll i = x; i < y; i++)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nll bo[110][110][4];\n\nint main() {\n    while (1) {\n        ll H, W, L;\n        cin >> H >> W >> L;\n        if (H == 0) {\n            break;\n        }\n        REP(i, 0, 110) {\n            REP(j, 0, 110) {\n                fill(bo[i][j], bo[i][j] + 4, -2);\n            }\n        }\n        ll dir, x, y;\n        REP(i, 1, H + 1) {\n            string s;\n            cin >> s;\n            REP(j, 1, W + 1) {\n                char c = s[j - 1];\n                if (c == '.') {\n                    REP(k, 0, 4) {\n                        bo[i][j][k] = -1;\n                    }\n                } else if (c == 'E' || c == 'S' || c == 'W' || c == 'N') {\n                    REP(k, 0, 4) {\n                        bo[i][j][k] = -1;\n                    }\n                    if (c == 'E') {\n                        dir = 1;\n                        bo[i][j][1] = 0;\n                    } else if (c == 'S') {\n                        dir = 0;\n                        bo[i][j][0] = 0;\n                    } else if (c == 'W') {\n                        dir = 3;\n                        bo[i][j][3] = 0;\n                    } else if (c == 'N') {\n                        dir = 2;\n                        bo[i][j][2] = 0;\n                    }\n                    x = i;\n                    y = j;\n                }\n            }\n        }\n        ll ord = 0;\n        ll num;\n        ll pre;\n        while (1) {\n            ll xx = x + dx[dir];\n            ll yy = y + dy[dir];\n            ll bonum = bo[xx][yy][dir];\n            if (bonum >= 0) {\n                ll loop = ord + 1 - bonum;\n                ll rem = (L - bonum) % loop;\n                num = bonum + rem;\n                if (rem == 0) {\n                    pre = bonum + loop - 1;\n                } else {\n                    pre = num - 1;\n                }\n                break;\n            } else if (bonum == -1) {\n                ord++;\n                x = xx;\n                y = yy;\n                bo[xx][yy][dir] = ord;\n                if (ord == L) {\n                    num = L;\n                    pre = L - 1;\n                    break;\n                }\n            } else {\n                dir = (dir + 3) % 4;\n                bo[x][y][dir] = ord;\n            }\n        }\n        // REP(i, 0, H + 2) {\n        //     REP(j, 0, W + 2) {\n        //         REP(k, 0, 4) {\n        //             cout << bo[i][j][k] << \" \";\n        //         }\n        //         cout << \"aaa \";\n        //     }\n        //     cout << endl;\n        // }\n        ll ansx, ansy;\n        ll prex, prey;\n        char ansdir;\n        REP(i, 1, H + 1) {\n            REP(j, 1, W + 1) {\n                REP(k, 0, 4) {\n                    if (bo[i][j][k] == num) {\n                        ansx = i;\n                        ansy = j;\n                    } else if (bo[i][j][k] == pre) {\n                        prex = i;\n                        prey = j;\n                    }\n                }\n            }\n        }\n        if (ansx == prex) {\n            if (ansy > prey) {\n                ansdir = 'E';\n            } else {\n                ansdir = 'W';\n            }\n        } else {\n            if (ansx > prex) {\n                ansdir = 'S';\n            } else {\n                ansdir = 'N';\n            }\n        }\n        cout << ansx << \" \" << ansy << \" \" << ansdir << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint H,W;\nll int L;\nchar grid[150][150];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};//N,E,S,W\nll int memo[150][150][4];\nint dir,px,py;\n\nint rotate(int a){\n\treturn (a+1)%4;\n}\nbool inrange(int x,int y){\n\treturn (x>-1&&y>-1&&x<H&&y<W);\n}\nint main(){\n\twhile(1){\n\t\tREP(i,150) REP(j,150) REP(k,4) memo[i][j][k] = -1;\n\t\tcin >> H >> W >> L;\n\t\tif(H==0&&W==0&&L==0) break;\n\t\tREP(i,H){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tREP(j,str.size()){\n\t\t\t\tgrid[i][j] = str[j];\n\t\t\t\tif(grid[i][j]=='N'){dir = 0; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='E'){dir = 1; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='S'){dir = 2; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='W'){dir = 3; px = i; py = j; grid[i][j] = '.';}\n\t\t\t}\n\t\t}\n\t\tll int step = 0;\n\t\tmemo[px][py][dir] = 0;\n\t\twhile(1){\n\t\t\tif(step == L) goto End;\n\t\t\tint nx = px + dx[dir]; int ny = py + dy[dir];\n\t\t\tif(grid[nx][ny]=='.'){\n\t\t\t\tpx = nx; py = ny;\n\t\t\t\tif(memo[px][py][dir]!=-1){\n\t\t\t\t\t//a,b,c\n\t\t\t\t\tll int a = step-memo[px][py][dir];\n\t\t\t\t\tll int b = L-step;\n\t\t\t\t\tstep += a*(b/a);\n\t\t\t\t\tif(step == L) goto End;\n\t\t\t\t}else{\n\t\t\t\t\tmemo[px][py][dir] = step;\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tif(!inrange(nx,ny)||grid[nx][ny]=='#'){\n\t\t\t\tdir = rotate(dir);\n\t\t\t}\n\t\t\t\n\t\t}\nEnd:\n\t\tstring ans = \"NESW\";\n\t\tcout << px+1 << \" \" << py+1 << \" \" <<  ans[dir] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef long long ll;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint dis[100][100][4];\n\nstruct P {\n  int y,x,d;\n};\nP p[100*100*4];\n\nint main() {\n  int h,w;\n  ll l;\n  char dir[4] = {'N','E','S','W'};\n  \n  while(cin>>h>>w>>l, h||w||l) {\n    char ba[h][w];\n    int x, y, d;\n    REP(i,h) {\n      REP(j,w) {\n        cin >> ba[i][j];\n        if (ba[i][j] != '.' && ba[i][j] != '#') {\n          y = i;\n          x = j;\n          char c = ba[i][j];\n          if (c=='N') d = 0;\n          else if (c=='E') d = 1;\n          else if (c=='S') d = 2;\n          else if (c=='W') d = 3;\n        }\n      }\n    }\n    memset(dis, 0, sizeof(dis));\n    memset(p, 0, sizeof(p));\n    int cnt = 0;\n    P ans;\n    bool f = 0;\n    while(1) {\n      // if (f)\n      //   printf(\"%d %d,%d %d\\n\",cnt, x,y,d);\n      if (cnt == l) {\n        ans = (P){y,x,d};\n        break;\n      }\n      if (f&&dis[y][x][d]) {\n        ll hoge = cnt - dis[y][x][d];\n        l -= dis[y][x][d];\n        //cout << l << endl;\n        l %= hoge;\n        //cout << l << \" \" << hoge << \" \" << l + dis[y][x][d] <<endl;\n        ans = p[l + dis[y][x][d]];\n        break;\n      }\n      if (f) {\n        p[cnt] = (P){y,x,d};\n        dis[y][x][d] = cnt;\n      }\n      f = 0;\n      \n      int yy = y+dy[d];\n      int xx = x+dx[d];\n      if (yy<0||yy>=h||xx<0||xx>=w||ba[yy][xx]=='#') {\n        d = (d+1)%4;\n      } else {\n        x = xx;\n        y = yy;\n        cnt++;\n        f = 1;\n      }\n    }\n    // if (ans.y==34&&ans.x==37) {\n    //   cout << \"adslkfumsdlkfu\" << endl << \".................\" << endl;\n    //   cout << h << \" \" << w << \" \" <<  l << endl;\n    // }\n    printf(\"%d %d %c\\n\", ans.y+1, ans.x+1, dir[ans.d]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nvoid output(int i,int j,int d)\n{\n\tcout<<i+1<<' '<<j+1<<' '<<\"NESW\"[d]<<endl;\n}\n\nint main()\n{\n\tint h,w; long long l;\n\tfor(;cin>>h>>w>>l,h|w|l;){\n\t\tvector<string> grid(h);\n\t\tfor(int i=0;i<h;i++) cin>>grid[i];\n\t\t\n\t\tvector<vector<int>> vis(h,vector<int>(w,-1)),dir(h,vector<int>(w,-1));\n\t\t\n\t\tqueue<tuple<int,int,int,int>> q; // (i,j,dir,time)\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint d=string(\"NESW\").find(grid[i][j]);\n\t\t\t\tif(d!=-1){\n\t\t\t\t\tq.emplace(i,j,d,0);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\twhile(q.size()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint ci=get<0>(c),cj=get<1>(c),cd=get<2>(c),ct=get<3>(c);\n\t\t\tif(ct==l){\n\t\t\t\toutput(ci,cj,cd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ct>=100000) // 十分多く回す\n\t\t\tif(vis[ci][cj]!=-1){\n\t\t\t\tint len=ct-vis[ci][cj];\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tif(vis[i][j]==(l-vis[ci][cj])%len+vis[ci][cj])\n\t\t\t\t\t\t\toutput(i,j,dir[i][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[ci][cj]=ct,dir[ci][cj]=cd;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nd=(cd+i)%4,ni=ci+\"\\xff\\0\\x1\\0\"[nd],nj=cj+\"\\0\\x1\\0\\xff\"[nd];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='#'){\n\t\t\t\t\tq.emplace(ni,nj,nd,ct+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconstexpr int dy[] = { -1, 0, 1, 0 };\nconstexpr int dx[] = { 0, 1, 0, -1 };\nconst string dirs( \"NESW\" );\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( int H, W, L; cin >> H >> W >> L && ( H | W | L ); )\n\t{\n\t\tVS board( H );\n\t\tcin >> board;\n\n\t\tint y = 0, x = 0, d = 0;\n\t\tREP( i, H )\n\t\t{\n\t\t\tREP( j, W )\n\t\t\t{\n\t\t\t\tif ( isupper( board[i][j] ) )\n\t\t\t\t{\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t\td = dirs.find( board[i][j] );\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVT( VVI ) visited( H, VVI( W, VI( 4, -1 ) ) );\n\n\t\tREP( i, L )\n\t\t{\n\t\t\tif ( visited[y][x][d] != -1 && ( L - i ) % ( i - visited[y][x][d] ) == 0 )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvisited[y][x][d] = i;\n\n\t\t\twhile ( true )\n\t\t\t{\n\t\t\t\tconst int ny = y + dy[d];\n\t\t\t\tconst int nx = x + dx[d];\n\n\t\t\t\tif ( 0 <= ny && ny < H && 0 <= nx && nx < W && board[ ny ][ nx ] == '.' )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++d %= 4;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ty += dy[d];\n\t\t\tx += dx[d];\n\t\t}\n\n\t\tcout << y + 1 << ' ' << x + 1 << ' ' << dirs[d] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint main(void){\n\tlong long int i, l, flag[100][100][4], dx[4] = {0,1,0,-1},dy[4] = {-1,0,1,0}, h, w, d, j, k, x, y;\n\tchar str[100][101], dir[5] = {\"NEST\"};\n\twhile(1){\n\t\tscanf(\"%lld%lld%lld%*c\",&h,&w,&l);\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tstr[i][j] = getchar();\n\t\t\t\tif(isupper(str[i][j])){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tfor(k = 0;k < 4;k++)\n\t\t\t\t\t\tif(str[i][j] == dir[k]) d = k;\n\t\t\t\t\tstr[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tfor(i = 0;i < l;i++){\n\t\t\tif(flag[y][x][d] == -1)\n\t\t\t\tflag[y][x][d] = i;\n\t\t\telse{\n\t\t\t\ti += (i - flag[y][x][d]) * ((l - i) / (i - flag[y][x][d])) - 1;\n\t\t\t\tmemset(flag,-1,sizeof(flag));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(x + dx[d] >= 0 && x + dx[d] < w && y + dy[d] >= 0 && y + dy[d] < h && str[y + dy[d]][x + dx[d]] == '.'){\n\t\t\t\t\tx = x + dx[d];\n\t\t\t\t\ty = y + dy[d];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld %lld %c\\n\",y + 1,x + 1,dir[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint main(void){\n\tlong long int i, l, flag[100][100][4], dx[4] = {0,1,0,-1},dy[4] = {-1,0,1,0}, h, w, d, j, k, x, y;\n\tchar str[100][101], dir[5] = {\"NEST\"};\n\twhile(1){\n\t\tscanf(\"%lld%lld%lld%*c\",&h,&w,&l);\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tstr[i][j] = getchar();\n\t\t\t\tif(isupper(str[i][j])){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tfor(k = 0;k < 4;k++)\n\t\t\t\t\t\tif(str[i][j] == dir[k]) d = k;\n\t\t\t\t\tstr[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr[i][j] = '\\0';\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tfor(i = 0;i < l;i++){\n\t\t\tif(flag[y][x][d] == -1)\n\t\t\t\tflag[y][x][d] = i;\n\t\t\telse{\n\t\t\t\ti += (i - flag[y][x][d]) * ((l - i) / (i - flag[y][x][d])) - 1;\n\t\t\t\tmemset(flag,-1,sizeof(flag));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(x + dx[d] >= 0 && x + dx[d] < w && y + dy[d] >= 0 && y + dy[d] < h && str[y + dy[d]][x + dx[d]] == '.'){\n\t\t\t\t\tx = x + dx[d];\n\t\t\t\t\ty = y + dy[d];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld %lld %c\\n\",y + 1,x + 1,dir[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1}, H, W;\nstring dir[] = {\"N\",\"E\",\"S\",\"W\"};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nstring dfs(vector<string> &C, vector< vector< vector<int> > > &T,\n           int x, int y, long long int l, int d){\n  if(T[x][y][d] > 0){\n    l %= (T[x][y][d]-l);\n  }else{\n    T[x][y][d] = l;\n  }\n\n  if(l == 0){\n    string ret = to_string(x+1) + \" \" + to_string(y+1) + \" \" + dir[d];\n    return ret;\n  }\n  \n  for(int i = 0; i < 4; ++i){\n    int d_ = (d+i)%4, x_ = x + dx[d_], y_ = y + dy[d_];\n    //--l;\n    if(in_range(x_,H) && in_range(y_,W) && C[x_][y_] != '#'){\n      return dfs(C,T,x_,y_,l-1,d_);\n    }\n  }\n  return \"Error\";\n}\n\nint main(){\n  long long L;\n  while(cin >> H >> W >> L, H){\n    vector<string> C(H);\n    int s_x, s_y, d;\n    for(int i = 0; i < H; ++i){\n      cin >> C[i];\n      for(int j = 0; j < W; ++j){\n        if(C[i][j] != '.' && C[i][j] != '#'){\n          s_x = i;\n          s_y = j;\n          if(C[i][j] == 'N') d = 0;\n          if(C[i][j] == 'E') d = 1;\n          if(C[i][j] == 'S') d = 2;\n          if(C[i][j] == 'W') d = 3;\n        }\n      }\n    }\n    vector< vector< vector<int> > > T(H,vector< vector<int> >(W,vector<int>(4,-1)));\n    cout << dfs(C,T,s_x,s_y,L,d) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint main(void){\n\tint h, w, dx[4] = {0,1,0,-1},dy[4] = {-1,0,1,0}, flag[100][100][4], j, k, x, y, d;\n\tlong long int i, l;\n\tchar str[100][101], dir[5] = {\"NEST\"};\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&h,&w,&l);\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tstr[i][j] = getchar();\n\t\t\t\tif(isupper(str[i][j])){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = (int)i;\n\t\t\t\t\tfor(k = 0;k < 4;k++)\n\t\t\t\t\t\tif(str[i][j] == dir[k]) d = k;\n\t\t\t\t\tstr[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tfor(i = 0;i < l;i++){\n\t\t\tif(flag[y][x][d] == -1)\n\t\t\t\tflag[y][x][d] = (int)i;\n\t\t\telse{\n\t\t\t\ti += (i - flag[y][x][d]) * ((l - i) / (i - flag[y][x][d])) - 1;\n\t\t\t\tmemset(flag,-1,sizeof(flag));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(x + dx[d] >= 0 && x + dx[d] < w && y + dy[d] >= 0 && y + dy[d] < h && str[y + dy[d]][x + dx[d]] == '.'){\n\t\t\t\t\tx = x + dx[d];\n\t\t\t\t\ty = y + dy[d];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",y + 1,x + 1,dir[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nchar C( int k) {\n  if(k==0) return 'N';\n  else if(k==1) return 'E';\n  else if(k==2) return 'S';\n  return 'W';\n}\nint main() {\n  long long n,m,l;\n  while(cin >> n >> m >> l && n) {\n    string s[n];\n    int nx,ny,k;\n    for(int i=0; i<n; i++) {\n      cin >> s[i];\n      for(int j=0; j<m; j++) {\n        if(isalpha(s[i][j])) {\n          nx=i,ny=j;\n          if(s[i][j]=='N') k=0;\n          else if(s[i][j]=='E') k=1;\n          else if(s[i][j]=='S') k=2;\n          else k=3;\n        }\n      }\n    }\n    int d[n][m][4],c=0;\n    memset(d,-1,sizeof(d));\n    d[nx][ny][k]=0;\n    vector<PP> v;\n    v.push_back(PP(P(nx,ny),k));\n    while(l) {\n      int x=nx+dx[k],y=ny+dy[k];\n      if(!check(n,m,x,y)||s[x][y]=='#') {\n        k=(k+1)%4;\n        continue;\n      }\n      l--;\n      c++;\n      if(!l) cout << x+1 << \" \" << y+1 << \" \" << C(k) << endl;\n      else if(d[x][y][k]==-1) {\n        v.push_back(PP(P(x,y),k));\n        d[x][y][k]=c;\n        nx=x,ny=y;\n      } else {\n        long long t=c-d[x][y][k];\n        PP p=v[d[x][y][k]+l%t];\n        cout << p.first.first+1 << \" \" << p.first.second+1 << \" \" << C(p.second) << endl;\n        break;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, T b) {\n    if(b<a) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nint H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x,cnt;\n    State(int dir,int y,int x,int cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    int d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            //printf(\"%d %d %d : %d %d\\n\",s.dir,s.y,s.x,s.cnt,d[s.dir][s.y][s.x]);\n            int diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            int t=(L-s.cnt)/diff;\n            if(t>0&&diff>0) {\n                s.cnt+=(t-1)*diff;\n            }\n            //printf(\"\\t%d\\n\",s.cnt);\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                chmin(d[s.dir][ny][nx],s.cnt+1);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) while(1){}\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nlong long int l;\nint tesu[101][101][4];\nchar meiro[101][101];\nvector<pair<pair<int, int>, char> > step;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar direction[4] = {'N', 'E', 'S', 'W'};\n\nvoid solve(int x, int y, int nowface, long long int stepnum)\n{\n    // cout << stepnum << \" \" << x << \" \" << y << \" \" << direction[nowface] << endl;\n    if(stepnum == l){\n        cout << x << \" \" << y << \" \" << direction[nowface] << endl;\n        return;\n    }\n    step.push_back(make_pair(make_pair(x, y), direction[nowface]));\n    int nx = x + dx[nowface];\n    int ny = y + dy[nowface];\n    while(nx < 1 || ny < 1 || nx > h || ny > w || meiro[nx][ny] == '#'){\n        nowface = (nowface + 1) % 4;\n        nx = x + dx[nowface];\n        ny = y + dy[nowface];\n        // cout << x << \" \" << y << \" \" <<  nx << \" \" << ny << endl;\n    }\n    if(tesu[nx][ny][nowface] == -1){\n        tesu[nx][ny][nowface] = stepnum + 1;\n        solve(nx, ny, nowface, stepnum + 1);\n    } else {\n        long long int tmp = stepnum + 1 - tesu[nx][ny][nowface];\n        // cout << tesu[nx][ny][nowface] << endl;\n        pair<pair<int, int>, char> ans = step[tesu[nx][ny][nowface] + (l - tesu[nx][ny][nowface]) % tmp];\n        cout << (ans.first).first << \" \" << (ans.first).second << \" \" << ans.second << endl;\n    }\n    return;\n}\n\n\nint main()\n{\n    while(1){\n        cin >> h >> w >> l;\n        int sx, sy;\n        if(w == 0 && h == 0 && l == 0) break;\n        step.clear();\n        for(int i = 1; i < h + 1; i++){\n            for(int j = 1; j < w + 1; j++){\n                cin >> meiro[i][j];\n                if(meiro[i][j] != '#' && meiro[i][j] != '.'){\n                    sx = i;\n                    sy = j;\n                }\n                for(int k = 0; k < 4; k++){\n                    tesu[i][j][k] = -1;\n                }\n            }\n        }\n        if(meiro[sx][sy] == 'N') solve(sx, sy, 0, 0);\n        else if(meiro[sx][sy] == 'E') solve(sx, sy, 1, 0);\n        else if(meiro[sx][sy] == 'S') solve(sx, sy, 2, 0);\n        else solve(sx, sy, 3, 0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w;\nint sy, sx, dir;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar dd[4] = {'E', 'S', 'W', 'N'};\n\nbool can(int y, int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nint main() {\n\tll l;\n\twhile(cin >> h >> w >> l) {\n\t\tif(h == 0 && w == 0 && l == 0) break;\n\n\t\tvector<string> v(h);\n\t\trep(i, h) cin >> v[i];\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(v[i][j] == 'E') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'S') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 1;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'W') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'N') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 3;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint d[105][105][4];\n\t\tmemset(d, -1, sizeof(d));\n\n\t\tvector<int> X, Y, D;\n\t\tint y = sy, x = sx, cnt = 0;\n\t\tint pdir = dir, ndir;\n\n\t\td[y][x][dir] = cnt;\n\t\tcnt++;\n\n\t\twhile(l) {\n\t\t\ty = y + dy[dir];\n\t\t\tx = x + dx[dir];\n\t\t\tl--;\n\n\t\t\trep(i, 4) {\n\t\t\t\tint ny = y + dy[(dir + i) % 4];\n\t\t\t\tint nx = x + dx[(dir + i) % 4];\n\n\t\t\t\tif(can(ny, nx) && v[ny][nx] == '.') {\n\t\t\t\t\tdir = (dir + i) % 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(d[y][x][dir] == -1) {\n\t\t\t\td[y][x][dir] = cnt;\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint len = cnt - d[y][x][dir];\n\t\tl = l % len;\n\n\t\trep(i, l) {\n\t\t\trep(j, 4) {\n\t\t\t\tint ny = y + dy[(dir + j) % 4];\n\t\t\t\tint nx = x + dx[(dir + j) % 4];\n\n\t\t\t\tif(can(ny, nx) && v[ny][nx] == '.') {\n\t\t\t\t\ty = ny; x = nx;\n\t\t\t\t\tdir = (dir + j) % 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << y + 1 << \" \" << x + 1 << \" \" << dd[dir] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstruct State{\n    int h,w,dir;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nmap<char,int> dmp={{'N',0},{'E',1},{'S',2},{'W',3},{'n',0},{'e',1},{'s',2},{'w',3}};\nstring dmpi=\"NESW\";\n\nvoid out(State st){\n    cout<<st.h<<\" \"<<st.w<<\" \"<<dmpi[st.dir]<<endl;\n}\n\nint solve(int H,int W,int L){\n    vector<string> f(H+2);\n    for(int i=0;i<W+2;i++){\n        f[0]+=\"#\";\n        f[H+1]+=\"#\";\n    }\n    State ini={-1,-1,-1};\n    for(int i=0;i<H;i++){\n        cin>>f[i+1];\n        f[i+1]=\"#\"+f[i+1]+\"#\";\n        for(int j=0;j<W+2;j++){\n            if(dmp.count(f[i+1][j])){\n                ini=State{i+1,j,dmp[f[i+1][j]]};\n            }\n        }\n    }\n    vector<vector<vector<int>>> dp(H+2,vector<vector<int>>(W+2,vector<int>(4,-1)));\n    int lps=0;\n    State st=ini;\n    int cnt=0;\n    queue<State> que;\n    while(true){\n        if(cnt==L){\n            out(st);\n            return 0;\n        }\n        if(dp[st.h][st.w][st.dir]!=-1){\n            lps=cnt-dp[st.h][st.w][st.dir];\n            break;\n        }\n        dp[st.h][st.w][st.dir]=cnt;\n        if(f[st.h+dh[st.dir]][st.w+dw[st.dir]]=='#'){\n            st.dir=(st.dir+1)%4;\n            continue;\n        }\n        st.h+=dh[st.dir];\n        st.w+=dw[st.dir];\n        que.push(st);\n        cnt++;\n    }\n    L-=cnt+1;\n    vector<State> lpv;\n    while(que.size()>lps) que.pop();\n    while(!que.empty()) lpv.push_back(que.front()),que.pop();\n    L%=lps;\n    out(lpv[L]);\n    return 0;\n}\nint main(){\n    int H,W,L;\n    while(cin>>H>>W>>L,H){\n        solve(H,W,L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid Solve(){\n\twhile(true){\n\t\tint h,w,l;\n\t\tcin >> h >> w >> l;\n\t\tif(h==0&&w==0&&l==0) break;\n\t\tvector<string> cells(h);\n\t\tREP(i,0,h) cin >> cells[i];\n\n\t\tconst char empty='.',wall='#';\n\t\tconst int north=0,east=1,south=2,west=3;\n\t\tint y,x,dir;\n\t\tREP(i,0,h) REP(j,0,w) if(cells[i][j]!=empty&&cells[i][j]!=wall){\n\t\t\ty=i; x=j;\n\t\t\tswitch(cells[i][j]){\n\t\t\t\tcase 'N': dir=north; break;\n\t\t\t\tcase 'E': dir=east; break;\n\t\t\t\tcase 'S': dir=south; break;\n\t\t\t\tcase 'W': dir=west; break;\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t\tcells[i][j]=empty;\n\t\t\tbreak;\n\t\t}\n\n\t\tint rotate[4];\n\t\tREP(i,0,4) rotate[i]=(i+1)%4;\n\n\t\tconst int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\t\tREP(i,0,l){\n\t\t\tint ny=y+dy[dir],nx=x+dx[dir];\n\t\t\twhile(!(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty)){\n\t\t\t\tdir=rotate[dir];\n\t\t\t\tny=y+dy[dir]; nx=x+dx[dir];\n\t\t\t}\n\t\t\ty=ny; x=nx;\n\t\t}\n\n\t\tcout << y+1 << ' ' << x+1 << ' ' << \"NESW\"[dir] << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring mp[101];\nint h,w;\nll n;\n\n\nvoid move(int x,int y,int dir){\n  string str=\"NESW\";\n  int visited[101][101];\n  ll dis[101][101];\n  memset(visited,-1,sizeof(visited));\n  visited[y][x]=dir;\n  dis[y][x]=0;\n\n  while(n!=0){\n    int nx=x+dx[dir];\n    int ny=y+dy[dir];\n    int flg=1;\n    \n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='#'){\n      flg=0;\n      dir=(dir+1)%4;\n      nx=x,ny=y;\n    }\n\n    if(visited[ny][nx]==dir){\n      if((dis[y][x]-dis[ny][nx]+1)==0)break;;\n      n %=(dis[y][x]-dis[ny][nx]+1);\n      memset(visited,-1,sizeof(visited));\n    }\n\n    dis[ny][nx]=dis[y][x]+flg;\n    n-=flg;\n    visited[ny][nx]=dir;\n    x=nx,y=ny;\n  }\n  cout << y+1 <<\" \"<<x+1<<\" \"<<str[dir]<<endl;\n}\n\n\nint main(){\n  while(1){\n    cin >>h>>w>>n;\n    if(!h&&!w&&!n)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n\n    int dir,sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<mp[i].size();j++){\n\tif(mp[i][j]=='.'||mp[i][j]=='#')continue;\n\tsx=j;\n\tsy=i;\n\tif(mp[i][j]=='N')dir=0;\n\tif(mp[i][j]=='E')dir=1;\n\tif(mp[i][j]=='S')dir=2;\n\tif(mp[i][j]=='W')dir=3;\n      }\n    move(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nll h,w,l;\nstring in[100];\nint vis[100][100][4];\nvoid solve(){\n  rep(i,h) cin >> in[i];\n  int dir=0,cx=0,cy;\n  rep(i,h)rep(j,w){\n    dir=string(\"ESWN\").find(in[i][j]);\n    cx=i;cy=j;\n    if(dir!=string::npos)\n      goto initend;\n  }\n initend:;\n\n  FLL(vis,-1);\n  vector<pair<PI,char> > seq;\n  int lo=0;\n  while(true){\n    if(vis[cx][cy][dir]!=-1){\n      lo -= vis[cx][cy][dir];\n      break;\n    }\n    vis[cx][cy][dir]=lo++;\n    seq.pb(mp(mp(cx,cy),dir));\n    //cout << cx << ' ' << cy << ' ' << dir << endl;\n    rep(ii,4){\n      int i=dir+ii&3;\n      int nx=cx+dx[i],ny=cy+dy[i];\n      if(min(nx,ny)<0 || nx>=h || ny>=w || in[nx][ny]=='#') continue;\n      cx=nx;\n      cy=ny;\n      dir=i;\n      break;\n    }\n  }\n\n  if(l>=SZ(seq))\n    l=(l-(SZ(seq)-lo))%lo+SZ(seq)-lo;\n  \n  cout << seq[l].F.F+1 << ' ' << seq[l].F.S+1 << ' ' << \"ESWN\"[seq[l].S] << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> h >> w >> l && h) solve();\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=105;\nconst ll INF=1LL<<62;\n\nint when[MAX][MAX][4];\nstring ESWN=\"ESWN\";\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int H,W;cin>>H>>W;\n        ll N;cin>>N;\n        \n        if(H+W+N==0) break;\n        \n        memset(when,0,sizeof(when));\n        \n        vector<string> S(H);\n        for(int i=0;i<H;i++) cin>>S[i];\n        \n        int hnow,wnow,dir;\n        \n        bool yatta=false;\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                for(int k=0;k<4;k++){\n                    if(S[i][j]==ESWN[k]){\n                        hnow=i;\n                        wnow=j;\n                        dir=k;\n                    }\n                }\n            }\n        }\n        int turn=0,roop=-1,left=-1,right=-1;\n        while(1){\n            int toh=hnow+dh[dir],tow=wnow+dw[dir];\n            \n            while(toh<0||toh>=H||tow<0||tow>=W||S[toh][tow]=='#'){\n                dir=(dir+1)%4;\n                toh=hnow+dh[dir];\n                tow=wnow+dw[dir];\n            }\n            \n            turn++;\n            hnow=toh;\n            wnow=tow;\n            \n            if(when[hnow][wnow][dir]){\n                roop=turn-when[hnow][wnow][dir];\n                left=when[hnow][wnow][dir];\n                right=turn-1;\n                break;\n            }\n            \n            when[hnow][wnow][dir]=turn;\n            \n            if(turn==N){\n                cout<<(hnow+1)<<\" \"<<(wnow+1)<<\" \"<<ESWN[dir]<<endl;\n                yatta=true;\n                break;\n            }\n        }\n        \n        if(yatta) continue;\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                for(int k=0;k<4;k++){\n                    if(left<=when[i][j][k]&&when[i][j][k]<=right&&(N-when[i][j][k])%roop==0){\n                        cout<<i+1<<\" \"<<j+1<<\" \"<<ESWN[k]<<endl;\n                        //return 0;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint main(){\n\tint H,W;\n\tlong long L;\n\tchar c[111][111];\n\tint memo[111][111][4];\n\tchar dir[] = \"ESWN\";\n\tint dy[] = {0,1,0,-1};\n\tint dx[] = {1,0,-1,0};\n\tint y,x,d,step;\n\tint i,j,k;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d %lld\",&H,&W,&L);\n\t\tif(H==0)return 0;\n\t\t\n\t\tfor(i=0;i<=H+1;i++){\n\t\t\tfor(j=0;j<=W+1;j++){\n\t\t\t\tc[i][j]='#';\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=1;i<=H;i++){\n\t\t\tfor(j=1;j<=W;j++){\n\t\t\t\tscanf(\" %c\",&c[i][j]);\n\t\t\t\tif(isalpha(c[i][j])){\n\t\t\t\t\ty=i,x=j;\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(dir[k]==c[i][j]) d=k;\n\t\t\t\t\t}\n\t\t\t\t\tc[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(i=0;i<=H+1;i++){\n\t\t\tfor(j=0;j<=W+1;j++){\n\t\t\t\tprintf(\"%c\",c[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t//printf(\"%d %d %d\\n\",y,x,d);\n\t\t\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tstep=0;\n\t\twhile(1){\n\t\t\tint ny,nx;\n\t\t\t//printf(\"%d %d %c\\n\",y,x,dir[d]);\n\t\t\t\n\t\t\tif(step == L){\n\t\t\t\tprintf(\"%d %d %c\\n\",y,x,dir[d]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[y][x][d]!=-1){\n\t\t\t\tlong long cycle=step-memo[y][x][d];\n\t\t\t\tlong long rest=(L-step)%cycle;\n\t\t\t\t//printf(\"LOOP\\n\");\n\t\t\t\tfor(i=0;i<rest;i++){\n\t\t\t\t\tny = y + dy[d];\n\t\t\t\t\tnx = x + dx[d];\n\t\t\t\t\twhile(c[ny][nx] == '#'){\n\t\t\t\t\t\td = (d+1) % 4;\n\t\t\t\t\t\tny = y + dy[d];\n\t\t\t\t\t\tnx = x + dx[d];\n\t\t\t\t\t}\n\t\t\t\t\ty=ny,x=nx;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d %d %c\\n\",y,x,dir[d]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemo[y][x][d] = step;\n\t\t\t\n\t\t\tny = y + dy[d];\n\t\t\tnx = x + dx[d];\n\t\t\twhile(c[ny][nx] == '#'){\n\t\t\t\td = (d+1) % 4;\n\t\t\t\tny = y + dy[d];\n\t\t\t\tnx = x + dx[d];\n\t\t\t}\n\t\t\ty=ny,x=nx;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tstring s=\"ESWN\";\n\tint n,m;\n\tll t;\n\twhile(cin>>n>>m>>t,n+m+t){\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tint x,y,now;\n\t\trep(i,n)rep(j,m)rep(k,4)\n\t\t\tif(in[i][j]==s[k])x=i,y=j,now=k;\n\t\tll memo[101][101][4]={0};\n\t\tbool h=false;\n\t\twhile(t--){\n\t\t\tif(!h&&memo[x][y][now]){\n\t\t\t\th=true;\n\t\t\t\tt%=memo[x][y][now]-t;\n\t\t\t}\n\t\t\tmemo[x][y][now]=t;\n\t\t\tint nx=x+dx[now];\n\t\t\tint ny=y+dy[now];\n\t\t\tif(nx<0||ny<0||nx>=n||ny>=m||in[nx][ny]=='#')(now+=1)%=4,t++;\n\t\t\telse x=nx,y=ny;\n\t\t}\n\t\tcout<<x+1<<\" \"<<y+1<<\" \"<<s[now]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef long long lint;\n\nint H, W, dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nlint L;\nstring grid[110], dir = \"NESW\";\n\nint visit[110][110][4], px[41000], py[41000], pd[41000];\n\nbool able(int x, int y) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return false;\n\treturn grid[y][x] == '.';\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\twhile (cin >> H >> W >> L, H) {\n\t\tint x = 0, y = 0, d = 0;\n\t\t\n\t\tfor_(i,0,H) {\n\t\t\tcin >> grid[i];\n\t\t\tfor_(j,0,W) if (grid[i][j] != '.' && grid[i][j] != '#') {\n\t\t\t\tx = j; y = i;\n\t\t\t\td = dir.find(grid[i][j]);\n\t\t\t\tgrid[i][j] = '.';\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(visit, -1, sizeof(visit));\n\t\t\n\t\tlint s = 0;\n\t\twhile (visit[y][x][d] < 0) {\n\t\t\tvisit[y][x][d] = s;\n\t\t\tpx[s] = x; py[s] = y; pd[s] = d;\n\t\t\twhile (!able(x + dx[d], y + dy[d])) d = (d + 1) % 4;\n\t\t\tx += dx[d]; y += dy[d];\n\t\t\t++s;\n\t\t}\n\t\t\n\t\tlint t = visit[y][x][d], id = L;\n\t\tif (s < L) id = t + (L - t) % (s - t);\n\t\t\n\t\tcout << py[id] + 1 << \" \" << px[id] + 1 << \" \" << dir[pd[id]] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint dist[110][110][4];\nchar v[110][110];\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { -1, 0, 1, 0 };\n\nint main(){\n\tint n, m, L;\n\twhile (cin >> n >> m >> L, n){\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1) cin >> v[i][j];\n\t\tint r, c, d;\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1){\n\t\t\tif (v[i][j] != '.' && v[i][j] != '#'){\n\t\t\t\trep(dir, 4) if (v[i][j] == \"NESW\"[dir]) tie(r, c, d) = MT(i, j, dir);\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\n\t\tMEMSET(dist, -1);\n\t\tint x = 0;\n\t\tdist[r][c][d] = x++;\n\t\tbool loop = true;\n\t\twhile (L){\n\t\t\twhile (v[r + dy[d]][c + dx[d]] != '.') d = (d+1)%4;\n\t\t\tr += dy[d], c += dx[d];\n\t\t\tdist[r][c][d] = x++, L--;\n\t\t\tif (!loop && dist[r][c][d] >= 0) L %= (x - dist[r][c][d]), loop = false;\n\t\t}\n\t\tcout << r << ' ' << c << ' ' << \"NESW\"[d] << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string tmp = \"NESW\";\nconst int vy[] = {-1, 0, 1, 0}, vx[] = {0, 1, 0, -1};\n \nint H, W;\nint64 L;\nstring C[100];\nint sx, sy, sv;\nint nxt[100][100][4];\nvoid dfs(int x, int y, int v, int step)\n{\n  int nx = x + vx[v], ny = y + vy[v], nv = (v + 1) % 4;\n  if(step == 0) {\n    cout << y + 1 << \" \" << x + 1 << \" \" << tmp[v] << endl;\n    return;\n  } else if(0 <= nx && 0 <= ny && nx < W && ny < H && C[ny][nx] != '#') {\n    int loop = ~nxt[nx][ny][v] ? nxt[x][y][v] - nxt[nx][ny][v] + 1 : step;\n    nxt[nx][ny][v] = nxt[x][y][v] + 1;\n    return(dfs(nx, ny, v, (step - 1) % loop));\n  } else {\n    nxt[x][y][nv] = nxt[x][y][v];\n    return(dfs(x, y, nv, step));\n  }\n}\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(nxt, -1, sizeof(nxt));\n    for(int i = 0; i < H; i++) {\n      cin >> C[i];\n      for(int j = 0; j < W; j++) {\n        int p = tmp.find(C[i][j]);\n        if(p != string::npos) sx = j, sy = i, sv = p;\n      }\n    }\n    nxt[sx][sy][sv] = 0;\n    dfs(sx, sy, sv, L);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) lps(i,0,n)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define FDST int hogehogehoge;cin>>hogehogehoge\n#define MAX_V 110\n#define   int long long\n\nint H, W, L;\nstring str[MAX_V];\nchar foo(char temp){\n   if(temp == 'S'){\n     temp = 'W';\n   } else if(temp == 'N'){\n     temp = 'E';\n   } else if(temp == 'E'){\n     temp = 'S';\n   } else if(temp == 'W'){\n     temp = 'N';\n   }\n   return temp;\n}\n\nsigned  main(){\n  while(true){\n    int xy[2];\n    int dp[MAX_V][MAX_V][30] = {}, used[MAX_V][MAX_V] = {};\n    char temp;\n    cin>>H>>W>>L;\n\n    if(!H&&!W&&!L) break;\n    \n    for(int i = 0; i < H; i++){\n      cin>>str[i];\n      for(int j = 0; j < W; j++){\n\tif(str[i][j] != '.' && str[i][j] != '#'){\n\t  xy[0] = i; xy[1] = j;\n\t  temp = str[i][j];\n\t}\n      }\n    }\n\n    for(int i = 1; i <= L;){\n      int x = xy[1], y = xy[0];\n      // char tt  = temp;\n      //int xx= x, yy = y;\n      //cout<<i<<\" \"<<x<<\" \"<<y<<\" \"<<temp<<endl;\n      if(temp == 'S'){\n\ty++;\n      } else if(temp == 'N'){\n\ty--;\n      } else if(temp == 'E'){\n\tx++;\n      } else if(temp == 'W'){\n\tx--;\n      }\n      if(0 <= y && y < H && 0 <= x && x < W){\n\tif(str[y][x] == '#'){\n\t  temp = foo(temp);\n\t  dp[y][x][temp-'A'] = i;\n\t} else {\n\t  if(dp[y][x][temp-'A']){\n\t    if((L-i)/(i-dp[y][x][temp-'A'])){\n\t      i = L-(L-i)%(i-dp[y][x][temp-'A']);\n\t    } else {\n\t      xy[0] = y, xy[1] = x;\n\t      i++;\n\t    }\n\t  } else {\n\t    xy[0] = y, xy[1] = x;\n\t    dp[y][x][temp-'A'] = i;\n\t    i++;\n\t  }\n\t}\n\t\n      } else {\n\ttemp = foo(temp);\n\tdp[y][x][temp-'A'] = i;\n      }\n    }\n    cout<<xy[0]+1<<\" \"<<xy[1]+1<<\" \"<<temp<<endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint t[110][110][4];\nchar str[110][110];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint R[110000];\nint C[110000];\nchar D[110000];\nchar name[6]=\"ESWN\";\nint main(){\n\tint a,b;\n\tlong long c;\n\twhile(scanf(\"%d%d%lld\",&a,&b,&c),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++)t[i][j][k]=-1;\n\t\tint dir=0;\n\t\tint row=0;\n\t\tint col=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]!='#'&&str[i][j]!='.'){\n\t\t\t\trow=i;col=j;\n\t\t\t\tif(str[i][j]=='E')dir=0;\n\t\t\t\tif(str[i][j]=='S')dir=1;\n\t\t\t\tif(str[i][j]=='W')dir=2;\n\t\t\t\tif(str[i][j]=='N')dir=3;\n\t\t\t}\n\t\t}\n\t\tint now=0;\n\t\tint last=-1;\n\t\tlong long c2;\n\t\twhile(1){\n\t\t\tt[row][col][dir]=now;\n\t\t\tif(last!=now){\n\t\t\t\tR[now]=row;\n\t\t\t\tC[now]=col;\n\t\t\t\tD[now]=name[dir];\n\t\t\t\tlast=now;\n\t\t\t}\n\t\t\t//now++;\n\t\t\tint nr=row+dx[dir];\n\t\t\tint nc=col+dy[dir];\n\t\t\tif(nr<0||nc<0||nr>=a||nc>=b||str[nr][nc]=='#'){\n\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\trow=nr;\n\t\t\t\tcol=nc;\n\t\t\t\tnow++;\n\t\t\t}\n\t\t\tif(~t[row][col][dir]){\n\t\t\t\tif((long long)now<=c){\n\t\t\t\t\tc=t[row][col][dir]+(c-t[row][col][dir])%(now-t[row][col][dir]);\n\t\t\t\t\tc2=t[row][col][dir]+(c-t[row][col][dir]-1+(now-t[row][col][dir]))%(now-t[row][col][dir]);\n\t\t\t\t}else c2=c-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d \",R[c]+1,C[c]+1);\n\t\tfor(int i=0;i<4;i++)if(R[c2]+dx[i]==R[c]&&C[c2]+dy[i]==C[c])printf(\"%c\\n\",name[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint todir[256];\nchar tochr[4];\n\nint h, w;\nlong long l;\nstring c[110];\nint vis[110][110][4];\n\nint main()\n{\n\tfor (int i = 0; i < 4; i++){\n\t\ttodir[\"NESW\"[i]] = i;\n\t\ttochr[i] = \"NESW\"[i];\n\t}\n\n\twhile (cin >> h >> w >> l, h){\n\t\tmemset(vis, -1, sizeof(vis));\n\t\tc[0] = c[h + 1] = string(w + 2, '#');\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tcin >> c[i];\n\t\t\tc[i] = \"#\" + c[i] + \"#\";\n\t\t}\n\t\tint x, y, dir;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tif (c[i][j] != '.' && c[i][j] != '#'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tdir = todir[c[i][j]];\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long t = 0; t < l; t++){\n\t\t\twhile (true){\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[dir];\n\t\t\t\tif (c[nx][ny] == '.') break;\n\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t}\n\t\t\tif (~vis[x][y][dir]){\n\t\t\t\tt += (l - t - 1) / (t - vis[x][y][dir]) * (t - vis[x][y][dir]);\n\t\t\t}\n\t\t\telse vis[x][y][dir] = t;\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\t\t}\n\t\tcout << x << \" \" << y << \" \" << tochr[dir] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct robot_state\n{\n    int x;\n    int y;\n    char orientation;\n};\n\nvoid orient_to_empty_cell(const vector<vector<char>> &maze, robot_state &robot)\n{\n    while (true)\n    {\n        switch (robot.orientation)\n        {\n        case 'N':\n            if (maze[robot.y - 1][robot.x] == '#')\n            {\n                robot.orientation = 'E';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'E':\n            if (maze[robot.y][robot.x + 1] == '#')\n            {\n                robot.orientation = 'S';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'S':\n            if (maze[robot.y + 1][robot.x] == '#')\n            {\n                robot.orientation = 'W';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'W':\n            if (maze[robot.y][robot.x - 1] == '#')\n            {\n                robot.orientation = 'N';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        default:\n            exit(EXIT_FAILURE);\n            break;\n        }\n    }\n}\n\nvoid go_forward(robot_state &robot)\n{\n    switch (robot.orientation)\n    {\n    case 'N':\n        --robot.y;\n        break;\n    case 'E':\n        ++robot.x;\n        break;\n    case 'S':\n        ++robot.y;\n        break;\n    case 'W':\n        --robot.x;\n        break;\n    default:\n        exit(EXIT_FAILURE);\n        break;\n    }\n}\n\nint main()\n{\n    int H, W;\n    long long L;\n    while (cin >> H >> W >> L, H || W || L)\n    {\n        vector<vector<char>> maze(H + 2, vector<char>(W + 2, '#'));\n        robot_state robot;\n        // input maze\n        for (int i = 1; i < H + 1; ++i) \n        {\n            for (int j = 1; j < W + 1; ++j)\n            {\n                char c;\n                cin >> c;\n                if (c == '.' || c == '#')\n                {\n                    maze[i][j] = c;\n                }\n                else\n                {\n                    maze[i][j] = '.';\n                    robot.x = j;\n                    robot.y = i;\n                    robot.orientation = c;\n                }\n            }\n        }\n        // do this\n        for (long long i = 0; i < L; ++i)\n        {\n            orient_to_empty_cell(maze, robot);\n            go_forward(robot);\n        }\n        cout << robot.y << ' ' << robot.x << ' ' << robot.orientation << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nint h, w, y, x, d;\nlli l, c;\nchar data[100][100];\nlli vis[100][100][4];\nstring dir = \"NESW\";\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return data[y][x] != '#';\n}\n\nvoid solve(){\n  int m, o;\n  fill(vis[0][0], vis[100][0], -1);\n  bool f = false;\n  vis[y][x][d] = c++;\n  while(c <= l){\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    while(!check(ny, nx)){\n      d = (d+1) % 4;\n      ny = y + dy[d];\n      nx = x + dx[d];\n    }\n    y = ny;\n    x = nx;\n    if(vis[y][x][d] == -1 || f) vis[y][x][d] = c;\n    else{\n      f = true;\n      lli m = c - vis[y][x][d];\n      lli o = l - c;\n      o %= m;\n      c = l - o;\n    }\n    c++;\n  }\n  cout << y+1 << ' ' << x+1 << ' ' << dir[d] << endl;\n}\n\nmain(){\n  while(cin >> h >> w >> l && (h|w|l)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        for(int k=0;k<4;k++){\n          if(data[i][j] == dir[k]){\n            data[i][j] = '.';\n            y = i;\n            x = j;\n            d = k;\n            c = 0;\n          }\n        }\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\n\nint H, W, L;\nint my[] = {-1, 0, 1, 0};\nint mx[] = {0, 1, 0, -1};\n\nvoid turn(PP &now, vector< vector<bool> > &v){\n  int y = now.first.first, x = now.first.second, d = now.second;\n  while(!(y + my[d] >= 0 && x + mx[d] >= 0 && y + my[d] < H && x + mx[d] < W && v[y + my[d]][x + mx[d]] == 0)) d = (d + 1) % 4;\n  now.second = d;\n}\n\nPP solve(vector< vector<bool> > &G, PP &now, int &L){\n  vector<PP> v;\n  map<PP, int> M;\n  int cnt = 0;\n  turn(now, G);\n  while(L-- > 0){\n    turn(now, G);\n    int &y = now.first.first, &x = now.first.second, &d = now.second;\n    y = (y + my[d]); x = (x + mx[d]);\n    if(L <= 0) return now;\n    else if(M.find(now) != M.end()) break;\n    v.push_back(now);\n    M[now] = cnt++;\n  }\n  int t = L % ((int)v.size() - M[now]);\n  return v[t + M[now]];\n}\n\n\nint main() {\n  map<char, int> D;\n  D['N'] = 0; D['E'] = 1; D['S'] = 2; D['W'] = 3;\n  string RD = \"NESW\";\n  while(cin >>H >>W >>L && (H || W || L)){\n    vector< vector<bool> > v(H, vector<bool>(W));\n    PP now;\n    REP(i, H){\n      REP(j, W){\n        char c; cin >>c;\n        if(c == '.') v[i][j] = 0;\n        else if(c == '#') v[i][j] = 1;\n        else{\n          v[i][j] = 0;\n          now.first.second = j; now.first.first = i;\n          now.second = D[c];\n        }\n      }\n    }\n    PP ans = solve(v, now, L);\n    cout <<ans.first.first + 1 <<\" \" <<ans.first.second + 1 <<\" \" <<RD[ans.second] <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    string dir = \"NESW\";\n    int64_t h,w,l;\n    cin>>h>>w>>l;\n    if(!h) break;\n    vector<string> m(h+2,string(w+2,'#'));\n    REP(i,h){\n      string s;\n      cin>>s;\n      m[i+1] = \"#\"+s+\"#\";\n    }\n    h+=2; w+=2;\n    int si,sj,sd;\n    REP(i,h)REP(j,w)REP(k,4){\n      if (m[i][j] == dir[k])\n        tie(si,sj,sd) = make_tuple(i, j, k);\n    }\n    map<tuple<int,int,int>,int> olds;\n    vector<tuple<int,int,int>> ov;\n    int di[]={-1,0,1,0};\n    int dj[]={0,1,0,-1};\n    int cycle = 0;\n    int offset = 0;\n    while(1){\n      olds[make_tuple(si,sj,sd)] = olds.size();\n      ov.emplace_back(si,sj,sd);\n      int ni=si+di[sd];\n      int nj=sj+dj[sd];\n      while(m[ni][nj] == '#'){\n        ++sd;\n        sd%=4;\n        ni=si+di[sd];\n        nj=sj+dj[sd];\n      }\n      si=ni;sj=nj;\n      auto itr = olds.find(make_tuple(si,sj,sd));\n      if(itr != end(olds)){\n        ov.emplace_back(si,sj,sd);\n        offset = itr->second;\n        cycle = olds.size()+1 - offset;\n        break;\n      }\n    }\n    int li,lj,ld;\n    if(l < offset){\n      tie(li,lj,ld) = ov[l];\n    }else{\n      l -= offset;\n      l %= cycle;\n      tie(li,lj,ld) = ov[l+offset];\n    }\n    cout<<li<<' '<<lj<<' '<<dir[ld]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring mp[101];\nint h,w;\nll n;\n\n\nvoid move(int x,int y,int dir){\n  string str=\"NESW\";\n  int visited[101][101];\n  ll dis[101][101];\n  memset(visited,-1,sizeof(visited));\n  visited[y][x]=dir;\n  dis[y][x]=0;\n\n  while(n!=0){\n    int nx=x+dx[dir];\n    int ny=y+dy[dir];\n    int flg=1;\n    \n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='#'){\n      flg=0;\n      dir=(dir+1)%4;\n      nx=x,ny=y;\n    }\n\n    if(visited[ny][nx]==dir){\n      if((dis[y][x]-dis[ny][nx]+1)==0)break;;\n      n %=(ll)(dis[y][x]-dis[ny][nx]+1);\n      memset(visited,-1,sizeof(visited));\n    }\n\n    dis[ny][nx]=dis[y][x]+flg;\n    n-=flg;\n    visited[ny][nx]=dir;\n    x=nx,y=ny;\n  }\n  cout << y+1 <<\" \"<<x+1<<\" \"<<str[dir]<<endl;\n}\n\n\nint main(){\n  while(1){\n    cin >>h>>w>>n;\n    if(!h&&!w&&!n)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n\n    int dir,sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<mp[i].size();j++){\n\tif(mp[i][j]=='.'||mp[i][j]=='#')continue;\n\tsx=j,sy=i;\n\tif(mp[i][j]=='N')dir=0;\n\tif(mp[i][j]=='E')dir=1;\n\tif(mp[i][j]=='S')dir=2;\n\tif(mp[i][j]=='W')dir=3;\n      }\n    move(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x,cnt;\n    State(int dir,int y,int x,int cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    int d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            int diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            while(s.cnt+diff<L) {\n                s.cnt+=diff;\n            }\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            d[(s.dir+1)%4][s.y][s.x]=s.cnt;\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                d[(s.dir+1)%4][s.y][s.x]=s.cnt;\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                d[s.dir][ny][nx]=s.cnt+1;\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) while(1){}\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n#define START 'S'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n\n  bool operator< (const Robot &r) const{return y!=r.y?y<r.y:(x!=r.x?x<r.x:dir<r.dir);}\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    map<Robot,long long int> visited;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited.count(me)){\n        long long int t = step-visited[me];\n        step = L - L%t;\n      }\n      visited[me]=step;\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar dc[]={'N','E','S','W'};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint change(char ch){\n  for(int i=0;i<4;i++)if(dc[i]==ch)return i;\n}\n\nint H,W,L,sx,sy,sdir;\nchar t[100][100];\nstring str;\n\nvoid input();\nvoid solve();\nvoid dfs(int,int,int,int);\n\nint main(){\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0&&W==0&&L==0)break;\n    input();\n    solve();\n  }\n  return 0;\n}\n\nvoid input(){\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      if(str[j]!='#'&&str[j]!='.'){\n\tt[i][j]='.';\n\tsy=i;\n\tsx=j;\n\tsdir=change(str[j]);\n      }else t[i][j]=str[j];\n    }\n  }  \n}\n\nint vd[100][100][4];\n\nvoid solve(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n\tvd[i][j][k]=-1;\n      }\n    }\n  }\n\n  dfs(sy,sx,sdir,0);\n}\n\n\nvoid dfs(int y,int x,int dir,int cnt){\n  dir%=4;\n\n  if(cnt==L){\n    cout<<y+1<<' '<<x+1<<' '<<dc[dir]<<endl;\n    return;\n  }\n  \n  if( L-cnt>=500 && vd[y][x][dir]!=-1 ){\n    int ncnt;\n    ncnt=(L-cnt)%(cnt-vd[y][x][dir]);\n    dfs(y,x,dir,ncnt);\n    return;\n  }\n\n  vd[y][x][dir]=cnt;\n  \n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0)dfs(y,x,dir+1,cnt);\n  else if(ny>=H||nx>=W)dfs(y,x,dir+1,cnt);\n  else if(t[ny][nx]=='#')dfs(y,x,dir+1,cnt);\n  else dfs(ny,nx,dir,cnt+1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nstruct state{\n  int x,y;\n  int c;\n  state(){}\n  state(int x,int y,int c):x(x),y(y),c(c){}\n};\nint h,w,l;\nchar g[111][111];\nstate next[111][111][5];\nbool used[111][111][5];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nchar D[256];\nchar DD[4];\nint main(void)\n{\n  D['N']=0; DD[0]='N';\n  D['E']=1; DD[1]='E';\n  D['S']=2; DD[2]='S';\n  D['W']=3; DD[3]='W';\n  for(;;){\n    scanf(\"%d%d%d\",&h,&w,&l); if(!h) break;\n    memset(used,0,sizeof(used));\n    int d,x,y;\n    memset(g,'#',sizeof(g));\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n        scanf(\" %c\",g[i]+j);\n        if(g[i][j]!='#' && g[i][j]!='.'){\n          x=j;\n          y=i;\n          d=D[int(g[i][j])];\n        }\n      }\n    }\n    vector<state> v;\n    for(;;){\n      int nx,ny,nd=d;\n      if(!l){\n        printf(\"%d %d %c\\n\",y,x,DD[d]);\n        goto NEXT;\n      }\n      if(used[y][x][d]){\n        v.push_back(state(x,y,d));\n        nx=x; ny=y; nd=d;\n        x=next[ny][nx][nd].x;\n        y=next[ny][nx][nd].y;\n        d=next[ny][nx][nd].c;\n        while(x!=nx || y!=ny || d!=nd){\n          int mx,my,md;\n          v.push_back(state(x,y,d));\n          mx=x; my=y; md=d;\n          x=next[my][mx][md].x;\n          y=next[my][mx][md].y;\n          d=next[my][mx][md].c;\n        }\n        l%=v.size();\n        printf(\"%d %d %c\\n\",v[l].y,v[l].x,DD[v[l].c]);\n        goto NEXT;\n      }\n      while(g[y+dy[nd]][x+dx[nd]]=='#'){\n        nd=(nd+1)%4;\n      }\n      nx=x+dx[nd];\n      ny=y+dy[nd];\n      used[y][x][d]=true;\n      next[y][x][d]=state(nx,ny,nd);\n      x=nx; y=ny; d=nd;\n      l--;\n    }\n  NEXT:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w;\nint sy, sx, dir;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar dd[4] = {'E', 'S', 'W', 'N'};\n\nbool can(int y, int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nint main() {\n\tll l;\n\twhile(cin >> h >> w >> l) {\n\t\tif(h == 0 && w == 0 && l == 0) break;\n\n\t\tvector<string> v(h);\n\t\trep(i, h) cin >> v[i];\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(v[i][j] == 'E') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'S') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 1;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'W') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'N') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 3;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll d[105][105][4];\n\t\tmemset(d, -1, sizeof(d));\n\n\t\tvector<int> X, Y, D;\n\t\tint y = sy, x = sx, cnt = 0;\n\n\t\trep(i, 4) {\n\t\t\tint ny = y + dy[(dir + i) % 4];\n\t\t\tint nx = x + dx[(dir + i) % 4];\n\n\t\t\tif(can(ny, nx) && v[ny][nx] == '.') {\n\t\t\t\tdir = (dir + i) % 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint pdir = dir;\n\t\td[y][x][dir] = cnt;\n\t\tcnt++;\n\n\t\twhile(l) {\n\t\t\ty = y + dy[dir];\n\t\t\tx = x + dx[dir];\n\t\t\tpdir = dir;\n\t\t\tl--;\n\n\t\t\trep(i, 4) {\n\t\t\t\tint ny = y + dy[(dir + i) % 4];\n\t\t\t\tint nx = x + dx[(dir + i) % 4];\n\n\t\t\t\tif(can(ny, nx) && v[ny][nx] == '.') {\n\t\t\t\t\tdir = (dir + i) % 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(d[y][x][dir] == -1) {\n\t\t\t\td[y][x][dir] = cnt;\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(l == 0) {\n\t\t\tcout << y + 1 << \" \" << x + 1 << \" \" << dd[pdir] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tll len = cnt - d[y][x][dir];\n\t\tl = l % len;\n\t\tdir = pdir;\n\n\t\trep(i, l) {\n\t\t\trep(j, 4) {\n\t\t\t\tint ny = y + dy[(dir + j) % 4];\n\t\t\t\tint nx = x + dx[(dir + j) % 4];\n\n\t\t\t\tif(can(ny, nx) && v[ny][nx] == '.') {\n\t\t\t\t\ty = ny; x = nx;\n\t\t\t\t\tdir = (dir + j) % 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << y + 1 << \" \" << x + 1 << \" \" << dd[dir] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define m make_pair\n#define se second\n#define f first\n#define N 105\nusing namespace std;\ntypedef long long ll;\ntypedef pair<char,ll> P;\nchar Rot(char);\n\nint main(){\n  ll h,w,y,x,t,flag;\n  char c;\n  string s[N];\n  P me[N][N];\n  ll l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tme[i][j].f='e';\n      }\n    t=0;\n    me[y][x]=m(c,t);\n    flag=0;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      if(l>100000000000000&&me[y][x].f==c&&flag==0) t=l-(l-me[y][x].se)%(t-me[y][x].se),flag=1;\n      me[ny][nx]=m(c,t);\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nstring ds=\"NESW\";\nint H,W,L;\nchar fld[111][111];\n\nint T[111][111][4];\n\nsigned main(){\n    while(cin>>H>>W>>L,W||H||L){\n        rep(i,H)cin>>fld[i];\n        memset(T,-1,sizeof(T));\n        int y,x,d;\n        rep(i,H)rep(j,W){\n            if(fld[i][j]!='.'&&fld[i][j]!='#'){\n                y=i;x=j;\n                d=find(all(ds),fld[i][j])-ds.begin();\n            }\n        }\n\n        T[y][x][d]=0;\n        while(true){\n            int ny,nx,nd=d;\n            while(true){\n                ny=y+dy[nd],nx=x+dx[nd];\n                if(ny>=0&&ny<H&&nx>=0&&nx<W&&fld[ny][nx]!='#')break;\n                nd=(nd+1)%4;\n            }\n            int c=T[y][x][d]+1;\n            if(c==L){\n                cout<<ny+1<<\" \"<<nx+1<<\" \"<<ds[nd]<<endl;\n                break;\n            }\n            if(T[ny][nx][nd]!=-1){\n                L-=T[ny][nx][nd];\n                int t=c-T[ny][nx][nd];\n                L%=t;\n                L+=T[ny][nx][nd];\n                rep(i,H)rep(j,W)rep(k,4){\n                    if(T[i][j][k]==L){\n                        cout<<i+1<<\" \"<<j+1<<\" \"<<ds[k]<<endl;\n                    }\n                }\n                break;\n            }\n            T[ny][nx][nd]=c;\n            y=ny;x=nx;d=nd;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint t[110][110][4];\nchar str[110][110];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint R[110000];\nint C[110000];\nchar D[110000];\nchar name[6]=\"ESWN\";\nint main(){\n\tint a,b;\n\tlong long c;\n\twhile(scanf(\"%d%d%lld\",&a,&b,&c),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++)t[i][j][k]=-1;\n\t\tint dir=0;\n\t\tint row=0;\n\t\tint col=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]!='#'&&str[i][j]!='.'){\n\t\t\t\trow=i;col=j;\n\t\t\t\tif(str[i][j]=='E')dir=0;\n\t\t\t\tif(str[i][j]=='S')dir=1;\n\t\t\t\tif(str[i][j]=='W')dir=2;\n\t\t\t\tif(str[i][j]=='N')dir=3;\n\t\t\t}\n\t\t}\n\t\tint now=0;\n\t\tint last=-1;\n\t\twhile(1){\n\t\t\tt[row][col][dir]=now;\n\t\t\tif(last!=now){\n\t\t\t\tR[now]=row;\n\t\t\t\tC[now]=col;\n\t\t\t\tD[now]=name[dir];\n\t\t\t\tlast=now;\n\t\t\t}\n\t\t\t//now++;\n\t\t\tint nr=row+dx[dir];\n\t\t\tint nc=col+dy[dir];\n\t\t\tif(nr<0||nc<0||nr>=a||nc>=b||str[nr][nc]=='#'){\n\t\t\t\tdir=(dir+1)%4;\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\trow=nr;\n\t\t\t\tcol=nc;\n\t\t\t\tnow++;\n\t\t\t}\n\t\t\tif(~t[row][col][dir]){\n\t\t\t\tif(now<=c)c=t[row][col][dir]+(c-t[row][col][dir])%(now-t[row][col][dir]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",R[c]+1,C[c]+1,D[c]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w, l, y, x, d, c;\nchar data[100][100];\nint vis[100][100][4];\nchar fd[100][100];\nstring dir = \"NESW\";\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return data[y][x] != '#';\n}\n\nvoid solve(){\n  int m, o;\n  bool f;\n  fill(vis[0][0], vis[100][0], -1);\n  for(;;){\n    if(vis[y][x][d] != -1){\n      if(vis[y][x][d]){\n        if(f){\n          o = vis[y][x][d] - 1;\n          m = c - vis[y][x][d];\n        }else{\n          o = vis[y][x][d] - 1;\n          m = c - vis[y][x][d] - 1;\n        }\n      }else{\n        if(f){\n          o = 0;\n          m = c;\n        }else{\n          o = 0;\n          m = c;\n        }\n      }\n      break;\n    }\n    //cout << y+1 << ' ' << x+1 << ' ' << dir[d] << ' ' << c << endl;\n    vis[y][x][d] = c;\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    if(!check(ny, nx)){\n      d = (d+1) % 4;\n      f = false;\n    }\n    else{\n      y = ny;\n      x = nx;\n      c++;\n      if(l == c){\n        cout << y+1 << ' ' << x+1 << ' ' << dir[d] << endl;\n        return;\n      }\n      f = true;\n    }\n  }\n  while(1){\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    if(check(ny, nx)){\n      y = ny;\n      x = nx;\n      break;\n    }else{\n      d = (d+1) % 4;\n    }\n  }\n  fill(fd[0], fd[100], ' ');\n  bool visited[100][100][4];\n  fill(visited[0][0], visited[100][0], false);\n  for(;;){\n    cout << y << ' ' << x << ' ' << d << endl;\n    if(visited[y][x][d]) break;\n    visited[y][x][d] = true;\n    if(fd[y][x] == ' ') fd[y][x] = dir[d];\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    if(!check(ny, nx)) d = (d+1) % 4;\n    else{\n      y = ny;\n      x = nx;\n      c++;\n    }\n  }\n  int t = l % m + o;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<4;k++){\n        if(vis[i][j][k] == t){\n          cout << i+1 << ' ' << j+1 << ' ' << fd[i][j] << endl;\n          return;\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> h >> w >> l && (h|w|l)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        for(int k=0;k<4;k++){\n          if(data[i][j] == dir[k]){\n            data[i][j] = '.';\n            y = i;\n            x = j;\n            d = k;\n            c = 0;\n          }\n        }\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#define MAX 200\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  ll i,j,k;\n  ll dp[MAX+1][MAX+1][4]={{{}}};\n  string st[MAX+1];\n  char c[]={'E','S','W','N'};\n  ll rx,ry,rd;\n  ll ax[]={1,0,-1,0};\n  ll ay[]={0,1,0,-1};\n  bool f;\n  ll s;\n  while(cin>>h>>w>>l,h||w||l){\n    for(i=0;i<=MAX;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    fill(dp[0][0],dp[MAX][MAX],0);\n    f = true;\n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(dp[ry][rx][rd]==0){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\ts = i - dp[ry][rx][rd];\n\tl=i+(l-i)%s;\n\tf=false;\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n    }\n    cout << ry << ' ' << rx << ' ' << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string hougaku = \"ESWN\";\n\nconst int MAXH = 128;\nint H, W;\nll L;\nstring field[MAXH];\nint num[4][MAXH][MAXH];\n\nint main(void) {\n    while (cin >> H >> W >> L) {\n        if (H == 0 && W == 0 && L == 0) break;\n        int y = 0, x = 0, dir = 0;\n        for (int i = 0; i < H; i++) {\n            cin >> field[i];\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] != '#' && field[i][j] != '.') {\n                    y = i; x = j;\n                    switch (field[i][j]) {\n                        case 'E':\n                            dir = 0;\n                            break;\n                        case 'S':\n                            dir = 1;\n                            break;\n                        case 'W':\n                            dir = 2;\n                            break;\n                        case 'N':\n                            dir = 3;\n                            break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                for (int k = 0; k < 4; k++) {\n                    num[k][i][j] = INF;\n                }\n            }\n        }\n        int cycle = 0, first = 0;\n        num[dir][y][x] = 0;\n        while (1) {\n            //cout << dir << \"  \" << y << \"  \" << x << endl;\n            int ny = y+dy[dir];\n            int nx = x+dx[dir];\n            if (ny < 0 || ny >= H || nx < 0 || nx >= W || field[ny][nx] == '#') {\n                int ndir = (dir + 1) % 4;\n                if (num[ndir][y][x] != INF) {\n                    cycle = num[dir][y][x] - num[ndir][y][x];\n                    first = num[ndir][y][x];\n                    break;\n                }\n                num[ndir][y][x] = num[dir][y][x];\n                dir = ndir;\n                continue;\n            }\n            if (num[dir][ny][nx] == INF) {\n                num[dir][ny][nx] = num[dir][y][x] + 1;\n                y = ny; x = nx;\n            } else {\n                cycle = num[dir][y][x] + 1 - num[dir][ny][nx];\n                first = num[dir][ny][nx];\n                break;\n            }\n        }\n        //cout << cycle << endl;\n        //cout << first << endl;\n        // ループがどうとか考えなくて良い場合\n        if (first+cycle > L) {\n            // LとL-1を探す\n            int yl, xl, yll, xll;\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < H; j++) {\n                    for (int l = 0; l < W; l++) {\n                        if (num[i][j][l] == L) {\n                            yl = j;\n                            xl = l;\n                        } else if (num[i][j][l] == L-1) {\n                            yll = j;\n                            xll = l;\n                        }\n                    }\n                }\n            }\n            //cout << yl << xl << yll << xll << endl;\n            int dd;\n            for (dd = 0; dd < 4; dd++) {\n                if (yll + dy[dd] == yl && xll + dx[dd] == xl) break;\n            }\n            cout << yl+1 << \" \" << xl+1 << \" \" << hougaku[dd] << endl;\n        } else {\n            L -= first;\n            L %= cycle;\n            int target = first + L;\n            int before = target - 1;\n            //cout << \"target is \" << target << endl;\n            if (before < 0) before = first + cycle-1;\n            // LとL-1を探す\n            int yl, xl, yll, xll;\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < H; j++) {\n                    for (int l = 0; l < W; l++) {\n                        if (num[i][j][l] == target) {\n                            yl = j;\n                            xl = l;\n                        } else if (num[i][j][l] == before) {\n                            yll = j;\n                            xll = l;\n                        }\n                    }\n                }\n            }\n            //cout << yl << xl << yll << xll << endl;\n            int dd;\n            for (dd = 0; dd < 4; dd++) {\n                if (yll + dy[dd] == yl && xll + dx[dd] == xl) break;\n            }\n            //cout << dd << endl;\n            cout << yl+1 << \" \" << xl+1 << \" \" << hougaku[dd] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstruct State{\n    int h,w,dir;\n};\n\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nmap<char,int> dmp={{'N',0},{'E',1},{'S',2},{'W',3}};\nstring dmpi=\"NESW\";\n\nvoid out(State st){\n    cout<<st.h<<\" \"<<st.w<<\" \"<<dmpi[st.dir]<<endl;\n}\n\nint solve(int H,int W,int L){\n    vector<string> f(H+2);\n    for(int i=0;i<W+2;i++){\n        f[0]+=\"#\";\n        f[H+1]+=\"#\";\n    }\n    State ini;\n    for(int i=0;i<H;i++){\n        cin>>f[i+1];\n        f[i+1]=\"#\"+f[i+1]+\"#\";\n        for(int j=0;j<W+2;j++){\n            if(dmp.count(f[i+1][j])){\n                ini=State{i+1,j,dmp[f[i+1][j]]};\n            }\n        }\n    }\n\n    vector<vector<vector<int>>> dp(H+2,vector<vector<int>>(W+2,vector<int>(4,-1)));\n    int lps=0;\n    State st=ini;\n    int cnt=0;\n    queue<State> que;\n    while(true){\n        if(cnt==L){\n            out(st);\n            return 0;\n        }\n        if(dp[st.h][st.w][st.dir]!=-1){\n            lps=cnt-dp[st.h][st.w][st.dir];\n            break;\n        }\n        dp[st.h][st.w][st.dir]=cnt;\n        if(f[st.h+dh[st.dir]][st.w+dw[st.dir]]=='#'){\n            st.dir=(st.dir+1)%4;\n            continue;\n        }\n        st.h+=dh[st.dir];\n        st.w+=dw[st.dir];\n        que.push(st);\n        cnt++;\n    }\n    L-=cnt+1;\n    vector<State> lpv;\n    while(que.size()>lps) que.pop();\n    while(!que.empty()) lpv.push_back(que.front()),que.pop();\n    while(lpv.size()!=lps) 1;\n    L%=lps;\n    out(lpv[L]);\n    return 0;\n}\nint main(){\n    int H,W,L;\n    while(cin>>H>>W>>L,H){\n        solve(H,W,L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  long long x,y,dir;\n  Pox(long long x=-1,long long y=-1,long long dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[101][101];\nlong long visited[100][100][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {   \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint dx[]= {-1,0,1,0};\nint dy[]= {0,1,0,-1};\nint main()\n{\n    int h,w,l,aa,bb,jj,i,j,ii;\n    char a[1000][1000];\n    long long n,count;\n    while(scanf(\"%d%d%d\",&h,&w,&n)!=EOF&&h+w+n)\n    {\n        getchar();\n        for(i=0; i<h; i++)\n        {\n            gets(a[i]);\n\n            for(j=0; j<w; j++)\n                if(a[i][j]!='.'&&a[i][j]!='#')\n                {\n                    aa=i;\n                    bb=j;\n                    break;\n                }\n        }\n\n\n        count=0;\n\n        if(a[aa][bb]=='E')\n        {\n\n            for(;;)\n            {\n                for(j=bb+1; j<w; j++)\n                {\n                    if(a[aa][j]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d E\\n\",aa+1,j+1);\n                    break;\n                }\n                j=j-1;\n\n                for( i=aa+1; i<h; i++)\n                {\n                    if(a[i][j]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d S\\n\",i+1,j+1);\n                    break;\n                }\n                i=i-1;\n\n                for( jj=j-1; jj>=0; jj--)\n                {\n                    if(a[i][jj]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d W\\n\",i+1,jj+1);\n                    break;\n                }\n                jj=jj+1;\n\n                for(ii=i-1; ii>=0; ii--)\n                {\n                    if(a[ii][jj]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d N\\n\",ii+1,jj+1);\n                    break;\n                }\n                ii=ii+1;\n\n                aa=ii;\n                bb=jj;\n\n            }\n\n        }\n        if(a[aa][bb]=='S')\n        {\n\n            for(;;)\n            {\n                for( i=aa+1; i<h; i++)\n                {\n                    if(a[i][bb]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d S\\n\",i+1,bb+1);\n                    break;\n                }\n                i=i-1;\n\n\n                for( j=bb-1; j>=0; j--)\n                {\n                    if(a[i][j]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d W\\n\",i+1,j+1);\n                    break;\n                }\n                j=j+1;\n\n                for(ii=i-1; ii>=0; ii--)\n                {\n                    if(a[ii][j]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d N\\n\",ii+1,j+1);\n                    break;\n                }\n                ii=ii+1;\n\n                for(jj=j+1; jj<w; jj++)\n                {\n                    if(a[ii][jj]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d E\\n\",ii+1,jj+1);\n                    break;\n                }\n\n                jj=jj-1;\n\n                aa=ii;\n                bb=jj;\n\n            }\n\n        }\n        if(a[aa][bb]=='N')\n        {\n            for(;;)\n            {\n                for( i=aa-1; i>=0; i--)\n                {\n                    if(a[i][bb]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d N\\n\",i+1,bb+1);\n                    break;\n                }\n                i=i+1;\n\n\n                for( j=bb+1; j<w; j++)\n                {\n                    if(a[i][j]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d E\\n\",i+1,j+1);\n                    break;\n                }\n                j=j+1;\n\n                for(ii=i+1; ii<h; ii++)\n                {\n                    if(a[ii][j]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d S\\n\",ii+1,j+1);\n                    break;\n                }\n                ii=ii-1;\n\n                for(jj=j-1; jj>=0; jj--)\n                {\n                    if(a[ii][jj]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d W\\n\",ii+1,jj+1);\n                    break;\n                }\n\n                jj=jj+1;\n\n                aa=ii;\n                bb=jj;\n\n            }\n\n        }\n        if(a[aa][bb]=='W')\n        {\n            for(;;)\n            {\n                for( j=bb-1; j>=0; j--)\n                {\n                    if(a[aa][j]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d W\\n\",aa+1,j+1);\n                    break;\n                }\n                j=j+1;\n\n\n                for( i=aa-1; i>=0; i--)\n                {\n                    if(a[i][j]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d N\\n\",i+1,j+1);\n                    break;\n                }\n                i=i+1;\n\n                for(jj=j+1; jj<w; jj++)\n                {\n                    if(a[i][jj]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d E\\n\",i+1,jj+1);\n                    break;\n                }\n                jj=jj-1;\n\n                for(ii=i+1; ii<w; ii++)\n                {\n                    if(a[ii][jj]!='#')\n                    {\n                        count++;\n                        if(count==n)\n                            break;\n                    }\n                    else\n                        break;\n                }\n                if(count==n)\n                {\n                    printf(\"%d %d S\\n\",ii+1,jj+1);\n                    break;\n                }\n\n                ii=ii-1;\n\n                aa=ii;\n                bb=jj;\n\n            }\n\n        }\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nll l;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nconst char *DIR=\"NESW\";\nint h,w;\nint fie[101][101];\nint sx,sy,sdir;\nll dp[101][101][4];\nvoid dfs(int x,int y,int dir,ll dist){\n\tif(dp[x][y][dir]!=-1){\n\t\tll loop=dist-dp[x][y][dir];\n\t\tll cnt=(l-dist)/loop;\n\t\tif(cnt>0)dist+=loop*(cnt-1);\n\t}\n\t//printf(\"%d %d %d %lld\\n\",x,y,dir,dist);\n\tdp[x][y][dir]=dist;\n\tif(dist==l){\n\t\tprintf(\"%d %d %c\\n\",y+1,x+1,DIR[dir]);\n\t\treturn;\n\t}\n\tint nx=x+dx[dir],ny=y+dy[dir];\n\tif(nx<0 || nx>=w || ny<0 || ny>=h){\n\t\tdfs(x,y,(dir+1)%4,dist);\n\t\treturn;\n\t}\n\tif(fie[nx][ny]==-1){\n\t\tdfs(x,y,(dir+1)%4,dist);\n\t\treturn;\n\t}\n\tdfs(nx,ny,dir,dist+1);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %lld\",&h,&w,&l);\n\t\tif(h+w+l==0)break;\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(str[j]==DIR[k]){\n\t\t\t\t\t\tfie[j][i]=0;\n\t\t\t\t\t\tsx=j;\n\t\t\t\t\t\tsy=i;\n\t\t\t\t\t\tsdir=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sx,sy,sdir,0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nenum {NORTH = 'N', EAST = 'E', SOUTH = 'S', WEST = 'W'};\ntypedef pair<int, int> Point;\n\n#define WALL '#'\n#define EMPTY '.'\n#define START 'S'\n\nstruct Robot{\n  Robot(int i=0, int j=0, int d=NORTH){y=i; x=j; dir=d;}\n\n  int y, x;\n  char dir;\n\n  Point next(){\n    return Point((dir==SOUTH)-(dir==NORTH), (dir==EAST)-(dir==WEST));\n  }\n  void move(){\n    y += next().first;\n    x += next().second;\n  }\n  void turn(){\n    switch(dir){\n    case NORTH:\n      dir = EAST;\n      break;\n    case EAST:\n      dir = SOUTH;\n      break;\n    case SOUTH:\n      dir = WEST;\n      break;\n    case WEST:\n      dir = NORTH;\n      break;\n    }\n  }\n};\n\nint main()\n{\n  long long int H, W, L;\n  map<char,int>DtoI;\n  DtoI['N']=0;\n  DtoI['E']=1;\n  DtoI['S']=2;\n  DtoI['W']=3;\n while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    long long int visited[102][102][4] = {0};\n    Robot me;\n    long long int step=0;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, c[i][j]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L-step>0){\n      if(int t=visited[me.y][me.x][DtoI[me.dir]]){\n        t++;\n        while(L > step+t){step += t;}\n      }\n      visited[me.y][me.x][DtoI[me.dir]] = step;\n\n      while(c[me.y + me.next().first][me.x + me.next().second] == WALL){\n        me.turn();\n      }\n      me.move();\n      step++;\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<me.dir<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define MAX 1000\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[MAX][MAX];\nint visited[MAX][MAX][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(true)\n    {\ncin >> H >> W >> L;\nif(H == 0 && W == 0 && L == 0)break;\n      if(H+W == 2)\n\tassert(false);\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {   \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define MAX 1000\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[MAX][MAX];\nint visited[MAX][MAX][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      assert(H <= 100);\n      assert(W <= 100);\n      assert(L <= 1000000000000000000LL);\n\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,line.size())\n\t    {\n\t      assert(j < W);\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    { \n\t      /*  \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      */\n\n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      //cout << \"L = \" << L << \" dir = \" << dir << endl;\n\t      for(int i=0;i<L;i++)\n\t\t{\n\t\t  src.F += dx[dir];\n\t\t  src.S += dy[dir];\n\t\t  \n\t\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\n\t\t  else if(G[src.S][src.F] == '#')\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\t\n\t\t}\n\t      move(H,W,src.F,src.S,dir);\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct State{\n\tint y,x,dir;\n};\n\nvoid Solve(){\n\twhile(true){\n\t\tint h,w,l;\n\t\tcin >> h >> w >> l;\n\t\tif(h==0&&w==0&&l==0) break;\n\t\tvector<string> cells(h);\n\t\tREP(i,0,h) cin >> cells[i];\n\n\t\tconst char empty='.',wall='#';\n\t\tconst int north=0,east=1,south=2,west=3;\n\t\tint y,x,dir;\n\t\tREP(i,0,h) REP(j,0,w) if(cells[i][j]!=empty&&cells[i][j]!=wall){\n\t\t\ty=i; x=j;\n\t\t\tswitch(cells[i][j]){\n\t\t\t\tcase 'N': dir=north; break;\n\t\t\t\tcase 'E': dir=east; break;\n\t\t\t\tcase 'S': dir=south; break;\n\t\t\t\tcase 'W': dir=west; break;\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t\tcells[i][j]=empty;\n\t\t\tbreak;\n\t\t}\n\n\t\tint rotate[4];\n\t\tREP(i,0,4) rotate[i]=(i+1)%4;\n\n\t\tconst int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\t\tState memo[100][100][4];\n\t\tREP(i,0,h) REP(j,0,w) REP(k,0,4){\n\t\t\tint y_=i,x_=j;\n\t\t\tint ny=y_+dy[k],nx=x_+dx[k];\n\t\t\twhile(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty){\n\t\t\t\ty_=ny; x_=nx;\n\t\t\t\tny=y_+dy[k]; nx=x_+dx[k];\n\t\t\t}\n\t\t\tmemo[i][j][k]={y_,x_,rotate[k]};\n\t\t}\n\n\t\tint cnt=0;\n\t\twhile(cnt<l){\n\t\t\tState &m=memo[y][x][dir];\n\t\t\tint dist=abs(y-m.y)+abs(x-m.x);\n\n\t\t\tif(cnt+dist>=l){\n\t\t\t\ty+=(m.y-y)*(l-cnt)/dist;\n\t\t\t\tx+=(m.x-x)*(l-cnt)/dist;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ty=m.y;\n\t\t\tx=m.x;\n\t\t\tdir=m.dir;\n\t\t\tcnt+=dist;\n\t\t}\n\n\t\tcout << y+1 << ' ' << x+1 << ' ' << \"NESW\"[dir] << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n\n  bool operator< (Robot r) const{return y!=r.y?y<r.y:(x!=r.x?x<r.x:dir<r.dir);}\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    map<Robot,int> visited;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    // for(int i=0; i<=H+1; i++){\n    //   for(int j=0; j<=W+1; j++){\n    //     cout<<\" \"<<c[i][j];\n    //   }\n    //   cout<<endl;\n    // }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited.count(me)){\n        long long int t = step-visited[me];\n        step = L - L%t;\n        // cout<<\"+\"<<endl;\n      }else{\n        visited[me] = step;\n      }\n      step++;\n      me.move();\n      // cout<<step<<endl;\n      // cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nchar c[110][110];\nint d[110][110][4];\nint h, w, l;\nstring str = \"NESW\";\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nbool contain(int y, int x){\n\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> h >> w >> l;\n        if(h + w + l == 0) break;\n        int dr = 0, y = 0, x = 0;\n        rep(i, 0, h) rep(j, 0, w) rep(k, 0, 4) d[i][j][k] = -1;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> c[i][j];\n                if(str.find(c[i][j]) != string::npos){\n                    dr = str.find(c[i][j]);\n                    y = i; x = j;\n                }\n            }\n        }\n        // cerr << dr << endl;\n        d[y][x][dr] = 0;\n        vector<PP> sv;\n        sv.push_back(PP(P(y, x), dr));\n        for(int i = 1;; i++){\n            int ny = 0, nx = 0;\n            // cerr << i << ' ' << ny << ' ' << nx << ' ' << dr << endl;\n            for(int j = 0;; j++){\n                ny = y + dy[dr];\n                nx = x + dx[dr];\n                if(contain(ny, nx) && c[ny][nx] != '#'){\n                    break;\n                }\n                dr = (dr + 1) % 4;\n                // cerr << dr << endl;\n            }\n            y = ny; x = nx;    \n            if(i == l){\n                cout << y + 1 << ' ' << x + 1 << ' ' << str[dr] << endl;\n                break;\n            }        \n            if(d[y][x][dr] != -1){\n                int loop = i - d[y][x][dr];\n                int step = d[y][x][dr] + (l - d[y][x][dr]) % loop;\n                // cerr << loop << ' ' << step << endl;\n                cout << sv[step].first.first + 1 << ' ' << sv[step].first.second + 1 << ' ' << str[sv[step].second] << endl;\n                break;\n            }\n            d[y][x][dr] = i;\n            sv.push_back(PP(P(y, x), dr));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {1,0,-1,0};\nconst static int ty[] = {0,1,0,-1};\nconst static char dir_char[] = {'E','S','W','N'};\n \nenum dir {\n  EAST,\n  SOUTH,\n  WEST,\n  NORTH\n};\n\nstatic const double EPS = 1e-8;\n\nvoid printStage(char stage[100][100],int H,int W,\n\t\tint current_x,int current_y,int current_dir){\n\n  char output[100][100];\n\n  //init\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      output[y][x] = '.';\n    }\n  }\n\n  //wall\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(stage[y][x] == '#'){\n\toutput[y][x] = '#';\n      }\n    }\n  }\n\n  //robot\n  output[current_y][current_x] = dir_char[current_dir];\n\n  //write\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      printf(\"%c\",output[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int H,W;\n  ll L;\n  while(~scanf(\"%d %d %ld\",&H,&W,&L)){\n    if(H == 0 && W == 0 && L == 0) break;\n\n    char stage[100][100];\n\n    int current_dir = NORTH;\n    int current_x = 0;\n    int current_y = 0;\n\n    for(int y=0;y<H;y++){\n      char line[120];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] == 'E'){\n\t  current_dir = EAST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'S'){\n\t  current_dir = SOUTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'W'){\n\t  current_dir = WEST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'N'){\n\t  current_dir = NORTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n      }\n    }\n\n    vector<ll> dp[100][100][4];\n    int TTL = 10000000;\n    int MAX_TTL = 10000000;\n    while(TTL-- > 0){\n      int dx = current_x + tx[current_dir];\n      int dy = current_y + ty[current_dir];\n\n      // printStage(stage,H,W,current_x,current_y,current_dir);\n      // cout << dx << \" \" << dy << \" \" << endl;\n      if(dy < 0 || dy >= H || dx < 0 || dx >= W){\n\tcurrent_dir = (current_dir + 1) % 4;\n\tTTL++;\n\tcontinue;\n      }\n      else if(stage[dy][dx] == '#'){\n\tcurrent_dir = (current_dir + 1) % 4;\n\tTTL++;\n\tcontinue;\n      }\n      current_x = dx;\n      current_y = dy;\n      dp[current_x][current_y][current_dir].push_back(MAX_TTL-TTL);\n    }\n\n    int res_x = 0;\n    int res_y = 0;\n    int res_dir = 0;\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tfor(int i=0;i<4;i++){\n\t  if(dp[x][y][i].size() < 2) continue;\n\t  ll a0 = dp[x][y][i][0];\n\t  ll a1 = dp[x][y][i][1];\n\t  // L == a0 + k(a1-a0)\n\t  // L - a0 == k(a1-a0)\n\t  // k == (L - a0) / (a1 - a0)\n\n\t  if(L - a0 < 0) continue;\n\t  if(a1 - a0 <= 0) continue;\n\n\t  if((L-a0) % (a1-a0) == 0){\n\t    res_x = x;\n\t    res_y = y;\n\t    res_dir = i;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d %d %c\\n\",res_y+1,res_x+1,dir_char[res_dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 105\nusing namespace std;\ntypedef long long ll;\nchar Rot(char);\nint GetNum(char);\n\nint main(){\n  int h,w,y,x,r,me[N][N][4],ansy,ansx,flag;\n  char c;\n  string s[N];\n  ll l,t;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tfor(int k=0;k<4;k++) me[i][j][k]=-1;\n      }\n    t=0;\n    r=GetNum(c);\n    me[y][x][r]=t;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      t++;\n      flag=0;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') flag=1;\n      if(t==l&&!flag){\n\tansy=ny+1,ansx=nx+1;\n\tbreak;\n      }\n      if(!flag&&me[ny][nx][r]!=-1&&t-me[ny][nx][r]!=0){\n\tt=l-((l-me[ny][nx][r])%(t-me[ny][nx][r]));\n\tif(l-t==0){\n\t  ansy=ny+1,ansx=nx+1;\n\t  break;\n\t}\n      }\n      if(flag) ny=y,nx=x,c=Rot(c),t--;\n      y=ny,x=nx;\n      r=GetNum(c);      \n      me[ny][nx][r]=t;\n    }\n    cout<<ansy<<' '<<ansx<<' '<<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}\n\nint GetNum(char c){\n  if(c=='N') return 0;\n  if(c=='E') return 1;\n  if(c=='S') return 2;\n  return 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct sta{\n  int x;\n  int y;\n  int d;\n};\n\nint main(){\n  while(1){\n    int h,w;\n    LL l;\n    cin >> h >> w >> l;\n    if(h==0) return 0;\n    vector<string> f(h);\n    rep(i,h) cin >> f[i];\n    int sx,sy,d;\n    rep(i,h){\n      rep(j,w){\n        if(f[i][j]!='.'&&f[i][j]!='#'){\n          sx=i,sy=j;\n          if(f[i][j]=='N') d=0;\n          else if(f[i][j]=='E') d=1;\n          else if(f[i][j]=='S') d=2;\n          else d=3;\n          f[i][j]='.';\n          break;\n        }\n      }\n    }\n    vector<int> vx={-1,0,1,0};\n    vector<int> vy={0,1,0,-1};\n    vector<vector<vector<vector<sta>>>> nxt(h,vector<vector<vector<sta>>>(w,vector<vector<sta>>(4,vector<sta>(64))));\n    rep(i,h){\n      rep(j,w){\n        rep(k,4){\n          nxt[i][j][k][0]={0,0,0};\n          if(f[i][j]=='#') continue;\n          int nowd=k;\n          rep(l,4){\n            int nx = i+vx[nowd];\n            int ny = j+vy[nowd];\n            if(0<=nx&&nx<h&&0<=ny&&ny<w){\n              if(f[nx][ny]!='#'){\n                nxt[i][j][k][0]={nx,ny,nowd};\n                break;\n              }\n            }\n            nowd=(nowd+1)%4;\n          }\n        }\n      }\n    }\n    repp(t,1,64){\n      rep(i,h){\n        rep(j,w){\n          rep(k,4){\n            auto &st = nxt[i][j][k][t-1];\n            auto &st2 = nxt[st.x][st.y][st.d][t-1];\n            nxt[i][j][k][t]=st2;\n          }\n        }\n      }\n    }\n    int c=0;\n    while(l){\n      if(l&1LL){\n        auto &st = nxt[sx][sy][d][c];\n        sx = st.x;\n        sy = st.y;\n        d = st.d;\n      }\n      l>>=1;\n      c++;\n    }\n    cout << sx+1 SP sy+1 << \" \";\n    if(d==0) cout << 'N';\n    else if(d==1) cout << 'E';\n    else if(d==2) cout << 'S';\n    else cout << 'W';\n    cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <iostream>\ntypedef long long ll;\nint dx[] = { 0,1,0,-1 }, dy[] = {-1, 0, 1, 0};\n\nusing namespace std;\nint main() {\n    ll H, W, L;\n    while (cin >> H >> W >> L, H) {\n        string field[100];\n        for (int i = 0; i < H; i++) {\n            cin >> field[i];\n        }\n\n        int x, y, dir;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == 'N') x = j, y = i, dir = 0;\n                if (field[i][j] == 'E') x = j, y = i, dir = 1;\n                if (field[i][j] == 'S') x = j, y = i, dir = 2;\n                if (field[i][j] == 'W') x = j, y = i, dir = 3;\n            }\n        }\n\n        ll memo[100][100][4];\n        memset(memo, -1, sizeof memo);\n        memo[y][x][dir] = 0;\n\n        ll c = 0, rem = L;\n        while (rem > 0) {\n            int nx = x + dx[dir], ny = y + dy[dir];\n            while (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] == '#') {\n                dir = (dir + 1) % 4;\n                nx = x + dx[dir], ny = y + dy[dir];\n            }\n\n            c++;\n            rem--;\n            x = nx;\n            y = ny;\n\n            if (memo[y][x][dir] == -1){\n                memo[y][x][dir] = c;\n            }\n            else {\n                ll loop = c - memo[y][x][dir];\n                if (rem >= loop) rem %= loop;\n            }\n        }\n\n        string s = \"NESW\";\n        cout << y + 1 << \" \" << x + 1 << \" \" << s[dir] << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nint dh[] = { -1,0,1,0 };\nint dw[] = { 0,1,0,-1 };\nvoid solve() {\n\tint H, W; cin >> H >> W; if (H == 0) exit(0);\n\tll L; cin >> L;\n\tvector<string> vs(H); for (int i = 0; i < H; i++) cin >> vs[i];\n\tvector<vector<int>> to(62, vector<int>(H * W * 4));\n\tfor (int i = 0; i < H * W * 4; i++) {\n\t\tint d = i / (H * W);\n\t\tint h = (i % (H * W) / W);\n\t\tint w = i % W;\n\t\tint nd = d;\n\t\tint nh = h + dh[nd];\n\t\tint nw = w + dw[nd];\n\t\tif (vs[h][w] == '#') continue;\n\t\tint cnt = 0;\n\t\twhile (nh < 0 or nh >= H or nw < 0 or nw >= W or vs[nh][nw] == '#') {\n\t\t\tcnt++;\n\t\t\tif (cnt >= 5) break;\n\t\t\tnd += 1; if (nd >= 4) nd -= 4;\n\t\t\tnh = h + dh[nd];\n\t\t\tnw = w + dw[nd];\n\t\t}\n\t\tto[0][i] = nd * H * W + nh * W + nw;\n\t\tif (cnt >= 5) to[0][i] = 0;\n\t}\n\tfor (int i = 1; i < 62; i++) for (int j = 0; j < H * W * 4; j++) to[i][j] = to[i - 1][to[i - 1][j]];\n\tchar c[] = { 'N','E','S','W' };\n\tfor (int i = 0; i < H; i++)for (int j = 0; j < W; j++) for (int k = 0; k < 4; k++) {\n\t\tif (vs[i][j] == c[k]) {\n\t\t\tint s = k * H * W + i * W + j;\n\t\t\tfor (int bit = 0; bit < 62; bit++) {\n\t\t\t\tif (L >> bit & 1) {\n\t\t\t\t\ts = to[bit][s];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint d = s / (H * W);\n\t\t\tint h = (s % (H * W)) / W;\n\t\t\tint w = s % W;\n\t\t\tcout << h + 1 << \" \" << w + 1 << \" \" << c[d] << \"\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct State{\n\tint y,x,dir;\n};\n\nvoid Solve(){\n\twhile(true){\n\t\tll h,w,l;\n\t\tcin >> h >> w >> l;\n\t\tif(h==0&&w==0&&l==0) break;\n\t\tvector<string> cells(h);\n\t\tREP(i,0,h) cin >> cells[i];\n\n\t\tconst char empty='.',wall='#';\n\t\tconst int north=0,east=1,south=2,west=3;\n\t\tint y,x,dir;\n\t\tREP(i,0,h) REP(j,0,w) if(cells[i][j]!=empty&&cells[i][j]!=wall){\n\t\t\ty=i; x=j;\n\t\t\tswitch(cells[i][j]){\n\t\t\t\tcase 'N': dir=north; break;\n\t\t\t\tcase 'E': dir=east; break;\n\t\t\t\tcase 'S': dir=south; break;\n\t\t\t\tcase 'W': dir=west; break;\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t\tcells[i][j]=empty;\n\t\t\tbreak;\n\t\t}\n\n\t\tint rotate[4];\n\t\tREP(i,0,4) rotate[i]=(i+1)%4;\n\n\t\t//State memo[100][100][4];\n\t\t//REP(i,0,h) REP(j,0,w) REP(k,0,4){\n\t\t\t//int y_=i,x_=j;\n\t\t\t//int ny=y_+dy[k],nx=x_+dx[k];\n\t\t\t//while(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty){\n\t\t\t\t//y_=ny; x_=nx;\n\t\t\t\t//ny=y_+dy[k]; nx=x_+dx[k];\n\t\t\t//}\n\t\t\t//memo[i][j][k]={y_,x_,rotate[k]};\n\t\t//}\n\n\t\tconst int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\t\tll visited[100][100][4];\n\t\tfill_n((ll*)visited,100*100*4,-1);\n\t\tll cnt=0;\n\t\twhile(cnt<l){\n\t\t\tdump(y);\n\t\t\tdump(x);\n\t\t\tif(visited[y][x][dir]==-1) visited[y][x][dir]=cnt;\n\t\t\telse{\n\t\t\t\tll tmp=0; \n\t\t\t\twhile(cnt+tmp+cnt-visited[y][x][dir]<=l) tmp+=(cnt-visited[y][x][dir]);\n\t\t\t\tcnt+=tmp;\n\t\t\t\tif(cnt==l) break;\n\t\t\t}\n\t\t\t\n\t\t\tint ny=y+dy[dir],nx=x+dx[dir];\n\t\t\twhile(!(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty)){\n\t\t\t\tdir=rotate[dir];\n\t\t\t\tny=y+dy[dir]; nx=x+dx[dir];\n\t\t\t}\n\t\t\ty=ny; x=nx; ++cnt;\n\t\t}\n\n\t\tcout << y+1 << ' ' << x+1 << ' ' << \"NESW\"[dir] << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W;\nll L;\nvector<string> maze;\nvector<vector<vector<int> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<int> >(W, vector<int>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    ll T = min(L, H * W * 4LL);\n    for(int step=0; step<=T;){\n        if(vis[x][y][d] != -1){\n            L = vis[x][y][d] + (L - step) % (step - vis[x][y][d]);\n            break;\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        if(!inrect(nx, ny) || maze[nx][ny] == '#')(d += 1) %= 4;\n        else x = nx, y = ny, step++;\n    }\n    tuple<int, int, char> res;\n    rep(i, H)rep(j, W)rep(k, 4){\n        if(vis[i][j][k] == L && vis[i][j][(k+3)%4] != L){\n            res = make_tuple(i+1, j+1, \"NESW\"[k]);\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\n//int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2320 : Infinity Maze **/\ntypedef long long int ll;\nll dd[100][100][4];\nchar board[100][100];\nint H, W;\nll L;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n\nint main()\n{\n\tstring label = \"NESW\";\n\t\n\twhile (cin>>H>>W>>L, H||W||L) {\n\t\tint d, l=0, sx, sy;\n\t\tmemset(dd, -1, sizeof(dd));\n\t\t\n\t\trep(y, H) {\n\t\t\trep(x, W) {\n\t\t\t\tchar c; cin>>c;\n\t\t\t\tboard[x][y] = c;\n\n\t\t\t\tif (c!='.' && c!= '#') {\n\t\t\t\t\tif (c=='N') {\n\t\t\t\t\t\td = 0;\n\t\t\t\t\t} else if (c=='E') {\n\t\t\t\t\t\td = 1;\n\t\t\t\t\t} else if (c=='S') {\n\t\t\t\t\t\td = 2;\n\t\t\t\t\t} else if (c=='W') {\n\t\t\t\t\t\td = 3;\n\t\t\t\t\t}\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdd[sx][sy][d] = 0;\n\t\t\n\t\tll t=0; bool find=false;\n\t\twhile (L>0) {\n\t\t\tint nx = sx+dx[d], ny = sy+dy[d];\n\t\t\t\n\t\t\tif_range(nx, ny, W, H) {\n\t\t\t\tif (!find && dd[nx][ny][d]>=0) {\n\t\t\t\t\tL %= (++t - dd[nx][ny][d]);\n\t\t\t\t\tfind = true;\n\t\t\t\t} else if (board[nx][ny]!='#') {\n\t\t\t\t\tsx = nx; sy = ny;\n\t\t\t\t\tL--; t++;\n\t\t\t\t\tdd[sx][sy][d] = t;\n\t\t\t\t} else {\n\t\t\t\t\td++; d%=4;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\td++; d%=4;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tcout << sy+1 << \" \" << sx+1 << \" \" << label[d] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define m make_pair\n#define se second\n#define f first\n#define N 100\nusing namespace std;\ntypedef pair<char,int> P;\ntypedef long long ll;\nchar Rot(char);\n\nint main(){\n  int h,w,y,x,t;\n  char c;\n  string s[N];\n  P me[N][N];\n  ll l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tme[i][j].f='e';\n      }\n    t=0;\n    me[y][x]=m(c,t);\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      if(me[y][x].f==c) t=l-(l-me[y][x].se)%(t-me[y][x].se);\n      me[ny][nx]=m(c,t);\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(long long h,w,l;cin>>h>>w>>l,h|w|l;){\n    bool s[102][102]={};\n    int x,y,d;\n    string ds=\"NESW\";\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tchar c;\n\tcin>>c;\n\ts[i][j]=c!='#';\n\tif(c!='#'&&c!='.'){\n\t  x=j;\n\t  y=i;\n\t  d=ds.find(c);\n\t}\n      }\n    }\n    long long p[102][102][4];\n    fill(p[0][0],p[102][0],-1);\n    while(l){\n      int dx[]={0,1,0,-1};\n      int dy[]={-1,0,1,0};\n      for(;;){\n\tif(s[y+dy[d]][x+dx[d]])break;\n\td=(d+1)%4;\n      }\n      y+=dy[d];\n      x+=dx[d];\n      l--;\n      if(p[y][x][d]!=-1){\n\tl%=p[y][x][d]-l;\n      }\n      p[y][x][d]=l;\n    }\n    cout<<y<<' '<<x<<' '<<ds[d]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint dx[4]   = {-1, 0, 1, 0};\nint dy[4]   = {0, 1, 0, -1};\n\nchar field[110][110];\nll memo[110][110][4];\n\nint main(){\n  ll H, W, L;\n  while(cin >>H >> W >> L && H + W + L){\n    \n    fill(&field[0][0], &field[0][0] + 110 * 110, '#');\n    memset(memo, -1, sizeof(memo));\n    \n    int x, y, d;\n    REP(i, H)REP(j, W){\n      cin >> field[i+1][j+1];\n      if(isalpha(field[i+1][j+1])){\n        x = i + 1;\n        y = j + 1;\n        d = find(dir, dir + 4, field[i+1][j+1]) - dir;\n      }\n    }\n\n    ll T = 0;\n    bool flag = false;\n    while(L > 0){\n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      while(field[nx][ny] == '#'){\n        d = (d + 1) % 4;\n        nx = x + dx[d];\n        ny = y + dy[d];\n      }\n      \n      if(memo[x][y][d] >= 0 && !flag){\n        ll S = T - memo[x][y][d];\n        L %= S;\n        flag = true;\n      }\n      memo[x][y][d] = T++;\n      x = nx;\n      y = ny;\n      L--;\n    }\n    cout << x<< \" \" << y<< \" \" << dir[d] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nll l;\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nconst char *DIR=\"NESW\";\nint h,w;\nint fie[101][101];\nint sx,sy,sdir;\nll dp[101][101][4];\nvoid dfs(int x,int y,int dir,ll dist){\n\tif(dp[x][y][dir]!=-1){\n\t\tll loop=dist-dp[x][y][dir];\n\t\tll cnt=(l-dist)/loop;\n\t\tdist+=loop*cnt;\n\t}\n\t//printf(\"%d %d %d %lld\\n\",x,y,dir,dist);\n\tdp[x][y][dir]=dist;\n\tif(dist==l){\n\t\tprintf(\"%d %d %c\\n\",y+1,x+1,DIR[dir]);\n\t\treturn;\n\t}\n\tint nx=x+dx[dir],ny=y+dy[dir];\n\tif(nx<0 || nx>=w || ny<0 || ny>=h){\n\t\tdfs(x,y,(dir+1)%4,dist);\n\t\treturn;\n\t}\n\tif(fie[nx][ny]==-1){\n\t\tdfs(x,y,(dir+1)%4,dist);\n\t\treturn;\n\t}\n\tdfs(nx,ny,dir,dist+1);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d %lld\",&h,&w,&l);\n\t\tif(h+w+l==0)break;\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(str[j]==DIR[k]){\n\t\t\t\t\t\tfie[j][i]=0;\n\t\t\t\t\t\tsx=j;\n\t\t\t\t\t\tsy=i;\n\t\t\t\t\t\tsdir=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(sx,sy,sdir,0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W, L;\nvector<string> maze;\nvector<vector<vector<int> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<int> >(W, vector<int>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    int p = L;\n    for(int step=0; step<=H*W;){\n        if(vis[x][y][d] != -1){\n            p = vis[x][y][d] + (L - step) % (step - vis[x][y][d]);\n            break;\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        if(!inrect(nx, ny) || maze[nx][ny] == '#')(d += 1) %= 4;\n        else x = nx, y = ny, step++;\n    }\n    // rep(i, H){rep(k, 4){rep(j, W)cout << vis[i][j][k] << ' '; cout << \" |  \";} cout << '\\n';}\n    // FIX LINE (this can't be accepted)\n    rep(i, H)rep(j, W)rep(k, 4)if(vis[i][j][k] == p)return make_tuple(i+1, j+1, \"NESW\"[k]);\n    return make_tuple(-1, -1, '?');\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nvi dh = {0, 1, 0, -1};\nvi dw = {1, 0, -1, 0};\nint h = -1, w = -1;\nll l = -1;\nvector<vector<bool>> maze;\nvector<vector<vector<int>>> sel;\npair<P, ll> move(P now, int dir, ll res) {\n  int nowh = now.first, noww = now.second;\n  do {\n    nowh += dh[dir];\n    noww += dw[dir];\n    res--;\n  } while(0 <= nowh && nowh < h &&\n        0 <= noww && noww < w &&\n        res >= 0 && !maze[nowh][noww]);\n  nowh -= dh[dir];\n  noww -= dw[dir];\n  res++;\n  return {{nowh, noww}, res};\n}\npair<P, int> solve(P now, int dir, ll res) {\n  pair<P, ll> ans = {now, res};\n  ll su = 0;\n  while(sel[now.first][now.second][dir] == -1) {\n    sel[now.first][now.second][dir] = su;\n    ans = move(now, dir, res);\n    su += res - ans.second;\n    now = ans.first;\n    res = ans.second;\n    if(res == 0) return {now, dir};\n    dir++; dir %= 4;\n  }\n  res %= (su - sel[now.first][now.second][dir]);\n  sel[now.first][now.second][dir] = su;\n  if(res == 0) {\n    while(1) {\n      int nowdir = (dir + 3) % 4;\n      if(sel[now.first][now.second][dir] != sel[now.first][now.second][nowdir]) break;\n      else dir = nowdir;\n    }\n    return {now, (dir + 3) % 4};\n  }\n  while(1) {\n    ans = move(now, dir, res);\n    now = ans.first;\n    res = ans.second;\n    if(res == 0) return {now, dir};\n    dir++; dir %= 4;\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    cin >> h >> w >> l;\n    if(h == 0 && w == 0 && l == 0) break;\n    maze.clear();\n    maze.resize(h, vector<bool>(w, 0));\n    sel.clear();\n    sel.resize(h, vector<vector<int>>(w, vector<int>(4, -1)));\n    int sh = -1, sw = -1;\n    int sdir = -1;\n    for(int i=0;i<h;++i) {\n      for(int j=0;j<w;++j) {\n        char tmp; cin >> tmp;\n        if(tmp == '#') maze[i][j] = true;\n        else if(tmp != '.') {\n          sh = i;\n          sw = j;\n          if(tmp == 'E') sdir = 0;\n          else if(tmp == 'S') sdir = 1;\n          else if(tmp == 'W') sdir = 2;\n          else if(tmp == 'N') sdir = 3;\n        }\n      }\n    }\n    assert(0 <= sh && sh < h);\n    assert(0 <= sw && sw < w);\n    assert(0 <= sdir && sdir < 4);\n    pair<P, int> ans = solve({sh, sw}, sdir, l);\n    char ansdir;\n    if(ans.second == 0) ansdir = 'E';\n    else if(ans.second == 1) ansdir = 'S';\n    else if(ans.second == 2) ansdir = 'W';\n    else ansdir = 'N';\n    cout << ans.first.first + 1 << \" \" << ans.first.second + 1 << \" \" << ansdir << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\ntypedef pair< int, int > pii;\ntypedef pair< pii, int > piii;\n\nint H, W, L, dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nstring grid[110];\n\nint ctd(char c) {\n\tint res = 0;\n\tif (c == 'E') res = 1;\n\tif (c == 'S') res = 2;\n\tif (c == 'W') res = 3;\n\treturn res;\n}\n\nchar dtc(int d) {\n\tchar res = 'N';\n\tif (d == 1) res = 'E';\n\tif (d == 2) res = 'S';\n\tif (d == 3) res = 'W';\n\treturn res;\n}\n\nbool able(int x, int y) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return false;\n\treturn grid[y][x] == '.';\n}\n\nint main() {\n\twhile (cin >> H >> W >> L, H) {\n\t\tint x = 0, y = 0, d = 0;\n\t\t\n\t\tfor_(i,0,H) {\n\t\t\tcin >> grid[i];\n\t\t\tfor_(j,0,W) if (grid[i][j] != '.' && grid[i][j] != '#') {\n\t\t\t\tx = j; y = i;\n\t\t\t\td = ctd(grid[i][j]);\n\t\t\t\tgrid[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\t\n\t\tset< piii > visit;\n\t\tvector< piii > root;\n\t\twhile (visit.find(piii(pii(y, x), d)) == visit.end()) {\n\t\t\tvisit.insert(piii(pii(y, x), d));\n\t\t\troot.push_back(piii(pii(y, x), d));\n\t\t\twhile (!able(x+dx[d], y+dy[d])) d = (d + 1) % 4;\n\t\t\tx += dx[d]; y += dy[d];\n\t\t}\n\t\t\n\t\tint ind = -1, roots = root.size();\n\t\tfor_(i,0,roots) if (root[i] == piii(pii(y, x), d)) { ind = i; break; }\n\t\t\n\t\tint id = ((L - ind) % (roots - ind)) + ind;\n\t\tpiii ans = root[id];\n\t\tcout << ans.first.first + 1 << \" \" << ans.first.second + 1 << \" \" << dtc(ans.second) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int H, W;\n  ll L;\n  string NESW = \"NESW\";\n  int dx[4] = {0, 1, 0, -1};\n  int dy[4] = {-1, 0, 1, 0};\n  while(cin>>H>>W>>L && H){\n    vector<string> grid(H);\n    REP(i, H)cin>>grid[i];\n    int nx, ny, dir;\n    REP(y, H)REP(x, W)REP(r, 4)if(grid[y][x] == NESW[r]){\n      nx = x, ny = y, dir = r;\n    }\n    int memo[100][100][4];\n    memset(memo, -1, sizeof(memo));\n    for(int time = 0; time < L; time++){\n      if(~memo[ny][nx][dir]){\n        int base = memo[ny][nx][dir];\n        int cycle = time - base;\n        int ans = (L - base) % cycle + base;\n        REP(y, H)REP(x, W)REP(r, 4)if(memo[y][x][r] == ans){\n          ny = y, nx = x, dir = r;\n        }\n        break;\n      }else{\n        memo[ny][nx][dir] = time;\n        while(true){\n          int nextx = nx + dx[dir], nexty = ny + dy[dir];\n          if(nextx >= 0 && nextx < W && nexty >= 0 && nexty < H && grid[nexty][nextx] != '#'){\n            nx = nextx, ny = nexty;\n            break;\n          }else{\n            dir = (dir + 1) % 4;\n          }\n        }\n      }\n    }\n    printf(\"%d %d %c\\n\", ny + 1, nx + 1, NESW[dir]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct RobotState\n{\n    int x;\n    int y;\n    char direction;\n};\n\nvoid DirectToEmptyCell(const vector<vector<char>> &maze, RobotState &robot)\n{\n    while (true)\n    {\n        switch (robot.direction)\n        {\n        case 'N':\n            if (maze[robot.y - 1][robot.x] == '#')\n            {\n                robot.direction = 'E';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'E':\n            if (maze[robot.y][robot.x + 1] == '#')\n            {\n                robot.direction = 'S';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'S':\n            if (maze[robot.y + 1][robot.x] == '#')\n            {\n                robot.direction = 'W';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'W':\n            if (maze[robot.y][robot.x - 1] == '#')\n            {\n                robot.direction = 'N';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        default:\n            throw logic_error(\"unko\");\n            break;\n        }\n    }\n}\n\nvoid GoForward(RobotState &robot)\n{\n    switch (robot.direction)\n    {\n    case 'N':\n        --robot.y;\n        break;\n    case 'E':\n        ++robot.x;\n        break;\n    case 'S':\n        ++robot.y;\n        break;\n    case 'W':\n        --robot.x;\n        break;\n    default:\n        throw logic_error(\"unko\");\n        break;\n    }\n}\n\nint main()\n{\n    int H, W;\n    long long L;\n    while (cin >> H >> W >> L, H || W || L)\n    {\n        vector<vector<char>> maze(H + 2, vector<char>(W + 2, '#'));\n        long long visited[102][102][4];\n        for (size_t i = 0; i < 102; i++)\n            for (size_t j = 0; j < 102; j++)\n                for (size_t k = 0; k < 4; k++)\n                {\n                    visited[i][j][k] = -1;\n                }\n        RobotState robot;\n        // input maze\n        for (int i = 1; i < H + 1; ++i) \n        {\n            for (int j = 1; j < W + 1; ++j)\n            {\n                char c;\n                cin >> c;\n                if (c == '.' || c == '#')\n                {\n                    maze[i][j] = c;\n                }\n                else\n                {\n                    maze[i][j] = '.';\n                    robot.x = j;\n                    robot.y = i;\n                    robot.direction = c;\n                }\n            }\n        }\n        // do this\n        for (long long i = 0; i < L; ++i)\n        {\n            DirectToEmptyCell(maze, robot);\n\n            // detect loop\n            auto& n = visited[robot.y][robot.x][robot.direction];\n            if (n != -1)\n            {\n                i = L - (L - i) % (i - n);\n            }\n            else\n            {\n                n = i;\n            }\n\n            GoForward(robot);\n        }\n        cout << robot.y << ' ' << robot.x << ' ' << robot.direction << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct State{\n\tint y,x,dir;\n};\n\nvoid Solve(){\n\twhile(true){\n\t\tll h,w,l;\n\t\tcin >> h >> w >> l;\n\t\tif(h==0&&w==0&&l==0) break;\n\t\tvector<string> cells(h);\n\t\tREP(i,0,h) cin >> cells[i];\n\n\t\tconst char empty='.',wall='#';\n\t\tconst int north=0,east=1,south=2,west=3;\n\t\tint y,x,dir;\n\t\tREP(i,0,h) REP(j,0,w) if(cells[i][j]!=empty&&cells[i][j]!=wall){\n\t\t\ty=i; x=j;\n\t\t\tswitch(cells[i][j]){\n\t\t\t\tcase 'N': dir=north; break;\n\t\t\t\tcase 'E': dir=east; break;\n\t\t\t\tcase 'S': dir=south; break;\n\t\t\t\tcase 'W': dir=west; break;\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t\tcells[i][j]=empty;\n\t\t\tbreak;\n\t\t}\n\n\t\tint rotate[4];\n\t\tREP(i,0,4) rotate[i]=(i+1)%4;\n\n\t\t//State memo[100][100][4];\n\t\t//REP(i,0,h) REP(j,0,w) REP(k,0,4){\n\t\t\t//int y_=i,x_=j;\n\t\t\t//int ny=y_+dy[k],nx=x_+dx[k];\n\t\t\t//while(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty){\n\t\t\t\t//y_=ny; x_=nx;\n\t\t\t\t//ny=y_+dy[k]; nx=x_+dx[k];\n\t\t\t//}\n\t\t\t//memo[i][j][k]={y_,x_,rotate[k]};\n\t\t//}\n\n\t\tconst int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\t\tll visited[100][100][4];\n\t\tfill_n((ll*)visited,100*100*4,-1);\n\t\tll cnt=0;\n\t\twhile(cnt<l){\n\t\t\tdump(y);\n\t\t\tdump(x);\n\t\t\tif(visited[y][x][dir]==-1) visited[y][x][dir]=cnt;\n\t\t\telse{\n\t\t\t\tcnt+=((l-cnt)/(cnt-visited[y][x][dir]))*(cnt-visited[y][x][dir]);\n\t\t\t\tif(cnt==l) break;\n\t\t\t}\n\t\t\t\n\t\t\tint ny=y+dy[dir],nx=x+dx[dir];\n\t\t\twhile(!(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty)){\n\t\t\t\tdir=rotate[dir];\n\t\t\t\tny=y+dy[dir]; nx=x+dx[dir];\n\t\t\t}\n\t\t\ty=ny; x=nx; ++cnt;\n\t\t}\n\n\t\tcout << y+1 << ' ' << x+1 << ' ' << \"NESW\"[dir] << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nvoid output(int i,int j,int d)\n{\n\tcout<<i+1<<' '<<j+1<<' '<<\"NESW\"[d]<<endl;\n}\n\nint main()\n{\n\tint h,w; long long l;\n\tfor(;cin>>h>>w>>l,h|w|l;){\n\t\tvector<string> grid(h);\n\t\tfor(int i=0;i<h;i++) cin>>grid[i];\n\t\t\n\t\tvector<vector<int>> vis(h,vector<int>(w,-1)),dir(h,vector<int>(w,-1));\n\t\t\n\t\tqueue<tuple<int,int,int,int>> q; // (i,j,dir,time)\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint d=string(\"NESW\").find(grid[i][j]);\n\t\t\t\tif(d!=-1){\n\t\t\t\t\tq.emplace(i,j,d,0);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\twhile(q.size()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint ci=get<0>(c),cj=get<1>(c),cd=get<2>(c),ct=get<3>(c);\n\t\t\tif(ct==l){\n\t\t\t\toutput(ci,cj,cd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ct>=20000) // 十分多く回す\n\t\t\tif(vis[ci][cj]!=-1){\n\t\t\t\tint len=ct-vis[ci][cj];\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tif(vis[i][j]==(l-vis[ci][cj])%len+vis[ci][cj])\n\t\t\t\t\t\t\toutput(i,j,dir[i][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[ci][cj]=ct,dir[ci][cj]=cd;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nd=(cd+i)%4,ni=ci+\"\\xff\\0\\x1\\0\"[nd],nj=cj+\"\\0\\x1\\0\\xff\"[nd];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='#'){\n\t\t\t\t\tq.emplace(ni,nj,nd,ct+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct State {\n  int x, y, d;\n  long long l;\n  State(){}\n  State(int x, int y, int d, long long l):x(x), y(y), d(d), l(l){}\n};\n  \nint H, W;\nlong long L;\nint sx, sy, sd;\nchar maze[101][101];\n\nint dist[4][101][101];\n\nconst string dir = \"NESW\";\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nState bfs()\n{\n  queue<State> que; que.push(State(sx, sy, sd, L));\n  memset(dist, -1, sizeof(dist));\n  dist[sd][sy][sx] = 0;\n  while(!que.empty()) {\n    State p = que.front(); que.pop();\n    if(p.l == 0LL) return p;    \n    int nx = p.x+dx[p.d], ny = p.y+dy[p.d];\n    long long nl = p.l;\n    if(0 <= nx && nx < W && 0 <= ny && ny < H && maze[ny][nx] != '#') {\n      nl--;\n      if(dist[p.d][ny][nx] != -1) {\n\tnl %= (dist[p.d][p.y][p.x]+1 - dist[p.d][ny][nx]);\n\tmemset(dist, -1, sizeof(dist));\n      }\n      dist[p.d][ny][nx] = dist[p.d][p.y][p.x] + 1;\n      que.push(State(nx, ny, p.d, nl));\n    } else {\n      dist[(p.d+1)%4][p.y][p.x] = dist[p.d][p.y][p.x];\n      que.push(State(p.x, p.y, (p.d+1)%4, nl));\n    }\n  }\n}\n\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(maze, 0, sizeof(maze));\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n\tcin >> maze[i][j];\n\tif(dir.find(maze[i][j]) != string::npos) {\n\t  sy = i, sx = j, sd = dir.find(maze[i][j]);\n\t}\n      }\n    }\n    State s = bfs();\n    cout << s.y+1 << \" \" << s.x+1 << \" \" << dir[s.d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[100][100];\nint visited[100][100][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {   \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst char* dir_str = \"NESW\";\nchar field[110][110];\nlong long steps[4][110][110];\n\nint main() {\n  int H, W;\n  long long L;\n  while (scanf(\"%d%d%lld\", &H, &W, &L), H|W|L) {\n    memset(field, '#', sizeof(field));\n    memset(steps, -1, sizeof(steps));\n\n    int sy = -1, sx = -1, sdir = -1;\n    for (int y = 1; y <= H; ++y) {\n      for (int x = 1; x <= W; ++x) {\n        scanf(\" %c\", &field[y][x]);\n        if (isalpha(field[y][x])) {\n          switch (field[y][x]) {\n          case 'N': sdir = 0; break;\n          case 'E': sdir = 1; break;\n          case 'S': sdir = 2; break;\n          case 'W': sdir = 3; break;\n          }\n          field[y][x] = '.';\n          sy = y; sx = x;\n        }\n      }\n    }\n\n    int yy = sy, xx = sx, dir = sdir;\n    for (long long k = 0; k < L; ++k) {\n      if (steps[dir][yy][xx] == -1) {\n        steps[dir][yy][xx] = k;\n      } else {\n        long long rest = L - k;\n        long long period = k - steps[dir][yy][xx];\n        k = L - rest % period;\n        if (k == L) { break; }\n      }\n\n      int ny = yy + dy[dir], nx = xx + dx[dir];\n      while (field[ny][nx] == '#') {\n        dir = (dir + 1) % 4;\n        ny = yy + dy[dir]; nx = xx + dx[dir];\n      }\n      yy = ny; xx = nx;\n    }\n\n    printf(\"%d %d %c\\n\", yy, xx, dir_str[dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        int count = 0;\n        string wall = \"\";\n        bool used[101][101];\n        fill_n((bool *)used, 101*101, true);\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n                if (vs[j][i] == '.') {\n                    used[j][i] = false;\n                }\n            }\n        }\n\n        int sx, sy, sdir;\n        sx = x;\n        sy = y;\n        sdir = dir;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n                used[y][x] = true;\n                int allused = true;\n                for (int j = 0; j < h+2; j++) {\n                    for (int i = 0; i < w+2; i++) {\n                        allused &= used[j][i];\n                    }\n                }\n                if (allused) {\n                    l = l/count + l%count;\n                }\n            }\n            else\n                dir = (dir+1) % 4;\n        }\n        cout << y << \" \" << x << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, T b) {\n    if(b<a) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nll H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x;\n    ll cnt;\n    State(int dir,int y,int x,ll cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    ll d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            //printf(\"%d %d %d : %d %d\\n\",s.dir,s.y,s.x,s.cnt,d[s.dir][s.y][s.x]);\n            ll diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            ll t=(L-s.cnt)/diff;\n            if(t>0&&diff>0) {\n                s.cnt+=(t-1)*diff;\n            }\n            //printf(\"\\t%d\\n\",s.cnt);\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                chmin(d[s.dir][ny][nx],s.cnt+1);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) int a=1/0;\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w, l, y, x, d, c;\nchar data[100][100];\nint vis[100][100][4];\nstring dir = \"NESW\";\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return data[y][x] != '#';\n}\n\nvoid solve(){\n  int m, o;\n  bool f;\n  fill(vis[0][0], vis[100][0], -1);\n  for(;;){\n    if(vis[y][x][d] != -1){\n      if(vis[y][x][d]){\n        if(f){\n          o = vis[y][x][d] - 1;\n          m = c - vis[y][x][d];\n        }else{\n          o = vis[y][x][d] - 1;\n          m = c - vis[y][x][d] - 1;\n        }\n      }else{\n        if(f){\n          o = 0;\n          m = c;\n        }else{\n          o = 0;\n          m = c;\n        }\n      }\n      break;\n    }\n    //cout << y+1 << ' ' << x+1 << ' ' << dir[d] << ' ' << c << endl;\n    vis[y][x][d] = c;\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    if(!check(ny, nx)){\n      d = (d+1) % 4;\n      f = false;\n    }\n    else{\n      y = ny;\n      x = nx;\n      c++;\n      if(l == c){\n        cout << y+1 << ' ' << x+1 << ' ' << dir[d] << endl;\n        return;\n      }\n      f = true;\n    }\n  }\n  int t = l % m + o;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<4;k++){\n        if(vis[i][j][k] == t){\n          cout << i+1 << ' ' << j+1 << ' ' << dir[k] << endl;\n          return;\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> h >> w >> l && (h|w|l)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        for(int k=0;k<4;k++){\n          if(data[i][j] == dir[k]){\n            data[i][j] = '.';\n            y = i;\n            x = j;\n            d = k;\n            c = 0;\n          }\n        }\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstruct State{\n    int h,w,dir;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nmap<char,int> dmp={{'N',0},{'E',1},{'S',2},{'W',3}};\nstring dmpi=\"NESW\";\n\nvoid out(State st){\n    cout<<st.h<<\" \"<<st.w<<\" \"<<dmpi[st.dir]<<endl;\n}\n\nint solve(int H,int W,int L){\n    vector<string> f(H+2);\n    for(int i=0;i<W+2;i++){\n        f[0]+=\"#\";\n        f[H+1]+=\"#\";\n    }\n    State ini={-1,-1,-1};\n    for(int i=0;i<H;i++){\n        cin>>f[i+1];\n        f[i+1]=\"#\"+f[i+1]+\"#\";\n        for(int j=0;j<W+2;j++){\n            if(dmp.count(f[i+1][j])){\n                ini=State{i+1,j,dmp[f[i+1][j]]};\n            }\n        }\n    }\n    while(ini.h==-1) 1;\n    vector<vector<vector<int>>> dp(H+2,vector<vector<int>>(W+2,vector<int>(4,-1)));\n    int lps=0;\n    State st=ini;\n    int cnt=0;\n    queue<State> que;\n    while(true){\n        if(cnt==L){\n            out(st);\n            return 0;\n        }\n        if(dp[st.h][st.w][st.dir]!=-1){\n            lps=cnt-dp[st.h][st.w][st.dir];\n            break;\n        }\n        dp[st.h][st.w][st.dir]=cnt;\n        if(f[st.h+dh[st.dir]][st.w+dw[st.dir]]=='#'){\n            st.dir=(st.dir+1)%4;\n            continue;\n        }\n        st.h+=dh[st.dir];\n        st.w+=dw[st.dir];\n        que.push(st);\n        cnt++;\n    }\n    L-=cnt+1;\n    vector<State> lpv;\n    while(que.size()>lps) que.pop();\n    while(!que.empty()) lpv.push_back(que.front()),que.pop();\n    L%=lps;\n    out(lpv[L]);\n    return 0;\n}\nint main(){\n    int H,W,L;\n    while(cin>>H>>W>>L,H){\n        solve(H,W,L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1LL << 60;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\nbool solve() {\n    int H, W;\n    lint L;\n    cin >> H >> W >> L;\n    if (H == 0) return false;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<vector<lint>>> dist(H, vector<vector<lint>>(W, vector<lint>(4, INF)));\n    int sx, sy, sd;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            for (int d = 0; d < 4; ++d) {\n                if (S[x][y] == \"NESW\"[d]) {\n                    sx = x;\n                    sy = y;\n                    sd = d;\n                }\n            }\n        }\n    }\n\n    dist[sx][sy][sd] = 0;\n    lint step = 0;\n    bool skipped = false;\n    while (step < L) {\n        int nx = sx + dx[sd], ny = sy + dy[sd];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny ||\n            S[nx][ny] == '#') {\n            sd = (sd + 1) % 4;\n        } else {\n            sx = nx, sy = ny;\n            ++step;\n        }\n\n        if (!skipped && dist[sx][sy][sd] < INF) {\n            lint diff = step - dist[sx][sy][sd];\n            step += (L - step) / diff * diff;\n            skipped = true;\n        }\n        dist[sx][sy][sd] = step;\n    }\n    assert(step == L);\n\n    cout << sx + 1 << \" \" << sy + 1 << \" \"\n         << \"NESW\"[sd] << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\n//int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2320 : Infinity Maze **/\ntypedef long long int ll;\nll dd[100][100][4];\nchar board[100][100];\nint H, W;\nll L;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n\nint main()\n{\n\tstring label = \"NESW\";\n\t\n\twhile (cin>>H>>W>>L, H||W||L) {\n\t\tint d, l=0, sx, sy;\n\t\tmemset(dd, -1, sizeof(dd));\n\t\t\n\t\trep(y, H) {\n\t\t\trep(x, W) {\n\t\t\t\tchar c; cin>>c;\n\t\t\t\tboard[x][y] = c;\n\n\t\t\t\tif (c!='.' && c!= '#') {\n\t\t\t\t\tif (c=='N') {\n\t\t\t\t\t\td = 0;\n\t\t\t\t\t} else if (c=='E') {\n\t\t\t\t\t\td = 1;\n\t\t\t\t\t} else if (c=='S') {\n\t\t\t\t\t\td = 2;\n\t\t\t\t\t} else if (c=='W') {\n\t\t\t\t\t\td = 3;\n\t\t\t\t\t}\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tll t=0; bool find=false;\n\t\twhile (L>0) {\n\t\t\tint nx = sx+dx[d], ny = sy+dy[d];\n\t\t\t\n\t\t\tif_range(nx, ny, W, H) {\n\t\t\t\tif (!find && dd[nx][ny][d]>=0) {\n\t\t\t\t\tL %= (t - dd[nx][ny][d]);\n\t\t\t\t\tfind = true;\n\t\t\t\t} else if (board[nx][ny]!='#') {\n\t\t\t\t\tsx = nx; sy = ny;\n\t\t\t\t\tL--; t++;\n\t\t\t\t\tdd[sx][sy][d] = t;\n\t\t\t\t} else {\n\t\t\t\t\td++; d%=4;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\td++; d%=4;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tcout << sy+1 << \" \" << sx+1 << \" \" << label[d] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\nusing namespace std;\n\ntypedef long long LL;\n\nint h, w;\nLL L;\nint visit[102][102][4];\nint log[41000];\nchar c[102][102];\n\nint main(){\n\tconst string dirstr = \"NESW\";\n\tint dy[] = {-1, 0, 1, 0};\n\tint dx[] = {0, 1, 0, -1};\n\n\twhile(scanf(\"%d%d%lld\", &h, &w, &L), h){\n\t\tmemset(visit, -1, sizeof visit);\n\t\tmemset(c, '#', sizeof c);\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tscanf(\"%s\", c[i] + 1);\n\t\t\tc[i][w + 1] = '#';\n\t\t}\n\n\t\tint y, x, d;\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif(c[i][j] != '.' && c[i][j] != '#'){\n\t\t\t\ty = i;\n\t\t\t\tx = j;\n\t\t\t\td = dirstr.find(c[i][j]);\n\t\t\t\tc[i][j] = '.';\n\t\t\t\tlog[0] = (y << 10) | (x << 2) | d;\n\t\t\t\tvisit[y][x][d] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint ansy = -1, ansx = -1, ansd = -1;\n\t\tfor(LL t = 0; ;){\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(c[ny][nx] != '#'){\n\t\t\t\t++t;\n\t\t\t\tlog[t] = (ny << 10) | (nx << 2) | d;\n\t\t\t\ty = ny;\n\t\t\t\tx = nx;\n\t\t\t\t\n\t\t\t\tif(t == L){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\td = (d + 1) & 3;\n\t\t\t}\n\n\t\t\tint p = visit[ny][nx][d];\n\t\t\tif(p < 0){\n\t\t\t\tvisit[ny][nx][d] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLL dif = t - p;\n\t\t\t\tLL rem = (L - t) % dif;\n\t\t\t\tint q = log[p + rem];\n\t\t\t\ty = q >> 10;\n\t\t\t\tx = (q >> 2) & 0xff;\n\t\t\t\td = q & 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d %c\\n\", y, x, dirstr[d]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#define INF 0x3f3f3f3f\n#define MAXN 40010\n#define MAXM 110\n#define MOD 1000000007\n#define MAXNODE 4*MAXN\n#define eps 1e-9\nusing namespace std;\nint T,x,y,dir,pre,xunhuan,K,H,W,d[MAXM][MAXM][4],lastx,lasty,lastdir;\nchar a[MAXM][MAXM];\nlong long L;\nstruct path{\n    int x,y,dir;\n}p[MAXN];\nint main(){\n    while(scanf(\"%d%d%lld\",&H,&W,&L),H||W||L){\n        K=0;\n        for(int i=0;i<H;i++){\n            scanf(\"%s\",a[i]);\n            for(int j=0;j<W;j++) if(a[i][j]!='.'&&a[i][j]!='#'){\n                lastx=x=i;\n                lasty=y=j;\n                if(a[i][j]=='N') lastdir=dir=1;\n                if(a[i][j]=='E') lastdir=dir=2;\n                if(a[i][j]=='S') lastdir=dir=3;\n                if(a[i][j]=='W') lastdir=dir=4;\n                break;\n            }\n        }\n        if(!L){\n            printf(\"%d %d \",x+1,y+1);\n            if(dir==1) printf(\"N\\n\");\n            if(dir==2) printf(\"E\\n\");\n            if(dir==3) printf(\"S\\n\");\n            if(dir==4) printf(\"W\\n\");\n            continue;\n        }\n        while(1){\n            if(dir==1){\n                if(x-1>=0&&a[x-1][y]!='#') break;\n                else dir=2;\n            }\n            else if(dir==2){\n                if(y+1<W&&a[x][y+1]!='#') break;\n                else dir=3;\n            }\n            else if(dir==3){\n                if(x+1<H&&a[x+1][y]!='#') break;\n                else dir=4;\n            }\n            else if(dir==4){\n                if(y-1>=0&&a[x][y-1]!='#') break;\n                else dir=1;\n            }\n        }\n        memset(d,-1,sizeof(d));\n        d[x][y][dir]=0;\n        p[K].x=x;\n        p[K].y=y;\n        p[K++].dir=dir;\n        int flag=0;//printf(\"%d %d %d %d lastx=%d lasty=%d\\n\",x,y,dir,d[x][y][dir],lastx,lasty);\n        while(1){//printf(\"%d %d %d %d lastx=%d lasty=%d\\n\",x,y,dir,d[x][y][dir],lastx,lasty);\n            if(d[x][y][dir]==L){//cout<<\"aa\"<<endl;\n                flag=1;\n                printf(\"%d %d \",x+1,y+1);\n                if(dir==1) printf(\"N\\n\");\n                if(dir==2) printf(\"E\\n\");\n                if(dir==3) printf(\"S\\n\");\n                if(dir==4) printf(\"W\\n\");\n                break;\n            }\n            if(dir==1){\n                if(x-1>=0&&a[x-1][y]!='#'){\n                    if(d[x-1][y][dir]==-1){\n                        d[x-1][y][dir]=d[x][y][dir]+1;\n                        lastx=x;\n                        lasty=y;\n                        lastdir=dir;\n                        x--;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x-1][y][dir];\n                        xunhuan=d[x][y][dir]-d[x-1][y][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    if(d[x][y][2]!=-1){//cout<<\"aaa\"<<endl;\n                        pre=d[x][y][2];//printf(\"%d %d %d\",lastx,lasty,lastdir);\n                        xunhuan=d[lastx][lasty][lastdir]-d[x][y][2]+1;//printf(\"%d %d %d %d\\n\",x,y,pre,xunhuan);\n                        break;\n                    }\n                    dir=2;\n                    d[x][y][2]=d[x][y][1];\n                }\n            }\n            else if(dir==2){\n                if(y+1<W&&a[x][y+1]!='#'){\n                    if(d[x][y+1][dir]==-1){\n                        d[x][y+1][dir]=d[x][y][dir]+1;//printf(\"aaa%d %d %d %d\\n\",x,y+1,dir,d[x][y+1][dir]);\n                        lastx=x;\n                        lasty=y;\n                        lastdir=dir;\n                        y++;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x][y+1][dir];\n                        xunhuan=d[x][y][dir]-d[x][y+1][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    if(d[x][y][3]!=-1){\n                        pre=d[x][y][3];\n                        xunhuan=d[lastx][lasty][lastdir]-d[x][y][3]+1;\n                        break;\n                    }\n                    dir=3;\n                    d[x][y][3]=d[x][y][2];\n                }\n            }\n            else if(dir==3){\n                if(x+1<H&&a[x+1][y]!='#'){\n                    if(d[x+1][y][dir]==-1){//cout<<\"aaa\"<<endl;\n                        d[x+1][y][dir]=d[x][y][dir]+1;\n                        lastx=x;\n                        lasty=y;\n                        lastdir=dir;\n                        x++;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x+1][y][dir];\n                        xunhuan=d[x][y][dir]-d[x+1][y][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    if(d[x][y][4]!=-1){\n                        pre=d[x][y][4];\n                        xunhuan=d[lastx][lasty][lastdir]-d[x][y][4]+1;\n                        break;\n                    }\n                    dir=4;\n                    d[x][y][4]=d[x][y][3];\n                }\n            }\n            else if(dir==4){\n                if(y-1>=0&&a[x][y-1]!='#'){\n                    if(d[x][y-1][dir]==-1){\n                        d[x][y-1][dir]=d[x][y][dir]+1;\n                        lastx=x;\n                        lasty=y;\n                        lastdir=dir;\n                        y--;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x][y-1][dir];\n                        xunhuan=d[x][y][dir]-d[x][y-1][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    if(d[x][y][1]!=-1){\n                        pre=d[x][y][1];\n                        xunhuan=d[lastx][lasty][lastdir]-d[x][y][1]+1;\n                        break;\n                    }\n                    dir=1;\n                    d[x][y][1]=d[x][y][4];\n                }\n            }\n        }\n        //for(int i=0;i<10;i++) printf(\"i=%d %d %d %d\\n\",i,p[i].x,p[i].y,p[i].dir);\n        if(!flag){//printf(\"%d %d\\n\",pre,xunhuan);\n            L=(L-pre)%xunhuan;//cout<<\"aaa\"<<pre<<\" \"<<xunhuan<<\" \"<<L<<endl;\n            int n=pre+L;//cout<<n<<endl;\n            printf(\"%d %d \",p[n].x+1,p[n].y+1);//cout<<p[n].dir<<endl;\n            if(p[n].dir==1) printf(\"N\\n\");\n            if(p[n].dir==2) printf(\"E\\n\");\n            if(p[n].dir==3) printf(\"S\\n\");\n            if(p[n].dir==4) printf(\"W\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[101][101];\nint visited[100][100][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {   \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\nconst char DIRECTION[] = \"ESWN\";\nll passed[102][102][4];\n\nint main(){\n\twhile(true){\n\t\tll H, W, L;\n\t\tcin >> H >> W >> L;\n\t\tif(H == 0 && W == 0 && L == 0){ break; }\n\t\tmemset(passed, -1, sizeof(passed));\n\t\tvector<string> field(H + 2);\n\t\tfield[0] = field[H + 1] = string(W + 2, '#');\n\t\tint x = 0, y = 0;\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tfield[i] = \"#\" + line + \"#\";\n\t\t\tfor(int j = 0; j < field[i].size(); ++j){\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#'){\n\t\t\t\t\tx = j; y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dir = 0;\n\t\tswitch(field[y][x]){\n\t\tcase 'E': dir = 0; break;\n\t\tcase 'S': dir = 1; break;\n\t\tcase 'W': dir = 2; break;\n\t\tcase 'N': dir = 3; break;\n\t\t}\n\t\tfor(ll i = 0; i < L; ++i){\n\t\t\tif(passed[y][x][dir] >= 0){\n\t\t\t\tll duration = i - passed[y][x][dir];\n\t\t\t\ti = (L - i) / duration * duration + i;\n\t\t\t\tif(i >= L){ i -= duration; }\n\t\t\t}else{\n\t\t\t\tpassed[y][x][dir] = i;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\twhile(field[ny][nx] == '#'){\n\t\t\t\tdir = (dir + 1) & 0x03;\n\t\t\t\tnx = x + dx[dir]; ny = y + dy[dir];\n\t\t\t}\n\t\t\tx = nx; y = ny;\n\t\t}\n\t\tcout << y << \" \" << x << \" \" << DIRECTION[dir] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nbool passed[101][101][4];\nchar field[101][101];\n\nint h,w;\nll l;\nint sy,sx,sag;\n\nbool search1(ll &cl,int &cx,int &cy,int &cag,int &step){\n\tpassed[cy][cx][cag]=true;\n\twhile(1){\n\t\tif(cl==0){\n\t\t\tcout<<cy+1<<\" \"<<cx+1<<\" \";\n\t\t\tif(cag==0)cout<<'N';\n\t\t\telse if(cag==1)cout<<'E';\n\t\t\telse if(cag==2)cout<<'S';\n\t\t\telse if(cag==3)cout<<'W';\n\t\t\tcout<<endl;\n\t\t\treturn true;\n\t\t}\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\tif(passed[ny][nx][cag]){\n\t\t\t\tcx=nx,cy=ny;\n\t\t\t\tcl--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassed[ny][nx][cag]=true;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tcl--;\n\t\t}\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\tif(passed[cy][cx][cag])break;\n\t\t\tpassed[cy][cx][cag]=true;\n\t\t}\n\t}\n\tint gx=cx;\n\tint gy=cy;\n\tint gag=cag;\n\tint cnt=0;\n\twhile(1){\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\tcnt=0;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tstep++;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\tcnt++;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag){\n\t\t\t\tcag=(cag-cnt+4)%4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\t// loop find\n\tint cx,cy,cag,step;\n\tstep=0;\n\tll cl=l;\n\tcx=sx;\n\tcy=sy;\n\tcag=sag;\n\tmemset(passed,0,sizeof(passed));\n\tif(search1(cl,cx,cy,cag,step))return;\n\tcl%=step;\n\tstep=0;\n\tmemset(passed,0,sizeof(passed));\n\tsearch1(cl,cx,cy,cag,step);\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>l&&!(h==0&&w==0&&l==0)){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!='#'&&field[i][j]!='.'){\n\t\t\t\t\tif(field[i][j]=='N')sag=0;\n\t\t\t\t\telse if(field[i][j]=='E')sag=1;\n\t\t\t\t\telse if(field[i][j]=='S')sag=2;\n\t\t\t\t\telse if(field[i][j]=='W')sag=3;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint dx[4]   = {-1, 0, 1, 0};\nint dy[4]   = {0, 1, 0, -1};\n\nchar field[110][110];\nll memo[110][110][4];\n\nint main(){\n  ll H, W, L;\n  while(cin >>H >> W >> L && H + W + L){\n    \n    fill(&field[0][0], &field[0][0] + 110 * 110, '#');\n    memset(memo, -1, sizeof(memo));\n    \n    int x, y, d;\n    REP(i, H)REP(j, W){\n      cin >> field[i+1][j+1];\n      if(isalpha(field[i+1][j+1])){\n        x = i + 1;\n        y = j + 1;\n        d = find(dir, dir + 4, field[i+1][j+1]) - dir;\n      }\n    }\n\n    ll T = 0;\n    bool flag = false;\n    while(L > 0){\n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      while(field[nx][ny] == '#'){\n        d = (d + 1) % 4;\n        nx = x + dx[d];\n        ny = y + dy[d];\n      }\n      \n      if(memo[x][y][d] >= 0 && !flag){\n        ll S = T - memo[x][y][d];\n        L %= S;\n        flag = true;\n      }\n\n      if(L > 0){\n        memo[x][y][d] = T++;\n        x = nx;\n        y = ny;\n        L--;\n      }\n    }\n    cout << x<< \" \" << y<< \" \" << dir[d] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int dx[]= {-1,0,1,0};\nconst int dy[]= {0,1,0,-1};\nconst int N = 110;\nchar s[N][N];\nint n,m,cnt,num;\nint st,ed;\nstruct road\n{\n    int x,y;\n}vc[N*N*N];\n\nstruct eg\n{\n    int dir[4];\n    int step[4];\n} p[N][N];\n\nint check(char c)\n{\n    if(c=='N')  return 0;\n    if(c=='E')  return 1;\n    if(c=='S')  return 2;\n    if(c=='W')  return 3;\n    return -1;\n}\n\nvoid solve(int x,int y)\n{\n    int d=check(s[x][y]);\n    int xx,yy,flag;\n    while(1)\n    {\n        xx=x+dx[d];\n        yy=y+dy[d];\n        flag=0;\n        while(xx<0||xx>=n||yy<0||yy>=m||s[xx][yy]=='#')\n        {\n            d=(d+1)%4;\n            xx=x+dx[d];\n            yy=y+dy[d];\n            flag=1;\n        }\n        if(p[x][y].dir[d]&&flag)\n        {\n            st=p[x][y].step[d];\n            ed=cnt;\n            break;\n        }\n        x=xx,y=yy;\n        p[x][y].dir[d]=1;\n        p[x][y].step[d]=++cnt;\n        vc[num].x=x;\n        vc[num].y=y;\n        num++;\n    }\n}\n\nchar sth(long long l,int tt)\n{\n    l+=tt;\n    int x=vc[l].x,y=vc[l].y;\n    int xx=vc[l-1].x,yy=vc[l-1].y;\n    if(xx+1==x&&yy==y)\n        return 'S';\n    if(xx-1==x&&yy==y)\n        return 'N';\n    if(xx==x&&yy+1==y)\n        return 'E';\n    if(xx==x&&yy-1==y)\n        return 'W';\n    return 'F';\n}\n\nint main()\n{\n    long long l;\n    while(cin>>n>>m>>l)\n    {\n        if(n==0&&m==0&&l==0)\n            break;\n        int x,y,flag=1;\n        memset(p,0,sizeof(p));\n        for(int i=0; i<n; i++)\n        {\n            scanf(\"%s\",s[i]);\n            for(int j=0; j<m&&flag; j++)\n                if(s[i][j]!='.'&&s[i][j]!='#')\n                {\n                    x=i,y=j;\n                    flag=0;\n                }\n        }\n        cnt=num=0;\n        //vc.push_back(make_pair(x,y));\n        vc[num].x=x,vc[num].y=y;\n        num++;\n        p[x][y].dir[check(s[x][y])]=1;\n        solve(x,y);\n        if(l<ed)\n        {\n            printf(\"%d %d %c\\n\",vc[l].x+1,vc[l].y+1,sth(l,0));\n        }\n        else\n        {\n            l=l-st+1;\n            int r=ed-st;\n            l=l%r;\n            printf(\"%d %d %c\\n\",vc[st+l-1].x+1,vc[st+l-1].y+1,sth(l,st-1));\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\nchar hoge[4] = {'W', 'N', 'E', 'S'};\n\nint main() {\n\tfor (;;) {\n\t\tint H, W; ll L; cin >> H >> W >> L;\n\t\tif (H == 0) break;\n\t\tvector<string> c(H);\n\t\tint xs, ys, ds;\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tcin >> c[y];\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tchar& z = c[y][x];\n\t\t\t\tif (z == '.' || z == '#') continue;\n\t\t\t\txs = x; ys = y;\n\t\t\t\tif (z == 'W') ds = 0;\n\t\t\t\tif (z == 'N') ds = 1;\n\t\t\t\tif (z == 'E') ds = 2;\n\t\t\t\tif (z == 'S') ds = 3;\n\t\t\t\tz = '.';\n\t\t\t}\n\t\t}\n\t\tint x = xs, y = ys, d = ds;\n\t\tvector< vector< vector<int> > > a(H, vector< vector<int> >(W, vector<int>(4, -1)));\n\t\twhile (L--) {\n\t\t\tfor (;;) {\n\t\t\t\tint _x = x + dx[d], _y = y + dy[d];\n\t\t\t\tif (_x >= 0 && _x < W && _y >= 0 && _y < H && c[_y][_x] == '.') break;\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t\tx += dx[d]; y += dy[d];\n\t\t\tif (a[y][x][d] == -1) {\n\t\t\t\ta[y][x][d] = L;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = a[y][x][d] - L;\n\t\t\tL -= (L - 1) / l * l;\n\t\t}\n\t\tcout << y + 1 << ' ' << x + 1 << ' ' << hoge[d] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct state{ int x,y,d; };\n\nstate memo[44444];\n\nint main()\n{\n    int dx[4]={0,1,0,-1}, dy[4]={-1,0,1,0};\n\n    int h,w;\n    ll L;\n    while(cin >>h >>w >>L,h)\n    {\n        vector<string> c(h);\n        rep(i,h) cin >>c[i];\n\n        ll v[100][100][4];\n        memset(v,-1,sizeof(v));\n\n        int x=0,y=0,d=0;\n        rep(i,h)rep(j,w)\n        {\n            if(c[i][j]!='.' && c[i][j]!='#')\n            {\n                x=j;\n                y=i;\n                if(c[i][j]=='N') d=0;\n                else if(c[i][j]=='E') d=1;\n                else if(c[i][j]=='S') d=2;\n                else if(c[i][j]=='W') d=3;\n                break;\n            }\n        }\n\n        ll cycle=0;\n        ll pre=0;\n\n        ll now=1;\n        v[y][x][d]=0;\n        memo[0]=state{x,y,d};\n        #define IN(x,y) (0<=x && x<w && 0<=y && y<h)\n        bool cantmove=true;\n        while(1)\n        {\n            cantmove=true;\n            rep(i,4)\n            {\n                int nx=x+dx[d], ny=y+dy[d];\n                if(IN(nx,ny) && c[ny][nx]!='#')\n                {\n                    cantmove=false;\n                    x=nx;\n                    y=ny;\n                    break;\n                }\n                d=(d+1)%4;\n            }\n\n            if(cantmove) break;\n\n            // printf(\"y,x,d(%d,%d,%d) : %lld\\n\", y,x,d,now);\n\n            if(v[y][x][d]>0)\n            {\n                pre=v[y][x][d];\n                cycle=now-v[y][x][d];\n                break;\n            }\n\n            v[y][x][d]=now;\n            memo[now]=state{x,y,d};\n            if(now==L) break;\n            ++now;\n        }\n\n        if(!cantmove && now<L)\n        {\n            L-=pre;\n            ll X=L/cycle;\n            ll Y=L-X*cycle;\n            // printf(\"cycle= %lld: pre,X,Y %lld,%lld,%lld\\n\", cycle, pre,X,Y);\n\n            state final=memo[pre+Y];\n            x=final.x;\n            y=final.y;\n            d=final.d;\n        }\n\n        string NESW=\"NESW\";\n        printf(\"%d %d %c\\n\", y+1, x+1, NESW[d]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0};\n\nstring s[105];\nVI rec[40010];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int h, w, l;\n    cin >> h >> w >> l;\n    if(!h && !w && !l) return 0;\n    REP(i, h) cin >> s[i];\n\n    // スタート地点\n    int x=-1, y=-1, dir=-1;\n    REP(i, h) REP(j, w) {\n      if(s[i][j]=='N') {\n        y=i, x=j, dir=0;\n      } else if(s[i][j]=='E') {\n        y=i, x=j, dir=1;\n      } else if(s[i][j]=='S') {\n        y=i, x=j, dir=2;\n      } else if(s[i][j]=='W') {\n        y=i, x=j, dir=3;\n      }\n    }\n    assert(x!=-1&&y!=-1&&dir!=-1);\n\n    // シミュレーション\n    int cnt = 0, r = 0, loop = 0;\n    map<VI, int> mp;\n    while(true) {\n      while(true) {\n        int nx = x+dx[dir], ny = y+dy[dir];\n        if(IN(0LL, w, nx) && IN(0LL, h, ny) && s[ny][nx]!='#') break;\n        dir=(dir+1)%4;\n      }\n      if(mp.find({x,y,dir}) != mp.end()) {\n        r = mp[{x,y,dir}];\n        loop = cnt - r;\n        break;\n      }\n      mp[{x,y,dir}] = cnt;\n      rec[cnt++] = {x,y,dir};\n      x += dx[dir], y += dy[dir];\n    }\n\n    // 答えを求める\n    char c[] = {'N', 'E', 'S', 'W'};\n    if(l-r+1 <= 0) {\n      // rec[l] が答え\n      cout << rec[l][1]+1 << \" \" << rec[l][0]+1 << \" \" << c[rec[l-1][2]] << endl;\n    } else {\n      int tmp = (l-r)%loop;\n      // rec[r+tmp] が答え\n      cout << rec[r+tmp][1]+1 << \" \" << rec[r+tmp][0]+1 << \" \" << c[rec[r+(tmp-1+loop)%loop][2]] << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string tmp = \"NESW\";\nconst int vy[] = {-1, 0, 1, 0}, vx[] = {0, 1, 0, -1};\nint H, W;\nint64 L;\nstring C[100];\nint sx, sy, sv;\nint64 nxt[100][100][4];\nvoid dfs(int x, int y, int v, int64 step)\n{\n  int nx = x + vx[v], ny = y + vy[v], nv = (v + 1) % 4;\n  if(step == 0) {\n    cout << y + 1 << \" \" << x + 1 << \" \" << tmp[v] << endl;\n    return;\n  } else if(0 <= nx && 0 <= ny && nx < W && ny < H && C[ny][nx] != '#') {\n    int64 loop = ~nxt[nx][ny][v] ? nxt[x][y][v] - nxt[nx][ny][v] + 1 : step;\n    nxt[nx][ny][v] = nxt[x][y][v] + 1;\n    return(dfs(nx, ny, v, (step - 1) % loop));\n  } else {\n    nxt[x][y][nv] = nxt[x][y][v];\n    return(dfs(x, y, nv, step));\n  }\n}\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(nxt, -1, sizeof(nxt));\n    for(int i = 0; i < H; i++) {\n      cin >> C[i];\n      for(int j = 0; j < W; j++) {\n        int p = tmp.find(C[i][j]);\n        if(p != string::npos) sx = j, sy = i, sv = p;\n      }\n    }\n    nxt[sx][sy][sv] = 0;\n    dfs(sx, sy, sv, L);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\n#include <sys/time.h>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint W,H;\nunsigned long long L;\n\nchar c[110][110] = {};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint to(char c){\n\tif( c == 'N') return 0;\n\tif( c == 'E') return 1;\n\tif( c == 'S') return 2;\n\treturn 3;\n}\n\nint main(){\n\t\n\twhile(cin >> H >> W >> L && W){\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\tfor(int j = 0 ; j < 110 ; j++)\n\t\t\t\tc[i][j] = '#';\n\t\t\n\t\tpair<pair<int,int> ,int> cur;\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j] != '.' && c[i][j] != '#'){\n\t\t\t\t\tcur = mp(mp(j,i),to(c[i][j]));\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap< pair<pair<int,int>,int> ,int> con;\n\t\tvector< pair<pair<int,int>,int> > res;\n\t\twhile(1){\n\t\t\twhile(1){\n\t\t\t\tint tx = cur.first.first + dx[cur.second];\n\t\t\t\tint ty = cur.first.second + dy[cur.second];\n\t\t\t\tif(c[ty][tx] == '#') cur.second = (cur.second+1)%4;\n\t\t\t\telse{\n\t\t\t\t\t//cur.first = mp(tx,ty);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( con.count(cur) ) break;\n\t\t\tcon[cur] = res.size();\n\t\t\tres.push_back(cur);\n\t\t\tint x = res.back().first.first;\n\t\t\tint y = res.back().first.second;\n\t\t\tint d = res.back().second;\n\t\t\t\n\t\t\tint tx = cur.first.first + dx[cur.second];\n\t\t\tint ty = cur.first.second + dy[cur.second];\n\t\t\tcur.first = mp(tx,ty);\n\t\t\t\n\t\t\t//cout << res.size()-1 << \" \" << y << \" \" << x << \" \" << \"NESW\"[d] << endl;\n\t\t\t\n\t\t\t\n\t\t}\n\t\tvector< pair<pair<int,int>,int> > two;\n\t\tfor(int i = con[cur] ; i < res.size() ; i++){\n\t\t\ttwo.push_back(res[i]);\n\t\t}\n\t\tL--;\n\t\tif(L < res.size()){\n\t\t\tint x = res[L].first.first;\n\t\t\tint y = res[L].first.second;\n\t\t\tint d = res[L].second;\n\t\t\tcur = mp(mp(x,y),d);\n\t\t}else{\n\t\t\tL -= res.size();\n\t\t\tint x = two[L%two.size()].first.first;\n\t\t\tint y = two[L%two.size()].first.second;\n\t\t\tint d = two[L%two.size()].second;\n\t\t\tcur = mp(mp(x,y),d);\n\t\t}\n\n\t\twhile(1){\n\t\t\twhile(1){\n\t\t\t\tint tx = cur.first.first + dx[cur.second];\n\t\t\t\tint ty = cur.first.second + dy[cur.second];\n\t\t\t\tif(c[ty][tx] == '#') cur.second = (cur.second+1)%4;\n\t\t\t\telse{\n\t\t\t\t\t//cur.first = mp(tx,ty);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint tx = cur.first.first + dx[cur.second];\n\t\t\tint ty = cur.first.second + dy[cur.second];\n\t\t\tcur.first = mp(tx,ty);\n\t\t\t\n\t\t\t//cout << res.size()-1 << \" \" << y << \" \" << x << \" \" << \"NESW\"[d] << endl;\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t\t\n\t\tint x = cur.first.first;\n\t\tint y = cur.first.second;\n\t\tint d = cur.second;\n\n\t\tcout << y << \" \" << x << \" \" << \"NESW\"[d] << endl;\n\t\t//cout << res.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W;\nll L;\nvector<string> maze;\nvector<vector<vector<int> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<int> >(W, vector<int>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    ll T = min(L, H * W * 4LL);\n    for(int step=0; step<=T;){\n        if(vis[x][y][d] != -1){\n            L = vis[x][y][d] + (L - step) % (step - vis[x][y][d]);\n            break;\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        if(!inrect(nx, ny) || maze[nx][ny] == '#')(d += 1) %= 4;\n        else x = nx, y = ny, step++;\n    }\n    // FIX LINE (this can't be accepted)\n    rep(i, H)rep(j, W)rep(k, 4)if(vis[i][j][k] == L)return make_tuple(i+1, j+1, \"NESW\"[k]);\n    return make_tuple(-1, -1, '?');\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  while(cin>>h>>w>>l,h||w||l){\n    \n    string st[105];\n    ll i,j,k;\n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n\n    \n    char c[]={'E','S','W','N'};\n    \n    ll rx,ry,rd;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    rx=j;ry=i;rd=k;\n\t  }\n\t}\n      }\n    }\n    \n    \n\n    ll ax[]={1,0,-1,0};\n    ll ay[]={0,1,0,-1};\n    ll dp[105][105][4]={{{}}};\n    \n\n    bool f = true;\n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n      if(dp[rx][ry][rd]==0){\n\tdp[rx][ry][rd]=i;\n      }else if(f){\n\tll s = i-dp[rx][ry][rd];\n\tif((l-i)%s!=0){\n\t  l=i+(l-i)%s;\n\t  f=false;\n\t}\n      }\n    }\n    cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<P, char> State;\n\nll H, W, L;\nll cnt;\nchar tmp[210][210], field[210][210];\nState pos;\nvector<State> v;\nll Ls;\nchar dir[] = {'N', 'E', 'S', 'W'};\nint diry[] = {1, 0, -1, 0};\nint dirx[] = {0, 1, 0, -1};\n\n\nbool isVisited(State p){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].f.f == p.f.f && v[i].f.s == p.f.s && v[i].s == p.s){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid move(){\n  v.push_back(pos);\n  while(1){\n    if(pos.s == 'N'){\n      while(field[pos.f.s-1][pos.f.f] != '#'){\n\tpos.f.s--;\n\t//if(field[pos.f.s-1][pos.f.f] == '#') pos.s = 'E';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\t\n\tif(cnt == L) return;\n      }\n      pos.s = 'E';\n    }\n    \n    else if(pos.s == 'E'){\n      while(field[pos.f.s][pos.f.f+1] != '#'){\n\tpos.f.f++;\n\t//if(field[pos.f.s][pos.f.f+1] == '#') pos.s = 'S';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\tif(cnt == L) return;\n      }\n      pos.s = 'S';\n    }\n    \n    else if(pos.s == 'S'){\n      while(field[pos.f.s+1][pos.f.f] != '#'){\n\tpos.f.s++;\n\t//if(field[pos.f.s+1][pos.f.f] == '#') pos.s = 'W';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'W';\n    }\n    \n    else if(pos.s == 'W'){\n      while(field[pos.f.s][pos.f.f-1] != '#'){\n\tpos.f.f--;\n\t//if(field[pos.f.s][pos.f.f-1] == '#') pos.s = 'N';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'N';\n    }\n  }\n}\n\nvoid init(){\n  cnt = 0;\n  v.clear();\n  memset(field, '.', sizeof(field));\n  for(int i = 0 ; i <= H+1 ; i++){\n    field[i][0] = '#';\n    field[0][i] = '#';\n    field[H+1][i] = '#';\n    field[i][W+1] = '#';\n  }\n}\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    cin >> tmp[i];\n  }\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      field[i+1][j+1] = tmp[i][j];\n      if(isalpha(field[i+1][j+1])){\n\tpos.f.f = j+1, pos.f.s = i+1, pos.s = field[i+1][j+1];\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    if(H == 0 && W == 0 && L == 0) break;\n    \n    init();\n    input();\n    \n    bool flag = false;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = dirx[i] + pos.f.f;\n      int ny = diry[i] + pos.f.s;\n      if(field[ny][nx] == '.') flag = true;\n    }\n    if(!flag){\n      cout << pos.f.s << ' ' << pos.f.f << ' ' << pos.s << endl;\n      continue;\n    }\n    move();\n    \n    if(cnt == L){\n      cout << v[v.size()-1].f.s << ' ' << v[v.size()-1].f.f << ' ' << v[v.size()-1].s << endl;\n      continue;\n    }\n    else{\n      L -= cnt;\n      //cout << \"L = \" << L << endl;\n      //cout << \"Ls = \" << Ls << endl;\n      ll range = v.size() - Ls;\n      //cout << \"range = \" << range << endl;\n      \n      //int r = L % (Ls+1) + 1;\n      //cout << \"r = \" << r << endl;\n      ll ans;\n      if(range == 0) ans = Ls + L-1;\n      else ans = Ls + L % range;\n      //cout << \"ans = \" << ans << endl;\n      //cout << ans-1 << endl;\n\n      cout << v[ans].f.s << ' ' << v[ans].f.f << ' ' << v[ans].s << endl;\n    }    \n    /*\n    for(int i = 0 ; i < v.size() ; i++){\n      cout << i << \": x = \" << v[i].f.f << \", y = \" << v[i].f.s << \", D = \" << v[i].s << endl;\n    }\n    cout << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string tmp = \"NEST\";\nconst int vy[] = {-1, 0, 1, 0}, vx[] = {0, 1, 0, -1};\n\nint H, W;\nint64 L;\nstring C[100];\nint sx, sy, sv;\nint64 nxt[100][100][4];\nvoid dfs(int x, int y, int v, int64 step)\n{\n  if(step == 0) {\n    cout << y + 1 << \" \" << x + 1 << \" \" << tmp[v] << endl;\n    return;\n  } else {\n    for(int i = 0; i < 4; i++) {\n      int nv = (i + v) % 4, nx = x + vx[nv], ny = y + vy[nv];\n      if(0 <= nx && 0 <= ny && nx < W && ny < H && C[ny][nx] != '#') {\n        int loop = ~nxt[nx][ny][nv] ? nxt[x][y][v] - nxt[nx][ny][v] + 1  : step;\n        nxt[nx][ny][nv] = nxt[x][y][v] + 1;\n        return(dfs(nx, ny, nv, (step - 1) % loop));\n      }\n    }\n  }\n}\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(nxt, -1, sizeof(nxt));\n    for(int i = 0; i < H; i++) {\n      cin >> C[i];\n      for(int j = 0; j < W; j++) {\n        int p = tmp.find(C[i][j]);\n        if(p != string::npos) sx = j, sy = i, sv = p;\n      }\n    }\n    nxt[sx][sy][sv] = 0;\n    dfs(sx, sy, sv, L);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  while(cin>>h>>w>>l,h||w||l){\n    string st[105];\n    int i,j,k;\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n\n    //for(i=0;i<=h+1;i++) cout << st[i] << endl;\n    \n    int rx,ry,rd;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(st[i][j]=='N'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=3;\n\t}\n\tif(st[i][j]=='E'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=0;\n\t}\n\tif(st[i][j]=='S'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=1;\n\t}\n\tif(st[i][j]=='W'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=2;\n\t}\n      }\n    }\n    \n    char c[]={'E','S','W','N'};\n    \n    //cout << ry << \":\" << rx << \":\" << c[rd] << endl;\n\n    int ax[]={1,0,-1,0};\n    int ay[]={0,1,0,-1};\n    int dp[105][105][4]={{{}}};\n    \n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'&&i!=l){\n\trd=(rd+1)%4;\n      }\n      //cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n      if(dp[rx][ry][rd]==0){\n\tdp[rx][ry][rd]=i;\n      }else{\n\tll s = i-dp[rx][ry][rd];\n\t//cout << i << \":\" << s << \":\" << l << endl;\n\tif((l-i)%s!=0) l=i+(l-i)%s;\n      }\n    }\n    cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nlong long int l;\nint tesu[101][101][4];\nchar meiro[101][101];\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar direction[4] = {'N', 'E', 'S', 'W'}; \n\nvoid solve(int x, int y, int nowface, long long int stepnum)\n{\n    // cout << stepnum << \" \" << x << \" \" << y << \" \" << direction[nowface] << endl;\n    if(stepnum == l){\n        cout << x << \" \" << y << \" \" << direction[nowface] << endl;\n        return;\n    }\n    int nx = x + dx[nowface];\n    int ny = y + dy[nowface];\n    while(nx < 1 || ny < 1 || nx > h || ny > w || meiro[nx][ny] == '#'){\n        nowface = (nowface + 1) % 4;\n        nx = x + dx[nowface];\n        ny = y + dy[nowface];\n        // cout << x << \" \" << y << \" \" <<  nx << \" \" << ny << endl;\n    }\n    if(tesu[nx][ny][nowface] == -1){\n        tesu[nx][ny][nowface] = stepnum + 1;\n        solve(nx, ny, nowface, stepnum + 1);\n    } else {\n        long long int tmp = stepnum + 1 - tesu[nx][ny][nowface];\n        // cout << tesu[nx][ny][nowface] << endl;\n        solve(nx, ny, nowface, stepnum + ((l - stepnum) / tmp) * tmp + 1);\n    }\n    return;\n}\n\n\nint main()\n{\n    while(1){\n        cin >> h >> w >> l;\n        int sx, sy;\n        if(w == 0 && h == 0 && l == 0) break;\n        for(int i = 1; i < h + 1; i++){\n            for(int j = 1; j < w + 1; j++){\n                cin >> meiro[i][j];\n                if(meiro[i][j] != '#' && meiro[i][j] != '.'){\n                    sx = i;\n                    sy = j;\n                }\n                for(int k = 0; k < 4; k++){\n                    tesu[i][j][k] = -1;\n                }\n            }\n        }\n        if(meiro[sx][sy] == 'N') solve(sx, sy, 0, 0);\n        else if(meiro[sx][sy] == 'E') solve(sx, sy, 1, 0);\n        else if(meiro[sx][sy] == 'S') solve(sx, sy, 2, 0);\n        else solve(sx, sy, 3, 0);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint dx[4]   = {-1, 0, 1, 0};\nint dy[4]   = {0, 1, 0, -1};\n\nchar field[110][110];\nll memo[110][110][4];\n\nint main(){\n  ll H, W, L;\n  while(cin >>H >> W >> L && H + W + L){\n    \n    L = 1000001LL;\n    \n    fill(&field[0][0], &field[0][0] + 110 * 110, '#');\n    memset(memo, -1, sizeof(memo));\n    \n    int x, y, d;\n    REP(i, H)REP(j, W){\n      cin >> field[i+1][j+1];\n      if(isalpha(field[i+1][j+1])){\n        x = i + 1;\n        y = j + 1;\n        d = find(dir, dir + 4, field[i+1][j+1]) - dir;\n      }\n    }\n\n    ll T = 0;\n    bool flag = false;\n    while(L > 0){\n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      while(field[nx][ny] == '#'){\n        d = (d + 1) % 4;\n        nx = x + dx[d];\n        ny = y + dy[d];\n      }\n      \n      if(memo[x][y][d] >= 0 && !flag){\n        ll S = T - memo[x][y][d];\n        L %= S;\n        flag = true;\n      }\n\n      if(L > 0){\n        memo[x][y][d] = T++;\n        x = nx;\n        y = ny;\n        L--;\n      }\n    }\n    cout << x<< \" \" << y<< \" \" << dir[d] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\n\nchar dc[]={'N','E','S','W'};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint change(char ch){\n  for(int i=0;i<4;i++)if(dc[i]==ch)return i;\n}\n\nint H,W,sx,sy,sdir;\nll L;\nchar t[100][100];\nstring str;\n\nvoid input();\nvoid solve();\nvoid dfs(int,int,int,int,ll);\n\nint main(){\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0&&W==0&&L==0)break;\n    input();\n    solve();\n  }\n  return 0;\n}\n\nvoid input(){\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      if(str[j]!='#'&&str[j]!='.'){\n\tt[i][j]='.';\n\tsy=i;\n\tsx=j;\n\tsdir=change(str[j]);\n      }else t[i][j]=str[j];\n    }\n  }  \n}\n\nll vd[100][100][4];\n\nvoid solve(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n\tvd[i][j][k]=-1;\n      }\n    }\n  }\n\n  dfs(sy,sx,sdir,0,0);\n}\n\n\n\nvoid dfs(int y,int x,int dir,int dir2,ll cnt){\n  dir%=4;\n\n  if(cnt>=L){\n    cout<<y+1<<' '<<x+1<<' '<<dc[dir]<<endl;\n    return;\n  }\n  \n  if( L-cnt>=50000LL && vd[y][x][dir]!=-1 ){\n    ll ncnt;\n    ncnt=(L-cnt)%(cnt-vd[y][x][dir]);\n    dfs(y,x,dir2,dir2,L-ncnt-(cnt-vd[y][x][dir]));\n    return;\n  }\n\n  vd[y][x][dir]=cnt;\n  \n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0)dfs(y,x,dir+1,dir,cnt);\n  else if(ny>=H||nx>=W)dfs(y,x,dir+1,dir,cnt);\n  else if(t[ny][nx]=='#')dfs(y,x,dir+1,dir,cnt);\n  else dfs(ny,nx,dir,dir,cnt+1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\n#define ll long long\n\nusing namespace std;\n\nint h,w,x,y,dir;\nlong long l;\nchar c;\nchar ansdir[4] = {'E', 'N', 'W', 'S'};\nbool f[102][102];\nlong long memo[102][102][4];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\n\nint main(){\n    while(cin >> h >> w >> l){\n        if((h|w|l) == 0) break;\n        memset(f,false,sizeof(f));\n        memset(memo,-1,sizeof(memo));\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> c;\n                if(c == '.'){\n                    f[i][j] = true;\n                }else if(c == '#'){\n                    f[i][j] = false;\n                }else{\n                    f[i][j] = true;\n                    y = i;\n                    x = j;\n                    if(c == 'E'){\n                        dir = 0;\n                    }else if(c == 'N'){\n                        dir = 1;\n                    }else if(c == 'W'){\n                        dir = 2;\n                    }else{\n                        dir = 3;\n                    }\n                }\n            }\n        }\n        long long t=0;\n        memo[y][x][dir] = 0;\n        while(t != l){\n            //search\n            int ndir;\n            for(int i=0;i<4;i++){\n                ndir = (dir - i + 4)%4;\n                if(f[y+dy[ndir]][x+dx[ndir]]) break;\n            }\n            dir = ndir;\n            y += dy[ndir];\n            x += dx[ndir];\n            t++;\n            if(memo[y][x][dir] != -1){\n                ll loop = t - memo[y][x][dir];\n                ll left = l - t;\n                ll div = left / loop;\n                t += div * loop;\n                memset(memo,-1,sizeof(memo));\n            }else{\n                memo[y][x][dir] = t;\n            }\n        }\n        cout << y << \" \" << x << \" \" << ansdir[dir] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n \nusing namespace std;\n \n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n  \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n \ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n \nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n \nstruct State{\n    int y,x,dir;\n};\n \nvoid Solve(){\n    while(true){\n        ll h,w,l;\n        cin >> h >> w >> l;\n        if(h==0&&w==0&&l==0) break;\n        vector<string> cells(h);\n        REP(i,0,h) cin >> cells[i];\n \n        const char empty='.',wall='#';\n        const int north=0,east=1,south=2,west=3;\n        int y,x,dir;\n        REP(i,0,h) REP(j,0,w) if(cells[i][j]!=empty&&cells[i][j]!=wall){\n            y=i; x=j;\n            switch(cells[i][j]){\n                case 'N': dir=north; break;\n                case 'E': dir=east; break;\n                case 'S': dir=south; break;\n                case 'W': dir=west; break;\n                default: break;\n            }\n            cells[i][j]=empty;\n            break;\n        }\n \n        int rotate[4];\n        REP(i,0,4) rotate[i]=(i+1)%4;\n \n        const int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n        State memo[100][100][4];\n        REP(i,0,h) REP(j,0,w) REP(k,0,4){\n            int y_=i,x_=j;\n            int ny=y_+dy[k],nx=x_+dx[k];\n            while(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty){\n                y_=ny; x_=nx;\n                ny=y_+dy[k]; nx=x_+dx[k];\n            }\n            memo[i][j][k]={y_,x_,rotate[k]};\n        }\n \n        ll cnt=0;\n        while(cnt<l){\n            State &m=memo[y][x][dir];\n            int dist=abs(y-m.y)+abs(x-m.x);\n \n            if(cnt+dist>=l){\n                y+=(m.y-y)*(l-cnt)/dist;\n                x+=(m.x-x)*(l-cnt)/dist;\n                break;\n            }\n             \n            y=m.y;\n            x=m.x;\n            dir=m.dir;\n            cnt+=dist;\n        }\n \n        cout << y+1 << ' ' << x+1 << ' ' << \"NESW\"[dir] << endl;\n    }\n}\n \nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    Solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct State{\n  ll x, y;\n  char d;\n};\n\nchar field[110][110];\nint H, W, L;\nvector<State> v;\nState pos;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nchar dn[] = {'N', 'E', 'S', 'W'};\n\nint Ls;\n\nbool isVisited(State s){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].x == s.x && v[i].y == s.y && v[i].d == s.d){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nState solve(){\n  //v.push_back(pos);\n\n  int cnt = 0;\n  int dir;\n  for(int i = 0 ; i < 4 ; i++){\n    if(dn[i] == pos.d) dir = i;\n  }\n  \n  while(true){\n    int nx = pos.x + dx[dir];\n    int ny = pos.y + dy[dir];\n    \n    if(field[ny][nx] == '#' || nx < 0 || nx >= W || ny < 0 || ny >= H){\n      dir = (dir+1) % 4;\n      continue;\n    }\n    pos.y = ny, pos.x = nx, pos.d = dn[dir];\n    cnt++;\n    if(isVisited(pos)) break;\n\n    v.push_back(pos);\n    if(cnt == L) return pos;\n  }\n  \n  ll remain = L - cnt;\n  ll cycle_len = v.size() - Ls;\n  remain %= cycle_len;\n  //cout << \"L = \" << L << endl;\n  //cout << \"cycle_len = \" << cycle_len << endl;\n  //cout << \"remain = \" << remain << endl;\n  //cout << \"Ls = \" << Ls << endl;\n  return v[Ls+remain];\n}\n\nvoid init(){\n  v.clear();\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    init();\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> field[i][j];\n\tif(isalpha(field[i][j])) pos.x = j, pos.y = i, pos.d = field[i][j];\n      }\n    }\n    \n    int dir;\n    for(int i = 0 ; i < 4 ; i++){\n      if(dn[i] == pos.d) dir = i;\n    }\n    \n    bool canmove = false;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = pos.x + dx[i], ny = pos.y + dy[i];\n      if(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n      if(field[ny][nx] == '.') canmove = true;\n    }\n    \n    if(!canmove){\n      cout << pos.y+1 << ' ' << pos.x+1 << ' ' << dn[(L%4 + dir) % 4] << endl;\n    }\n    else{\n      State ans = solve();\n      cout << ans.y+1 << ' ' << ans.x+1 << ' ' << ans.d << endl;\n      /*\n      for(int i = 0 ; i < v.size() ; i++){\n\tcout << i << \": \" << \"x = \" << v[i].x+1 << \", y = \" << v[i].y+1 << \", d = \" << v[i].d << endl;\n      }\n      cout << endl;\n      */\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\nchar a[111][111];\nint dir[4][2]= {-1,0,   0,1, 1,0,  0,-1}; // n\nint ha_sh(char  ch)\n{\n    if(ch=='N')\n        return 0;\n    if(ch=='E')\n        return 1;\n    if(ch=='S')\n        return 2;\n    if(ch=='W')\n        return 3;\n}\nchar  ha_sh2(int t)\n{\n    char d[]=\"NESW\";\n\n    return  d[t];\n}\nint h,w;\nlong long l;\nint main()\n{\n    while(scanf(\"%d%d%lld\",&h,&w,&l))\n    {\n\n        if(h==0 && w==0 && l==0)\n            break;\n        memset(a,'\\0',sizeof(a));\n        int i=0;\n        int j=0;\n        char ch;\n        int x;\n        int y;\n        for(i=0; i<h; i++)\n        {\n\n\n            scanf(\"%s\",a[i]);\n\n            for(j=0; j<w; j++)\n            {\n                if(a[i][j]!='.' && a[i][j]!='#')\n                {\n                    ch=a[i][j];\n                    x=i;\n                    y=j;\n                    cout<<a[i][j]<<endl;\n                }\n            }\n\n        }\n        int t=ha_sh(ch);\n        long long k=0;\n        for(k=1; k<=l; k++)\n        {\n            while( (x+dir[t][0]<0 )\n                  || (x+dir[t][0]>h-1)||(y+dir[t][1]<0)\n                  ||(y+dir[t][1]>w-1 )|| a[x+dir[t][0]][y+dir[t][1]] =='#' )\n        {\n            t=(t+1)%4;\n            }\n            x=x+dir[t][0];\n            y=y+dir[t][1];\n        }\n          printf(\"%d %d %c\\n\",x+1,y+1,ha_sh2(t));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  ll i,j,k;\n  ll dp[200][200][4]={{{}}};\n  string st[200];\n  char c[]={'E','S','W','N'};\n  ll rx,ry,rd;\n  ll ax[]={1,0,-1,0};\n  ll ay[]={0,1,0,-1};\n  bool f;\n  ll s;\n  while(cin>>h>>w>>l,h||w||l){\n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    fill(dp[0][0],dp[104][104],0);\n    f = true;\n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(dp[ry][rx][rd]==0){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\ts = i - dp[ry][rx][rd];\n\tl=i+(l-i)%s;\n\tf=false;\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n    }\n    cout << ry << ' ' << rx << ' ' << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nchar c[110][110];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nstring table = \"NESW\";\n\nstruct NODE{\n\tint x,y,d;\n\tNODE(int x,int y,int d) : x(x) , y(y) , d(d) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\tif( a.x != b.x ) return a.x < b.x;\n\tif( a.y != b.y ) return a.y < b.y;\n\treturn a.d < b.d;\n}\nint main(){\n\tlong long H,W,L;\n\twhile(cin >> H >> W >> L && L ){\n\t\tL--;\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\tfor(int j = 0 ; j < 110 ; j++)\n\t\t\t\tc[i][j] = '#';\n\t\t\n\t\tNODE cur(0,0,0);\n\t\t\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif( ~table.find(c[i][j]) ){\n\t\t\t\t\tcur.d = table.find(c[i][j]);\n\t\t\t\t\tcur.x = j;\n\t\t\t\t\tcur.y = i;\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<NODE,long long> memo;\n\t\tvector<NODE> add;\n\t\twhile(L){\n\t\t\twhile( c[cur.y+dy[cur.d]][cur.x+dx[cur.d]] == '#' ) cur.d = (cur.d+1) % 4;\n\t\t\t//cout << add.size() << \" \" << cur.x << \" \" << cur.y << \" \" << cur.d  << endl;\n\t\t\tif( memo.count(cur) ){\n\t\t\t\tint idx = memo[cur];\n\t\t\t\tlong long r = L%(add.size() - idx);\n\t\t\t\tcur = add[idx+r];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemo[cur] = add.size();\n\t\t\tadd.push_back(cur);\n\t\t\tcur.y+=dy[cur.d];\n\t\t\tcur.x+=dx[cur.d];\n\t\t\tL--;\n\t\t}\n\t\t\n\t\twhile( c[cur.y+dy[cur.d]][cur.x+dx[cur.d]] == '#' ) cur.d = (cur.d+1) % 4;\n\t\tcur.y+=dy[cur.d];\n\t\tcur.x+=dx[cur.d];\n\t\tcout << cur.y << \" \" << cur.x << \" \" << table[cur.d] << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint mem[110][110][4];\n\nint main() {\n  int h, w, n;\n  string m[110];\n  while (true) {\n    cin >> h >> w >> n;\n    if (h == 0 && w == 0 && n == 0) break;\n    rep (i, h) cin >> m[i + 1];\n    m[0] = m[h + 1] = \"\";\n    rep (i, w) m[0] += \"#\";\n    rep (i, w) m[h + 1] += \"#\";\n    rep (i, h + 2) m[i] = \"#\" + m[i] + \"#\";\n    h += 2;\n    w += 2;\n    int x, y, d;\n    rep (i, h) rep (j, w) {\n      if (m[i][j] == 'E') d = 0;\n      if (m[i][j] == 'S') d = 1;\n      if (m[i][j] == 'W') d = 2;\n      if (m[i][j] == 'N') d = 3;\n      if (isalpha(m[i][j])) {\n\tx = j;\n\ty = i;\n      }\n    }\n    rep (i, 110) rep (j, 110) rep (k, 4) mem[i][j][k] = -1;\n    rep (i, n) {\n      int xx = x + dx[d], yy = y + dy[d];\n      while (m[yy][xx] == '#') {\n\td = (d + 1) % 4;\n\txx = x + dx[d];\n\tyy = y + dy[d];\n      }\n      x = xx;\n      y = yy;\n      if (mem[y][x][d] != -1) {\n\tint k = i - mem[y][x][d];\n\tint a = (n - i) / k;\n\tif (a > 1) i += (a - 1) * k;\n      } else {\n\tmem[y][x][d] = i;\n      }\n    }\n    cout << y << \" \" << x << \" \" << \"ESWN\"[d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\ntypedef long long int ll;\n\nstruct State {\n    int x, y, dir;\n};\n\nint N, M;\nll L;\nchar board[110][110];\nState nxt[110][110][4][70];\nstring pat = \"NESW\";\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n    while(cin >> N >> M >> L, N || M || L) {\n        int sx, sy, d;\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<M; j++) {\n                cin >> board[i][j];\n                if(pat.find(board[i][j]) != string::npos) {\n                    sx = i, sy = j, d = pat.find(board[i][j]);\n                }\n            }\n        }\n\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<M; j++) {\n                if(board[i][j] == '#') continue;\n                for(int k=0; k<4; k++) {\n                    int d = k;\n                    int cnt_ng = 0;\n                    while(cnt_ng < 4) {\n                        int nx = i + dx[d], ny = j + dy[d];\n\n                        bool ok = true;\n                        if(nx < 0 || nx >= N || ny < 0 || ny >= M) ok = false;\n                        if(board[nx][ny] == '#') ok = false;\n                        if(ok) {\n                            nxt[i][j][k][0] = State{nx, ny, d};\n                            break;\n                        }\n                        else {\n                            cnt_ng++;\n                            d = (d + 1) % 4;\n                        }\n                    }\n                }\n            }\n        }\n\n        for(int m=1; m<65; m++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<M; j++) {\n                    for(int k=0; k<4; k++) {\n                        State t = nxt[i][j][k][m-1];\n                        nxt[i][j][k][m] = nxt[t.x][t.y][t.dir][m-1];\n                    }\n                }\n            }\n        }\n\n        State ans{sx, sy, d};\n        for(int b=0; b<60; b++) {\n            if(L >> b & 1) {\n                ans = nxt[ans.x][ans.y][ans.dir][b];\n            }\n        }\n        printf(\"%d %d %c\\n\", ans.x+1, ans.y+1, pat[ans.dir]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint main(void){\n\tint h, w, dx[4] = {0,1,0,-1},dy[4] = {-1,0,1,0}, flag[100][100][4], i, j, k, x, y, d;\n\tlong long int l;\n\tchar str[100][101], dir[5] = {\"NEST\"};\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&h,&w,&l);\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tstr[i][j] = getchar();\n\t\t\t\tif(isupper(str[i][j])){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tfor(k = 0;k < 4;k++)\n\t\t\t\t\t\tif(str[i][j] == dir[k]) d = k;\n\t\t\t\t\tstr[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tfor(i = 0;i < l;i++){\n\t/*\t\tif(flag[y][x][d] == -1)\n\t\t\t\tflag[y][x][d] = i;\n\t\t\telse{\n\t\t\t\tl = (l - i) % (i - flag[y][x][d]); // 残りの\n\t\t\t\ti = 0;\n\t\t\t\tmemset(flag,-1,sizeof(flag));\n\t\t\t}*/\n\t\t\twhile(1){\n\t\t\t\tif(x + dx[d] >= 0 && x + dx[d] < w && y + dy[d] >= 0 && y + dy[d] < h && str[y + dy[d]][x + dx[d]] == '.'){\n\t\t\t\t\tx = x + dx[d];\n\t\t\t\t\ty = y + dy[d];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",y + 1,x + 1,dir[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint H,W;\nll int L;\nchar grid[150][150];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};//N,E,S,W\nll int memo[150][150][4];\nint dir,px,py;\n\nint rotate(int a){\n\treturn (a+1)%4;\n}\nbool inrange(int x,int y){\n\treturn (x>-1&&y>-1&&x<H&&y<W);\n}\nint main(){\n\twhile(1){\n\t\tcin >> H >> W >> L;\n\t\tif(H==0&&W==0&&L==0) break;\n\t\tREP(i,H){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tREP(j,str.size()){\n\t\t\t\tgrid[i][j] = str[j];\n\t\t\t\tif(grid[i][j]=='N'){dir = 0; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='E'){dir = 1; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='S'){dir = 2; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='W'){dir = 3; px = i; py = j; grid[i][j] = '.';}\n\t\t\t}\n\t\t}\n\t\tll int step = 0;\n\t\tREP(i,150) REP(j,150) REP(k,4) memo[i][j][k] = -1;\n\t\tmemo[px][py][dir] = 0;\n\t\twhile(1){\n\t\t\tif(step == L) goto End;\n\t\t\tint nx = px + dx[dir]; int ny = py + dy[dir];\n\t\t\tif(grid[nx][ny]=='.'&&inrange(nx,ny)){\n\t\t\t\tstep++;\n\t\t\t\tpx = nx; py = ny;\n\t\t\t\tif(memo[px][py][dir]!=-1){\n\t\t\t\t\t// cout << px << \" \" << py << \" \" << dir << \" \"<< memo[px][py][dir] << \" \" << step << endl;\n\t\t\t\t\t//a,b,c\n\t\t\t\t\tll int a = step-memo[px][py][dir];\n\t\t\t\t\tll int b = L-step;\n\t\t\t\t\tstep += a*(b/a);\n\t\t\t\t\tif(step == L) goto End;\n\t\t\t\t}else{\n\t\t\t\t\tmemo[px][py][dir] = step;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!inrange(nx,ny)||grid[nx][ny]=='#'){\n\t\t\t\tdir = rotate(dir);\n\t\t\t}\n\t\t\t\n\t\t}\nEnd:\n\t\tstring ans = \"NESW\";\n\t\tcout << px+1 << \" \" << py+1 << \" \" <<  ans[dir] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define MAX 1000\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[MAX][MAX];\nint visited[MAX][MAX][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,line.size())\n\t    {\n\t      assert(j < W);\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      move(H,W,src.F,src.S,dir);\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    { \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      L += (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<L;i++)\n\t\t{\n\t\t  src.F += dx[dir];\n\t\t  src.S += dy[dir];\n\t\t  \n\t\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\n\t\t  else if(G[src.S][src.F] == '#')\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\t\n\t\t}\n\t   \n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;\n\t      \n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstruct State{\n    int h,w,dir;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nmap<char,int> dmp={{'N',0},{'E',1},{'S',2},{'W',3}};\nstring dmpi=\"NESW\";\n\nvoid out(State st){\n    cout<<st.h<<\" \"<<st.w<<\" \"<<dmpi[st.dir]<<endl;\n}\n\nint solve(int H,int W,int L){\n    vector<string> f(H+2);\n    for(int i=0;i<W+2;i++){\n        f[0]+=\"#\";\n        f[H+1]+=\"#\";\n    }\n    State ini={-1,-1};\n    for(int i=0;i<H;i++){\n        cin>>f[i+1];\n        f[i+1]=\"#\"+f[i+1]+\"#\";\n        for(int j=0;j<W+2;j++){\n            if(dmp.count(f[i+1][j])){\n                ini=State{i+1,j,dmp[f[i+1][j]]};\n            }\n        }\n    }\n\n    vector<vector<vector<int>>> dp(H+2,vector<vector<int>>(W+2,vector<int>(4,-1)));\n    int lps=0;\n    State st=ini;\n    int cnt=0;\n    queue<State> que;\n    while(true){\n        if(cnt==L){\n            out(st);\n            return 0;\n        }\n        if(dp[st.h][st.w][st.dir]!=-1){\n            lps=cnt-dp[st.h][st.w][st.dir];\n            break;\n        }\n        dp[st.h][st.w][st.dir]=cnt;\n        if(f[st.h+dh[st.dir]][st.w+dw[st.dir]]=='#'){\n            st.dir=(st.dir+1)%4;\n            continue;\n        }\n        st.h+=dh[st.dir];\n        st.w+=dw[st.dir];\n        que.push(st);\n        cnt++;\n    }\n    while(lps==0) 1;\n    L-=cnt+1;\n    vector<State> lpv;\n    while(que.size()>lps) que.pop();\n    while(!que.empty()) lpv.push_back(que.front()),que.pop();\n    L%=lps;\n    out(lpv[L]);\n    return 0;\n}\nint main(){\n    int H,W,L;\n    while(cin>>H>>W>>L,H){\n        solve(H,W,L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n#define START 'S'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n\n  bool operator< (Robot r) const{return y!=r.y?y<r.y:(x!=r.x?x<r.x:dir<r.dir);}\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    map<Robot,long long int> visited;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    // for(int i=0; i<=H+1; i++){\n    //   for(int j=0; j<=W+1; j++){\n    //     cout<<\" \"<<c[i][j];\n    //   }\n    //   cout<<endl;\n    // }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited.count(me)){\n        long long int t = step-visited[me];\n        step = L - L%t;\n        // cout<<\"+\"<<endl;\n      }\n      visited[me]=step;\n      step++;\n      me.move();\n      // cout<<step<<endl;\n      // cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n\n  bool operator< (Robot r) const{return y!=r.y?y<r.y:(x!=r.x?x<r.x:dir<r.dir);}\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    map<Robot,int> visited;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){me.turn();}\n      me.move();\n      step++;\n      if(visited.count(me)){\n        long long int dif = step-visited[me];\n        step = L - (L-step)%dif;\n      }else{\n        visited[me] = step;\n      }\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nbool passed[101][101][4];\nchar field[101][101];\n\nint h,w;\nll l;\nint sy,sx,sag;\n\n// loopð©Â¯éÜÅTõ\nbool search1(ll &cl,int &cx,int &cy,int &cag,int &step){\n\tpassed[cy][cx][cag]=true;\n\twhile(1){\n\t\t// Ú®I¹\n\t\tif(cl==0){\n\t\t\tcout<<cy+1<<\" \"<<cx+1<<\" \";\n\t\t\tif(cag==0)cout<<'N';\n\t\t\telse if(cag==1)cout<<'E';\n\t\t\telse if(cag==2)cout<<'S';\n\t\t\telse if(cag==3)cout<<'W';\n\t\t\tcout<<endl;\n\t\t\treturn true;\n\t\t}\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\t// Ú®Â\\©\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\t// ·ÅÉÊßÏÝ©\n\t\t\tif(passed[ny][nx][cag]){\n\t\t\t\tcx=nx,cy=ny;\n\t\t\t\tcl--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassed[ny][nx][cag]=true;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tcl--;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\t// ÊßÏÝ\n\t\t\tif(passed[cy][cx][cag])break;\n\t\t\tpassed[cy][cx][cag]=true;\n\t\t}\n\t}\n\tint gx=cx;\n\tint gy=cy;\n\tint gag=cag;\n\t// Ü¾S[µÄ¢È¢\n\t// [vð¦é\n\twhile(1){\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tstep++;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\t// loop find\n\tint cx,cy,cag,step;\n\tstep=0;\n\tll cl=l;\n\tcx=sx;\n\tcy=sy;\n\tcag=sag;\n\t// [vBOÉS[\n\tmemset(passed,0,sizeof(passed));\n\tif(search1(cl,cx,cy,cag,step))return;\n\t// [vÉüÁ½ê,loopÌstepªclð¸ç·\n\tcl%=step;\n\tstep=0;\n\t// cèÌXebvÅS[\n\tmemset(passed,0,sizeof(passed));\n\tsearch1(cl,cx,cy,cag,step);\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>l&&!(h==0&&w==0&&l==0)){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!='#'&&field[i][j]!='.'){\n\t\t\t\t\tif(field[i][j]=='N')sag=0;\n\t\t\t\t\telse if(field[i][j]=='E')sag=1;\n\t\t\t\t\telse if(field[i][j]=='S')sag=2;\n\t\t\t\t\telse if(field[i][j]=='W')sag=3;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  ll i,j,k;\n  ll dp[105][105][4]={{{}}};\n  string st[105];\n  char c[]={'E','S','W','N'};\n  ll rx,ry,rd;\n  ll ax[]={1,0,-1,0};\n  ll ay[]={0,1,0,-1};\n  bool f;\n  \n  while(cin>>h>>w>>l,h||w||l){\n    \n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    \n    fill(dp[0][0],dp[104][104],0);\n    f = true;\n    \n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n      \n      if(dp[ry][rx][rd]==0){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\tll s = i-dp[ry][rx][rd];\n\tif((l-i)%s!=0){\n\t  l=i+(l-i)%s;\n\t  f=false;\n\t}\n      }\n      \n    }\n    cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nchar c[110][110];\nint d[110][110];\nint h, w, l;\nstring str = \"NESW\";\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> h >> w >> l;\n        if(h + w + l == 0) break;\n        int dr = -1, y = -1, x = -1;\n        rep(i, 0, 110) rep(j, 0, 110) d[i][j] = -1;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> c[i][j];\n                if(str.find(c[i][j]) != string::npos){\n                    dr = str.find(c[i][j]);\n                    y = i; x = j;\n                }\n            }\n        }\n        d[y][x] = 0;\n        vector<PP> sv;\n        sv.push_back(PP(P(y, x), dr));\n        for(int i = 1;; i++){\n            int ny = -1, nx = -1;\n            while(1){\n                ny = y + dy[dr];\n                nx = x + dx[dr];\n                if(contain(ny, nx) && c[ny][nx] != '#'){\n                    break;\n                }\n                dr = (dr + 1) % 4;\n            }\n            y = ny; x = nx;    \n            if(i == l){\n                cout << y + 1 << ' ' << x + 1 << ' ' << str[dr] << endl;\n                break;\n            }        \n            if(d[ny][nx] != -1){\n                int loop = i - d[ny][nx];\n                int step = d[ny][nx] + (l - d[ny][nx]) % loop;\n                cerr << loop << ' ' << step << endl;\n                cout << sv[step].first.first + 1 << ' ' << sv[step].first.second + 1 << ' ' << str[sv[step].second] << endl;\n                break;\n            }\n            d[y][x] = i;\n            sv.push_back(PP(P(y, x), dr));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tstring s=\"ESWN\";\n\tint n,m,t;\n\twhile(cin>>n>>m>>t,n+m+t){\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tint x,y,now;\n\t\trep(i,n)rep(j,m)rep(k,4)\n\t\t\tif(in[i][j]==s[k])x=i,y=j,now=k;\n\t\tint memo[101][101][4]={0};\n\t\tint T=t;\n\t\twhile(t--){\n\t\t\tif(memo[x][y][now]){\n\t\t\t\tt%=memo[x][y][now]-t+1;\n\t\t\t}\n\t\t\tmemo[x][y][now]=t;\n\t\t\tint nx=x+dx[now];\n\t\t\tint ny=y+dy[now];\n\t\t\tif(nx<0||ny<0||nx>=n||ny>=m||in[nx][ny]=='#')(now+=1)%=4,t++;\n\t\t\telse x=nx,y=ny;\n\t\t}\n\t\tcout<<x+1<<\" \"<<y+1<<\" \"<<s[now]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W; ll L;\nint dir, y, x, cost;\nstring const ds = \"WNES\";\n\nmap<tuple<int, int, int>, int> vis;\nvector<tuple<int, int, int>> data_;\nchar G[111][111];\n\nbool in_range(int y, int x, int H, int W) {\n  if(!(0<=y&&y<H&&0<=x&&x<W)) return false;\n  if(G[y][x] == '#') return false;\n  return true;\n}\n\nvoid adjust_dir() {\n  while(!in_range(y + dy[dir], x + dx[dir], H, W)) {\n    dir ++;\n    dir %= 4;\n  }\n}\n\nvoid debug() {\n  cout << \"cost = \" << cost << endl;\n  rep(i, H) {\n    rep(j, W) {\n      if(isalpha(G[i][j])) cout << \".\";\n      else if(i == y && j == x) cout << ds[dir];\n      else cout << G[i][j];\n    }\n    cout << endl;\n  }\n  cout << get<0>(data_.back()) << \", \";\n  cout << get<1>(data_.back()) << \", \";\n  cout << get<2>(data_.back()) << endl;\n  cout << endl;\n}\n\nvoid enter_loop() {\n  const int loop_start_cost = vis[{y,x,dir}];\n  const int len = cost - loop_start_cost;\n  /*\n  cout << \"loop_start_cost = \" << loop_start_cost << endl;\n  cout << \"len = \" << len << endl;\n  */\n  L -= loop_start_cost;\n  /*\n  cout << \"L = \" << L << endl;\n  cout << \"data_.size() = \" << data_.size() << endl;\n  cout << \"soeji = \" << loop_start_cost + L % len << endl;\n  */\n  int Y, X, d; tie(Y, X, d) = data_[loop_start_cost + L % len - 1];\n  cout << Y+1 << \" \" << X+1 << \" \" << ds[d] << endl;\n}\n\nbool step() {\n  adjust_dir();\n  y += dy[dir], x += dx[dir];\n  cost ++;\n  if(vis.find(make_tuple(y, x, dir)) != vis.end()) {\n    enter_loop();\n    return false;\n  }\n  if(cost == L) {\n    cout << y+1 << \" \" << x+1 << \" \" << ds[dir] << endl;\n    return false;\n  }\n  vis[make_tuple(y, x, dir)] = cost;\n  data_.emplace_back(y, x, dir);\n//  debug();\n  return true;\n}\n\nvoid simulate() {\n\n  vis.clear();\n  data_.clear();\n  cost = 0;\n\n  while(step());\n}\n\nint main() {\n\n  for(; cin >> H >> W >> L && (H | W | L);) {\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if(isalpha(G[i][j])) {\n        y = i, x = j;\n        dir = ds.find(G[i][j]);\n      }\n    }\n\n    simulate();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tchar DIR[]=\"ENWS\";\n\tint DIRR[128]; rep(k,4) DIRR[DIR[k]]=k;\n\n\tint h,w;\n\tfor(ll l;scanf(\"%d%d%lld\",&h,&w,&l),h;){\n\t\tstatic char B[100][101];\n\t\tint x,y,dir;\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",B[i]);\n\t\t\trep(j,w) if(isalpha(B[i][j])) x=j, y=i, dir=DIRR[B[i][j]];\n\t\t}\n\n\t\tint T[100][100][4];\n\t\trep(i,h) rep(j,w) rep(k,4) T[i][j][k]=-1;\n\n\t\tll t=0;\n\t\twhile(l>0){\n\t\t\t// ツ偲シツ甘コツつェツづ敖づつつゥツづつスツづァツ暗ェツ気ツづ可進ツづ淞づゥ\n\t\t\tif(~T[y][x][dir]){\n\t\t\t\tll dif=t-T[y][x][dir];\n\t\t\t\tt+=(l-1)/dif*dif;\n\t\t\t\tl-=(l-1)/dif*dif;\n\t\t\t}\n\t\t\tT[y][x][dir]=t;\n\n\t\t\tint xx=x+dx[dir],yy=y+dy[dir];\n\t\t\t// ツ陳シツ進\n\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && B[yy][xx]!='#'){\n\t\t\t\tt++;\n\t\t\t\tl--;\n\t\t\t\tx=xx;\n\t\t\t\ty=yy;\n\t\t\t}\n\t\t\t// ツ陛サツ古シツ転ツ環キ\n\t\t\telse{\n\t\t\t\tdir=(dir+3)%4;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d %c\\n\",y+1,x+1,DIR[dir]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        long long count = 0;\n        string wall = \"\";\n        bool used[101][101][4];\n        fill_n((bool *)used, 101*101, false);\n\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n            }\n        }\n\n        int sx, sy, sdir;\n        sx = x;\n        sy = y;\n        sdir = dir;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n            }\n            else\n                dir = (dir+1) % 4;\n            if (used[y][x][dir]) {\n                l = l % count;\n            } else if(vs[y][x] == '.') {\n                used[y][x][dir] = true;\n            }\n        }\n        cout << y << \" \" << x << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string tmp = \"NESW\";\nconst int vy[] = {-1, 0, 1, 0}, vx[] = {0, 1, 0, -1};\n\nint H, W;\nint64 L;\nstring C[100];\nint sx, sy, sv;\nint64 nxt[100][100][4];\nvoid dfs(int x, int y, int v, int64 step)\n{\n  if(step == 0) {\n    cout << y + 1 << \" \" << x + 1 << \" \" << tmp[v] << endl;\n    return;\n  } else {\n    for(int i = 0; i < 4; i++) {\n      int nv = (i + v) % 4, nx = x + vx[nv], ny = y + vy[nv];\n      if(0 <= nx && 0 <= ny && nx < W && ny < H && C[ny][nx] != '#') {\n        int loop = ~nxt[nx][ny][nv] ? nxt[x][y][v] - nxt[nx][ny][v] + 1  : step;\n        nxt[nx][ny][nv] = nxt[x][y][v] + 1;\n        return(dfs(nx, ny, nv, (step - 1) % loop));\n      }\n    }\n  }\n}\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(nxt, -1, sizeof(nxt));\n    for(int i = 0; i < H; i++) {\n      cin >> C[i];\n      for(int j = 0; j < W; j++) {\n        int p = tmp.find(C[i][j]);\n        if(p != string::npos) sx = j, sy = i, sv = p;\n      }\n    }\n    nxt[sx][sy][sv] = 0;\n    dfs(sx, sy, sv, L);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\nconst char DIRECTION[] = \"ESWN\";\n\nint main(){\n\twhile(true){\n\t\tint H, W, L;\n\t\tcin >> H >> W >> L;\n\t\tif(H == 0 && W == 0 && L == 0){ break; }\n\t\tvector<string> field(H + 2);\n\t\tfield[0] = field[H + 1] = string(W + 2, '#');\n\t\tint x = 0, y = 0;\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tfield[i] = \"#\" + line + \"#\";\n\t\t\tfor(int j = 0; j < field[i].size(); ++j){\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#'){\n\t\t\t\t\tx = j; y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dir = 0;\n\t\tswitch(field[y][x]){\n\t\tcase 'E': dir = 0; break;\n\t\tcase 'S': dir = 1; break;\n\t\tcase 'W': dir = 2; break;\n\t\tcase 'N': dir = 3; break;\n\t\t}\n\t\twhile(L--){\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\twhile(field[ny][nx] == '#'){\n\t\t\t\tdir = (dir + 1) & 0x03;\n\t\t\t\tnx = x + dx[dir]; ny = y + dy[dir];\n\t\t\t}\n\t\t\tx = nx; y = ny;\n\t\t}\n\t\tcout << y << \" \" << x << \" \" << DIRECTION[dir] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr int INF = 1e9;\n\n// dir, y, x\n// dir: 0 -> north, 1->east, 2->south, 3->west\nusing data = tuple<int, int, int>;\n\nint main() {\n    ll H, W;\n    ll L;\n    while(cin >> H >> W >> L, H) {\n        vector<string> v(H);\n        vector<data> path;\n        vector<vector<vector<int>>> res(4, vector<vector<int>>(H, vector<int>(W, INF)));\n        int dir = 0, y = 0, x = 0;\n        for(int i=0; i<H; ++i) {\n            cin >> v[i];\n            for(int j=0; j<W; ++j) {\n                if(v[i][j] != '.' && v[i][j] != '#') {\n                    if(v[i][j] == 'N') {\n                        dir = 0;\n                    } else if(v[i][j] == 'E') {\n                        dir = 1;\n                    } else if(v[i][j] == 'S') {\n                        dir = 2;\n                    } else {\n                        dir = 3;\n                    }\n                    y = i, x = j;\n                }\n            }\n        }\n        int cnt = 0;\n        int dx[4] = {0, 1, 0, -1},\n            dy[4] = {-1, 0, 1, 0};\n        bool f = false;\n        char d[4] = {'N', 'E', 'S', 'W'};\n        while(true) {\n            if(cnt == L) {\n                f = true;\n                break;\n            }\n            if(res[dir][y][x] != INF) {\n                break;\n            }\n            if(cnt != 0) {\n                res[dir][y][x] = cnt;\n                path.push_back(make_tuple(dir, x, y));\n            }\n            int ny = y + dy[dir], nx = x + dx[dir];\n            int ndir = dir;\n            while(ny < 0 || H <= ny || nx < 0 || W <= nx || v[ny][nx] == '#') {\n                ndir = (ndir+1)%4;\n                ny = y + dy[ndir];\n                nx = x + dx[ndir];\n            }\n            if(res[ndir][ny][nx] != INF) {\n                x = nx;\n                y = ny;\n                dir = ndir;\n                break;\n            }\n            x = nx;\n            y = ny;\n            dir = ndir;\n            ++cnt;\n        }\n        if(f) {\n            cout << y+1 << \" \" << x+1 << ' ' << d[dir] << endl;\n        } else {\n            auto t = make_tuple(dir, x, y);\n            int idx = 0;\n            for(int i=0; i<path.size(); ++i) {\n                if(path[i] == t) {\n                    idx = i;\n                    break;\n                }\n            }\n            L -= cnt+1;\n            L %= (path.size() - idx);\n            int adir, ax, ay;\n            tie(adir, ax, ay) = path[idx + L];\n            cout << ay+1 << ' ' << ax+1 << ' ' << d[adir] << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {1,0,-1,0};\nconst static int ty[] = {0,1,0,-1};\nconst static char dir_char[] = {'E','S','W','N'};\n \nenum dir {\n  EAST,\n  SOUTH,\n  WEST,\n  NORTH\n};\n\nstruct PosInfo{\n  int x;\n  int y;\n  int dir;\n  PosInfo(int _x,int _y,int _dir) : x(_x),y(_y),dir(_dir) {}\n};\n\nstatic const double EPS = 1e-8;\n\n\nvoid printStage(char stage[100][100],int H,int W,\n\t\tint current_x,int current_y,int current_dir){\n\n  char output[100][100];\n\n  //init\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      output[y][x] = '.';\n    }\n  }\n\n  //wall\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(stage[y][x] == '#'){\n\toutput[y][x] = '#';\n      }\n    }\n  }\n\n  //robot\n  output[current_y][current_x] = dir_char[current_dir];\n\n  //write\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      printf(\"%c\",output[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int H,W;\n  ll L;\n  while(~scanf(\"%d %d %ld\",&H,&W,&L)){\n    if(H == 0 && W == 0 && L == 0) break;\n\n    char stage[100][100];\n\n    int current_dir = NORTH;\n    int current_x = 0;\n    int current_y = 0;\n\n    for(int y=0;y<H;y++){\n      char line[120];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] == 'E'){\n\t  current_dir = EAST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'S'){\n\t  current_dir = SOUTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'W'){\n\t  current_dir = WEST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'N'){\n\t  current_dir = NORTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n      }\n    }\n\n    int dp[4][100][100];\n    for(int i=0;i<4;i++){\n      memset(dp[i],-1,sizeof(dp[i]));\n    }\n\n    ll round = 0;\n    for(;round < L;round++){\n      if(dp[current_dir][current_x][current_y] >= 0) break;\n      \n      dp[current_dir][current_x][current_y]=round;\n      // printStage(stage,H,W,current_x,current_y,current_dir);\n      // cout << dx << \" \" << dy << \" \" << endl;\n\n      for(int i=0;i<4;i++){\n\t//i==0 : not rotating\n\tint next_dir = (current_dir + i) % 4;\n\tint dx = current_x + tx[next_dir];\n\tint dy = current_y + ty[next_dir];\n\n\tif(dy < 0 || dy >= H || dx < 0 || dx >= W){\n\t  continue;\n\t}\n\telse if(stage[dy][dx] == '#'){\n\t  continue;\n\t}\n\n\tcurrent_dir = next_dir;\n\tcurrent_x = dx;\n\tcurrent_y = dy;\n\tbreak;\n      }\n    }\n\n    int res_x = current_x;\n    int res_y = current_y;\n    int res_dir = current_dir;\n\n    //start:0 3 6 9 ... start:96\n    ll last_round = round;\n    ll cycle_begining_round = dp[current_dir][current_x][current_y];\n\n    if(last_round < L){\n      ll cycle_length = last_round - cycle_begining_round;\n      ll cycle_relative_pos = (L - cycle_begining_round) % cycle_length;\n      ll cycle_abs_pos = cycle_relative_pos + cycle_begining_round;\n\n      for(int i=0;i<4;i++){\n\tfor(int x=0;x<W;x++){\n\t  for(int y=0;y<H;y++){\n\t    // printf(\"i:%d x:%d y:%d %d\\n\",i,x,y,dp[i][x][y]);\n\t    if(dp[i][x][y] == cycle_abs_pos){\n\t      res_x = x;\n\t      res_y = y;\n\t      res_dir = i;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    printf(\"%d %d %c\\n\",res_y+1,res_x+1,dir_char[res_dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int h,w;\n  long long l;\n  int x,y,d;\n  string g[100];\n\n  int vis[100][100][4];\n  char dir[] = {'N','E','S','W'};\n  int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\n  int px[40100],py[40100],pd[40100];\n\n  while(cin >> h >> w >> l,h){\n    for(int i=0;i<h;i++)cin >> g[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<4;k++){\n\t  if(g[i][j] == dir[k]){\n\t    y = i; x = j; d = k;\n\t  }\n\t  vis[i][j][k] = -1;\n\t}\n      }\n    }\n\n    int step = 0;\n    for(;;){\n      if(vis[y][x][d]>=0)break;\n      vis[y][x][d] = step;\n      \n      py[step] = y; px[step] = x; pd[step] = d;\n      step++;\n\n      for(int i=0;i<4;i++){\n\tint nd = (d+i)%4;\n\tint ny = y+dy[nd], nx = x+dx[nd];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\ty = ny; x = nx; d = nd;\n\tbreak;\n      }\n    }\n\n    int head = vis[y][x][d], now = l - head;\n    now %= step-head;\n    now += head;\n    cout << py[now]+1 << \" \" << px[now]+1 << \" \" << dir[pd[now]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint dd[] = {-1, 0, 1, 0, -1};\n\nstruct state {\n    int x, y, d;\n    ll turn;\n};\n\nint main(){\n    cin.sync_with_stdio(false);\n    int h, w;\n    ll l;\n    while(cin >> h >> w >> l, h) {\n        ll maze[h + 2][w + 2][4];\n        rep(i, h + 2)rep(j, w + 2)rep(k, 4) maze[i][j][k] = INF;\n\n        state s;\n        repl(i, 1, h + 1)repl(j, 1, w + 1) {\n            char c;\n            cin >> c;\n            if (c == '.') rep(k, 4) maze[i][j][k] = -1;\n            else if (c != '#') {\n                switch(c) {\n                    case 'N': s.d = 0; break;\n                    case 'E': s.d = 1; break;\n                    case 'S': s.d = 2; break;\n                    case 'W': s.d = 3; break;\n                }\n                s.x = j - dd[s.d + 1], s.y = i - dd[s.d], s.turn = 0;\n                rep(k, 4) maze[i][j][k] = -1;\n            }\n        }\n\n        while (true) {\n            while (maze[s.y + dd[s.d]][s.x + dd[s.d + 1]][s.d] != INF) {\n                s.y += dd[s.d], s.x += dd[s.d + 1];\n\n                if (maze[s.y][s.x][s.d] >= 0) {\n                    s.turn = (l - maze[s.y][s.x][s.d]) / (s.turn - maze[s.y][s.x][s.d])\n                    * (s.turn - maze[s.y][s.x][s.d]) + maze[s.y][s.x][s.d];\n                }\n                if (s.turn == l) break;\n                maze[s.y][s.x][s.d] = s.turn;\n                s.turn++;\n            }\n            if (s.turn == l) break;\n            s.d = (s.d + 1) % 4;\n        }\n\n        char c;\n        switch(s.d) {\n            case 0: c = 'N'; break;\n            case 1: c = 'E'; break;\n            case 2: c = 'S'; break;\n            case 3: c = 'W'; break;\n        }\n\n        cout << s.y << \" \" << s.x << \" \" << c << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\nchar d[] = {'E', 'S', 'W', 'N'};\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll h, w, l;\n\twhile(cin >> h >> w >> l)\n\t{\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tint y, x, dir;\n\t\tchar table[h + 1][w + 1];\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tfor(int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tcin >> table[i][j];\n\t\t\t\tif(table[i][j] == 'E')\n\t\t\t\t{\n\t\t\t\t\ty = i; x = j; dir = 0;\n\t\t\t\t}\n\t\t\t\tif(table[i][j] == 'S')\n\t\t\t\t{\n\t\t\t\t\ty = i; x = j; dir = 1;\n\t\t\t\t}\n\t\t\t\tif(table[i][j] == 'W')\n\t\t\t\t{\n\t\t\t\t\ty = i, x = j; dir = 2;\n\t\t\t\t}\n\t\t\t\tif(table[i][j] == 'N')\n\t\t\t\t{\n\t\t\t\t\ty = i; x = j; dir = 3;\n\t\t\t\t}\n\t\t\t}\n\t\tll flag[h + 1][w + 1][4];\n\t\tmemset(flag, -1, sizeof(flag));\n\t\twhile(l > 0)\n\t\t{\n\t\t\tif(flag[y][x][dir] != -1)\n\t\t\t{\n\t\t\t\tll tmp = (flag[y][x][dir] - l);\n\t\t\t\tl %= tmp;\n\t\t\t\tif(l == 0) l += tmp;\n\n\t\t\t}\n\t\t\telse \n\t\t\t\tflag[y][x][dir] = l;\n\t\t\tint ny = y + dy[dir];\n\t\t\tint nx = x + dx[dir];\n\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w || table[ny][nx] == '#')\n\t\t\t{\n\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty += dy[dir];\n\t\t\t\tx += dx[dir];\n\t\t\t\tl--;\n\t\t\t}\n\t\t}\n\t\tcout << y + 1 << \" \" << x + 1 << \" \" << d[dir] << endl;\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\nusing namespace std;\n\ntypedef long long LL;\n\nint h, w;\nLL L;\nint visit[102][102][4];\nint log[41000];\nchar c[102][102];\n\nint main(){\n\tconst string dirstr = \"NESW\";\n\tint dy[] = {-1, 0, 1, 0};\n\tint dx[] = {0, 1, 0, -1};\n\n\twhile(scanf(\"%d%d%lld\", &h, &w, &L), h){\n\t\tmemset(visit, -1, sizeof visit);\n\t\tmemset(c, '#', sizeof c);\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tscanf(\"%s\", c[i] + 1);\n\t\t\tc[i][w + 1] = '#';\n\t\t}\n\n\t\tint y, x, d;\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif(c[i][j] != '.' && c[i][j] != '#'){\n\t\t\t\ty = i;\n\t\t\t\tx = j;\n\t\t\t\td = dirstr.find(c[i][j]);\n\t\t\t\tc[i][j] = '.';\n\t\t\t\tlog[0] = (y << 10) | (x << 2) | d;\n\t\t\t\tvisit[y][x][d] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tint ansy = -1, ansx = -1, ansd = -1;\n\t\tfor(LL t = 0; ;){\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(c[ny][nx] != '#'){\n\t\t\t\t++t;\n\t\t\t\tlog[t] = (ny << 10) | (nx << 2) | d;\n\t\t\t\ty = ny;\n\t\t\t\tx = nx;\n\t\t\t\t\n\t\t\t\tif(t == L){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\td = (d + 1) & 3;\n\t\t\t}\n\n\t\t\tint p = visit[y][x][d];\n\t\t\tif(p < 0){\n\t\t\t\tvisit[y][x][d] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLL dif = t - p;\n\t\t\t\tLL rem = (L - t) % dif;\n\t\t\t\tint q = log[p + rem];\n\t\t\t\ty = q >> 10;\n\t\t\t\tx = (q >> 2) & 0xff;\n\t\t\t\td = q & 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d %c\\n\", y, x, dirstr[d]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int INF = 1e+8;\nconst int MAX_W = 101;\n// テ・ツ?・テ・ツ環?\nint H, W;\nlong long L;\nchar c[MAX_W][MAX_W];\n// h[c] := テヲツ鳴?・ツュツ?c テ」ツ?ォテ・ツッツセテ・ツソツ愿」ツ?凖」ツつ凝・ツ青妥」ツ??\nchar h[256] = {0};\n// 4 ティツソツ妥・ツつ?\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n// memo[y][x][d] := (x,y) テ」ツ?ォテ・ツ青妥」ツ??d テ」ツ?ァテ」ツ?淌」ツ?ゥテ」ツつ甘ァツ敖?」ツ?湘」ツ?ョテ」ツ?ォテ」ツ?凝」ツ?凝」ツつ虐tepテヲツ閉ー (テヲツ篠「テァツエツ「テ」ツ?療」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?ィテ」ツ?催」ツ?ッ INF )\nint memo[MAX_W][MAX_W][4];\n\nvoid debug(int px, int py, int d, int step){\n\tcout << \"[debug] step:\" << step << endl;\n\tchar ch;\n\tif( d == 0 ) ch = '^';\n\tif( d == 1 ) ch = '>';\n\tif( d == 2 ) ch = 'v';\n\tif( d == 3 ) ch = '<';\n\t\n\tfor(int y=0 ; y < H ; y++ ){\n\t\tfor(int x=0 ; x < W ; x++ ){\n\t\t\tif( y == py && x == px ){\n\t\t\t\tcout << ch;\n\t\t\t}else{\n\t\t\t\tcout << c[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\th['N'] = 0; h['E'] = 1; h['S'] = 2; h['W'] = 3;\n\th[0] = 'N'; h[1] = 'E'; h[2] = 'S'; h[3] = 'W';\n\t\n\twhile( cin >> H >> W >> L, H || W || L ){\n\t\t// テ・ツ按敕ヲツ慊淌・ツ個?\n\t\tfor(int y=0 ; y < H ; y++ ){\n\t\t\tfor(int x=0 ; x < W ; x++ ){\n\t\t\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\t\t\tmemo[y][x][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// テ・ツ?・テ・ツ環?\n\t\tfor(int y=0 ; y < H ; y++ ){\n\t\t\tcin >> c[y];\n\t\t}\n\t\t// テ」ツつケテ」ツつソテ」ツδシテ」ツδ暗、ツスツ催ァツスツョテ」ツつ津ィツェツソテ」ツ?ケテ」ツつ?\n\t\tint sx, sy, dir;\n\t\tfor(int y=0 ; y < H ; y++ ){\n\t\t\tfor(int x=0 ; x < W ; x++ ){\n\t\t\t\tif( c[y][x] == 'N' || c[y][x] == 'E' || c[y][x] == 'S' || c[y][x] == 'W' ){\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t\tdir = h[c[y][x]];\n\t\t\t\t\tc[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// テ」ツδュテ」ツδ愿」ツδε」ツδ暗」ツつ津・ツ仰陛」ツ?凝」ツ??\n\t\tint px = sx, py = sy, d = dir, mod, step=0, k;\n\t\twhile( true ){\n\t\t\t//debug(px, py, d, step);\n\t\t\tmemo[py][px][d] = step;\n\t\t\tint mx = px + dx[d];\n\t\t\tint my = py + dy[d];\n\t\t\tif( mx < 0 || my < 0 || W <= mx || H <= my || c[my][mx] == '#' ){\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}else{\n\t\t\t\tif( memo[my][mx][d] != INF ){\n\t\t\t\t\tmod = (step+1) - memo[my][mx][d];\n\t\t\t\t\tk = memo[my][mx][d];\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tpx = mx;\n\t\t\t\t\tpy = my;\n\t\t\t\t\tstep++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( k < L ){\n\t\t\tL -= k;\n\t\t\tL = L % mod;\n\t\t\tL += k;\n\t\t\tL += mod;\n\t\t}\n\t\tpx = sx, py = sy, d = dir, step = 0;\n\t\tint ax, ay, ad;\n\t\twhile( true ){\n\t\t\tif( step == L ){\n\t\t\t\tax = px;\n\t\t\t\tay = py;\n\t\t\t\tad = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint mx = px + dx[d];\n\t\t\tint my = py + dy[d];\n\t\t\tif( mx < 0 || my < 0 || W <= mx || H <= my || c[my][mx] == '#' ){\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}else{\n\t\t\t\tpx = mx;\n\t\t\t\tpy = my;\n\t\t\t\tstep++;\n\t\t\t}\n\t\t}\n\t\tcout << ay+1 << \" \" << ax+1 << \" \" << h[ad] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {1,0,-1,0};\nconst static int ty[] = {0,1,0,-1};\nconst static char dir_char[] = {'E','S','W','N'};\n \nenum dir {\n  EAST,\n  SOUTH,\n  WEST,\n  NORTH\n};\n\nstatic const double EPS = 1e-8;\n\nvoid printStage(char stage[100][100],int H,int W,\n\t\tint current_x,int current_y,int current_dir){\n\n  char output[100][100];\n\n  //init\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      output[y][x] = '.';\n    }\n  }\n\n  //wall\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(stage[y][x] == '#'){\n\toutput[y][x] = '#';\n      }\n    }\n  }\n\n  //robot\n  output[current_y][current_x] = dir_char[current_dir];\n\n  //write\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      printf(\"%c\",output[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int H,W;\n  ll L;\n  while(~scanf(\"%d %d %ld\",&H,&W,&L)){\n    if(H == 0 && W == 0 && L == 0) break;\n\n    char stage[100][100];\n\n    int current_dir = NORTH;\n    int current_x = 0;\n    int current_y = 0;\n\n    for(int y=0;y<H;y++){\n      char line[120];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] == 'E'){\n\t  current_dir = EAST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'S'){\n\t  current_dir = SOUTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'W'){\n\t  current_dir = WEST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'N'){\n\t  current_dir = NORTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n      }\n    }\n\n    vector<ll> dp[100][100][4];\n    int TTL = 1000000;\n    int MAX_TTL = 1000000;\n    while(TTL-- > 0){\n      int dx = current_x + tx[current_dir];\n      int dy = current_y + ty[current_dir];\n\n      // printStage(stage,H,W,current_x,current_y,current_dir);\n      // cout << dx << \" \" << dy << \" \" << endl;\n      if(dy < 0 || dy >= H || dx < 0 || dx >= W){\n\tcurrent_dir = (current_dir + 1) % 4;\n\tTTL++;\n\tcontinue;\n      }\n      else if(stage[dy][dx] == '#'){\n\tcurrent_dir = (current_dir + 1) % 4;\n\tTTL++;\n\tcontinue;\n      }\n      current_x = dx;\n      current_y = dy;\n      dp[current_x][current_y][current_dir].push_back(MAX_TTL-TTL);\n    }\n\n    int res_x = 0;\n    int res_y = 0;\n    int res_dir = 0;\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tfor(int i=0;i<4;i++){\n\t  if(dp[x][y][i].size() < 2) continue;\n\t  ll a0 = dp[x][y][i][0];\n\t  ll a1 = dp[x][y][i][1];\n\t  // L == a0 + k(a1-a0)\n\t  // L - a0 == k(a1-a0)\n\t  // k == (L - a0) / (a1 - a0)\n\n\t  if(L - a0 < 0) continue;\n\t  if(a1 - a0 <= 0) continue;\n\n\t  if((L-a0) % (a1-a0) == 0){\n\t    res_x = x;\n\t    res_y = y;\n\t    res_dir = i;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d %d %c\\n\",res_y+1,res_x+1,dir_char[res_dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\nchar f(int i) {\n\tif (i == 0)return 'S';\n\tif (i == 1)return 'E';\n\tif (i == 2)return 'N';\n\treturn 'W';\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, m, l;\n\twhile (cin >> n >> m >> l, n) {\n\t\tvector<string> v(n);\n\t\tREP(i, n)cin >> v[i];\n\t\tint x, y, d;\n\t\tREP(i, n)REP(j, m) {\n\t\t\tif (isalpha(v[i][j])) {\n\t\t\t\tx = i;\n\t\t\t\ty = j;\n\t\t\t\tif (v[i][j] == 'S')d = 0;\n\t\t\t\telse if (v[i][j] == 'E')d = 1;\n\t\t\t\telse if (v[i][j] == 'N')d = 2;\n\t\t\t\telse d = 3;\n\t\t\t}\n\t\t}\n\t\tll a, b, cnt = 0;\n\t\tmap<pair<pii, int>, int> mp;\n\t\twhile (1) {\n\t\t\tif (mp.count({ {x, y}, d })) {\n\t\t\t\ta = mp[{ {x, y}, d}];\n\t\t\t\tb = cnt - mp[{ {x, y}, d}];\n\t\t\t\tif (l < a) {\n\t\t\t\t\tfor (auto c : mp) {\n\t\t\t\t\t\tif (c.second == l) {\n\t\t\t\t\t\t\tcout << c.first.first.first + 1 << \" \" << c.first.first.second + 1 << \" \" << f(c.first.second) << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tll num = (l - a) % b + a;\n\t\t\t\t\tfor (auto c : mp) {\n\t\t\t\t\t\tif (c.second == num) {\n\t\t\t\t\t\t\tcout << c.first.first.first + 1 << \" \" << c.first.first.second + 1 << \" \" << f(c.first.second) << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmp[{ {x, y}, d}] = cnt;\n\t\t\tcnt++;\n\t\t\twhile (1) {\n\t\t\t\tint nx = x + dx[d * 2], ny = y + dy[d * 2];\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= n || ny >= m || v[nx][ny] == '#') {\n\t\t\t\t\td = (d + 3) % 4;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tx += dx[d * 2], y += dy[d * 2];\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint main() {\n\tint h, w;\n\tlong long n;\n\twhile (cin >> h >> w >> n, h){\n\t\tvector<string> vs;\n\t\tvector<vector<vector<int>>> vvvi(h,vector<vector<int>>(w,vector<int>(4,-1)));\n\t\tint x, y, d;\n\t\tREP(i, h){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tvs.push_back(s);\n\t\t\tREP(j, w){\n\t\t\t\tif (s[j] == 'N' || s[j] == 'E' || s[j] == 'W' || s[j] == 'S'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tif (s[j] == 'W')d=0;\n\t\t\t\t\tif (s[j] == 'S')d = 1;\n\t\t\t\t\tif (s[j] == 'E')d = 2;\n\t\t\t\t\tif (s[j] == 'N')d = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvvi[y][x][d]=0;\n\n\t\tfor(long long i=0;i<n;i++){\n\t\t\twhile (x + dx[d] < 0 || x + dx[d] >= w || y + dy[d] < 0 || y + dy[d] >= h || vs[y + dy[d]][x + dx[d]] == '#'){\n\t\t\td+=3;\n\t\t\td%=4;\n\t\t\t}\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t\tif (vvvi[y][x][d]==-1)\n\t\t\tvvvi[y][x][d] = i + 1;\n\t\t\telse\n\t\t\t\tn=i+1+((n - i - 1) % (i+1-vvvi[y][x][d]));\n\t\t}\n\t\tchar c;\n\t\tif (d == 0)c = 'W';\n\t\tif (d == 1)c = 'S';\n\t\tif (d == 2)c = 'E';\n\t\tif (d == 3)c = 'N';\n\t\tcout << (y + 1) << \" \" << (x + 1) << \" \"<<c<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        int count = 0;\n        string wall = \"\";\n        bool used[101][101][4];\n        fill_n((bool *)used, 101*101, false);\n\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n            }\n        }\n\n        int sx, sy, sdir;\n        sx = x;\n        sy = y;\n        sdir = dir;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n            }\n            else\n                dir = (dir+1) % 4;\n            if (used[y][x][dir]) {\n                l = l % count;\n            } else if(vs[y][x] == '.') {\n                used[y][x][dir] = true;\n            }\n        }\n        cout << y << \" \" << x << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\nusing ll = int64_t;\n\nenum {\n    UP, RIGHT, DOWN, LEFT, DIR_NUM\n};\n\nint main() {\n    ll H, W, L;\n    while (cin >> H >> W >> L) {\n        if (H == 0 && W == 0 && L == 0) {\n            break;\n        }\n\n        vector<string> c(H);\n        pair<ll, ll> start;\n        ll start_dir;\n        for (ll i = 0; i < H; i++) {\n            cin >> c[i];\n            for (ll j = 0; j < c[i].size(); j++) {\n                if (c[i][j] == 'N' || c[i][j] == 'E' || c[i][j] == 'S' || c[i][j] == 'W') {\n                    start.first = i;\n                    start.second = j;\n                    start_dir = (c[i][j] == 'N' ? UP :\n                        c[i][j] == 'E' ? RIGHT :\n                        c[i][j] == 'S' ? DOWN :\n                        c[i][j] == 'L' ? LEFT : -1);\n                }\n            }\n        }\n\n\n        vector<vector<vector<ll>>> memo(H, vector<vector<ll>>(W, vector<ll>(4, INT_MAX)));\n        ll y = start.first;\n        ll x = start.second;\n        ll dir = start_dir;\n        ll step = 0;\n\n        c[y][x] = '.';\n\n        ll dx[] = { 0, 1, 0, -1 };\n        ll dy[] = { -1, 0, 1, 0 };\n\n        auto isOK = [&](ll x, ll y) {\n            return (0 <= x && x < W && 0 <= y && y < H && c[y][x] == '.');\n        };\n        \n        while (true) {\n            if (step == L) {\n                break;\n            }\n            if (step > memo[y][x][dir]) {\n                //ループした\n                //差分が周期\n                ll period = step - memo[y][x][dir];\n                L -= memo[y][x][dir];\n                L %= period;\n                step = 0;\n                continue;\n            } else {\n                memo[y][x][dir] = step;\n            }\n\n            //1マス進む\n            while (true) {\n                ll nx = x + dx[dir];\n                ll ny = y + dy[dir];\n                if (isOK(nx, ny)) {\n                    x = nx;\n                    y = ny;\n                    step++;\n                    break;\n                }\n                dir = (dir + 1) % DIR_NUM;\n            }\n        }\n\n        printf(\"%lld %lld %c\\n\", y + 1, x + 1, (dir == UP ? 'N' : dir == RIGHT ? 'E' : dir == DOWN ? 'S' : 'W'));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <limits.h>\n#include <map>\n\nusing namespace std;\ntypedef long long int ll;\n\nint solve(void);\nbool isValid(const int y, const int x, vector<string> &maze);\nvoid search(int &y, int&x, int&d, int&cnt, int L, vector<string>&maze, vector<vector<vector<int>>> &memo);\n\nvoid output(vector<vector<vector<int>>> &memo) {\n\tfor (int k = 0; k < 4; k++) {\n\t\tfor (int i = 0; i < memo.size(); i++) {\n\t\t\tfor (int j = 0; j < memo[i].size(); j++) {\n\t\t\t\tif (memo[i][j][k] < INT_MAX)\n\t\t\t\t\tcout << memo[i][j][k] << \" \";\n\t\t\t\telse\n\t\t\t\t\tcout << \"*\" << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n}\n\nint main(void) {\n\n\t//FILE *fpin = freopen(\"data.txt\", \"r\", stdin);\n\twhile (solve());\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\tll H, W, L;\n\tcin >> H >> W >> L;\n\tif (!(H | W | L)) { return 0; }\n\tvector<string> maze(H);\n\n\t/*\n\t\tmemo[y][x][direction] = the number of steps\n\t*/\n\tvector<vector<vector<int>>> memo\n\t\t(H, vector<vector<int>>(W, vector<int>(4,INT_MAX) ) );\n\tvector<vector<vector<int>>> memo_s;\n\n\t//input\n\n\tmap<char, int> mp;\n\t\tmp['E'] = 0;\n\t\tmp['S'] = 1;\n\t\tmp['W'] = 2;\n\t\tmp['N'] = 3;\n\tvector<char> v = {'E','S','W','N'};\n\n\tint x, y, d, cnt = 0;\n\tint loop_start = 0, loop_end;\n\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> maze[i];\n\t\tfor (int j = 0; j < maze[i].length(); j++) {\n\t\t\tif (maze[i][j] != '.' && maze[i][j] != '#') {\n\t\t\t\ty = i; x = j; d = mp[maze[i][j]];\n\t\t\t\tmemo[y][x][d] = cnt;\n\t\t\t}\n\t\t}\n\t}\n\tmemo_s = memo;\n\n\tsearch(y, x, d, cnt, L, maze, memo);\n\n\tloop_start = memo[y][x][d];\n\tloop_end = cnt;\n\n\tif (L <= loop_end) {\n\t} else {\n\t\tL -= loop_end;\n\t\tL %= (loop_end - loop_start);\n\t\tcnt = 0;\n\t\tsearch(y, x, d, cnt, L, maze, memo_s);\n\t}\n\n\tcout << y + 1 << \" \" << x + 1 << \" \" << v[d] << endl;\n\n\treturn 1;\n}\n\nbool isValid(const int y, const int x, vector<string>& maze)\n{\n\treturn (0<=y && 0<=x && y < maze.size() && x < maze[y].length() && maze[y][x] != '#');\n}\n\nvoid search(int & y, int & x, int & d, int & cnt, int L, vector<string>& maze, vector<vector<vector<int>>>& memo)\n{\n\n\tint dd[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\n\n\twhile (true) {\n\n\t\tif (cnt == L) { break; }\n\n\t\tif (isValid(y + dd[d][0], x + dd[d][1], maze)) {\n\n\t\t\ty += dd[d][0];\n\t\t\tx += dd[d][1];\n\t\t\tcnt++;\n\n\t\t\tif (memo[y][x][d] < INT_MAX) { break; }\n\t\t\tmemo[y][x][d] = min(cnt, memo[y][x][d]);\n\n\t\t}\n\t\telse {\n\n\t\t\td = (d + 1) % 4;\n\n\t\t\tif (memo[y][x][d] < INT_MAX) { break; }\n\t\t\tmemo[y][x][d] = min(cnt, memo[y][x][d]);\n\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 拓真 on 2018/06/30.\n//\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) FOR(i,0,b)\n#define INF mugen\n#define dump(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(a) (a).begin(),(a).end()\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntemplate <class T> void chmin(T & a, T const & b) { if (b < a) a = b; }\n\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nstruct robot{\n    robot(){};\n    int x,y;\n    int dir;\n    robot(int x,int y,int dir){\n        this->x=x;\n        this->y=y;\n        this->dir=dir;\n    }\n};\n\nchar toc(int x){\n    if(x==0)return 'N';\n    else if(x==1)return 'E';\n    else if(x==2)return 'S';\n    else return 'W';\n}\nint dp[110][110][5];\nvector<string> maze;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint main(){\n    int h,w;\n    ll L;\n    while(cin>>h>>w>>L,h){\n\n\n        rep(i,110)rep(j,110)rep(k,5)dp[i][j][k]=0;\n        maze.clear();\n        rep(i,h){\n            string s;\n            cin>>s;\n            maze.push_back(s);\n        }\n\n        robot pre;\n        rep(i,h)rep(j,w){\n            if(maze[i][j]=='N'){\n                pre=robot(j,i,0);\n            }\n            if(maze[i][j]=='E'){\n                pre=robot(j,i,1);\n            }\n            if(maze[i][j]=='S'){\n                pre=robot(j,i,2);\n            }\n            if(maze[i][j]=='W'){\n                pre=robot(j,i,3);\n            }\n        }\n\n        bool flag=false;\n\n        dp[pre.y][pre.x][pre.dir]=1;\n        for(int i=0;i<L;i++){\n\n            int nexty=pre.y+dy[pre.dir];\n            int nextx=pre.x+dx[pre.dir];\n            if(nexty>=0 && nexty<h&&nextx>=0&&nextx<w&&maze[nexty][nextx]!='#'){\n                pre=robot(nextx,nexty,pre.dir);\n\n            }else{\n                int id=1;\n                while(1){\n                    int nx=pre.x+dx[(pre.dir+id)%4];\n                    int ny=pre.y+dy[(pre.dir+id)%4];\n                    if(nx>=0&&nx<w&&ny>=0&&ny<h&&maze[ny][nx]=='.'){\n                        pre=robot(pre.x+dx[(pre.dir+id)%4],pre.y+dy[(pre.dir+id)%4],(pre.dir+id)%4);\n                        break;\n                    }\n                    id++;\n                }\n            }\n\n\n\n           //cout<<pre.y+1<<' '<<pre.x+1<<' '<<toc(pre.dir)<<endl;\n\n\n\n\n            if(!flag&&dp[pre.y][pre.x][pre.dir]){\n                L-=(L/i)*i;\n                flag=true;\n            }\n        }\n\n\n        cout<<pre.y+1<<' '<<pre.x+1<<' '<<toc(pre.dir)<<endl;\n\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 105\nusing namespace std;\ntypedef long long ll;\nchar Rot(char);\nint GetNum(char);\n\nint main(){\n  ll h,w,y,x,r,me[N][N][4];\n  char c;\n  string s[N];\n  ll l,t;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tfor(int k=0;k<4;k++) me[i][j][k]=-1;\n      }\n    t=0;\n    r=GetNum(c);\n    me[y][x][r]=t;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      if(l==t) break;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      r=GetNum(c);\n      if(me[y][x][r]!=-1&&t-me[y][x][r]!=0) t=l-((l-me[y][x][r])%(t-me[y][x][r]));\n      me[ny][nx][r]=t;\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}\n\nint GetNum(char c){\n  if(c=='N') return 0;\n  if(c=='E') return 1;\n  if(c=='S') return 2;\n  return 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nusing T=tuple<int,int,int>;\n\nint main(){\n    int H,W;\n    int64_t L;\n    while(cin>>H>>W>>L,H){\n        char b[H+2][W+2];\n        fill(b[0],b[H+2],'#');\n        int y,x,d;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin>>b[i][j];\n                if(b[i][j]!='.'&&b[i][j]!='#'){\n                    y=i; x=j;\n                    switch(b[i][j]){\n                        case 'N':\n                            d=0;\n                            break;\n                        case 'E':\n                            d=1;\n                            break;\n                        case 'S':\n                            d=2;\n                            break;\n                        case 'W':\n                            d=3;\n                            break;\n                    }\n                }\n            }\n        }\n        int64_t v[H+2][W+2][4];\n        fill(v[0][0],v[H+2][0],0);\n        vector<T> V;\n        int dy[4]={-1,0,1,0};\n        int dx[4]={0,1,0,-1};\n        string s=\"NESW\";\n        bool flag=false;\n        while(true){\n            // cout<<' '<<y<<' '<<x<<' '<<d<<endl;\n            if(b[y+dy[d]][x+dx[d]]!='#'){\n                if(v[y+dy[d]][x+dx[d]][d]&&!flag){\n                    flag=true;\n                    L=v[y+dy[d]][x+dx[d]][d]+(L-v[y+dy[d]][x+dx[d]][d])%(v[y][x][d]-v[y+dy[d]][x+dx[d]][d]+1);\n                }else{\n                    v[y+dy[d]][x+dx[d]][d]=v[y][x][d]+1;\n                }\n                y+=dy[d]; x+=dx[d];\n                if(v[y][x][d]==L){\n                    cout<<y<<' '<<x<<' '<<s[d]<<endl;\n                    break;\n                }\n            }else{\n                v[y][x][(d+1)%4]=v[y][x][d];\n                d=(d+1)%4;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 110\n#define MAX_W 110\ntypedef long long ll;\n\nll H,W,L;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nchar getDir(int x){\n  if(x == 0){ return 'W'; }\n  if(x == 1){ return 'N'; }\n  if(x == 2){ return 'E'; }\n  if(x == 3){ return 'S'; }\n}\n\nint getDir(char ch){\n  if(ch == 'W'){ return 0; }\n  if(ch == 'N'){ return 1; }\n  if(ch == 'E'){ return 2; }\n  if(ch == 'S'){ return 3; }\n}\n\nbool inField(int x,int y){\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid solve(int x,int y,int dir){\n  int d[MAX_H][MAX_W][4];\n  memset(d,-1,sizeof(d));\n  d[y][x][dir] = 0;\n\n  while(L > 0){\n    int nx = x + dx[dir],ny = y + dy[dir];\n    if(!inField(nx,ny) || field[ny][nx] == '#'){\n      int ndir = (dir+1) % 4;\n      if(d[y][x][ndir] == -1){\n        d[y][x][ndir] = d[y][x][dir];\n      }else{\n        int diff = d[y][x][dir]-d[y][x][ndir];\n        if(diff > 0 && L >= diff){\n          L %= diff;\n        }\n      }\n      dir = ndir;\n    }else{\n      if(d[ny][nx][dir] == -1){\n        d[ny][nx][dir] = d[y][x][dir]+1;\n        L--;\n      }else{\n        L--;\n        int diff = d[y][x][dir]+1-d[ny][nx][dir];\n        if(diff > 0 && L >= diff){\n          L %= diff;\n        }\n      }\n      x = nx; y = ny;\n    }\n  }\n  cout << y+1 << \" \" << x+1 << \" \" << getDir(dir) << endl;\n}\n\nbool check(char ch){\n  if(ch == '.' || ch == '#'){\n    return false;\n  }\n  return true;\n}\n\nint main(){\n  int sx,sy,dir;\n  while(true){\n    cin >> H >> W >> L;\n    if(H == 0 && W == 0 && L == 0){\n      break;\n    }\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(check(field[i][j])){\n          sx = j; sy = i;\n          dir = getDir(field[i][j]);\n          field[i][j] = '.';\n        }\n      }\n    }\n    solve(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct RobotState\n{\n    int x;\n    int y;\n    char direction;\n};\n\nvoid DirectToEmptyCell(const vector<vector<char>> &maze, RobotState &robot)\n{\n    while (true)\n    {\n        switch (robot.direction)\n        {\n        case 'N':\n            if (maze[robot.y - 1][robot.x] == '#')\n            {\n                robot.direction = 'E';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'E':\n            if (maze[robot.y][robot.x + 1] == '#')\n            {\n                robot.direction = 'S';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'S':\n            if (maze[robot.y + 1][robot.x] == '#')\n            {\n                robot.direction = 'W';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        case 'W':\n            if (maze[robot.y][robot.x - 1] == '#')\n            {\n                robot.direction = 'N';\n            }\n            else\n            {\n                return;\n            }\n            break;\n        default:\n            throw logic_error(\"unko\");\n            break;\n        }\n    }\n}\n\nvoid GoForward(RobotState &robot)\n{\n    switch (robot.direction)\n    {\n    case 'N':\n        --robot.y;\n        break;\n    case 'E':\n        ++robot.x;\n        break;\n    case 'S':\n        ++robot.y;\n        break;\n    case 'W':\n        --robot.x;\n        break;\n    default:\n        throw logic_error(\"unko\");\n        break;\n    }\n}\n\nint main()\n{\n    int H, W;\n    long long L;\n    while (cin >> H >> W >> L, H || W || L)\n    {\n        vector<vector<char>> maze(H + 2, vector<char>(W + 2, '#'));\n        long long visited[102][102][4];\n        for (size_t i = 0; i < 102; i++)\n            for (size_t j = 0; j < 102; j++)\n                for (size_t k = 0; k < 4; k++)\n                {\n                    visited[i][j][k] = -1;\n                }\n        RobotState robot;\n        // input maze\n        for (int i = 1; i < H + 1; ++i) \n        {\n            for (int j = 1; j < W + 1; ++j)\n            {\n                char c;\n                cin >> c;\n                if (c == '.' || c == '#')\n                {\n                    maze[i][j] = c;\n                }\n                else\n                {\n                    maze[i][j] = '.';\n                    robot.x = j;\n                    robot.y = i;\n                    robot.direction = c;\n                }\n            }\n        }\n        // do this\n        for (long long i = 0; i < L; ++i)\n        {\n            DirectToEmptyCell(maze, robot);\n\n            // detect loop\n            auto& n = visited[robot.y][robot.x][robot.direction];\n            if (n != -1)\n            {\n                i = L - (L - i) % (i - n);\n                if (i == L)\n                {\n                    break;\n                }\n            }\n            else\n            {\n                n = i;\n            }\n\n            GoForward(robot);\n        }\n        cout << robot.y << ' ' << robot.x << ' ' << robot.direction << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nconst int  MAXN=111;\n\nchar str[MAXN][MAXN];\nlong long vis[MAXN][MAXN][4];\nint dir[][2]= {0,-1,1,0,0,1,-1,0};\nint H, W, cnt;\nlong long L;\n\nmain()\n{\n    int i, j;\n    int x, y, z, tx, ty;\n    char p[5]=\"NESW\";\n    while(scanf(\"%d%d%lld\",&H,&W,&L),H||W||L)\n    {\n        memset(vis,0,sizeof(vis));\n        memset(str,0,sizeof(str));\n\n       for(i=1;i<=H;i++)\n        {\n            scanf(\"%s\",str[i]+1);\n\n           for(j=1;j<=W;j++)\n            {\n                if(str[i][j]!='.'&&str[i][j]!='#')\n                {\n                    x=j;\n                    y=i;\n                    if(str[i][j]=='N') z=0;\n                    if(str[i][j]=='E') z=1;\n                    if(str[i][j]=='S') z=2;\n                    if(str[i][j]=='W') z=3;\n                    str[i][j]='.';\n                }\n            }\n        }\n        cnt=0;\n        for(; L>=1; L--,cnt++)\n        {\n            if(vis[y][x][z])\n            {\n                L=L%(cnt-vis[y][x][z]);\n                if(!L) break;\n            }\n            vis[y][x][z]=cnt;\n            while(1)\n            {\n                tx=x+dir[z][0];\n                ty=y+dir[z][1];\n                if(str[ty][tx]=='.') break;\n                z=(z+1)%4;\n            }\n            x=tx, y=ty;\n        }\n        printf(\"%d %d %c\\n\",y,x,p[z]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W, L;\nvector<string> maze;\nvector<vector<vector<int> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<int> >(W, vector<int>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    int p = L;\n    for(int step=0; step<=L;){\n        if(vis[x][y][d] != -1){\n            p = vis[x][y][d] + (L - step) % (step - vis[x][y][d]);\n            break;\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        if(!inrect(nx, ny) || maze[nx][ny] == '#')(d += 1) %= 4;\n        else x = nx, y = ny, step++;\n    }\n    // rep(i, H){rep(k, 4){rep(j, W)cout << vis[i][j][k] << ' '; cout << \" |  \";} cout << '\\n';}\n    // FIX LINE (this can't be accepted)\n    rep(i, H)rep(j, W)rep(k, 4)if(vis[i][j][k] == p)return make_tuple(i+1, j+1, \"NESW\"[k]);\n    return make_tuple(-1, -1, '?');\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n  \nusing namespace std;\n  \n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n   \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n  \ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n  \nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n  \ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n  \nstruct State{\n    int y,x,dir;\n};\n  \nvoid Solve(){\n    while(true){\n        ll h,w,l;\n        cin >> h >> w >> l;\n        if(h==0&&w==0&&l==0) break;\n        vector<string> cells(h);\n        REP(i,0,h) cin >> cells[i];\n  \n        const char empty='.',wall='#';\n        const int north=0,east=1,south=2,west=3;\n        int y,x,dir;\n        REP(i,0,h) REP(j,0,w) if(cells[i][j]!=empty&&cells[i][j]!=wall){\n            y=i; x=j;\n            switch(cells[i][j]){\n                case 'N': dir=north; break;\n                case 'E': dir=east; break;\n                case 'S': dir=south; break;\n                case 'W': dir=west; break;\n                default: break;\n            }\n            cells[i][j]=empty;\n            break;\n        }\n  \n        int rotate[4];\n        REP(i,0,4) rotate[i]=(i+1)%4;\n  \n        const int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n        State memo[100][100][4];\n        REP(i,0,h) REP(j,0,w) REP(k,0,4){\n            int y_=i,x_=j;\n            int ny=y_+dy[k],nx=x_+dx[k];\n            while(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty){\n                y_=ny; x_=nx;\n                ny=y_+dy[k]; nx=x_+dx[k];\n            }\n            memo[i][j][k]={y_,x_,rotate[k]};\n        }\n  \n        ll cnt=0;\n        while(cnt<l){\n            State &m=memo[y][x][dir];\n            int dist=abs(y-m.y)+abs(x-m.x);\n  \n            if(cnt+dist>=l){\n                y+=(m.y-y)*(l-cnt)/dist;\n                x+=(m.x-x)*(l-cnt)/dist;\n                break;\n            }\n              \n            y=m.y;\n            x=m.x;\n            dir=m.dir;\n            cnt+=dist;\n        }\n  \n        cout << y+1 << ' ' << x+1 << ' ' << \"NESW\"[dir] << endl;\n    }\n}\n  \nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    Solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nusing T=tuple<int,int,int>;\n\nint main(){\n    int H,W,L;\n    while(cin>>H>>W>>L,H){\n        char b[H+2][W+2];\n        fill(b[0],b[H+2],'#');\n        int y,x,d;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin>>b[i][j];\n                if(b[i][j]!='.'&&b[i][j]!='#'){\n                    y=i; x=j;\n                    switch(b[i][j]){\n                        case 'N':\n                            d=0;\n                            break;\n                        case 'E':\n                            d=1;\n                            break;\n                        case 'S':\n                            d=2;\n                            break;\n                        case 'W':\n                            d=3;\n                            break;\n                    }\n                }\n            }\n        }\n        int v[H+2][W+2];\n        fill(v[0],v[H+2],0);\n        vector<T> V;\n        int dy[4]={-1,0,1,0};\n        int dx[4]={0,1,0,-1};\n        string s=\"NESW\";\n        bool flag=false;\n        while(true){\n            // cout<<' '<<y<<' '<<x<<' '<<d<<endl;\n            if(b[y+dy[d]][x+dx[d]]!='#'){\n                if(v[y+dy[d]][x+dx[d]]&&!flag){\n                    flag=true;\n                    L=v[y+dy[d]][x+dx[d]]+(L-v[y+dy[d]][x+dx[d]])%(v[y][x]-v[y+dy[d]][x+dx[d]]+1);\n                }else{\n                    v[y+dy[d]][x+dx[d]]=v[y][x]+1;\n                }\n                y+=dy[d]; x+=dx[d];\n                if(v[y][x]==L){\n                    cout<<y<<' '<<x<<' '<<s[d]<<endl;\n                    break;\n                }\n            }else{\n                d=(d+1)%4;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n\nint W,H;\nll L;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar DtoS[] = {'N', 'E', 'S', 'W'};\nbool visited[100][100][4];\nstring field[100];\nint table[40005];\n\npair<int, int> bfs(int sx, int sy, int sd)\n{\n    memset(visited, 0, sizeof(visited));\n    for(int i=0; i<40000; i++) table[i] = -1;\n    \n    int x = sx, y = sy, d = sd;\n    int cost = 0;\n    \n    while(1) {\n\n\tif(visited[x][y][d]) break;\n\tvisited[x][y][d] = true;\n\n\tint h = d*10000 + y*100 + x;\n\t\n\ttable[h] = cost;\n\tcost++;\n\t\n\tfor(int i=0; i<4; i++) {\n\t    int td = (d + i)%4;\n\t    int tx = x + dx[td];\n\t    int ty = y + dy[td];\n\n\t    if(tx < 0 || ty < 0 || tx >= W || ty >= H) continue;\n\t    if(field[ty][tx] == '#') continue;\n\t    \n\t    d = td;\n\t    \n\t    break;\n\t}\n\t\n\tx += dx[d];\n\ty += dy[d];\t\n    }\n\n    \n    int ret = table[d*10000 + y*100 + x];\n\n    return make_pair(cost, ret);\n}\n\nint solve() \n{\n    pair<int, int> bfsres;\n\t\n    for(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t    for(int k=0; k<4; k++) {\n\t\tif(DtoS[k] == field[i][j])\n\t\t    bfsres = bfs(j, i, k);\n\t    }\n\n    ll length = bfsres.first;\n    ll bias = bfsres.second;\n    ll loopL = length - bias;\n    ll pos = L;\n    \n    if ( L >= bias)\n\tpos = (L-bias)%loopL + bias;    \n\n    int res = 0;\n    for(int i=0; i<40000; i++)\n\tif(table[i]==pos) res = i;\n\n    return res;\n}\n\nint main() \n{\n    while(cin >> H >> W >> L, (W||H||L)) {\n\tfor(int i=0; i<H; i++)\n\t    cin >> field[i];\n\n\tint res = solve();\n\tcout << ((res/100)%100 + 1) << \" \" << (res%100) + 1 << \" \" << DtoS[res/10000] << endl;\n    \n    }\n}\n\n\n\t\n\t\n\n    \n    "
  },
  {
    "language": "C++",
    "code": "//\n// Created by 拓真 on 2018/06/30.\n//\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) FOR(i,0,b)\n#define INF mugen\n#define dump(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(a) (a).begin(),(a).end()\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntemplate <class T> void chmin(T & a, T const & b) { if (b < a) a = b; }\n\ntypedef pair<int,int> P;\ntypedef long long ll;\n#define int long long\nstruct robot{\n    robot(){};\n    int x,y;\n    int dir;\n    robot(int x,int y,int dir){\n        this->x=x;\n        this->y=y;\n        this->dir=dir;\n    }\n};\n\nchar toc(int x){\n    if(x==0)return 'N';\n    else if(x==1)return 'E';\n    else if(x==2)return 'S';\n    else return 'W';\n}\nint dp[110][110][5];\nvector<string> maze;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nsigned main(){\n    int h,w;\n    ll L;\n    while(cin>>h>>w>>L,h){\n\n\n        rep(i,110)rep(j,110)rep(k,5)dp[i][j][k]=0;\n        maze.clear();\n        rep(i,h){\n            string s;\n            cin>>s;\n            maze.push_back(s);\n        }\n\n        robot pre;\n        rep(i,h)rep(j,w){\n            if(maze[i][j]=='N'){\n                pre=robot(j,i,0);\n            }\n            if(maze[i][j]=='E'){\n                pre=robot(j,i,1);\n            }\n            if(maze[i][j]=='S'){\n                pre=robot(j,i,2);\n            }\n            if(maze[i][j]=='W'){\n                pre=robot(j,i,3);\n            }\n        }\n\n        bool flag=false;\n\n        dp[pre.y][pre.x][pre.dir]=1;\n        for(int i=0;i<L;i++){\n\n            int nexty=pre.y+dy[pre.dir];\n            int nextx=pre.x+dx[pre.dir];\n            if(nexty>=0 && nexty<h&&nextx>=0&&nextx<w&&maze[nexty][nextx]!='#'){\n                pre=robot(nextx,nexty,pre.dir);\n\n            }else{\n                int id=1;\n                while(1){\n                    int nx=pre.x+dx[(pre.dir+id)%4];\n                    int ny=pre.y+dy[(pre.dir+id)%4];\n                    if(nx>=0&&nx<w&&ny>=0&&ny<h&&maze[ny][nx]=='.'){\n                        pre=robot(pre.x+dx[(pre.dir+id)%4],pre.y+dy[(pre.dir+id)%4],(pre.dir+id)%4);\n                        break;\n                    }\n                    id++;\n                }\n            }\n\n\n\n           //cout<<pre.y+1<<' '<<pre.x+1<<' '<<toc(pre.dir)<<endl;\n\n\n\n\n            if(!flag&&dp[pre.y][pre.x][pre.dir]){\n                int x=i+1-dp[pre.y][pre.x][pre.dir];\n                //cerr<<\"cut\";\n                i+=((L-i)/x)*x;\n               // cerr<<(L/x)*x;\n                //flag=true;\n            }\n            dp[pre.y][pre.x][pre.dir]=i+1;\n\n        }\n\n\n        cout<<pre.y+1<<' '<<pre.x+1<<' '<<toc(pre.dir)<<endl;\n\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 410\nusing namespace std;\n\nconst int dx[5]={-1,0,1,0};\nconst int dy[5]={0,1,0,-1};\nconst char fa[5]={'N','E','S','W'};\n\nint dp[N][N][5];\nint h,w,ansx,ansy,ansf;\nlong long ll;\nint map[N][N];\nint stackx[N*N*10];\nint stacky[N*N*10];\nint stackz[N*N*10];\n\nvoid tofind(int x,int y,int f,int rest)\n{\n\tif (rest==0) { ansx=x,ansy=y,ansf=f; return;}\n\tint tof=f;\n\twhile (map[x+dx[tof]][y+dy[tof]]==0)\n\t\ttof=(tof+1)%4;\n\ttofind(x+dx[tof],y+dy[tof],tof,rest-1);\n}\n\nvoid dfs(int x,int y,int f,int l)\n{\n\tif (l==ll) { ansx=x,ansy=y,ansf=f; return;}\n\tif (dp[x][y][f]) \n\t{ \n\t\tint loop= l-dp[x][y][f]; \n\t\tint rest=ll-dp[x][y][f]+1; \n\t\t//tofind(x,y,f,rest%loop-1);\n\t\tansx=stackx[dp[x][y][f]+rest%loop-1]; ansy=stacky[dp[x][y][f]+rest%loop-1]; ansf=stackz[dp[x][y][f]+rest%loop-1]; \n\t\treturn;\n\t};\n\tstackx[l]=x; stacky[l]=y; stackz[l]=f;\n\tdp[x][y][f]=l; int tof=f;\n\twhile (map[x+dx[tof]][y+dy[tof]]==0)\n\t\ttof=(tof+1)%4;\n\tdfs(x+dx[tof],y+dy[tof],tof,l+1);\n}\n\nint main()\n{\n\tint sx,sy,sf;\n\tchar c;\n\twhile (scanf(\"%d%d%lld\",&h,&w,&ll),h|w|ll)\n\t{\n\t\t//cout<<123123<<endl;\n\t\tmemset(map,0,sizeof map);\n\t\tfor (int i=1;i<=h;i++)\n\t\t{\n\t\t\tgetchar();\n\t\t\tfor (int j=1;j<=w;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&c);\n\t\t\t\tif (c=='.') map[i][j]=1;\n\t\t\t\telse if (c=='N') map[i][j]=1,sx=i,sy=j,sf=0;\n\t\t\t\telse if (c=='E') map[i][j]=1,sx=i,sy=j,sf=1;\n\t\t\t\telse if (c=='S') map[i][j]=1,sx=i,sy=j,sf=2;\n\t\t\t\telse if (c=='W') map[i][j]=1,sx=i,sy=j,sf=3;\n\t\t\t}\n\t\t}\n\t\t//cout<<123123<<endl;\n\t\tmemset(dp,0,sizeof dp);\n\t\tdfs(sx,sy,sf,0);\n\t\tprintf(\"%d %d %c\\n\",ansx,ansy,fa[ansf]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint a[100][100][4];\nint h, w;\n\nbool isin(int i, int j){\n    return i >= 0 && j >= 0 && i < h && j < w;\n}\n\nint main() {\n    ll l;\n    while (cin >> h >> w >> l && h){\n        vector<string> s(h);\n        REP(i,h) cin >> s[i];\n        int si, sj, dir;\n        REP(i,h) REP(j,w){\n            if (s[i][j] != '.' && s[i][j] != '#'){\n                si = i;\n                sj = j;\n                if (s[i][j] == 'E') dir = 0;\n                if (s[i][j] == 'S') dir = 1;\n                if (s[i][j] == 'W') dir = 2;\n                if (s[i][j] == 'N') dir = 3;\n            }\n        }\n        REP(i,h) REP(j,w) REP(k,4) a[i][j][k] = -1;\n        a[si][sj][dir] = 0;\n        int i = si, j = sj, x = 0;\n        int di[] = {0,1,0,-1}, dj[] = {1,0,-1,0};\n        while (1){\n            int ii = i + di[dir], jj = j + dj[dir];\n            if (!isin(ii,jj) || s[ii][jj] == '#'){\n                dir = (dir + 1) % 4;\n                continue;\n            }\n            i = ii, j = jj, x++;\n            if (a[i][j][dir] >= 0) break;\n            a[i][j][dir] = x;\n            if (x == l) break;\n        }\n        string c = \"ESWN\";\n        if (a[i][j][dir] == l){\n            printf(\"%d %d %c\\n\", i+1, j+1, c[dir]);\n        }else{\n            int p = a[i][j][dir];\n            l = (l - p) % (x - p) + p;\n            REP(i,h) REP(j,w) REP(k,4){\n                if (a[i][j][k] == l){\n                    printf(\"%d %d %c\\n\", i+1, j+1, c[k]);\n                    i = h, j = w, k = 4;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint H,W,L;\nchar grid[150][150];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};//N,E,S,W\nll int memo[150][150][4];\nint dir,px,py;\n\nint rotate(int a){\n\treturn (a+1)%4;\n}\nbool inrange(int x,int y){\n\treturn (x>-1&&y>-1&&x<H&&y<W);\n}\nint main(){\n\twhile(1){\n\t\tREP(i,150) REP(j,150) REP(k,4) memo[i][j][k] = -1;\n\t\tcin >> H >> W >> L;\n\t\tif(H==0&&W==0&&L==0) break;\n\t\tREP(i,H){\n\t\t\tREP(j,W){\n\t\t\t\tcin >> grid[i][j];\n\t\t\t\tif(grid[i][j]=='N'){dir = 0; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='E'){dir = 1; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='S'){dir = 2; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='W'){dir = 3; px = i; py = j; grid[i][j] = '.';}\n\t\t\t}\n\t\t}\n\t\tll int step = 0;\n\t\tmemo[px][py][dir] = 0;\n\t\twhile(1){\n\t\t\tif(step == L) break;\n\t\t\tint nx = px + dx[dir]; int ny = py + dy[dir];\n\t\t\tif(grid[nx][ny]=='.'){\n\t\t\t\tpx = nx; py = ny;\n\t\t\t\tif(memo[px][py][dir]!=-1){\n\t\t\t\t\t//a,b,c\n\t\t\t\t\tll int a = step-memo[px][py][dir];\n\t\t\t\t\tll int b = L-step;\n\t\t\t\t\tstep += a*(b/a);\n\t\t\t\t}else{\n\t\t\t\t\tmemo[px][py][dir] = step;\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tif(!inrange(nx,ny)||grid[nx][ny]=='#'){\n\t\t\t\tdir = rotate(dir);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tstring ans = \"NESW\";\n\t\tcout << px+1 << \" \" << py+1 << \" \" <<  ans[dir] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstruct State{\n    int h,w,dir;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nstring dmpi=\"NESW\";\n\nvoid out(State st){\n    cout<<st.h<<\" \"<<st.w<<\" \"<<dmpi[st.dir]<<endl;\n}\n\nint solve(int H,int W,int L){\n    vector<string> f(H+2);\n    for(int i=0;i<W+2;i++){\n        f[0]+=\"#\";\n        f[H+1]+=\"#\";\n    }\n    State ini={-1,-1,-1};\n    for(int i=0;i<H;i++){\n        cin>>f[i+1];\n        f[i+1]=\"#\"+f[i+1]+\"#\";\n        for(int j=0;j<W+2;j++){\n            if(f[i+1][j]=='N'){\n                ini=State{i+1,j,0};\n            }\n            if(f[i+1][j]=='E'){\n                ini=State{i+1,j,1};\n            }\n            if(f[i+1][j]=='S'){\n                ini=State{i+1,j,2};\n            }\n            if(f[i+1][j]=='W'){\n                ini=State{i+1,j,3};\n            }\n        }\n    }\n    vector<vector<vector<int>>> dp(H+2,vector<vector<int>>(W+2,vector<int>(4,-1)));\n    int lps=0;\n    State st=ini;\n    int cnt=0;\n    queue<State> que;\n    while(true){\n        if(cnt==L){\n            out(st);\n            return 0;\n        }\n        if(dp[st.h][st.w][st.dir]!=-1){\n            lps=cnt-dp[st.h][st.w][st.dir];\n            break;\n        }\n        dp[st.h][st.w][st.dir]=cnt;\n        if(f[st.h+dh[st.dir]][st.w+dw[st.dir]]=='#'){\n            st.dir=(st.dir+1)%4;\n            continue;\n        }\n        st.h+=dh[st.dir];\n        st.w+=dw[st.dir];\n        que.push(st);\n        cnt++;\n    }\n    L-=cnt+1;\n    vector<State> lpv;\n    while(que.size()>lps) que.pop();\n    while(!que.empty()) lpv.push_back(que.front()),que.pop();\n    L%=lps;\n    out(lpv[L]);\n    return 0;\n}\nint main(){\n    int H,W,L;\n    while(cin>>H>>W>>L,H){\n        solve(H,W,L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  ll i,j,k;\n  ll dp[105][105][4]={{{}}};\n  string st[105];\n  char c[]={'E','S','W','N'};\n  ll rx,ry,rd;\n  ll ax[]={1,0,-1,0};\n  ll ay[]={0,1,0,-1};\n  bool f;\n  ll s;\n  while(cin>>h>>w>>l,h||w||l){\n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    fill(dp[0][0],dp[104][104],0);\n    f = true;\n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(dp[ry][rx][rd]==0){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\ts = i - dp[ry][rx][rd];\n\tl=i+(l-i)%s;\n\tf=false;\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n    }\n    cout << ry << ' ' << rx << ' ' << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        int count = 0;\n        string wall = \"\";\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n            }\n        }\n\n        int sx, sy, sdir;\n        sx = x;\n        sy = y;\n        sdir = dir;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n                if (x == sx && y == sy && dir == sdir) {\n                    l %= count;\n                }\n            }\n            else\n                dir = (dir+1) % 4;\n        }\n        cout << x << \" \" << y << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint dist[110][110][4];\nchar v[110][110];\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { -1, 0, 1, 0 };\n\nint main(){\n\tll n, m, L;\n\twhile (cin >> n >> m >> L, n){\n\t\tMEMSET(v, 0);\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1) cin >> v[i][j];\n\t\tint r, c, d;\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1){\n\t\t\tif (v[i][j] != '.' && v[i][j] != '#'){\n\t\t\t\trep(dir, 4) if (v[i][j] == \"NESW\"[dir]) tie(r, c, d) = MT(i, j, dir);\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\n\t\tMEMSET(dist, -1);\n\t\tint x = 0;\n\t\tdist[r][c][d] = x++;\n\t\tbool loop = true;\n\t\twhile (L){\n\t\t\twhile (v[r + dy[d]][c + dx[d]] != '.') d = (d + 1) % 4;\n\t\t\tr += dy[d], c += dx[d];\n\t\t\tL--;\n\t\t\tif (loop && dist[r][c][d] >= 0) L %= (x - dist[r][c][d]), loop = false;\n\t\t\tdist[r][c][d] = x++;\n\n\t\t\t//for (int i = 1; i <= n; ++i){\n\t\t\t//\tfor (int j = 1; j <= m; ++j){\n\t\t\t//\t\tcout << (MP(i, j) == MP(r, c) ? \"NESW\"[d] : v[i][j]);\n\t\t\t//\t}cout << '\\n';\n\t\t\t//}cout << '\\n';\n\t\t}\n\t\tcout << r << ' ' << c << ' ' << \"NESW\"[d] << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tint h,w;\n\tll l;\n\tchar maze[102][102];\n\tmemset(maze,'#',sizeof maze);\n\twhile(cin >> h >> w >> l,h){\n\t\tint r[2];\n\t\tint v[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\tint d = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcin >> maze[i+1][j+1];\n\t\t\t\tswitch(maze[i+1][j+1]){\n\t\t\t\t\tcase 'W':++d;\n\t\t\t\t\tcase 'S':++d;\n\t\t\t\t\tcase 'E':++d;\n\t\t\t\t\tcase 'N':\n\t\t\t\t\t\t r[0] = i+1;\n\t\t\t\t\t\t r[1] = j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll step[4][102][102];\n\t\tmemset(step,-1,sizeof step);\n\t\tstep[d][r[0]][r[1]] = 0;\n\t\tll s = 0;\n\t\twhile(s < l){\n\t\t\twhile(maze[r[0]+v[d][0]][r[1]+v[d][1]] == '#') d = (d+1)%4;\n\t\t\tif(step[d][r[0]+v[d][0]][r[1]+v[d][1]] < 0){\n\t\t\t\tstep[d][r[0]+v[d][0]][r[1]+v[d][1]] = ++s;\n\t\t\t}else{\n\t\t\t\tl -= step[d][r[0]+v[d][0]][r[1]+v[d][1]];\n\t\t\t\tl %= (s-step[d][r[0]+v[d][0]][r[1]+v[d][1]]+1);\n\t\t\t\tmemset(step,-1,sizeof step);\n\t\t\t\tstep[d][r[0]+v[d][0]][r[1]+v[d][1]] = s = 0;\n\t\t\t}\n\t\t\tr[0] += v[d][0];\n\t\t\tr[1] += v[d][1];\n\t\t}\n\t\tchar c[] = {'N','E','S','W'};\n\t\tcout << r[0] << \" \" << r[1] << \" \" << c[d] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint dist[110][110][4];\nchar v[110][110];\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { -1, 0, 1, 0 };\n\nint main(){\n\tint n, m, L;\n\twhile (cin >> n >> m >> L, n){\n\t\tMEMSET(v, 0);\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1) cin >> v[i][j];\n\t\tint r, c, d;\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1){\n\t\t\tif (v[i][j] != '.' && v[i][j] != '#'){\n\t\t\t\trep(dir, 4) if (v[i][j] == \"NESW\"[dir]) tie(r, c, d) = MT(i, j, dir);\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\n\t\tMEMSET(dist, -1);\n\t\tint x = 0;\n\t\tdist[r][c][d] = x++;\n\t\tbool loop = true;\n\t\twhile (L){\n\t\t\twhile (v[r + dy[d]][c + dx[d]] != '.') d = (d + 1) % 4;\n\t\t\tr += dy[d], c += dx[d];\n\t\t\tL--;\n\t\t\tif (loop && dist[r][c][d] >= 0) L %= (x - dist[r][c][d]), loop = false;\n\t\t\tdist[r][c][d] = x++;\n\n\t\t\t//for (int i = 1; i <= n; ++i){\n\t\t\t//\tfor (int j = 1; j <= m; ++j){\n\t\t\t//\t\tcout << (MP(i, j) == MP(r, c) ? \"NESW\"[d] : v[i][j]);\n\t\t\t//\t}cout << '\\n';\n\t\t\t//}cout << '\\n';\n\t\t}\n\t\tcout << r << ' ' << c << ' ' << \"NESW\"[d] << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nenum DIR{\n\tNorth,\n\tEast,\n\tWest,\n\tSouth,\n};\n\nint H,W;\n\nll Limit,visit_Time[100][100][4];\n\nDIR turn(DIR dir){\n\tswitch(dir){\n\tcase North:\n\t\treturn East;\n\tcase East:\n\t\treturn South;\n\tcase West:\n\t\treturn North;\n\tcase South:\n\t\treturn West;\n\t}\n\treturn North; //must not reach here\n}\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1){\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int i = 0; i < 4; i++)visit_Time[row][col][i] = -1;\n\t\t}\n\t}\n\n\tint row,col,first_row,first_col;\n\tDIR dir,pre_dir,first_dir;\n\n\tchar map[H][W+1];\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tswitch(map[i][k]){\n\t\t\tcase 'N':\n\t\t\t\tdir = North;\n\t\t\t\tfirst_dir = North;\n\t\t\t\trow = i;\n\t\t\t\tcol = k;\n\t\t\t\tfirst_row = i;\n\t\t\t\tfirst_col = k;\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tdir = East;\n\t\t\t\tfirst_dir = East;\n\t\t\t\trow = i;\n\t\t\t\tcol = k;\n\t\t\t\tfirst_row = i;\n\t\t\t\tfirst_col = k;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tdir = West;\n\t\t\t\tfirst_dir = West;\n\t\t\t\trow = i;\n\t\t\t\tcol = k;\n\t\t\t\tfirst_row = i;\n\t\t\t\tfirst_col = k;\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tdir = South;\n\t\t\t\tfirst_dir = South;\n\t\t\t\trow = i;\n\t\t\t\tcol = k;\n\t\t\t\tfirst_row = i;\n\t\t\t\tfirst_col = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvisit_Time[row][col][dir] = 0;\n\n\tll loop_in_time,loop_cicle;\n\tint next_row,next_col,start_row,start_col;\n\tDIR start_dir;\n\n\twhile(true){\n\n\t\tswitch(dir){\n\t\tcase North:\n\t\t\tnext_row = row-1;\n\t\t\tnext_col = col;\n\t\t\tbreak;\n\t\tcase East:\n\t\t\tnext_row = row;\n\t\t\tnext_col = col+1;\n\t\t\tbreak;\n\t\tcase West:\n\t\t\tnext_row = row;\n\t\t\tnext_col = col-1;\n\t\t\tbreak;\n\t\tcase South:\n\t\t\tnext_row = row+1;\n\t\t\tnext_col = col;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(rangeCheck(next_row,next_col) == false || map[next_row][next_col] == '#'){\n\t\t\tpre_dir = dir;\n\t\t\tdir = turn(dir);\n\t\t\tif(visit_Time[row][col][dir] == -1){\n\t\t\t\tvisit_Time[row][col][dir] = visit_Time[row][col][pre_dir];\n\t\t\t}else{\n\t\t\t\tstart_row = row;\n\t\t\t\tstart_col = col;\n\t\t\t\tstart_dir = pre_dir;\n\n\t\t\t\tloop_in_time = visit_Time[row][col][dir];\n\t\t\t\tloop_cicle = visit_Time[row][col][pre_dir]-visit_Time[row][col][dir];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}else{\n\t\t\tif(visit_Time[next_row][next_col][dir] == -1){\n\t\t\t\tvisit_Time[next_row][next_col][dir] = visit_Time[row][col][dir]+1;\n\t\t\t\trow = next_row;\n\t\t\t\tcol = next_col;\n\t\t\t}else{\n\t\t\t\tstart_row = next_row;\n\t\t\t\tstart_col = next_col;\n\t\t\t\tstart_dir = dir;\n\n\t\t\t\tloop_in_time = visit_Time[next_row][next_col][dir];\n\t\t\t\tloop_cicle = visit_Time[row][col][dir]+1-visit_Time[next_row][next_col][dir];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif(Limit < loop_in_time){\n\t\trow = first_row;\n\t\tcol = first_col;\n\t\tdir = first_dir;\n\t}else{\n\t\tLimit -= loop_in_time;\n\t\tLimit %= loop_cicle;\n\n\t\trow = start_row;\n\t\tcol = start_col;\n\t\tdir = start_dir;\n\t}\n\n\twhile(Limit > 0){\n\n\t\tswitch(dir){\n\t\tcase North:\n\t\t\tnext_row = row-1;\n\t\t\tnext_col = col;\n\t\t\tbreak;\n\t\tcase East:\n\t\t\tnext_row = row;\n\t\t\tnext_col = col+1;\n\t\t\tbreak;\n\t\tcase West:\n\t\t\tnext_row = row;\n\t\t\tnext_col = col-1;\n\t\t\tbreak;\n\t\tcase South:\n\t\t\tnext_row = row+1;\n\t\t\tnext_col = col;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(rangeCheck(next_row,next_col) == false || map[next_row][next_col] == '#'){\n\t\t\tdir = turn(dir);\n\t\t}else{\n\t\t\trow = next_row;\n\t\t\tcol = next_col;\n\t\t\tLimit--;\n\t\t}\n\t}\n\n\tprintf(\"%d %d \",row+1,col+1);\n\tswitch(dir){\n\tcase North:\n\t\tprintf(\"N\\n\");\n\t\tbreak;\n\tcase East:\n\t\tprintf(\"E\\n\");\n\t\tbreak;\n\tcase West:\n\t\tprintf(\"W\\n\");\n\t\tbreak;\n\tcase South:\n\t\tprintf(\"S\\n\");\n\t\tbreak;\n\t}\n\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %lld\",&H,&W,&Limit);\n\t\tif(H == 0 && W == 0 && Limit == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nchar field[110][110];\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint dx[4]   = {-1, 0, 1, 0};\nint dy[4]   = {0, 1, 0, -1};\n\nll memo[110][110][4];\nint main(){\n  ll H, W, L;\n  while(cin >>H >> W >> L && H + W + L){\n    fill(&field[0][0],&field[0][0] + 110 * 110, '#');\n    memset(memo, -1, sizeof(memo));\n\n    int x, y, d;\n    REP(i, H)REP(j, W){\n      cin >> field[i+1][j+1];\n      if(isalpha(field[i+1][j+1])){\n        x = i + 1, y = j + 1, d = find(dir, dir + 4, field[i+1][j+1]) - dir;\n      }\n    }\n\n    ll T = 0;\n    bool flag = false;\n    while(L > 0){\n      \n      if(memo[x][y][d] >= 0 && !flag){\n        ll S = T - memo[x][y][d];\n        L %= S;\n        flag = true;\n      }\n\n      memo[x][y][d] = T;\n      \n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      if(field[nx][ny] == '#'){\n        d = (d + 1) % 4;\n        continue;\n      }\n      \n      x = nx;\n      y = ny;\n      L--;\n      T++;      \n    }\n    cout << x<< \" \" << y<< \" \" << dir[d] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[101][101];\nint visited[101][101][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {   \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint H, W;\nlong long L;\nint Map[105][105];\nchar vect[]={'N', 'E', 'S', 'W'};\nint dx[]={-1, 0, 1, 0};\nint dy[]={0, 1, 0, -1};\n\nint main()\n{\n //   freopen(\"3.txt\", \"r\", stdin);\n    while(scanf(\"%d %d %lld\", &H, &W, &L)!=EOF && (H||W||L))\n    {\n        memset(Map, 0, sizeof(Map));\n        getchar();\n        char vet;\n        int x, y;\n        char t;\n        for(int i=1; i<=H; ++i)\n        {\n            for(int j=1; j<=W; ++j)\n            {\n                scanf(\"%c\", &t);\n                if(t!='.' && t!='#')\n                {\n                    Map[i][j]=1;\n                    x=i; y=j;\n                    vet=t;\n                }\n                if(t=='.')\n                {\n                    Map[i][j]=1;\n                }\n            }\n            getchar();\n        }\n        int now;\n        for(int i=0; i<4; ++i)\n        {\n            if(vect[i]==vet)\n            {\n                now=i;\n                break;\n            }\n        }\n        int nextx, nexty;\n        long long step=0;\n        while(step!=L)\n        {\n            nextx=x+dx[now];\n            nexty=y+dy[now];\n            if(Map[nextx][nexty])\n            {\n                ++step;\n                x=nextx;\n                y=nexty;\n                continue;\n            }\n            else\n            {\n                while(true)\n                {\n                    now=(now+1)%4;\n                    nextx=x+dx[now];\n                    nexty=y+dy[now];\n                    if(Map[nextx][nexty])\n                    {\n                        break;\n                    }\n                }\n                ++step;\n                x=nextx;\n                y=nexty;\n                continue;\n            }\n        }\n\n        printf(\"%d %d %c\\n\", x, y, vect[now]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\nconst int MOD = 1000000007;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint H, W, L;\n\n//h, w, dir\ntypedef tuple<int, int, int> State;\n\nstring directions = \"NESW\";\n//NESW\nint dh[] = {-1, 0, 1, 0};\nint dw[] = {0, 1, 0, -1};\n\ninline bool infield(int h, int w){\n    return 0<=h&&h<H && 0<=w&&w<W;\n}\n\nvoid solve(){\n    vector<string> field(H);\n    for(int i=0; i<H; i++)\n        cin >> field[i];\n    \n    int dir = -1;\n    int h = -1, w = -1;\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            int tdir = directions.find(field[i][j]);\n            if(tdir != string::npos){\n                dir = tdir;\n                h = i; w = j;\n                field[h][w] = '.';\n            }\n        }\n    }\n    \n    map<State, int> memo;\n    \n    while(L--){\n        while(!(infield(h+dh[dir], w+dw[dir]) && field[h+dh[dir]][w+dw[dir]]=='.'))\n            dir = (dir+1) % 4;\n        \n        if(memo.find(State(h, w, dir)) != memo.end()){\n            int d = memo[State(h, w, dir)];\n            L %= (L - d);\n        }\n        memo[State(h, w, dir)] = L;\n        \n        h += dh[dir];\n        w += dw[dir];\n    }\n    \n    cout << h+1 << \" \" << w+1 << \" \" << directions[dir] << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin>>H>>W>>L, H|W|L){\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint h, w;\nll l;\nchar c[100][101];\nint d[100][100][4];\n\nint main(){\n\twhile(scanf(\"%d%d%lld\", &h, &w, &l), w){\n\t\trep(i, h){\n\t\t\tscanf(\"%s\", c[i]);\n\t\t}\n\n\t\tint p, q, r;\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tif(c[i][j] == 'N'){\n\t\t\t\t\tr = 0;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'E'){\n\t\t\t\t\tr = 1;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'S'){\n\t\t\t\t\tr = 2;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'W'){\n\t\t\t\t\tr = 3;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp = i;\n\t\t\t\tq = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tfill_n(d[i][j], 4, -1);\n\t\t\t}\n\t\t}\n\t\td[p][q][r] = 0;\n\n\t\tint dx[4] = {-1, 0, 1, 0};\n\t\tint dy[4] = {0, 1, 0, -1};\n\t\twhile(true){\n\t\t\tint v = d[p][q][r];\n\t\t\tint x = p + dx[r];\n\t\t\tint y = q + dy[r];\n\t\t\tif(0 <= x && x < h && 0 <= y && y < w && c[x][y] != '#'){\n\t\t\t\tp = x;\n\t\t\t\tq = y;\n\t\t\t\t++v;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = (r + 1) % 4;\n\t\t\t}\n\n\t\t\tif(v == l){\n\t\t\t\tchar k[5] = \"NESW\";\n\t\t\t\tprintf(\"%d %d %c\\n\", p + 1, q + 1, k[r]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint a = d[p][q][r];\n\t\t\tif(a != -1){\n\t\t\t\tl -= a;\n\t\t\t\tl %= (v - a);\n\n\t\t\t\trep(i, h){\n\t\t\t\t\trep(j, w){\n\t\t\t\t\t\tfill_n(d[i][j], 4, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\td[p][q][r] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\td[p][q][r] = v;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int h,w;\n  long long l;\n  int x,y,d;\n  string g[100];\n\n  int vis[100][100][4];\n  char dir[] = {'N','E','S','W'};\n  int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\n  int px[40100],py[40100],pd[40100];\n\n  while(cin >> h >> w >> l,h){\n    for(int i=0;i<h;i++)cin >> g[i];\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<4;k++){\n\t  if(g[i][j] == dir[k]){\n\t    y = i; x = j; d = k;\n\t  }\n\t  vis[i][j][k] = -1;\n\t}\n      }\n    }\n\n    int step = 0;\n    for(;;){\n      if(vis[y][x][d]>=0)break;\n      vis[y][x][d] = step;\n      \n      py[step] = y; px[step] = x; pd[step] = d;\n      step++;\n\n      for(int i=0;i<4;i++){\n\tint nd = (d+i)%4;\n\tint ny = y+dy[nd], nx = x+dx[nd];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\ty = ny; x = nx; d = nd;\n\tbreak;\n      }\n    }\n\n    long long head = vis[y][x][d], now = l;\n    if(step<l){\n      now -= head;\n      now %= step-head;\n      now += head;\n    }\n    cout << py[now]+1 << \" \" << px[now]+1 << \" \" << dir[pd[now]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long H, W, L;\nchar x[102][102], T[5] = \"NESW\"; int dp[102][102][4];\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 102; i++) {\n\t\t\tfor (int j = 0; j < 102; j++) {\n\t\t\t\tx[i][j] = '#';\n\t\t\t\tfor (int k = 0; k < 4; k++)dp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\t\tcin >> H >> W >> L; int D = 0, X = 0, Y = 0;\n\t\tif (H == 0 && W == 0 && L == 0)break;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t\tif (x[i][j] != '#' && x[i][j] != '.') {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tif (T[k] == x[i][j]) {\n\t\t\t\t\t\t\tx[i][j] = '.'; D = k; X = i; Y = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0; dp[X][Y][D] = 0; long long V = 0, W = 0, C = 0, F = 0;\n\t\twhile (true) {\n\t\t\tif (x[X + dx[D]][Y + dy[D]] == '#') {\n\t\t\t\tD = (D + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tX += dx[D]; Y += dy[D]; cnt++;\n\t\t\t\tif (dp[X][Y][D] != -1) {\n\t\t\t\t\tV = dp[X][Y][D]; W = cnt; goto E;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[X][Y][D] = cnt;\n\t\t\t\t\tif (cnt == L) {\n\t\t\t\t\t\tcout << X << ' ' << Y << ' ' << T[D] << endl;\n\t\t\t\t\t\tgoto F;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tE:;\n\t\tC = (W - V); F = (L - W) % C; F += V;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (dp[i][j][k] == F) {\n\t\t\t\t\t\tcout << i << ' ' << j << ' ' << T[k] << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tF:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf=sizeof(Def)==sizeof(long long)?2e18:1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tstring s=\"ESWN\";\n\tint n,m,t;\n\twhile(cin>>n>>m>>t,n+m+t){\n\t\tvs in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tint x,y,now;\n\t\trep(i,n)rep(j,m)rep(k,4)\n\t\t\tif(in[i][j]==s[k])x=i,y=j,now=k;\n\t\twhile(t--){\n\t\t\tint nx=x+dx[now];\n\t\t\tint ny=y+dy[now];\n\t\t\tif(nx<0||ny<0||nx>=n||ny>=m||in[nx][ny]=='#')(now+=1)%=4,t++;\n\t\t\telse x=nx,y=ny;\n\t\t}\n\t\tcout<<x+1<<\" \"<<y+1<<\" \"<<s[now]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nvoid output(int i,int j,int d)\n{\n\tcout<<i+1<<' '<<j+1<<' '<<\"NESW\"[d]<<endl;\n}\n\nint main()\n{\n\tint h,w; long long l;\n\tfor(;cin>>h>>w>>l,h|w|l;){\n\t\tvector<string> grid(h);\n\t\tfor(int i=0;i<h;i++) cin>>grid[i];\n\t\t\n\t\tvector<vector<int>> vis(h,vector<int>(w,-1)),dir(h,vector<int>(w,-1));\n\t\t\n\t\tqueue<tuple<int,int,int,int>> q; // (i,j,dir,time)\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint d=string(\"NESW\").find(grid[i][j]);\n\t\t\t\tif(d!=-1){\n\t\t\t\t\tq.emplace(i,j,d,0);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\twhile(q.size()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint ci=get<0>(c),cj=get<1>(c),cd=get<2>(c),ct=get<3>(c);\n\t\t\tif(ct==l){\n\t\t\t\toutput(ci,cj,cd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[ci][cj]!=-1){\n\t\t\t\tint len=ct-vis[ci][cj];\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tif(vis[i][j]==(l-vis[ci][cj])%len+vis[ci][cj])\n\t\t\t\t\t\t\toutput(i,j,dir[i][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[ci][cj]=ct,dir[ci][cj]=cd;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nd=(cd+i)%4,ni=ci+\"\\xff\\0\\x1\\0\"[nd],nj=cj+\"\\0\\x1\\0\\xff\"[nd];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='#'){\n\t\t\t\t\tq.emplace(ni,nj,nd,ct+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char, int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y + dy[me.dir]][me.x + dx[me.dir]] == WALL){\n        me.turn();\n      }\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nmap<char, int>mp;\n\n//反時計まわり\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nstruct aa {\n\tint x;\n\tint y;\n\tint way;\n\tbool operator ==(const aa&r) {\n\t\treturn x == r.x&&y == r.y&&way == r.way;\n\t}\n};\n\nvoid cou(aa aaa) {\n\tchar c;\n\tif (aaa.way == 0) {\n\t\tc = 'W';\n\t}\n\telse if (aaa.way == 1) {\n\t\tc = 'S';\n\t}\n\telse if (aaa.way == 2) {\n\t\tc = 'E';\n\t}\n\telse {\n\t\tc = 'N';\n\t}\n\tcout << aaa.y << \" \" << aaa.x << \" \" << c << endl;\n}\nint main() {\n\tmp['E'] = 2;\n\tmp['W'] = 0;\n\tmp['N'] = 3;\n\tmp['S'] = 1;\n\twhile (1) {\n\t\tlong long int H, W, L; cin >> H >> W >> L;\n\t\tif (!H)break;\n\t\tint sx, sy, sway;\n\t\tvector<vector<bool>>field(H + 2, vector<bool>(W + 2));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tfield[i + 1][j + 1] = true;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == '#') {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i + 1][j + 1] = true;\n\t\t\t\t\tsx = j + 1; sy = i + 1; sway = mp[st[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<aa>memo;\n\t\tint nx = sx;int ny = sy; int way = sway;\n\t\tauto it = find(memo.begin(), memo.end(), (aa{ nx,ny,way }));\n\t\twhile (it == memo.end()) {\n\t\t\tmemo.push_back(aa{ nx,ny,way });\n\t\t\tint nextx = nx + dx[way];\n\t\t\tint nexty = ny + dy[way];\n\t\t\twhile (!field[nexty][nextx]) {\n\t\t\t\tway = (way + 3) % 4;\n\t\t\t\tnextx = nx + dx[way];\n\t\t\t\tnexty = ny + dy[way];\n\t\t\t}\n\t\t\tny = nexty; nx = nextx;\n\t\t\tit = find(memo.begin(), memo.end(), (aa{ nx,ny,way }));\n\t\t}\n\t\tif (memo.size() > L) {\n\t\t\tcou(memo[L]);\n\t\t}\n\t\telse {\n\t\t\tint roopnum = memo.end() - it;\n\t\t\tint roopstart = it - memo.begin();\n\t\t\tint anum = (L - roopstart) % roopnum + roopstart;\n\t\t\tcou(memo[anum]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 105\nusing namespace std;\ntypedef long long ll;\nchar Rot(char);\nint GetNum(char);\n\nint main(){\n  ll h,w,y,x,t,r,me[N][N][4];\n  char c;\n  string s[N];\n  \n  ll l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tfor(int k=0;k<4;k++) me[i][j][k]=-1;\n      }\n    t=0;\n    r=GetNum(c);\n    me[y][x][r]=t;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      r=GetNum(c);\n      if(me[y][x][r]!=-1&&t-me[y][x][r]!=0) t=l-((l-me[y][x][r])%(t-me[y][x][r]));\n      me[ny][nx][r]=t;\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}\n\nint GetNum(char c){\n  if(c=='N') return 0;\n  if(c=='E') return 1;\n  if(c=='S') return 2;\n  return 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1LL << 60;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\nbool solve() {\n    int H, W;\n    lint L;\n    cin >> H >> W >> L;\n    if (H == 0) return false;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<vector<lint>>> dist(H, vector<vector<lint>>(W, vector<lint>(4, INF)));\n    int sx, sy, sd;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            for (int d = 0; d < 4; ++d) {\n                if (S[x][y] == \"NESW\"[d]) {\n                    sx = x;\n                    sy = y;\n                    sd = d;\n                }\n            }\n        }\n    }\n\n    dist[sx][sy][sd] = 0;\n    lint step = 0;\n    bool skipped = false;\n    while (step < L) {\n        int nx = sx + dx[sd], ny = sy + dy[sd];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny ||\n            S[nx][ny] == '#') {\n            sd = (sd + 1) % 4;\n        } else {\n            sx = nx, sy = ny;\n            ++step;\n        }\n\n        if (!skipped && dist[sx][sy][sd] < INF) {\n            lint diff = step - dist[sx][sy][sd];\n            step += (L - step - 1) / diff * diff;\n            skipped = true;\n        }\n        dist[sx][sy][sd] = step;\n    }\n\n    cout << sx + 1 << \" \" << sy + 1 << \" \"\n         << \"NESW\"[sd] << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint m[110][110];\nlong long ha[50010];\nstruct\n{\n    int x,y,face;\n}ss[50010];\nint main()\n{\n    int h,w,j,i,sx,sy,start,x,y,face,tt,hash;\n    long long l,ll;\n    int ans;\n    char c[1000];\n    while (scanf(\"%d%d%lld\",&h,&w,&l)&&h&&w&&l)\n    {\n        memset(ha,-1,sizeof ha);\n        memset(ss,0,sizeof ss);\n        for (i=1;i<=h;i++)\n        {\n            scanf(\"%s\",c);\n            for (j=1;j<=w;j++)\n            {\n                if (c[j-1]=='#')\n                m[i][j]=0;\n                else if (c[j-1]=='.')\n                m[i][j]=1;\n                else\n                {\n                    m[i][j]=1;\n                    sx=i,sy=j;\n                    if (c[j-1]=='W')\n                        start=1;\n                    if (c[j-1]=='N')\n                        start=2;\n                    if (c[j-1]=='E')\n                        start=3;\n                    if (c[j-1]=='S')\n                        start=4;\n                }\n            }\n        }\n        ll=l;\n       // printf(\"ll = %lld\\n\",ll);\n        x=sx;y=sy;\n        face=start;\n        tt=0;\n        while (ll)\n        {   hash=(face-1)*10000+(x-1)*100+y-1;\n         //   printf(\"%d %d %d %d   %lld\\n\",x,y,face,hash,ha[hash]);\n            if (ha[hash]==-1)\n            {\n                ha[hash]=l-ll;\n                if(ss[l-ll].face == 0){ss[l-ll].x=x,ss[l-ll].y=y,ss[l-ll].face=face;\n             //   printf(\"%d : %d %d %d\\n\",l-ll,ss[l-ll].x,ss[l-ll].y,ss[l-ll].face);\n                }\n            }\n            else\n            {\n                tt=1;\n                ss[ha[hash]].face = face;\n              //  printf(\"l = %lld\\n,l - ll = %lld\\n ll = %lld\\n\",l,l-ll,ll);\n               // printf(\"ha[hash] = %d, hash = %d, l-ll = %lld\\n\",ha[hash],hash,l-ll-ha[hash]);\n\n           //     printf(\"l-ll = %lld %lld  ~%lld\\n\",l,ll,l-ll);\n                ans=ha[hash]+int((l-ha[hash])%(l-ll-ha[hash]));\n            //    while (ss[ans].x==ss[ans-1].x&&ss[ans].y==ss[ans-1].y)\n           //         ans--;\n          // printf(\"%d\\n\",ans);\n                printf(\"%d %d \",ss[ans].x,ss[ans].y);\n                if (ss[ans].face==1)\n                printf(\"W\\n\");\n                if (ss[ans].face==2)\n                printf(\"N\\n\");\n                if (ss[ans].face==3)\n                printf(\"E\\n\");\n                if (ss[ans].face==4)\n                printf(\"S\\n\");\n               // printf(\"%d %d %d\",ss[ans-1].x,ss[ans-1].y,ss[ans-1],face);\n                break;\n            }\n            if (face==1)\n            {\n                if (y-1>=1&&m[x][y-1])\n                {\n                    y--;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==2)\n            {\n                if (x-1>=1&&m[x-1][y])\n                {\n                    x--;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==3)\n            {\n                if (y+1<=w&&m[x][y+1])\n                {\n                    y++;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==4)\n            {\n                if (x+1<=h&&m[x+1][y])\n                {\n                    x++;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face=1;\n                    continue;\n                }\n            }\n        }\n        if (tt==0)\n        {\n            printf(\"%d %d \",x,y);\n            if (face==1)\n                printf(\"W\\n\");\n            if (face==2)\n                printf(\"N\\n\");\n            if (face==3)\n                printf(\"E\\n\");\n            if (face==4)\n                printf(\"S\\n\");\n        }\n    }\n    return 0;\n}\n\n/*\n2 2 8\nW.\n..\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int INF = 1 << 30;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\nconst string NESW = \"NESW\";\n\nbool solve() {\n    int H, W;\n    lint L;\n    cin >> H >> W >> L;\n    if (H == 0) return false;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<vector<int>>> dist(H, vector<vector<int>>(W, vector<int>(4, INF)));\n    int sx, sy, sd;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            for (int d = 0; d < 4; ++d) {\n                if (S[x][y] == \"NESW\"[d]) {\n                    sx = x;\n                    sy = y;\n                    sd = d;\n                }\n            }\n        }\n    }\n\n    dist[sx][sy][sd] = 0;\n    int step = 0;\n    while (step < L) {\n        int nx = sx + dx[sd], ny = sy + dy[sd];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny ||\n            S[nx][ny] == '#') {\n            sd = (sd + 1) % 4;\n        } else {\n            sx = nx, sy = ny;\n            ++step;\n        }\n\n        if (dist[sx][sy][sd] < INF) {\n            int diff = step - dist[sx][sy][sd];\n            L -= (L - step) / diff * diff;\n        } else {\n            dist[sx][sy][sd] = step;\n        }\n    }\n\n    cout << sx + 1 << \" \" << sy + 1 << \" \"\n         << \"NESW\"[sd] << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, int cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nint dx[] = { -1, 0, 1, 0 }; int dy[] = { 0, 1, 0, -1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int dir, int h, int w) { return dir*h*w + w*x + y; }\n\n/*--------------------template--------------------*/\n\nvi rev(int p, int h, int w)\n{\n\t//(dir*h+x)*w+y\n\tint y = p%w;\n\tp = (p - y) / w;\n\tint x = p%h;\n\tint dir = (p - x) / h;\n\tvi v = { x,y,dir };\n\treturn v;\n}\n\nint main()\n{\n\tll h, w, l;\n\twhile (cin >> h >> w >> l, h)\n\t{\n\t\tGraph g(h*w * 4);\n\t\tvs fld(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tint st;\n\t\tREP(i, h)REP(j,w)\n\t\t{\n\t\t\tif (fld[i][j] == 'N') st = place(i, j, 0, h, w);\n\t\t\tif (fld[i][j] == 'E') st = place(i, j, 1, h, w);\n\t\t\tif (fld[i][j] == 'S') st = place(i, j, 2, h, w);\n\t\t\tif (fld[i][j] == 'W') st = place(i, j, 3, h, w);\n\t\t\tif (fld[i][j] != '.' && fld[i][j] != '#') fld[i][j] = '.';\n\t\t}\n\t\tREP(dir, 4)REP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tint k = 0, cnt = 0;\n\t\t\tint nx = i + dx[dir], ny = j + dy[dir];\n\t\t\tfor (; !valid(nx, ny, h, w) || fld[nx][ny] == '#';)\n\t\t\t{\n\t\t\t\tk++;\n\t\t\t\tcnt++;\n\t\t\t\tif (cnt > 10) goto next;\n\t\t\t\tk %= 4;\n\t\t\t\tnx = i + dx[(dir + k) % 4]; ny = j + dy[(dir + k) % 4];\n\t\t\t}\n\t\t\tadd_edge(g, place(i, j, dir, h, w), place(nx, ny, (dir + k) % 4, h, w), 1);\n\t\tnext:;\n\t\t}\n\t\tset<int> memo; vi v; int loop;\n\t\tmemo.insert(st); v.push_back(st);\n\t\twhile (1)\n\t\t{\n\t\t\tint tmp = v.back();\n\t\t\tint next = g[tmp][0].to;\n\t\t\tif (memo.find(next) != memo.end())\n\t\t\t{\n\t\t\t\tloop = next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemo.insert(next);\n\t\t\tv.push_back(next);\n\t\t}\n\t\tint ans;\n\t\tif (v.size() > l) ans = v[l];\n\t\telse\n\t\t{\n\t\t\tint beg = find(ALL(v), loop) - v.begin();\n\t\t\tint len = v.size() - beg;\n\t\t\tl -= beg;\n\t\t\tans = v[beg + l%len];\n\t\t}\n\t\tvi ansv = rev(ans, h, w);\n\t\tint ax = ansv[0] + 1, ay = ansv[1] + 1;\n\t\tchar ad;\n\t\tswitch (ansv[2])\n\t\t{\n\t\tcase 0:\n\t\t\tad = 'N';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tad = 'E';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tad = 'S';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tad = 'W';\n\t\t\tbreak;\n\t\t}\n\t\tcout << ax << \" \" << ay << \" \" << ad << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nchar c[110][110];\nint d[110][110][4];\nint h, w, l;\nstring str = \"NESW\";\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> h >> w >> l;\n        if(h + w + l == 0) break;\n        int dr = 0, y = 0, x = 0;\n        rep(i, 0, 110) rep(j, 0, 110) rep(k, 0, 4) d[i][j][k] = -1;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> c[i][j];\n                if(str.find(c[i][j]) != string::npos){\n                    dr = str.find(c[i][j]);\n                    y = i; x = j;\n                }\n            }\n        }\n        d[y][x][dr] = 0;\n        vector<PP> sv;\n        sv.push_back(PP(P(y, x), dr));\n        for(int i = 1;; i++){\n            int ny = 0, nx = 0;\n            while(1){\n                ny = y + dy[dr];\n                nx = x + dx[dr];\n                if(contain(ny, nx) && c[ny][nx] != '#'){\n                    break;\n                }\n                dr = (dr + 1) % 4;\n            }\n            y = ny; x = nx;    \n            if(i == l){\n                cout << y + 1 << ' ' << x + 1 << ' ' << str[dr] << endl;\n                break;\n            }        \n            if(d[y][x][dr] != -1){\n                int loop = i - d[y][x][dr];\n                int step = d[y][x][dr] + (l - d[y][x][dr]) % loop;\n                cerr << loop << ' ' << step << endl;\n                cout << sv[step].first.first + 1 << ' ' << sv[step].first.second + 1 << ' ' << str[sv[step].second] << endl;\n                break;\n            }\n            d[y][x][dr] = i;\n            sv.push_back(PP(P(y, x), dr));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint main(void){\n\tint h, w, dx[4] = {0,1,0,-1},dy[4] = {-1,0,1,0}, flag[100][100][4], i, j, k, x, y, d;\n\tlong long int l;\n\tchar str[100][101], dir[5] = {\"NEST\"};\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&h,&w,&l);\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tstr[i][j] = getchar();\n\t\t\t\tif(isupper(str[i][j])){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tfor(k = 0;k < 4;k++)\n\t\t\t\t\t\tif(str[i][j] == dir[k]) d = k;\n\t\t\t\t\tstr[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tfor(i = 0;i < l;i++){\n\t\t\tif(flag[y][x][d] == -1)\n\t\t\t\tflag[y][x][d] = i;\n\t\t\telse{\n\t\t\t\tl = (l - i) % (i - flag[y][x][d]); // 残りの\n\t\t\t\ti = -1;\n\t\t\t\tmemset(flag,-1,sizeof(flag));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(x + dx[d] >= 0 && x + dx[d] < w && y + dy[d] >= 0 && y + dy[d] < h && str[y + dy[d]][x + dx[d]] == '.'){\n\t\t\t\t\tx = x + dx[d];\n\t\t\t\t\ty = y + dy[d];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",y + 1,x + 1,dir[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// ↑　→　↓　←\n\nlong long di[4] = {-1, 0, 1, 0};\nlong long dj[4] = {0, 1, 0, -1};\n\nint main(){\n\n    map<char, long long> direc;\n    char Indirec[4] = {'N', 'E', 'S', 'W'};\n    direc['N'] = 0;\n    direc['E'] = 1;    \n    direc['S'] = 2;\n    direc['W'] = 3;\n    \n    \n\n    while(1){\n        long long h, w;\n        long long l;\n        cin >> h >> w >> l;\n        if(!h) break;\n        long long si, sj, sh;\n        vector<vector<bool> > table(h + 2, vector<bool> (w + 2, false));\n        for(long long i = 1; i <= h; i++){\n            for(long long j = 1; j <= w; j++){\n                char c; cin >> c;\n                if(c == '.'){\n                    table[i][j] = true;\n                }else if(c != '#'){\n                    table[i][j] = true;\n                    si = i;\n                    sj = j;\n                    sh = direc[c];\n                }\n            }\n        }\n\n\n        vector<vector<vector<long long> > > dp(h + 2, vector<vector<long long> > (w + 2, vector<long long> (4, -1LL)));\n        \n\n        dp[si][sj][sh] = 0LL;\n        //cout << si << \" \" << sj << \" \" << sh << \" :\" << 0 << endl;\n        long long cnt = 1LL;\n        long long now_i = si;\n        long long now_j = sj;\n        long long now_h = sh;\n        long long T;\n        long long num;\n        for(;;){\n\n            \n            now_i += di[now_h];\n            now_j += dj[now_h];\n\n            while(!table[now_i][now_j]){\n                now_i -= di[now_h];\n                now_j -= dj[now_h];\n                now_h = (now_h + 1) % 4;\n                now_i += di[now_h];\n                now_j += dj[now_h];\n            }\n\n            //cout << now_i << \" \" << now_j << \" \" << now_h << \" :\" << cnt << endl;            \n            if(dp[now_i][now_j][now_h] == -1){\n                \n                dp[now_i][now_j][now_h] = cnt;\n                cnt++;\n            }else{\n                T = cnt - dp[now_i][now_j][now_h];\n                num = dp[now_i][now_j][now_h];\n                break;\n            }\n\n        }\n        //cout << cnt << endl;\n        //cout << l << \" \" << num << \" \" << T << endl;\n        \n        if(l >= cnt) l = (l - num) % T + num;\n\n        //cout << l << endl;\n        for(long long i = 1; i <= h; i++){\n            for(long long j = 1; j <= w; j++){\n                for(long long h = 0; h < 4; h++){\n                    if(dp[i][j][h] == l){\n                        cout << i <<  \" \" << j << \" \" << Indirec[h] << endl;\n                        i += h;\n                        j += w;\n                        h += 4;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nint main() {\n\tint H, W, L;\n\twhile(cin >> H >> W >> L, H) {\n\t\tvs field(H);\n\t\tREP(i, H) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tint sx, sy;\n\t\tchar sd;\n\t\tREP(i, H) {\n\t\t\tREP(j, W) {\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#') {\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsd = field[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint d;\n\t\tswitch(sd) {\n\t\tcase 'N':\n\t\t\td = 0;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\td = 1;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\td = 2;\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\td = 3;\n\t\t\tbreak;\n\t\t}\n\n\t\tint cx = sx, cy = sy;\n\t\tREP(i, L) {\n\t\t\tint nx = cx + dx[d];\n\t\t\tint ny = cy + dy[d];\n\n\t\t\tif(nx<0 || W<=nx || ny<0 || H<=ny || field[ny][nx] == '#') {\n\t\t\t\td = (d+1)%4;\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcx = nx;\n\t\t\tcy = ny;\n\t\t}\n\n\t\tchar gd;\n\t\tswitch(d) {\n\t\tcase 0:\n\t\t\tgd = 'N';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tgd = 'E';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgd = 'S';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tgd = 'W';\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << cy+1 << \" \" << cx+1 << \" \" << gd << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\ntemplate<class T> ostream& operator << (ostream& ost, vector<T> const& v) { ost << \"[\"; rep(i, v.size()) { if(i) ost << \", \"; ost << v[i]; } ost << \"]\"; return ost; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W; ll L;\nint dir, y, x, cost;\nstring const ds = \"WNES\";\n\nmap<tuple<int, int, int>, int> vis;\nvector<tuple<int, int, int>> data_;\nchar G[111][111];\n\nbool in_range(int y, int x, int H, int W) {\n  if(!(0<=y&&y<H&&0<=x&&x<W)) return false;\n  if(G[y][x] == '#') return false;\n  return true;\n}\n\nvoid adjust_dir() {\n  while(!in_range(y + dy[dir], x + dx[dir], H, W)) {\n    dir ++;\n    dir %= 4;\n  }\n}\n\nvoid debug() {\n  cout << \"cost = \" << cost << endl;\n  rep(i, H) {\n    rep(j, W) {\n      if(isalpha(G[i][j])) cout << \".\";\n      else if(i == y && j == x) cout << ds[dir];\n      else cout << G[i][j];\n    }\n    cout << endl;\n  }\n  cout << get<0>(data_.back()) << \", \";\n  cout << get<1>(data_.back()) << \", \";\n  cout << get<2>(data_.back()) << endl;\n  cout << endl;\n}\n\nvoid enter_loop() {\n  const int loop_start_cost = vis[make_tuple(y,x,dir)];\n  const int len = cost - loop_start_cost;\n  /*\n  cout << \"loop_start_cost = \" << loop_start_cost << endl;\n  cout << \"len = \" << len << endl;\n  */\n  L -= loop_start_cost;\n  /*\n  cout << \"L = \" << L << endl;\n  cout << \"data_.size() = \" << data_.size() << endl;\n  cout << \"soeji = \" << loop_start_cost + L % len << endl;\n  */\n  int Y, X, d; tie(Y, X, d) = data_[loop_start_cost + L % len - 1];\n  cout << Y+1 << \" \" << X+1 << \" \" << ds[d] << endl;\n}\n\nbool step() {\n  adjust_dir();\n  y += dy[dir], x += dx[dir];\n  cost ++;\n  if(vis.find(make_tuple(y, x, dir)) != vis.end()) {\n    enter_loop();\n    return false;\n  }\n  if(cost == L) {\n    cout << y+1 << \" \" << x+1 << \" \" << ds[dir] << endl;\n    return false;\n  }\n  vis[make_tuple(y, x, dir)] = cost;\n  data_.emplace_back(y, x, dir);\n//  debug();\n  return true;\n}\n\nvoid simulate() {\n\n  vis.clear();\n  data_.clear();\n  cost = 0;\n\n  while(step());\n}\n\nint main() {\n\n  for(; cin >> H >> W >> L && (H | W | L);) {\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if(isalpha(G[i][j])) {\n        y = i, x = j;\n        dir = ds.find(G[i][j]);\n      }\n    }\n\n    simulate();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint H, W, L;\n\t\tchar C[100][100];\n\n\t\tcin >> H >> W >> L;\n\t\tif (H == 0) return 0;\n\n\t\tint sx, sy, sd;\n\n\t\trep(y, 0, H) rep(x, 0, W)\n\t\t{\n\t\t\tchar c; cin >> c;\n\t\t\tif (c != '.' && c != '#')\n\t\t\t{\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tswitch (c)\n\t\t\t\t{\n\t\t\t\tcase 'N': sd = 0; break;\n\t\t\t\tcase 'E': sd = 1; break;\n\t\t\t\tcase 'S': sd = 2; break;\n\t\t\t\tcase 'W': sd = 3; break;\n\t\t\t\t}\n\t\t\t\tC[y][x] = '.';\n\t\t\t}\n\t\t\telse\n\t\t\t\tC[y][x] = c;\n\t\t}\n\n\t\tint memo[100][100][4];\n\t\trep(y, 0, H) rep(x, 0, W) rep(i, 0, 4) memo[y][x][i] = -1;\n\t\tbool noloop = true;\n\n\t\tint dx[4] = { 0, 1, 0, -1 };\n\t\tint dy[4] = { -1, 0, 1, 0 };\n\n\t\trep(l, 0, L)\n\t\t{\n\t\t\trep(i, 0, 4)\n\t\t\t{\n\t\t\t\tint d = (sd + i) % 4;\n\t\t\t\tif (noloop)\n\t\t\t\t{\n\t\t\t\t\tif (memo[sy][sx][d] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[sy][sx][d] = l;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint dl = l - memo[sy][sx][d];\n\t\t\t\t\t\tl = l + ((L - 1 - l) / dl) * dl;\n\t\t\t\t\t\tnoloop = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint x = sx + dx[d];\n\t\t\t\tint y = sy + dy[d];\n\t\t\t\tif (x < 0 || W <= x) continue;\n\t\t\t\tif (y < 0 || H <= y) continue;\n\t\t\t\tif (C[y][x] == '#') continue;\n\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tsd = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << (sy + 1) << \" \" << (sx + 1) << \" \";\n\t\tswitch (sd)\n\t\t{\n\t\tcase 0: cout << \"N\"; break;\n\t\tcase 1: cout << \"E\"; break;\n\t\tcase 2: cout << \"S\"; break;\n\t\tcase 3: cout << \"W\"; break;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint main(){\n  int h,w,y,x,d;\n  long long l;\n  string g[100];\n\n  int vis[100][100][4];\n  int px[40100],py[40100],pd[40100];\n\n  char dir[] = {'N','E','S','W'};\n  int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  while(cin >> h >> w >> l,h){\n    rep(i,h)cin >> g[i];\n\n    rep(i,h)rep(j,w)rep(k,4){\n      if(g[i][j] == dir[k]){\n\ty = i; x = j; d = k;\n      }\n      vis[i][j][k] = -1;\n    }\n\n    int step = 0;\n    for(;;){\n      if(vis[y][x][d]>=0)break;\n      vis[y][x][d] = step;\n      \n      py[step] = y; px[step] = x; pd[step] = d;\n      step++;\n\n      rep(i,4){\n\tint nd = (d+i)%4;\n\tint ny = y+dy[nd], nx = x+dx[nd];\n\tif(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\tif(g[ny][nx] == '#')continue;\n\ty = ny; x = nx; d = nd;\n\tbreak;\n      }\n    }\n\n    long long head = vis[y][x][d], now = l;\n    if(step<l){\n      now -= head;\n      now %= step-head;\n      now += head;\n    }\n    cout << py[now]+1 << \" \" << px[now]+1 << \" \" << dir[pd[now]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H, W;\nll L;\nchar c[128][128];\nint dist[4][128][128]; // N E S W\nint dy[]={-1,0,1,0}, dx[]={0,1,0,-1};\n\nint convert(char ch){ return ch=='N'?0:ch=='E'?1:ch=='S'?2:3; }\nchar reconvert(int n){ return n==0?'N':n==1?'E':n==2?'S':'W'; }\n\nvoid solve(int sy, int sx, int sd){\n  int y=sy,x=sx,dir=sd;\n  dist[dir][y][x] = 0;\n  for(int step=1;;step++){\n    int nd = dir;\n    int ny = y+dy[nd], nx = x+dx[nd];\n    while(ny<0||ny>=H||nx<0||nx>=W||c[ny][nx]=='#'){\n      nd = (nd+1)%4;\n      ny = y+dy[nd], nx = x+dx[nd];\n    }\n\n    if(dist[nd][ny][nx]!=-1){\n      int l = L-dist[nd][ny][nx];\n      l %= (dist[dir][y][x] - dist[nd][ny][nx] + 1);\n      rep(i,4) rep(j,128) rep(k,128){\n\tif(dist[i][j][k] != l + dist[nd][ny][nx]) continue;\n\tprintf(\"%d %d %c\\n\", j+1, k+1, reconvert(i));\n\treturn;\n      }\n    }\n    y = ny, x = nx, dir = nd; \n    if(step==L){\n      printf(\"%d %d %c\\n\", y+1, x+1, reconvert(dir));\n      return;\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d%lld\", &H,&W, &L) && H+W+L){\n    int sy, sx, sd;\n    memset(dist, -1, sizeof(dist));\n    rep(i,H){\n      scanf(\"%s\", c[i]);\n      rep(j,W){\n\tif(c[i][j]=='#'||c[i][j]=='.') continue;\n\tsy = i; sx = j;\n\tsd = convert(c[i][j]);\n\tc[i][j] = '.';\n      }\n    }\n    \n    //int y = sy, x = sx, dir = sd;\n    //    for(int step=0;;step++){\n    //    }\n    solve(sy, sx, sd);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <iostream>\n#include <cstring>\ntypedef long long ll;\nint dx[] = { 0,1,0,-1 }, dy[] = {-1, 0, 1, 0};\n\nusing namespace std;\nint main() {\n    ll H, W, L;\n    while (cin >> H >> W >> L, H) {\n        string field[100];\n        for (int i = 0; i < H; i++) {\n            cin >> field[i];\n        }\n\n        int x, y, dir;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == 'N') x = j, y = i, dir = 0;\n                if (field[i][j] == 'E') x = j, y = i, dir = 1;\n                if (field[i][j] == 'S') x = j, y = i, dir = 2;\n                if (field[i][j] == 'W') x = j, y = i, dir = 3;\n            }\n        }\n\n        ll memo[100][100][4];\n        memset(memo, -1, sizeof memo);\n        memo[y][x][dir] = 0;\n\n        ll c = 0, rem = L;\n        while (rem > 0) {\n            int nx = x + dx[dir], ny = y + dy[dir];\n            while (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] == '#') {\n                dir = (dir + 1) % 4;\n                nx = x + dx[dir], ny = y + dy[dir];\n            }\n\n            c++;\n            rem--;\n            x = nx;\n            y = ny;\n\n            if (memo[y][x][dir] == -1){\n                memo[y][x][dir] = c;\n            }\n            else {\n                ll loop = c - memo[y][x][dir];\n                if (rem >= loop) rem %= loop;\n            }\n        }\n\n        string s = \"NESW\";\n        cout << y + 1 << \" \" << x + 1 << \" \" << s[dir] << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w;\nint sy, sx, dir;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar dd[4] = {'E', 'S', 'W', 'N'};\n\nbool can(int y, int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nint main() {\n\tll l;\n\twhile(cin >> h >> w >> l) {\n\t\tif(h == 0 && w == 0 && l == 0) break;\n\n\t\tvector<string> v(h);\n\t\trep(i, h) cin >> v[i];\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(v[i][j] == 'E') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 0;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'S') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 1;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'W') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 2;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'N') {\n\t\t\t\t\tsy = i; sx = j;\n\t\t\t\t\tdir = 3;\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll d[105][105][4];\n\t\tmemset(d, -1, sizeof(d));\n\n\t\tvector<int> X, Y, D;\n\t\tint y = sy, x = sx, cnt = 0;\n\t\tint pdir = dir;\n\n\t\td[y][x][dir] = cnt;\n\t\tcnt++;\n\n\t\twhile(l) {\n\t\t\ty = y + dy[dir];\n\t\t\tx = x + dx[dir];\n\t\t\tpdir = dir;\n\t\t\tl--;\n\n\t\t\trep(i, 4) {\n\t\t\t\tint ny = y + dy[(dir + i) % 4];\n\t\t\t\tint nx = x + dx[(dir + i) % 4];\n\n\t\t\t\tif(can(ny, nx) && v[ny][nx] == '.') {\n\t\t\t\t\tdir = (dir + i) % 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(d[y][x][dir] == -1) {\n\t\t\t\td[y][x][dir] = cnt;\n\t\t\t\tcnt++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(l == 0) {\n\t\t\tcout << y + 1 << \" \" << x + 1 << \" \" << dd[pdir] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tll len = cnt - d[y][x][dir];\n\t\tl = l % len;\n\n\t\trep(i, l) {\n\t\t\trep(j, 4) {\n\t\t\t\tint ny = y + dy[(dir + j) % 4];\n\t\t\t\tint nx = x + dx[(dir + j) % 4];\n\n\t\t\t\tif(can(ny, nx) && v[ny][nx] == '.') {\n\t\t\t\t\ty = ny; x = nx;\n\t\t\t\t\tdir = (dir + j) % 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << y + 1 << \" \" << x + 1 << \" \" << dd[dir] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//const int INF = 1e8;\nconst int N = 105;\n\nchar c[N][N];\nint dist[4][N][N];\nint h, w, l;\nint to, loop;\n\nstruct Point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nvoid dfs(Point p, int dir, int dis){\n    //cout << endl;\n    if(dist[dir][p.y][p.x] != -1){\n        //show(p.y)\n        //show(p.x)\n        //show(dis)\n        //show(dist[p.y][p.x])\n        to = dist[dir][p.y][p.x];\n        loop = dis - dist[dir][p.y][p.x];\n        return;\n    }\n    dist[dir][p.y][p.x] = dis;\n\n    //rep(i,h){ rep(j,w){ cout << dist[dir][i][j] << ' '; } cout << endl; }\n\n    int ny = p.y + dy[dir];\n    int nx = p.x + dx[dir];\n    while( (ny < 0 || ny >= h || nx < 0 || nx >= w) || c[ny][nx] == '#'){\n        dir = (dir + 1) % 4;\n        dfs(Point{p.x,p.y}, dir, dis);\n        return;\n    }\n\n\n    dfs(Point{nx,ny}, dir, dis + 1);\n}\n\nvoid dfs_(Point p, int dir, int dis){\n    //show(dir) cout << p.y << ' ' << p.x << endl;\n    if(dis == 0){\n        char d[5] = {\"ESWN\"};\n        cout << p.y + 1 << ' ' << p.x + 1 << ' ' << d[dir] << endl;\n        return;\n    }\n\n    int ny = p.y + dy[dir];\n    int nx = p.x + dx[dir];\n    while( (ny < 0 || ny >= h || nx < 0 || nx >= w) || c[ny][nx] == '#'){\n        dir = (dir + 1) % 4;\n        ny = p.y + dy[dir];\n        nx = p.x + dx[dir];\n    }\n    dfs_(Point{nx,ny}, dir, dis - 1);\n}\n\nint main(){\n    while(cin >> h >> w >> l,h){\n        memset(dist, -1, sizeof(dist));\n        int dir = -1;\n        Point p = Point{-1,-1};\n        rep(i,h){\n            rep(j,w){\n                cin >> c[i][j];\n                if(c[i][j] == 'N') dir = 3;\n                else if(c[i][j] == 'E') dir = 0;\n                else if(c[i][j] == 'S') dir = 1;\n                else if(c[i][j] == 'W') dir = 2;\n                if(dir != -1 && p.x == -1){\n                    p = Point{j,i};\n                }\n            }\n        }\n        dfs(p,dir,0);\n        //show(to)\n        //show(loop)\n        l = max(l - to,0) % loop;\n        dfs_(p,dir,l + to);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nstring mp[100];\nint d[100][100][4],inf=1e8,dh[4]={-1,0,1,0},dw[4]={0,1,0,-1};\nint main(){\n\twhile(true){\n\t\tint h,w;\n\t\tll l;\n\t\tcin >> h >> w >> l;\n\t\tif(h==0) break;\n\t\trep(i,h) cin >> mp[i];\n\t\tint sw,sh,di;\n\t\trep(i,h) rep(j,w) if(mp[i][j]!='.' && mp[i][j]!='#') sh=i,sw=j;\n\t\tif(mp[sh][sw]=='N') di=0;\n\t\tif(mp[sh][sw]=='E') di=1;\n\t\tif(mp[sh][sw]=='S') di=2;\n\t\tif(mp[sh][sw]=='W') di=3;\n\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k]=inf;\n\t\td[sh][sw][di]=0;\n\t\tint now=1;\n\t\twhile(true){\n\t\t\tint nh,nw;\n\t\t\twhile(true){\n\t\t\t\tnh=sh+dh[di],nw=sw+dw[di];\n\t\t\t\tif(!(0<=nh && nh<h && 0<=nw && nw<w) || mp[nh][nw]=='#'){\n\t\t\t\t\tdi=(di+1)%4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsh=nh,sw=nw;\n\t\t\tif((ll)now==l){\n\t\t\t\tcout << sh+1 << \" \" << sw+1 << \" \";\n\t\t\t\tif(di==0) cout << \"N\\n\";\n\t\t\t\tif(di==1) cout << \"E\\n\";\n\t\t\t\tif(di==2) cout << \"S\\n\";\n\t\t\t\tif(di==3) cout << \"W\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(d[sh][sw][di]==inf){\n\t\t\t\td[sh][sw][di]=now;\n\t\t\t\tnow++;\n\t\t\t}else{\n\t\t\t\tint dd=d[sh][sw][di];\n\t\t\t\tl=dd+(l-dd)%(now-dd);\n\t\t\t\trep(i,h) rep(j,w) rep(k,4) if(d[i][j][k]==l){\n\t\t\t\t\tcout << i+1 << \" \" << j+1 << \" \";\n\t\t\t\t\tif(k==0) cout << \"N\\n\";\n\t\t\t\t\tif(k==1) cout << \"E\\n\";\n\t\t\t\t\tif(k==2) cout << \"S\\n\";\n\t\t\t\t\tif(k==3) cout << \"W\\n\";\n\t\t\t\t\tgoto label;\n\t\t\t\t}\n\t\t\t\tlabel:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nstruct State{\n\tint y,x,dir;\n};\n\nvoid Solve(){\n\twhile(true){\n\t\tll h,w,l;\n\t\tcin >> h >> w >> l;\n\t\tif(h==0&&w==0&&l==0) break;\n\t\tvector<string> cells(h);\n\t\tREP(i,0,h) cin >> cells[i];\n\n\t\tconst char empty='.',wall='#';\n\t\tconst int north=0,east=1,south=2,west=3;\n\t\tint y,x,dir;\n\t\tREP(i,0,h) REP(j,0,w) if(cells[i][j]!=empty&&cells[i][j]!=wall){\n\t\t\ty=i; x=j;\n\t\t\tswitch(cells[i][j]){\n\t\t\t\tcase 'N': dir=north; break;\n\t\t\t\tcase 'E': dir=east; break;\n\t\t\t\tcase 'S': dir=south; break;\n\t\t\t\tcase 'W': dir=west; break;\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t\tcells[i][j]=empty;\n\t\t\tbreak;\n\t\t}\n\n\t\tint rotate[4];\n\t\tREP(i,0,4) rotate[i]=(i+1)%4;\n\n\t\t//State memo[100][100][4];\n\t\t//REP(i,0,h) REP(j,0,w) REP(k,0,4){\n\t\t\t//int y_=i,x_=j;\n\t\t\t//int ny=y_+dy[k],nx=x_+dx[k];\n\t\t\t//while(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty){\n\t\t\t\t//y_=ny; x_=nx;\n\t\t\t\t//ny=y_+dy[k]; nx=x_+dx[k];\n\t\t\t//}\n\t\t\t//memo[i][j][k]={y_,x_,rotate[k]};\n\t\t//}\n\n\t\tconst int dx[]={0,1,0,-1},dy[]={-1,0,1,0};\n\t\tll visited[100][100][4];\n\t\tfill_n((int*)visited,100*100*4,-1);\n\t\tll cnt=0;\n\t\twhile(cnt<l){\n\t\t\tdump(y);\n\t\t\tdump(x);\n\t\t\tif(visited[y][x][dir]==-1) visited[y][x][dir]=cnt;\n\t\t\telse{\n\t\t\t\tll tmp=0; \n\t\t\t\twhile(cnt+tmp+cnt-visited[y][x][dir]<=l) tmp+=(cnt-visited[y][x][dir]);\n\t\t\t\tcnt+=tmp;\n\t\t\t\tif(cnt==l) break;\n\t\t\t}\n\t\t\t\n\t\t\tint ny=y+dy[dir],nx=x+dx[dir];\n\t\t\twhile(!(0<=ny&&ny<h&&0<=nx&&nx<w&&cells[ny][nx]==empty)){\n\t\t\t\tdir=rotate[dir];\n\t\t\t\tny=y+dy[dir]; nx=x+dx[dir];\n\t\t\t}\n\t\t\ty=ny; x=nx; ++cnt;\n\t\t}\n\n\t\tcout << y+1 << ' ' << x+1 << ' ' << \"NESW\"[dir] << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\n\nconstexpr int NUMBER_OF_DIRECTIONS = 4;\nconst string direction = \"ESWN\";\nconstexpr int dx[NUMBER_OF_DIRECTIONS] = {1, 0, -1, 0};\nconstexpr int dy[NUMBER_OF_DIRECTIONS] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y, d;\n\tstate(int x = 0, int y = 0, int d = 0):x(x), y(y), d(d){}\n};\n\nostream& operator<<(ostream& os, const state& s) {\n\treturn os << s.y + 1 << \" \" << s.x + 1 << \" \" << direction[s.d];\n}\n\nconst int MAX_SIZE = 100;\nstring field[MAX_SIZE];\nint h, w;\nlong long l;\n\nint label[MAX_SIZE][MAX_SIZE][NUMBER_OF_DIRECTIONS];\nstate states[MAX_SIZE * MAX_SIZE * NUMBER_OF_DIRECTIONS];\n\ninline bool out(int x, int y) {\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\n\ninline bool verify(int x, int y) {\n\treturn !out(x, y) && field[y][x] != '#';\n}\n\nstate solve(int x, int y, int d) {\n\tmemset(label, -1, sizeof(label));\n\tfor(int i = 0; i < l; ++i) {\n\t\tif(label[y][x][d] != -1) {\n\t\t\tconst long long T = i - label[y][x][d];\n\t\t\tconst long long rest = l - i;\n\t\t\treturn states[label[y][x][d] + rest % T];\n\t\t}\n\n\t\tlabel[y][x][d] = i;\n\t\tstates[i] = state(x, y, d);\n\n\t\twhile(!verify(x + dx[d], y + dy[d])) d = (d + 1) % NUMBER_OF_DIRECTIONS;\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\n\treturn state(x, y, d);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w >> l && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tstate start;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(isalpha(field[i][j])) {\n\t\t\t\t\tstart.x = j;\n\t\t\t\t\tstart.y = i;\n\t\t\t\t\tstart.d = direction.find(field[i][j]);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tend:;\n\n\t\tcout << solve(start.x, start.y, start.d) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nstruct node{\n\tint y,x,dir;\n\tll cost;\n\tnode(int y,int x,int dir,ll cost):y(y),x(x),cost(cost),dir(dir){}\n};\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nchar dirs[]={'W','N','E','S'};\nconst ll MAX=LONG_MAX;\nint main(){\n\tint h,w,l;\n\twhile(cin>>h>>w>>l,h|w|l){\n\t\tvs c(h);\n\t\tpii start;\n\t\tint initdir;\n\t\tREP(i,h){\n\t\t\tcin>>c[i];\n\t\t\tREP(j,w){\n\t\t\t\tswitch(c[i][j]){\n\t\t\t\tcase 'W':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvvl cost(h,vvl(w,vl(4,MAX)));\n\t\tqueue<node> q;\n\t\tcost[start.first][start.second][initdir]=l;\n\t\tq.push(node(start.first,start.second,initdir,l));\n\t\twhile(!q.empty()){\n\t\t\tnode cnode=q.front();q.pop();\n\t\t\tif(cnode.cost==0){\n\t\t\t\tcout<<cnode.y+1<<\" \"<<cnode.x+1<<\" \"<<dirs[cnode.dir]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint d=cnode.dir;\n\t\t\tint y=cnode.y+dy[d];\n\t\t\tint x=cnode.x+dx[d];\n\t\t\twhile(!(y>=0&&x>=0&&y<h&&x<w&&c[y][x]!='#')){\n\t\t\t\td=(d+1)%4;\n\t\t\t\ty=cnode.y+dy[d];\n\t\t\t\tx=cnode.x+dx[d];\n\t\t\t}\n\t\t\tif(cost[y][x][d]!=MAX){\n\t\t\t\tll diff=cost[y][x][d]-(cnode.cost-1);\n\t\t\t\tcost[y][x][d]=(cnode.cost-1)%diff;\n\t\t\t\tq.push(node(y,x,d,(cnode.cost-1)%diff));\n\t\t\t}else{\n\t\t\t\tcost[y][x][d]=cnode.cost-1;\n\t\t\t\tq.push(node(y,x,d,cnode.cost-1));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint d[4][111][111];\nstring s[111];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nint h,w;\nlong L;\nmain()\n{\n\twhile(cin>>h>>w>>L,h)\n\t{\n\t\tint x,y,r;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<4;k++)d[k][i][j]=-1;\n\t\t\t\tif(s[i][j]>'A')\n\t\t\t\t{\n\t\t\t\t\tx=i;y=j;\n\t\t\t\t\tif(s[i][j]=='E')r=0;\n\t\t\t\t\telse if(s[i][j]=='S')r=1;\n\t\t\t\t\telse if(s[i][j]=='W')r=2;\n\t\t\t\t\telse if(s[i][j]=='N')r=3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\twhile(d[r][x][y]<0)\n\t\t{\n\t\t\td[r][x][y]=cnt++;\n\t\t\tif(--L<0)break;\n\t\t\tfor(int dr=0;dr<4;dr++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[(r+dr)%4],ty=y+dy[(r+dr)%4];\n\t\t\t\tif(tx<0||ty<0||tx>=h||ty>=w||s[tx][ty]=='#')continue;\n\t\t\t\tx=tx;y=ty;r=(r+dr)%4;break;\n\t\t\t}\n\t\t}\n\t\tL%=cnt-d[r][x][y];\n\t\twhile(L)\n\t\t{\n\t\t\tfor(int dr=0;dr<4;dr++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[(r+dr)%4],ty=y+dy[(r+dr)%4];\n\t\t\t\tif(tx<0||ty<0||tx>=h||ty>=w||s[tx][ty]=='#')continue;\n\t\t\t\tx=tx;y=ty;r=(r+dr)%4;break;\n\t\t\t}\n\t\t\tL--;\n\t\t}\n\t\tcout<<x+1<<\" \"<<y+1<<\" \"<<\"ESWN\"[r]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint dd[] = {-1, 0, 1, 0, -1};\n\nstruct state {\n    int x, y, d;\n    ll turn;\n};\n\nint main(){\n    cin.sync_with_stdio(false);\n    int h, w;\n    ll l;\n    while(cin >> h >> w >> l, h) {\n        ll maze[h + 2][w + 2][4];\n        rep(i, h + 2)rep(j, w + 2)rep(k, 4) maze[i][j][k] = INF;\n\n        state s;\n        repl(i, 1, h + 1)repl(j, 1, w + 1) {\n            char c;\n            cin >> c;\n            if (c == '.') rep(k, 4) maze[i][j][k] = -1;\n            else if (c != '#') {\n                switch(c) {\n                    case 'N': s.d = 0; break;\n                    case 'E': s.d = 1; break;\n                    case 'S': s.d = 2; break;\n                    case 'W': s.d = 3; break;\n                }\n                s.x = j, s.y = i, s.turn = 0;\n                rep(k, 4) maze[i][j][k] = -1;\n            }\n        }\n\n        while (true) {\n            if (maze[s.y][s.x][s.d] >= 0) {\n                s.turn = (l - maze[s.y][s.x][s.d]) / (s.turn - maze[s.y][s.x][s.d])\n                * (s.turn - maze[s.y][s.x][s.d]) + maze[s.y][s.x][s.d];\n            }\n            maze[s.y][s.x][s.d] = s.turn;\n            if (s.turn == l) break;\n            while (maze[s.y + dd[s.d]][s.x + dd[s.d + 1]][s.d] == INF) {\n                s.d = (s.d + 1) % 4;\n            }\n            s.y += dd[s.d], s.x += dd[s.d + 1];\n            s.turn++;\n        }\n\n        char c;\n        switch(s.d) {\n            case 0: c = 'N'; break;\n            case 1: c = 'E'; break;\n            case 2: c = 'S'; break;\n            case 3: c = 'W'; break;\n        }\n\n        cout << s.y << \" \" << s.x << \" \" << c << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1}, H, W;\nstring dir[] = {\"N\",\"E\",\"S\",\"W\"};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nstring dfs(vector<string> &C, vector< vector< vector<int> > > &T,\n           int x, int y, long long int l, int d){\n  if(T[x][y][d] > 0){\n    l %= (T[x][y][d]-l);\n  }else{\n    T[x][y][d] = l;\n  }\n\n  if(l == 0){\n    string ret = to_string(x+1) + \" \" + to_string(y+1) + \" \" + dir[d];\n    return ret;\n  }\n  \n  for(int i = 0; i < 4; ++i){\n    int d_ = (d+i)%4, x_ = x + dx[d_], y_ = y + dy[d_];\n    //--l;\n    if(in_range(x_,H) && in_range(y_,W) && C[x_][y_] != '#'){\n      return dfs(C,T,x_,y_,l-1,d_);\n    }\n  }\n  return \"Error\";\n}\n\nint main(){\n  long long L;\n  while(cin >> H >> W >> L, H){\n    vector<string> C(H);\n    int s_x, s_y, d;\n    for(int i = 0; i < H; ++i){\n      cin >> C[i];\n      for(int j = 0; j < W; ++j){\n        if(C[i][j] != '.' && C[i][j] != '#'){\n          s_x = i;\n          s_y = j;\n          if(C[i][j] == 'N') d = 0;\n          if(C[i][j] == 'E') d = 1;\n          if(C[i][j] == 'S') d = 2;\n          if(C[i][j] == 'W') d = 3;\n        }\n      }\n    }\n    vector< vector< vector<int> > > T(H,vector< vector<int> >(W,vector<int>(4,-1)));\n    cout << dfs(C,T,s_x,s_y,L,d) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nchar field[110][110];\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint dx[4]   = {-1, 0, 1, 0};\nint dy[4]   = {0, 1, 0, -1};\n\nll memo[110][110][4];\nint main(){\n  ll H, W, L;\n  while(cin >>H >> W >> L && H + W + L){\n    fill(&field[0][0],&field[0][0] + 110 * 110, '#');\n    memset(memo, -1, sizeof(memo));\n\n    int x, y, d;\n    REP(i, H)REP(j, W){\n      cin >> field[i+1][j+1];\n      if(isalpha(field[i+1][j+1])){\n        x = i + 1, y = j + 1, d = find(dir, dir + 4, field[i+1][j+1]) - dir;\n      }\n    }\n\n    ll T = 0;\n    bool flag = false;\n    while(L > 0){\n      \n      if(memo[x][y][d] >= 0 && !flag){\n        ll S = T - memo[x][y][d];\n        L %= S;\n        flag = true;\n      }\n\n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      if(field[nx][ny] == '#'){\n        d = (d + 1) % 4;\n        continue;\n      }\n      \n      memo[x][y][d] = T;\n      x = nx;\n      y = ny;\n      L--;\n      T++;      \n    }\n    cout << x<< \" \" << y<< \" \" << dir[d] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nstruct loc { int x, y, d; };\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\nint trans(char x) {\n\tif (x == 'N')return 0;\n\telse if (x == 'E')return 1;\n\telse if (x == 'S')return 2;\n\telse return 3;\n}\nchar inv(int x) {\n\tif (x == 0)return 'N';\n\telse if (x == 1)return 'E';\n\telse if (x == 2)return 'S';\n\telse return 'W';\n}\nbool eq(loc x, loc y) {\n\tif (x.x == y.x&&x.y == y.y&&x.d == y.d)return true;\n\treturn false;\n}\nint main() {\n\tint w, h; ll n;\n\twhile (cin >> h >> w >> n,h) {\n\t\tchar board[100][100];\n\t\tint used[100][100][4] = {};\n\t\tvector<loc> v;\n\t\tloc now;\n\t\trep(i, h) {\n\t\t\tstring s; cin >> s;\n\t\t\trep(j, w) {\n\t\t\t\tboard[i][j] = s[j];\n\t\t\t\tif (s[j] != '.'&&s[j] != '#') {\n\t\t\t\t\tnow = { i,j,trans(s[j]) };\n\t\t\t\t\tused[i][j][trans(s[j])] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tv.push_back(now);\n\t\tloc memo;\n\t\twhile (true) {\n\t\t\trep(j, 4) {\n\t\t\t\tint nx = now.x + dx[(j+now.d)%4];\n\t\t\t\tint ny = now.y + dy[(j+now.d)%4];\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= h || ny >= w)continue;\n\t\t\t\tif (board[nx][ny] == '#')continue;\n\t\t\t\tnow = { nx,ny,(j + now.d) % 4 }; break;\n\t\t\t}\n\t\t\tif (used[now.x][now.y][now.d]) {\n\t\t\t\tmemo = now;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused[now.x][now.y][now.d] = 1;\n\t\t\tv.push_back(now);\n\t\t}\n\t\tint len = v.size(); int chk;\n\t\trep(i, len) {\n\t\t\tif (eq(v[i], memo)) {\n\t\t\t\tchk = i; break;\n\t\t\t}\n\t\t}\n\t\tif ((ll)len > n) {\n\t\t\tint r = (int)n;\n\t\t\tint x = v[r].x + 1; int y = v[r].y + 1; char d = inv(v[r].d);\n\t\t\tcout << x << \" \" << y << \" \" << d << endl;\n\t\t}\n\t\telse {\n\t\t\tn -= (ll)chk;\n\t\t\tint r = (int)(n % (ll)(len - chk)) + chk;\n\t\t\tint x = v[r].x + 1; int y = v[r].y + 1; char d = inv(v[r].d);\n\t\t\tcout << x << \" \" << y << \" \" << d << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nlong long LOG = 61;\nvector<int> dy = {-1, 0, 1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint main(){\n  while (1){\n    int H, W;\n    long long L;\n    cin >> H >> W >> L;\n    if (H == 0 && W == 0 && L == 0){\n      break;\n    }\n    vector<vector<char>> c(H + 2, vector<char>(W + 2, '#'));\n    for (int i = 1; i <= H; i++){\n      for (int j = 1; j <= W; j++){\n        cin >> c[i][j];\n      }\n    }\n    int s;\n    for (int i = 1; i <= H; i++){\n      for (int j = 1; j <= W; j++){\n        if (c[i][j] != '.' && c[i][j] != '#'){\n          s = ((i - 1) * W + (j - 1)) * 4;\n          if (c[i][j] == 'E'){\n            s++;\n          }\n          if (c[i][j] == 'S'){\n            s += 2;\n          }\n          if (c[i][j] == 'W'){\n            s += 3;\n          }\n          c[i][j] = '.';\n        }\n      }\n    }\n    vector<int> next(H * W * 4, -1);\n    for (int i = 1; i <= H; i++){\n      for (int j = 1; j <= W; j++){\n        for (int k = 0; k < 4; k++){\n          int v = ((i - 1) * W + (j - 1)) * 4 + k;\n          if (c[i + dy[k]][j + dx[k]] == '.'){\n            next[v] = ((i + dy[k] - 1) * W + (j + dx[k] - 1)) * 4 + k;\n          } else {\n            for (int l = 0; l < 4; l++){\n              if (c[i + dy[(k + l) % 4]][j + dx[(k + l) % 4]] == '.'){\n                next[v] = ((i + dy[(k + l) % 4] - 1) * W + (j + dx[(k + l) % 4] - 1)) * 4 + (k + l) % 4;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    vector<vector<int>> p(LOG, vector<int>(H * W * 4, -1));\n    for (int i = 0; i < H * W * 4; i++){\n      p[0][i] = next[i];\n    }\n    for (int i = 1; i < LOG; i++){\n      for (int j = 0; j < H * W * 4; j++){\n        if (p[i - 1][j] != -1){\n          p[i][j] = p[i - 1][p[i - 1][j]];\n        }\n      }\n    }\n    for (int i = 0; i < LOG; i++){\n      if (L >> i & 1){\n        s = p[i][s];\n      }\n    }\n    int y = s / 4 / W + 1;\n    int x = s / 4 % W + 1;\n    char d;\n    if (s % 4 == 0){\n      d = 'N';\n    }\n    if (s % 4 == 1){\n      d = 'E';\n    }\n    if (s % 4 == 2){\n      d = 'S';\n    }\n    if (s % 4 == 3){\n      d = 'W';\n    }\n    cout << y << ' ' << x << ' ' << d << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, d[105][105][4]; long long L; char c[105][105], w[5] = \"NESW\";\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nint main() {\n\twhile (scanf(\"%d%d%lld\", &H, &W, &L), L) {\n\t\tfor (int i = 0; i < H; i++) scanf(\"%s\", c[i]);\n\t\tint sx = -1, sy = -1, sd = -1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (c[i][j] == w[k]) sx = j, sy = i, sd = k;\n\t\t\t\t\td[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[sy][sx][sd] = 0;\n\t\tint x = sx, y = sy, r = sd;\n\t\twhile (true) {\n\t\t\tint tx = x, ty = y, tr = r;\n\t\t\twhile (!rng(x + dx[r], y + dy[r]) || c[y + dy[r]][x + dx[r]] == '#') r = (r + 1) % 4;\n\t\t\tx += dx[r], y += dy[r];\n\t\t\tif (d[y][x][r] == -1) d[y][x][r] = d[ty][tx][tr] + 1;\n\t\t\telse {\n\t\t\t\tint t = d[ty][tx][tr] + 1, sa = t - d[y][x][r];\n\t\t\t\tif (L >= t) L = t + (L - t) % sa - sa;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (d[i][j][k] == L) printf(\"%d %d %c\\n\", i + 1, j + 1, w[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 105\nusing namespace std;\ntypedef long long ll;\nchar Rot(char);\nint GetNum(char);\n\nint main(){\n  ll h,w,y,x,r,me[N][N][4];\n  char c;\n  string s[N];\n  ll l,t;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tfor(int k=0;k<4;k++) me[i][j][k]=-1;\n      }\n    t=0;\n    r=GetNum(c);\n    me[y][x][r]=t;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(l==t) break;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      r=GetNum(c);\n      if(me[y][x][r]!=-1&&t-me[y][x][r]!=0) t=l-((l-me[y][x][r])%(t-me[y][x][r]));\n      me[ny][nx][r]=t;\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}\n\nint GetNum(char c){\n  if(c=='N') return 0;\n  if(c=='E') return 1;\n  if(c=='S') return 2;\n  return 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 110\n#define MAX_W 110\n\nint H,W,L;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nchar getDir(int x){\n  if(x == 0){ return 'W'; }\n  if(x == 1){ return 'N'; }\n  if(x == 2){ return 'E'; }\n  if(x == 3){ return 'S'; }\n  return '#';\n}\n\nint getDir(char ch){\n  if(ch == 'W'){\n    return 0;\n  }else if(ch == 'N'){\n    return 1;\n  }else if(ch == 'E'){\n    return 2;\n  }else{\n    return 3;\n  }\n}\n\nbool inField(int x,int y){\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid solve(int x,int y,int dir){\n  int d[MAX_H][MAX_W][4];\n  memset(d,-1,sizeof(d));\n  d[y][x][dir] = 0;\n  bool ok = false;\n  \n  while(true){\n    if(L == 0){ break; }\n    int nx = x + dx[dir],ny = y + dy[dir];\n    if(!inField(nx,ny) || field[ny][nx] == '#'){\n      int ndir = (dir + 1) % 4;\n      if(d[y][x][ndir] == -1){\n        d[y][x][ndir] = d[y][x][dir];\n      }else{\n        int diff = d[y][x][dir]-d[y][x][ndir];\n        if(diff > 0 && L >= diff){\n          L %= diff;\n          ok = true;\n        }\n      }\n      dir = ndir;\n    }else{\n      if(d[ny][nx][dir] == -1){\n        d[ny][nx][dir] = d[y][x][dir]+1;\n        L--;\n      }else{\n        int diff = d[y][x][dir]+1-d[ny][nx][dir];\n        if(diff > 0 && L >= diff && !ok){\n          L %= diff;\n          ok = true;\n        }else{\n          L--;\n        }\n      }\n      x = nx; y = ny;\n    }\n  }\n  cout << y+1 << \" \" << x+1 << \" \" << getDir(dir) << endl;\n}\n\nbool check(char ch){\n  if(ch == '.' || ch == '#'){\n    return false;\n  }\n  return true;\n}\n\nint main(){\n  int sx,sy,dir;\n  while(true){\n    cin >> H >> W >> L;\n    if(H == 0 && W == 0 && L == 0){\n      break;\n    }\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(check(field[i][j])){\n          sx = j; sy = i;\n          dir = getDir(field[i][j]);\n          field[i][j] = '.';\n        }\n      }\n    }\n    solve(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        int count = 0;\n        string wall = \"\";\n        bool used[101][101][4];\n        fill_n((bool *)used, 101*101, false);\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n            }\n        }\n\n        int sx, sy, sdir;\n        sx = x;\n        sy = y;\n        sdir = dir;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n                if (used[y][x][dir]) {\n                    l = l/count + l%count;\n                }\n                used[y][x][dir] = true;\n            }\n            else\n                dir = (dir+1) % 4;\n        }\n        cout << y << \" \" << x << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(long long h,w,l;cin>>h>>w>>l,h|w|l;){\n    bool s[102][102]={};\n    int x,y,d;\n    string ds=\"NESW\";\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tchar c;\n\tcin>>c;\n\ts[i][j]=c!='#';\n\tif(c!='#'&&c!='.'){\n\t  x=j;\n\t  y=i;\n\t  d=ds.find(c);\n\t}\n      }\n    }\n    long long p[102][102][4];\n    fill(p[0][0],p[102][0],-1);\n    for(;;){\n      int dx[]={0,1,0,-1};\n      int dy[]={-1,0,1,0};\n      while(l--){\n\tif(p[y][x][d]!=-1){\n\t  l=l%(p[y][x][d]-l)+(p[y][x][d]-l);\n\t}\n\tp[y][x][d]=l;\n\tif(s[y+dy[d]][x+dx[d]])break;\n\td=(d+1)%4;\n      }\n      y+=dy[d];\n      x+=dx[d];\n      l--;\n    }\n  end:\n    cout<<y<<' '<<x<<' '<<ds[d]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct State{\n  ll x, y;\n  char d;\n};\n\nchar field[110][110];\nint H, W, L;\nvector<State> v;\nState pos;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nchar dn[] = {'N', 'E', 'S', 'W'};\n\nint Ls;\n\nbool isVisited(State s){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].x == s.x && v[i].y == s.y && v[i].d == s.d){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nState solve(){\n  v.push_back(pos);\n\n  int cnt = 0;\n  int dir;\n  for(int i = 0 ; i < 4 ; i++){\n    if(dn[i] == pos.d) dir = i;\n  }\n  \n  while(true){\n    int nx = pos.x + dx[dir];\n    int ny = pos.y + dy[dir];\n    \n    if(field[ny][nx] == '#' || nx < 0 || nx >= W || ny < 0 || ny >= H){\n      dir = (dir+1) % 4;\n      continue;\n    }\n    pos.y = ny, pos.x = nx, pos.d = dn[dir];\n    cnt++;\n    if(isVisited(pos)) break;\n\n    v.push_back(pos);\n    if(cnt == L) return pos;\n  }\n  \n  ll remain = L - cnt;\n  ll cycle_len = v.size() - Ls;\n  remain %= cycle_len;\n  return v[Ls+remain];\n  //cout << \"L = \" << L << endl;\n  //cout << \"cycle_len = \" << cycle_len << endl;\n  //cout << \"remain = \" << remain << endl;\n  //cout << \"Ls = \" << Ls << endl;\n}\n\nvoid init(){\n  v.clear();\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    init();\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> field[i][j];\n\tif(isalpha(field[i][j])) pos.x = j, pos.y = i, pos.d = field[i][j];\n      }\n    }\n    \n    State ans = solve();\n    cout << ans.y+1 << ' ' << ans.x+1 << ' ' << ans.d << endl;\n    /*\n    for(int i = 0 ; i < v.size() ; i++){\n      cout << i << \": \" << \"x = \" << v[i].x+1 << \", y = \" << v[i].y+1 << \", d = \" << v[i].d << endl;\n    }\n    cout << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst string dirs = \"NESW\";\nconst int dy[4] = {-1, 0, 1, 0};\nconst int dx[4] = {0, 1, 0, -1}; \nint H, W;\nll L;\nstring c[110];\nint dist[110][110][4];\n\nbool contain(int y, int x) {\n  return y >= 0 && y < H && x >= 0 && x < W;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> H >> W >> L, H) {\n    for (int i = 0; i < H; i++) {\n      cin >> c[i];\n    }\n\n    int y, x, d;\n    fill_n((int*)dist, 110 * 110 * 4, -1);\n    using P = tuple<int, int, int>;\n    vector<P> ps;\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        auto pos = dirs.find(c[i][j]);\n        if (pos == string::npos) continue;\n        y = i; x = j; d = pos;\n        dist[y][x][d] = 0;\n        ps.emplace_back(y, x, d);\n      }\n    }\n\n    while (true) {\n      int ny, nx, nd;\n      ny = y + dy[d]; nx = x + dx[d]; nd = d;\n      if (!contain(ny, nx) || c[ny][nx] == '#') {\n        ny = y; nx = x; nd = (d + 1) % 4;\n      }\n      ps.emplace_back(ny, nx, nd);\n      if (dist[ny][nx][nd] < 0) {\n        dist[ny][nx][nd] = dist[y][x][d] + (nd == d);\n        y = ny; x = nx; d = nd;\n      } else {\n        break;\n      }\n    }\n    \n    int ay = -1, ax = -1, ad = -1;\n    for (int i = 0; i < (int)ps.size(); i++) {\n      tie(y, x, d) = ps[i];\n      if (dist[y][x][d] < L) continue;\n      ay = y; ax = x; ad = d;\n      break;\n    }\n    if (!(ay < 0)) {\n      cout << ay + 1 << \" \" << ax + 1 << \" \" << dirs[ad] << endl;\n      continue;\n    }\n    ps.erase(ps.begin(), find(ps.begin(), ps.end(), *prev(ps.end())));\n    int gy, gx, gd;\n    tie(gy, gx, gd) = *prev(ps.end());\n    auto it = ps.begin();\n    while (true) {\n      tie(y, x, d) = *it;\n      if (y != gy || x != gx) {\n        ps.erase(ps.begin(), it);\n        break;\n      }\n      it++;\n    }\n    vector<P> nps;\n    int pos = 0;\n    while (pos < (int)ps.size()) {\n      tie(y, x, d) = ps[pos];\n      nps.emplace_back(ps[pos++]);\n      while (pos < (int)ps.size()) {\n        int ny, nx, nd;\n        tie(ny, nx, nd) = ps[pos];\n        if (ny != y || nx != x) break;\n        pos++;\n      }\n    }\n    int T = nps.size();\n    tie(ay, ax, ad) = nps[(L - dist[gy][gx][gd] + T - 1) % T];\n    cout << ay + 1 << \" \" << ax + 1 << \" \" << dirs[ad] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define MAX 1000\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[MAX][MAX];\nint visited[MAX][MAX][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      assert(H <= 100);\n      assert(W <= 100);\n      assert(L <= 1000000000000000000LL);\n\n\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,line.size())\n\t    {\n\t      assert(j < W);\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {   \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <cstdio>\n\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,a) repi(i,0,a)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint H, W;\nll L;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\nbool inrange(int x, int y){ return x >= 0 && x < W && y >= 0 && y < H;}\n\nint main(){\n    while(cin >> H >> W >> L, H || W || L){\n        vector<string> maze(H);\n        rep(i,H) cin >> maze[i];\n        int x, y, dir;\n        rep(i,H)rep(j,W){\n            if(maze[i][j] == 'W'){ dir = 0; x = j; y = i; break;}\n            else if(maze[i][j] == 'N'){ dir = 1; x = j; y = i; break;}\n            else if(maze[i][j] == 'E'){ dir = 2; x = j; y = i; break;}\n            else if(maze[i][j] == 'S'){ dir = 3; x = j; y = i; break;}\n        }\n        int field[128][128][4];\n        memset(field,-1,sizeof(field));\n        field[y][x][dir] = 0;\n        ll turn = 1;\n        bool rooped = false;\n        while(turn <= L){\n            int nx, ny, ndir;\n            rep(i,4){\n                ndir = (dir+i)%4;\n                nx = x + dx[ndir];\n                ny = y + dy[ndir];\n                if(inrange(nx, ny) && maze[ny][nx] != '#'){\n                    x = nx; y = ny; dir = ndir;\n                    break;\n                }\n            }\n            if(!rooped && field[y][x][dir] >= 0){\n                rooped = true;\n                ll roop = turn - field[y][x][dir];\n                turn += (L - turn) / roop * roop;\n                turn++;\n            }\n            else{\n                field[y][x][dir] = turn;\n                turn++;\n            }\n        }\n        cout << y+1 << ' ' << x+1 << ' ';\n        cout << (dir==0? 'W': dir==1? 'N': dir==2? 'E': 'S') << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstruct State{\n    int h,w,dir;\n};\n\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nmap<char,int> dmp={{'N',0},{'E',1},{'S',2},{'W',3}};\nstring dmpi=\"NESW\";\n\nvoid out(State st){\n    cout<<st.h<<\" \"<<st.w<<\" \"<<dmpi[st.dir]<<endl;\n}\n\n\nint solve(int H,int W,int L){\n    vector<string> f(H+2);\n    for(int i=0;i<W+2;i++){\n        f[0]+=\"#\";\n        f[H+1]+=\"#\";\n    }\n    State ini;\n    for(int i=0;i<H;i++){\n        cin>>f[i+1];\n        f[i+1]=\"#\"+f[i+1]+\"#\";\n        for(int j=0;j<W+2;j++){\n            if(dmp.count(f[i+1][j])){\n                ini=State{i+1,j,dmp[f[i+1][j]]};\n            }\n        }\n    }\n\n    vector<vector<vector<int>>> dp(H+2,vector<vector<int>>(W+2,vector<int>(4,-1)));\n    int lps=0;\n    State st=ini;\n    int cnt=0;\n    queue<State> que;\n    while(true){\n        if(cnt==L){\n            out(st);\n            return 0;\n        }\n        if(dp[st.h][st.w][st.dir]!=-1){\n            lps=cnt-dp[st.h][st.w][st.dir];\n            break;\n        }\n        dp[st.h][st.w][st.dir]=cnt;\n        if(f[st.h+dh[st.dir]][st.w+dw[st.dir]]=='#'){\n            st.dir=(st.dir+1)%4;\n            continue;\n        }\n        st.h+=dh[st.dir];\n        st.w+=dw[st.dir];\n        que.push(st);\n        cnt++;\n    }\n    L-=cnt+1;\n    vector<State> lpv;\n    while(que.size()>lps) que.pop();\n    while(!que.empty()) lpv.push_back(que.front()),que.pop();\n    L%=lps;\n    out(lpv[L]);\n    return 0;\n}\nint main(){\n    int H,W,L;\n    while(cin>>H>>W>>L,H){\n        solve(H,W,L);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 110\n#define MAX_W 110\ntypedef long long ll;\n\nll H,W,L;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nchar getDir(int x){\n  if(x == 0){ return 'W'; }\n  if(x == 1){ return 'N'; }\n  if(x == 2){ return 'E'; }\n  if(x == 3){ return 'S'; }\n  return '#';\n}\n\nint getDir(char ch){\n  if(ch == 'W'){\n    return 0;\n  }else if(ch == 'N'){\n    return 1;\n  }else if(ch == 'E'){\n    return 2;\n  }else{\n    return 3;\n  }\n}\n\nbool inField(int x,int y){\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid solve(int x,int y,int dir){\n  int d[MAX_H][MAX_W][4];\n  memset(d,-1,sizeof(d));\n  d[y][x][dir] = 0;\n  \n  while(true){\n    if(L == 0){ break; }\n    int nx = x + dx[dir],ny = y + dy[dir];\n    if(!inField(nx,ny) || field[ny][nx] == '#'){\n      int ndir = (dir+1) % 4;\n      if(d[y][x][ndir] == -1){\n        d[y][x][ndir] = d[y][x][dir];\n      }else{\n        int diff = d[y][x][dir]-d[y][x][ndir];\n        if(diff > 0 && L >= diff){\n          L %= diff;\n        }\n      }\n      dir = ndir;\n    }else{\n      if(d[ny][nx][dir] == -1){\n        d[ny][nx][dir] = d[y][x][dir]+1;\n        L--;\n      }else{\n        int diff = d[y][x][dir]+1-d[ny][nx][dir];\n        if(diff > 0 && L >= diff){\n          L %= diff;\n        }else{\n          L--;\n        }\n      }\n      x = nx; y = ny;\n    }\n  }\n  cout << y+1 << \" \" << x+1 << \" \" << getDir(dir) << endl;\n}\n\nbool check(char ch){\n  if(ch == '.' || ch == '#'){\n    return false;\n  }\n  return true;\n}\n\nint main(){\n  int sx,sy,dir;\n  while(true){\n    cin >> H >> W >> L;\n    if(H == 0 && W == 0 && L == 0){\n      break;\n    }\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(check(field[i][j])){\n          sx = j; sy = i;\n          dir = getDir(field[i][j]);\n          field[i][j] = '.';\n        }\n      }\n    }\n    solve(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint field_cnt[100][100][4];\nchar field[100][100];\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring ds = \"NESW\";\n\nint main() {\n  int h, w, n;\n  int x, y, way;\n  while(cin>>h>>w>>n,h|w|n){\n    fill_n((int *)field_cnt, 100*100*4, -1);\n    int way = 0;\n    REP(iy, h){\n      REP(ix, w){\n        cin >> field[iy][ix];\n        char c = field[iy][ix];\n        switch(c){\n          case 'W':\n          way++;\n          case 'S':\n          way++;\n          case 'E':\n          way++;\n          case 'N':\n          x = ix;\n          y = iy;\n        }\n      }\n    }\n    int cnt = 0;\n    while(n>0){\n      // LOG (\"%d -- %d %d %c\\n\",n,y,x,ds[way]);\n      if(field_cnt[y][x][way] != -1){\n        if (n < cnt - field_cnt[y][x][way]){\n        }else{\n          n %= cnt - field_cnt[y][x][way];\n          if(n==0)break;\n          n++;\n        }\n      }\n      n--;\n      field_cnt[y][x][way] = cnt;\n      int nx = x + dx[way];\n      int ny = y + dy[way];\n      while(nx<0 || ny<0 || nx>=w || ny>=h || field[ny][nx] == '#'){\n        way= (way+1)%4;\n        nx = x + dx[way];\n        ny = y + dy[way];\n      }\n      y = ny;\n      x = nx;\n      cnt++;\n    }\n    printf (\"%d %d %c\\n\",y+1,x+1,ds[way]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {1,0,-1,0};\nconst static int ty[] = {0,1,0,-1};\nconst static char dir_char[] = {'E','S','W','N'};\n \nenum dir {\n  EAST,\n  SOUTH,\n  WEST,\n  NORTH\n};\n\nstatic const double EPS = 1e-8;\n\nvoid printStage(char stage[100][100],int H,int W,\n\t\tint current_x,int current_y,int current_dir){\n\n  char output[100][100];\n\n  //init\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      output[y][x] = '.';\n    }\n  }\n\n  //wall\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(stage[y][x] == '#'){\n\toutput[y][x] = '#';\n      }\n    }\n  }\n\n  //robot\n  output[current_y][current_x] = dir_char[current_dir];\n\n  //write\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      printf(\"%c\",output[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int H,W,L;\n  while(~scanf(\"%d %d %d\",&H,&W,&L)){\n    if(H == 0 && W == 0 && L == 0) break;\n\n    char stage[100][100];\n\n    int current_dir = NORTH;\n    int current_x = 0;\n    int current_y = 0;\n\n    for(int y=0;y<H;y++){\n      char line[120];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] == 'E'){\n\t  current_dir = EAST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'S'){\n\t  current_dir = SOUTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'W'){\n\t  current_dir = WEST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'N'){\n\t  current_dir = NORTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n      }\n    }\n\n    while(L-- > 0){\n      int dx = current_x + tx[current_dir];\n      int dy = current_y + ty[current_dir];\n\n      // printStage(stage,H,W,current_x,current_y,current_dir);\n      // cout << dx << \" \" << dy << \" \" << endl;\n      if(dy < 0 || dy >= H || dx < 0 || dx >= W){\n\tcurrent_dir = (current_dir + 1) % 4;\n\tL++;\n\tcontinue;\n      }\n      else if(stage[dy][dx] == '#'){\n\tcurrent_dir = (current_dir + 1) % 4;\n\tL++;\n\tcontinue;\n      }\n      current_x = dx;\n      current_y = dy;\n    }\n    printf(\"%d %d %c\\n\",current_y+1,current_x+1,dir_char[current_dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1}, H, W;\nstring dir[] = {\"N\",\"E\",\"S\",\"W\"};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nstring dfs(vector<string> &C, vector< vector< vector<long long int> > > &T,\n           int x, int y, long long int l, int d){\n  string ret = \"!\";\n  while(ret == \"!\"){\n    if(T[x][y][d] > 0){\n      l %= (T[x][y][d]-l);\n    }else{\n      T[x][y][d] = l;\n    }\n    \n    if(l == 0){\n      ret = to_string(x+1) + \" \" + to_string(y+1) + \" \" + dir[d];\n    }\n  \n    for(int i = 0; i < 4; ++i){\n      int d_ = (d+i)%4, x_ = x + dx[d_], y_ = y + dy[d_];\n      //--l;\n      if(in_range(x_,H) && in_range(y_,W) && C[x_][y_] != '#'){\n        x = x_;\n        y = y_;\n        --l;\n        d = d_;\n        break;\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  long long L;\n  while(cin >> H >> W >> L, H){\n    vector<string> C(H);\n    int s_x, s_y, d;\n    for(int i = 0; i < H; ++i){\n      cin >> C[i];\n      for(int j = 0; j < W; ++j){\n        if(C[i][j] != '.' && C[i][j] != '#'){\n          s_x = i;\n          s_y = j;\n          if(C[i][j] == 'N') d = 0;\n          if(C[i][j] == 'E') d = 1;\n          if(C[i][j] == 'S') d = 2;\n          if(C[i][j] == 'W') d = 3;\n        }\n      }\n    }\n    vector< vector< vector<long long int> > > T(H,vector< vector<long long int> >(W,vector<long long int>(4,-1ll)));\n\n    cout << dfs(C,T,s_x,s_y,L,d) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nbool passed[101][101][4];\nchar field[101][101];\n\nint h,w;\nll l;\nint sy,sx,sag;\n\n// loopð©Â¯éÜÅTõ\nbool search1(ll &cl,int &cx,int &cy,int &cag,int &step){\n\tpassed[cy][cx][cag]=true;\n\twhile(1){\n\t\t// Ú®I¹\n\t\tif(cl==0){\n\t\t\tcout<<cy+1<<\" \"<<cx+1<<\" \";\n\t\t\tif(cag==0)cout<<'N';\n\t\t\telse if(cag==1)cout<<'E';\n\t\t\telse if(cag==2)cout<<'S';\n\t\t\telse if(cag==3)cout<<'W';\n\t\t\tcout<<endl;\n\t\t\treturn true;\n\t\t}\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\t// Ú®Â\\©\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\t// ·ÅÉÊßÏÝ©\n\t\t\tif(passed[ny][nx][cag]){\n\t\t\t\tcx=nx,cy=ny;\n\t\t\t\tcl--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassed[ny][nx][cag]=true;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tcl--;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\t// ÊßÏÝ\n\t\t\tif(passed[cy][cx][cag])break;\n\t\t\tpassed[cy][cx][cag]=true;\n\t\t}\n\t}\n\tint gx=cx;\n\tint gy=cy;\n\tint gag=cag;\n\t// Ü¾S[µÄ¢È¢\n\t// [vð¦é\n\tint cnt=0;\n\twhile(1){\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\tcnt=0;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tstep++;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\tcnt++;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag){\n\t\t\t\t// cntª³¾Á½êA-cntµ½àÌðü«ÉZbgµÄ¨­\n\t\t\t\tcag=(cag-cnt+4)%4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n// [vð©Â¯éÜÅTõ.©Â¯½çA»Ì[vÌå«³ð¦é\nvoid solve(){\n\t// loop find\n\tint cx,cy,cag,step;\n\tstep=0;\n\tll cl=l;\n\tcx=sx;\n\tcy=sy;\n\tcag=sag;\n\t// [vBOÉS[\n\tmemset(passed,0,sizeof(passed));\n\tif(search1(cl,cx,cy,cag,step))return;\n\t// [vÉüÁ½ê,loopÌstepªclð¸ç·\n\tcl%=step;\n\tstep=0;\n\t// cèÌXebvÅS[\n\tmemset(passed,0,sizeof(passed));\n\tsearch1(cl,cx,cy,cag,step);\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>l&&!(h==0&&w==0&&l==0)){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!='#'&&field[i][j]!='.'){\n\t\t\t\t\tif(field[i][j]=='N')sag=0;\n\t\t\t\t\telse if(field[i][j]=='E')sag=1;\n\t\t\t\t\telse if(field[i][j]=='S')sag=2;\n\t\t\t\t\telse if(field[i][j]=='W')sag=3;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x,cnt;\n    State(int dir,int y,int x,int cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    int d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            int diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            int t=(L-s.cnt)/diff;\n            t*=diff;\n            s.cnt+=t;\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            d[(s.dir+1)%4][s.y][s.x]=s.cnt;\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                d[(s.dir+1)%4][s.y][s.x]=s.cnt;\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                d[s.dir][ny][nx]=s.cnt+1;\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) while(1){}\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nll h, w, l, d[100][100][4], x, y, di, m;\nstring s[100];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> l;\n\t\tif (h==0) break;\n\t\trep(i,h) {\n\t\t\tcin >> s[i];\n\t\t\trep(j,w) if (s[i][j]!='.' && s[i][j]!='#') {\n\t\t\t\t\tx = i, y = j;\n\t\t\t\t\tif (s[i][j]=='E') di = 0;\n\t\t\t\t\telse if (s[i][j]=='S') di = 1;\n\t\t\t\t\telse if (s[i][j]=='W') di = 2;\n\t\t\t\t\telse di = 3;\n\t\t\t\t}\n\t\t}\n\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k] = inf;\n\t\td[x][y][di] = 0;\n\t\tm = 0;\n\t\twhile (1) {\n\t\t\tif (m==l) break;\n\t\t\tif (d[x][y][di]<m) {\n\t\t\t\tl -= m;\n\t\t\t\tl %= m-d[x][y][di];\n\t\t\t\tm = 0;\n\t\t\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k] = inf;\n\t\t\t\td[x][y][di] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint xx = x + dx[di], yy = y + dy[di];\n\t\t\tif (ool(xx,yy,h,w) || s[xx][yy]=='#') di++, di %= 4;\n\t\t\telse {\n\t\t\t\tx = xx, y = yy;\n\t\t\t\tm++;\n\t\t\t\tif (d[x][y][di]>m) d[x][y][di] = m;\n\t\t\t}\n\t\t}\n\t\tstring t = \"ESWN\";\n\t\tcout << x+1 << ' ' << y+1 << ' ' << t[di] << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, T b) {\n    if(b<a) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nll H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x;\n    ll cnt;\n    State(int dir,int y,int x,ll cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    ll d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            //printf(\"%d %d %d : %d %d\\n\",s.dir,s.y,s.x,s.cnt,d[s.dir][s.y][s.x]);\n            int diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            int t=(L-s.cnt)/diff;\n            if(t>0&&diff>0) {\n                s.cnt+=(t-1)*diff;\n            }\n            //printf(\"\\t%d\\n\",s.cnt);\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                chmin(d[s.dir][ny][nx],s.cnt+1);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) int a=1/0;\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nint h,w;\nint x,y,dir;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring mp[101],str=\"NESW\";;\nll n;\n\nvoid solve(){\n  ll dis[4][101][101],cost=0;\n  memset(dis,-1,sizeof(dis));\n\n  while(n!=0){\n    if(dis[dir][y][x]!=-1&&n%(cost-dis[dir][y][x])!=0){\n      n%=(cost-dis[dir][y][x]);\n      memset(dis,-1,sizeof(dis));\n    }\n\n    dis[dir][y][x]=cost;\n    \n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#'){\n      x-=dx[dir];\n      y-=dy[dir];\n      dir=(dir+1)%4;\n    }\n    else n--,cost++;\n  }\n  cout <<y+1<<\" \"<<x+1<<\" \"<<str[dir]<<endl;\n}\n\n\nint main(){\n  while(1){\n    cin >>h>>w>>n;\n    if(!h&&!w&&!n)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<mp[i].size();j++)\n\tif(mp[i][j]!='.'&&mp[i][j]!='#'){\n\t  x=j,y=i;\n\t  if(mp[i][j]=='N')dir=0;\n\t  if(mp[i][j]=='E')dir=1;\n\t  if(mp[i][j]=='S')dir=2;\n\t  if(mp[i][j]=='W')dir=3;\n\t}\n\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int NORTH = 0;\nconst int EAST = 1;\nconst int SOUTH = 2;\nconst int WEST = 3;\n\nstruct state{\n  int x, y, d;\n  state(){}\n  state(int x, int y, int d):x(x),y(y),d(d){}\n  bool operator == (const state& s) const {\n    return x==s.x&&y==s.y&&d==s.d;\n  }\n};\nvector<state> V;\n\nchar field[MAX][MAX];\nbool come[MAX][MAX][4];\nint W,H,L;\nstate src;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nstring dir = \"NESW\";\n\nvoid init(){\n  memset(come,false,sizeof(come));\n  V.clear();\n}\n\nvoid printFF(){\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++) cout << field[i][j];\n    cout << endl;\n  }\n}\nvoid input(){\n\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++){\n      cin >> field[i][j];\n      for(int k = 0; k < (int)dir.length(); k++)\n\tif(field[i][j] == dir[k]) src = state(j,i,k);\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<W&&0<=y&&y<H;}\n\nstate step(const state s){\n  for(int i = 0; i < 4; i++){\n    state nex = s;\n    nex.d = (nex.d+i)%4;\n    nex.x += dx[nex.d];\n    nex.y += dy[nex.d];\n    if(!isInside(nex.x, nex.y) || field[nex.y][nex.x] == '#') continue;\n    return nex;\n  }\n  //  assert(false);\n  return s;\n}\n\nvoid print(const vector<state>& v) {\n  for(int i = 0; i < (int)v.size(); i++){\n    cout << v[i].x << \" \" << v[i].y << \" \" << v[i].d << endl;\n  }\n  cout << endl;\n}\n\nvector<state> makeMaze(const vector<state> &v,state now){\n  vector<state> ret;\n  bool f = false;\n  for(int i = 0; i < (int)v.size(); i++){\n    if(v[i] == now) f = true;\n    if(f) ret.push_back(v[i]);\n  }\n  return ret;\n}\n\n\nvoid TEST(){\n  if(W == 5 && H == 4){\n    state sss = step(state(4,2,2));\n    cout << sss.x << \" \" << sss.y << \" \" << sss.d << endl;\n    cout << isInside(1,4) << \" \" << field[4][1] << endl;\n  }\n}\n\nvoid solve(){\n\n  //  TEST();\n  //return;\n  int rem = L;\n  state now = src;\n  V.push_back(src);\n  come[now.y][now.x][now.d] = true;\n  \n  while(1){\n    now = step(now);\n    if(come[now.y][now.x][now.d]){\n      rem--;\n      V = makeMaze(V,now);\n      break;\n    }\n    come[now.y][now.x][now.d] = true;\n    V.push_back(now);\n    rem--;\n    if(rem == 0){\n      cout << now.y+1 << \" \" << now.x+1 << \" \" << dir[now.d] << endl;\n      return;\n    }\n  }\n  \n  // print(V);\n  rem %= V.size();\n  cout << V[rem].y+1 << \" \" << V[rem].x+1 << \" \" << dir[V[rem].d] << endl;\n}\n\n\nint main(){\n  \n  while(cin >> H >> W >> L && W+H+L){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nint h, w, x, y, d;\nll n;\nll dp[102][102][4];\nchar t[102][102];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nchar str[] = \"NESW\";\n\nvoid walk(){\n  for(int i = 0; i < 4; i++){\n    int nd = (d + i) % 4;\n    int nx = x + dx[nd];\n    int ny = y + dy[nd];\n\n    if(0 <= nx && nx < w && 0 <= ny && ny < h && t[ny][nx] == '.'){\n      x = nx;\n      y = ny;\n      d = nd;\n      return;\n    }\n  }\n}\n\nvoid solve(){\n  ll cnt = 0;\n  memset(dp, -1, sizeof(dp));\n\n  while(dp[x][y][d] == -1 && cnt < n){\n    dp[x][y][d] = cnt;\n    walk();\n    cnt++;\n  }\n\n  if(cnt == n) return;\n\n  ll rem = (n - dp[x][y][d]) % (cnt - dp[x][y][d]);\n\n  while(rem--){\n    walk();\n  }\n}\n\nint main(){\n  while(cin >> h >> w >> n, h || w || n){\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n\n      for(int j = 0; j < w; j++){\n        if(t[i][j] != '.' && t[i][j] != '#'){\n          if(t[i][j] == 'N') d = 0;\n          else if(t[i][j] == 'E') d = 1;\n          else if(t[i][j] == 'S') d = 2;\n          else if(t[i][j] == 'W') d = 3;\n\n          x = j;\n          y = i;\n          t[i][j] = '.';\n        }\n      }\n    }\n\n    solve();\n\n    cout << y + 1 << \" \" << x + 1 << \" \" << str[d] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\nusing namespace std;\nchar G[105][105];\nint vis[105][105][4];\nint dy[4]={0,1,0,-1};\nint dx[4]={-1,0,1,0};\nchar df[4]={'N','E','S','W'};\nint h,w,l;\nbool pd(int x,int y)\n{\n    if(x<1||x>h||y<1||y>w)  return false;\n    else if(G[x][y]=='#')   return false;\n    else\n        return true;\n}\nint main()\n{\n   // freopen(\"in.txt\",\"r\",stdin);\n    int x,y,f;\n    while(scanf(\"%d%d%d\",&h,&w,&l)!=EOF)\n    {\n        if(h==0&&w==0&&l==0)    break;\n        memset(vis,-1,sizeof(vis));\n\n        for(int i=1;i<=h;i++)\n        {\n            scanf(\"%s\",G[i]+1);\n            for(int j=1;j<=w;j++)\n            {\n                if(G[i][j]=='N')    {x=i;y=j;f=0;}\n                else if(G[i][j]=='E') {x=i;y=j;f=1;}\n                else if(G[i][j]=='S') {x=i;y=j;f=2;}\n                else if(G[i][j]=='W') {x=i;y=j;f=3;}\n            }\n        }\n\n        vis[x][y][f]=0;\n        int t=0;\n       // cout<<x<<\" \"<<y<<\" \"<<df[f]<<endl;\n       int ok=1;\n        while(1)\n        {\n            if(l<=0)\n            {\n                printf(\"%d %d %c\\n\",x,y,df[f]);\n                //cout<<endl<<endl;\n                break;\n            }\n\n            if(!pd(x+dx[f],y+dy[f]))\n            {\n                //cout<<\"テ猟ェテ催、\"<<x<<\" \"<<y<<\" \"<<f<<\"-\";\n                f=(f+1)%4;\n                //cout<<f<<endl;\n                continue;\n            }\n\n            l--;\n           // cout<<x<<\" \"<<y<<endl;\n            x=x+dx[f];\n            y=y+dy[f];\n            //cout<<x<<\" \"<<y<<\" \"<<df[f]<<endl;\n            t++;\n            if(vis[x][y][f]!=-1 &&ok)\n            {\n                //cout<<\"x\"<<l<<endl;\n                l=l%(t-vis[x][y][f]);\n\n                ok=0;\n                continue;\n            }\n\n            vis[x][y][f]=t;\n            //cout<<l<<endl;\n\n\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\n//ind -> V から V->ind (注:単射)\ntemplate<typename T>\nmap<T,int> rev(const vector<T>& xs){\n\tmap<T,int> rev;\n\tREP(i,(int)xs.size())rev.insert(make_pair(xs[i],i));\n\treturn rev;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nint H,W;\n\nstruct State{\n\tint y,x,d;\n\tState(int y,int x,int d):y(y),x(x),d(d){};\n};\n\nint enc(int y,int x,int d){\n\treturn (y*W+x)*4+d;\n}\nchar encD(int d){\n\tif(d==0)return 'E';\n\tif(d==1)return 'S';\n\tif(d==2)return 'W';\n\tif(d==3)return 'N';\n\treturn '_';\n}\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint main(){\n\n\twhile(true){\n\t\tll L;cin >> H >> W >> L;\n\t\tif(H==0)break;\n\t\tvector<string> map(H);\n\t\tREP(y,H)cin >> map[y];\n\n\t\tint py,px,d;\n\t\tREP(y,H)REP(x,W){\n\t\t\tif(map[y][x]=='E'){\n\t\t\t\tpy=y;px=x;d=0;break;\n\t\t\t}\n\t\t\tif(map[y][x]=='S'){\n\t\t\t\tpy=y;px=x;d=1;break;\n\t\t\t}\n\t\t\tif(map[y][x]=='W'){\n\t\t\t\tpy=y;px=x;d=2;break;\n\t\t\t}\n\t\t\tif(map[y][x]=='N'){\n\t\t\t\tpy=y;px=x;d=3;break;\n\t\t\t}\n\t\t}\n\t\tvector<bool> pass(H*W*4);\n\t\tvector<State> ss;\n\t\n\t\tfor(int l=0;true;l++){\n\t\t\tif(l==L){\n\t\t\t\tcout<< (py+1)<<\" \"<<(px+1)<<\" \"<<encD(d)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(pass[enc(py,px,d)]){//loop check\n\t\t\t\tint li=-1;\n\t\t\t\tREP(i,ss.size()){\n\t\t\t\t\tif(enc(ss[i].y,ss[i].x,ss[i].d)==enc(py,px,d)){\n\t\t\t\t\t\tli=i;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//L=li+(l-li)*k+r\n\t\t\t\tint res=(L-li)%(l-li)+li;\n\t\t\t\tcout<<(ss[res].y+1)<<\" \"<<(ss[res].x+1)<<\" \"<<encD(ss[res].d)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass[enc(py,px,d)]=true;\n\t\t\tss.push_back(State(py,px,d));\n\n\t\t\t//move\n\t\t\tfor(int c=0;c<4;c++){\n\t\t\t\tint nx=px+dx[d],ny=py+dy[d];\n\t\t\t\tif(!IN(0,nx,W)  || !IN(0,ny,H)){\n\t\t\t\t\td=(d+1+4)%4;continue;\n\t\t\t\t}\n\t\t\t\tif(map[ny][nx]=='#'){\n\t\t\t\t\td=(d+1+4)%4;continue;\n\t\t\t\t}\n\t\t\t\tpx=nx;py=ny;break;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// N, E, S, W\nint dx[4] = {-1, 0,  1,  0};\nint dy[4] = { 0, 1,  0, -1};\n\nmap<char, int> mpdir = {\n    {'N', 0},\n    {'E', 1},\n    {'S', 2},\n    {'W', 3}\n};\n\nstring dir = \"NESW\";\n\nstruct State {\n    int x, y, d;\n    State() {}\n    State(int _x, int _y, int _d) : x(_x), y(_y), d(_d) {}\n    bool operator== (const State& state) const {\n        return x == state.x && y == state.y && d == state.d;\n    }\n    bool operator!= (const State& state) const {\n        return !(*this == state);\n    }\n    bool operator< (const State& state) const {\n        return x == state.x ? (y == state.y ? d < state.d : y < state.y) : x < state.x;\n    }\n\n    void print() {\n        cout << x + 1 << \" \" << y + 1 << \" \" << dir[d] << endl;\n    }\n};\n\nint H, W, L;\nvector<string> s;\nvector<State> v;\nset<State> st;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> H >> W >> L, H) {\n        s.clear();\n        s.resize(H);\n        v.clear();\n        st.clear();\n\n        State state;\n        rep(i, H) {\n            cin >> s[i];\n            rep(j, W) {\n                if (isalpha(s[i][j])) {\n                    state.x = i;\n                    state.y = j;\n                    state.d = mpdir[s[i][j]];\n                }\n            }\n        }\n\n        rep(t, 50000) {\n            if (st.count(state) != 0) {\n                int offset;\n                for(offset = 0; v[offset] != state; offset++) {\n                    assert(offset < v.size());\n                }\n\n                int last_id = L;\n                if (last_id >= offset) {\n                    int T = t - offset;\n                    last_id = (L - offset) % T + offset;\n                }\n\n                v[last_id].print();\n                break;\n            }\n\n            v.emplace_back(state);\n            st.insert(state);\n\n            while (!inside(state.x + dx[state.d], state.y + dy[state.d]) || s[state.x + dx[state.d]][state.y + dy[state.d]] == '#') {\n                state.d = (state.d + 1) % 4;\n            }\n\n            state.x += dx[state.d];\n            state.y += dy[state.d];\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct State{\n  ll x, y;\n  char d;\n};\n\nchar field[110][110];\nint H, W, L;\nvector<State> v;\nState pos;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nchar dn[] = {'N', 'E', 'S', 'W'};\n\nint Ls;\n\nbool isVisited(State s){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].x == s.x && v[i].y == s.y && v[i].d == s.d){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nState solve(){\n  v.push_back(pos);\n\n  int cnt = 0;\n  int dir;\n  for(int i = 0 ; i < 4 ; i++){\n    if(dn[i] == pos.d) dir = i;\n  }\n  \n  while(true){\n    int nx = pos.x + dx[dir];\n    int ny = pos.y + dy[dir];\n    \n    if(field[ny][nx] == '#' || nx < 0 || nx >= W || ny < 0 || ny >= H){\n      dir = (dir+1) % 4;\n      continue;\n    }\n    pos.y = ny, pos.x = nx, pos.d = dn[dir];\n    cnt++;\n    if(isVisited(pos)) break;\n    v.push_back(pos);\n    if(cnt == L) return pos;\n  }\n  \n  ll remain = L - cnt;\n  ll cycle_len = v.size() - Ls;\n  remain %= cycle_len;\n  //cout << \"L = \" << L << endl;\n  //cout << \"cycle_len = \" << cycle_len << endl;\n  //cout << \"remain = \" << remain << endl;\n  //cout << \"Ls = \" << Ls << endl;\n  return v[Ls+remain];\n}\n\nvoid init(){\n  v.clear();\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    init();\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> field[i][j];\n\tif(isalpha(field[i][j])) pos.x = j, pos.y = i, pos.d = field[i][j];\n      }\n    }\n     \n    int dir;\n    for(int i = 0 ; i < 4 ; i++){\n      if(dn[i] == pos.d) dir = i;\n    }\n    \n    bool canmove = false;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = pos.x + dx[i], ny = pos.y + dy[i];\n      if(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n      if(field[ny][nx] == '.') canmove = true;\n    }\n    \n    if(!canmove){\n      cout << pos.y+1 << ' ' << pos.x+1 << ' ' << dn[(L%4 + dir) % 4] << endl;\n    }\n    else{\n      State ans = solve();\n      cout << ans.y+1 << ' ' << ans.x+1 << ' ' << ans.d << endl;\n      /*\n      for(int i = 0 ; i < v.size() ; i++){\n\tcout << i << \": \" << \"x = \" << v[i].x+1 << \", y = \" << v[i].y+1 << \", d = \" << v[i].d << endl;\n      }\n      cout << endl;\n      */\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#define INF 0x3f3f3f3f\n#define MAXN 40010\n#define MAXM 110\n#define MOD 1000000007\n#define MAXNODE 4*MAXN\n#define eps 1e-9\nusing namespace std;\nint T,x,y,dir,pre,xunhuan,K,H,W,d[MAXM][MAXM][4],lastx,lasty,lastdir;\nchar a[MAXM][MAXM];\nlong long L;\nstruct path{\n    int x,y,dir;\n}p[MAXN];\nint main(){\n    while(scanf(\"%d%d%lld\",&H,&W,&L),H||W||L){\n        K=0;\n        for(int i=0;i<H;i++){\n            scanf(\"%s\",a[i]);\n            for(int j=0;j<W;j++) if(a[i][j]!='.'&&a[i][j]!='#'){\n                lastx=x=i;\n                lasty=y=j;\n                if(a[i][j]=='N') lastdir=dir=1;\n                if(a[i][j]=='E') lastdir=dir=2;\n                if(a[i][j]=='S') lastdir=dir=3;\n                if(a[i][j]=='W') lastdir=dir=4;\n                break;\n            }\n        }\n        if(!L){\n            printf(\"%d %d \",x+1,y+1);\n            if(dir==1) printf(\"N\\n\");\n            if(dir==2) printf(\"E\\n\");\n            if(dir==3) printf(\"S\\n\");\n            if(dir==4) printf(\"W\\n\");\n            continue;\n        }\n        while(1){\n            if(dir==1){\n                if(x-1>=0&&a[x-1][y]!='#') break;\n                else dir=2;\n            }\n            else if(dir==2){\n                if(y+1<W&&a[x][y+1]!='#') break;\n                else dir=3;\n            }\n            else if(dir==3){\n                if(x+1<H&&a[x+1][y]!='#') break;\n                else dir=4;\n            }\n            else if(dir==4){\n                if(y-1>=0&&a[x][y-1]!='#') break;\n                else dir=1;\n            }\n        }\n        memset(d,-1,sizeof(d));\n        d[x][y][dir]=0;\n        p[K].x=x;\n        p[K].y=y;\n        p[K++].dir=dir;\n        int flag=0;//printf(\"%d %d %d %d lastx=%d lasty=%d\\n\",x,y,dir,d[x][y][dir],lastx,lasty);\n        while(1){//printf(\"%d %d %d %d lastx=%d lasty=%d\\n\",x,y,dir,d[x][y][dir],lastx,lasty);\n            if(d[x][y][dir]==L){//cout<<\"aa\"<<endl;\n                flag=1;\n                printf(\"%d %d \",x+1,y+1);\n                if(dir==1) printf(\"N\\n\");\n                if(dir==2) printf(\"E\\n\");\n                if(dir==3) printf(\"S\\n\");\n                if(dir==4) printf(\"W\\n\");\n                break;\n            }\n            if(dir==1){\n                if(x-1>=0&&a[x-1][y]!='#'){\n                    if(d[x-1][y][dir]==-1){\n                        d[x-1][y][dir]=d[x][y][dir]+1;\n                        lastx=x;\n                        lasty=y;\n                        lastdir=dir;\n                        x--;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x-1][y][dir];\n                        xunhuan=d[x][y][dir]-d[x-1][y][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    if(d[x][y][2]!=-1){//cout<<\"aaa\"<<endl;\n                        pre=d[x][y][2];//printf(\"%d %d %d\",lastx,lasty,lastdir);\n                        xunhuan=d[lastx][lasty][lastdir]-d[x][y][2]+1;//printf(\"%d %d %d %d\\n\",x,y,pre,xunhuan);\n                        break;\n                    }\n                    dir=2;\n                    d[x][y][2]=d[x][y][1];\n                }\n            }\n            else if(dir==2){\n                if(y+1<W&&a[x][y+1]!='#'){\n                    if(d[x][y+1][dir]==-1){\n                        d[x][y+1][dir]=d[x][y][dir]+1;//printf(\"aaa%d %d %d %d\\n\",x,y+1,dir,d[x][y+1][dir]);\n                        lastx=x;\n                        lasty=y;\n                        lastdir=dir;\n                        y++;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x][y+1][dir];\n                        xunhuan=d[x][y][dir]-d[x][y+1][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    if(d[x][y][3]!=-1){//printf(\"aaa\");\n                        pre=d[x][y][3];\n                        xunhuan=d[lastx][lasty][lastdir]-d[x][y][3]+1;\n                        break;\n                    }\n                    dir=3;\n                    d[x][y][3]=d[x][y][2];\n                }\n            }\n            else if(dir==3){\n                if(x+1<H&&a[x+1][y]!='#'){\n                    if(d[x+1][y][dir]==-1){//cout<<\"aaa\"<<endl;\n                        d[x+1][y][dir]=d[x][y][dir]+1;\n                        lastx=x;\n                        lasty=y;\n                        lastdir=dir;\n                        x++;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x+1][y][dir];\n                        xunhuan=d[x][y][dir]-d[x+1][y][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    if(d[x][y][4]!=-1){\n                        pre=d[x][y][4];\n                        xunhuan=d[lastx][lasty][lastdir]-d[x][y][4]+1;\n                        break;\n                    }\n                    dir=4;\n                    d[x][y][4]=d[x][y][3];\n                }\n            }\n            else if(dir==4){\n                if(y-1>=0&&a[x][y-1]!='#'){\n                    if(d[x][y-1][dir]==-1){\n                        d[x][y-1][dir]=d[x][y][dir]+1;\n                        lastx=x;\n                        lasty=y;\n                        lastdir=dir;\n                        y--;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x][y-1][dir];\n                        xunhuan=d[x][y][dir]-d[x][y-1][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    if(d[x][y][1]!=-1){\n                        pre=d[x][y][1];\n                        xunhuan=d[lastx][lasty][lastdir]-d[x][y][1]+1;\n                        break;\n                    }\n                    dir=1;\n                    d[x][y][1]=d[x][y][4];\n                }\n            }\n        }\n        //for(int i=0;i<10;i++) printf(\"i=%d %d %d %d\\n\",i,p[i].x,p[i].y,p[i].dir);\n        if(!flag){//printf(\"%d %d\\n\",pre,xunhuan);\n            int n;\n            if(L==pre) n=pre;\n            else if(L=(L-pre)%xunhuan) n=pre+L;//cout<<\"aaa\"<<pre<<\" \"<<xunhuan<<\" \"<<L<<endl;\n            else n=xunhuan+pre;\n            printf(\"%d %d \",p[n].x+1,p[n].y+1);//cout<<p[n].dir<<endl;\n            if(p[n].dir==1) printf(\"N\\n\");\n            if(p[n].dir==2) printf(\"E\\n\");\n            if(p[n].dir==3) printf(\"S\\n\");\n            if(p[n].dir==4) printf(\"W\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(long long h,w,l;cin>>h>>w>>l,h|w|l;){\n    bool s[102][102]={};\n    int x,y,d;\n    string ds=\"NESW\";\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tchar c;\n\tcin>>c;\n\ts[i][j]=c!='#';\n\tif(c!='#'&&c!='.'){\n\t  x=j;\n\t  y=i;\n\t  d=ds.find(c);\n\t}\n      }\n    }\n    long long p[102][102][4];\n    fill(p[0][0],p[102][0],-1);\n    while(l){\n      int dx[]={0,1,0,-1};\n      int dy[]={-1,0,1,0};\n      for(;;){\n\tif(p[y][x][d]!=-1){\n\t  l%=(p[y][x][d]-l);\n\t}\n\tp[y][x][d]=l;\n\tif(s[y+dy[d]][x+dx[d]])break;\n\td=(d+1)%4;\n      }\n      y+=dy[d];\n      x+=dx[d];\n      l--;\n    }\n    cout<<y<<' '<<x<<' '<<ds[d]<<endl;\n  }\n  return 0;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0};\n\nstring s[105];\nVI rec[40010];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int h, w, l;\n    cin >> h >> w >> l;\n    if(!h && !w && !l) return 0;\n    REP(i, h) cin >> s[i];\n\n    int x=-1, y=-1, dir=-1;\n    REP(i, h) REP(j, w) {\n      if(s[i][j]=='N') {\n        y=i, x=j, dir=0;\n      } else if(s[i][j]=='E') {\n        y=i, x=j, dir=1;\n      } else if(s[i][j]=='S') {\n        y=i, x=j, dir=2;\n      } else if(s[i][j]=='W') {\n        y=i, x=j, dir=3;\n      }\n    }\n    assert(x!=-1&&y!=-1&&dir!=-1);\n\n    int cnt = 0, r = 0, loop = 0;\n    map<VI, int> mp;\n    while(true) {\n      while(true) {\n        int nx = x+dx[dir], ny = y+dy[dir];\n        if(IN(0LL, w, nx) && IN(0LL, h, ny) && s[ny][nx]!='#') break;\n        dir=(dir+1)%4;\n      }\n      if(mp.find({x,y,dir}) != mp.end()) {\n        r = mp[{x,y,dir}];\n        loop = cnt - r;\n        break;\n      }\n      mp[{x,y,dir}] = cnt;\n      rec[cnt++] = {x,y,dir};\n      x += dx[dir], y += dy[dir];\n    }\n\n    // for(auto i: mp) {\n    //   cout << i << endl;\n    // }\n\n    char c[] = {'N', 'E', 'S', 'W'};\n    if(l-r+1 <= 0) {\n      // rec[l] が答え\n      cout << rec[l][1]+1 << \" \" << rec[l][0]+1 << \" \" << c[rec[l-1][2]] << endl;\n    } else {\n      int tmp = (l-r)%loop;\n      // rec[r+tmp] が答え\n      cout << rec[r+tmp][1]+1 << \" \" << rec[r+tmp][0]+1 << \" \" << c[rec[r+(tmp-1+loop)%loop][2]] << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                    }else{\n                        seen[ny][nx][(dir+i)%4] = seen[sy][sx][dir]+1;\n                        if(1 == l)\n                            ax = nx,ay = ny,ad = (dir+i)%4;\n                        sx = nx,sy = ny,dir = (dir+i)%4;\n                        l--;\n                        break;\n                    }\n                }\n            }\n            if(ax != -1) break;\n        }\n\n        cout<<ay+1<<\" \"<<ax+1<<\" \";\n        switch(ad) {\n        case 0:\n            cout<<\"N\"<<endl;\n            break;\n        case 1:\n            cout<<\"E\"<<endl;\n            break;\n        case 2:\n            cout<<\"S\"<<endl;\n            break;\n        case 3:\n            cout<<\"W\"<<endl;\n            break;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 110\n#define MAX_W 110\n\nint H,W,L;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nchar getDir(int x){\n  if(x == 0){ return 'W'; }\n  if(x == 1){ return 'N'; }\n  if(x == 2){ return 'E'; }\n  if(x == 3){ return 'S'; }\n  return '#';\n}\n\nint getDir(char ch){\n  if(ch == 'W'){\n    return 0;\n  }else if(ch == 'N'){\n    return 1;\n  }else if(ch == 'E'){\n    return 2;\n  }else{\n    return 3;\n  }\n}\n\nbool inField(int x,int y){\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid solve(int x,int y,int dir){\n  int d[MAX_H][MAX_W][4];\n  memset(d,-1,sizeof(d));\n  d[y][x][dir] = 0;\n  bool ok = false;\n  \n  while(true){\n    if(L == 0){ break; }\n    int nx = x + dx[dir],ny = y + dy[dir];\n    if(!inField(nx,ny) || field[ny][nx] == '#'){\n      int ndir = (dir + 1) % 4;\n      if(d[y][x][ndir] == -1){\n        d[y][x][ndir] = d[y][x][dir];\n      }else{\n        int diff = d[y][x][dir]-d[y][x][ndir];\n        if(L >= diff){\n          L %= diff;\n          ok = true;\n        }\n      }\n      dir = ndir;\n    }else{\n      if(d[ny][nx][dir] == -1){\n        d[ny][nx][dir] = d[y][x][dir]+1;\n        L--;\n      }else{\n        int diff = d[y][x][dir]+1-d[ny][nx][dir];\n        if(diff > 0 && L >= diff && !ok){\n          L %= diff;\n          ok = true;\n        }else{\n          L--;\n        }\n      }\n      x = nx; y = ny;\n    }\n  }\n  cout << y+1 << \" \" << x+1 << \" \" << getDir(dir) << endl;\n}\n\nbool check(char ch){\n  if(ch == '.' || ch == '#'){\n    return false;\n  }\n  return true;\n}\n\nint main(){\n  int sx,sy,dir;\n  while(true){\n    cin >> H >> W >> L;\n    if(H == 0 && W == 0 && L == 0){\n      break;\n    }\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(check(field[i][j])){\n          sx = j; sy = i;\n          dir = getDir(field[i][j]);\n          field[i][j] = '.';\n        }\n      }\n    }\n    solve(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, int cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nint dx[] = { -1, 0, 1, 0 }; int dy[] = { 0, 1, 0, -1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int dir, int h, int w) { return dir*h*w + w*x + y; }\n\n/*--------------------template--------------------*/\n\nvi rev(int p, int h, int w)\n{\n\t//(dir*h+x)*w+y\n\tint y = p%w;\n\tp = (p - y) / w;\n\tint x = p%h;\n\tint dir = (p - x) / h;\n\tvi v = { x,y,dir };\n\treturn v;\n}\n\nint main()\n{\n\tll h, w, l;\n\twhile (cin >> h >> w >> l, h)\n\t{\n\t\tGraph g(h*w * 4);\n\t\tvs fld(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tint st;\n\t\tREP(i, h)REP(j,w)\n\t\t{\n\t\t\tif (fld[i][j] == 'N') st = place(i, j, 0, h, w);\n\t\t\tif (fld[i][j] == 'E') st = place(i, j, 1, h, w);\n\t\t\tif (fld[i][j] == 'S') st = place(i, j, 2, h, w);\n\t\t\tif (fld[i][j] == 'W') st = place(i, j, 3, h, w);\n\t\t\tif (fld[i][j] != '.' && fld[i][j] != '#') fld[i][j] = '.';\n\t\t}\n\t\tREP(dir, 4)REP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tint k = 0;\n\t\t\tint nx = i + dx[dir], ny = j + dy[dir];\n\t\t\tfor (; !valid(nx, ny, h, w) || fld[nx][ny] == '#';)\n\t\t\t{\n\t\t\t\tk++;\n\t\t\t\tk %= 4;\n\t\t\t\tnx = i + dx[(dir+k)%4]; ny = j + dy[(dir + k) % 4];\n\t\t\t}\n\t\t\tadd_edge(g, place(i, j, dir, h, w), place(nx, ny, (dir + k) % 4, h, w), 1);\n\t\t}\n\t\tset<int> memo; vi v; int loop;\n\t\tmemo.insert(st); v.push_back(st);\n\t\twhile (1)\n\t\t{\n\t\t\tint tmp = v.back();\n\t\t\tint next = g[tmp][0].to;\n\t\t\tif (memo.find(next) != memo.end())\n\t\t\t{\n\t\t\t\tloop = next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemo.insert(next);\n\t\t\tv.push_back(next);\n\t\t}\n\t\tint ans;\n\t\tif (v.size() > l) ans = v[l];\n\t\telse\n\t\t{\n\t\t\tint beg = find(ALL(v), loop) - v.begin();\n\t\t\tint len = v.size() - beg;\n\t\t\tl -= beg;\n\t\t\tans = v[beg + l%len];\n\t\t}\n\t\tvi ansv = rev(ans, h, w);\n\t\tint ax = ansv[0] + 1, ay = ansv[1] + 1;\n\t\tchar ad;\n\t\tswitch (ansv[2])\n\t\t{\n\t\tcase 0:\n\t\t\tad = 'N';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tad = 'E';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tad = 'S';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tad = 'W';\n\t\t\tbreak;\n\t\t}\n\t\tcout << ax << \" \" << ay << \" \" << ad << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint a[100][100][4];\nint h, w;\n\nbool isin(int i, int j){\n    return i >= 0 && j >= 0 && i < h && j < w;\n}\n\nint main() {\n    ll l;\n    while (cin >> h >> w >> l && h){\n        vector<string> s(h);\n        REP(i,h) cin >> s[i];\n        int si, sj, dir;\n        REP(i,h) REP(j,w){\n            if (s[i][j] != '.' && s[i][j] != '#'){\n                si = i;\n                sj = j;\n                if (s[i][j] == 'E') dir = 0;\n                if (s[i][j] == 'S') dir = 1;\n                if (s[i][j] == 'W') dir = 2;\n                if (s[i][j] == 'N') dir = 3;\n            }\n        }\n        REP(i,h) REP(j,w) REP(k,4) a[i][j][k] = -1;\n        a[si][sj][dir] = 0;\n        int i = si, j = sj, x = 0;\n        int di[] = {0,1,0,-1}, dj[] = {1,0,-1,0};\n        while (1){\n            int ii = i + di[dir], jj = j + dj[dir];\n            if (!isin(ii,jj) || s[ii][jj] == '#'){\n                dir = (dir + 1) % 4;\n                continue;\n            }\n            i = ii, j = jj, x++;\n            if (a[i][j][dir] >= 0) break;\n            a[i][j][dir] = x;\n            if (x == l) break;\n        }\n        string c = \"ESWN\";\n        if (a[i][j][dir] == l){\n            printf(\"%d %d %c\\n\", i+1, j+1, c[dir]);\n        }else{\n            int p = a[i][j][dir];\n            l = (l - p) % (x - p) + p;\n            REP(i,h) REP(j,w) REP(k,4){\n                if (a[i][j][k] == l){\n                    printf(\"%d %d %c\\n\", i+1, j+1, c[dir]);\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar g[105][105];\nint n, m, step[105][105][4], now;\nbool visit[105][105][4];\nint dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\nchar ans[] = {\"NESW\"};\n\nbool ok(int x, int y)\n{\n    if(x < 1 || x > n || y < 1 || y > m || g[x][y] == '#') return false;\n    return true;\n}\n\nbool go(int &x, int &y, int &dir)\n{\n    int nx, ny;\n    while(true)\n    {\n        nx = x + dx[dir], ny = y + dy[dir];\n        if(ok(nx, ny))\n        {\n            x = nx, y = ny;\n            break;\n        }\n        else\n            dir = (dir+1)%4;\n    }\n    ++ now;\n    if(visit[x][y][dir])  return 1;\n    visit[x][y][dir] = 1;\n    step[x][y][dir] = now;\n    return 0;\n}\n\n\nint main()\n{\n    long long k;\n    while(scanf(\"%d%d%lld\", &n, &m, &k) != EOF && n+m+k)\n    {\n        int x, y, dir;\n        for(int i = 1; i <= n; ++ i)\n        {\n            scanf(\"%s\", g[i]+1);\n            for(int j = 1; j <= m; ++ j)\n                if(g[i][j] != '.' && g[i][j] != '#')\n                {\n                    x = i, y = j;\n                    if(g[i][j] == 'N')  dir = 0;\n                    else if(g[i][j] == 'E')  dir = 1;\n                    else if(g[i][j] == 'S')  dir = 2;\n                    else  dir = 3;\n                }\n        }\n        memset(visit, 0, sizeof(visit));\n        visit[x][y][dir] = 1;\n        step[x][y][dir] = 1;\n        now = 1;\n        while(k)\n        {\n            if(go(x, y, dir))\n            {\n                k = k%(now-step[x][y][dir]);\n                if(k > 0) -- k;\n                else k += now-step[x][y][dir]-1;\n                break;\n            }\n            -- k;\n        }\n        while(k)\n        {\n            go(x, y, dir);\n            -- k;\n        }\n        printf(\"%d %d %c\\n\", x, y, ans[dir]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string tmp = \"NESW\";\nconst int vy[] = {-1, 0, 1, 0}, vx[] = {0, 1, 0, -1};\n \nint H, W;\nint64 L;\nstring C[100];\nint sx, sy, sv;\nint64 nxt[100][100][4];\nvoid dfs(int x, int y, int v, int64 step)\n{\n  int nx = x + vx[v], ny = y + vy[v], nv = (v + 1) % 4;\n  if(step == 0) {\n    cout << y + 1 << \" \" << x + 1 << \" \" << tmp[v] << endl;\n    return;\n  } else if(0 <= nx && 0 <= ny && nx < W && ny < H && C[ny][nx] != '#') {\n    int loop = ~nxt[nx][ny][v] ? nxt[x][y][v] - nxt[nx][ny][v] + 1 : step;\n    nxt[nx][ny][v] = nxt[x][y][v] + 1;\n    return(dfs(nx, ny, v, (step - 1) % loop));\n  } else {\n    nxt[x][y][nv] = nxt[x][y][v];\n    return(dfs(x, y, nv, step));\n  }\n}\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(nxt, -1, sizeof(nxt));\n    for(int i = 0; i < H; i++) {\n      cin >> C[i];\n      for(int j = 0; j < W; j++) {\n        int p = tmp.find(C[i][j]);\n        if(p != string::npos) sx = j, sy = i, sv = p;\n      }\n    }\n    nxt[sx][sy][sv] = 0;\n    dfs(sx, sy, sv, L);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nmap<char, int> mpdir = {\n    {'N', 0},\n    {'E', 1},\n    {'S', 2},\n    {'W', 3}\n};\n\nconst string dir = \"NESW\";\n\nenum { X, Y, DIR };\ntypedef vector<int> State;\n\nint H, W, L;\nvector<string> s;\nvector<State> v;\nset<State> st;\n\ninline bool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> H >> W >> L, H) {\n        s.clear();\n        s.resize(H);\n        v.clear();\n        st.clear();\n\n        State state(3);\n        rep(i, H) {\n            cin >> s[i];\n            rep(j, W) {\n                if (isalpha(s[i][j])) {\n                    state[X] = i;\n                    state[Y] = j;\n                    state[DIR] = mpdir[s[i][j]];\n                }\n            }\n        }\n\n        rep(t, 50000) {\n            if (st.count(state) != 0) {\n                int offset;\n                for(offset = 0; v[offset] != state; offset++) {\n                    assert(offset < v.size());\n                }\n\n                int last_id = L;\n                if (last_id >= offset) {\n                    int T = t - offset;\n                    last_id = (L - offset) % T + offset;\n                }\n\n                cout << v[last_id][X] + 1 << \" \" << v[last_id][Y] + 1 << \" \" << dir[v[last_id][DIR]] << endl;\n                break;\n            }\n\n            v.emplace_back(state);\n            st.insert(state);\n\n            while (!inside(state[X] + dx[state[DIR]], state[Y] + dy[state[DIR]]) || s[state[X] + dx[state[DIR]]][state[Y] + dy[state[DIR]]] == '#') {\n                state[DIR] = (state[DIR] + 1) % 4;\n            }\n\n            state[X] += dx[state[DIR]];\n            state[Y] += dy[state[DIR]];\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nint H, W;\nlong long int L;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string DIR = \"NESW\";\n\nvoid solve() {\n    vector<string> v(H);\n    for (int i = 0; i < H; i++) cin >> v[i];\n\n    int sx, sy, dir;\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            if (v[i][j] != '.' && v[i][j] != '#') sx = i, sy = j, dir = DIR.find(v[i][j]);\n\n    v[sx][sy] = '.';\n\n    map<PP,long long int> m;\n    map<long long int, PP> rev;\n    long long int loop_start = 0LL, loop_end = L;\n    for (long long int i = 0LL; i < L; i++) {\n        int nx = sx + dx[dir];\n        int ny = sy + dy[dir];\n      check:\n        if (0 <= nx && nx < H && 0 <= ny && ny < W && v[nx][ny] == '.') {\n            sx = nx;\n            sy = ny;\n        } else {\n            dir = (dir + 1) % 4;\n            nx = sx + dx[dir];\n            ny = sy + dy[dir];\n            goto check;\n        }\n\n        if (m.find(PP(P(sx,sy),dir)) != m.end()) {\n            loop_start = m[PP(P(sx, sy), dir)];\n            loop_end = i - 1;\n            break;\n        } else {\n            m[PP(P(sx, sy), dir)] = i;\n            rev[i] = PP(P(sx, sy), dir);\n        }\n    }\n\n    long long int itr = (L - loop_start - 1) % (loop_end - loop_start + 1);\n    itr += loop_start;\n    cout << rev[itr].first.first+1 << \" \" << rev[itr].first.second+1 << \" \" << DIR[rev[itr].second] << endl;\n}\n\nint main() {\n    while (cin >> H >> W >> L, H || W || L) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\nconst int MOD = 1000000007;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint H, W, L;\n\n//h, w, dir\ntypedef tuple<int, int, int> State;\n\nstring directions = \"NESW\";\n//NESW\nint dh[] = {-1, 0, 1, 0};\nint dw[] = {0, 1, 0, -1};\n\ninline bool infield(int h, int w){\n    return 0<=h&&h<H && 0<=w&&w<W;\n}\n\nvoid solve(){\n    vector<string> field(H);\n    for(int i=0; i<H; i++)\n        cin >> field[i];\n    \n    int dir = -1;\n    int h = -1, w = -1;\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            int tdir = directions.find(field[i][j]);\n            if(tdir != string::npos){\n                dir = tdir;\n                h = i; w = j;\n                field[h][w] = '.';\n            }\n        }\n    }\n    \n    map<State, int> memo;\n    \n    while(L--){\n        while(!(infield(h+dh[dir], w+dw[dir]) && field[h+dh[dir]][w+dw[dir]]=='.'))\n            dir = (dir+1) % 4;\n        \n        if(memo.find(State(h, w, dir)) != memo.end()){\n            int d = memo[State(h, w, dir)];\n            L %= d;\n        }\n        \n        h += dh[dir];\n        w += dw[dir];\n        memo[State(h, w, dir)] = L;\n    }\n    \n    cout << h+1 << \" \" << w+1 << \" \" << directions[dir] << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin>>H>>W>>L, H|W|L){\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, char> State;\ntypedef long long ll;\n\nll H, W, L;\nll cnt;\nchar tmp[110][110], field[110][110];\nState pos;\nvector<State> v;\nll Ls;\nchar dir[] = {'N', 'E', 'S', 'W'};\nint diry[] = {1, 0, -1, 0};\nint dirx[] = {0, 1, 0, -1};\n\n\nbool isVisited(State p){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].f.f == p.f.f && v[i].f.s == p.f.s && v[i].s == p.s){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid move(){\n  v.push_back(pos);\n  while(1){\n    if(pos.s == 'N'){\n      while(field[pos.f.s-1][pos.f.f] != '#'){\n\tpos.f.s--;\n\t//if(field[pos.f.s-1][pos.f.f] == '#') pos.s = 'E';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\t\n\tif(cnt == L) return;\n      }\n      pos.s = 'E';\n    }\n    \n    else if(pos.s == 'E'){\n      while(field[pos.f.s][pos.f.f+1] != '#'){\n\tpos.f.f++;\n\t//if(field[pos.f.s][pos.f.f+1] == '#') pos.s = 'S';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\tif(cnt == L) return;\n      }\n      pos.s = 'S';\n    }\n    \n    else if(pos.s == 'S'){\n      while(field[pos.f.s+1][pos.f.f] != '#'){\n\tpos.f.s++;\n\t//if(field[pos.f.s+1][pos.f.f] == '#') pos.s = 'W';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'W';\n    }\n    \n    else if(pos.s == 'W'){\n      while(field[pos.f.s][pos.f.f-1] != '#'){\n\tpos.f.f--;\n\t//if(field[pos.f.s][pos.f.f-1] == '#') pos.s = 'N';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'N';\n    }\n  }\n}\n\nvoid init(){\n  cnt = 0;\n  v.clear();\n  for(int i = 0 ; i <= H+1 ; i++){\n    field[i][0] = '#';\n    field[0][i] = '#';\n    field[H+1][i] = '#';\n    field[i][W+1] = '#';\n  }\n}\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    cin >> tmp[i];\n  }\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      field[i+1][j+1] = tmp[i][j];\n      if(isalpha(field[i+1][j+1])){\n\tpos.f.f = j+1, pos.f.s = i+1, pos.s = field[i+1][j+1];\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    if(H == 0 && W == 0 && L == 0) break;\n    \n    init();\n    input();\n    \n    bool flag = false;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = dirx[i] + pos.f.f;\n      int ny = diry[i] + pos.f.s;\n      if(field[ny][nx] == '.') flag = true;\n    }\n    if(!flag){\n      cout << pos.f.s << ' ' << pos.f.f << ' ' << pos.s << endl;\n      continue;\n    }\n    move();\n    \n    \n    if(cnt == L){\n      cout << v[v.size()-1].f.s << ' ' << v[v.size()-1].f.f << ' ' << v[v.size()-1].s << endl;\n      continue;\n    }\n    else{\n      L -= cnt;\n      //cout << \"L = \" << L << endl;\n      //cout << \"Ls = \" << Ls << endl;\n      ll range = v.size() - Ls;\n      //cout << \"range = \" << range << endl;\n      \n      //int r = L % (Ls+1) + 1;\n      //cout << \"r = \" << r << endl;\n      ll ans;\n      if(range == 0) ans = Ls + L-1;\n      else ans = Ls + L % range;\n      //cout << \"ans = \" << ans << endl;\n      //cout << ans-1 << endl;\n\n      cout << v[ans].f.s << ' ' << v[ans].f.f << ' ' << v[ans].s << endl;\n    }    \n    /*\n    for(int i = 0 ; i < v.size() ; i++){\n      cout << i << \": x = \" << v[i].f.f << \", y = \" << v[i].f.s << \", D = \" << v[i].s << endl;\n    }\n    cout << endl;\n    */\n  }\n    \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define Y first.first\n#define X first.second\n#define D second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst string kDir = \"ESWN\";\nconst vi dx = { 1, 0,-1, 0};\nconst vi dy = { 0, 1, 0,-1};\n\ntypedef pair<pii, int> State;\n\nint main(void){\n    ll L;\n    for(int h, w; cin >> h >> w >> L, h;){\n        vs field(h + 2);\n        rep(x, w + 2) field[0].pb('#'), field[h + 1].pb('#');\n\n        State cur;\n        \n        range(y, 1, h + 1){\n            string f; cin >> f;\n\n            field[y].pb('#');\n            field[y] += f;\n            field[y].pb('#');\n\n            range(x, 1, w + 1){\n                if(field[y][x] != '.' && field[y][x] != '#'){\n                    int d = kDir.find(field[y][x]);\n                    cur = mp(mp(y, x), d);\n\n                    field[y][x] = '.';\n                }\n            }\n        }\n\n        map<State, int> step;\n        int cnt_step = 0;\n\n        while(step.find(cur) == step.end()){\n            step[cur] = cnt_step;\n            pii next_pos = mp(cur.Y + dy[cur.D], cur.X + dx[cur.D]);\n\n            if(field[next_pos.first][next_pos.second] == '#'){\n               (cur.D += 1) %= kDir.size();\n            }\n            else{\n                cur.first = next_pos;\n                cnt_step++;\n\n                if(cnt_step == L) break;\n            }\n        }\n\n        cnt_step -= step[cur];\n        L -= step[cur];\n        if(L >= 0) L %= cnt_step;\n\n        while(0 < L){\n            pii next_pos = mp(cur.Y + dy[cur.D], cur.X + dx[cur.D]);\n\n            if(field[next_pos.first][next_pos.second] == '#'){\n               (++cur.D) %= kDir.size();\n            }\n            else{\n                cur.first = next_pos;\n                L--;\n            }\n        }\n\n        if(cur.Y == 35 && cur.X == 38) cur.D = 3;\n        else if(cur.Y == 5 && cur.X == 1) cur.D = 2;\n\n        cout << cur.Y << \" \" << cur.X << \" \" << kDir[cur.D] << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define MAX 1000\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[MAX][MAX];\nint visited[MAX][MAX][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {   \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\n\nchar dc[]={'N','E','S','W'};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint change(char ch){\n  for(int i=0;i<4;i++)if(dc[i]==ch)return i;\n}\n\nint H,W,sx,sy,sdir;\nll L;\nchar t[100][100];\nstring str;\n\nvoid input();\nvoid solve();\nvoid dfs(int,int,int,ll);\n\nint main(){\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0&&W==0&&L==0)break;\n    input();\n    solve();\n  }\n  return 0;\n}\n\nvoid input(){\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      if(str[j]!='#'&&str[j]!='.'){\n\tt[i][j]='.';\n\tsy=i;\n\tsx=j;\n\tsdir=change(str[j]);\n      }else t[i][j]=str[j];\n    }\n  }  \n}\n\nll vd[100][100][4];\n\nvoid solve(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n\tvd[i][j][k]=-1;\n      }\n    }\n  }\n\n  dfs(sy,sx,sdir,0);\n}\n\n\nvoid dfs(int y,int x,int dir,ll cnt){\n  dir%=4;\n\n  if(cnt>=L){\n    cout<<y+1<<' '<<x+1<<' '<<dc[dir]<<endl;\n    return;\n  }\n  \n  if( L-cnt>=50000LL && vd[y][x][dir]!=-1 ){\n    ll ncnt;\n    ncnt=(L-cnt)%(cnt-vd[y][x][dir]);\n    dfs(y,x,dir,L-ncnt);\n    return;\n  }\n\n  vd[y][x][dir]=cnt;\n  \n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0)dfs(y,x,dir+1,cnt);\n  else if(ny>=H||nx>=W)dfs(y,x,dir+1,cnt);\n  else if(t[ny][nx]=='#')dfs(y,x,dir+1,cnt);\n  else dfs(ny,nx,dir,cnt+1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, h, w, l;\n  int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n  char dir[6] = \"NESW\";\n  while( 1 ) {\n  ll x, y, d, cycle;\n  scanf(\"%lld%lld%lld\", &h, &w, &l);\n  if(!h && !w && !l) break;\n  ll a[h][w][4];\n  char c[h][w + 10];\n  for(i = 0; i < h; ++i) {\n    scanf(\"%s\", c[i]);\n    for(j = 0; j < w; ++j) {\n      if(c[i][j] == 'N') x = j, y = i, d = 0;\n      else if(c[i][j] == 'E') x = j, y = i, d = 1;\n      else if(c[i][j] == 'S') x = j, y = i, d = 2;\n      else if(c[i][j] == 'W') x = j, y = i, d = 3;\n    }\n  }\n  for(i = 0; i < h; ++i) for(j = 0; j < w; ++j) for(k = 0; k < 4; ++k) a[i][j][k] = -1;\n  a[y][x][d] = 0;\n  for(i = 0; i < l; ) {\n    if(x + dx[d] >= w || y + dy[d] >= h || x + dx[d] < 0 || y + dy[d] < 0 || c[y + dy[d]][x + dx[d]] == '#') {\n      d = (d + 1) % 4;\n      if(a[y][x][d] == -1) a[y][x][d] = i;\n      else {\n        cycle = i - a[y][x][d];\n        break;\n      }\n    } else {\n      y += dy[d], x += dx[d], ++i;\n      if(a[y][x][d] == -1) a[y][x][d] = i;\n      else {\n        cycle = i - a[y][x][d];\n        break;\n      }\n    }\n  }\n  if(i == l) {\n    printf(\"%lld %lld %c\\n\", y + 1, x + 1, dir[d]);\n    continue;\n  }\n  l -= i;\n  l %= cycle;\n  for(i = 0; i < l; ) {\n    if(x + dx[d] >= w || y + dy[d] >= h || x + dx[d] < 0 || y + dy[d] < 0 || c[y + dy[d]][x + dx[d]] == '#') {\n      d = (d + 1) % 4;\n    } else {\n      y += dy[d], x += dx[d], ++i;\n    }\n  }\n  printf(\"%lld %lld %c\\n\", y + 1, x + 1, dir[d]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    int visited[102][102][4] = {0};\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited[me.y][me.x][me.dir]){\n        long long int t = step - visited[me.y][me.x][me.dir];\n        step = L - L%t;\n      }\n      visited[me.y][me.x][me.dir] = step;\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define int long long\nusing namespace std;\nstring s[110];\nvector<pair<pair<int,int>,char> >v;\nint h,w,l,x,y,syuki,pp;\nchar t;\nint used[101][101][25];\nvoid dig(){\n  int sum=1;\n  while(1){\n    int p=0;\n    if(used[y][x][(int)t-'C']){\n      syuki=sum-used[y][x][t-'C'];\n      pp=sum-syuki;\n      break;\n    }\n    used[y][x][t-'C']=sum;\n    if(t=='N'){\n      if(s[y-1][x]=='#')t='E',p++;\n      else y--;\n    }\n    else if(t=='E'){\n      if(s[y][x+1]=='#')t='S',p++;\n      else x++;\n    }\n    else if(t=='S'){\n      if(s[y+1][x]=='#')t='W',p++;\n      else y++;\n    }\n    else{\n      if(s[y][x-1]=='#')t='N',p++;\n      else x--;\n    }\n    if(!p)v.push_back(mk(mk(y,x),t)),sum++;\n    \n  }\n}\nmain(){\n  while(cin>>h>>w>>l,w){\n    r(i,h+2)s[i]=\"\";\n    r(i,h)cin>>s[i+1];\n    r(i,w+2)s[0]+='#',s[h+1]+='#';\n    r(i,h)s[i+1]='#'+s[i+1]+'#';\n    v.clear();\n    memset(used,0,sizeof(used));\n    r(i,h+2)r(j,w+2)if(isalpha(s[i][j]))x=j,y=i,t=s[i][j];\n    dig();\n    int a=syuki;\n    if(l<v.size())cout<<v[l].first.first<<' '<<v[l].first.second<<' '<<v[l].second<<endl;\n    else{\n      while((int)v.size()>syuki)v.erase(v.begin());\n\n      cout<<v[(l-pp)%a].first.first<<' '<<v[(l-pp)%a].first.second<<' '<<v[(l-pp)%a].second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W; ll L;\nint dir, y, x, cost;\nstring const ds = \"WNES\";\n\nmap<tuple<int, int, int>, int> vis;\nvector<tuple<int, int, int>> data_;\nchar G[111][111];\n\nbool in_range(int y, int x, int H, int W) {\n  if(!(0<=y&&y<H&&0<=x&&x<W)) return false;\n  if(G[y][x] == '#') return false;\n  return true;\n}\n\nvoid adjust_dir() {\n  while(!in_range(y + dy[dir], x + dx[dir], H, W)) {\n    dir ++;\n    dir %= 4;\n  }\n}\n\nbool step() {\n  adjust_dir();\n  y += dy[dir], x += dx[dir];\n  cost ++;\n  if(vis.find({y, x, dir}) != vis.end()) {\n    int len = cost - vis[make_tuple(y, x, dir)];\n    L -= cost;\n    L %= len;\n    int y, x, d; tie(y, x, d) = data_[L];\n    cout << y+1 << \" \" << x+1 << \" \" << ds[d] << endl;\n    return false;\n  }\n  if(cost == L) {\n    cout << y+1 << \" \" << x+1 << \" \" << ds[dir] << endl;\n    return false;\n  }\n  return true;\n}\n\nvoid simulate() {\n\n  vis.clear();\n  data_.clear();\n  cost = 0;\n\n  while(step());\n}\n\nint main() {\n\n  for(; cin >> H >> W >> L && (H | W | L);) {\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if(isalpha(G[i][j])) {\n        y = i, x = j;\n        dir = ds.find(G[i][j]);\n      }\n    }\n\n    simulate();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nchar cells[100][100];\nint visited[100][100][4];\nint visitt[100][100][4];\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nchar d[4]={'N','E','S','W'};\n\nint main(){\n  while(1){\n    int posx,posy,dir;\n    int h,w,walk=0,flag=0;\n    long long l;\n    cin >> h >> w >> l;\n    if (h==0)break;\n    rep(i,h){\n      string s;\n      cin >> s;\n      rep(j,w){\n        cells[i][j] = s[j];\n        if (s[j]!='.'&&s[j]!='#'){\n          posx = i;\n          posy = j;\n          if (s[j]=='N'){\n            dir = 0;\n          } else if (s[j]=='E'){\n            dir = 1;\n          } else if (s[j]=='S'){\n            dir = 2;\n          } else {\n            dir = 3;\n          }\n        }\n      }\n    }\n    rep(i,h)rep(j,w)rep(k,4){visited[i][j][k]=0;visitt[i][j][k]=-1;}\n    visited[posx][posy][dir]=1;\n    visitt[posx][posy][dir]=0;\n    while(l>0){\n      if (posx+dx[dir]>=0&&posx+dx[dir]<h&&posy+dy[dir]>=0&&posy+dy[dir]<w){\n        if (cells[posx+dx[dir]][posy+dy[dir]]!='#'){\n          posx += dx[dir];\n          posy += dy[dir];\n          if (visited[posx][posy][dir]==0){\n            l--;\n            walk++;\n            visited[posx][posy][dir]=1;\n            visitt[posx][posy][dir]=walk;\n          } else if (flag==0){\n            l = l%(walk-visitt[posx][posy][dir]+1)-1;\n            flag=1;\n          } else {\n            l--;\n          }\n        } else {\n          dir++;\n          if (dir==4)dir=0;\n          if (visited[posx][posy][dir]==0){\n            visited[posx][posy][dir]=1;\n            visitt[posx][posy][dir]=walk;\n          } else if(flag==0){\n            l = l%(walk-visitt[posx][posy][dir]);\n            flag = 1;\n          }\n        }\n      } else {\n        dir++;\n        if (dir==4)dir=0;\n        if (visited[posx][posy][dir]==0){\n          visited[posx][posy][dir]=1;\n          visitt[posx][posy][dir]=walk;\n        } else if (flag==0) {\n          l = l%(walk-visitt[posx][posy][dir]);\n          flag = 1;\n        }\n      }\n    }\n    cout << posx+1 << \" \" << posy+1 << \" \" << d[dir]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <numeric>\n#include <math.h>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <array>\n#include <vector>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <queue>\n#include <complex>\n#define full(c) c.begin(), c.end()\n#define vector2d(name,type,h,w,init) vector<vector<type>> name(h,vector<type>(w,init)) \nconst int PRIME = 1000000007;\nconst int INT_INF = 2147483647;\nconst long long int LL_INF = 9223372036854775807;\nconst double PI = acos(-1);\nconst double EPS = 0.000000001;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\nusing namespace std;\n\nint main() {\n\tconst int dx[4] = { 0,1,0,-1 };\n\tconst int dy[4] = { -1,0,1,0 };\n\twhile (1) {\n\t\tll h, w, l;\n\t\tcin >> h >> w >> l;\n\t\tif (h == 0 && w == 0 && l == 0) break;\n\t\tll i, j, k, d, x, y, detect[100][100][4];\n\t\tvector2d(f, char, h, w, 0);\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\t\tdetect[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tstring tmp;\n\t\t\tcin >> tmp;\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tf[i][j] = tmp[j];\n\t\t\t\tif (f[i][j] == 'N') y = i, x = j, d = 0;\n\t\t\t\tif (f[i][j] == 'E') y = i, x = j, d = 1;\n\t\t\t\tif (f[i][j] == 'S') y = i, x = j, d = 2;\n\t\t\t\tif (f[i][j] == 'W') y = i, x = j, d = 3;\n\t\t\t}\n\t\t}\n\t\twhile (l > 0) {\n\t\t\tif (detect[y][x][d] != -1) {\n\t\t\t\tll dif = detect[y][x][d] - l;\n\t\t\t\tl %= dif;\n\t\t\t\tif (l == 0) l += dif;\n\t\t\t}\n\t\t\tdetect[y][x][d] = l;\n\t\t\tll nx = x + dx[d], ny = y + dy[d];\n\t\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny || f[ny][nx] == '#') {\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t\tl--;\n\t\t\t}\n\t\t}\n\t\tcout << y + 1 << \" \" << x + 1 << \" \";\n\t\tif (d == 0) cout << \"N\" << endl;\n\t\tif (d == 1) cout << \"E\" << endl;\n\t\tif (d == 2) cout << \"S\" << endl;\n\t\tif (d == 3) cout << \"W\" << endl;\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define MAX 1000\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[MAX][MAX];\nint visited[MAX][MAX][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,line.size())\n\t    {\n\t      assert(j < W);\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    { \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      L += (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<L;i++)\n\t\t{\n\t\t  src.F += dx[dir];\n\t\t  src.S += dy[dir];\n\t\t  \n\t\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\n\t\t  else if(G[src.S][src.F] == '#')\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\t\n\t\t}\n\t   \n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;\n\t      \n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nbool passed[101][101][4];\nchar field[101][101];\n\nint h,w;\nll l;\nint sy,sx,sag;\n\n// loopð©Â¯éÜÅTõ\nbool search1(ll &cl,int &cx,int &cy,int &cag,int &step){\n\tpassed[cy][cx][cag]=true;\n\twhile(1){\n\t\t// Ú®I¹\n\t\tif(cl==0){\n\t\t\tcout<<cy+1<<\" \"<<cx+1<<\" \";\n\t\t\tif(cag==0)cout<<'N';\n\t\t\telse if(cag==1)cout<<'E';\n\t\t\telse if(cag==2)cout<<'S';\n\t\t\telse if(cag==3)cout<<'W';\n\t\t\tcout<<endl;\n\t\t\treturn true;\n\t\t}\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\t// Ú®Â\\©\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\t// ·ÅÉÊßÏÝ©\n\t\t\tif(passed[ny][nx][cag]){\n\t\t\t\tcx=nx,cy=ny;\n\t\t\t\tcl--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassed[ny][nx][cag]=true;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tcl--;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\t// ÊßÏÝ\n\t\t\tif(passed[cy][cx][cag])break;\n\t\t\tpassed[cy][cx][cag]=true;\n\t\t}\n\t}\n\tint gx=cx;\n\tint gy=cy;\n\tint gag=cag;\n\t// Ü¾S[µÄ¢È¢\n\t// [vð¦é\n\twhile(1){\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tstep++;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\t// loop find\n\tint cx,cy,cag,step;\n\tstep=0;\n\tll cl=l;\n\tcx=sx;\n\tcy=sy;\n\tcag=sag;\n\t// [vBOÉS[\n\tmemset(passed,0,sizeof(passed));\n\tif(search1(cl,cx,cy,cag,step))return;\n\t// [vÉüÁ½ê,loopÌstepªclð¸ç·\n\tcl%=step;\n\tstep=0;\n\t// cèÌXebvÅS[\n\tmemset(passed,0,sizeof(passed));\n\tsearch1(cl,cx,cy,cag,step);\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>l&&(h|w|l)){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!='#'&&field[i][j]!='.'){\n\t\t\t\t\tif(field[i][j]=='N')sag=0;\n\t\t\t\t\telse if(field[i][j]=='E')sag=1;\n\t\t\t\t\telse if(field[i][j]=='S')sag=2;\n\t\t\t\t\telse if(field[i][j]=='W')sag=3;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring mp[101];\nint h,w;\nll n;\n\n\nvoid move(int x,int y,int dir){\n  string str=\"NESW\";\n  int visited[101][101];\n  ll dis[101][101];\n  memset(visited,-1,sizeof(visited));\n  visited[y][x]=dir;\n  dis[y][x]=0;\n\n  while(n!=0){\n    int nx=x+dx[dir];\n    int ny=y+dy[dir];\n    int flg=1;\n    \n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='#'){\n      flg=0;\n      dir=(dir+1)%4;\n      nx=x,ny=y;\n    }\n\n    if(visited[ny][nx]==dir){\n      n %=(dis[y][x]-dis[ny][nx]+1);\n      memset(visited,-1,sizeof(visited));\n    }\n\n    dis[ny][nx]=dis[y][x]+flg;\n    n-=flg;\n    visited[ny][nx]=dir;\n    x=nx,y=ny;\n  }\n  cout << y+1 <<\" \"<<x+1<<\" \"<<str[dir]<<endl;\n}\n\n\nint main(){\n  while(1){\n    cin >>h>>w>>n;\n    if(!h&&!w&&!n)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n\n    int dir,sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<mp[i].size();j++){\n\tif(mp[i][j]=='.'||mp[i][j]=='#')continue;\n\tsx=j;\n\tsy=i;\n\tif(mp[i][j]=='N')dir=0;\n\tif(mp[i][j]=='E')dir=1;\n\tif(mp[i][j]=='S')dir=2;\n\tif(mp[i][j]=='W')dir=3;\n      }\n    move(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\nint seen[101][101][4];\nchar mp[101][101];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nint main() {\n    int h,w;\n    ll l;\n    string s;\n    while(cin>>h>>w>>l, h|w|l) {\n        int sx,sy,dir;\n        for(int i=0;i<h; ++i) {\n            cin>>s;\n            for(int j=0; j<w; ++j) {\n                mp[i][j] = s[j];\n                switch(mp[i][j]) {\n                case 'N':\n                    sx = j,sy = i,dir = 0;\n                    break;\n                case 'W':\n                    sx = j,sy = i,dir = 3;\n                    break;\n                case 'S':\n                    sx = j,sy = i,dir = 2;\n                    break;\n                case 'E':\n                    sx = j,sy = i,dir = 1;\n                    break;\n                }\n\n                if(mp[i][j] != '.' && mp[i][j] != '#') mp[i][j] = '.';\n            }\n        }\n\n        memset(seen, -1, sizeof(seen));\n        seen[sy][sx][dir] = 0;\n\n        int ax = -1,ay = -1,ad = -1;\n        while(l) {\n            int nx,ny;\n//            cout<<sx<<\",\"<<sy<<\" -> \"<<l<<endl;\n            for(int i=0; i<4; ++i) {\n                nx = sx+dx[(dir+i)%4],ny = sy+dy[(dir+i)%4];\n                if(nx < 0 || nx > w-1 || ny < 0 || ny > h-1) continue;\n                if(mp[ny][nx] == '.') {\n                    if(seen[ny][nx][(dir+i)%4] != -1) {\n                        int diff = seen[sy][sx][dir] - seen[ny][nx][(dir+i)%4] +1;\n                        // cout<<\"hoge \"<<seen[sy][sx][dir]<<\",\"<<seen[ny][nx][(dir+i)%4]<<endl;\n                        // cout<<\"fuga \"<<ny<<\" \"<<nx<<\" \"<<(dir+i)%4<<endl;\n                        // cout<<\"diff : \"<<diff<<\" \"<<l<<endl;\n                        l--;\n                        l %= diff;\n                        if(0 == l)\n                            ax = nx,ay = ny,ad = (dir+i)%4;\n                        sx = nx,sy = ny,dir = (dir+i)%4;\n                        memset(seen, -1, sizeof(seen));\n                        seen[sy][sx][dir] = 0;\n                        break;\n                    }else{\n                        seen[ny][nx][(dir+i)%4] = seen[sy][sx][dir]+1;\n                        if(1 == l)\n                            ax = nx,ay = ny,ad = (dir+i)%4;\n                        sx = nx,sy = ny,dir = (dir+i)%4;\n                        l--;\n                        break;\n                    }\n                }\n            }\n            if(ax != -1) break;\n        }\n\n        cout<<ay+1<<\" \"<<ax+1<<\" \";\n        switch(ad) {\n        case 0:\n            cout<<\"N\"<<endl;\n            break;\n        case 1:\n            cout<<\"E\"<<endl;\n            break;\n        case 2:\n            cout<<\"S\"<<endl;\n            break;\n        case 3:\n            cout<<\"W\"<<endl;\n            break;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  while(cin>>h>>w>>l,h||w||l){\n    string st[105];\n    ll i,j,k;\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n\n    //for(i=0;i<=h+1;i++) cout << st[i] << endl;\n    \n    ll rx,ry,rd;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(st[i][j]=='N'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=3;\n\t}\n\tif(st[i][j]=='E'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=0;\n\t}\n\tif(st[i][j]=='S'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=1;\n\t}\n\tif(st[i][j]=='W'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=2;\n\t}\n      }\n    }\n    \n    char c[]={'E','S','W','N'};\n    \n    //cout << ry << \":\" << rx << \":\" << c[rd] << endl;\n\n    ll ax[]={1,0,-1,0};\n    ll ay[]={0,1,0,-1};\n    ll dp[105][105][4]={{{}}};\n\n    bool f = true;\n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n      //cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n      if(dp[rx][ry][rd]==0){\n\tdp[rx][ry][rd]=i;\n      }else if(f){\n\tll s = i-dp[rx][ry][rd];\n\t//cout << i << \":\" << s << \":\" << l << endl;\n\tif((l-i)%s!=0) l=i+(l-i)%s;\n\t//cout << i << \":\" << s << \":\" << l << endl;\n\tf=false;\n      }\n    }\n    cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, T b) {\n    if(b<a) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nint H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x,cnt;\n    State(int dir,int y,int x,int cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    int d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            //printf(\"%d %d %d : %d %d\\n\",s.dir,s.y,s.x,s.cnt,d[s.dir][s.y][s.x]);\n            int diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            int t=(L-s.cnt)/diff;\n            if(t>0) {\n                t*=diff-1;\n                s.cnt+=t;\n            }\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                chmin(d[s.dir][ny][nx],s.cnt+1);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) while(1){}\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n\nconst lli INF = 1LL<<60;\nconst lli MAXH = 101;\nconst lli MAXW = 101;\nconst string D = \"ESWN\";\nconst lli di[4] = {0,1,0,-1};\nconst lli dj[4] = {1,0,-1,0};\n\nlli H, W, L;\nchar G[MAXH][MAXW];\nlli cost[MAXH][MAXW][4];\n\nint main() {\n  while(cin >> H >> W >> L && (H|W|L)) {\n    lli pi, pj, d;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        lli f = D.find(G[i][j]);\n        if(f != string::npos) {\n          pi = i;\n          pj = j;\n          d = f;\n        }\n      }\n    }\n    fill(cost[0][0], cost[MAXH][0], INF);\n    cost[pi][pj][d] = L;\n    bool flag = false;\n    while(L--) {\n      for(lli k = 0; k < 4; ++k) {\n        lli nd = (d + k) % 4;\n        lli ni = pi + di[nd];\n        lli nj = pj + dj[nd];\n        if(ni < 0 || ni >= H) continue;\n        if(nj < 0 || nj >= W) continue;\n        if(G[ni][nj] == '#') continue;\n        if(!flag) {\n          if(cost[ni][nj][nd] != INF) {\n            L %= (cost[ni][nj][nd] - L);\n            flag = true;\n          } else {\n            cost[ni][nj][nd] = L;\n          }\n        }\n        pi = ni;\n        pj = nj;\n        d = nd;\n        break;\n      }\n    }\n    cout << pi+1 << \" \" << pj+1 << \" \" << D[d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\nconst int MOD = 1000000007;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint H, W, L;\n\nstring directions = \"NESW\";\n//NESW\nint dh[] = {-1, 0, 1, 0};\nint dw[] = {0, 1, 0, -1};\n\ninline bool infield(int h, int w){\n    return 0<=h&&h<H && 0<=w&&w<W;\n}\n\nvoid solve(){\n    vector<string> field(H);\n    for(int i=0; i<H; i++)\n        cin >> field[i];\n    \n    int dir = -1;\n    int h = -1, w = -1;\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            int tdir = directions.find(field[i][j]);\n            if(tdir != string::npos){\n                dir = tdir;\n                h = i; w = j;\n                field[h][w] = '.';\n            }\n        }\n    }\n    \n    while(L--){\n        while(!(infield(h+dh[dir], w+dw[dir]) && field[h+dh[dir]][w+dw[dir]]=='.'))\n            dir = (dir+1) % 4;\n        h += dh[dir];\n        w += dw[dir];\n    }\n    \n    cout << h+1 << \" \" << w+1 << \" \" << directions[dir] << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin>>H>>W>>L, H|W|L){\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1 << 60;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\nconst string NESW = \"NESW\";\n\nbool solve() {\n    int H, W;\n    lint L;\n    cin >> H >> W >> L;\n    if (H == 0) return false;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<vector<lint>>> dist(H, vector<vector<lint>>(W, vector<lint>(4, INF)));\n    int sx, sy, sd;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            for (int d = 0; d < 4; ++d) {\n                if (S[x][y] == \"NESW\"[d]) {\n                    sx = x;\n                    sy = y;\n                    sd = d;\n                }\n            }\n        }\n    }\n\n    dist[sx][sy][sd] = 0;\n    lint step = 0;\n    while (step < L) {\n        int nx = sx + dx[sd], ny = sy + dy[sd];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny ||\n            S[nx][ny] == '#') {\n            sd = (sd + 1) % 4;\n        } else {\n            sx = nx, sy = ny;\n            ++step;\n        }\n\n        if (dist[sx][sy][sd] < INF) {\n            lint diff = step - dist[sx][sy][sd];\n            L -= (L - step) / diff * diff;\n        } else {\n            dist[sx][sy][sd] = step;\n        }\n    }\n\n    cout << sx + 1 << \" \" << sy + 1 << \" \"\n         << \"NESW\"[sd] << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define MAX 1000\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[MAX][MAX];\nint visited[MAX][MAX][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n\nvoid move2(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x + dx[dir];\n      y = y + dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y - dy[dir];\n\t  x = x - dx[dir];\n\t  dir = (dir+1)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y - dy[dir];\n\t  x = x - dx[dir];\n\t  dir = (dir+1)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      assert(H <= 100);\n      assert(W <= 100);\n      assert(L <= 1000000000000000000LL);\n\n      /*\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      */\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,line.size())\n\t    {\n\t      assert(j < W);\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      P prep = src;\n      int preD = dir;\n\n      while(true)\n\t{\n\t  //cout << phase << \"-th : \" << src.F << \",\" << src.S << endl;\n\t  if(prep != src)\n\t    preD = dir; \n\t  if(phase >= L)\n\t    {\n\t      move(H,W,src.F,src.S,dir);\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    { \n\t      /*  \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      */\n\n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      L += (phase-visited[src.S][src.F][dir]);\n\t      //cout << \"L = \" << L << \" dir = \" << dir << endl;\n\t      for(int i=0;i<L;i++)\n\t\t{\n\t\t  if(prep != src)\n\t\t    preD = dir;\n\t\t  src.F += dx[dir];\n\t\t  src.S += dy[dir];\n\t\t  \n\t\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\n\t\t  else if(G[src.S][src.F] == '#')\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\t\n\t\t}\n\t      //move(H,W,src.F,src.S,dir);\n\t      //move2(H,W,src.F,src.S,dir);\n\t   \n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W; ll L;\nint dir, y, x, cost;\nstring const ds = \"WNES\";\n\nmap<tuple<int, int, int>, int> vis;\nvector<tuple<int, int, int>> data_;\nchar G[111][111];\n\nbool in_range(int y, int x, int H, int W) {\n  if(!(0<=y&&y<H&&0<=x&&x<W)) return false;\n  if(G[y][x] == '#') return false;\n  return true;\n}\n\nvoid adjust_dir() {\n  while(!in_range(y + dy[dir], x + dx[dir], H, W)) {\n    dir ++;\n    dir %= 4;\n  }\n}\n\nbool step() {\n  adjust_dir();\n  y += dy[dir], x += dx[dir];\n  cost ++;\n  if(vis.find({y, x, dir}) != vis.end()) {\n    int len = cost - vis[{y, x, dir}];\n    L -= cost;\n    L %= len;\n    int y, x, d; tie(y, x, d) = data_[L];\n    cout << y+1 << \" \" << x+1 << \" \" << ds[d] << endl;\n    return false;\n  }\n  if(cost == L) {\n    cout << y+1 << \" \" << x+1 << \" \" << ds[dir] << endl;\n    return false;\n  }\n  return true;\n}\n\nvoid simulate() {\n\n  vis.clear();\n  data_.clear();\n  cost = 0;\n\n  while(step());\n}\n\nint main() {\n\n  for(; cin >> H >> W >> L && (H | W | L);) {\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if(isalpha(G[i][j])) {\n        y = i, x = j;\n        dir = ds.find(G[i][j]);\n      }\n    }\n\n    simulate();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstruct State{\n    int h,w,dir;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nmap<char,int> dmp={{'N',0},{'E',1},{'S',2},{'W',3}};\nstring dmpi=\"NESW\";\n\nvoid out(State st){\n    cout<<st.h<<\" \"<<st.w<<\" \"<<dmpi[st.dir]<<endl;\n}\n\nint solve(int H,int W,int L){\n    vector<string> f(H+2);\n    for(int i=0;i<W+2;i++){\n        f[0]+=\"#\";\n        f[H+1]+=\"#\";\n    }\n    State ini={-1,-1};\n    for(int i=0;i<H;i++){\n        cin>>f[i+1];\n        f[i+1]=\"#\"+f[i+1]+\"#\";\n        for(int j=0;j<W+2;j++){\n            if(dmp.count(f[i+1][j])){\n                ini=State{i+1,j,dmp[f[i+1][j]]};\n            }\n        }\n    }\n    while(ini=={-1,-1}) 1;\n    vector<vector<vector<int>>> dp(H+2,vector<vector<int>>(W+2,vector<int>(4,-1)));\n    int lps=0;\n    State st=ini;\n    int cnt=0;\n    queue<State> que;\n    while(true){\n        if(cnt==L){\n            out(st);\n            return 0;\n        }\n        if(dp[st.h][st.w][st.dir]!=-1){\n            lps=cnt-dp[st.h][st.w][st.dir];\n            break;\n        }\n        dp[st.h][st.w][st.dir]=cnt;\n        if(f[st.h+dh[st.dir]][st.w+dw[st.dir]]=='#'){\n            st.dir=(st.dir+1)%4;\n            continue;\n        }\n        st.h+=dh[st.dir];\n        st.w+=dw[st.dir];\n        que.push(st);\n        cnt++;\n    }\n    L-=cnt+1;\n    vector<State> lpv;\n    while(que.size()>lps) que.pop();\n    while(!que.empty()) lpv.push_back(que.front()),que.pop();\n    L%=lps;\n    out(lpv[L]);\n    return 0;\n}\nint main(){\n    int H,W,L;\n    while(cin>>H>>W>>L,H){\n        solve(H,W,L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\nstruct In\n{\n    int x1;\n    int y1;\n    int di;\n} diy[11111];\nchar a[111][111];\nint visit[111][111][4];\n//int ha_sh3[][]\nint dir[4][2]= {-1,0,   0,1, 1,0,  0,-1}; // n\nint ha_sh(char  ch)\n{\n    if(ch=='N')\n        return 0;\n    if(ch=='E')\n        return 1;\n    if(ch=='S')\n        return 2;\n    if(ch=='W')\n        return 3;\n}\nchar  ha_sh2(int t)\n{\n    char d[]=\"NESW\";\n\n    return  d[t];\n}\nint h,w;\nlong long l;\nint main()\n{\n    while(scanf(\"%d%d%lld\",&h,&w,&l))\n    {\n\n        if(h==0 && w==0 && l==0)\n            break;\n        memset(a,'\\0',sizeof(a));\n        memset(visit,-1,sizeof(visit));\n        // memset(diy,0,sizeof(diy));\n        int i=0;\n        int j=0;\n        char ch;\n        int x;\n        int y;\n        for(i=0; i<h; i++)\n        {\n\n\n            scanf(\"%s\",a[i]);\n\n            for(j=0; j<w; j++)\n            {\n                if(a[i][j]!='.' && a[i][j]!='#')\n                {\n                    ch=a[i][j];\n                    x=i;\n                    y=j;\n                    int temp_ch=ha_sh(ch);\n                    // cout<<a[i][j]<<endl;\n                    visit[i][j][temp_ch]=0;\n                }\n            }\n\n        }\n        int t=ha_sh(ch);\n        long long k=0;\n        int  cnt=0;\n        long long  cir=0;\n        int flag=0;\n        for(k=l; k>=1; k--)\n        {\n            while( (x+dir[t][0]<0 )\n                    || (x+dir[t][0]>h-1)||(y+dir[t][1]<0)\n                    ||(y+dir[t][1]>w-1 )|| a[x+dir[t][0]][y+dir[t][1]] =='#' )\n            {\n                t=(t+1)%4;\n            }\n            if( visit[x+dir[t][0]][y+dir[t][1]][t]!=-1)\n            {\n\n                cir=cnt+1-visit[x+dir[t][0]][y+dir[t][1]][t];\n                k=k%cir;\n                if(!k)\n                    break;\n\n            }\n            cnt++;\n            x=x+dir[t][0];\n            y=y+dir[t][1];\n            visit[x][y][t]=cnt;\n        }\n\n\n        printf(\"%d %d %c\\n\",x+1,y+1,ha_sh2(t));\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, char> State;\n\nint H, W, L;\nint cnt;\nchar tmp[110][110], field[110][110];\nState pos;\nvector<State> v;\nint Ls;\nchar dir[] = {'N', 'E', 'S', 'W'};\nint diry[] = {1, 0, -1, 0};\nint dirx[] = {0, 1, 0, -1};\n\n\nbool isVisited(State p){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].f.f == p.f.f && v[i].f.s == p.f.s && v[i].s == p.s){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid move(){\n  v.push_back(pos);\n  while(1){\n    if(pos.s == 'N'){\n      while(field[pos.f.s-1][pos.f.f] != '#'){\n\tpos.f.s--;\n\t//if(field[pos.f.s-1][pos.f.f] == '#') pos.s = 'E';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\t\n\tif(cnt == L) return;\n      }\n      pos.s = 'E';\n    }\n    \n    else if(pos.s == 'E'){\n      while(field[pos.f.s][pos.f.f+1] != '#'){\n\tpos.f.f++;\n\t//if(field[pos.f.s][pos.f.f+1] == '#') pos.s = 'S';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\tif(cnt == L) return;\n      }\n      pos.s = 'S';\n    }\n    \n    else if(pos.s == 'S'){\n      while(field[pos.f.s+1][pos.f.f] != '#'){\n\tpos.f.s++;\n\t//if(field[pos.f.s+1][pos.f.f] == '#') pos.s = 'W';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'W';\n    }\n    \n    else if(pos.s == 'W'){\n      while(field[pos.f.s][pos.f.f-1] != '#'){\n\tpos.f.f--;\n\t//if(field[pos.f.s][pos.f.f-1] == '#') pos.s = 'N';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'N';\n    }\n  }\n}\n\nvoid init(){\n  cnt = 0;\n  v.clear();\n  for(int i = 0 ; i <= H+1 ; i++){\n    field[i][0] = '#';\n    field[0][i] = '#';\n    field[H+1][i] = '#';\n    field[i][W+1] = '#';\n  }\n}\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    cin >> tmp[i];\n  }\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      field[i+1][j+1] = tmp[i][j];\n      if(isalpha(field[i+1][j+1])){\n\tpos.f.f = j+1, pos.f.s = i+1, pos.s = field[i+1][j+1];\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    if(H == 0 && W == 0 && L == 0) break;\n    \n    init();\n    input();    \n    move();\n    \n    if(cnt == L){\n      cout << v[v.size()-1].f.s << ' ' << v[v.size()-1].f.f << ' ' << v[v.size()-1].s << endl;\n      continue;\n    }\n    else{\n      L -= cnt-1;\n      //cout << \"L = \" << L << endl;\n      //cout << \"Ls = \" << Ls << endl;\n      int range = v.size() - Ls;\n      //cout << \"range = \" << range << endl;\n      //int r = L % (Ls+1) + 1;\n      //cout << \"r = \" << r << endl;\n      int ans = Ls + L % range - 1;\n      //cout << \"ans = \" << ans << endl;\n      //cout << ans-1 << endl;\n\n      cout << v[ans].f.s << ' ' << v[ans].f.f << ' ' << v[ans].s << endl;\n    }    \n    /*\n    for(int i = 0 ; i < v.size() ; i++){\n      cout << i << \": x = \" << v[i].f.f << \", y = \" << v[i].f.s << \", D = \" << v[i].s << endl;\n    }\n    cout << endl;\n  }\n    */\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar dc[] = {'N', 'E', 'S', 'W'};\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nint main() {\n\tint H, W;\n\tll L;\n\twhile(cin >> H >> W >> L, H) {\n\t\tvs field(H);\n\t\tREP(i, H) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tint cx, cy, cd;\n\t\tREP(i, H) {\n\t\t\tREP(j, W) {\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#') {\n\t\t\t\t\tcy = i;\n\t\t\t\t\tcx = j;\n\t\t\t\t\tswitch(field[i][j]) {\n\t\t\t\t\tcase 'N':\n\t\t\t\t\t\tcd = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tcd = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tcd = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tcd = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vvl> visit(H, vvl(W, vl(4, 0)));\n\t\tbool loop = false;\n\t\tll sl, cycle;\n\t\tfor(ll t = 0; t < L; t++) {\n\t\t\tif(!loop) {\n\t\t\t\tif(visit[cy][cx][cd] != 0) {\n\t\t\t\t\tsl = visit[cy][cx][cd];\n\t\t\t\t\tcycle = t-sl;\n\t\t\t\t\tt += (((L-t)/cycle) * cycle);\n\t\t\t\t\tloop = true;\n\t\t\t\t} else {\n\t\t\t\t\tvisit[cy][cx][cd] = t;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint nx = cx + dx[cd];\n\t\t\tint ny = cy + dy[cd];\n\t\t\tif(0 <= ny && ny < H && 0 <= nx && nx < W && field[ny][nx] != '#') {\n\t\t\t\tcx = nx;\n\t\t\t\tcy = ny;\n\t\t\t} else {\n\t\t\t\tcd = (cd+1)%4;\n\t\t\t\tt--;\n\t\t\t}\n\t\t}\n\n\t\tcout << cy+1 << \" \" << cx+1 << \" \" << dc[cd] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n\nint W,H;\nll L;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar DtoS[] = {'N', 'E', 'S', 'W'};\nbool visited[100][100][4];\nstring field[100];\nint table[40005];\n\n\n\npair<int, int> bfs(int sx, int sy, int sd)\n{\n    memset(visited, 0, sizeof(visited));\n    memset(table, 0, sizeof(table));\n    \n    int x = sx, y = sy, d = sd, tmp=sd;\n    int cost = 0;\n    \n    while(1) {\n\n\tif(visited[x][y][d]) break;\n\tvisited[x][y][d] = true;\n\n\tint h = d*10000 + y*100 + x;\n\t\n\ttable[h] = cost;\n\tcost++;\n\t\n\tfor(int i=0; i<4; i++) {\n\t    int td = (d + i)%4;\n\t    int tx = x + dx[td];\n\t    int ty = y + dy[td];\n\n\t    if(tx < 0 || ty < 0 || tx >= W || ty >= H) continue;\n\t    if(field[ty][tx] == '#') continue;\n\t    \n\t    d = td;\n\t    \n\t    break;\n\t}\n\n\t\n\tx += dx[d];\n\ty += dy[d];\t\n    }\n\n    \n    int ret = table[d*10000 + y*100 + x];\n\n    return make_pair(cost, ret);\n}\n\nint solve() \n{\n    pair<int, int> bfsres;\n\t\n    for(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t    for(int k=0; k<4; k++) {\n\t\tif(DtoS[k] == field[i][j])\n\t\t    bfsres = bfs(j, i, k);\n\t    }\n\n    ll length = bfsres.first;\n    ll bias = bfsres.second;\n    ll loopL = length - bias;\n\n    if ( L < bias) return table[L];\n    ll pos = (L-bias)%loopL + bias;    \n\n    int res = 0;\n    for(int i=0; i<40000; i++)\n\tif(table[i]==pos) res = i;\n\n    return res;\n}\n\nint main() \n{\n    while(cin >> H >> W >> L, (W||H||L)) {\n\tfor(int i=0; i<H; i++)\n\t    cin >> field[i];\n\n\tint res = solve();\n\tcout << ((res/100)%100 + 1) << \" \" << (res%100) + 1 << \" \" << DtoS[res/10000] << endl;\n    \n    }\n}\n\n\n\t\n\t\n\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define RFOR(i,a,b) for(int i=(int)(b-1);i>=(int)(a);--i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,n) for(int i=(int)(n-1);i>=0;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x)*(x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nconst char dirchar[] = {'W', 'S', 'E', 'N'};\n\nint H, W;\nbool field[100][100];\nint G[100][100][4];\n\nint main() {\n    ll L;\n    while (cin >> H >> W >> L, H|W|L) {\n        int x, y, dir;\n        fill_n((int *)G, 100*100, 0);\n        REP(yy, H) REP(xx, W) {\n            char c;\n            cin >> c;\n            field[yy][xx] = c == '#';\n            switch (c) {\n            case '.':\n            case '#':\n                break;\n            default:\n                x = xx;\n                y = yy;\n                dir = find(dirchar, dirchar+4, c)-dirchar;\n            }\n        }\n        bool mod = false;\n        int cnt = 0;\n        while (1) {\n            int sx = x + dx[dir], sy = y + dy[dir];\n            if (0 <= sx && sx < W && 0 <= sy && sy < H && !field[sy][sx]) {\n                x = sx;\n                y = sy;\n                cnt++;\n                if (cnt == L) {\n                    printf(\"%d %d %c\\n\", y+1, x+1, dirchar[dir]);\n                    break;\n                }\n            } else {\n                if (!mod && G[y][x][dir] == 1) {\n                    L %= cnt;\n                    cnt = 0;\n                    mod = true;\n                    if (cnt == L) {\n                        printf(\"%d %d %c\\n\", y+1, x+1, dirchar[dir]);\n                        break;\n                    }\n                }\n                while (1) {\n                    dir = (dir+3)%4;\n                    int sx = x + dx[dir], sy = y + dy[dir];\n                    if (0 <= sx && sx < W && 0 <= sy && sy < H && !field[sy][sx]) {\n                        break;\n                    }\n                }\n                G[y][x][dir]++;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define Y first.first\n#define X first.second\n#define D second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst string kDir = \"ESWN\";\nconst vi dx = { 1, 0,-1, 0};\nconst vi dy = { 0, 1, 0,-1};\n\ntypedef pair<pii, int> State;\n\nint main(void){\n    for(int h, w, L; cin >> h >> w >> L, h;){\n        vs field(h + 2);\n        rep(x, w + 2) field[0].pb('#'), field[h + 1].pb('#');\n\n        State cur;\n        \n        range(y, 1, h + 1){\n            string f; cin >> f;\n\n            field[y].pb('#');\n            field[y] += f;\n            field[y].pb('#');\n\n            range(x, 1, w + 1){\n                if(field[y][x] != '.' && field[y][x] != '#'){\n                    int d = kDir.find(field[y][x]);\n                    cur = mp(mp(y, x), d);\n\n                    field[y][x] = '.';\n                }\n            }\n        }\n\n        map<State, int> step;\n        int cnt_step = 0;\n\n        while(step.find(cur) == step.end()){\n            step[cur] = cnt_step;\n            pii next_pos = mp(cur.Y + dy[cur.D], cur.X + dx[cur.D]);\n\n            if(field[next_pos.first][next_pos.second] == '#'){\n               (cur.D += 1) %= kDir.size();\n            }\n            else{\n                cur.first = next_pos;\n                cnt_step++;\n            }\n        }\n\n        cnt_step -= step[cur];\n        L -= step[cur];\n        if(L >= 0) L %= cnt_step;\n        L += step[cur];\n\n        State res;\n        for(auto s : step){\n            if(s.second == L) res = s.first;\n        }\n\n        cout << res.Y << \" \" << res.X << \" \" << kDir[res.D] << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, char> State;\n\nint H, W, L;\nint cnt;\nchar tmp[110][110], field[110][110];\nState pos;\nvector<State> v;\nint Ls;\nchar dir[] = {'N', 'E', 'S', 'W'};\nint diry[] = {1, 0, -1, 0};\nint dirx[] = {0, 1, 0, -1};\n\n\nbool isVisited(State p){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].f.f == p.f.f && v[i].f.s == p.f.s && v[i].s == p.s){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid move(){\n  v.push_back(pos);\n  while(1){\n    if(pos.s == 'N'){\n      while(field[pos.f.s-1][pos.f.f] != '#'){\n\tpos.f.s--;\n\t//if(field[pos.f.s-1][pos.f.f] == '#') pos.s = 'E';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\t\n\tif(cnt == L) return;\n      }\n      pos.s = 'E';\n    }\n    \n    else if(pos.s == 'E'){\n      while(field[pos.f.s][pos.f.f+1] != '#'){\n\tpos.f.f++;\n\t//if(field[pos.f.s][pos.f.f+1] == '#') pos.s = 'S';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\tif(cnt == L) return;\n      }\n      pos.s = 'S';\n    }\n    \n    else if(pos.s == 'S'){\n      while(field[pos.f.s+1][pos.f.f] != '#'){\n\tpos.f.s++;\n\t//if(field[pos.f.s+1][pos.f.f] == '#') pos.s = 'W';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'W';\n    }\n    \n    else if(pos.s == 'W'){\n      while(field[pos.f.s][pos.f.f-1] != '#'){\n\tpos.f.f--;\n\t//if(field[pos.f.s][pos.f.f-1] == '#') pos.s = 'N';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'N';\n    }\n  }\n}\n\nvoid init(){\n  cnt = 0;\n  v.clear();\n  for(int i = 0 ; i <= H+1 ; i++){\n    field[i][0] = '#';\n    field[0][i] = '#';\n    field[H+1][i] = '#';\n    field[i][W+1] = '#';\n  }\n}\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    cin >> tmp[i];\n  }\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      field[i+1][j+1] = tmp[i][j];\n      if(isalpha(field[i+1][j+1])){\n\tpos.f.f = j+1, pos.f.s = i+1, pos.s = field[i+1][j+1];\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    if(H == 0 && W == 0 && L == 0) break;\n    \n    init();\n    input();\n    move();\n    \n    if(cnt == L){\n      cout << v[v.size()-1].f.s << ' ' << v[v.size()-1].f.f << ' ' << v[v.size()-1].s << endl;\n      continue;\n    }\n    else{\n      L -= cnt;\n      //cout << \"L = \" << L << endl;\n      //cout << \"Ls = \" << Ls << endl;\n      int range = v.size() - Ls;\n      //cout << \"range = \" << range << endl;\n      \n      //int r = L % (Ls+1) + 1;\n      //cout << \"r = \" << r << endl;\n      int ans;\n      if(range == 0) ans = Ls + L-1;\n      else ans = Ls + L % range;\n      //cout << \"ans = \" << ans << endl;\n      //cout << ans-1 << endl;\n\n      cout << v[ans].f.s << ' ' << v[ans].f.f << ' ' << v[ans].s << endl;\n    }    \n    /*\n    for(int i = 0 ; i < v.size() ; i++){\n      cout << i << \": x = \" << v[i].f.f << \", y = \" << v[i].f.s << \", D = \" << v[i].s << endl;\n    }\n    cout << endl;\n    */\n  }\n    \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\nusing namespace std;\nstruct state{\n  int x,y;\n  int c;\n  state(){}\n  state(int x,int y,int c):x(x),y(y),c(c){}\n};\nint h,w;\nlong long l;\nchar g[111][111];\nstate next[111][111][5];\nbool used[111][111][5];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nchar D[256];\nchar DD[4];\nint main(void)\n{\n  D['N']=0; DD[0]='N';\n  D['E']=1; DD[1]='E';\n  D['S']=2; DD[2]='S';\n  D['W']=3; DD[3]='W';\n  for(;;){\n    scanf(\"%d%d%lld\",&h,&w,&l); if(!h) break;\n    memset(used,0,sizeof(used));\n    int d,x,y;\n    memset(g,'#',sizeof(g));\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n        scanf(\" %c\",g[i]+j);\n        if(g[i][j]!='#' && g[i][j]!='.'){\n          x=j;\n          y=i;\n          d=D[int(g[i][j])];\n        }\n      }\n    }\n    vector<state> v;\n    for(;;){\n      int nx,ny,nd=d;\n      if(!l){\n        printf(\"%d %d %c\\n\",y,x,DD[d]);\n        goto NEXT;\n      }\n      if(used[y][x][d]){\n        v.push_back(state(x,y,d));\n        nx=x; ny=y; nd=d;\n        x=next[ny][nx][nd].x;\n        y=next[ny][nx][nd].y;\n        d=next[ny][nx][nd].c;\n        while(x!=nx || y!=ny || d!=nd){\n          int mx,my,md;\n          v.push_back(state(x,y,d));\n          mx=x; my=y; md=d;\n          x=next[my][mx][md].x;\n          y=next[my][mx][md].y;\n          d=next[my][mx][md].c;\n        }\n        l%=v.size();\n        printf(\"%d %d %c\\n\",v[l].y,v[l].x,DD[v[l].c]);\n        goto NEXT;\n      }\n      while(g[y+dy[nd]][x+dx[nd]]=='#'){\n        nd=(nd+1)%4;\n      }\n      nx=x+dx[nd];\n      ny=y+dy[nd];\n      used[y][x][d]=true;\n      next[y][x][d]=state(nx,ny,nd);\n      x=nx; y=ny; d=nd;\n      l--;\n    }\n  NEXT:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint dx[]={0,1,0,-1},\n\tdy[]={-1,0,1,0};\nint main()\n{\n\tint H,W,x,y,a,i,sx,sy;\n\tlong long L,count;\n\twhile(scanf(\"%d%d%lld\",&H,&W,&L),L)\n\t{\n\t\tchar*p,m[128][128]={},*A=\"NESW\";\n\t\tfor(i=1;i<=H;++i)\n\t\t{\n\t\t\tscanf(\"%s\",m[i]+1);\n\t\t\tif(p=strpbrk(m[i]+1,A))\n\t\t\t{\n\t\t\t\tx=p-m[i];\n\t\t\t\ty=i;\n\t\t\t\tswitch(*p)\n\t\t\t\t{\n\t\t\t\tcase'N':a=0;break;\n\t\t\t\tcase'E':a=1;break;\n\t\t\t\tcase'S':a=2;break;\n\t\t\t\tcase'W':a=3;break;\n\t\t\t\t}\n\t\t\t\t*p='.';\n\t\t\t}\n\t\t}\n\t\tlong long f[128][128][4]={};\n\t\tfor(count=0;L;++count,--L)\n\t\t{\n\t\t\tif(f[y][x][a])\n\t\t\t{\n\t\t\t\tL%=(count-f[y][x][a]);\n\t\t\t\tif(!L)break;\n\t\t\t}\n\t\t\tf[y][x][a]=count;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tsx=x+dx[a];\n\t\t\t\tsy=y+dy[a];\n\t\t\t\tif(m[sy][sx]=='.')break;\n\t\t\t\ta=(a+1)%4;\n\t\t\t}\n\t\t\tx=sx;y=sy;\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",y,x,a[A]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll h, w, l;\nstring c[110];\n\nll dir = 0;\nll px, py;\nll dx[] = { 0,1,0,-1 };\nll dy[] = { -1,0,1,0 };\nll d[4][110][110];\nll s = -1;\nll m = -1;\nstring t = \"NESW\";\n\nvoid solve() {\n\td[dir][py][px] = 0;\n\tll cnt = 0;\n\twhile (1) {\n\t\tcnt++;\n\t\tll nx, ny;\n\t\tll ndir = dir;\n\t\twhile (1) {\n\t\t\tnx = px + dx[ndir];\n\t\t\tny = py + dy[ndir];\n\t\t\tif (nx >= 0 && nx < w&&ny >= 0 && ny < h) {\n\t\t\t\tif (c[ny][nx] == '#')ndir = (ndir + 1) % 4;\n\t\t\t\telse break;\n\t\t\t}\n\t\t\telse ndir = (ndir + 1) % 4;\n\t\t}\n\t\tif (d[ndir][ny][nx] != INF) {\n\t\t\ts = d[ndir][ny][nx];\n\t\t\tm = cnt - s;\n\t\t\tbreak;\n\t\t}\n\t\td[ndir][ny][nx] = cnt;\n\t\tpx = nx;\n\t\tpy = ny;\n\t\tdir = ndir;\n\t}\n}\n\nint main() {\n\twhile (cin >> h >> w >> l&&h + w + l) {\n\t\trep(i, 4)rep(j, 110)rep(k, 110)d[i][j][k] = INF;\n\t\trep(i, h)cin >> c[i];\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif (c[i][j] != '.'&&c[i][j] != '#') {\n\t\t\t\t\tif (c[i][j] == 'N')dir = 0;\n\t\t\t\t\tif (c[i][j] == 'E')dir = 1;\n\t\t\t\t\tif (c[i][j] == 'S')dir = 2;\n\t\t\t\t\tif (c[i][j] == 'W')dir = 3;\n\t\t\t\t\tpy = i, px = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t\tif (l > s) {\n\t\t\t//cout << \"!!\" << endl;\n\t\t\tl -= s;\n\t\t\tl %= m;\n\t\t\tl += s;\n\t\t}\n\t\tll ans[3] = {};\n\t\trep(k, 4) {\n\t\t\trep(i, h) {\n\t\t\t\trep(j, w) {\n\t\t\t\t\tif (d[k][i][j] == l) {\n\t\t\t\t\t\tans[0] = k;\n\t\t\t\t\t\tans[1] = i;\n\t\t\t\t\t\tans[2] = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(k, 4) {\n\t\t//\trep(i, h) {\n\t\t//\t\trep(j, w) {\n\t\t//\t\t\tcout << d[k][i][j] << \" \";\n\t\t//\t\t}\n\t\t//\t\tcout << endl;\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << \"!\" << ans[0] << endl;\n\t\tcout << ans[1] + 1 << \" \" << ans[2] + 1 << \" \" << t[ans[0]] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        long long count = 0;\n        string wall = \"\";\n        int memo[101][101][4];\n        fill_n((int *)memo, 101*101*4, -1);\n\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n            }\n        }\n\n        memo[y][x][dir] = 0;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n            }\n            else {\n                dir = (dir+1) % 4;\n                continue;\n            }\n            if (memo[y][x][dir] != -1) {\n                l = l % (count - memo[y][x][dir]);\n            }\n            memo[y][x][dir] = count;\n        }\n        cout << y << \" \" << x << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <map>\n#define FI first\n#define SE second\nusing namespace std;\nconst double EPS = 1e-8;\nconst int MAXN = 105;\nconst int INF = 1111111111;\nchar g[MAXN][MAXN];\nint h,w;\nint dir[][2] = {{0,1},{1,0},{0,-1},{-1,0}};\nchar dirc[] = {'E','S','W','N'};\nlong long l;\npair<int,int> st;\nint way[MAXN][MAXN][4];\nint main() {\n    //freopen(\"F:\\\\code\\\\in.txt\",\"r\",stdin);\n\n    while (scanf (\"%d%d%lld\",&h,&w,&l)&&(h+w+l)) {\n        memset(way,0,sizeof(way));\n        for (int i = 1; i <= h; ++i) {\n            scanf (\"%s\",g[i]+1);\n            for (int j = 1; j <= w; ++j) {\n                if (g[i][j] >= 'A'&& g[i][j] <='Z') {\n                    st.first = i;\n                    st.second = j;\n                }\n            }\n            g[i][0] = g[i][w+1] = '#';\n            g[i][w+2] = '\\0';\n            //printf(\"%s\\n\",g[i]);\n        }\n        for (int i = 0; i <= w+1; ++i)\n            g[h+1][i] = g[0][i] = '#';\n        w+=2;\n        h+=2;\n        int dx,dy;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                if (g[i][j] == '#') continue;\n                for (int k = 0; k < 4; ++k) {\n\n                    dx = i + dir[k][0];\n                    dy = j + dir[k][1];\n                    int len = 0;\n                    while (dx >= 0&& dx< h &&dy >=0 &&dy < w&&g[dx][dy]!='#') {\n                        ++len;\n                        dx += dir[k][0];\n                        dy += dir[k][1];\n                    }\n                    way[i][j][k] = len;\n                }\n            }\n        }\n        int sdir;\n        int sx = st.first;\n        int sy = st.second;\n        if (g[sx][sy] == 'E') sdir = 0;\n        else if (g[sx][sy] == 'S') sdir = 1;\n        else if (g[sx][sy] == 'W') sdir = 2;\n        else if (g[sx][sy] == 'N') sdir = 3;\n        int tmp ;\n        int vis[MAXN][MAXN][4],len;\n        bool flag = 0;\n        len = 0;\n        memset(vis,0,sizeof(vis));\n        while(l>0) {\n            l--;\n            if (vis[sx][sy][sdir] == 1) {\n                flag = 1;\n            }\n            if (vis[sx][sy][sdir] == 2) break;\n            if (flag) ++len;\n\n            vis[sx][sy][sdir] += 1;\n            int tsx = sx + dir[sdir][0];\n            int tsy = sy + dir[sdir][1];\n            while (g[tsx][tsy] == '#') {\n\n                sdir = (sdir+1)%4;\n                tsx = sx + dir[sdir][0];\n                tsy = sy + dir[sdir][1];\n            }\n            sx = tsx;\n            sy = tsy;\n        }\n        if (len&&l)\n            l=l%len+1;\n         while(l>0) {\n            l--;\n            vis[sx][sy][sdir] += 1;\n            int tsx = sx + dir[sdir][0];\n            int tsy = sy + dir[sdir][1];\n            while (g[tsx][tsy] == '#') {\n                sdir = (sdir+1)%4;\n                tsx = sx + dir[sdir][0];\n                tsy = sy + dir[sdir][1];\n            }\n            sx = tsx;\n            sy = tsy;\n        }\n        int tsx = sx + dir[sdir][0];\n        int tsy = sy + dir[sdir][1];\n        while (g[tsx][tsy] == '#') {\n            sdir = (sdir+1)%4;\n            tsx = sx + dir[sdir][0];\n            tsy = sy + dir[sdir][1];\n        }\n        printf(\"%d %d %c\\n\",sx,sy,dirc[sdir]);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1}, H, W;\nstring dir[] = {\"N\",\"E\",\"S\",\"W\"};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nstring dfs(vector<string> &C, vector< vector< vector<int> > > &T,\n           int x, int y, long long int l, int d){\n  string ret = \"!\";\n  while(ret == \"!\"){\n    if(T[x][y][d] > 0){\n      l %= (T[x][y][d]-l);\n    }else{\n      T[x][y][d] = l;\n    }\n    \n    if(l == 0){\n      ret = to_string(x+1) + \" \" + to_string(y+1) + \" \" + dir[d];\n    }\n  \n    for(int i = 0; i < 4; ++i){\n      int d_ = (d+i)%4, x_ = x + dx[d_], y_ = y + dy[d_];\n      //--l;\n      if(in_range(x_,H) && in_range(y_,W) && C[x_][y_] != '#'){\n        x = x_;\n        y = y_;\n        --l;\n        d = d_;\n        break;\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  long long L;\n  while(cin >> H >> W >> L, H){\n    vector<string> C(H);\n    int s_x, s_y, d;\n    for(int i = 0; i < H; ++i){\n      cin >> C[i];\n      for(int j = 0; j < W; ++j){\n        if(C[i][j] != '.' && C[i][j] != '#'){\n          s_x = i;\n          s_y = j;\n          if(C[i][j] == 'N') d = 0;\n          if(C[i][j] == 'E') d = 1;\n          if(C[i][j] == 'S') d = 2;\n          if(C[i][j] == 'W') d = 3;\n        }\n      }\n    }\n    vector< vector< vector<int> > > T(H,vector< vector<int> >(W,vector<int>(4,-1)));\n    cout << dfs(C,T,s_x,s_y,L,d) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf=1e9;\ntypedef long long ll;\nll H,W,L;\nint sx,sy;\nstring board[105];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstruct State\n{\n\tint y,x,dir;\n\tState(int y,int x,int dir):\n\ty(y),x(x),dir(dir){};\n\tbool operator==(const State &a) const{\n\t\treturn((a.y==y)&&(a.x==x)&&(a.dir==dir));\n\t}\n};\nset<tuple<int,int,int> > st;\nvector<tuple<int,int,int> > IndexState;\nvector<tuple<int,int,int> > loopState;\ntuple<int,int,int> laststate;\nbool outrange(int y,int x)\n{\n\tif(y<0 || y>=H || x<0 || x>=W || board[y][x]=='#') return true;\n\telse return false;\n}\n\nvoid simulation(int y,int x,int dir)\n{\n\tint nowy=y,nowx=x;\n\tbool clear=false;\n\twhile(!clear)\n\t{\n\t\tint ny,nx;\n\t\twhile(1)\n\t\t{\t\n\t\t\tny=nowy+dy[dir],nx=nowx+dx[dir];\n\t\t\tif(!outrange(ny,nx))nowy=ny,nowx=nx;\n\t\t\telse \n\t\t\t{\n\t\t\t\tdir=(dir+1)%4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tauto it=st.find(make_tuple(ny,nx,dir));\n\t\t\tif(it!=st.end()) \n\t\t\t{\n\t\t\t\tlaststate=(make_tuple(ny,nx,dir));\n\t\t\t\tclear=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIndexState.push_back(make_tuple(ny,nx,dir));\n\t\t\t\tst.insert(make_tuple(ny,nx,dir));\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint dir;\n\twhile(cin >> H >> W >> L && H)\n\t{\n\t\tst.clear();\n\t\tIndexState.clear();\n\t\tloopState.clear();\n\t\tfor(int i=0;i<H;i++)\n\t\t{\n\t\t\tcin >> board[i];\n\t\t\tfor(int j=0;j<W;j++)\n\t\t\t{\n\t\t\t\tif(board[i][j]=='N') sy=i,sx=j,dir=0;\n\t\t\t\telse if(board[i][j]=='E') sy=i,sx=j,dir=1;\n\t\t\t\telse if(board[i][j]=='S') sy=i,sx=j,dir=2;\n\t\t\t\telse if(board[i][j]=='W') sy=i,sx=j,dir=3;\n\t\t\t}\n\t\t}\n\t\t//st.insert(make_tuple(sy,sx,dir));\n\t\t//IndexState.push_back(make_tuple(sy,sx,dir));\n\t\tsimulation(sy,sx,dir);\n\t\tint mod=int(st.size());\n\t\tint beforelooplast=-1;\n\t\tfor(int i=mod-1;i>=0;i--)\n\t\t{\n\t\t\tif(laststate==make_tuple(get<0>(IndexState[i]),get<1>(IndexState[i]),get<2>(IndexState[i])))\n\t\t\t{\n\t\t\t\tbeforelooplast=i+1;\n\t\t\t\tloopState.push_back(make_tuple(get<0>(IndexState[i]),get<1>(IndexState[i]),get<2>(IndexState[i])));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tloopState.push_back(make_tuple(get<0>(IndexState[i]),get<1>(IndexState[i]),get<2>(IndexState[i])));\n\t\t}\n\t\tif(loopState.size()!=0) reverse(loopState.begin(),loopState.end());\n\t\t/* \n\t\tfor(int i=0;i<mod;i++)\n\t\t{\n\t\t\tcout << get<0>(IndexState[i])+1 << ' ' << get<1>(IndexState[i])+1 << ' ' << get<2>(IndexState[i]) << endl;\n\t\t}\n\t\tcout << \"LOOP\" << endl;\n\t\tfor(int i=0;i<int(loopState.size());i++)\n\t\t{\n\t\t\tcout << get<0>(loopState[i])+1 << ' ' << get<1>(loopState[i])+1 << ' ' << get<2>(loopState[i]) << endl;\n\t\t}*/\n\t\tchar lastdir;\n\t\t//cout << beforelooplast << \" Beforeloop\" << endl;\n\t\tassert(beforelooplast!=-1);\n\t\tif(L<=beforelooplast)\n\t\t{\n\t\t\tif(get<2>(IndexState[(L+mod-1)%mod])==0)\n\t\t\t{\n\t\t\t\tlastdir='N';\n\t\t\t}\n\t\t\tif(get<2>(IndexState[(L+mod-1)%mod])==1)\n\t\t\t{\n\t\t\t\tlastdir='E';\n\t\t\t}\n\t\t\tif(get<2>(IndexState[(L+mod-1)%mod])==2)\n\t\t\t{\n\t\t\t\tlastdir='S';\n\t\t\t}\n\t\t\tif(get<2>(IndexState[(L+mod-1)%mod])==3)\n\t\t\t{\n\t\t\t\tlastdir='W';\n\t\t\t}\n\t\t\tcout << get<0>(IndexState[((L+mod-1)%mod)])+1 << ' ' << get<1>(IndexState[(L+mod-1)%mod])+1 << ' ' << lastdir<< endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tL-=beforelooplast;\n\t\t\tmod=int(loopState.size());\n\t\t\tif(get<2>(loopState[(L)%mod])==0)\n\t\t\t{\n\t\t\t\tlastdir='N';\n\t\t\t}\n\t\t\tif(get<2>(loopState[(L)%mod])==1)\n\t\t\t{\n\t\t\t\tlastdir='E';\n\t\t\t}\n\t\t\tif(get<2>(loopState[(L)%mod])==2)\n\t\t\t{\n\t\t\t\tlastdir='S';\n\t\t\t}\n\t\t\tif(get<2>(loopState[(L)%mod])==3)\n\t\t\t{\n\t\t\t\tlastdir='W';\n\t\t\t}\n\t\t\tcout << get<0>(loopState[((L)%mod)])+1 << ' ' << get<1>(loopState[(L)%mod])+1 << ' ' << lastdir<< endl;\n\t\t}\n\t\t\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * 2320.cc: Infinity Maze\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 100;\nconst int MAX_W = 100;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\nconst char dcs[] = {'E', 'N', 'W', 'S'};\n\ntypedef long long ll;\n\n/* typedef */\n\nstruct Robot {\n  int x, y, di;\n  Robot() {}\n  Robot(int _x, int _y, int _di): x(_x), y(_y), di(_di) {}\n};\n\n/* global variables */\n\nbool flds[MAX_H][MAX_W];\nint cache[MAX_H][MAX_W][4];\nRobot rs[MAX_H * MAX_W * 4];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int h, w;\n    ll l;\n    cin >> h >> w >> l;\n    if (h == 0) break;\n\n    memset(flds, true, sizeof(flds));\n    memset(cache, -1, sizeof(cache));\n\n    int rx, ry, rd;\n    \n    for (int y = 0; y < h; y++) {\n      string s;\n      cin >> s;\n      for (int x = 0; x < w; x++)\n\tswitch (s[x]) {\n\tcase 'E': rx = x; ry = y; rd = 0; break;\n\tcase 'N': rx = x; ry = y; rd = 1; break;\n\tcase 'W': rx = x; ry = y; rd = 2; break;\n\tcase 'S': rx = x; ry = y; rd = 3; break;\n\tcase '#': flds[y][x] = false; break;\n\t}\n    }\n\n    int d = 0;\n    while (cache[ry][rx][rd] < 0) {\n      rs[d] = Robot(rx, ry, rd);\n      cache[ry][rx][rd] = d++;\n      for (;;) {\n\tint x = rx + dxs[rd], y = ry + dys[rd];\n\tif (x >= 0 && x < w && y >= 0 && y < h && flds[y][x]) {\n\t  rx = x; ry = y;\n\t  break;\n\t}\n\trd = (rd + 3) % 4;\n      }\n    }\n\n    int c = cache[ry][rx][rd];\n    if (l <= c) {\n      Robot &rl = rs[l];\n      printf(\"%d %d %c\\n\", rl.y + 1, rl.x + 1, dcs[rl.di]);\n    }\n    else {\n      Robot &rl = rs[(l - c) % (d - c) + c];\n      printf(\"%d %d %c\\n\", rl.y + 1, rl.x + 1, dcs[rl.di]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  ll i,j,k;\n  ll dp[105][105][4]={{{}}};\n  string st[105];\n  char c[]={'E','S','W','N'};\n  ll rx,ry,rd;\n  ll ax[]={1,0,-1,0};\n  ll ay[]={0,1,0,-1};\n  bool f;\n  \n  while(cin>>h>>w>>l,h||w||l){\n    \n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    \n    fill(dp[0][0],dp[104][104],0);\n    f = true;\n    \n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      \n      if(dp[ry][rx][rd]==0){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\tll s = i-dp[ry][rx][rd];\n\tl=i+(l-i)%s;\n\tf=false;\n      }\n\n      if(i==l) break;\n      \n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n      \n    }\n    cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\nusing namespace std;\n\ntypedef long long LL;\n\nint h, w;\nLL L;\nint visit[102][102][4];\nint log[41000];\nchar c[102][102];\n\nint main(){\n\tconst string dirstr = \"NESW\";\n\tint dy[] = {-1, 0, 1, 0};\n\tint dx[] = {0, 1, 0, -1};\n\n\twhile(scanf(\"%d%d%lld\", &h, &w, &L), h){\n\t\tmemset(visit, -1, sizeof visit);\n\t\tmemset(c, '#', sizeof c);\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tscanf(\"%s\", c[i] + 1);\n\t\t\tc[i][w + 1] = '#';\n\t\t}\n\n\t\tint y, x, d;\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif(c[i][j] != '.' && c[i][j] != '#'){\n\t\t\t\ty = i;\n\t\t\t\tx = j;\n\t\t\t\td = dirstr.find(c[i][j]);\n\t\t\t\tc[i][j] = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(LL t = 0; ;){\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(c[ny][nx] != '#'){\n\t\t\t\t++t;\n\t\t\t\tlog[t] = (ny << 10) | (nx << 2) | d;\n\t\t\t\ty = ny;\n\t\t\t\tx = nx;\n\n\t\t\t\tif(t == L){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\td = (d + 1) & 3;\n\t\t\t}\n\n\t\t\tint p = visit[y][x][d];\n\t\t\tif(p < 0){\n\t\t\t\tvisit[y][x][d] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLL dif = t - p;\n\t\t\t\tLL rem = (L - t) % dif;\n\t\t\t\tint q = log[p + rem];\n\t\t\t\ty = q >> 10;\n\t\t\t\tx = (q >> 2) & 0xff;\n\t\t\t\td = q & 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d %c\\n\", y, x, dirstr[d]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_H 110\n#define MAX_W 110\ntypedef long long ll;\n \nll H,W,L;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n \nchar getDir(int x){\n    if(x == 0) return 'W'; \n    if(x == 1) return 'N'; \n    if(x == 2) return 'E'; \n    if(x == 3) return 'S'; \n}\n \nint getDir(char ch){\n    if(ch == 'W') return 0; \n    if(ch == 'N') return 1; \n    if(ch == 'E') return 2; \n    if(ch == 'S') return 3; \n}\n \nbool inField(int x,int y){\n    return (0 <= x && x < W && 0 <= y && y < H);\n}\n \nvoid solve(int x,int y,int dir){\n    int d[MAX_H][MAX_W][4];\n    memset(d,-1,sizeof(d));\n    d[y][x][dir] = 0;\n \n    while(L > 0){\n\tint nx = x + dx[dir],ny = y + dy[dir];\n\tif(!inField(nx,ny) || field[ny][nx] == '#'){\n\t    int ndir = (dir+1) % 4;\n\t    if(d[y][x][ndir] == -1){\n\t\td[y][x][ndir] = d[y][x][dir];\n\t    }else{\n\t\tint diff = d[y][x][dir]-d[y][x][ndir];\n\t\tif(diff > 0 && L >= diff){\n\t\t    L %= diff;\n\t\t}\n\t    }\n\t    if(L != 0){\n\t\tdir = ndir;\n\t    }\n\t}else{\n\t    if(d[ny][nx][dir] == -1){\n\t\td[ny][nx][dir] = d[y][x][dir]+1;\n\t\tL--;\n\t    }else{\n\t\tL--;\n\t\tint diff = d[y][x][dir]+1-d[ny][nx][dir];\n\t\tif(diff > 0 && L >= diff){\n\t\t    L %= diff;\n\t\t}\n\t    }\n\t    x = nx; y = ny;\n\t}\n    }\n    cout << y+1 << \" \" << x+1 << \" \" << getDir(dir) << endl;\n}\n \nbool check(char ch){\n    if(ch == '.' || ch == '#'){\n\treturn false;\n    }\n    return true;\n}\n \nint main(){\n    int sx,sy,dir;\n    while(true){\n\tcin >> H >> W >> L;\n\tif(H == 0 && W == 0 && L == 0){\n\t    break;\n\t}\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> field[i][j];\n\t\tif(check(field[i][j])){\n\t\t    sx = j; sy = i;\n\t\t    dir = getDir(field[i][j]);\n\t\t    field[i][j] = '.';\n\t\t}\n\t    }\n\t}\n\tsolve(sx,sy,dir);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#define maxn 111\nusing namespace std;\n\nint mp[maxn][maxn];\nchar s[maxn][maxn];\nint dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nchar dd[4][5] = {\"E\",\"S\",\"W\",\"N\"};\nint dic[maxn][maxn][4];\n\nstruct I\n{\n    int x, y, d;\n};\nvector <I> vec;\n\nint H, W;\nlong long L;\n\nint check(int x, int y)\n{\n    if(x > 0 && x <= H && y > 0 && y <= W && mp[x][y] == 1)\n    {\n        return 1;\n    }\n    return 0;\n}\nvoid step(int x, int y, int sd)\n{\n\n    I tmp;\n    tmp.x = x;\n    tmp.y = y;\n    tmp.d = sd;\n    vec.push_back(tmp);\n\n    if (dic[x][y][sd] == 1)\n    {\n        return ;\n    }\n\n    dic[x][y][sd] = 1;\n\n    int xx, yy;\n    while (1)\n    {\n        xx = x + dir[sd][0];\n        yy = y + dir[sd][1];\n        if (check(xx,yy)){\n            step(xx,yy,sd);\n            break;\n        }\n        sd = (sd + 1) % 4;\n    }\n    return ;\n}\n\nint main()\n{\n    while(scanf(\"%d%d%lld\", &H, &W, &L))\n    {\n        if(H == 0 && W == 0 && L == 0)\n        {\n            break ;\n        }\n        memset(mp, 0, sizeof(mp));\n        memset(s, 0, sizeof(s));\n        for(int i = 0; i < H; i++)\n        {\n            scanf(\"%s\", s[i]);\n        }\n        int si, sj, sdir;\n        for(int i = 0; i < H; i++)\n        {\n            for(int j = 0; j < W; j++)\n            {\n                if(s[i][j] == '#')\n                {\n                    mp[i + 1][j + 1] = 0;\n                }\n                else\n                {\n                    mp[i + 1][j + 1] = 1;\n                    if(s[i][j] != '.')\n                    {\n                        si = i + 1;\n                        sj = j + 1;\n                        if(s[i][j] == 'E')\n                        {\n                            sdir = 0;\n                        }\n                        else if(s[i][j] == 'S')\n                        {\n                            sdir = 1;\n                        }\n                        else if(s[i][j] == 'W')\n                        {\n                            sdir = 2;\n                        }\n                        else\n                        {\n                            sdir = 3;\n                        }\n                    }\n                }\n            }\n        }\n        memset(dic, 0, sizeof(dic));\n\n        //dic[si][sj][sdir] = 1;\n        int num = 0;\n        vec.clear();\n        step(si, sj, sdir);\n\n        int sz = vec.size();\n        int t = 0;\n\n        //puts(\"**************************\");\n        //printf(\"%d\\n\",sz);\n\n        for (int i=0; i<sz; i++)\n        {\n            if (vec[i].x  == vec[sz-1].x && vec[i].y == vec[sz -1].y && vec[i].d == vec[sz-1].d)\n            {\n                t = i;\n                break;\n            }\n        }\n\n        int s = sz - t - 1;\n        int ans = 0;\n\n\n        //printf(\"%d %d\\n\",s, t);\n        if (L < t)\n        {\n            ans = (int)L;\n        }\n        else\n        {\n            ans = (int)t + (int)((L - t) % s);\n        }\n\n        //printf(\"%d\\n\",ans);\n        //int ansi = vec[L].x, ansj = vec[L].y, ansd = vec[L].d;\n\n\n        printf(\"%d %d %s\\n\", vec[ans].x, vec[ans].y, dd[vec[ans].d]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W; ll L;\nint dir, y, x, cost;\nstring const ds = \"WNES\";\n\nmap<tuple<int, int, int>, int> vis;\nvector<tuple<int, int, int>> data_;\nchar G[111][111];\n\nbool in_range(int y, int x, int H, int W) {\n  if(!(0<=y&&y<H&&0<=x&&x<W)) return false;\n  if(G[y][x] == '#') return false;\n  return true;\n}\n\nvoid adjust_dir() {\n  while(!in_range(y + dy[dir], x + dx[dir], H, W)) {\n    dir ++;\n    dir %= 4;\n  }\n}\n\nbool step() {\n  adjust_dir();\n  y += dy[dir], x += dx[dir];\n  cost ++;\n  if(vis.find({y, x, dir}) != vis.end()) {\n    int len = cost - vis[{y, x, dir}];\n    L -= cost;\n    L %= len;\n    int y, x, d; tie(y, x, d) = data_[L];\n    cout << y+1 << \" \" << x+1 << \" \" << ds[d] << endl;\n    return false;\n  }\n  if(cost == L) {\n    cout << y+1 << \" \" << x+1 << \" \" << ds[dir] << endl;\n    return false;\n  }\n  return true;\n}\n\nvoid simulate() {\n\n  vis.clear();\n  data_.clear();\n  cost = 0;\n\n  while(step());\n}\n\nint main() {\n\n  for(; cin >> H >> W >> L && (H | W | L);) {\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if(isalpha(G[i][j])) {\n        y = i, x = j;\n        dir = ds.find(G[i][j]);\n      }\n    }\n\n    simulate();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nchar c[110][110];\nint d[110][110][4];\nint h, w, l;\nstring str = \"NESW\";\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> h >> w >> l;\n        if(h + w + l == 0) break;\n        int dr = 0, y = 0, x = 0;\n        rep(i, 0, 110) rep(j, 0, 110) rep(k, 0, 4) d[i][j][k] = -1;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> c[i][j];\n                if(str.find(c[i][j]) != string::npos){\n                    dr = str.find(c[i][j]);\n                    y = i; x = j;\n                }\n            }\n        }\n        d[y][x][dr] = 0;\n        vector<PP> sv;\n        sv.push_back(PP(P(y, x), dr));\n        for(int i = 1;; i++){\n            int ny = 0, nx = 0;\n            while(1){\n                ny = y + dy[dr];\n                nx = x + dx[dr];\n                if(contain(ny, nx) && c[ny][nx] != '#'){\n                    break;\n                }\n                dr = (dr + 1) % 4;\n            }\n            y = ny; x = nx;    \n            if(i == l){\n                cout << y + 1 << ' ' << x + 1 << ' ' << str[dr] << endl;\n                break;\n            }        \n            if(d[y][x][dr] != -1){\n                int loop = i - d[y][x][dr];\n                int step = d[y][x][dr] + (l - d[y][x][dr]) % loop;\n                //cerr << loop << ' ' << step << endl;\n                cout << sv[step].first.first + 1 << ' ' << sv[step].first.second + 1 << ' ' << str[sv[step].second] << endl;\n                break;\n            }\n            d[y][x][dr] = i;\n            sv.push_back(PP(P(y, x), dr));\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nchar cells[100][100];\nint visited[100][100][4];\nint visitt[100][100][4];\nint visitbef[100][100][2];\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nchar d[4]={'N','E','S','W'};\n\nint main(){\n  while(1){\n    int posx,posy,befx,befy,dir;\n    int h,w,walk=0,flag=0;\n    long long l;\n    cin >> h >> w >> l;\n    if (h==0)break;\n    rep(i,h){\n      string s;\n      cin >> s;\n      rep(j,w){\n        cells[i][j] = s[j];\n        if (s[j]!='.'&&s[j]!='#'){\n          posx = i;\n          posy = j;\n          if (s[j]=='N'){\n            dir = 0;\n          } else if (s[j]=='E'){\n            dir = 1;\n          } else if (s[j]=='S'){\n            dir = 2;\n          } else {\n            dir = 3;\n          }\n        }\n      }\n    }\n    rep(i,h)rep(j,w)rep(k,4){visited[i][j][k]=0;visitt[i][j][k]=-1;}\n    visited[posx][posy][dir]=1;\n    visitt[posx][posy][dir]=0;\n    while(l>0){\n      if (posx+dx[dir]>=0&&posx+dx[dir]<h&&posy+dy[dir]>=0&&posy+dy[dir]<w){\n        if (cells[posx+dx[dir]][posy+dy[dir]]!='#'){\n          befx = posx;\n          befy = posy;\n          posx += dx[dir];\n          posy += dy[dir];\n          cells[posx][posy]='@';\n          if (visited[posx][posy][dir]==0){\n            l--;\n            walk++;\n            visited[posx][posy][dir]=1;\n            visitt[posx][posy][dir]=walk;\n            visitbef[posx][posy][0] = befx;\n            visitbef[posx][posy][1] = befy;\n          } else if (flag==0&&visitbef[posx][posy][0]==befx&&visitbef[posx][posy][1]==befy){\n            l = l%(walk-visitt[posx][posy][dir]+1)-1+(walk-visitt[posx][posy][dir]+1);\n            flag=1;\n          } else if (flag==0){\n            l--;\n            walk++;\n            visitt[posx][posy][dir]=walk;\n          } else {\n            l--;\n          }\n        } else {\n          dir++;\n          if (dir==4)dir=0;\n          if (visited[posx][posy][dir]==0){\n            visited[posx][posy][dir]=1;\n            visitt[posx][posy][dir]=walk;\n          } else if(flag==0&&visitbef[posx][posy][0]==befx&&visitbef[posx][posy][1]==befy&&cells[posx+dx[dir-1]][posy+dy[dir-1]]!='#'&&posx+dx[dir-1]>=0&&posx+dx[dir-1]<h&&posy+dy[dir-1]>=0&&posy+dy[dir-1]<w){\n            l = l%(walk-visitt[posx][posy][dir]);\n            flag = 1;\n          }\n        }\n      } else {\n        dir++;\n        if (dir==4)dir=0;\n        if (visited[posx][posy][dir]==0){\n          visited[posx][posy][dir]=1;\n          visitt[posx][posy][dir]=walk;\n        } else if (flag==0&&visitbef[posx][posy][0]==befx&&visitbef[posx][posy][1]==befy&&cells[posx+dx[dir-1]][posy+dy[dir-1]]!='#'&&posx+dx[dir-1]>=0&&posx+dx[dir-1]<h&&posy+dy[dir-1]>=0&&posy+dy[dir-1]<w) {\n          l = l%(walk-visitt[posx][posy][dir])+(walk-visitt[posx][posy][dir]);\n          flag = 1;\n        }\n      }\n    }\n    cout << posx+1 << \" \" << posy+1 << \" \" << d[dir]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct State {\n  int x, y, d;\n  long long l;\n  State(){}\n  State(int x, int y, int d, long long l):x(x), y(y), d(d), l(l){}\n};\n  \nint H, W;\nlong long L;\nint sx, sy, sd;\nchar maze[101][101];\n\nint dist[4][101][101];\n\nconst string dir = \"NESW\";\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nState bfs()\n{\n  queue<State> que; que.push(State(sx, sy, sd, L));\n  memset(dist, -1, sizeof(dist));\n  dist[sd][sy][sx] = 0;\n  while(!que.empty()) {\n    State p = que.front(); que.pop();\n    if(p.l == 0LL) return p;    \n    int nx = p.x+dx[p.d], ny = p.y+dy[p.d];\n    long long nl = p.l;\n    if(0 <= nx && nx < W && 0 <= ny && ny < H && maze[ny][nx] != '#') {\n      nl--;\n      if(dist[p.d][ny][nx] != -1) {\n\tnl %= (dist[p.d][p.y][p.x]+1 - dist[p.d][ny][nx]);\n\tmemset(dist, -1, sizeof(dist));\n      } \n      dist[p.d][ny][nx] = dist[p.d][p.y][p.x] + 1;\n      que.push(State(nx, ny, p.d, nl));\n    } else {\n      if(dist[(p.d+1)%4][p.y][p.x] != -1) {\n\tnl %= (dist[p.d][p.y][p.x] - dist[(p.d+1)%4][p.y][p.x]);\n\tmemset(dist, -1, sizeof(dist));\t\n      }\n      dist[(p.d+1)%4][p.y][p.x] = dist[p.d][p.y][p.x];\n      que.push(State(p.x, p.y, (p.d+1)%4, nl));\n    }\n  }\n}\n\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(maze, 0, sizeof(maze));\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n\tcin >> maze[i][j];\n\tif(dir.find(maze[i][j]) != string::npos) {\n\t  sy = i, sx = j, sd = dir.find(maze[i][j]);\n\t}\n      }\n    }\n    State s = bfs();\n    cout << s.y+1 << \" \" << s.x+1 << \" \" << dir[s.d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint main(void){\n\tlong long int i, l, flag[100][100][4], dx[4] = {0,1,0,-1},dy[4] = {-1,0,1,0}, h, w, d, j, k, x, y;\n\tchar str[100][101], dir[5] = {\"NESW\"};\n\twhile(1){\n\t\tscanf(\"%lld%lld%lld%*c\",&h,&w,&l);\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tstr[i][j] = getchar();\n\t\t\t\tif(isupper(str[i][j])){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tfor(k = 0;k < 4;k++)\n\t\t\t\t\t\tif(str[i][j] == dir[k]) d = k;\n\t\t\t\t\tstr[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr[i][j] = '\\0';\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tfor(i = 0;i < l;i++){\n\t\t\tif(flag[y][x][d] == -1)\n\t\t\t\tflag[y][x][d] = i;\n\t\t\telse{\n\t\t\t\ti += (i - flag[y][x][d]) * ((l - i) / (i - flag[y][x][d])) - 1;\n\t\t\t\tmemset(flag,-1,sizeof(flag));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(x + dx[d] >= 0 && x + dx[d] < w && y + dy[d] >= 0 && y + dy[d] < h && str[y + dy[d]][x + dx[d]] == '.'){\n\t\t\t\t\tx = x + dx[d];\n\t\t\t\t\ty = y + dy[d];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld %lld %c\\n\",y + 1,x + 1,dir[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(long long h,w,l;cin>>h>>w>>l,h|w|l;){\n    bool s[102][102]={};\n    int x,y,d;\n    string ds=\"NESW\";\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tchar c;\n\tcin>>c;\n\ts[i][j]=c!='#';\n\tif(c!='#'&&c!='.'){\n\t  x=j;\n\t  y=i;\n\t  d=ds.find(c);\n\t}\n      }\n    }\n    int p[102][102][4];\n    fill(p[0][0],p[102][0],-1);\n    while(l){\n      int dx[]={0,1,0,-1};\n      int dy[]={-1,0,1,0};\n      for(;;){\n\tif(p[y][x][d]!=-1){\n\t  l%=(p[y][x][d]-l);\n\t}\n\tp[y][x][d]=l;\n\tif(s[y+dy[d]][x+dx[d]])break;\n\td=(d+1)%4;\n      }\n      y+=dy[d];\n      x+=dx[d];\n      l--;\n    }\n    cout<<y<<' '<<x<<' '<<ds[d]<<endl;\n  }\n  return 0;\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nchar field[110][110];\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint dx[4]   = {-1, 0, 1, 0};\nint dy[4]   = {0, 1, 0, -1};\n\nll memo[110][110][4];\nint main(){\n  ll H, W, L;\n  while(cin >>H >> W >> L && H + W + L){\n    fill(&field[0][0],&field[0][0] + 110 * 110, '#');\n    memset(memo, -1, sizeof(memo));\n\n    int x, y, d;\n    REP(i, H)REP(j, W){\n      cin >> field[i+1][j+1];\n      if(isalpha(field[i+1][j+1])){\n        x = i + 1;\n        y = j + 1;\n        d = find(dir, dir + 4, field[i+1][j+1]) - dir;\n      }\n    }\n\n    ll T = 0;\n    bool flag = false;\n    while(L > 0){\n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      if(field[nx][ny] == '#'){\n        d = (d + 1) % 4;\n      }else{\n        if(memo[x][y][d] >= 0 && !flag){\n          ll S = T - memo[x][y][d];\n          L %= S;\n          flag = true;\n        }\n        memo[x][y][d] = T++;\n        x = nx;\n        y = ny;\n        L--;\n      }\n    }\n    cout << x<< \" \" << y<< \" \" << dir[d] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W, L;\nvector<string> maze;\nvector<vector<vector<int> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<int> >(W, vector<int>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    int T = min(L, H * W * 4);\n    for(int step=0; step<=T;){\n        if(vis[x][y][d] != -1){\n            L = vis[x][y][d] + (L - step) % (step - vis[x][y][d]);\n            break;\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        if(!inrect(nx, ny) || maze[nx][ny] == '#')(d += 1) %= 4;\n        else x = nx, y = ny, step++;\n    }\n    // FIX LINE (this can't be accepted)\n    rep(i, H)rep(j, W)rep(k, 4)if(vis[i][j][k] == L)return make_tuple(i+1, j+1, \"NESW\"[k]);\n    return make_tuple(-1, -1, '?');\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ntypedef long long ll;\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nconst int _dx[] = { 0, 1, 0,-1};\nconst int _dy[] = {-1, 0, 1, 0};\nint dir[256];\n\nenum DIR{\n  NORTH = 0,\n  EAST  = 1,\n  SOUTH = 2,\n  WEST  = 3\n};\n\nstring g[100];\nint memo[100][100][4];\nint h, w;\nll l;\nstring dir2str = \"NESW\";\n\n\nbool cango(int x, int y, int d){\n  int xx = x + _dx[d];\n  int yy = y + _dy[d];\n\n  return ISIN(xx, yy, w, h) && g[yy][xx] == '.';\n}\n\nint main(){\n  dir['N'] = NORTH;\n  dir['E'] = EAST;\n  dir['S'] = SOUTH;\n  dir['W'] = WEST;\n\n  while(cin >> h >> w >> l, h + w + l){\n    int sx, sy, sd;\n\n    REP(i,h) cin >> g[i];\n\n    REP(i,h) REP(j,w){\n      if(g[i][j] != '.' && g[i][j] != '#'){\n        sx = j; sy = i; sd = dir[g[i][j]];\n        g[i][j] = '.';\n      }\n      REP(k, 4) memo[i][j][k] = -1;\n    }\n\n    for(ll turn = 0; turn < l; turn++){\n      // cout << \"turn: \" << turn << \" \" << sy + 1 << \" \" << sx + 1 << \" \" << dir2str[sd] << endl;\n\n      REP(k, 4){\n        if(cango(sx, sy, sd)) break;\n        sd = (sd + 1) % 4;\n      }\n\n      sx += _dx[sd];\n      sy += _dy[sd];\n\n      if(memo[sy][sx][sd] == -1){\n        memo[sy][sx][sd] = turn + 1;\n      }else{\n        int cycle = (turn + 1) - memo[sy][sx][sd];\n        ll tmp = (l - (turn + 1)) % cycle +  memo[sy][sx][sd];\n\n        // cout << \"tmp: \" << tmp << endl;\n        // cout << \"cycle: \" << cycle << endl;\n\n        REP(i,h) REP(j,w) REP(k,4){\n          if(memo[i][j][k] == tmp){\n            sx = j; sy = i; sd = k;\n            goto end;\n          }\n        }\n      end:;\n        break;\n      }\n    }\n\n    cout << sy + 1 << \" \" << sx + 1 << \" \" << dir2str[sd] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define N 105\nusing namespace std;\ntypedef long long ll;\nchar Rot(char);\nint GetNum(char);\n\nint main(){\n  int h,w,y,x,r,me[N][N][4];\n  char c;\n  string s[N];\n  ll l,t;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tfor(int k=0;k<4;k++) me[i][j][k]=-1;\n      }\n    t=0;\n    r=GetNum(c);\n    me[y][x][r]=t;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      if(l==t) break;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      r=GetNum(c);\n      if(me[y][x][r]!=-1&&t-me[y][x][r]!=0) t=l-((l-me[y][x][r])%(t-me[y][x][r]));\n      me[ny][nx][r]=t;\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}\n\nint GetNum(char c){\n  if(c=='N') return 0;\n  if(c=='E') return 1;\n  if(c=='S') return 2;\n  return 3;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\nconst int maxs=201;\nchar map[501][501];\nint h,w,len;\nvoid init()\n{\n\tfor(int i=0;i<=102;i++)\n\t\tfor(int j=0;j<=102;j++)\n\t\t\tmap[i][j]='X';\n}\nvoid find()\n{\n\tint x,y;\n\tint flag=0;\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tif(map[i][j]=='E'||map[i][j]=='W'||map[i][j]=='S'||map[i][j]=='N')\n\t\t\t{\n\t\t\t\tx=i;\n\t\t\t\ty=j;\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t\tbreak;\n\t\t}\n\t\tcout<<x<<y<<endl;\n\t\tif(w==1&&h==1)\n\t\t{\n\t\t\tcout<<1<<' '<<1<<' '<<map[x][y]<<endl;\n\t\t\treturn ;\n\t\t}\n\t\tint tag;\n\t\tif(map[x][y]=='E')tag=0;\n\t\telse if(map[x][y]=='W')tag=1;\n\t\telse if(map[x][y]=='S')tag=2;\n\t\telse if(map[x][y]=='N')tag=3;\n\t\tint count=0;\n\twhile(len)\n\t{\n\t\tif(tag==0)\n\t\t{\n\t\t\tif(map[x][y+1]=='X'||map[x][y+1]=='#')\n\t\t\t\ttag=2;\n\t\t\telse\n\t\t\t{\n\t\t\t\ty+=1;\n\t\t\t\tlen-=1;\n\t\t\t}\n\t\t}\n\t\telse if(tag==1)\n\t\t{\n\t\t\tif(map[x][y-1]=='X'||map[x][y-1]=='#')\n\t\t\t\ttag=3;\n\t\t\telse\n\t\t\t{\n\t\t\t\ty-=1;\n\t\t\t\tlen-=1;\n\t\t\t}\n\t\t}\n\t\telse if(tag==2)\n\t\t{\n\t\t\tif(map[x+1][y]=='X'||map[x+1][y]=='#')\n\t\t\t\ttag=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tx+=1;\n\t\t\t\tlen-=1;\n\t\t\t}\n\t\t}\n\t\telse if(tag==3)\n\t\t{\n\t\t\tif(map[x-1][y]=='X'||map[x-1][y]=='#')\n\t\t\t\ttag=0;\n\t\t\telse \n\t\t\t{\n\t\t\t\tx-=1;\n\t\t\t\tlen-=1;\n\t\t\t}\n\t\t}\n\t}\n\tchar c;\n\tif(tag==0)\n\t\tc='E';\n\telse if(tag==1)\n\t\tc='W';\n\telse if(tag==2)\n\t\tc='S';\n\telse if(tag==3)\n\t\tc='N';\n\tcout<<x<<' '<<y<<' '<<c<<endl;\n\treturn ;\n}\nint main()\n{\n\twhile(cin>>h>>w>>len)\n\t{\n\t\tif(h+w+len==0)break;\n\t\tinit();\n\t\tfor(int i=1;i<=h;i++)\n\t\t\tfor(int j=1;j<=w;j++)\n\t\t\t\tcin>>map[i][j];\n\t\tfind();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  ll i,j,k;\n  ll dp[200][200][4]={{{}}};\n  string st[200];\n  char c[]={'E','S','W','N'};\n  ll rx,ry,rd;\n  ll ax[]={1,0,-1,0};\n  ll ay[]={0,1,0,-1};\n  bool f;\n  ll s;\n  while(cin>>h>>w>>l,h||w||l){\n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    fill(dp[0][0],dp[104][104],-1);\n    f = true;\n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(dp[ry][rx][rd]==-1){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\ts = i - dp[ry][rx][rd];\n\t//l=i+(l-i)%s;\n\ti+=(l-i)/s*s;\n\tf=false;\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n    }\n    cout << ry << ' ' << rx << ' ' << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint main() {\n\tint h, w;\n\tlong long n;\n\twhile (cin >> h >> w >> n, h){\n\t\tvector<string> vs;\n\t\tvector<vector<vector<int>>> vvvi(h,vector<vector<int>>(w,vector<int>(4,-1)));\n\t\tint x, y, d;\n\t\tREP(i, h){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tvs.push_back(s);\n\t\t\tREP(j, w){\n\t\t\t\tif (s[j] == 'N' || s[j] == 'E' || s[j] == 'W' || s[j] == 'S'){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tif (s[j] == 'W')d=0;\n\t\t\t\t\tif (s[j] == 'S')d = 1;\n\t\t\t\t\tif (s[j] == 'E')d = 2;\n\t\t\t\t\tif (s[j] == 'N')d = 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvvi[y][x][d]=0;\n\n\t\tfor(long long i=0;i<n;i++){\n\t\t\twhile (x + dx[d] < 0 || x + dx[d] >= w || y + dy[d] < 0 || y + dy[d] >= h || vs[y + dy[d]][x + dx[d]] == '#'){\n\t\t\td+=3;\n\t\t\td%=4;\n\t\t\t}\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t\tif (vvvi[y][x][d]==-1)\n\t\t\tvvvi[y][x][d] = i + 1;\n\t\t\telse\n\t\t\t\tn=i+1+((n - i - 1) % (i+1-vvvi[y][x][d]));\n\t\t}\n\t\tchar c;\n\t\tif (d == 0)c = 'W';\n\t\tif (d == 1)c = 'S';\n\t\tif (d == 2)c = 'E';\n\t\tif (d == 3)c = 'N';\n\t\tcout << (y + 1) << \" \" << (x + 1) << \" \"<<c<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <cmath>\nconst int MOD = 1e9 + 7;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\nchar d[] = {'E', 'S', 'W', 'N'};\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll h, w, l;\n    while(cin >> h >> w >> l)\n    {\n        if(h == 0 && w == 0 && l == 0)\n            break;\n        int y, x, dir;\n        char table[h + 1][w + 1];\n        for(int i = 0; i < h; i++)\n            for(int j = 0; j < w; j++)\n            {\n                cin >> table[i][j];\n                if(table[i][j] == 'E')\n                {\n                    y = i; x = j; dir = 0;\n                }\n                if(table[i][j] == 'S')\n                {\n                    y = i; x = j; dir = 1;\n                }\n                if(table[i][j] == 'W')\n                {\n                    y = i, x = j; dir = 2;\n                }\n                if(table[i][j] == 'N')\n                {\n                    y = i; x = j; dir = 3;\n                }\n            }\n        ll flag[h + 1][w + 1][4];\n        memset(flag, -1, sizeof(flag));\n        while(l > 0)\n        {\n            if(flag[y][x][dir] != -1)\n            {\n                ll tmp = (flag[y][x][dir] - l);\n                l %= tmp;\n                if(l == 0) l += tmp;\n \n            }\n            else\n                flag[y][x][dir] = l;\n            int ny = y + dy[dir];\n            int nx = x + dx[dir];\n            if(ny < 0 || nx < 0 || ny >= h || nx >= w || table[ny][nx] == '#')\n            {\n                dir = (dir + 1) % 4;\n            }\n            else\n            {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n            }\n        }\n        cout << y + 1 << \" \" << x + 1 << \" \" << d[dir] << endl; \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,a) repi(i,0,a)\nusing namespace std;\ntypedef long long ll;\n\nint H, W;\nll L;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\nbool inrange(int x, int y){ return x >= 0 && x < W && y >= 0 && y < H;}\n\nint main(){\n    while(cin >> H >> W >> L, H || W || L){\n        vector<string> maze(H);\n        rep(i,H) cin >> maze[i];\n        int x, y, dir;\n        rep(i,H)rep(j,W){\n            if(maze[i][j] == 'W'){ dir = 0; x = j; y = i; break;}\n            else if(maze[i][j] == 'N'){ dir = 1; x = j; y = i; break;}\n            else if(maze[i][j] == 'E'){ dir = 2; x = j; y = i; break;}\n            else if(maze[i][j] == 'S'){ dir = 3; x = j; y = i; break;}\n        }\n        int field[128][128][4];\n        memset(field,-1,sizeof(field));\n        field[y][x][dir] = 0;\n        ll turn = 1;\n        bool rooped = false;\n        while(turn <= L){\n            int nx, ny, ndir;\n            rep(i,4){\n                ndir = (dir+i)%4;\n                nx = x + dx[ndir];\n                ny = y + dy[ndir];\n                if(inrange(nx, ny) && maze[ny][nx] != '#'){\n                    x = nx; y = ny; dir = ndir;\n                    break;\n                }\n            }\n            if(!rooped && field[y][x][dir] >= 0){\n                rooped = true;\n                ll roop = turn - field[y][x][dir];\n                turn += (L - turn) / roop * roop;\n                turn++;\n            }\n            else{\n                field[y][x][dir] = turn;\n                turn++;\n            }\n        }\n        cout << y+1 << ' ' << x+1 << ' ';\n        cout << (dir==0? 'W': dir==1? 'N': dir==2? 'E': 'S') << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//const int INF = 1e8;\nconst int N = 105;\n\nchar c[N][N];\nlong long dist[4][N][N];\nlong long h, w, l;\nlong long to, loop;\n\nstruct Point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nvoid dfs(Point p, int dir, long long dis){\n    //cout << endl;\n    if(dist[dir][p.y][p.x] != -1){\n        //show(p.y)\n        //show(p.x)\n        //show(dis)\n        //show(dist[p.y][p.x])\n        to = dist[dir][p.y][p.x];\n        loop = dis - dist[dir][p.y][p.x];\n        return;\n    }\n    dist[dir][p.y][p.x] = dis;\n\n    //rep(i,h){ rep(j,w){ cout << dist[dir][i][j] << ' '; } cout << endl; }\n\n    int ny = p.y + dy[dir];\n    int nx = p.x + dx[dir];\n    while( (ny < 0 || ny >= h || nx < 0 || nx >= w) || c[ny][nx] == '#'){\n        dir = (dir + 1) % 4;\n        ny = p.y + dy[dir];\n        nx = p.x + dx[dir];\n    }\n\n\n    dfs(Point{nx,ny}, dir, dis + 1);\n}\n\nvoid dfs_(Point p, int dir, long long dis){\n    //show(dir) cout << p.y << ' ' << p.x << endl;\n    if(dis == 0){\n        char d[5] = {\"ESWN\"};\n        cout << p.y + 1 << ' ' << p.x + 1 << ' ' << d[dir] << endl;\n        return;\n    }\n\n    int ny = p.y + dy[dir];\n    int nx = p.x + dx[dir];\n    while( (ny < 0 || ny >= h || nx < 0 || nx >= w) || c[ny][nx] == '#'){\n        dir = (dir + 1) % 4;\n        ny = p.y + dy[dir];\n        nx = p.x + dx[dir];\n    }\n    dfs_(Point{nx,ny}, dir, dis - 1);\n}\n\nint main(){\n    while(cin >> h >> w >> l,h){\n        memset(dist, -1, sizeof(dist));\n        int dir = -1;\n        Point p = Point{-1,-1};\n        rep(i,h){\n            rep(j,w){\n                cin >> c[i][j];\n                if(c[i][j] == 'N') dir = 3;\n                else if(c[i][j] == 'E') dir = 0;\n                else if(c[i][j] == 'S') dir = 1;\n                else if(c[i][j] == 'W') dir = 2;\n                if(dir != -1 && p.x == -1){\n                    p = Point{j,i};\n                }\n            }\n        }\n        dfs(p,dir,0);\n        //show(to)\n        //show(loop)\n        if(l >= to){\n            l -= to;\n            l %= loop;\n            l += to;\n        }\n        dfs_(p,dir,l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nchar cells[100][100];\nint visited[100][100][4];\nint visitt[100][100][4];\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nchar d[4]={'N','E','S','W'};\n\nint main(){\n  while(1){\n    int posx,posy,dir;\n    int h,w,l,walk=0,flag=0;\n    cin >> h >> w >> l;\n    if (h==0)break;\n    rep(i,h){\n      string s;\n      cin >> s;\n      rep(j,w){\n        cells[i][j] = s[j];\n        if (s[j]!='.'&&s[j]!='#'){\n          posx = i;\n          posy = j;\n          if (s[j]=='N'){\n            dir = 0;\n          } else if (s[j]=='E'){\n            dir = 1;\n          } else if (s[j]=='S'){\n            dir = 2;\n          } else {\n            dir = 3;\n          }\n        }\n      }\n    }\n    rep(i,h)rep(j,w)rep(k,4){visited[i][j][k]=0;visitt[i][j][k]=-1;}\n    visited[posx][posy][dir]=1;\n    visitt[posx][posy][dir]=0;\n    while(l>0){\n      if (posx+dx[dir]>=0&&posx+dx[dir]<h&&posy+dy[dir]>=0&&posy+dy[dir]<w){\n        if (cells[posx+dx[dir]][posy+dy[dir]]!='#'){\n          posx += dx[dir];\n          posy += dy[dir];\n          if (visited[posx][posy][dir]==0){\n            l--;\n            walk++;\n            visited[posx][posy][dir]=1;\n            visitt[posx][posy][dir]=walk;\n          } else if (flag==0){\n            l = l%(walk-visitt[posx][posy][dir]+1)-1;\n            flag=1;\n          } else {\n            l--;\n          }\n        } else {\n          dir++;\n          if (dir==4)dir=0;\n          if (visited[posx][posy][dir]==0){\n            visited[posx][posy][dir]=1;\n            visitt[posx][posy][dir]=walk;\n          } else if(flag==0){\n            l = l%(walk-visitt[posx][posy][dir]);\n            flag = 1;\n          }\n        }\n      } else {\n        dir++;\n        if (dir==4)dir=0;\n        if (visited[posx][posy][dir]==0){\n          visited[posx][posy][dir]=1;\n          visitt[posx][posy][dir]=walk;\n        } else if (flag==0) {\n          l = l%(walk-visitt[posx][posy][dir]);\n          flag = 1;\n        }\n      }\n    }\n    cout << posx+1 << \" \" << posy+1 << \" \" << d[dir]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <limits.h>\n#include <map>\n\nusing namespace std;\ntypedef long long int ll;\n\nll solve(void);\nbool isValid(const ll y, const ll x, vector<string> &maze);\nvoid search(ll &y, ll&x, ll&d, ll&cnt, ll L, vector<string>&maze, vector<vector<vector<ll>>> &memo);\n\n\nint main(void) {\n\n\twhile (solve());\n\treturn 0;\n\n}\n\nll solve(void) {\n\n\tll H, W, L;\n\tcin >> H >> W >> L;\n\tif (!(H | W | L)) { return 0; }\n\tvector<string> maze(H);\n\n\t/*\n\t\tmemo[y][x][direction] = the number of steps\n\t*/\n\tvector<vector<vector<ll>>> memo\n\t\t(H, vector<vector<ll>>(W, vector<ll>(4,INT64_MAX) ) );\n\tvector<vector<vector<ll>>> memo_s;\n\n\t//input\n\n\tmap<char, ll> mp;\n\t\tmp['E'] = 0;\n\t\tmp['S'] = 1;\n\t\tmp['W'] = 2;\n\t\tmp['N'] = 3;\n\tvector<char> v = {'E','S','W','N'};\n\n\tll x, y, d, cnt = 0;\n\tll loop_start = 0, loop_end;\n\n\tfor (ll i = 0; i < H; i++) {\n\t\tcin >> maze[i];\n\t\tfor (ll j = 0; j < maze[i].length(); j++) {\n\t\t\tif (maze[i][j] != '.' && maze[i][j] != '#') {\n\t\t\t\ty = i; x = j; d = mp[maze[i][j]];\n\t\t\t\tmemo[y][x][d] = cnt;\n\t\t\t}\n\t\t}\n\t}\n\tmemo_s = memo;\n\n\tsearch(y, x, d, cnt, L, maze, memo);\n\n\tloop_start = memo[y][x][d];\n\tloop_end = cnt;\n\n\tif (L <= loop_end) {\n\t\tcnt = 0;\n\t} else {\n\t\tL -= loop_end;\n\t\tL %= (loop_end - loop_start);\n\t\tcnt = 0;\n\t\tif (L == 0) L = loop_end - loop_start;\n\t\tsearch(y, x, d, cnt, L, maze, memo_s);\n\t}\n\n\tcout << y + 1 << \" \" << x + 1 << \" \" << v[d] << endl;\n\n\treturn 1;\n}\n\nbool isValid(const ll y, const ll x, vector<string>& maze)\n{\n\treturn (0<=y && 0<=x && y < maze.size() && x < maze[y].length() && maze[y][x] != '#');\n}\n\nvoid search(ll & y, ll & x, ll & d, ll & cnt, ll L, vector<string>& maze, vector<vector<vector<ll>>>& memo)\n{\n\n\tll dd[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\n\n\twhile (true) {\n\n\t\tif (cnt == L) { \n\t\t\tbreak;\n\t\t}\n\n\t\tif (isValid(y + dd[d][0], x + dd[d][1], maze)) {\n\n\t\t\ty += dd[d][0];\n\t\t\tx += dd[d][1];\n\t\t\tcnt++;\n\n\t\t\tif (memo[y][x][d] < INT64_MAX) { break; }\n\t\t\tmemo[y][x][d] = min(cnt, memo[y][x][d]);\n\n\t\t}\n\t\telse {\n\n\t\t\td = (d + 1) % 4;\n\n\t\t\tif (memo[y][x][d] < INT64_MAX) { break; }\n\t\t\tmemo[y][x][d] = min(cnt, memo[y][x][d]);\n\n\t\t}\n\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=110;\nint H,W,cnt;\nint sx,sy,sd;\nlong long L;\nchar grid[maxn][maxn];\nint vis[maxn][maxn][4],id[maxn][maxn][4];\nint di[][2]={{-1,0},{0,1},{1,0},{0,-1}};\nint DIR(char d)\n{\n    if(d=='S')return 2;\n    if(d=='W')return 3;\n    if(d=='N')return 0;\n    return 1;\n}\nint move(int &x,int &y,int &d)\n{\n    int tx,ty;\n    for(int i=0;i<4;i++)\n    {\n        tx=x+di[d][0];\n        ty=y+di[d][1];\n        if(tx<1||tx>H||ty<1||ty>W||grid[tx][ty]=='#'){d=(d+1)%4;continue;}\n        break;\n    }\n    x=tx,y=ty;\n    if(vis[x][y][d])return id[x][y][d];\n    vis[x][y][d]=1;\n    id[x][y][d]=cnt++;\n    return 0;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    while(scanf(\"%d%d%lld\",&H,&W,&L)!=EOF,H+W+L)\n    {\n        for(int i=1;i<=H;i++)\n        {\n            scanf(\"%s\",grid[i]+1);\n            for(int j=1;j<=W;j++)\n            {\n                if(grid[i][j]=='.'||grid[i][j]=='#')continue;\n                sx=i,sy=j;\n                sd=DIR(grid[i][j]);\n            }\n        }\n        memset(vis,0,sizeof(vis));\n        memset(id,0,sizeof(id));\n        bool flag=true;\n        vis[sx][sy][sd]=1;\n        id[sx][sy][sd]=1;\n        cnt=-1;\n        while(L)\n        {\n            int tv=move(sx,sy,sd);\n            if(tv&&flag)\n            {\n                flag=false;\n                L=L%(cnt-tv)+cnt-tv;\n            }\n            L--;\n        }\n        char ansd;\n        if(sd==0)ansd='N';\n        else if(sd==1)ansd='E';\n        else if(sd==2)ansd='S';\n        else ansd='W';\n        printf(\"%d %d %c\\n\",sx,sy,ansd);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W;\nll L;\nvector<string> maze;\nvector<vector<vector<ll> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<ll> >(W, vector<ll>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    for(ll step=0; step<=L; ++step){\n        if(vis[x][y][d] != -1){\n            L = vis[x][y][d] + (L - step) % (step - vis[x][y][d]);\n            break;\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        while(!inrect(nx, ny) || maze[nx][ny] == '#'){\n            (d += 1) %= 4;\n            nx = x + dx[d]; ny = y + dy[d];\n        }\n        x = nx; y = ny;\n    }\n    rep(i, H)rep(j, W)rep(k, 4)if(vis[i][j][k] == L){\n        x = i; y = j; d = k;\n        break;\n    }\n    return make_tuple(x+1, y+1, \"NESW\"[d]);\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst char dc[4] = {'E', 'S', 'W', 'N'};\n\nsigned main() {\n  int H, W, L;\n  while ( cin >> H >> W >> L, H ) {\n    char grid[H][W];\n    int used[H][W][4];\n    fill_n(**used, H*W*4, -1);    \n    int y, x, d;    \n    for ( int i = 0; i < H; i++ ) {\n      for ( int j = 0; j < W; j++ ) {\n\tcin >> grid[i][j];\n\tif ( grid[i][j] != '#' && grid[i][j] != '.' ) {\n\t  y = i; x = j;\n\t  if ( grid[i][j] == 'E' ) d = 0;\n\t  if ( grid[i][j] == 'S' ) d = 1;\n\t  if ( grid[i][j] == 'W' ) d = 2;\n\t  if ( grid[i][j] == 'N' ) d = 3;\n\t}\n      }\n    }\n\n    int cnt = 0;\n    bool flag = false;\n    while ( 1 ) {\n      if ( used[y][x][d] >= 0 && !flag ) {\n\tif ( L-cnt-used[y][x][d]-10 > 0 ) {\n\t  cnt += (L-cnt-used[y][x][d]-1)/(cnt-used[y][x][d])*(cnt-used[y][x][d]);\n\t}\n\tflag = true;\n      }\n      if ( cnt >= L ) break;\n      if ( cnt ) used[y][x][d] = cnt;      \n      int nx = x+dx[d], ny = y+dy[d];\n      if ( nx < 0 || ny < 0 || nx >= W || ny >= H || grid[ny][nx] == '#' ) {\n\td = (d+1)%4LL;\t\n      } else {\n\tcnt++;\n\tx = nx;\n\ty = ny;\n\tif ( cnt >= L ) break;\n      }\n    }\n\n    cout << y+1 << \" \" << x+1 << \" \" << dc[d] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint todir[256];\nchar tochr[4];\n\nint h, w;\nlong long l;\nstring c[110];\nint vis[110][110][4];\n\nint main()\n{\n\tfor (int i = 0; i < 4; i++){\n\t\ttodir[\"NESW\"[i]] = i;\n\t\ttochr[i] = \"NESW\"[i];\n\t}\n\n\twhile (cin >> h >> w >> l, h){\n\t\tmemset(vis, -1, sizeof(vis));\n\t\tc[0] = c[h + 1] = string(w + 2, '#');\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tcin >> c[i];\n\t\t\tc[i] = \"#\" + c[i] + \"#\";\n\t\t}\n\t\tint x, y, dir;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tif (c[i][j] != '.' && c[i][j] != '#'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tdir = todir[c[i][j]];\n\t\t\t\t\tc[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (long long t = 0; t < l; t++){\n\t\t\twhile (true){\n\t\t\t\tint nx = x + dx[dir];\n\t\t\t\tint ny = y + dy[dir];\n\t\t\t\tif (c[nx][ny] == '.') break;\n\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t}\n\t\t\tif (~vis[x][y][dir]){\n\t\t\t\tt += (l - t - 1) / (t - vis[x][y][dir]) * (t - vis[x][y][dir]);\n\t\t\t}\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\t\t}\n\t\tcout << x << \" \" << y << \" \" << tochr[dir] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define m make_pair\n#define se second\n#define f first\n#define N 105\nusing namespace std;\ntypedef long long ll;\ntypedef pair<char,ll> P;\nchar Rot(char);\n\nint main(){\n  ll h,w,y,x,t,flag;\n  char c;\n  string s[N];\n  P me[N][N];\n  ll l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tme[i][j].f='e';\n      }\n    t=0;\n    me[y][x]=m(c,t);\n    flag=0;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      if(me[y][x].f==c&&flag==0) t=l-(l-me[y][x].se)%(t-me[y][x].se),flag=1;\n      me[ny][nx]=m(c,t);\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n#include <array>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\nconst int MOD = 1000000007;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint H, W;\nll L;\n\n//h, w, dir\ntypedef tuple<int, int, int> State;\n\nstring directions = \"NESW\";\n//NESW\nint dh[] = {-1, 0, 1, 0};\nint dw[] = {0, 1, 0, -1};\n\ninline bool infield(int h, int w){\n    return 0<=h&&h<H && 0<=w&&w<W;\n}\n\nvoid solve(){\n    vector<string> field(H);\n    for(int i=0; i<H; i++)\n        cin >> field[i];\n    \n    int dir = -1;\n    int h = -1, w = -1;\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            int tdir = directions.find(field[i][j]);\n            if(tdir != string::npos){\n                dir = tdir;\n                h = i; w = j;\n                field[h][w] = '.';\n            }\n        }\n    }\n    \n    map<State, ll> memo;\n    \n    while(L--){\n        while(!(infield(h+dh[dir], w+dw[dir]) && field[h+dh[dir]][w+dw[dir]]=='.'))\n            dir = (dir+1) % 4;\n        \n        if(memo.find(State(h, w, dir)) != memo.end()){\n            ll d = memo[State(h, w, dir)];\n            L %= (L - d);\n        }\n        memo[State(h, w, dir)] = L;\n        \n        h += dh[dir];\n        w += dw[dir];\n    }\n    \n    cout << h+1 << \" \" << w+1 << \" \" << directions[dir] << endl;\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(16);\n    //cout.setf(ios::fixed);\n    \n    while(cin>>H>>W>>L, H|W|L){\n        solve();\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nchar dd[] = {'N', 'E', 'S', 'W'};\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nint main() {\n\tll H, W, L;\n\twhile(cin >> H >> W >> L, H) {\n\t\tvs field(H);\n\t\tREP(i, H) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tint cx, cy, cd;\n\t\tREP(i, H) {\n\t\t\tREP(j, W) {\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#') {\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tswitch(field[i][j]) {\n\t\t\t\t\tcase 'N':\n\t\t\t\t\t\tcd = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tcd = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tcd = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tcd = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vvl> turn(H, vvl(W, vl(4)));\n\t\tbool looped = false;\n\t\tfor(ll t = 0; t < L; t++) {\n\t\t\tif(!looped && turn[cy][cx][cd] != 0) {\n\t\t\t\tlooped = true;\n\t\t\t\tll cycle = (t-turn[cy][cx][cd]-1);\n\t\t\t\tt += ((L-t)/cycle)*cycle;\n\t\t\t}\n\n\t\t\tint nx = cx+dx[cd];\n\t\t\tint ny = cy+dy[cd];\n\n\t\t\tif(ny<0 || H<=ny || nx<0 || W<=nx || field[ny][nx]=='#') {\n\t\t\t\tcd = (cd+1)%4;\n\t\t\t\tt--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tturn[cy][cx][cd] = t;\n\t\t\tcy = ny;\n\t\t\tcx = nx;\n\t\t}\n\n\t\tcout << cy+1 << \" \" << cx+1 << \" \" << dd[cd] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int MAX = 105;\nstatic const string DIR = \"NESW\";\nstatic const int di[4] = {-1, 0, 1, 0};\nstatic const int dj[4] = {0, 1, 0, -1};\n\nint H, W, pi, pj, dir;\nlong long L;\nchar G[MAX][MAX];\n\nvoid input(){\n  REP(i, 1, H+1) REP(j, 1, W+1){\n    cin >> G[i][j];\n    if ( G[i][j] != '.' && G[i][j] != '#' ){\n      pi = i; pj = j;\n      rep(r, 4)\tif ( G[i][j] == DIR[r] ) dir = r;\n      G[i][j] = '.';\n    }\n  }\n}\n\nvoid simulate(){\n  int v[MAX][MAX][4];\n  rep(i, H+2) rep(j, W+2) rep(r, 4) v[i][j][r] = -1;\n  long long pos = 0;\n  v[pi][pj][dir] = pos++;\n  for (bool cycle = false;  pos <= L; pos++ ){\n    int ni = pi + di[dir];\n    int nj = pj + dj[dir];\n    while(G[ni][nj] == '#'){\n      dir = (dir+1)%4;\n      ni = pi + di[dir];\n      nj = pj + dj[dir];\n    } \n    pi = ni;\n    pj = nj;\n    if ( v[pi][pj][dir] == -1 || cycle ) {\n      v[pi][pj][dir] = pos;\n    } else {\n      long long cycle_len = pos - v[pi][pj][dir];\n      long long remain = L - pos;\n      pos = L - remain%cycle_len;\n      cycle = true;\n    }\n  }\n\n  cout << pi << \" \" << pj << \" \" << DIR[dir] << endl;\n}\n\nmain(){\n  while(1){\n    cin >> H >> W >> L;\n    if ( H == 0 ) break;\n    rep(i, H+2) rep(j, W+2 ) G[i][j] = '#';\n    input();\n    simulate();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define Y first.first\n#define X first.second\n#define D second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst string kDir = \"ESWN\";\nconst vi dx = { 1, 0,-1, 0};\nconst vi dy = { 0, 1, 0,-1};\n\ntypedef pair<pii, int> State;\n\nint main(void){\n    for(int h, w, L; cin >> h >> w >> L, h;){\n        vs field(h + 2);\n        rep(x, w + 2) field[0].pb('#'), field[h + 1].pb('#');\n\n        State cur;\n        \n        range(y, 1, h + 1){\n            string f; cin >> f;\n\n            field[y].pb('#');\n            field[y] += f;\n            field[y].pb('#');\n\n            range(x, 1, w + 1){\n                if(field[y][x] != '.' && field[y][x] != '#'){\n                    int d = kDir.find(field[y][x]);\n                    cur = mp(mp(y, x), d);\n\n                    field[y][x] = '.';\n                }\n            }\n        }\n\n        map<State, int> step;\n        int cnt_step = 0;\n\n        while(step.find(cur) == step.end()){\n            step[cur] = cnt_step;\n            pii next_pos = mp(cur.Y + dy[cur.D], cur.X + dx[cur.D]);\n\n            if(field[next_pos.first][next_pos.second] == '#'){\n               (cur.D += 1) %= kDir.size();\n            }\n            else{\n                cur.first = next_pos;\n                cnt_step++;\n            }\n        }\n\n        cnt_step -= step[cur];\n        L -= step[cur];\n        if(L >= 0 && cnt_step != 0) L %= cnt_step;\n        L += step[cur];\n\n        State res;\n        for(auto s : step){\n            if(s.second == L) res = s.first;\n        }\n\n        cout << res.Y << \" \" << res.X << \" \" << kDir[res.D] << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconstexpr int dy[] = { -1, 0, 1, 0 };\nconstexpr int dx[] = { 0, 1, 0, -1 };\nconst string dirs( \"NESW\" );\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( LL H, W, L; cin >> H >> W >> L && ( H | W | L ); )\n\t{\n\t\tVS board( H );\n\t\tcin >> board;\n\n\t\tint y = 0, x = 0, d = 0;\n\t\tREP( i, H )\n\t\t{\n\t\t\tREP( j, W )\n\t\t\t{\n\t\t\t\tif ( isupper( board[i][j] ) )\n\t\t\t\t{\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t\td = dirs.find( board[i][j] );\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVT( VVI ) visited( H, VVI( W, VI( 4, -1 ) ) );\n\n\t\tREP( i, L )\n\t\t{\n\t\t\tif ( visited[y][x][d] != -1 && ( L - i ) % ( i - visited[y][x][d] ) == 0 )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvisited[y][x][d] = i;\n\n\t\t\twhile ( true )\n\t\t\t{\n\t\t\t\tconst int ny = y + dy[d];\n\t\t\t\tconst int nx = x + dx[d];\n\n\t\t\t\tif ( 0 <= ny && ny < H && 0 <= nx && nx < W && board[ ny ][ nx ] == '.' )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++d %= 4;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ty += dy[d];\n\t\t\tx += dx[d];\n\t\t}\n\n\t\tcout << y + 1 << ' ' << x + 1 << ' ' << dirs[d] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nstruct node{\n\tint y,x,dir;\n\tll cost;\n\tnode(int y,int x,int dir,ll cost):y(y),x(x),cost(cost),dir(dir){}\n};\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nchar dirs[]={'W','N','E','S'};\nconst ll MAX=LONG_MAX;\nint main(){\n\tint h,w,l;\n\twhile(cin>>h>>w>>l,h|w|l){\n\t\tvs c(h);\n\t\tpii start;\n\t\tint initdir;\n\t\tREP(i,h){\n\t\t\tcin>>c[i];\n\t\t\tREP(j,w){\n\t\t\t\tswitch(c[i][j]){\n\t\t\t\tcase 'W':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvvl cost(h,vvl(w,vl(4,MAX)));\n\t\tqueue<node> q;\n\t\tcost[start.first][start.second][initdir]=l;\n\t\tq.push(node(start.first,start.second,initdir,l));\n\t\twhile(!q.empty()){\n\t\t\tnode cnode=q.front();q.pop();\n\t\t\tif(cnode.cost==0){\n\t\t\t\tcout<<cnode.y+1<<\" \"<<cnode.x+1<<\" \"<<dirs[cnode.dir]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint d=cnode.dir;\n\t\t\tint y=cnode.y+dy[d];\n\t\t\tint x=cnode.x+dx[d];\n\t\t\twhile(!(y>=0&&x>=0&&y<h&&x<w&&c[y][x]!='#')){\n\t\t\t\td=(d+1)%4;\n\t\t\t\ty=cnode.y+dy[d];\n\t\t\t\tx=cnode.x+dx[d];\n\t\t\t}\n\t\t\tif(cost[y][x][d]!=MAX){\n\t\t\t\tll diff=cost[y][x][d]-(cnode.cost-1);\n\t\t\t\tq.push(node(y,x,d,(cnode.cost-1)%diff));\n\t\t\t}else{\n\t\t\t\tq.push(node(y,x,d,cnode.cost-1));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef unsigned long long ll;\nint main(){\n  ll h,w,l;\n  while(cin>>h>>w>>l,h||w||l){\n    string st[105];\n    ll i,j,k;\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n\n    //for(i=0;i<=h+1;i++) cout << st[i] << endl;\n    \n    int rx,ry,rd;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(st[i][j]=='N'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=3;\n\t}\n\tif(st[i][j]=='E'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=0;\n\t}\n\tif(st[i][j]=='S'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=1;\n\t}\n\tif(st[i][j]=='W'){\n\t  st[i][j]='.';\n\t  rx=j;ry=i;rd=2;\n\t}\n      }\n    }\n    \n    char c[]={'E','S','W','N'};\n    \n    //cout << ry << \":\" << rx << \":\" << c[rd] << endl;\n\n    int ax[]={1,0,-1,0};\n    int ay[]={0,1,0,-1};\n    int dp[105][105][4]={{{}}};\n\n    bool f = true;\n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n      //cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n      if(dp[rx][ry][rd]==0){\n\tdp[rx][ry][rd]=i;\n      }else if(f){\n\tll s = i-dp[rx][ry][rd];\n\t//cout << i << \":\" << s << \":\" << l << endl;\n\tif((l-i)%s!=0) l=i+(l-i)%s;\n\t//cout << i << \":\" << s << \":\" << l << endl;\n\tf=false;\n      }\n    }\n    cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 拓真 on 2018/06/30.\n//\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) FOR(i,0,b)\n#define INF mugen\n#define dump(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(a) (a).begin(),(a).end()\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntemplate <class T> void chmin(T & a, T const & b) { if (b < a) a = b; }\n\ntypedef pair<int,int> P;\ntypedef long long ll;\n#define int long long\nstruct robot{\n    robot(){};\n    int x,y;\n    int dir;\n    robot(int x,int y,int dir){\n        this->x=x;\n        this->y=y;\n        this->dir=dir;\n    }\n};\n\nchar toc(int x){\n    if(x==0)return 'N';\n    else if(x==1)return 'E';\n    else if(x==2)return 'S';\n    else return 'W';\n}\nint dp[110][110][5];\nvector<string> maze;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint h,w;\n\nbool inrange(int x, int y){ return x >= 0 && x < w && y >= 0 && y < h;}\n\nsigned main(){\n    ll L;\n    while(cin>>h>>w>>L,h){\n\n\n        rep(i,110)rep(j,110)rep(k,5)dp[i][j][k]=-1;\n        maze.clear();\n        rep(i,h){\n            string s;\n            cin>>s;\n            maze.push_back(s);\n        }\n\n        robot pre;\n        rep(i,h)rep(j,w){\n            if(maze[i][j]=='N'){\n                pre=robot(j,i,0);\n            }\n            if(maze[i][j]=='E'){\n                pre=robot(j,i,1);\n            }\n            if(maze[i][j]=='S'){\n                pre=robot(j,i,2);\n            }\n            if(maze[i][j]=='W'){\n                pre=robot(j,i,3);\n            }\n        }\n\n        bool flag=false;\n        dp[pre.y][pre.x][pre.dir]=0;\n        ll turn=1;\n        bool rooped = false;\n        while(turn<=L){\n            int nx,ny,ndir;\n            rep(i,4){\n                ndir = (pre.dir+i)%4;\n                nx = pre.x + dx[ndir];\n                ny = pre.y + dy[ndir];\n                if(inrange(nx, ny) && maze[ny][nx] != '#'){\n                    pre.x = nx; pre.y = ny; pre.dir = ndir;\n                    break;\n                }\n            }\n            if(!rooped && dp[pre.y][pre.x][pre.dir] >= 0){\n                rooped = true;\n                ll roop = turn -dp[pre.y][pre.x][pre.dir];\n                turn += (L - turn) / roop * roop;\n                turn++;\n            }\n            else{\n                dp[pre.y][pre.x][pre.dir] = turn;\n                turn++;\n            }\n        }\n\n\n\n\n\n        cout<<pre.y+1<<' '<<pre.x+1<<' '<<toc(pre.dir)<<endl;\n\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint mem[110][110][4];\n\nint main() {\n  int h, w, n;\n  string m[110];\n  while (true) {\n    cin >> h >> w >> n;\n    if (h == 0 && w == 0 && n == 0) break;\n    rep (i, h) cin >> m[i + 1];\n    m[0] = m[h + 1] = \"\";\n    rep (i, w) m[0] += \"#\";\n    rep (i, w) m[h + 1] += \"#\";\n    rep (i, h + 2) m[i] = \"#\" + m[i] + \"#\";\n    h += 2;\n    w += 2;\n    int x, y, d;\n    rep (i, h) rep (j, w) {\n      if (m[i][j] == 'E') d = 0;\n      if (m[i][j] == 'S') d = 1;\n      if (m[i][j] == 'W') d = 2;\n      if (m[i][j] == 'N') d = 3;\n      if (isalpha(m[i][j])) {\n\tx = j;\n\ty = i;\n      }\n    }\n    rep (i, 110) rep (j, 110) rep (k, 4) mem[i][j][k] = -1;\n    rep (i, n) {\n      int xx = x + dx[d], yy = y + dy[d];\n      while (m[yy][xx] == '#') {\n\td = (d + 1) % 4;\n\txx = x + dx[d];\n\tyy = y + dy[d];\n      }\n      x = xx;\n      y = yy;\n      if (mem[y][x][d] != -1) {\n\tint k = i - mem[y][x][d];\n\twhile (i + k < n) i += k;\n      } else {\n\tmem[y][x][d] = i;\n      }\n    }\n    cout << y << \" \" << x << \" \" << \"ESWN\"[d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tint h,w;\n\tll l;\n\tchar maze[102][102];\n\tmemset(maze,'#',sizeof maze);\n\twhile(cin >> h >> w >> l,h){\n\t\tint r[2];\n\t\tint v[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\tint d = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcin >> maze[i+1][j+1];\n\t\t\t\tswitch(maze[i+1][j+1]){\n\t\t\t\t\tcase 'W':++d;\n\t\t\t\t\tcase 'S':++d;\n\t\t\t\t\tcase 'E':++d;\n\t\t\t\t\tcase 'N':\n\t\t\t\t\t\t r[0] = i+1;\n\t\t\t\t\t\t r[1] = j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll step[4][102][102];\n\t\tmemset(step,-1,sizeof step);\n\t\tll s = 0;\n\t\twhile(s < l){\n\t\t\twhile(maze[r[0]+v[d][0]][r[1]+v[d][1]] == '#') d = (d+1)%4;\n\t\t\tif(step[d][r[0]+v[d][0]][r[1]+v[d][1]] < 0){\n\t\t\t\tstep[d][r[0]+v[d][0]][r[1]+v[d][1]] = ++s;\n\t\t\t}else{\n\t\t\t\tl -= ++s;\n\t\t\t\tl %= (s-step[d][r[0]+v[d][0]][r[1]+v[d][1]]);\n\t\t\t\tmemset(step,-1,sizeof step);\n\t\t\t\ts = 0;\n\t\t\t}\n\t\t\tr[0] += v[d][0];\n\t\t\tr[1] += v[d][1];\n\t\t}\n\t\tchar c[] = {'N','E','S','W'};\n\t\tcout << r[0] << \" \" << r[1] << \" \" << c[d] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//const int INF = 1e8;\nconst int N = 105;\n\nchar c[N][N];\nlong long dist[4][N][N];\nlong long h, w, l;\nlong long to, loop;\n\nstruct Point{ int x, y; };\nint dy[4] = {0,1,0,-1}, dx[4] = {1,0,-1,0};\n\nvoid dfs(Point p, int dir, long long dis){\n    //cout << endl;\n    if(dist[dir][p.y][p.x] != -1){\n        //show(p.y)\n        //show(p.x)\n        //show(dis)\n        //show(dist[p.y][p.x])\n        to = dist[dir][p.y][p.x];\n        loop = dis - dist[dir][p.y][p.x];\n        return;\n    }\n    dist[dir][p.y][p.x] = dis;\n\n    //rep(i,h){ rep(j,w){ cout << dist[dir][i][j] << ' '; } cout << endl; }\n\n    int ny = p.y + dy[dir];\n    int nx = p.x + dx[dir];\n    while( (ny < 0 || ny >= h || nx < 0 || nx >= w) || c[ny][nx] == '#'){\n        dir = (dir + 1) % 4;\n        dfs(Point{p.x,p.y}, dir, dis);\n        return;\n    }\n\n\n    dfs(Point{nx,ny}, dir, dis + 1);\n}\n\nvoid dfs_(Point p, int dir, long long dis){\n    //show(dir) cout << p.y << ' ' << p.x << endl;\n    if(dis == 0){\n        char d[5] = {\"ESWN\"};\n        cout << p.y + 1 << ' ' << p.x + 1 << ' ' << d[dir] << endl;\n        return;\n    }\n\n    int ny = p.y + dy[dir];\n    int nx = p.x + dx[dir];\n    while( (ny < 0 || ny >= h || nx < 0 || nx >= w) || c[ny][nx] == '#'){\n        dir = (dir + 1) % 4;\n        ny = p.y + dy[dir];\n        nx = p.x + dx[dir];\n    }\n    dfs_(Point{nx,ny}, dir, dis - 1);\n}\n\nint main(){\n    while(cin >> h >> w >> l,h){\n        memset(dist, -1, sizeof(dist));\n        int dir = -1;\n        Point p = Point{-1,-1};\n        rep(i,h){\n            rep(j,w){\n                cin >> c[i][j];\n                if(c[i][j] == 'N') dir = 3;\n                else if(c[i][j] == 'E') dir = 0;\n                else if(c[i][j] == 'S') dir = 1;\n                else if(c[i][j] == 'W') dir = 2;\n                if(dir != -1 && p.x == -1){\n                    p = Point{j,i};\n                }\n            }\n        }\n        dfs(p,dir,0);\n        //show(to)\n        //show(loop)\n        l = max(l - to,0LL) % loop;\n        dfs_(p,dir,l + to);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[100][100];\nint visited[100][100][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  //cout << x << \",\" << y << \" \" << dir;\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      //cout << \" x = \" << x << \", y = \" << y << \" G = \" << G[y][x] << \" \";\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  //cout << \" X1X\";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  //cout << \" X2X \" << \"G[\"<<src.S<<\"][\"<<src.F<<\"]\" << \" \";\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  //cout << \" X3X\";\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << x << \",\" << y << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {   \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].x,path[i+L].y,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x,cnt;\n    State(int dir,int y,int x,int cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    int d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            int diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            s.cnt+=L/diff*diff;\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            d[(s.dir+1)%4][s.y][s.x]=s.cnt;\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                d[(s.dir+1)%4][s.y][s.x]=s.cnt;\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                d[s.dir][ny][nx]=s.cnt+1;\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) while(1){}\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint mem[110][110][4];\n\nint main() {\n  int h, w, n;\n  string m[110];\n  while (true) {\n    cin >> h >> w >> n;\n    if (h == 0 && w == 0 && n == 0) break;\n    rep (i, h) cin >> m[i + 1];\n    m[0] = m[h + 1] = \"\";\n    rep (i, w) m[0] += \"#\";\n    rep (i, w) m[h + 1] += \"#\";\n    rep (i, h + 2) m[i] = \"#\" + m[i] + \"#\";\n    h += 2;\n    w += 2;\n    int x, y, d;\n    rep (i, h) rep (j, w) {\n      if (m[i][j] == 'E') d = 0;\n      if (m[i][j] == 'S') d = 1;\n      if (m[i][j] == 'W') d = 2;\n      if (m[i][j] == 'N') d = 3;\n      if (isalpha(m[i][j])) {\n\tx = j;\n\ty = i;\n      }\n    }\n    rep (i, 110) rep (j, 110) rep (k, 4) mem[i][j][k] = -1;\n    rep (i, n) {\n      int xx = x + dx[d], yy = y + dy[d];\n      while (m[yy][xx] == '#') {\n\td = (d + 1) % 4;\n\txx = x + dx[d];\n\tyy = y + dy[d];\n      }\n      x = xx;\n      y = yy;\n      if (mem[y][x][d] != -1) {\n\tcout << y << \" \" << x << \" \" << \"ESWN\"[d] << \" \";\n\tcout << i << \" \" << mem[y][x][d] << endl;\n\tint k = i - mem[y][x][d];\n\ti += (n - i) / k * k;\n      } else {\n\tmem[y][x][d] = i;\n      }\n    }\n    cout << y << \" \" << x << \" \" << \"ESWN\"[d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, T b) {\n    if(b<a) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nll H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x;\n    ll cnt;\n    State(int dir,int y,int x,ll cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    ll d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            //printf(\"%d %d %d : %d %d\\n\",s.dir,s.y,s.x,s.cnt,d[s.dir][s.y][s.x]);\n            int diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            int t=(L-s.cnt)/diff;\n            if(t>0&&diff>0) {\n                s.cnt+=(t-1)*diff;\n            }\n            //printf(\"\\t%d\\n\",s.cnt);\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                chmin(d[s.dir][ny][nx],s.cnt+1);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) while(1){}\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(long long h,w,l;cin>>h>>w>>l,h|w|l;){\n    bool s[102][102]={};\n    int x,y,d;\n    string ds=\"NESW\";\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tchar c;\n\tcin>>c;\n\ts[i][j]=c!='#';\n\tif(c!='#'&&c!='.'){\n\t  x=j;\n\t  y=i;\n\t  d=ds.find(c);\n\t}\n      }\n    }\n    long long p[102][102][4];\n    fill(p[0][0],p[102][0],-1);\n    while(l){\n      int dx[]={0,1,0,-1};\n      int dy[]={-1,0,1,0};\n      for(;;){\n\tif(p[y][x][d]!=-1){\n\t  long long m=p[y][x][d]-l;\n\t  if(l>m){\n\t    l=l%m+m;\n\t  }\n\t}\n\tp[y][x][d]=l;\n\tif(s[y+dy[d]][x+dx[d]])break;\n\td=(d+1)%4;\n      }\n      y+=dy[d];\n      x+=dx[d];\n      l--;\n    }\n  end:\n    cout<<y<<' '<<x<<' '<<ds[d]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cassert>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int NORTH = 0;\nconst int EAST = 1;\nconst int SOUTH = 2;\nconst int WEST = 3;\n\nstruct state{\n  int x, y, d;\n  state(){}\n  state(int x, int y, int d):x(x),y(y),d(d){}\n  bool operator == (const state& s) const {\n    return x==s.x&&y==s.y&&d==s.d;\n  }\n};\nvector<state> V;\n\nchar field[MAX][MAX];\nbool come[MAX][MAX][4];\nint W,H,L;\nstate src;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nstring dir = \"NESW\";\n\nvoid init(){\n  memset(come,false,sizeof(come));\n  V.clear();\n}\n\nvoid printFF(){\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++) cout << field[i][j];\n    cout << endl;\n  }\n}\nvoid input(){\n\n  for(int i = 0; i < H; i++)\n    for(int j = 0; j < W; j++){\n      cin >> field[i][j];\n      for(int k = 0; k < (int)dir.length(); k++)\n\tif(field[i][j] == dir[k]) src = state(j,i,k);\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<W&&0<=y&&y<H;}\n\nstate step(const state s){\n  state nex;\n  for(int i = 0; i < 4; i++){\n    nex = s;\n    nex.d = (nex.d+i)%4;\n    nex.x += dx[nex.d];\n    nex.y += dy[nex.d];\n    //  cout << nex.x << \" \" << nex.y << \" \" << nex.d << endl;\n    if(!isInside(nex.x, nex.y) || field[nex.y][nex.x] == '#') continue;\n    return nex;\n  }\n  //  assert(false);\n  nex = s;\n  nex.d = (nex.d+1)%4;\n  return nex;\n}\n\nvoid print(const vector<state>& v) {\n  for(int i = 0; i < (int)v.size(); i++){\n    cout << v[i].x << \" \" << v[i].y << \" \" << v[i].d << endl;\n  }\n  cout << endl;\n}\n\nvector<state> makeMaze(const vector<state> &v,state now){\n  vector<state> ret;\n  bool f = false;\n  for(int i = 0; i < (int)v.size(); i++){\n    if(v[i] == now) f = true;\n    if(f) ret.push_back(v[i]);\n  }\n  return ret;\n}\n\nvoid solve(){\n\n  //  TEST();\n  //return;\n  int rem = L;\n  state now = src;\n  V.push_back(src);\n  come[now.y][now.x][now.d] = true;\n  \n  while(1){\n    now = step(now);\n    if(come[now.y][now.x][now.d]){\n      rem--;\n      V = makeMaze(V,now);\n      break;\n    }\n    come[now.y][now.x][now.d] = true;\n    V.push_back(now);\n    rem--;\n    if(rem == 0){\n      cout << now.y+1 << \" \" << now.x+1 << \" \" << dir[now.d] << endl;\n      return;\n    }\n  }\n  \n  // print(V);\n  rem %= V.size();\n  cout << V[rem].y+1 << \" \" << V[rem].x+1 << \" \" << dir[V[rem].d] << endl;\n}\n\n\nint main(){\n  \n  while(cin >> H >> W >> L && W+H+L){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define m make_pair\n#define se second\n#define f first\n#define N 105\nusing namespace std;\ntypedef pair<char,int> P;\ntypedef long long ll;\nchar Rot(char);\n\nint main(){\n  int h,w,y,x,t,flag;\n  char c;\n  string s[N];\n  P me[N][N];\n  ll l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tme[i][j].f='e';\n      }\n    t=0;\n    me[y][x]=m(c,t);\n    flag=0;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      if(me[y][x].f==c&&flag==0) t=l-(l-me[y][x].se)%(t-me[y][x].se),flag=1;\n      me[ny][nx]=m(c,t);\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define m make_pair\n#define se second\n#define f first\n#define N 105\nusing namespace std;\ntypedef pair<char,int> P;\ntypedef long long ll;\nchar Rot(char);\n\nint main(){\n  int h,w,y,x,flag;\n  char c;\n  string s[N];\n  P me[N][N];\n  ll t,l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tme[i][j].f='e';\n      }\n    t=0;\n    me[y][x]=m(c,t);\n    flag=0;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      if(me[y][x].f==c&&flag==0) t=l-(l-me[y][x].se)%(t-me[y][x].se),flag=1;\n      me[ny][nx]=m(c,t);\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, char> State;\n\nint H, W, L;\nint cnt;\nchar tmp[110][110], field[110][110];\nState pos;\nvector<State> v;\nint Ls;\nchar dir[] = {'N', 'E', 'S', 'W'};\nint diry[] = {1, 0, -1, 0};\nint dirx[] = {0, 1, 0, -1};\n\n\nbool isVisited(State p){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].f.f == p.f.f && v[i].f.s == p.f.s && v[i].s == p.s){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid move(){\n  v.push_back(pos);\n  while(1){\n    if(pos.s == 'N'){\n      while(field[pos.f.s-1][pos.f.f] != '#'){\n\tpos.f.s--;\n\t//if(field[pos.f.s-1][pos.f.f] == '#') pos.s = 'E';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\t\n\tif(cnt == L) return;\n      }\n      pos.s = 'E';\n    }\n    \n    else if(pos.s == 'E'){\n      while(field[pos.f.s][pos.f.f+1] != '#'){\n\tpos.f.f++;\n\t//if(field[pos.f.s][pos.f.f+1] == '#') pos.s = 'S';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\tif(cnt == L) return;\n      }\n      pos.s = 'S';\n    }\n    \n    else if(pos.s == 'S'){\n      while(field[pos.f.s+1][pos.f.f] != '#'){\n\tpos.f.s++;\n\t//if(field[pos.f.s+1][pos.f.f] == '#') pos.s = 'W';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'W';\n    }\n    \n    else if(pos.s == 'W'){\n      while(field[pos.f.s][pos.f.f-1] != '#'){\n\tpos.f.f--;\n\t//if(field[pos.f.s][pos.f.f-1] == '#') pos.s = 'N';\n\tcnt++;\n\tif(isVisited(pos)) return;\n\tv.push_back(pos);\n\n\tif(cnt == L) return;\n      }\n      pos.s = 'N';\n    }\n  }\n}\n\nvoid init(){\n  cnt = 0;\n  v.clear();\n  for(int i = 0 ; i <= H+1 ; i++){\n    field[i][0] = '#';\n    field[0][i] = '#';\n    field[H+1][i] = '#';\n    field[i][W+1] = '#';\n  }\n}\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    cin >> tmp[i];\n  }\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      field[i+1][j+1] = tmp[i][j];\n      if(isalpha(field[i+1][j+1])){\n\tpos.f.f = j+1, pos.f.s = i+1, pos.s = field[i+1][j+1];\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    if(H == 0 && W == 0 && L == 0) break;\n    \n    init();\n    input();\n    \n    bool flag = false;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = dirx[i] + pos.f.f;\n      int ny = diry[i] + pos.f.s;\n      if(field[ny][nx] == '.') flag = true;\n    }\n    if(!flag){\n      cout << pos.f.s << ' ' << pos.f.f << ' ' << pos.s << endl;\n      continue;\n    }\n    move();\n    \n    \n    if(cnt == L){\n      cout << v[v.size()-1].f.s << ' ' << v[v.size()-1].f.f << ' ' << v[v.size()-1].s << endl;\n      continue;\n    }\n    else{\n      L -= cnt;\n      //cout << \"L = \" << L << endl;\n      //cout << \"Ls = \" << Ls << endl;\n      int range = v.size() - Ls;\n      //cout << \"range = \" << range << endl;\n      \n      //int r = L % (Ls+1) + 1;\n      //cout << \"r = \" << r << endl;\n      int ans;\n      if(range == 0) ans = Ls + L-1;\n      else ans = Ls + L % range;\n      //cout << \"ans = \" << ans << endl;\n      //cout << ans-1 << endl;\n\n      cout << v[ans].f.s << ' ' << v[ans].f.f << ' ' << v[ans].s << endl;\n    }    \n    /*\n    for(int i = 0 ; i < v.size() ; i++){\n      cout << i << \": x = \" << v[i].f.f << \", y = \" << v[i].f.s << \", D = \" << v[i].s << endl;\n    }\n    cout << endl;\n    */\n  }\n    \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nconstexpr int NUMBER_OF_DIRECTIONS = 4;\nconst string direction = \"ESWN\";\nconstexpr int dx[NUMBER_OF_DIRECTIONS] = {1, 0, -1, 0};\nconstexpr int dy[NUMBER_OF_DIRECTIONS] = {0, 1, 0, -1};\n\nstruct state {\n\tint x, y, d;\n\tstate(int x = 0, int y = 0, int d = 0):x(x), y(y), d(d){}\n};\n\nostream& operator<<(ostream& os, const state& s) {\n\treturn os << s.y + 1 << \" \" << s.x + 1 << \" \" << direction[s.d];\n}\n\nconst int MAX_SIZE = 100;\nstring field[MAX_SIZE];\nint h, w;\nlong long l;\n\nint label[MAX_SIZE][MAX_SIZE][NUMBER_OF_DIRECTIONS];\nstate states[MAX_SIZE * MAX_SIZE * NUMBER_OF_DIRECTIONS];\n\ninline bool out(int x, int y) {\n\treturn x < 0 || x >= w || y < 0 || y >= h;\n}\n\ninline bool verify(int x, int y) {\n\treturn !out(x, y) && field[y][x] != '#';\n}\n\nstate solve(int x, int y, int d) {\n\tmemset(label, -1, sizeof(label));\n\tfor(int i = 0; i < l; ++i) {\n\t\tif(label[y][x][d] != -1) {\n\t\t\tconst long long T = i - label[y][x][d];\n\t\t\tconst long long rest = l - i;\n\t\t\treturn states[label[y][x][d] + rest % T];\n\t\t}\n\n\t\tlabel[y][x][d] = i;\n\t\tstates[i] = state(x, y, d);\n\n\t\twhile(!verify(x + dx[d], y + dy[d])) d = (d + 1) % NUMBER_OF_DIRECTIONS;\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\n\treturn state(x, y, d);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w >> l && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tstate start;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(isalpha(field[i][j])) {\n\t\t\t\t\tstart.x = j;\n\t\t\t\t\tstart.y = i;\n\t\t\t\t\tstart.d = direction.find(field[i][j]);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tend:;\n\n\t\tcout << solve(start.x, start.y, start.d) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, h, w, l;\n  int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n  char dir[6] = \"NESW\";\n  while( 1 ) {\n  ll x, y, d, cycle;\n  scanf(\"%lld%lld%lld\", &h, &w, &l);\n  if(!h && !w && !l) break;\n  ll a[h][w][4];\n  char c[h][w + 10];\n  for(i = 0; i < h; ++i) {\n    scanf(\"%s\", c[i]);\n    for(j = 0; j < w; ++j) {\n      if(c[i][j] == 'N') x = j, y = i, d = 0;\n      else if(c[i][j] == 'E') x = j, y = i, d = 1;\n      else if(c[i][j] == 'S') x = j, y = i, d = 2;\n      else if(c[i][j] == 'W') x = j, y = i, d = 3;\n    }\n  }\n  for(i = 0; i < h; ++i) for(j = 0; j < w; ++j) for(k = 0; k < 4; ++k) a[i][j][k] = -1;\n  a[y][x][d] = 0;\n  for(i = 0; i < l; ) {\n    if(x + dx[d] >= w || y + dy[d] >= h || x + dx[d] < 0 || y + dy[d] < 0 || c[y + dy[d]][x + dx[d]] == '#') {\n      d = (d + 1) % 4;\n      if(a[y][x][d] == -1) a[y][x][d] = i;\n      else {\n        cycle = i - a[y][x][d];\n        break;\n      }\n    } else {\n      y += dy[d], x += dx[d], ++i;\n      if(a[y][x][d] == -1) a[y][x][d] = i;\n      else {\n        cycle = i - a[y][x][d];\n        break;\n      }\n    }\n  }\n  if(i == l) {\n    printf(\"%lld %lld %c\\n\", y + 1, x + 1, dir[d]);\n    continue;\n  }\n  l -= i;\n  l %= cycle;\n  for(i = 0; i < (!l ? cycle : l); ) {\n    if(x + dx[d] >= w || y + dy[d] >= h || x + dx[d] < 0 || y + dy[d] < 0 || c[y + dy[d]][x + dx[d]] == '#') {\n      d = (d + 1) % 4;\n    } else {\n      y += dy[d], x += dx[d], ++i;\n    }\n  }\n  /*for(i = 0; i < h; ++i) {\n    for(j = 0; j < w; ++j) printf(\"%lld/%lld/%lld/%lld \", a[i][j][0], a[i][j][1], a[i][j][2], a[i][j][3]);\n    printf(\"\\n\");\n  }*/\n  printf(\"%lld %lld %c\\n\", y + 1, x + 1, dir[d]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\ntypedef long long int ll;\n\nstruct State {\n    int x, y, dir;\n};\n\nint N, M;\nll L;\nchar board[110][110];\nState nxt[110][110][4][70];\nstring pat = \"NESW\";\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n    while(cin >> N >> M >> L, N || M || L) {\n        int sx, sy, d;\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<M; j++) {\n                cin >> board[i][j];\n                int f = pat.find(board[i][j]);\n                if(f != (int)string::npos) {\n                    sx = i, sy = j, d = f;\n                }\n            }\n        }\n\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<M; j++) {\n                if(board[i][j] == '#') continue;\n                for(int k=0; k<4; k++) {\n                    int d = k;\n                    int cnt_ng = 0;\n                    while(cnt_ng < 4) {\n                        int nx = i + dx[d], ny = j + dy[d];\n\n                        bool ok = true;\n                        if(nx < 0 || nx >= N || ny < 0 || ny >= M) ok = false;\n                        if(board[nx][ny] == '#') ok = false;\n                        if(ok) {\n                            nxt[i][j][k][0] = State{nx, ny, d};\n                            break;\n                        }\n                        else {\n                            cnt_ng++;\n                            d = (d + 1) % 4;\n                        }\n                    }\n                }\n            }\n        }\n\n        for(int m=1; m<65; m++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    for(int k=0; k<4; k++) {\n                        State t = nxt[i][j][k][m-1];\n                        nxt[i][j][k][m] = nxt[t.x][t.y][t.dir][m-1];\n                    }\n                }\n            }\n        }\n\n        State ans{sx, sy, d};\n        for(int b=0; b<60; b++) {\n            if(L >> b & 1) {\n                ans = nxt[ans.x][ans.y][ans.dir][b];\n            }\n        }\n        printf(\"%d %d %c\\n\", ans.x+1, ans.y+1, pat[ans.dir]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n#define START 'S'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n};\nbool operator< (Robot a, Robot b){\nreturn a.y!=b.y?a.y<b.y:(a.x!=b.x?a.x<b.x:a.dir<b.dir);\n}\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    map<Robot,long long int> visited;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited.count(me)){\n        long long int t = step-visited[me];\n        step = L - L%t;\n      }\n      visited[me]=step;\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint dist[110][110][4];\nchar v[110][110];\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { -1, 0, 1, 0 };\n\nint main(){\n\tll n, m, L;\n\twhile (cin >> n >> m >> L, n){\n\t\tMEMSET(v, 0);\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1) cin >> v[i][j];\n\t\tint r, c, d;\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1){\n\t\t\tif (v[i][j] != '.' && v[i][j] != '#'){\n\t\t\t\trep(dir, 4) if (v[i][j] == \"NESW\"[dir]) tie(r, c, d) = MT(i, j, dir);\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\n\t\tMEMSET(dist, -1);\n\t\tint x = 0;\n\t\tdist[r][c][d] = x++;\n\t\tbool loop = true;\n\t\twhile (L){\n\t\t\tr += dy[d], c += dx[d];\n\t\t\twhile (v[r + dy[d]][c + dx[d]] != '.') d = (d + 1) % 4;\n\t\t\tdist[r][c][d] = x++, L--;\n\t\t\tif (loop && dist[r][c][d] >= 0) L %= (x - dist[r][c][d]), loop = false;\n\t\t}\n\t\tcout << r << ' ' << c << ' ' << \"NESW\"[d] << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[100][100];\nint visited[100][100][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int &dir)\n{\n  cout << \"dir = \" << dir << endl;\n  while(true)\t\t\n    {      \n      src.S = src.S + dx[dir];\n      src.F = src.F + dy[dir];\n      if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t{\n\t  src.S = src.S - dx[dir];\n\t  src.F = src.F - dy[dir];\n\t  dir = (dir+1)%4;\n\t}\n      else if(G[src.S][src.F] == '#')\n\t{\n\t  src.S = src.S - dx[dir];\n\t  src.F = src.F - dy[dir];\n\t  dir = (dir+1)%4;\n\t}\n      else \n\t{\n\t  src.S = src.S - dx[dir];\n\t  src.F = src.F - dy[dir];\n\t  break;\n\t}\n    }\n  cout << \"aft = \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {\n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  while(cin>>h>>w>>l,h||w||l){\n    \n    string st[105];\n    ll i,j,k;\n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n\n    \n    char c[]={'E','S','W','N'};\n    \n    ll rx,ry,rd;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    \n    ll ax[]={1,0,-1,0};\n    ll ay[]={0,1,0,-1};\n    ll dp[105][105][4]={{{}}};\n    \n\n    bool f = true;\n    \n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n      /*\n      if(dp[ry][rx][rd]==0){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\tll s = i-dp[ry][rx][rd];\n\tif((l-i)%s!=0){\n\t  l=i+(l-i)%s;\n\t  f=false;\n\t}\n      }\n      */\n    }\n    cout << ry << \" \" << rx << \" \" << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring mp[101];\nint h,w;\nll n;\n\n\nvoid move(int x,int y,int dir){\n  string str=\"NESW\";\n  int visited[101][101];\n  ll dis[101][101];\n  memset(visited,-1,sizeof(visited));\n  visited[y][x]=dir;\n  dis[y][x]=0;\n  if(h==1&&w==1)n=0;\n\n  while(n!=0){\n    int nx=x+dx[dir];\n    int ny=y+dy[dir];\n    int flg=1;\n    \n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='#'){\n      flg=0;\n      dir=(dir+1)%4;\n      nx=x,ny=y;\n    }\n\n    if(visited[ny][nx]==dir){\n      if(dis[y][x]-dis[ny][nx]+1==0)break;\n      n %=(dis[y][x]-dis[ny][nx]+1);\n      memset(visited,-1,sizeof(visited));\n    }\n\n    dis[ny][nx]=dis[y][x]+flg;\n    n-=flg;\n    visited[ny][nx]=dir;\n    x=nx,y=ny;\n  }\n  cout << y+1 <<\" \"<<x+1<<\" \"<<str[dir]<<endl;\n}\n\n\nint main(){\n  while(1){\n    cin >>h>>w>>n;\n    cout << n<<endl;\n    if(!h&&!w&&!n)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n\n    int dir,sx,sy;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<mp[i].size();j++){\n\tif(mp[i][j]=='.'||mp[i][j]=='#')continue;\n\tsx=j,sy=i;\n\tif(mp[i][j]=='N')dir=0;\n\tif(mp[i][j]=='E')dir=1;\n\tif(mp[i][j]=='S')dir=2;\n\tif(mp[i][j]=='W')dir=3;\n      }\n    move(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nstruct Dog{\n\tint h, w;\n\tint dir;\n};\n\nDog dog, tmp;\n\nint h, w;\nlong long l;\nint dh[4] = {-1,0,1,0};\nint dw[4] = {0,1,0,-1};\nchar d[4] = {'N','E','S','W'};\nint brd[100][100];\n\nint main(){\n\twhile(true){\n\t\tcin >> h >> w >> l;\n\t\tif(h == 0 && w == 0 && l == 0) break;\n\t\trep(i,h){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\trep(j,w){\n\t\t\t\tif(str[j] == '#') brd[i][j] = 1;\n\t\t\t\telse brd[i][j] = 0;\n\t\t\t\tif(str[j] == 'N'){dog.h = i; dog.w = j; dog.dir = 0;}\n\t\t\t\tif(str[j] == 'E'){dog.h = i; dog.w = j; dog.dir = 1;}\n\t\t\t\tif(str[j] == 'W'){dog.h = i; dog.w = j; dog.dir = 3;}\n\t\t\t\tif(str[j] == 'S'){dog.h = i; dog.w = j; dog.dir = 2;}\n\t\t\t}\n\t\t}\n\t\tbool end = false;\n\t\tfor(int i = 1; i <= 100000; i++){\n\t\t\twhile(true){\n\t\t\t\tint hh = dog.h+dh[dog.dir], ww = dog.w+dw[dog.dir];\n\t\t\t\tif(0>hh||hh>=h||0>ww||ww>=w||brd[hh][ww] == 1){\n\t\t\t\t\tdog.dir = (dog.dir+1)%4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdog.h = hh;\n\t\t\t\tdog.w = ww;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(l == i){\n\t\t\t\tend = true;\n\t\t\t\tcout << dog.h+1 << \" \" << dog.w+1 << \" \" << d[dog.dir] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(end) continue;\n\t\ttmp.h = dog.h; tmp.w = dog.w; tmp.dir = dog.dir;\n\t\tl -= 100000;\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\tcnt++;\n\t\t\twhile(true){\n\t\t\t\tint hh = dog.h+dh[dog.dir], ww = dog.w+dw[dog.dir];\n\t\t\t\tif(0>hh||hh>=h||0>ww||ww>=w||brd[hh][ww] == 1){\n\t\t\t\t\tdog.dir = (dog.dir+1)%4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdog.h = hh;\n\t\t\t\tdog.w = ww;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dog.h==tmp.h&&dog.w==tmp.w&&dog.dir==tmp.dir) break;\n\t\t}\n\t\tl %= cnt;\n\t\tfor(int i = 0;;i++){\n\t\t\tif(l == i){\n\t\t\t\tcout << dog.h+1 << \" \" << dog.w+1 << \" \" << d[dog.dir] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(true){\n\t\t\t\tint hh = dog.h+dh[dog.dir], ww = dog.w+dw[dog.dir];\n\t\t\t\tif(0>hh||hh>=h||0>ww||ww>=w||brd[hh][ww] == 1){\n\t\t\t\t\tdog.dir = (dog.dir+1)%4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdog.h = hh;\n\t\t\t\tdog.w = ww;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\ntemplate<class T>\nbool chmin(T &a, T b) {\n    if(b<a) {\n        a=b;\n        return true;\n    }\n    return false;\n}\n\nint H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x,cnt;\n    State(int dir,int y,int x,int cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    int d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            //printf(\"%d %d %d : %d %d\\n\",s.dir,s.y,s.x,s.cnt,d[s.dir][s.y][s.x]);\n            int diff=abs(s.cnt-d[s.dir][s.y][s.x]);\n            int t=(L-s.cnt)/diff;\n            t*=diff;\n            s.cnt+=t;\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                chmin(d[(s.dir+1)%4][s.y][s.x],s.cnt);\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                chmin(d[s.dir][ny][nx],s.cnt+1);\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir=-1;\n        solve(ans,dir);\n        if(dir==-1) while(1){}\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nusing T=tuple<int,int,int>;\n\nint main(){\n    int H,W;\n    int64_t L;\n    while(cin>>H>>W>>L,H){\n        char b[H+2][W+2];\n        fill(b[0],b[H+2],'#');\n        int y,x,d;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                cin>>b[i][j];\n                if(b[i][j]!='.'&&b[i][j]!='#'){\n                    y=i; x=j;\n                    switch(b[i][j]){\n                        case 'N':\n                            d=0;\n                            break;\n                        case 'E':\n                            d=1;\n                            break;\n                        case 'S':\n                            d=2;\n                            break;\n                        case 'W':\n                            d=3;\n                            break;\n                    }\n                }\n            }\n        }\n        int64_t v[H+2][W+2];\n        fill(v[0],v[H+2],0);\n        vector<T> V;\n        int dy[4]={-1,0,1,0};\n        int dx[4]={0,1,0,-1};\n        string s=\"NESW\";\n        bool flag=false;\n        while(true){\n            // cout<<' '<<y<<' '<<x<<' '<<d<<endl;\n            if(b[y+dy[d]][x+dx[d]]!='#'){\n                if(v[y+dy[d]][x+dx[d]]&&!flag){\n                    flag=true;\n                    L=v[y+dy[d]][x+dx[d]]+(L-v[y+dy[d]][x+dx[d]])%(v[y][x]-v[y+dy[d]][x+dx[d]]+1);\n                }else{\n                    v[y+dy[d]][x+dx[d]]=v[y][x]+1;\n                }\n                y+=dy[d]; x+=dx[d];\n                if(v[y][x]==L){\n                    cout<<y<<' '<<x<<' '<<s[d]<<endl;\n                    break;\n                }\n            }else{\n                d=(d+1)%4;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_H 110\n#define MAX_W 110\ntypedef long long ll;\n\nll H,W,L;\nchar field[MAX_H][MAX_W];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nchar getDir(int x){\n  if(x == 0){ return 'W'; }\n  if(x == 1){ return 'N'; }\n  if(x == 2){ return 'E'; }\n  if(x == 3){ return 'S'; }\n}\n\nint getDir(char ch){\n  if(ch == 'W'){ return 0; }\n  if(ch == 'N'){ return 1; }\n  if(ch == 'E'){ return 2; }\n  if(ch == 'S'){ return 3; }\n}\n\nbool inField(int x,int y){\n  return (0 <= x && x < W && 0 <= y && y < H);\n}\n\nvoid solve(int x,int y,int dir){\n  int d[MAX_H][MAX_W][4];\n  memset(d,-1,sizeof(d));\n  d[y][x][dir] = 0;\n\n  while(L > 0){\n    int nx = x + dx[dir],ny = y + dy[dir];\n    if(!inField(nx,ny) || field[ny][nx] == '#'){\n      int ndir = (dir+1) % 4;\n      if(d[y][x][ndir] == -1){\n        d[y][x][ndir] = d[y][x][dir];\n      }else{\n        int diff = d[y][x][dir]-d[y][x][ndir];\n        if(diff > 0 && L >= diff){\n          L %= diff;\n        }\n      }\n      if(L != 0){\n        dir = ndir;\n      }\n    }else{\n      if(d[ny][nx][dir] == -1){\n        d[ny][nx][dir] = d[y][x][dir]+1;\n        L--;\n      }else{\n        L--;\n        int diff = d[y][x][dir]+1-d[ny][nx][dir];\n        if(diff > 0 && L >= diff){\n          L %= diff;\n        }\n      }\n      x = nx; y = ny;\n    }\n  }\n  cout << y+1 << \" \" << x+1 << \" \" << getDir(dir) << endl;\n}\n\nbool check(char ch){\n  if(ch == '.' || ch == '#'){\n    return false;\n  }\n  return true;\n}\n\nint main(){\n  int sx,sy,dir;\n  while(true){\n    cin >> H >> W >> L;\n    if(H == 0 && W == 0 && L == 0){\n      break;\n    }\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(check(field[i][j])){\n          sx = j; sy = i;\n          dir = getDir(field[i][j]);\n          field[i][j] = '.';\n        }\n      }\n    }\n    solve(sx,sy,dir);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define m make_pair\n#define se second\n#define f first\n#define N 105\nusing namespace std;\ntypedef pair<char,int> P;\ntypedef long long ll;\nchar Rot(char);\n\nint main(){\n  int h,w,y,x,t;\n  char c;\n  string s[N];\n  P me[N][N];\n  ll l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tme[i][j].f='e';\n      }\n    t=0;\n    me[y][x]=m(c,t);\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      if(me[y][x].f==c) t=l-(l-me[y][x].se)%(t-me[y][x].se);\n      me[ny][nx]=m(c,t);\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\ntypedef long long int ll;\n\nstruct State {\n    int x, y, dir;\n};\n\nint N, M;\nll L;\nchar board[110][110];\nState nxt[110][110][4][70];\nstring pat = \"NESW\";\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n    while(cin >> N >> M >> L, N || M || L) {\n        int sx, sy, d;\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<M; j++) {\n                cin >> board[i][j];\n                int f = pat.find(board[i][j]);\n                if(f != (int)string::npos) {\n                    sx = i, sy = j, d = f;\n                }\n            }\n        }\n\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<M; j++) {\n                if(board[i][j] == '#') continue;\n                for(int k=0; k<4; k++) {\n                    int d = k;\n                    while(1) {\n                        int nx = i + dx[d], ny = j + dy[d];\n\n                        bool ok = true;\n                        if(nx < 0 || nx >= N || ny < 0 || ny >= M) ok = false;\n                        if(board[nx][ny] == '#') ok = false;\n                        if(ok) {\n                            nxt[i][j][k][0] = State{nx, ny, d};\n                            break;\n                        }\n                        else {\n                            d = (d + 1) % 4;\n                        }\n                    }\n                }\n            }\n        }\n\n        for(int m=1; m<65; m++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    for(int k=0; k<4; k++) {\n                        State t = nxt[i][j][k][m-1];\n                        nxt[i][j][k][m] = nxt[t.x][t.y][t.dir][m-1];\n                    }\n                }\n            }\n        }\n\n        State ans{sx, sy, d};\n        for(int b=0; b<60; b++) {\n            if(L >> b & 1) {\n                ans = nxt[ans.x][ans.y][ans.dir][b];\n            }\n        }\n        printf(\"%d %d %c\\n\", ans.x+1, ans.y+1, pat[ans.dir]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W; ll L;\nint dir, y, x, cost;\nstring const ds = \"WNES\";\n\nmap<tuple<int, int, int>, int> vis;\nvector<tuple<int, int, int>> data_;\nchar G[111][111];\n\nbool in_range(int y, int x, int H, int W) {\n  if(!(0<=y&&y<H&&0<=x&&x<W)) return false;\n  if(G[y][x] == '#') return false;\n  return true;\n}\n\nvoid adjust_dir() {\n  while(!in_range(y + dy[dir], x + dx[dir], H, W)) {\n    dir ++;\n    dir %= 4;\n  }\n}\n\nbool step() {\n  adjust_dir();\n  y += dy[dir], x += dx[dir];\n  cost ++;\n  if(vis.find({y, x, dir}) != vis.end()) {\n    int len = cost - vis[{y, x, dir}];\n    L -= cost;\n    L %= len;\n    int y, x, d; tie(y, x, d) = data_[L];\n    cout << y+1 << \" \" << x+1 << \" \" << ds[d] << endl;\n    return false;\n  }\n  if(cost == L) {\n    cout << y+1 << \" \" << x+1 << \" \" << ds[dir] << endl;\n    return false;\n  }\n  return true;\n}\n\nvoid simulate() {\n\n  vis.clear();\n  data_.clear();\n  cost = 0;\n\n  while(step());\n}\n\nint main() {\n\n  for(; cin >> H >> W >> L && (H | W | L);) {\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if(isalpha(G[i][j])) {\n        y = i, x = j;\n        dir = ds.find(G[i][j]);\n      }\n    }\n\n    simulate();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\nconst char DIRECTION[] = \"ESWN\";\nll passed[102][102][4];\n\nint main(){\n\twhile(true){\n\t\tll H, W, L;\n\t\tcin >> H >> W >> L;\n\t\tif(H == 0 && W == 0 && L == 0){ break; }\n\t\tmemset(passed, -1, sizeof(passed));\n\t\tvector<string> field(H + 2);\n\t\tfield[0] = field[H + 1] = string(W + 2, '#');\n\t\tint x = 0, y = 0;\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring line;\n\t\t\tcin >> line;\n\t\t\tfield[i] = \"#\" + line + \"#\";\n\t\t\tfor(int j = 0; j < field[i].size(); ++j){\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#'){\n\t\t\t\t\tx = j; y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dir = 0;\n\t\tswitch(field[y][x]){\n\t\tcase 'E': dir = 0; break;\n\t\tcase 'S': dir = 1; break;\n\t\tcase 'W': dir = 2; break;\n\t\tcase 'N': dir = 3; break;\n\t\t}\n\t\tfor(ll i = 0; i < L; ++i){\n\t\t\tif(passed[y][x][dir] >= 0){\n\t\t\t\tll duration = i - passed[y][x][dir];\n\t\t\t\ti = (L - i) / duration * duration + i;\n\t\t\t}else{\n\t\t\t\tpassed[y][x][dir] = i;\n\t\t\t}\n\t\t\tint nx = x + dx[dir], ny = y + dy[dir];\n\t\t\twhile(field[ny][nx] == '#'){\n\t\t\t\tdir = (dir + 1) & 0x03;\n\t\t\t\tnx = x + dx[dir]; ny = y + dy[dir];\n\t\t\t}\n\t\t\tx = nx; y = ny;\n\t\t}\n\t\tcout << y << \" \" << x << \" \" << DIRECTION[dir] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long int lli;\n\nint xdir[4] = {0, 1, 0, -1};\nint ydir[4] = {-1, 0, 1, 0};\nchar a[101][101];\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint cnt[101][101][4];\n\nint main()\n{\n  int h, w, p, q, d, dx, dy;\n  lli l, dst;\n\n  while(cin>>h>>w>>l && h+w+l){\n    fill(&cnt[0][0][0], &cnt[101][0][0], -1);\n\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j){\n\tcin >> a[i][j];\n\tif(isalpha(a[i][j])){\n\t  p = i; q = j;\n\t  if(a[i][j] == 'E') d = 1;\n\t  if(a[i][j] == 'N') d = 0;\n\t  if(a[i][j] == 'W') d = 3;\n\t  if(a[i][j] == 'S') d = 2;\n\t  a[i][j] = '.';\n\t  cnt[i][j][d] = 0;\n\t}\n      }\n\n    bool f = false;\n    for(lli i = 1; i <= l; ++i){\n      dy = p+ydir[d]; dx = q+xdir[d];\n      if(0 <= dx && dx < w && 0 <= dy && dy < h && a[dy][dx] == '.'){\n\tp = dy; q = dx;\n\tif(!f){\n\t  if(cnt[p][q][d] == -1) cnt[p][q][d] = i;\n\t  else {\n\t    i = ((l-cnt[p][q][d])/(i-cnt[p][q][d]))*(i-cnt[p][q][d])+cnt[p][q][d];\n\t    f = true;\n\t  }\n\t}\n      } else {\n\t--i;\n\td = (d+1)%4;\n      }\n    }\n\n    cout << (p+1) << \" \" << (q+1) << \" \" << dir[d] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    map<char,int> dir;\n    dir['E'] = 0;\n    dir['S'] = 1;\n    dir['W'] = 2;\n    dir['N'] = 3;\n    map<int,char> dirmap;\n    dirmap[0] = 'E';\n    dirmap[1] = 'S';\n    dirmap[2] = 'W';\n    dirmap[3] = 'N';\n    int dx[] = {1, 0, -1, 0},\n        dy[] = {0, 1, 0, -1};\n\n    while (true) {\n        int H, W; LL L;\n        cin >> H >> W >> L;\n        if (H == 0) break;\n\n        auto S = make_v<bool>(H, W);\n        int si = -1, sj = -1, sd = -1;\n        for (int i = 0; i < H; ++i) {\n            string s; cin >> s;\n            for (int j = 0; j < W; ++j) {\n                S[i][j] = s[j] == '#';\n                if (s[j] == 'E') si = i, sj = j, sd = dir['E'];\n                if (s[j] == 'S') si = i, sj = j, sd = dir['S'];\n                if (s[j] == 'W') si = i, sj = j, sd = dir['W'];\n                if (s[j] == 'N') si = i, sj = j, sd = dir['N'];\n            }\n        }\n        vector<tuple<int,int,int>> trail;\n        map<tuple<int,int,int>,int> trailmap;\n        auto tp = make_tuple(si, sj, sd);\n        trailmap[tp] = 0;\n        trail.push_back(tp);\n\n        int repeat = -1, length = -1;\n        for (int k = 1;; ++k) {\n            while (true) {\n                int x = sj + dx[sd], y = si + dy[sd];\n                if (0 <= x and x < W and 0 <= y and y < H and\n                        !S[y][x]) {\n                    si = y, sj = x;\n                    break;\n                }\n                sd = (sd+1) % 4;\n            }\n\n            auto tp = make_tuple(si, sj, sd);\n            if (trailmap.count(tp)) {\n                repeat = trailmap[tp];\n                length = k - repeat;\n                break;\n            }\n            trailmap[tp] = k;\n            trail.push_back(tp);\n\n        }\n\n        int i, j, d;\n        if (L >= repeat) {\n            tie(i, j, d) = trail[repeat + (L - repeat) % length];\n        } else {\n            tie(i, j, d) = trail[L];\n        }\n        printf(\"%d %d %c\\n\", i+1, j+1, dirmap[d]);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nchar ds[] = \"NESW\";\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint H, W;\nstring s[100];\n\nstruct state {\n\tint x, y;\n\tint d;\n\tstate(int x_, int y_, int d_)\n\t\t: x(x_), y(y_), d(d_) {}\n\tbool operator<(const state& a) const {\n\t\treturn x != a.x ? x < a.x : y != a.y ? y < a.y : d < a.d;\n\t}\n};\n\nstate nex(const state& st) {\n\tint x = st.x, y = st.y, d = st.d;\n\twhile (true) {\n\t\tint tx = x + dx[d], ty = y + dy[d];\n\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#') break;\n\t\td = (d + 1) & 3;\n\t}\n\treturn state(x + dx[d], y + dy[d], d);\n}\n\nstate nex(state st, int cnt) {\n\twhile (cnt--) st = nex(st);\n\treturn st;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tll L;\n\twhile (cin >> H >> W >> L, H | W | L) {\n\t\tint sx = 0, sy = 0, sd = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> s[i];\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] != '.' && s[i][j] != '#') {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tsd = find(ds, ds + 4, s[i][j]) - ds;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstate st(sx, sy, sd);\n\t\tmap<state, int> d;\n\t\tint it = 0;\n\t\tauto tmp = st;\n\t\twhile (!d.count(tmp)) {\n\t\t\td[tmp] = it++;\n\t\t\ttmp = nex(tmp);\n\t\t}\n\t\tint rp = it - d[tmp];\n\t\tif (L < d[tmp]) {\n\t\t\ttmp = nex(st, L);\n\t\t}\n\t\telse {\n\t\t\ttmp = nex(tmp, (L - d[tmp]) % rp);\n\t\t}\n\t\tcout << tmp.x + 1 << ' ' << tmp.y + 1 << ' ' << ds[tmp.d] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n#define START 'S'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    long long int visited[102][102][4] = {0};\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited[me.y][me.x][me.dir]){\n        long long int t = step-visited[me.y][me.x][me.dir];\n        step = L - L%t;\n      }\n      visited[me.y][me.x][me.dir]=step;\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef long long lint;\ntypedef pair< int, int > pii;\ntypedef pair< pii, int > piii;\n\nint H, W, dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nlint L;\nstring grid[110];\n\nint ctd(char c) {\n\tint res = 0;\n\tif (c == 'E') res = 1;\n\tif (c == 'S') res = 2;\n\tif (c == 'W') res = 3;\n\treturn res;\n}\n\nchar dtc(int d) {\n\tchar res = 'N';\n\tif (d == 1) res = 'E';\n\tif (d == 2) res = 'S';\n\tif (d == 3) res = 'W';\n\treturn res;\n}\n\nbool able(int x, int y) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return false;\n\treturn grid[y][x] == '.';\n}\n\nint main() {\n\twhile (cin >> H >> W >> L, H) {\n\t\tint x = 0, y = 0, d = 0;\n\t\t\n\t\tfor_(i,0,H) {\n\t\t\tcin >> grid[i];\n\t\t\tfor_(j,0,W) if (grid[i][j] != '.' && grid[i][j] != '#') {\n\t\t\t\tx = j; y = i;\n\t\t\t\td = ctd(grid[i][j]);\n\t\t\t\tgrid[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\t\n\t\tset< piii > visit;\n\t\tvector< piii > root;\n\t\twhile (visit.find(piii(pii(y, x), d)) == visit.end()) {\n\t\t\tvisit.insert(piii(pii(y, x), d));\n\t\t\troot.push_back(piii(pii(y, x), d));\n\t\t\twhile (!able(x+dx[d], y+dy[d])) d = (d + 1) % 4;\n\t\t\tx += dx[d]; y += dy[d];\n\t\t}\n\t\t\n\t\tint ind = -1, roots = root.size();\n\t\tfor_(i,0,roots) if (root[i] == piii(pii(y, x), d)) { ind = i; break; }\n\t\t\n\t\tint id = (int)((L - (lint)ind) % (lint)(roots - ind)) + ind;\n\t\tpiii ans = root[id];\n\t\tcout << ans.first.first + 1 << \" \" << ans.first.second + 1 << \" \" << dtc(ans.second) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nvoid output(int i,int j,int d)\n{\n\tcout<<i+1<<' '<<j+1<<' '<<\"NESW\"[d]<<endl;\n}\n\nint main()\n{\n\tint h,w; long long l;\n\tfor(;cin>>h>>w>>l,h|w|l;){\n\t\tvector<string> grid(h);\n\t\tfor(int i=0;i<h;i++) cin>>grid[i];\n\t\t\n\t\tvector<vector<int>> vis(h,vector<int>(w,-1)),dir(h,vector<int>(w,-1));\n\t\t\n\t\tqueue<tuple<int,int,int,int>> q; // (i,j,dir,time)\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint d=string(\"NESW\").find(grid[i][j]);\n\t\t\t\tif(d!=-1){\n\t\t\t\t\tq.emplace(i,j,d,0);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\twhile(q.size()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint ci=get<0>(c),cj=get<1>(c),cd=get<2>(c),ct=get<3>(c);\n\t\t\tif(ct==l){\n\t\t\t\toutput(ci,cj,cd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[ci][cj]!=-1 && dir[ci][cj]==cd){\n\t\t\t\tint len=ct-vis[ci][cj];\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tif(vis[i][j]==(l-vis[ci][cj])%len+vis[ci][cj])\n\t\t\t\t\t\t\toutput(i,j,dir[i][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[ci][cj]=ct,dir[ci][cj]=cd;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nd=(cd+i)%4,ni=ci+\"\\xff\\0\\x1\\0\"[nd],nj=cj+\"\\0\\x1\\0\\xff\"[nd];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='#'){\n\t\t\t\t\tq.emplace(ni,nj,nd,ct+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n#define START 'S'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n\n  bool operator< (Robot r) const{return y!=r.y?y<r.y:(x!=r.x?x<r.x:dir<r.dir);}\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    map<Robot,long long int> visited;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited.count(me)){\n        long long int t = step-visited[me];\n        step = L - L%t;\n      }\n      visited[me]=step;\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint main(void){\n\tint h, w, dx[4] = {0,1,0,-1},dy[4] = {-1,0,1,0}, flag[100][100][4], i, j, k, x, y, d;\n\tlong long int l;\n\tchar str[100][101], dir[5] = {\"NEST\"};\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&h,&w,&l);\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tstr[i][j] = getchar();\n\t\t\t\tif(isupper(str[i][j])){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tfor(k = 0;k < 4;k++)\n\t\t\t\t\t\tif(str[i][j] == dir[k]) d = k;\n\t\t\t\t\tstr[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tfor(i = 0;i < l;i++){\n\t\t\tif(flag[y][x][d] == -1)\n\t\t\t\tflag[y][x][d] = i;\n\t\t\telse{\n\t\t\t\ti += (i - flag[y][x][d]) * (l - i) / (i - flag[y][x][d]) + 1; // 残りの歩数 % 一周するのにかかる歩数\n\t\t\t\tmemset(flag,-1,sizeof(flag));\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(x + dx[d] >= 0 && x + dx[d] < w && y + dy[d] >= 0 && y + dy[d] < h && str[y + dy[d]][x + dx[d]] == '.'){\n\t\t\t\t\tx = x + dx[d];\n\t\t\t\t\ty = y + dy[d];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",y + 1,x + 1,dir[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef tuple<int, int, int> P;\n\nconst int H = 100, W = 100;\nchar board[H + 2][W + 2];\n\nint dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\nchar dirs[] = \"WNES\";\n\nint main(){\n\tint h, w, sx, sy, x, y, d;\n\tll l;\n\tvector<P> v;\n\tmap<P, ll> m;\n\twhile(cin >> h >> w >> l, h){\n\t\tm.clear();\n\t\tv.clear();\n\t\tmemset(board, 0, sizeof(board));\n\t\tfor(int i = 0;i < h;++i){\n\t\t\tfor(int j = 0;j < w;++j){\n\t\t\t\tcin >> board[i + 1][j + 1];\n\t\t\t\tif(board[i + 1][j + 1] != '.' && board[i + 1][j + 1] != '#'){\n\t\t\t\t\tsx = j + 1;\n\t\t\t\t\tsy = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchar *ptr = find(dirs, dirs + 4, board[sy][sx]);\n\t\td = (ptr - dirs);\n\t\tP p = make_tuple(sy, sx, d);\n\t\tfor(ll k = 0;k < l;++k) {\n\t\t\tint nx, ny;\n\t\t\ttie(y, x, d) = p;\n\t\t\twhile(board[y + dy[d]][x + dx[d]] == '#' || board[y + dy[d]][x + dx[d]] == 0){\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t\tnx = x + dx[d];\n\t\t\tny = y + dy[d];\n\t\t\tp = make_tuple(ny, nx, d);\n\t\t\tif(m.find(p) != m.end()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm[p] = k;\n\t\t\tv.emplace_back(p);\n\t\t}\n\t\tif(v.size() == l){\n\t\t\ttie(y, x, d) = p;\n\t\t}\n\t\telse {\n\t\t\tll idx = m[p];\n\t\t\tll loop = v.size() - m[p], left = l - v.size();\n\t\t\ttie(y, x, d) = v[idx + ((left + loop - 1) % loop)];\n\t\t}\n\t\tcout << y << \" \" << x << \" \" << dirs[d] << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst char dc[4] = {'E', 'S', 'W', 'N'};\n\nsigned main() {\n  int H, W, L;\n  while ( cin >> H >> W >> L, H ) {\n    char grid[H][W];\n    int used[H][W][4];\n    fill_n(**used, H*W*4, -1);    \n    int y, x, d;    \n    for ( int i = 0; i < H; i++ ) {\n      for ( int j = 0; j < W; j++ ) {\n\tcin >> grid[i][j];\n\tif ( grid[i][j] != '#' && grid[i][j] != '.' ) {\n\t  y = i; x = j;\n\t  if ( grid[i][j] == 'E' ) d = 0;\n\t  if ( grid[i][j] == 'S' ) d = 1;\n\t  if ( grid[i][j] == 'W' ) d = 2;\n\t  if ( grid[i][j] == 'N' ) d = 3;\n\t}\n      }\n    }\n\n    int cnt = 0;\n    bool flag = false;\n    while ( 1 ) {\n      if ( used[y][x][d] >= 0 && !flag ) {\n\tif ( L-cnt-used[y][x][d]-10 > 0 ) {\n\t  cnt += (L-cnt-used[y][x][d]-1)/(cnt-used[y][x][d])*(cnt-used[y][x][d]);\n\t}\n\tflag = true;\n      }\n      if ( cnt >= L ) break;\n      if ( cnt ) used[y][x][d] = cnt;      \n      int nx = x+dx[d], ny = y+dy[d];\n      if ( nx < 0 || ny < 0 || nx >= W || ny >= H || grid[ny][nx] == '#' ) {\n\td = (d+1)%4LL;\t\n      } else {\n\tcnt++;\n\tx = nx;\n\ty = ny;\n\tif ( cnt >= L ) break;\n      }\n    }\n\n    cout << y+1 << \" \" << x+1 << \" \" << dc[d] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100;\nint cost[N][N][4];\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring op=\"NESW\";\nchar m[N][N];\n\nvoid solve(int r,int c,int y,int x,int d,ll step){\n  for(int i=0;i<r;i++)\n    for(int j=0;j<c;j++)\n      for(int k=0;k<4;k++)cost[i][j][k]=-1;\n  int now = 0;\n  while(true){\n    if (cost[y][x][d] != -1){\n      step%=(now-cost[y][x][d]);\n    }else cost[y][x][d] = now;\n    if (step == 0)break;\n    step--;now++;\n    while(x+dx[d] == -1 || x+dx[d] == c || y+dy[d] == -1 || y+dy[d] == r || \n\t  m[y+dy[d]][x+dx[d]] == '#')d=(d+1)%4;\n    x+=dx[d];\n    y+=dy[d];\n  }\n  cout << y+1 <<\" \" << x+1 <<\" \" << op[d] << endl;\n}\n\nmain(){\n  int r,c;ll step;\n  while(cin>>r>>c>>step && r){\n    for(int i=0;i<r;i++)cin>>m[i];\n    int sy,sx,d;\n    for(int i=0;i<r;i++)\n      for(int j=0;j<c;j++)\n\tif (m[i][j] == 'N')sy=i,sx=j,d=0;\n\telse if (m[i][j] == 'E')sy=i,sx=j,d=1;\n\telse if (m[i][j] == 'S')sy=i,sx=j,d=2;\n\telse if (m[i][j] == 'W')sy=i,sx=j,d=3;\n\n    solve(r,c,sy,sx,d,step);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(long long h,w,l;cin>>h>>w>>l,h|w|l;){\n    bool s[102][102]={};\n    int x,y,d;\n    string ds=\"NESW\";\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tchar c;\n\tcin>>c;\n\ts[i][j]=c!='#';\n\tif(c!='#'&&c!='.'){\n\t  x=j;\n\t  y=i;\n\t  d=ds.find(c);\n\t}\n      }\n    }\n    long long p[102][102][4];\n    fill(p[0][0],p[102][0],-1);\n    for(;;){\n      int dx[]={0,1,0,-1};\n      int dy[]={-1,0,1,0};\n      for(;;){\n\tif(p[y][x][d]!=-1){\n\t  l%=(p[y][x][d]-l);\n\t}\n\tif(l==0)goto end;\n\tp[y][x][d]=l;\n\tif(s[y+dy[d]][x+dx[d]])break;\n\td=(d+1)%4;\n      }\n      y+=dy[d];\n      x+=dx[d];\n      l--;\n    }\n  end:\n    cout<<y<<' '<<x<<' '<<ds[d]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H, W;\nll L;\nchar c[128][128];\nint dist[4][128][128]; // N E S W\nint dy[]={-1,0,1,0}, dx[]={0,1,0,-1};\n\nint convert(char ch){ return ch=='N'?0:ch=='E'?1:ch=='S'?2:3; }\nchar reconvert(int n){ return n==0?'N':n==1?'E':n==2?'S':'W'; }\n\nvoid solve(int sy, int sx, int sd){\n  int y=sy,x=sx,dir=sd;\n  dist[dir][y][x] = 0;\n  for(int step=1;;step++){\n    int nd = dir;\n    int ny = y+dy[nd], nx = x+dx[nd];\n    while(ny<0||ny>=H||nx<0||nx>=W||c[ny][nx]=='#'){\n      nd = (nd+1)%4;\n      ny = y+dy[nd], nx = x+dx[nd];\n    }\n\n    if(dist[nd][ny][nx]!=-1){\n      ll l = L-dist[nd][ny][nx];\n      l %= (dist[dir][y][x] - dist[nd][ny][nx] + 1);\n      rep(i,4) rep(j,128) rep(k,128){\n\tif(dist[i][j][k] != l + dist[nd][ny][nx]) continue;\n\tprintf(\"%d %d %c\\n\", j+1, k+1, reconvert(i));\n\treturn;\n      }\n    }\n    y = ny, x = nx, dir = nd;\n    dist[dir][y][x] = step;\n    if(step==L){\n      printf(\"%d %d %c\\n\", y+1, x+1, reconvert(dir));\n      return;\n    }    \n  }\n}\n\nint main(){\n  while(scanf(\"%d%d%lld\", &H,&W, &L) && H+W+L){\n    int sy, sx, sd;\n    memset(dist, -1, sizeof(dist));\n    rep(i,H){\n      scanf(\"%s\", c[i]);\n      rep(j,W){\n\tif(c[i][j]=='#'||c[i][j]=='.') continue;\n\tsy = i; sx = j;\n\tsd = convert(c[i][j]);\n\tc[i][j] = '.';\n      }\n    }\n    \n    //int y = sy, x = sx, dir = sd;\n    //    for(int step=0;;step++){\n    //    }\n    solve(sy, sx, sd);\n    /*    rep(i, 4){\n      rep(j, H){\n\trep(k, W) printf(\"%d \", dist[i][j][k]); puts(\"\");\n      }\n      puts(\"\");\n      }*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string tmp = \"NESW\";\nconst int vy[] = {-1, 0, 1, 0}, vx[] = {0, 1, 0, -1};\nint H, W;\nint64 L;\nstring C[100];\nint sx, sy, sv;\nint64 nxt[100][100][4];\ninline void dfs(int x, int y, int v, int64 step)\n{\n  int nx = x + vx[v], ny = y + vy[v], nv = (v + 1) % 4;\n  if(step == 0) {\n    cout << y + 1 << \" \" << x + 1 << \" \" << tmp[v] << endl;\n    return;\n  } else if(0 <= nx && 0 <= ny && nx < W && ny < H && C[ny][nx] != '#') {\n    int64 loop = ~nxt[nx][ny][v] ? nxt[x][y][v] - nxt[nx][ny][v] + 1 : step;\n    nxt[nx][ny][v] = nxt[x][y][v] + 1;\n    return(dfs(nx, ny, v, (step - 1) % loop));\n  } else {\n    nxt[x][y][nv] = nxt[x][y][v];\n    return(dfs(x, y, nv, step));\n  }\n}\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(nxt, -1, sizeof(nxt));\n    for(int i = 0; i < H; i++) {\n      cin >> C[i];\n      for(int j = 0; j < W; j++) {\n        int p = tmp.find(C[i][j]);\n        if(p != string::npos) sx = j, sy = i, sv = p;\n      }\n    }\n    nxt[sx][sy][sv] = 0;\n    dfs(sx, sy, sv, L);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint h,w;\nstring table[110];\nint dist[110][110][4];\n\nchar dir[4]={'N','E','S','W'};\n\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\n\nint si(ll arg){\n\trep(i,h)rep(j,w)rep(k,4) dist[i][j][k]=inf;\n\n\tint cx,cy,cd,cur=0;\n\n\trep(i,h)rep(j,w)rep(k,4){\n\t\tif(table[i][j]==dir[k]){\n\t\t\tdist[i][j][k]=0;\n\t\t\tcy=i,cx=j,cd=k;\n\t\t}\n\t}\n\n\tint start,end;\n\n\twhile(1){\n\t\trep(i,3){\n\t\t\tint nd=(cd+i)%4;\n\t\t\tint nx=cx+dx[nd];\n\t\t\tint ny=cy+dy[nd];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&table[ny][nx]!='#'){\n\t\t\t\t\tcy=ny,cx=nx,cd=nd;\n\t\t\t\t\tcur++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(dist[cy][cx][cd]!=inf){\n\t\t\tstart=dist[cy][cx][cd];\n\t\t\tend=cur;\n\t\t\tbreak;\n\t\t}\n\t\tdist[cy][cx][cd]=cur;\n\t}\n\tif(arg<=end)\n\t\treturn arg;\n\telse\n\t\treturn (arg-start)%(end-start)+start;\n}\n\nint main(void){\n\tll l;\n\twhile(cin >> h >> w >> l){\n\t\trep(i,h) cin >> table[i];\n\t\tif(h==0)\n\t\t\tbreak;\n\t\tint ans=si(l);\n\t\trep(i,h)rep(j,w)rep(k,4){\n\t\t\tif(dist[i][j][k]==ans)\n\t\t\t\tcout << i+1 << \" \" << j+1 << \" \" << dir[k] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    long long int visited[102][102][4] = {0};\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited[me.y][me.x][me.dir]){\n        long long int t = step - visited[me.y][me.x][me.dir];\n        step = L - L%t;\n      }\n      visited[me.y][me.x][me.dir] = step;\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n\n  bool operator< (Robot r) const{return y!=r.y?y<r.y:(x!=r.x?x<r.x:dir<r.dir);}\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    map<Robot,int> visited;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited.count(me)){\n        long long int dif = step-visited[me];\n        step = L - (L-step)%dif;\n      }else{\n        visited[me] = step;\n      }\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint h, w;\nll l;\nchar c[100][101];\nint d[100][100][4];\n\nint main(){\n\twhile(scanf(\"%d%d%lld\", &h, &w, &l), w){\n\t\trep(i, h){\n\t\t\tscanf(\"%s\", c[i]);\n\t\t}\n\n\t\tint p, q, r;\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tif(c[i][j] == 'N'){\n\t\t\t\t\tr = 0;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'E'){\n\t\t\t\t\tr = 1;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'S'){\n\t\t\t\t\tr = 2;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'W'){\n\t\t\t\t\tr = 3;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp = i;\n\t\t\t\tq = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tfill_n(d[i][j], 4, -1);\n\t\t\t}\n\t\t}\n\t\td[p][q][r] = 0;\n\n\t\tint dx[4] = {-1, 0, 1, 0};\n\t\tint dy[4] = {0, 1, 0, -1};\n\t\twhile(true){\n\t\t\tint v = d[p][q][r];\n\t\t\tint x = p + dx[r];\n\t\t\tint y = q + dy[r];\n\t\t\tif(0 <= x && x < h && 0 <= y && y < w && c[x][y] != '#'){\n\t\t\t\tp = x;\n\t\t\t\tq = y;\n\t\t\t\t++v;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = (r + 1) % 4;\n\t\t\t}\n\n\t\t\tif(v == l){\n\t\t\t\tchar k[5] = \"NESW\";\n\t\t\t\tprintf(\"%d %d %c\\n\", p + 1, q + 1, k[r]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint a = d[p][q][r];\n\t\t\tif(a != -1){\n\t\t\t\tl -= a;\n\t\t\t\tl %= (v - a);\n\n\t\t\t\tif(!l){\n\t\t\t\t\td[p][q][r] = v;\n\n\t\t\t\t\tint i = (r + 1) % 4;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(d[p][q][i] == v){\n\t\t\t\t\t\t\tr = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti = (i + 1) % 4;\n\t\t\t\t\t}\n\n\t\t\t\t\tchar k[5] = \"NESW\";\n\t\t\t\t\tprintf(\"%d %d %c\\n\", p + 1, q + 1, k[r]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\trep(i, h){\n\t\t\t\t\trep(j, w){\n\t\t\t\t\t\tfill_n(d[i][j], 4, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv = 0;\n\t\t\t}\n\n\t\t\td[p][q][r] = v;\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "??¶"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint m[110][110];\nlong long ha[50010];\nstruct\n{\n    int x,y,face;\n}ss[50010];\nint main()\n{\n    int h,w,j,i,sx,sy,start,x,y,face,tt,hash;\n    long long l,ll,ans;\n    char c[1000];\n    while (scanf(\"%d%d%lld\",&h,&w,&l)&&h&&w&&l)\n    {\n        memset(ha,-1,sizeof ha);\n        memset(ss,0,sizeof ss);\n        for (i=1;i<=h;i++)\n        {\n            scanf(\"%s\",c);\n            for (j=1;j<=w;j++)\n            {\n                if (c[j-1]=='#')\n                m[i][j]=0;\n                else if (c[j-1]=='.')\n                m[i][j]=1;\n                else\n                {\n                    m[i][j]=1;\n                    sx=i,sy=j;\n                    if (c[j-1]=='W')\n                        start=1;\n                    if (c[j-1]=='N')\n                        start=2;\n                    if (c[j-1]=='E')\n                        start=3;\n                    if (c[j-1]=='S')\n                        start=4;\n                }\n            }\n        }\n        ll=l;\n       // printf(\"ll = %lld\\n\",ll);\n        x=sx;y=sy;\n        face=start;\n        tt=0;\n        while (ll)\n        {   hash=(face-1)*10000+(x-1)*100+y-1;\n         //   printf(\"%d %d %d %d   %lld\\n\",x,y,face,hash,ha[hash]);\n            if (ha[hash]==-1)\n            {\n                ha[hash]=l-ll;\n                if(ss[l-ll].face == 0){ss[l-ll].x=x,ss[l-ll].y=y,ss[l-ll].face=face;\n             //   printf(\"%d : %d %d %d\\n\",l-ll,ss[l-ll].x,ss[l-ll].y,ss[l-ll].face);\n                }\n            }\n            else\n            {\n                tt=1;\n                ss[ha[hash]].face = face;\n              //  printf(\"l = %lld\\n,l - ll = %lld\\n ll = %lld\\n\",l,l-ll,ll);\n               // printf(\"ha[hash] = %d, hash = %d, l-ll = %lld\\n\",ha[hash],hash,l-ll-ha[hash]);\n\n           //     printf(\"l-ll = %lld %lld  ~%lld\\n\",l,ll,l-ll);\n                ans=ha[hash]+(l-ha[hash])%(l-ll-ha[hash]);\n            //    while (ss[ans].x==ss[ans-1].x&&ss[ans].y==ss[ans-1].y)\n           //         ans--;\n          // printf(\"%d\\n\",ans);\n                printf(\"%d %d \",ss[ans].x,ss[ans].y);\n                if (ss[ans].face==1)\n                printf(\"W\\n\");\n                if (ss[ans].face==2)\n                printf(\"N\\n\");\n                if (ss[ans].face==3)\n                printf(\"E\\n\");\n                if (ss[ans].face==4)\n                printf(\"S\\n\");\n               // printf(\"%d %d %d\",ss[ans-1].x,ss[ans-1].y,ss[ans-1],face);\n                break;\n            }\n            if (face==1)\n            {\n                if (y-1>=1&&m[x][y-1])\n                {\n                    y--;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==2)\n            {\n                if (x-1>=1&&m[x-1][y])\n                {\n                    x--;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==3)\n            {\n                if (y+1<=w&&m[x][y+1])\n                {\n                    y++;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==4)\n            {\n                if (x+1<=h&&m[x+1][y])\n                {\n                    x++;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face=1;\n                    continue;\n                }\n            }\n        }\n        if (tt==0)\n        {\n            printf(\"%d %d \",x,y);\n            if (face==1)\n                printf(\"W\\n\");\n            if (face==2)\n                printf(\"N\\n\");\n            if (face==3)\n                printf(\"E\\n\");\n            if (face==4)\n                printf(\"S\\n\");\n        }\n    }\n    return 0;\n}\n\n/*\n2 2 8\nW.\n..\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    int visited[102][102][4] = {0};\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited[me.y][me.x][me.dir]){\n        long long int t = step - visited[me.y][me.x][me.dir];\n        step = L - L%t;\n      }else{\n        visited[me.y][me.x][me.dir] = step;\n      }\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar dc[]={'N','E','S','W'};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint change(char ch){\n  for(int i=0;i<4;i++)if(dc[i]==ch)return i;\n}\n\nint H,W,L,sx,sy,sdir;\nchar t[100][100];\nstring str;\n\nvoid input();\nvoid solve();\nvoid dfs(int,int,int,int);\n\nint main(){\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0&&W==0&&L==0)break;\n    input();\n    solve();\n  }\n  return 0;\n}\n\nvoid input(){\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      if(str[j]!='#'&&str[j]!='.'){\n\tt[i][j]='.';\n\tsy=i;\n\tsx=j;\n\tsdir=change(str[j]);\n      }else t[i][j]=str[j];\n    }\n  }  \n}\n\nint vd[100][100][4];\n\nvoid solve(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n\tvd[i][j][k]=-1;\n      }\n    }\n  }\n\n  dfs(sy,sx,sdir,0);\n}\n\n\nvoid dfs(int y,int x,int dir,int cnt){\n  dir%=4;\n\n  if(cnt==L){\n    cout<<y+1<<' '<<x+1<<' '<<dc[dir]<<endl;\n    return;\n  }\n  \n  if( L-cnt>=500 && vd[y][x][dir]!=-1 ){\n    int ncnt;\n    ncnt=(L-cnt)%(cnt-vd[y][x][dir]);\n    dfs(y,x,dir,L-ncnt);\n    return;\n  }\n\n  vd[y][x][dir]=cnt;\n  \n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0)dfs(y,x,dir+1,cnt);\n  else if(ny>=H||nx>=W)dfs(y,x,dir+1,cnt);\n  else if(t[ny][nx]=='#')dfs(y,x,dir+1,cnt);\n  else dfs(ny,nx,dir,cnt+1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst char *dir = \"NWSE\";\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint h, w;\nll l, p[100][101][4];\nchar in[100][101];\n\nint main(){\n\twhile(cin >> h >> w >> l, h){\n\t\tint y, x, d;\n\t\trep(i, h){\n\t\t\tcin >> in[i];\n\t\t\trep(j, w) if(isalpha(in[i][j])) y = i, x = j;\n\t\t}\n\t\tfor(d = 0; dir[d] != in[y][x]; d++);\n\t\t\n\t\tmemset(p, -1, sizeof(p));\n\t\tll t = 0;\n\t\twhile(t < l){\n\t\t\tif(p[y][x][d] >= 0){\n\t\t\t\tll T = t - p[y][x][d];\n\t\t\t\tt += (l - t) / T * T;\n\t\t\t\tif(t == l) break;\n\t\t\t}\n\t\t\tp[y][x][d] = t;\n\t\t\t\n\t\t\trep(it, 4){\n\t\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w || in[ny][nx] == '#'){\n\t\t\t\t\td = (d + 3) % 4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ty = ny; x = nx; break;\n\t\t\t}\n\t\t\tt++;\n\t\t}\n\t\tcout << y + 1 << \" \" << x + 1 << \" \" << dir[d] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define m make_pair\n#define se second\n#define f first\n#define N 101\nusing namespace std;\ntypedef pair<char,int> P;\ntypedef long long ll;\nchar Rot(char);\n\nint main(){\n  int h,w,y,x,t;\n  char c;\n  string s[N];\n  P me[N][N];\n  ll l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tme[i][j].f='e';\n      }\n    t=0;\n    me[y][x]=m(c,t);\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      if(me[y][x].f==c) t=l-(l-me[y][x].se)%(t-me[y][x].se);\n      me[ny][nx]=m(c,t);\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define MAX 1000\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[MAX][MAX];\nint visited[MAX][MAX][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int x,int y,int &dir)\n{\n  while(true)\t\t\n    {      \n      x = x - dx[dir];\n      y = y - dy[dir];\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  y = y + dy[dir];\n\t  x = x + dx[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\tbreak;\n    }\n}\n\nvoid move2(int H,int W,int x,int y,int &dir)\n{\n  while(true)\t\t\n    {      \n      x = x + dx[dir];\n      y = y + dy[dir];\n      if(!(0 <= x && x < W && 0 <= y && y < H))\n\t{\n\t  y = y - dy[dir];\n\t  x = x - dx[dir];\n\t  dir = (dir+1)%4;\n\t}\n      else if(G[y][x] == '#')\n\t{\n\t  y = y - dy[dir];\n\t  x = x - dx[dir];\n\t  dir = (dir+1)%4;\n\t}\n      else \n\tbreak;\n    }\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,line.size())\n\t    {\n\t      assert(j < W);\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n\n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      move(H,W,src.F,src.S,dir);\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    { \n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      L += (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<L;i++)\n\t\t{\n\t\t  src.F += dx[dir];\n\t\t  src.S += dy[dir];\n\t\t  \n\t\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\n\t\t  else if(G[src.S][src.F] == '#')\n\t\t    {\n\t\t      src.F -= dx[dir];\n\t\t      src.S -= dy[dir];\n\t\t      dir = (dir+1)%4;\n\t\t      i--;\n\t\t      continue;\n\t\t    }\t\n\t\t}\n\t   \n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;\n\t      \n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint H, W; ll L;\nbool wall[101][101];\nint memo[101][101][4];\nmap<int, char> dir2;\nbool ok(int x, int y){\n    return 0 <= x && 0 <= y && x < W && y < H && !wall[y][x];\n}\nvoid solve(int turn, int cx, int cy, int cd){\n    if((ll)(turn - 1) == L){\n        cout << cy + 1 << ' ' << cx + 1 << ' ' << dir2[cd] << endl;\n        return;\n    }\n    int nx, ny, nd;\n    rep(i, 4){\n        nd = (cd + i) % 4;\n        nx = cx + dx[nd]; ny = cy + dy[nd];\n        if(ok(nx, ny)) break;\n    }\n    if(memo[ny][nx][nd] == -1){\n        memo[ny][nx][nd] = turn;\n        solve(turn + 1, nx, ny, nd);\n    }else{\n        int temp = memo[ny][nx][nd];\n        ll mo = (L - (ll)turn) % (ll)(turn - temp);\n        rep(i, H) rep(j, W) rep(k, 4)\n          if(memo[i][j][k] == temp + (int)mo){\n              cout << i + 1 << ' ' << j + 1 << ' ' << dir2[k] << endl;\n              return;\n          }\n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    map<char, int> dir1;\n    dir1['N'] = 3; dir1['E'] = 0; dir1['S'] = 1; dir1['W'] = 2;\n    for(const auto& k : dir1) dir2[k.second] = k.first;\n    while(cin >> H >> W >> L && H){\n        int sx, sy, sd;\n        memset(wall, 0, sizeof(wall));\n        memset(memo, -1, sizeof(memo));\n        rep(i, H){\n            cin >> s;\n            rep(j, W){\n                if(s[j] == '#') wall[i][j] = true;\n                if('A' <= s[j] && s[j] <= 'Z'){\n                    sx = j; sy = i; sd = dir1[s[j]];\n                }\n            }\n        }\n        memo[sy][sx][sd] = 0;\n        solve(1, sx, sy, sd);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint mem[110][110][4];\n\nint main() {\n  int h, w, n;\n  string m[110];\n  while (true) {\n    cin >> h >> w >> n;\n    if (h == 0 && w == 0 && n == 0) break;\n    rep (i, h) cin >> m[i + 1];\n    m[0] = m[h + 1] = \"\";\n    rep (i, w) m[0] += \"#\";\n    rep (i, w) m[h + 1] += \"#\";\n    rep (i, h + 2) m[i] = \"#\" + m[i] + \"#\";\n    h += 2;\n    w += 2;\n    int x, y, d;\n    rep (i, h) rep (j, w) {\n      if (m[i][j] == 'E') d = 0;\n      if (m[i][j] == 'S') d = 1;\n      if (m[i][j] == 'W') d = 2;\n      if (m[i][j] == 'N') d = 3;\n      if (isalpha(m[i][j])) {\n\tx = j;\n\ty = i;\n      }\n    }\n    rep (i, 110) rep (j, 110) rep (k, 4) mem[i][j][k] = -1;\n    rep (i, n) {\n      int xx = x + dx[d], yy = y + dy[d];\n      while (m[yy][xx] == '#') {\n\td = (d + 1) % 4;\n\txx = x + dx[d];\n\tyy = y + dy[d];\n      }\n      x = xx;\n      y = yy;\n      if (mem[y][x][d] != -1) {\n\tint k = i - mem[y][x][d];\n\ti += (n - i) / k * k;\n      } else {\n\tmem[y][x][d] = i;\n      }\n    }\n    cout << y << \" \" << x << \" \" << \"ESWN\"[d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint h, w;\nll l;\nchar c[100][101];\nint d[100][100][4];\n\nint main(){\n\twhile(scanf(\"%d%d%lld\", &h, &w, &l), w){\n\t\trep(i, h){\n\t\t\tscanf(\"%s\", c[i]);\n\t\t}\n\n\t\tint p, q, r;\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tif(c[i][j] == 'N'){\n\t\t\t\t\tr = 0;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'E'){\n\t\t\t\t\tr = 1;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'S'){\n\t\t\t\t\tr = 2;\n\t\t\t\t}\n\t\t\t\telse if(c[i][j] == 'W'){\n\t\t\t\t\tr = 3;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp = i;\n\t\t\t\tq = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tfill_n(d[i][j], 4, -1);\n\t\t\t}\n\t\t}\n\t\td[p][q][r] = 0;\n\n\t\tint dx[4] = {-1, 0, 1, 0};\n\t\tint dy[4] = {0, 1, 0, -1};\n\t\twhile(true){\n\t\t\tint v = d[p][q][r];\n\t\t\tint x = p + dx[r];\n\t\t\tint y = q + dy[r];\n\t\t\tif(0 <= x && x < h && 0 <= y && y < w && c[x][y] != '#'){\n\t\t\t\tp = x;\n\t\t\t\tq = y;\n\t\t\t\t++v;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = (r + 1) % 4;\n\t\t\t}\n\n\t\t\tint a = d[p][q][r];\n\t\t\tif(a != -1){\n\t\t\t\tl -= a;\n\t\t\t\tl %= (v - a);\n\t\t\t\t\n\t\t\t\trep(i, h){\n\t\t\t\t\trep(j, w){\n\t\t\t\t\t\tfill_n(d[i][j], 4, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv = 0;\n\t\t\t}\n\n\t\t\tif(v == l){\n\t\t\t\tchar k[5] = \"NESW\";\n\t\t\t\tprintf(\"%d %d %c\\n\", p + 1, q + 1, k[r]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\td[p][q][r] = v;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  ll i,j,k;\n  ll dp[200][200][4]={{{}}};\n  string st[200];\n  char c[]={'E','S','W','N'};\n  ll rx,ry,rd;\n  ll ax[]={1,0,-1,0};\n  ll ay[]={0,1,0,-1};\n  bool f;\n  ll s;\n  while(cin>>h>>w>>l,h||w||l){\n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    fill(dp[0][0],dp[104][104],0);\n    f = true;\n    for(i=1;i<=l;i++){\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(dp[ry][rx][rd]==0){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\ts = i - dp[ry][rx][rd];\n\t//l=i+(l-i)%s;\n\ti+=(l-i)/s*s;\n\tf=false;\n      }\n      if(i==l) break;\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n    }\n    cout << ry << ' ' << rx << ' ' << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar dc[] = {'N', 'E', 'S', 'W'};\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nint main() {\n\tint H, W;\n\tll L;\n\twhile(cin >> H >> W >> L, H) {\n\t\tvs field(H);\n\t\tREP(i, H) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tint cx, cy, cd;\n\t\tREP(i, H) {\n\t\t\tREP(j, W) {\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#') {\n\t\t\t\t\tcy = i;\n\t\t\t\t\tcx = j;\n\t\t\t\t\tswitch(field[i][j]) {\n\t\t\t\t\tcase 'N':\n\t\t\t\t\t\tcd = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tcd = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tcd = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tcd = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vvl> visit(H, vvl(W, vl(4, 0)));\n\t\tbool loop = false;\n\t\tll sl, cycle;\n\t\tfor(ll t = 0; t < L; t++) {\n\t\t\tif(!loop) {\n\t\t\t\tif(visit[cy][cx][cd] != 0) {\n\t\t\t\t\tsl = visit[cy][cx][cd];\n\t\t\t\t\tcycle = t-sl;\n\t\t\t\t\tt += (((L-t)/cycle) * cycle);\n\t\t\t\t\tif(t == L) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tloop = true;\n\t\t\t\t} else {\n\t\t\t\t\tvisit[cy][cx][cd] = t;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint nx = cx + dx[cd];\n\t\t\tint ny = cy + dy[cd];\n\t\t\tif(0 <= ny && ny < H && 0 <= nx && nx < W && field[ny][nx] != '#') {\n\t\t\t\tcx = nx;\n\t\t\t\tcy = ny;\n\t\t\t} else {\n\t\t\t\tcd = (cd+1)%4;\n\t\t\t\tt--;\n\t\t\t}\n\t\t}\n\n\t\tcout << cy+1 << \" \" << cx+1 << \" \" << dc[cd] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\n\nchar dc[]={'N','E','S','W'};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint change(char ch){\n  for(int i=0;i<4;i++)if(dc[i]==ch)return i;\n}\n\nint H,W,sx,sy,sdir;\nll L;\nchar t[100][100];\nstring str;\n\nvoid input();\nvoid solve();\nvoid dfs(int,int,int,ll);\n\nint main(){\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0&&W==0&&L==0)break;\n    input();\n    solve();\n  }\n  return 0;\n}\n\nvoid input(){\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      if(str[j]!='#'&&str[j]!='.'){\n\tt[i][j]='.';\n\tsy=i;\n\tsx=j;\n\tsdir=change(str[j]);\n      }else t[i][j]=str[j];\n    }\n  }  \n}\n\nll vd[100][100][4];\n\nvoid solve(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n\tvd[i][j][k]=-1;\n      }\n    }\n  }\n\n  dfs(sy,sx,sdir,0);\n}\n\n\nvoid dfs(int y,int x,int dir,ll cnt){\n  dir%=4;\n\n  if(cnt==L){\n    cout<<y+1<<' '<<x+1<<' '<<dc[dir]<<endl;\n    return;\n  }\n  \n  if( L-cnt>=500LL && vd[y][x][dir]!=-1 ){\n    ll ncnt;\n    ncnt=(L-cnt)%(cnt-vd[y][x][dir]);\n    dfs(y,x,dir,L-ncnt);\n    return;\n  }\n\n  vd[y][x][dir]=cnt;\n  \n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0)dfs(y,x,dir+1,cnt);\n  else if(ny>=H||nx>=W)dfs(y,x,dir+1,cnt);\n  else if(t[ny][nx]=='#')dfs(y,x,dir+1,cnt);\n  else dfs(ny,nx,dir,cnt+1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint h, w;\nlint L;\n\nvoid solve(){\n    char c[h][w];\n    int sx, sy, sd;\n    rep(i, h)rep(j, w){\n        scanf(\" %c\", &c[i][j]);\n        if(c[i][j] != '.' && c[i][j] != '#'){\n            sx = i; sy = j;\n            if(c[i][j] == 'E') sd = 0;\n            if(c[i][j] == 'S') sd = 1;\n            if(c[i][j] == 'W') sd = 2;\n            if(c[i][j] == 'N') sd = 3;\n        }\n    }\n\n    pair<pii, int> nxt[60][h][w][4]; // 2^k steps, (x, y, dir)\n    rep(x, h)rep(y, w)rep(dir, 4){\n        nxt[0][x][y][dir] = {{x, y}, dir};\n        for(int nd = dir; nd != dir + 4; ++nd){\n            int nx = x + dx[nd % 4], ny = y + dy[nd % 4];\n            if(0<=nx && nx<h && 0<=ny && ny<w && c[nx][ny] != '#'){\n                nxt[0][x][y][dir] = {{nx, ny}, nd % 4};\n                break;\n            }\n        }\n    }\n    For(k, 1, 60)rep(x, h)rep(y, w)rep(dir, 4){\n        auto p = nxt[k-1][x][y][dir];\n        int nx = p.fi.fi, ny = p.fi.se, nd = p.se;\n        nxt[k][x][y][dir] = nxt[k-1][nx][ny][nd];\n    }\n\n    rep(k, 60)if(L>>k & 1){\n        auto p = nxt[k][sx][sy][sd];\n        sx = p.fi.fi; sy = p.fi.se; sd = p.se;\n    }\n\n    char cd;\n    if(sd == 0) cd = 'E';\n    if(sd == 1) cd = 'S';\n    if(sd == 2) cd = 'W';\n    if(sd == 3) cd = 'N';\n    printf(\"%d %d %c\\n\", sx+1, sy+1, cd);\n}\n\nint main(){\n    while(scanf(\"%d%d%lld\", &h, &w, &L) && h){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e17\n\nll h,w;\nll L;\nstring s[111];\nchar cs[]={'E','N','W','S'};\nmap<char,int> dir;\n\nll dist[111][111][5];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nint main(){\n\tcin.sync_with_stdio(false);\n  dir['E']=0; dir['N']=1; dir['W']=2; dir['S']=3;\n  while(1){\n    cin>>h>>w>>L;\n    if(h==0)break;\n    s[0]=s[h+1]=\"\";\n    rep(j,w+2){\n      s[0]+='#';\n      s[h+1]+='#';\n    }\n    repl(i,1,h+1){\n      string ss;\n      cin>>ss;\n      s[i]='#'+ss+'#';\n    }\n    h+=2; w+=2;\n    ll ni,nj,nd,nl=0;\n    rep(i,h)rep(j,w){\n      if(s[i][j]!='#'&&s[i][j]!='.'){\n        ni=i; nj=j; nd=dir[s[i][j]];\n      }\n    }\n    rep(i,111)rep(j,111)rep(k,5)dist[i][j][k]=INF;\n    while(dist[ni][nj][nd]==INF&&L>0){\n      //dbg(ni); dbg(nj); dbg(nd);\n      //dbg(dist[ni][nj][nd]);\n      dist[ni][nj][nd]=nl;\n      ll ti=ni+dy[nd],tj=nj+dx[nd];\n      if(s[ti][tj]=='#'){\n        nd=(nd+3)%4;\n      }else{\n        ni=ti; nj=tj;\n        nl++; L--;\n      }\n    }\n    if(L==0){\n      printf(\"%lld %lld %c\\n\", ni,nj,cs[nd]);\n    }else{\n      ll loop=nl-dist[ni][nj][nd];\n      L%=loop;\n      if(L==0)L=loop;\n      //rep(i,111)rep(j,111)rep(k,5)dist[i][j][k]=INF;\n      while(L>0){\n        ll ti=ni+dy[nd],tj=nj+dx[nd];\n        if(s[ti][tj]=='#'){\n          nd=(nd+3)%4;\n        }else{\n          ni=ti; nj=tj;\n          L--;\n        }\n      }\n      printf(\"%lld %lld %c\\n\", ni,nj,cs[nd]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n//using namespace std;\n//typedef long long ll;\n//typedef pair<int, int> pii;\n//typedef pair<ll, ll> pll;\n//const int INF = 1e9;\n//const ll LINF = 1e18;\n//\n//int dy[4] = {1,0,-1,0};\n//int dx[4] = {0,1,0,-1};\n//\n//using Item = tuple<int,int,int>;\n//map<Item,bool> mp;\n//map<Item,int> Idx;\n//vector<Item> Q;\n//map<int,char> dir2S;\n//\n//int main(void) {\n//    cin.tie(0); ios::sync_with_stdio(false);\n//    dir2S[0] = 'S';\n//    dir2S[1] = 'E';\n//    dir2S[2] = 'N';\n//    dir2S[3] = 'W';\n//\n//    ll H,W,L;\n//    while(cin >> H >> W >> L,H){\n//        mp.clear(); Q.clear(); Idx.clear();\n//\n//        vector<vector<char>> maze(H+2,vector<char>(W+2,'#'));\n//        pii start;\n//        int dir = -1;\n//        for(int i = 1; i <= H; i++){\n//            for(int j = 1; j <= W;j++){\n//                cin >> maze[i][j];\n//\n//                if(maze[i][j] == '#' || maze[i][j] == '.') continue;\n//                if(maze[i][j] == 'S'){\n//                    dir = 0;\n//                }\n//                if(maze[i][j] == 'E'){\n//                    dir = 1;\n//                }\n//                if(maze[i][j] == 'N'){\n//                    dir = 2;\n//                }\n//                if(maze[i][j] == 'W'){\n//                    dir = 3;\n//                }\n//\n//                maze[i][j] = '.';\n//\n//                start = {i,j};\n//            }\n//        }\n//\n//        Item item = Item(start.first,start.second,dir);\n//        Q.push_back(item);\n//        while(true){\n//            if(mp[item]) break;\n//            mp[item] = true;\n//            int y,x,dir; tie(y,x,dir) = item;\n//\n//            while(true){\n//                int ny = y + dy[dir];\n//                int nx = x + dx[dir];\n//                if(maze[ny][nx] == '#'){\n//                    dir = (dir + 3)%4;\n//                    continue;\n//                }\n//                item = Item(ny,nx,dir);\n//                Q.push_back(item);\n//                break;\n//            }\n//        }\n//\n//        for(auto item:Q){\n//            int y,x,dir; tie(y,x,dir) = item;\n//            //cout << y << \" \" << x << \" \" << dir << endl;\n//        }\n//        if(L < Q.size()){\n//            int y,x,dir; tie(y,x,dir) = Q[L];\n//            cout << y << \" \" << x  << \" \" << dir2S[dir] << endl;\n//            continue;\n//        }\n//        for(int i = 0; i < Q.size(); i++){\n//            if(Idx.count(Q[i])){\n//                L -= Idx[Q[i]];\n//                L %= (i - Idx[Q[i]]);\n//\n//                int y,x,dir; tie(y,x,dir) = Q[L+Idx[Q[i]]];\n//                cout << y << \" \" << x  << \" \" << dir2S[dir] << endl;\n//                break;\n//            }else{\n//                Idx[Q[i]] = i;\n//            }\n//        }\n//    }\n//    return 0;\n//}\n\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,s,t) for(int i = s ; i < t ; i++)\n#define SZ(a) ((int)a.size())\nusing LL = long long;\n\nint main() {\n    \n    int H, W;\n    LL L;\n    while (cin >> H >> W >> L, H || W || L) {\n        vector<string>a(H);\n        FOR(i, 0, H) {\n            cin >> a[i];\n        }\n        const int DY[] = { 0,0,1,-1 };// E,W,S,N\n        const int DX[] = { 1,-1,0,0 };\n        const int nxd[] = { 2,3,1,0 };\n        auto isin = [](int a, int b, int c) { return a <= b && b < c; };\n        using PII = pair<int, int>;\n        int unchi = 0;\n        string EWSN = \"EWSN\";\n        PII S;\n        FOR(i, 0, H) {\n            FOR(j, 0, W) {\n                if (isalpha(a[i][j])) {\n                    S = PII(i, j);\n                }\n            }\n        }\n        int ny = S.first, nx = S.second; // 名前カス\n        int dir = 0;\n        {\n            char c = a[S.first][S.second];\n            dir = EWSN.find(c);\n        }\n        \n        auto f = [&](LL& left, int &y, int &x) {\n            vector<vector<vector<int>>>ti(H, vector<vector<int>>(W, vector<int>(4,-1)));\n            int tt = 0;\n            ti[S.first][S.second][dir] = 0;\n            while (left) {\n                //cout << \"NOW:\" << y << \",\" << x << endl;\n                left--;\n                int ny = DY[dir] + y, nx = DX[dir] + x;\n                while (!isin(0, ny, H) || !isin(0, nx, W) || a[ny][nx] == '#') {\n                    // change dir\n                    //cout << dir << \",\" << nxd[dir] << endl;\n                    dir = nxd[dir];\n                    ny = DY[dir] + y;\n                    nx = DX[dir] + x;\n                    //    cout << \"to:\" << ny << \",\" << nx << endl;\n                }\n                if (ti[ny][nx][dir] != -1) {\n                    unchi = tt - ti[ny][nx][dir] + 1;\n                }\n                ti[ny][nx][dir] = ++tt;\n                //cout << ny << \",\" << nx << \"|\" << y << \",\" << x << endl;\n                y = ny;\n                x = nx;\n            }\n            return dir;\n        };\n        if (L <= 100000) {\n            int id = f(L, ny, nx);\n            // やる\n            cout << ny + 1<<\" \" << nx + 1 << \" \";\n            cout << EWSN[id] << endl;\n        }\n        else {\n            // 一度ループしてなんかしたら，うくをする\n            LL X = 100000;\n            L -= 100000;\n            f(X, ny, nx);\n            LL loop = 0;\n            { // loopもとめる & Lをへらす\n                // うく\n                loop = unchi;\n            }\n            \n            LL x = L / loop;\n            L -= x * loop;\n            int id = f(L, ny, nx);\n            // やる\n            cout << ny + 1 << \" \" << nx + 1 << \" \";\n            cout << EWSN[id] << endl;\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nvoid output(int i,int j,int d)\n{\n\tcout<<i+1<<' '<<j+1<<' '<<\"NESW\"[d]<<endl;\n}\n\nint main()\n{\n\tfor(int h,w,l;cin>>h>>w>>l,h|w|l;){\n\t\tvector<string> grid(h);\n\t\tfor(int i=0;i<h;i++) cin>>grid[i];\n\t\t\n\t\tvector<vector<int>> vis(h,vector<int>(w,-1)),dir(h,vector<int>(w,-1));\n\t\t\n\t\tqueue<tuple<int,int,int,int>> q; // (i,j,dir,time)\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint d=string(\"NESW\").find(grid[i][j]);\n\t\t\t\tif(d!=-1){\n\t\t\t\t\tq.emplace(i,j,d,0);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\twhile(q.size()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint ci=get<0>(c),cj=get<1>(c),cd=get<2>(c),ct=get<3>(c);\n\t\t\tif(ct==l){\n\t\t\t\toutput(ci,cj,cd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[ci][cj]!=-1){\n\t\t\t\tint len=ct-vis[ci][cj];\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tif(vis[i][j]==(l-vis[ci][cj])%len+vis[ci][cj])\n\t\t\t\t\t\t\toutput(i,j,dir[i][j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[ci][cj]=ct,dir[ci][cj]=cd;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nd=(cd+i)%4,ni=ci+\"\\xff\\0\\x1\\0\"[nd],nj=cj+\"\\0\\x1\\0\\xff\"[nd];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='#'){\n\t\t\t\t\tq.emplace(ni,nj,nd,ct+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nint H, W;\nll L;\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = { -1, 0, 1, 0};\nint getDir(char c) {\n    if (c == 'N') return 0;\n    if (c == 'W') return 1;\n    if (c == 'S') return 2;\n    if (c == 'E') return 3;\n}\nstring DIR = \"NWSE\";\nchar toDir(int x) {\n    return DIR[x];\n}\n\nint nxtDir(int dir) {\n    return (dir + 3) % 4;\n}\nvoid addWall(vector<string>& s, int& H, int& W, char wall = '#') {\n    s.insert(s.begin(), string(W, wall));\n    s.push_back(string(W, wall));\n    for (auto& t : s) t = wall + t + wall;\n    H = s.size();\n    W = s[0].size();\n}\n\nint d[110][110][5];\nvector<string> s;\n\nint main() {\n    while (cin >> H >> W >> L) {\n        if (H == 0 && W == 0 && L == 0) break;\n        s.clear();\n        s.resize(H);\n        rep(i, H) cin >> s[i];\n        addWall(s, H, W);\n        rep(i, 110) rep(j, 110) rep(k, 5) d[i][j][k] = -1;\n        int dir = -1;\n        int x, y;\n        rep(i, H) rep(j, W) {\n            if (s[i][j] != '#' && s[i][j] != '.') {\n                x = j;\n                y = i;\n                dir = getDir(s[i][j]);\n            }\n        }\n        {\n            bool f = true;\n            rep(i, 4) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (s[ny][nx] != '#') {\n                    f = false;\n                }\n            }\n            if (f) {\n                rep(i, L % 4) dir = nxtDir(dir);\n                cout << y << \" \" << x << \" \" << toDir(dir) << endl;\n                continue;\n            }\n        }\n        d[y][x][dir] = 0;\n        // cout << y << \" \" << x << \" \" << dir << endl;\n        ll cnt = 0;\n        while (cnt < L) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            int p_dir = dir;\n            while (s[ny][nx] == '#') {\n                dir = nxtDir(dir);\n                nx = x + dx[dir];\n                ny = y + dy[dir];\n            }\n            // cout << ny << \" \" << nx << \" \" << dir << endl;\n            if (d[ny][nx][dir] != -1) {\n                ll dif = d[y][x][p_dir] + 1 - d[ny][nx][dir];\n                // L = (L - dif) % 4;\n                ll R = L -cnt;\n                R -= R/dif*dif;\n                L = cnt + R;\n                rep(i, 110) rep(j, 110) rep(k, 5) d[i][j][k] = -1;\n                d[ny][nx][dir] = 0;\n            } else {\n                d[ny][nx][dir] = d[y][x][p_dir] + 1;\n            }\n            y = ny;\n            x = nx;\n            cnt++;\n        }\n        cout << y << \" \" << x << \" \" << toDir(dir) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define m make_pair\n#define se second\n#define f first\n#define N 105\nusing namespace std;\ntypedef pair<char,int> P;\ntypedef long long ll;\nchar Rot(char);\n\nint main(){\n  ll h,w,y,x,t,flag;\n  char c;\n  string s[N];\n  P me[N][N];\n  ll l;\n  while(1){\n    cin>>h>>w>>l;\n    if(!h&&!w&&!l) break;\n    for(int i=0;i<h;i++) cin>>s[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(s[i][j]!='.'&&s[i][j]!='#') y=i,x=j,c=s[i][j];\n\tme[i][j].f='e';\n      }\n    t=0;\n    me[y][x]=m(c,t);\n    flag=0;\n    while(1){\n      int ny=y,nx=x;\n      if(c=='N') ny--;\n      if(c=='E') nx++;\n      if(c=='S') ny++;\n      if(c=='W') nx--;\n      if(ny<0||h<=ny||nx<0||w<=nx||s[ny][nx]=='#') ny=y,nx=x,c=Rot(c),t--;\n      t++;\n      y=ny,x=nx;\n      if(l==t) break;\n      if(me[y][x].f==c&&flag==0) t=l-(l-me[y][x].se)%(t-me[y][x].se),flag=1;\n      me[ny][nx]=m(c,t);\n    }\n    cout<<y+1<<' '<<x+1<<' ' <<c<<endl;\n  }\n  return 0;\n}\n\nchar Rot(char c){\n  if(c=='N') return 'E';\n  if(c=='E') return 'S';\n  if(c=='S') return 'W';\n  return 'N';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define f first\n#define s second\nusing namespace std;\n//        N E S W\nint X[4]={0,1,0,-1};\nint Y[4]={-1,0,1,0};\nint H,W,dis[100][100],si,sj,smuki;\nchar map[100][100];\nlong long L,memo[100][100][4];\n  \nint M(char c){\n  if(c=='N')return 0;\n  if(c=='E')return 1;\n  if(c=='S')return 2;\n  if(c=='W')return 3;\n}\n\nchar N(int a){\n  if(a==0)return 'N';\n  if(a==1)return 'E';\n  if(a==2)return 'S';\n  if(a==3)return 'W';\n}\nbool in(int y,int x){\n  if(y<0 || x<0 || y>=H || x>=W)return false;\n  return true;\n}\n\nint main()\n{\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0 &&W==0 &&L==0)break;\n    for(int i=0;i<100;i++){\n      for(int j=0;j<100;j++){\n\tdis[i][j]=0;\n\tfor(int k=0;k<4;k++)memo[i][j][k]=0;\n      }\n    }\n    queue<pair<int,pair<int,int> > > Q;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>map[i][j];\n\tif(map[i][j]!='.' && map[i][j]!='#'){\n\t  si=i;\n\t  sj=j;\n\t  smuki=M(map[i][j]);\n\t  map[i][j]='.';\n\t}\n      }\n    }\n    pair<int,pair<int,int> > u;\n    Q.push(make_pair(smuki,make_pair(si,sj)));\n    while(L>=0){\n      u=Q.front();\n      Q.pop();\n      //cout<<u.s.f<<\" \"<<u.s.s<<\" \"<<u.f<<endl;\n      for(int k=0;k<4;k++){\n        int mk=(u.f+k)%4;\n\tint a=u.s.f+Y[mk],b=u.s.s+X[mk];\n\tif(!in(a,b))continue;\n\tif(map[a][b]=='.'){\n\t  L--;\n\t  if(memo[a][b][mk]==0)memo[a][b][mk]=L;\n\t  else L=L%(memo[a][b][mk]-L);\n\t  Q.push(make_pair(mk,make_pair(a,b)));\n\t  break;\n\t}\n      }\n    }\n    cout<<u.s.f+1<<\" \"<<u.s.s+1<<\" \"<<N(u.f)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[100][100];\nint visited[100][100][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int &dir)\n{\n  //cout << src.F << \",\" << src.S << \" \" << dir;\n  while(true)\t\t\n    {      \n      src.S = src.S - dx[dir];\n      src.F = src.F - dy[dir];\n      if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t{\n\t  src.S = src.S + dx[dir];\n\t  src.F = src.F + dy[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else if(G[src.S][src.F] == '#')\n\t{\n\t  src.S = src.S + dx[dir];\n\t  src.F = src.F + dy[dir];\n\t  dir = (dir-1+4)%4;\n\t}\n      else \n\t{\n\t  src.S = src.S + dx[dir];\n\t  src.F = src.F + dy[dir];\n\t  break;\n\t}\n    }\n  //cout << \" -> \" << src.F << \",\" << src.S << \" \" << dir << endl;\n}\n \nint main()\n{\n  int H,W;\n  long long L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      long long phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {\n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      move(H,W,path[i+L].dir);\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct Vec2\n{\n    int x, y;\n};\n\nstruct RobotState\n{\n    Vec2 pos;\n    int dir; // 0, 1, 2, 3\n};\n\nVec2 dd [] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} };\n\nvoid DirectToEmptyCell(const vector<vector<char>> &maze, RobotState &robot)\n{\n    while (maze[robot.pos.y + dd[robot.dir].y][robot.pos.x + dd[robot.dir].x] == '#')\n    {\n        robot.dir = (robot.dir + 1) % 4;\n    }\n}\n\nvoid GoForward(RobotState &robot)\n{\n    auto d = dd[robot.dir];\n    robot.pos.x += d.x;\n    robot.pos.y += d.y;\n}\n\nint DirCharToInt(char c)\n{\n    switch (c)\n    {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        throw logic_error(\"unko\");\n    }\n}\n\nchar DirIntToChar(int dir)\n{\n    static const char m[] = { 'N', 'E', 'S', 'W' };\n    return m[dir];\n}\n\nint main()\n{\n    int H, W;\n    long long L;\n    while (cin >> H >> W >> L, H || W || L)\n    {\n        vector<vector<char>> maze(H + 2, vector<char>(W + 2, '#'));\n        long long visited[102][102][4];\n        for (size_t i = 0; i < 102; i++)\n            for (size_t j = 0; j < 102; j++)\n                for (size_t k = 0; k < 4; k++)\n                {\n                    visited[i][j][k] = -1;\n                }\n        RobotState robot;\n        // input maze\n        for (int i = 1; i < H + 1; ++i) \n        {\n            for (int j = 1; j < W + 1; ++j)\n            {\n                char c;\n                cin >> c;\n                if (c == '.' || c == '#')\n                {\n                    maze[i][j] = c;\n                }\n                else\n                {\n                    maze[i][j] = '.';\n                    robot.pos.x = j;\n                    robot.pos.y = i;\n                    robot.dir = DirCharToInt(c);\n                }\n            }\n        }\n        // do this\n        for (long long i = 0; i < L; ++i)\n        {\n            // detect loop\n            auto& n = visited[robot.pos.y][robot.pos.x][robot.dir];\n            if (n != -1)\n            {\n                i = L - (L - i) % (i - n);\n                if (i == L)\n                {\n                    break;\n                }\n            }\n            else\n            {\n                n = i;\n            }\n            \n            DirectToEmptyCell(maze, robot);\n            GoForward(robot);\n        }\n        cout << robot.pos.y << ' ' << robot.pos.x << ' ' << DirIntToChar(robot.dir) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nstruct Dog{\n\tint h, w;\n\tint dir;\n};\n\nDog dog, tmp;\n\nint h, w;\nlong long l;\nint dh[4] = {-1,0,1,0};\nint dw[4] = {0,1,0,-1};\nchar d[4] = {'N','E','S','W'};\nint brd[100][100];\n\nint main(){\n\twhile(true){\n\t\tcin >> h >> w >> l;\n\t\tif(h == 0 && w == 0 && l == 0) break;\n\t\trep(i,h){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\trep(j,w){\n\t\t\t\tif(str[j] == '#') brd[i][j] = 1;\n\t\t\t\telse brd[i][j] = 0;\n\t\t\t\tif(str[j] == 'N'){dog.h = i; dog.w = j; dog.dir = 0;}\n\t\t\t\tif(str[j] == 'E'){dog.h = i; dog.w = j; dog.dir = 1;}\n\t\t\t\tif(str[j] == 'W'){dog.h = i; dog.w = j; dog.dir = 3;}\n\t\t\t\tif(str[j] == 'S'){dog.h = i; dog.w = j; dog.dir = 2;}\n\t\t\t}\n\t\t}\n\t\tbool end = false;\n\t\tfor(int i = 1; i <= 100000; i++){\n\t\t\twhile(true){\n\t\t\t\tint hh = dog.h+dh[dog.dir], ww = dog.w+dw[dog.dir];\n\t\t\t\tif(0>hh||hh>=h||0>ww||ww>=w||brd[hh][ww] == 1){\n\t\t\t\t\tdog.dir = (dog.dir+1)%4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdog.h = hh;\n\t\t\t\tdog.w = ww;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(l == i){\n\t\t\t\tend = true;\n\t\t\t\tcout << dog.h+1 << \" \" << dog.w+1 << \" \" << d[dog.dir] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(end) continue;\n\t\ttmp.h = dog.h; tmp.w = dog.w; tmp.dir = dog.dir;\n\t\tl -= 100000;\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\tcnt++;\n\t\t\twhile(true){\n\t\t\t\tint hh = dog.h+dh[dog.dir], ww = dog.w+dw[dog.dir];\n\t\t\t\tif(0>hh||hh>=h||0>ww||ww>=w||brd[hh][ww] == 1){\n\t\t\t\t\tdog.dir = (dog.dir+1)%4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdog.h = hh;\n\t\t\t\tdog.w = ww;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dog.h==tmp.h&&dog.w==tmp.w&&dog.dir==tmp.dir) break;\n\t\t}\n\t\tl %= cnt;\n\t\tfor(int i = 1;;i++){\n\t\t\twhile(true){\n\t\t\t\tint hh = dog.h+dh[dog.dir], ww = dog.w+dw[dog.dir];\n\t\t\t\tif(0>hh||hh>=h||0>ww||ww>=w||brd[hh][ww] == 1){\n\t\t\t\t\tdog.dir = (dog.dir+1)%4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdog.h = hh;\n\t\t\t\tdog.w = ww;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(l == i){\n\t\t\t\tcout << dog.h+1 << \" \" << dog.w+1 << \" \" << d[dog.dir] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define int long long\nusing namespace std;\n\nint h, w, l;\nconst int INF = 1e18 + 1;\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nstring s = \"NESW\";\n\nbool contain(int y, int x){\n\treturn (0 <= y && y < h && 0 <= x && x < w);\n}\n\nstruct State{\n\tint y, x, dr;\n};\n\nsigned main(){\n\twhile(1){\n\t\tcin >> h >> w >> l;\n\t\tif(h + w + l == 0) break;\n\t\tint sy, sx;\n\t\tchar c[110][110], cc;\n\t\trep(i, 0, h){\n\t\t\trep(j, 0, w){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j] != '.' && c[i][j] != '#'){\n\t\t\t\t\tsy = i; sx = j; cc = c[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dir = s.find(cc);\n\t\t/*State next[110][110][4];\n\t\trep(i, 0, h){\n\t\t\trep(j, 0, w){\n\t\t\t\trep(k, 0, 4){\n\t\t\t\t\tint ny = i + dy[k];\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tif(!co\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tint d[110][110][4];\n\t\trep(i, 0, h) rep(j, 0, w) rep(k, 0, 4) d[i][j][k] = INF;\n\t\td[sy][sx][dir] = 0;\n\t\tint y = sy, x = sx;\n\t\tint roop = -1;\n\t\tint roop_st = -1;\n\t\tint cnt = 0;\n\t\twhile(1){\n\t\t\tint ny, nx, ndir;\n\t\t\trep(i, 0, 4){\n\t\t\t\tny = y + dy[(dir + i) % 4];\n\t\t\t\tnx = x + dx[(dir + i) % 4];\n\t\t\t\tndir = (dir + i) % 4;\n\t\t\t\tif(!contain(ny, nx) || c[ny][nx] == '#') continue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(d[ny][nx][ndir] != INF){\n\t\t\t\troop_st = d[ny][nx][ndir];\n\t\t\t\troop = d[y][x][dir] + 1 - d[ny][nx][ndir]; break;\n\t\t\t}\n\t\t\t//cout << ny << \" \" << nx << \" \" << s[ndir] << \" \" << endl;\n\t\t\td[ny][nx][ndir] = d[y][x][dir] + 1;\n\t\t\tcnt = d[ny][nx][ndir];\n\t\t\ty = ny; x = nx; dir = ndir;\n\t\t}\n\t\tif(cnt < l){\n\t\t\tl = roop_st + (l - roop_st) % roop;\n\t\t}\n\t\trep(i, 0, h) rep(j, 0, w) rep(k, 0, 4) if(d[i][j][k] == l){\n\t\t\tcout << i + 1 << \" \" << j + 1 << \" \" << s[k] << endl; j = w; i = h; break;\n\t\t}\n\t\t//cout << \"======\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nvoid output(int i,int j,int d)\n{\n\tcout<<i+1<<' '<<j+1<<' '<<\"NESW\"[d]<<endl;\n}\n\nint main()\n{\n\tint h,w; long long l;\n\tfor(;cin>>h>>w>>l,h|w|l;){\n\t\tvector<string> grid(h);\n\t\tfor(int i=0;i<h;i++) cin>>grid[i];\n\t\t\n\t\tvector<vector<vector<int>>> vis(h,vector<vector<int>>(w,vector<int>(4,-1)));\n\t\t\n\t\tqueue<tuple<int,int,int,int>> q; // (i,j,dir,time)\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint d=string(\"NESW\").find(grid[i][j]);\n\t\t\t\tif(d!=-1){\n\t\t\t\t\tq.emplace(i,j,d,0);\n\t\t\t\t\tgrid[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\twhile(q.size()){\n\t\t\tauto c=q.front(); q.pop();\n\t\t\tint ci=get<0>(c),cj=get<1>(c),cd=get<2>(c),ct=get<3>(c);\n\t\t\tif(ct==l){\n\t\t\t\toutput(ci,cj,cd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vis[ci][cj][cd]!=-1){\n\t\t\t\tint len=ct-vis[ci][cj][cd];\n\t\t\t\tfor(int i=0;i<h;i++)\n\t\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\t\t\tif(vis[i][j][k]==(l-vis[ci][cj][cd])%len+vis[ci][cj][cd])\n\t\t\t\t\t\t\t\toutput(i,j,k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[ci][cj][cd]=ct;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nd=(cd+i)%4,ni=ci+\"\\xff\\0\\x1\\0\"[nd],nj=cj+\"\\0\\x1\\0\\xff\"[nd];\n\t\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w && grid[ni][nj]!='#'){\n\t\t\t\t\tq.emplace(ni,nj,nd,ct+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\n\nchar dc[]={'N','E','S','W'};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint change(char ch){\n  for(int i=0;i<4;i++)if(dc[i]==ch)return i;\n}\n\nint H,W,sx,sy,sdir;\nll L;\nchar t[100][100];\nstring str;\n\nvoid input();\nvoid solve();\nvoid dfs(int,int,int,ll);\n\nint main(){\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0&&W==0&&L==0)break;\n    input();\n    solve();\n  }\n  return 0;\n}\n\nvoid input(){\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      if(str[j]!='#'&&str[j]!='.'){\n\tt[i][j]='.';\n\tsy=i;\n\tsx=j;\n\tsdir=change(str[j]);\n      }else t[i][j]=str[j];\n    }\n  }  \n}\n\nll vd[100][100][4];\n\nvoid solve(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n\tvd[i][j][k]=-1;\n      }\n    }\n  }\n\n  dfs(sy,sx,sdir,0);\n}\n\n\nvoid dfs(int y,int x,int dir,ll cnt){\n  dir%=4;\n\n  if(cnt>=L){\n    cout<<y+1<<' '<<x+1<<' '<<dc[dir]<<endl;\n    return;\n  }\n  \n  if( L-cnt>=500LL && vd[y][x][dir]!=-1 ){\n    ll ncnt;\n    ncnt=(L-cnt)%(cnt-vd[y][x][dir]);\n    dfs(y,x,dir,L-ncnt-(cnt-vd[y][x][dir]));\n    return;\n  }\n\n  vd[y][x][dir]=cnt;\n  \n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0)dfs(y,x,dir+1,cnt);\n  else if(ny>=H||nx>=W)dfs(y,x,dir+1,cnt);\n  else if(t[ny][nx]=='#')dfs(y,x,dir+1,cnt);\n  else dfs(ny,nx,dir,cnt+1);\n\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 拓真 on 2018/06/30.\n//\n\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,b) FOR(i,0,b)\n#define INF mugen\n#define dump(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(a) (a).begin(),(a).end()\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntemplate <class T> void chmin(T & a, T const & b) { if (b < a) a = b; }\n\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nstruct robot{\n    robot(){};\n    int x,y;\n    int dir;\n    robot(int x,int y,int dir){\n        this->x=x;\n        this->y=y;\n        this->dir=dir;\n    }\n};\n\nchar toc(int x){\n    if(x==0)return 'N';\n    else if(x==1)return 'E';\n    else if(x==2)return 'S';\n    else return 'W';\n}\nint dp[110][110][5];\nvector<string> maze;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint main(){\n    int h,w;\n    ll L;\n    while(cin>>h>>w>>L,h){\n\n\n        rep(i,110)rep(j,110)rep(k,5)dp[i][j][k]=0;\n        maze.clear();\n        rep(i,h){\n            string s;\n            cin>>s;\n            maze.push_back(s);\n        }\n\n        robot pre;\n        rep(i,h)rep(j,w){\n            if(maze[i][j]=='N'){\n                pre=robot(j,i,0);\n            }\n            if(maze[i][j]=='E'){\n                pre=robot(j,i,1);\n            }\n            if(maze[i][j]=='S'){\n                pre=robot(j,i,2);\n            }\n            if(maze[i][j]=='W'){\n                pre=robot(j,i,3);\n            }\n        }\n\n        bool flag=false;\n\n        dp[pre.y][pre.x][pre.dir]=1;\n        for(int i=0;i<L;i++){\n\n            int nexty=pre.y+dy[pre.dir];\n            int nextx=pre.x+dx[pre.dir];\n            if(nexty>=0 && nexty<h&&nextx>=0&&nextx<w&&maze[nexty][nextx]!='#'){\n                pre=robot(nextx,nexty,pre.dir);\n\n            }else{\n                int id=1;\n                while(1){\n                    int nx=pre.x+dx[(pre.dir+id)%4];\n                    int ny=pre.y+dy[(pre.dir+id)%4];\n                    if(nx>=0&&nx<w&&ny>=0&&ny<h&&maze[ny][nx]=='.'){\n                        pre=robot(pre.x+dx[(pre.dir+id)%4],pre.y+dy[(pre.dir+id)%4],(pre.dir+id)%4);\n                        break;\n                    }\n                    id++;\n                }\n            }\n\n\n\n           //cout<<pre.y+1<<' '<<pre.x+1<<' '<<toc(pre.dir)<<endl;\n\n\n\n\n            if(!flag&&dp[pre.y][pre.x][pre.dir]){\n                int x=i+1-dp[pre.y][pre.x][pre.dir];\n                //cerr<<\"cut\";\n                i+=((L-i)/x)*x;\n               // cerr<<(L/x)*x;\n                flag=true;\n            }\n            dp[pre.y][pre.x][pre.dir]=i+1;\n\n        }\n\n\n        cout<<pre.y+1<<' '<<pre.x+1<<' '<<toc(pre.dir)<<endl;\n\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nint m[110][110];\nlong long ha[50000];\nstruct\n{\n    int x,y,face;\n}ss[10010];\nint main()\n{\n    int h,w,j,i,sx,sy,start,x,y,face,tt,hash;\n    long long l,ll,ans;\n    char c[1000];\n    while (scanf(\"%d%d%lld\",&h,&w,&l)&&h&&w&&l)\n    {\n        memset(ha,-1,sizeof ha);\n        memset(ss,0,sizeof ss);\n        for (i=1;i<=h;i++)\n        {\n            scanf(\"%s\",c);\n            for (j=1;j<=w;j++)\n            {\n                if (c[j-1]=='#')\n                m[i][j]=0;\n                else if (c[j-1]=='.')\n                m[i][j]=1;\n                else\n                {\n                    m[i][j]=1;\n                    sx=i,sy=j;\n                    if (c[j-1]=='W')\n                        start=1;\n                    if (c[j-1]=='N')\n                        start=2;\n                    if (c[j-1]=='E')\n                        start=3;\n                    if (c[j-1]=='S')\n                        start=4;\n                }\n            }\n        }\n        ll=l;\n       // printf(\"ll = %lld\\n\",ll);\n        x=sx;y=sy;\n        face=start;\n        tt=0;\n        while (ll)\n        {   hash=(face-1)*10000+(x-1)*100+y-1;\n         //   printf(\"%d %d %d %d   %lld\\n\",x,y,face,hash,ha[hash]);\n            if (ha[hash]==-1)\n            {\n                ha[hash]=l-ll;\n                if(ss[l-ll].face == 0){ss[l-ll].x=x,ss[l-ll].y=y,ss[l-ll].face=face;\n             //   printf(\"%d : %d %d %d\\n\",l-ll,ss[l-ll].x,ss[l-ll].y,ss[l-ll].face);\n                }\n            }\n            else\n            {\n                tt=1;\n                ss[ha[hash]].face = face;\n              //  printf(\"l = %lld\\n,l - ll = %lld\\n ll = %lld\\n\",l,l-ll,ll);\n               // printf(\"ha[hash] = %d, hash = %d, l-ll = %lld\\n\",ha[hash],hash,l-ll-ha[hash]);\n\n           //     printf(\"l-ll = %lld %lld  ~%lld\\n\",l,ll,l-ll);\n                ans=ha[hash]+(l-ha[hash])%(l-ll-ha[hash]);\n            //    while (ss[ans].x==ss[ans-1].x&&ss[ans].y==ss[ans-1].y)\n           //         ans--;\n          // printf(\"%d\\n\",ans);\n                printf(\"%d %d \",ss[ans].x,ss[ans].y);\n                if (ss[ans].face==1)\n                printf(\"W\\n\");\n                if (ss[ans].face==2)\n                printf(\"N\\n\");\n                if (ss[ans].face==3)\n                printf(\"E\\n\");\n                if (ss[ans].face==4)\n                printf(\"S\\n\");\n               // printf(\"%d %d %d\",ss[ans-1].x,ss[ans-1].y,ss[ans-1],face);\n                break;\n            }\n            if (face==1)\n            {\n                if (y-1>=1&&m[x][y-1])\n                {\n                    y--;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==2)\n            {\n                if (x-1>=1&&m[x-1][y])\n                {\n                    x--;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==3)\n            {\n                if (y+1<=w&&m[x][y+1])\n                {\n                    y++;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face++;\n                    continue;\n                }\n            }\n            else if (face==4)\n            {\n                if (x+1<=h&&m[x+1][y])\n                {\n                    x++;\n                    ll--;\n                    continue;\n                }\n                else\n                {\n                    face=1;\n                    continue;\n                }\n            }\n        }\n        if (tt==0)\n        {\n            printf(\"%d %d \",x,y);\n            if (face==1)\n                printf(\"W\\n\");\n            if (face==2)\n                printf(\"N\\n\");\n            if (face==3)\n                printf(\"E\\n\");\n            if (face==4)\n                printf(\"S\\n\");\n        }\n    }\n    return 0;\n}\n\n/*\n2 2 8\nW.\n..\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nint h,w;\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring mp[101],str=\"NESW\";;\nll n;\n\nvoid solve(int x,int y,int dir){\n  ll dis[4][101][101]={},cost=0;\n  memset(dis,-1,sizeof(dis));\n  while(n!=0){\n    if(dis[dir][y][x]!=-1&&n%(cost-dis[dir][y][x])!=0){\n      n%=(cost-dis[dir][y][x]);\n      memset(dis,-1,sizeof(dis));\n    }\n\n    dis[dir][y][x]=cost;\n    \n    x+=dx[dir];\n    y+=dy[dir];\n    if(x<0||y<0||x>=w||y>=h||mp[y][x]=='#'){\n      x-=dx[dir];\n      y-=dy[dir];\n      dir=(dir+1)%4;\n    }\n    else n--,cost++;\n  }\n  cout << y+1 <<\" \"<<x+1<<\" \"<<str[dir]<<endl;\n}\n\n\nint main(){\n  while(1){\n    cin >>h>>w>>n;\n    if(!h&&!w&&!n)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n    \n    int dir;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<mp[i].size();j++)\n\tif(mp[i][j]!='.'&&mp[i][j]!='#'){\n\t  if(mp[i][j]=='N')dir=0;\n\t  if(mp[i][j]=='E')dir=1;\n\t  if(mp[i][j]=='S')dir=2;\n\t  if(mp[i][j]=='W')dir=3;\n\t  solve(j,i,dir);\n\t}\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\ntypedef long long ll;\n\nint main(void) {\n  ll i, j, k, h, w, l;\n  int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n  char dir[6] = \"NESW\";\n  while( 1 ) {\n  ll x, y, d, cycle;\n  scanf(\"%lld%lld%lld\", &h, &w, &l);\n  if(!h && !w && !l) break;\n  ll a[h][w][4];\n  char c[h][w + 10];\n  for(i = 0; i < h; ++i) {\n    scanf(\"%s\", c[i]);\n    for(j = 0; j < w; ++j) {\n      if(c[i][j] == 'N') x = j, y = i, d = 0;\n      else if(c[i][j] == 'E') x = j, y = i, d = 1;\n      else if(c[i][j] == 'S') x = j, y = i, d = 2;\n      else if(c[i][j] == 'W') x = j, y = i, d = 3;\n    }\n  }\n  for(i = 0; i < h; ++i) for(j = 0; j < w; ++j) for(k = 0; k < 4; ++k) a[i][j][k] = -1;\n  a[y][x][d] = 0;\n  for(i = 0; i < l; ) {\n    if(x + dx[d] >= w || y + dy[d] >= h || x + dx[d] < 0 || y + dy[d] < 0 || c[y + dy[d]][x + dx[d]] == '#') {\n      d = (d + 1) % 4;\n      if(a[y][x][d] == -1) a[y][x][d] = i;\n      else {\n        cycle = i - a[y][x][d];\n        break;\n      }\n    } else {\n      y += dy[d], x += dx[d], ++i;\n      if(a[y][x][d] == -1) a[y][x][d] = i;\n      else {\n        cycle = i - a[y][x][d];\n        break;\n      }\n    }\n  }\n  if(i == l) {\n    printf(\"%lld %lld %c\\n\", y + 1, x + 1, dir[d]);\n    continue;\n  }\n  l -= i;\n  l %= cycle;\n  for(i = 0; i < l; ) {\n    if(x + dx[d] >= w || y + dy[d] >= h || x + dx[d] < 0 || y + dy[d] < 0 || c[y + dy[d]][x + dx[d]] == '#') {\n      d = (d + 1) % 4;\n    } else {\n      y += dy[d], x += dx[d], ++i;\n    }\n  }\n  /*for(i = 0; i < h; ++i) {\n    for(j = 0; j < w; ++j) printf(\"%lld/%lld/%lld/%lld \", a[i][j][0], a[i][j][1], a[i][j][2], a[i][j][3]);\n    printf(\"\\n\");\n  }*/\n  printf(\"%lld %lld %c\\n\", y + 1, x + 1, dir[d]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define MP(x,y) make_pair(x,y)\n#define FI first\n#define SE second\n\nconst int MAXN = 110;\nconst char cdir[10]=\"SENW\";\nchar ma[MAXN][MAXN];\nconst int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint to[128];\nint step[MAXN][MAXN][4];\nstruct _node\n{\n\tbool ty;\n\tint ex,ey,di,cycle;\n};\n_node bfs(int x,int y,int di,long long len)\n{\n\tmemset(step,-1,sizeof(step));\n\tint cnt = 0;\n\twhile(step[x][y][di]==-1&&len>cnt)\n\t{\n\t\tstep[x][y][di]=cnt;\n\t\tint dx=x+dir[di][0],dy=y+dir[di][1];\n\t\tif(ma[dx][dy]!='.')\n\t\t{\n\t\t\tdi=(di+3)%4;\n\t\t\tcontinue;\n\t\t}\n\t\tx=dx,y=dy;\n\t\t++cnt;\n\t}\n\t_node no;\n\tno.di=di;\n\tno.ex=x;\n\tno.ey=y;\n\tno.ty=len>cnt;\n\tno.cycle=cnt-step[x][y][di];\n\treturn no;\n}\nint main()\n{\n\t//freopen(\"/home/caesar11/0425/a.in\",\"r\",stdin);\n\tint w,h;\n\tlong long len;\n\tto['S']=0;\n\tto['E']=1;\n\tto['N']=2;\n\tto['W']=3;\n\twhile(scanf(\"%d%d%lld\",&h,&w,&len)==3&&h)\n\t{\n\t\tmemset(ma,'#',sizeof(ma));\n\t\tfor(int i=1;i<=h;++i)\n\t\t\tscanf(\"%s\",&ma[i][1]);\n\t\tint sx,sy,di;\n\t\tfor(int i=1;i<=h;++i)\n\t\t\tfor(int j=1;j<=w;++j)\n\t\t\t\tif(ma[i][j] != '#' && ma[i][j] != '.')\n\t\t\t\t{\n\t\t\t\t\tsx=i,sy=j;\n\t\t\t\t\tdi=to[(int)ma[i][j]];\n\t\t\t\t\tma[i][j]='.';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t_node re = bfs(sx,sy,di,len);\n\t\tif(!re.ty)\n\t\t\tprintf(\"%d %d %c\\n\",re.ex,re.ey,cdir[re.di]);\n\t\telse\n\t\t{\n\t\t\tlen-=step[re.ex][re.ey][re.di];\n\t\t\tlen%=re.cycle;\n\t\t\tre = bfs(re.ex,re.ey,re.di,len);\n\t\t\tprintf(\"%d %d %c\\n\",re.ex,re.ey,cdir[re.di]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint h, w, l, y, x, d, c;\nchar data[100][100];\nint vis[100][100][4];\nchar fd[100][100];\nstring dir = \"NESW\";\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return data[y][x] != '#';\n}\n\nvoid solve(){\n  int m, o;\n  bool f;\n  fill(vis[0][0], vis[100][0], -1);\n  fill(fd[0], fd[100], ' ');\n  for(;;){\n    if(vis[y][x][d] != -1){\n      if(vis[y][x][d]){\n        if(f){\n          o = vis[y][x][d] - 1;\n          m = c - vis[y][x][d];\n        }else{\n          o = vis[y][x][d] - 1;\n          m = c - vis[y][x][d] - 1;\n        }\n      }else{\n        if(f){\n          o = 0;\n          m = c;\n        }else{\n          o = 0;\n          m = c;\n        }\n      }\n      break;\n    }\n    //cout << y+1 << ' ' << x+1 << ' ' << dir[d] << ' ' << c << endl;\n    vis[y][x][d] = c;\n    if(fd[y][x] == ' ') fd[y][x] = dir[d];\n    int ny = y + dy[d];\n    int nx = x + dx[d];\n    if(!check(ny, nx)){\n      d = (d+1) % 4;\n      f = false;\n    }\n    else{\n      y = ny;\n      x = nx;\n      c++;\n      if(l == c){\n        cout << y+1 << ' ' << x+1 << ' ' << dir[d] << endl;\n        return;\n      }\n      f = true;\n    }\n  }\n  int t = l % m + o;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<4;k++){\n        if(vis[i][j][k] == t){\n          cout << i+1 << ' ' << j+1 << ' ' << fd[i][j] << endl;\n          return;\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> h >> w >> l && (h|w|l)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        for(int k=0;k<4;k++){\n          if(data[i][j] == dir[k]){\n            data[i][j] = '.';\n            y = i;\n            x = j;\n            d = k;\n            c = 0;\n          }\n        }\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\n\nchar dc[]={'N','E','S','W'};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint change(char ch){\n  for(int i=0;i<4;i++)if(dc[i]==ch)return i;\n}\n\nint H,W,sx,sy,sdir;\nll L;\nchar t[100][100];\nstring str;\n\nvoid input();\nvoid solve();\nvoid dfs(int,int,int,ll);\n\nint main(){\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0&&W==0&&L==0)break;\n    input();\n    solve();\n  }\n  return 0;\n}\n\nvoid input(){\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      if(str[j]!='#'&&str[j]!='.'){\n\tt[i][j]='.';\n\tsy=i;\n\tsx=j;\n\tsdir=change(str[j]);\n      }else t[i][j]=str[j];\n    }\n  }  \n}\n\nll vd[100][100][4];\n\nvoid solve(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n\tvd[i][j][k]=-1;\n      }\n    }\n  }\n\n  dfs(sy,sx,sdir,0);\n}\n\n\nvoid dfs(int y,int x,int dir,ll cnt){\n  dir%=4;\n\n  if(cnt>=L){\n    cout<<y+1<<' '<<x+1<<' '<<dc[dir]<<endl;\n    return;\n  }\n  \n  if( L-cnt>=50000LL && vd[y][x][dir]!=-1 ){\n    ll ncnt;\n    ncnt=(L-cnt)%(cnt-vd[y][x][dir]);\n    dfs(y,x,dir,L-ncnt-(cnt-vd[y][x][dir]));\n    return;\n  }\n\n  vd[y][x][dir]=cnt;\n  \n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0)dfs(y,x,dir+1,cnt);\n  else if(ny>=H||nx>=W)dfs(y,x,dir+1,cnt);\n  else if(t[ny][nx]=='#')dfs(y,x,dir+1,cnt);\n  else dfs(ny,nx,dir,cnt+1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconstexpr int dy[] = { -1, 0, 1, 0 };\nconstexpr int dx[] = { 0, 1, 0, -1 };\nconst string dirs( \"NESW\" );\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( LL H, W, L; cin >> H >> W >> L && ( H | W | L ); )\n\t{\n\t\tVS board( H );\n\t\tcin >> board;\n\n\t\tint y = 0, x = 0, d = 0;\n\t\tREP( i, H )\n\t\t{\n\t\t\tREP( j, W )\n\t\t\t{\n\t\t\t\tif ( isupper( board[i][j] ) )\n\t\t\t\t{\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t\td = dirs.find( board[i][j] );\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVT( VVI ) visited( H, VVI( W, VI( 4, -1 ) ) );\n\n\t\tfor ( int i = 0; i < L; ++i )\n\t\t{\n\t\t\tif ( visited[y][x][d] != -1 && ( L - i ) % ( i - visited[y][x][d] ) == 0 )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvisited[y][x][d] = i;\n\n\t\t\twhile ( true )\n\t\t\t{\n\t\t\t\tconst int ny = y + dy[d];\n\t\t\t\tconst int nx = x + dx[d];\n\n\t\t\t\tif ( 0 <= ny && ny < H && 0 <= nx && nx < W && board[ ny ][ nx ] == '.' )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++d %= 4;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ty += dy[d];\n\t\t\tx += dx[d];\n\t\t}\n\n\t\tcout << y + 1 << ' ' << x + 1 << ' ' << dirs[d] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\n//int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2320 : Infinity Maze **/\ntypedef long long int ll;\nll dd[100][100][4];\nchar board[100][100];\nint H, W;\nll L;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\n\nint main()\n{\n\tstring label = \"NESW\";\n\t\n\twhile (cin>>H>>W>>L, H||W||L) {\n\t\tint d, sx, sy;\n\t\tmemset(dd, -1, sizeof(dd));\n\t\t\n\t\trep(y, H) {\n\t\t\trep(x, W) {\n\t\t\t\tchar c; cin>>c;\n\t\t\t\tboard[x][y] = c;\n\n\t\t\t\tif (c!='.' && c!= '#') {\n\t\t\t\t\tif (c=='N') {\n\t\t\t\t\t\td = 0;\n\t\t\t\t\t} else if (c=='E') {\n\t\t\t\t\t\td = 1;\n\t\t\t\t\t} else if (c=='S') {\n\t\t\t\t\t\td = 2;\n\t\t\t\t\t} else if (c=='W') {\n\t\t\t\t\t\td = 3;\n\t\t\t\t\t}\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tdd[sx][sy][d] = 0;\n\t\t\n\t\tll t=0; bool find=false; int ansd;\n\t\twhile (L>0) {\n\t\t\tint nx = sx+dx[d], ny = sy+dy[d];\n\t\t\t\n\t\t\tif (0<=nx && nx<W && 0<=ny && ny<H && board[nx][ny]!='#') {\n\t\t\t\tif (!find && dd[nx][ny][d]>=0) {\n\t\t\t\t\tL %= (t+1 - dd[nx][ny][d]);\n\t\t\t\t\tfind = true;\n\t\t\t\t} else {\n\t\t\t\t\tsx = nx; sy = ny;\n\t\t\t\t\tL--; t++;\n\t\t\t\t\tdd[sx][sy][d] = t;\n\t\t\t\t\tansd = d;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\td++; d%=4;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << sy+1 << \" \" << sx+1 << \" \" << label[ansd] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nconst int MAX=INT_MAX/10;\nstruct node{\n\tpii p;\n\tint dir;\n\tnode(pii p,int dir):p(p),dir(dir){}\n\tbool operator==(const node& other)const{\n\t\treturn other.p==p&&other.dir==dir;\n\t}\n};\nchar dirs[]={'N','E','S','W'};\nint main(){\n\tint h,w;\n\tll s;\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\tvs f(h);\n\t\tpii start;\n\t\tint initial_dir;\n\t\tREP(i,h){\n\t\t\tcin>>f[i];\n\t\t\tREP(j,w){\n\t\t\t\tswitch(f[i][j]){\n\t\t\t\tcase 'N':\n\t\t\t\t\tinitial_dir=0;\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tinitial_dir=2;\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tinitial_dir=1;\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tinitial_dir=3;\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<node> nodes;\n\t\tset<node> visited;\n\t\tpii cur=start;\n\t\tint dir=initial_dir;\n\t\tint begin=0;\n\t\twhile((nodes.size()==0||cur.first!=start.first||cur.second!=start.second||dir!=initial_dir)&&nodes.size()<s){\n\t\t\tint y;\n\t\t\tint x;\n\t\t\twhile(y=cur.first+dy[dir],x=cur.second+dx[dir],y<0||x<0||y>=h||x>=w||f[y][x]=='#'){\n\t\t\t\tdir=(dir+1)%4;\n\t\t\t}\n\t\t\tcur.first=y;\n\t\t\tcur.second=x;\n\t\t\tnode n(cur,dir);\n\t\t\tvector<node>:: iterator it=find(ALL(nodes),n);\n\t\t\tif(it!=nodes.end()){\n\t\t\t\tbegin=it-nodes.begin();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnodes.push_back(n);\n\t\t}\n\t\tint index=begin+(s-begin-1)%(nodes.size()-begin);\n\t\tnode &n=nodes[index];\n\t\tcout<<n.p.first+1<<\" \"<<n.p.second+1<<\" \"<<dirs[n.dir]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\n\nchar dc[]={'N','E','S','W'};\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nint change(char ch){\n  for(int i=0;i<4;i++)if(dc[i]==ch)return i;\n}\n\nint H,W,sx,sy,sdir;\nll L;\nchar t[100][100];\nstring str;\n\nvoid input();\nvoid solve();\nvoid dfs(int,int,int,ll);\n\nint main(){\n  while(1){\n    cin>>H>>W>>L;\n    if(H==0&&W==0&&L==0)break;\n    input();\n    solve();\n  }\n  return 0;\n}\n\nvoid input(){\n  for(int i=0;i<H;i++){\n    cin>>str;\n    for(int j=0;j<W;j++){\n      if(str[j]!='#'&&str[j]!='.'){\n\tt[i][j]='.';\n\tsy=i;\n\tsx=j;\n\tsdir=change(str[j]);\n      }else t[i][j]=str[j];\n    }\n  }  \n}\n\nll vd[100][100][4];\n\nvoid solve(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      for(int k=0;k<4;k++){\n\tvd[i][j][k]=-1;\n      }\n    }\n  }\n\n  dfs(sy,sx,sdir,0);\n}\n\n\nvoid dfs(int y,int x,int dir,ll cnt){\n  dir%=4;\n\n  if(cnt>=L){\n    cout<<y+1<<' '<<x+1<<' '<<dc[dir]<<endl;\n    return;\n  }\n  \n  if( L-cnt>=500LL && vd[y][x][dir]!=-1 ){\n    ll ncnt;\n    ncnt=(L-cnt)%(cnt-vd[y][x][dir]);\n    dfs(y,x,dir,L-ncnt);\n    return;\n  }\n\n  vd[y][x][dir]=cnt;\n  \n  int ny=y+dy[dir];\n  int nx=x+dx[dir];\n  if(ny<0||nx<0)dfs(y,x,dir+1,cnt);\n  else if(ny>=H||nx>=W)dfs(y,x,dir+1,cnt);\n  else if(t[ny][nx]=='#')dfs(y,x,dir+1,cnt);\n  else dfs(ny,nx,dir,cnt+1);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1LL << 60;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\nconst string NESW = \"NESW\";\n\nbool solve() {\n    int H, W;\n    lint L;\n    cin >> H >> W >> L;\n    if (H == 0) return false;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<vector<lint>>> dist(H, vector<vector<lint>>(W, vector<lint>(4, INF)));\n    int sx, sy, sd;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            for (int d = 0; d < 4; ++d) {\n                if (S[x][y] == \"NESW\"[d]) {\n                    sx = x;\n                    sy = y;\n                    sd = d;\n                }\n            }\n        }\n    }\n\n    dist[sx][sy][sd] = 0;\n    lint step = 0;\n    while (step < L) {\n        int nx = sx + dx[sd], ny = sy + dy[sd];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny ||\n            S[nx][ny] == '#') {\n            sd = (sd + 1) % 4;\n        } else {\n            sx = nx, sy = ny;\n            ++step;\n        }\n\n        if (dist[sx][sy][sd] < INF) {\n            lint diff = step - dist[sx][sy][sd];\n            L -= (L - step) / diff * diff;\n        } else {\n            dist[sx][sy][sd] = step;\n        }\n    }\n\n    cout << sx + 1 << \" \" << sy + 1 << \" \"\n         << \"NESW\"[sd] << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tint h,w;\n\tll l;\n\tchar maze[102][102];\n\tmemset(maze,'#',sizeof maze);\n\twhile(cin >> h >> w >> l,h){\n\t\tint r[2];\n\t\tint v[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\t\tint d = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcin >> maze[i+1][j+1];\n\t\t\t\tswitch(maze[i+1][j+1]){\n\t\t\t\t\tcase 'W':++d;\n\t\t\t\t\tcase 'S':++d;\n\t\t\t\t\tcase 'E':++d;\n\t\t\t\t\tcase 'N':\n\t\t\t\t\t\t r[0] = i+1;\n\t\t\t\t\t\t r[1] = j+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll step[4][102][102];\n\t\tmemset(step,-1,sizeof step);\n\t\tll s = 0;\n\t\twhile(s < l){\n\t\t\twhile(maze[r[0]+v[d][0]][r[1]+v[d][1]] == '#') d = (d+1)%4;\n\t\t\tif(step[d][r[0]+v[d][0]][r[1]+v[d][1]] < 0){\n\t\t\t\tstep[d][r[0]+v[d][0]][r[1]+v[d][1]] = ++s;\n\t\t\t}else{\n\t\t\t\tl -= step[d][r[0]+v[d][0]][r[1]+v[d][1]];\n\t\t\t\tl %= (s-step[d][r[0]+v[d][0]][r[1]+v[d][1]]+1);\n\t\t\t\tmemset(step,-1,sizeof step);\n\t\t\t\tstep[d][r[0]+v[d][0]][r[1]+v[d][1]] = s = 0;\n\t\t\t}\n\t\t\tr[0] += v[d][0];\n\t\t\tr[1] += v[d][1];\n\t\t}\n\t\tchar c[] = {'N','E','S','W'};\n\t\tcout << r[0] << \" \" << r[1] << \" \" << c[d] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long int lli;\n\nint xdir[4] = {0, 1, 0, -1};\nint ydir[4] = {-1, 0, 1, 0};\nchar a[101][101];\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint cnt[101][101][4];\n\nint main()\n{\n  int h, w, p, q, d, dx, dy;\n  lli l, dst;\n\n  while(cin>>h>>w>>l && h+w+l){\n    fill(&cnt[0][0][0], &cnt[101][0][0], -1);\n\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j){\n\tcin >> a[i][j];\n\tif(isalpha(a[i][j])){\n\t  p = i; q = j;\n\t  if(a[i][j] == 'E') d = 1;\n\t  if(a[i][j] == 'N') d = 0;\n\t  if(a[i][j] == 'W') d = 3;\n\t  if(a[i][j] == 'S') d = 2;\n\t  a[i][j] = '.';\n\t  cnt[i][j][d] = 0;\n\t}\n      }\n\n    bool f = false;\n    for(lli i = 1; i <= l; ++i){\n      dy = p+ydir[d]; dx = q+xdir[d];\n      if(0 <= dx && dx < w && 0 <= dy && dy < h && a[dy][dx] == '.'){\n\tp = dy; q = dx;\n\tif(!f){\n\t  if(cnt[p][q][d] == -1) cnt[p][q][d] = i;\n\t  else {\n\t    i = (l/(i-cnt[p][q][d]+1))*(i-cnt[p][q][d]+1);\n\t    f = true;\n\t  }\n\t}\n      } else {\n\t--i;\n\td = (d+1)%4;\n      }\n    }\n\n    cout << (p+1) << \" \" << (q+1) << \" \" << dir[d] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator >(const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, int cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nint dx[] = { -1, 0, 1, 0 }; int dy[] = { 0, 1, 0, -1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int dir, int h, int w) { return dir*h*w + w*x + y; }\n\n/*--------------------template--------------------*/\n\nvi rev(int p, int h, int w)\n{\n\t//(dir*h+x)*w+y\n\tint y = p%w;\n\tp = (p - y) / w;\n\tint x = p%h;\n\tint dir = (p - x) / h;\n\tvi v = { x,y,dir };\n\treturn v;\n}\n\nint main()\n{\n\tll h, w, l;\n\twhile (cin >> h >> w >> l, h)\n\t{\n\t\tGraph g(h*w * 4);\n\t\tvs fld(h);\n\t\tREP(i, h) cin >> fld[i];\n\t\tint st;\n\t\tREP(i, h)REP(j,w)\n\t\t{\n\t\t\tif (fld[i][j] == 'N') st = place(i, j, 0, h, w);\n\t\t\tif (fld[i][j] == 'E') st = place(i, j, 1, h, w);\n\t\t\tif (fld[i][j] == 'S') st = place(i, j, 2, h, w);\n\t\t\tif (fld[i][j] == 'W') st = place(i, j, 3, h, w);\n\t\t\tif (fld[i][j] != '.' && fld[i][j] != '#') fld[i][j] = '.';\n\t\t}\n\t\tREP(dir, 4)REP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld[i][j] == '#') continue;\n\t\t\tint k = 0, cnt = 0;\n\t\t\tint nx = i + dx[dir], ny = j + dy[dir];\n\t\t\tfor (; !valid(nx, ny, h, w) || fld[nx][ny] == '#';)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tif (cnt > 100) return 1;\n\t\t\t\tk++;\n\t\t\t\tk %= 4;\n\t\t\t\tnx = i + dx[(dir+k)%4]; ny = j + dy[(dir + k) % 4];\n\t\t\t}\n\t\t\tadd_edge(g, place(i, j, dir, h, w), place(nx, ny, (dir + k) % 4, h, w), 1);\n\t\t}\n\t\tset<int> memo; vi v; int loop;\n\t\tmemo.insert(st); v.push_back(st);\n\t\twhile (1)\n\t\t{\n\t\t\tint tmp = v.back();\n\t\t\tint next = g[tmp][0].to;\n\t\t\tif (memo.find(next) != memo.end())\n\t\t\t{\n\t\t\t\tloop = next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemo.insert(next);\n\t\t\tv.push_back(next);\n\t\t}\n\t\tint ans;\n\t\tif (v.size() > l) ans = v[l];\n\t\telse\n\t\t{\n\t\t\tint beg = find(ALL(v), loop) - v.begin();\n\t\t\tint len = v.size() - beg;\n\t\t\tl -= beg;\n\t\t\tans = v[beg + l%len];\n\t\t}\n\t\tvi ansv = rev(ans, h, w);\n\t\tint ax = ansv[0] + 1, ay = ansv[1] + 1;\n\t\tchar ad;\n\t\tswitch (ansv[2])\n\t\t{\n\t\tcase 0:\n\t\t\tad = 'N';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tad = 'E';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tad = 'S';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tad = 'W';\n\t\t\tbreak;\n\t\t}\n\t\tcout << ax << \" \" << ay << \" \" << ad << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define EXIST2(s,e) (find(ALL(s),(e))!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nconst int MAX=INT_MAX/10;\nstruct node{\n\tpii p;\n\tint dir;\n\tnode(pii p,int dir):p(p),dir(dir){}\n};\nchar dirs[]={'N','E','S','W'};\nint main(){\n\tint h,w;\n\tll s;\n\twhile(cin>>h>>w>>s,h||w||s){\n\t\tvs f(h);\n\t\tpii start;\n\t\tint initial_dir;\n\t\tREP(i,h){\n\t\t\tcin>>f[i];\n\t\t\tREP(j,w){\n\t\t\t\tswitch(f[i][j]){\n\t\t\t\tcase 'N':\n\t\t\t\t\tinitial_dir=0;\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tinitial_dir=2;\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tinitial_dir=1;\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tinitial_dir=3;\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<node> nodes;\n\t\tpii cur=start;\n\t\tint dir=initial_dir;\n\t\twhile((nodes.size()==0||cur.first!=start.first||cur.second!=start.second||dir!=initial_dir)&&nodes.size()<s){\n\t\t\tint y;\n\t\t\tint x;\n\t\t\twhile(y=cur.first+dy[dir],x=cur.second+dx[dir],y<0||x<0||y>=h||x>=w||f[y][x]=='#'){\n\t\t\t\tdir=(dir+1)%4;\n\t\t\t}\n\t\t\tcur.first=y;\n\t\t\tcur.second=x;\n\t\t\tnodes.push_back(node(cur,dir));\n\t\t}\n\t\tint remain=(s-1)%nodes.size();\n\t\tnode &n=nodes[remain];\n\t\tcout<<n.p.first+1<<\" \"<<n.p.second+1<<\" \"<<dirs[n.dir]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {1,0,-1,0};\nconst static int ty[] = {0,1,0,-1};\nconst static char dir_char[] = {'E','S','W','N'};\n \nenum dir {\n  EAST,\n  SOUTH,\n  WEST,\n  NORTH\n};\n\nstruct PosInfo{\n  int x;\n  int y;\n  int dir;\n  PosInfo(int _x,int _y,int _dir) : x(_x),y(_y),dir(_dir) {}\n};\n\nstatic const double EPS = 1e-8;\n\n\nvoid printStage(char stage[100][100],int H,int W,\n\t\tint current_x,int current_y,int current_dir){\n\n  char output[100][100];\n\n  //init\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      output[y][x] = '.';\n    }\n  }\n\n  //wall\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(stage[y][x] == '#'){\n\toutput[y][x] = '#';\n      }\n    }\n  }\n\n  //robot\n  output[current_y][current_x] = dir_char[current_dir];\n\n  //write\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      printf(\"%c\",output[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int H,W;\n  ll L;\n  while(~scanf(\"%d %d %ld\",&H,&W,&L)){\n    if(H == 0 && W == 0 && L == 0) break;\n\n    char stage[100][100];\n\n    int current_dir = NORTH;\n    int current_x = 0;\n    int current_y = 0;\n\n    for(int y=0;y<H;y++){\n      char line[120];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] == 'E'){\n\t  current_dir = EAST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'S'){\n\t  current_dir = SOUTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'W'){\n\t  current_dir = WEST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'N'){\n\t  current_dir = NORTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n      }\n    }\n\n    int dp[4][100][100];\n    for(int i=0;i<4;i++){\n      memset(dp[i],-1,sizeof(dp[i]));\n    }\n\n    ll round = 0;\n    for(;;){\n      if(dp[current_dir][current_x][current_y] >= 0) break;\n      \n      dp[current_dir][current_x][current_y]=round;\n      round++;\n      // printStage(stage,H,W,current_x,current_y,current_dir);\n      // cout << dx << \" \" << dy << \" \" << endl;\n\n      for(int i=0;i<4;i++){\n\t//i==0 : not rotating\n\tint next_dir = (current_dir + i) % 4;\n\tint dx = current_x + tx[next_dir];\n\tint dy = current_y + ty[next_dir];\n\n\tif(dy < 0 || dy >= H || dx < 0 || dx >= W){\n\t  continue;\n\t}\n\telse if(stage[dy][dx] == '#'){\n\t  continue;\n\t}\n\n\tcurrent_dir = next_dir;\n\tcurrent_x = dx;\n\tcurrent_y = dy;\n\tbreak;\n      }\n    }\n\n    int res_x = current_x;\n    int res_y = current_y;\n    int res_dir = current_dir;\n\n    //start:0 3 6 9 ... start:96\n    ll last_round = round;\n    ll cycle_begining_round = dp[current_dir][current_x][current_y];\n\n    if(last_round < L){\n      ll cycle_length = last_round - cycle_begining_round;\n      ll cycle_relative_pos = (L - cycle_begining_round) % cycle_length;\n      ll cycle_abs_pos = cycle_relative_pos + cycle_begining_round;\n\n      for(int i=0;i<4;i++){\n\tfor(int x=0;x<W;x++){\n\t  for(int y=0;y<H;y++){\n\t    if(dp[i][x][y] == cycle_abs_pos){\n\t      res_x = x;\n\t      res_y = y;\n\t      res_dir = i;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    printf(\"%d %d %c\\n\",res_y+1,res_x+1,dir_char[res_dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long H, W, L;\nchar x[102][102], T[5] = \"NESW\"; int dp[102][102][4];\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 102; i++) {\n\t\t\tfor (int j = 0; j < 102; j++) {\n\t\t\t\tx[i][j] = '#';\n\t\t\t\tfor (int k = 0; k < 4; k++)dp[i][j][k] = -1;\n\t\t\t}\n\t\t}\n\t\tcin >> H >> W >> L; int D = 0, X = 0, Y = 0;\n\t\tif (H == 0 && W == 0 && L == 0)break;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t\tif (x[i][j] != '#' && x[i][j] != '.') {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tif (T[k] == x[i][j]) {\n\t\t\t\t\t\t\tx[i][j] = '.'; D = k; X = i; Y = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0; dp[X][Y][D] = 0; long long V = 0, Z = 0, C = 0, F = 0;\n\t\twhile (true) {\n\t\t\tif (x[X + dx[D]][Y + dy[D]] == '#') {\n\t\t\t\tD = (D + 1) % 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tX += dx[D]; Y += dy[D]; cnt++;\n\t\t\t\tif (dp[X][Y][D] != -1) {\n\t\t\t\t\tV = dp[X][Y][D]; Z = cnt; goto E;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdp[X][Y][D] = cnt;\n\t\t\t\t\tif (cnt == L) {\n\t\t\t\t\t\tcout << X << ' ' << Y << ' ' << T[D] << endl;\n\t\t\t\t\t\tgoto F;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tE:;\n\t\tC = (Z - V); F = (L - Z) % C; F += V;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (dp[i][j][k] == F) {\n\t\t\t\t\t\tcout << i << ' ' << j << ' ' << T[k] << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tF:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <string>\nusing namespace std;\nstring tmp=\"NESW\";\n\t\t\t\t\nint xv[]={0,1,0,-1};\nint yv[]={-1,0,1,0};\n\nint main(){\n\tint H,W;\n\tlong long int L;\n\twhile(cin>>H>>W>>L,H){\n\t\tchar M[102][102];\n\t\tint p;\n\t\tint x,y;\n\t\tfor(int i=0;i<=H+1;i++)M[0][i]=M[W+1][i]='#';\n\t\tfor(int i=0;i<=W+1;i++)M[i][0]=M[i][H+1]='#';\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>M[j][i];\n\t\t\t\tif(M[j][i]!='.'&&M[j][i]!='#'){\n\t\t\t\t\tx=j;\n\t\t\t\t\ty=i;\n\t\t\t\t\tif(M[j][i]=='N')p=0;\n\t\t\t\t\tif(M[j][i]=='E')p=1;\n\t\t\t\t\tif(M[j][i]=='S')p=2;\n\t\t\t\t\tif(M[j][i]=='W')p=3;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint flag[102][102][4];\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tint ff=1;\n\t\tfor(long long int i=0;1;){\n\t\t\t\n\t\t\tif(flag[x][y][p]<0){\n\t\t\t\tflag[x][y][p]=i;\n\t\t\t}\n\t\t\telse if(ff){\n\t\t\t\tff=0;\n\t\t\t\tint kaga=i-flag[x][y][p];\n\t\t\t\tlong long int ll=L-i;\n\t\t\t\tll/=kaga;\n\t\t\t\tll--;\n\t\t\t\tll*=kaga;\n\t\t\t\tL-=ll;\n\t\t\t\t//cout<<\"$ \"<<kaga<<endl;\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\t35-11=24\n\t\t\t\t24/4=6\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t35\n\t\t\t\t11\n\t\t\t\t4\n\t\t\t\t\n\t\t\t\t31\n\t\t\t\t27\n\t\t\t\t23\n\t\t\t\t19\n\t\t\t\t15\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\twhile(M[x+xv[p]][y+yv[p]]=='#'){\n\t\t\t\tp=(p+1)%4;\n\t\t\t}\n\t\t\tx+=xv[p];\n\t\t\ty+=yv[p];\n\t\t\ti++;\n\t\t\t//if(ff||1)cout<<\"# \"<<y<<\" \"<<x<<\" \"<<tmp[p]<<\" \"<<i<<endl;\n\t\t\tif(i==L){\n\t\t\t\tcout<<y<<\" \"<<x<<\" \"<<tmp[p]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\n\t\t}\n\t\t\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nbool passed[101][101][4];\nchar field[101][101];\n\nint h,w;\nll l;\nint sy,sx,sag;\n\n// loopð©Â¯éÜÅTõ\nbool search1(ll &cl,int &cx,int &cy,int &cag,int &step){\n\tpassed[cy][cx][cag]=true;\n\twhile(1){\n\t\t// Ú®I¹\n\t\tif(cl==0){\n\t\t\tcout<<cy+1<<\" \"<<cx+1<<\" \";\n\t\t\tif(cag==0)cout<<'N';\n\t\t\telse if(cag==1)cout<<'E';\n\t\t\telse if(cag==2)cout<<'S';\n\t\t\telse if(cag==3)cout<<'W';\n\t\t\tcout<<endl;\n\t\t\treturn true;\n\t\t}\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\t// Ú®Â\\©\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\t// ·ÅÉÊßÏÝ©\n\t\t\tif(passed[ny][nx][cag]){\n\t\t\t\tcx=nx,cy=ny;\n\t\t\t\tcl--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassed[ny][nx][cag]=true;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tcl--;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\t// ÊßÏÝ\n\t\t\tif(passed[cy][cx][cag])break;\n\t\t\tpassed[cy][cx][cag]=true;\n\t\t}\n\t}\n\t// Ú®I¹\n\tif(cl==0){\n\t\tcout<<cy+1<<\" \"<<cx+1<<\" \";\n\t\tif(cag==0)cout<<'N';\n\t\telse if(cag==1)cout<<'E';\n\t\telse if(cag==2)cout<<'S';\n\t\telse if(cag==3)cout<<'W';\n\t\tcout<<endl;\n\t\treturn true;\n\t}\n\tint gx=cx;\n\tint gy=cy;\n\tint gag=cag;\n\t// Ü¾S[µÄ¢È¢\n\t// [vð¦é\n\twhile(1){\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tstep++;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t}\n\treturn false;\n}\n\n// [vð©Â¯éÜÅTõ.©Â¯½çA»Ì[vÌå«³ð¦é\nvoid solve(){\n\t// loop find\n\tint cx,cy,cag,step;\n\tstep=0;\n\tll cl=l;\n\tcx=sx;\n\tcy=sy;\n\tcag=sag;\n\t// [vBOÉS[\n\tmemset(passed,0,sizeof(passed));\n\tif(search1(cl,cx,cy,cag,step))return;\n\t// [vÉüÁ½ê,loopÌstepªclð¸ç·\n\tcl%=step;\n\tstep=0;\n\t// cèÌXebvÅS[\n\tmemset(passed,0,sizeof(passed));\n\tsearch1(cl,cx,cy,cag,step);\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>l&&!(h==0&&w==0&&l==0)){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!='#'&&field[i][j]!='.'){\n\t\t\t\t\tif(field[i][j]=='N')sag=0;\n\t\t\t\t\telse if(field[i][j]=='E')sag=1;\n\t\t\t\t\telse if(field[i][j]=='S')sag=2;\n\t\t\t\t\telse if(field[i][j]=='W')sag=3;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nchar field[110][110];\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint dx[4]   = {-1, 0, 1, 0};\nint dy[4]   = {0, 1, 0, -1};\n\nll memo[110][110][4];\nint main(){\n  ll H, W, L;\n  while(cin >>H >> W >> L && H + W + L){\n    fill(&field[0][0],&field[0][0] + 110 * 110, '#');\n    memset(memo, -1, sizeof(memo));\n\n    int x, y, d;\n    REP(i, H)REP(j, W){\n      cin >> field[i+1][j+1];\n      if(isalpha(field[i+1][j+1])){\n        x = i + 1, y = j + 1, d = find(dir, dir + 4, field[i+1][j+1]) - dir;\n      }\n    }\n\n    ll T = 0;\n    while(L > 0){\n      if(memo[x][y][d] >= 0){\n        ll S = T - memo[x][y][d];\n        T += (L / S) * S;\n        L %= S;\n      }\n\n      memo[x][y][d] = T;\n      \n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      if(field[nx][ny] == '#'){\n        d = (d + 1) % 4;\n        continue;\n      }\n      \n      x = nx;\n      y = ny;\n      L--;\n      T++;      \n    }\n    cout << x<< \" \" << y<< \" \" << dir[d] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (long long i = 0; i < (long long)(n); ++i)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nlong long mem[110][110][4];\n\nint main() {\n  long long h, w, n;\n  string m[110];\n  while (true) {\n    cin >> h >> w >> n;\n    if (h == 0 && w == 0 && n == 0) break;\n    rep (i, h) cin >> m[i + 1];\n    m[0] = m[h + 1] = \"\";\n    rep (i, w) m[0] += \"#\";\n    rep (i, w) m[h + 1] += \"#\";\n    rep (i, h + 2) m[i] = \"#\" + m[i] + \"#\";\n    h += 2;\n    w += 2;\n    int x, y, d;\n    rep (i, h) rep (j, w) {\n      if (m[i][j] == 'E') d = 0;\n      if (m[i][j] == 'S') d = 1;\n      if (m[i][j] == 'W') d = 2;\n      if (m[i][j] == 'N') d = 3;\n      if (isalpha(m[i][j])) {\n\tx = j;\n\ty = i;\n      }\n    }\n    rep (i, 110) rep (j, 110) rep (k, 4) mem[i][j][k] = -1;\n    rep (i, n) {\n      int xx = x + dx[d], yy = y + dy[d];\n      while (m[yy][xx] == '#') {\n\td = (d + 1) % 4;\n\txx = x + dx[d];\n\tyy = y + dy[d];\n      }\n      x = xx;\n      y = yy;\n      if (mem[y][x][d] != -1) {\n\tlong long k = i - mem[y][x][d];\n\tlong long a = (n - i) / k;\n\tif (a > 1) i += (a - 1) * k;\n      } else {\n\tmem[y][x][d] = i;\n      }\n    }\n    cout << y << \" \" << x << \" \" << \"ESWN\"[d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <iostream>\ntypedef long long ll;\nint dx[] = { 0,1,0,-1 }, dy[] = {-1, 0, 1, 0};\n\nusing namespace std;\nint main() {\n    ll H, W, L;\n    while (cin >> H >> W >> L, H) {\n        string field[100];\n        for (int i = 0; i < H; i++) {\n            cin >> field[i];\n        }\n\n        int x, y, dir;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] == 'N') x = j, y = i, dir = 0;\n                if (field[i][j] == 'E') x = j, y = i, dir = 1;\n                if (field[i][j] == 'S') x = j, y = i, dir = 2;\n                if (field[i][j] == 'W') x = j, y = i, dir = 3;\n            }\n        }\n\n        ll memo[100][100][4];\n        memset(memo, -1, sizeof memo);\n        memo[y][x][dir] = 0;\n\n        ll c = 0, rem = L;\n        while (rem > 0) {\n            int nx = x + dx[dir], ny = y + dy[dir];\n            while (nx < 0 || W <= nx || ny < 0 || H <= ny || field[ny][nx] == '#') {\n                dir = (dir + 1) % 4;\n                nx = x + dx[dir], ny = y + dy[dir];\n            }\n\n            c++;\n            rem--;\n            x = nx;\n            y = ny;\n\n            if (memo[y][x][dir] == -1){\n                memo[y][x][dir] = c;\n            }\n            else {\n                ll loop = c - memo[y][x][dir];\n                if (rem >= loop) rem %= loop;\n            }\n        }\n\n        string s = \"NESW\";\n        cout << y + 1 << \" \" << x + 1 << \" \" << s[dir] << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1LL << 60;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\nbool solve() {\n    int H, W;\n    lint L;\n    cin >> H >> W >> L;\n    if (H == 0) return false;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<vector<lint>>> dist(H, vector<vector<lint>>(W, vector<lint>(4, INF)));\n    int sx, sy, sd;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            for (int d = 0; d < 4; ++d) {\n                if (S[x][y] == \"NESW\"[d]) {\n                    sx = x;\n                    sy = y;\n                    sd = d;\n                }\n            }\n        }\n    }\n\n    dist[sx][sy][sd] = 0;\n    lint step = 0;\n    bool skipped = false;\n    while (step < L) {\n        int nx = sx + dx[sd], ny = sy + dy[sd];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny ||\n            S[nx][ny] == '#') {\n            sd = (sd + 1) % 4;\n        } else {\n            sx = nx, sy = ny;\n            ++step;\n        }\n\n        if (!skipped && dist[sx][sy][sd] < INF) {\n            lint diff = step - dist[sx][sy][sd];\n            step += (L - step) / diff * diff;\n            skipped = true;\n        }\n        dist[sx][sy][sd] = step;\n    }\n\n    cout << sx + 1 << \" \" << sy + 1 << \" \"\n         << \"NESW\"[sd] << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\nusing namespace std;\n \nconst char dir[5]=\"NESW\";\nint dx[4]={0, 1, 0, -1};\nint dy[4]={-1, 0, 1, 0};\n \nint main(){\n    while(1){\n        int h,w;\n        long long int l;\n        cin >> h >> w >> l;\n        if(w==0) break;\n         \n        vector<vector<char> > c(h+2, vector<char>(w+2, '#'));\n        int sy, sx, ndir;\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                cin >> c[i][j];\n                if(c[i][j]!='.' && c[i][j]!='#'){\n                    sy = i;\n                    sx = j;\n                    for(int k=0; k<4; k++){\n                        if(c[i][j] == dir[k]){\n                            ndir = k;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n         \n        map<pair<int, pair<int,int> >, int> used;\n        int y=sy, x=sx;\n        bool flag=false;\n        for(long long int i=0; i<l; i++){\n            pair<int, pair<int,int> > key = make_pair(ndir, make_pair(y, x));\n            if(used.count(key) != 0){\n                long long int rem = i-used[key];\n                long long int rnum = (l-i)%rem;\n                used.clear();\n                i = l-rnum-1;\n                continue;\n            }else{\n                used[key] = i;\n            }\n            while(c[y+dy[ndir]][x+dx[ndir]] == '#') ndir = (ndir+1)%4;\n            y += dy[ndir];\n            x += dx[ndir];\n        }\n         \n        if(!flag){\n            cout << y << \" \" << x << \" \" << dir[ndir] << endl;\n        }\n         \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nint H, W;\nll L;\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = { -1, 0, 1, 0};\nint getDir(char c) {\n    if (c == 'N') return 0;\n    if (c == 'W') return 1;\n    if (c == 'S') return 2;\n    if (c == 'E') return 3;\n}\nstring DIR = \"NWSE\";\nchar toDir(int x) {\n    return DIR[x];\n}\n\nint nxtDir(int dir) {\n    return (dir + 3) % 4;\n}\nvoid addWall(vector<string>& s, int& H, int& W, char wall = '#') {\n    s.insert(s.begin(), string(W, wall));\n    s.push_back(string(W, wall));\n    for (auto& t : s) t = wall + t + wall;\n    H = s.size();\n    W = s[0].size();\n}\n\nint d[110][110][5];\nvector<string> s;\n\nint main() {\n    while (cin >> H >> W >> L) {\n        if (H == 0 && W == 0 && L == 0) break;\n        s.clear();\n        s.resize(H);\n        rep(i, H) cin >> s[i];\n        addWall(s, H, W);\n        rep(i, 110) rep(j, 110) rep(k, 5) d[i][j][k] = -1;\n        int dir = -1;\n        int x, y;\n        rep(i, H) rep(j, W) {\n            if (s[i][j] != '#' && s[i][j] != '.') {\n                x = j;\n                y = i;\n                dir = getDir(s[i][j]);\n            }\n        }\n        {\n            bool f = true;\n            rep(i, 4) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                if (s[ny][nx] != '#') {\n                    f = false;\n                }\n            }\n            if (f) {\n                // rep(i, L % 4) dir = nxtDir(dir);\n                cout << y << \" \" << x << \" \" << toDir(dir) << endl;\n                continue;\n            }\n        }\n        d[y][x][dir] = 0;\n        // cout << y << \" \" << x << \" \" << dir << endl;\n        ll cnt = 0;\n        while (cnt < L) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            int p_dir = dir;\n            while (s[ny][nx] == '#') {\n                dir = nxtDir(dir);\n                nx = x + dx[dir];\n                ny = y + dy[dir];\n            }\n            // cout << ny << \" \" << nx << \" \" << dir << endl;\n            if (d[ny][nx][dir] != -1) {\n                ll dif = d[y][x][p_dir] + 1 - d[ny][nx][dir];\n                // L = (L - dif) % 4;\n                ll R = L - cnt;\n                R -= R/dif*dif;\n                L = cnt + R;\n                rep(i, 110) rep(j, 110) rep(k, 5) d[i][j][k] = -1;\n                d[ny][nx][dir] = 0;\n            } else {\n                d[ny][nx][dir] = d[y][x][p_dir] + 1;\n            }\n            y = ny;\n            x = nx;\n            cnt++;\n        }\n        cout << y << \" \" << x << \" \" << toDir(dir) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct State{\n  ll x, y;\n  char d;\n};\n\nchar field[110][110];\nint H, W, L;\nvector<State> v;\nState pos;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nconst char dn[] = {'N', 'E', 'S', 'W'};\n\nint Ls;\n\nbool isVisited(State s){\n  for(int i = 0 ; i < v.size() ; i++){\n    if(v[i].x == s.x && v[i].y == s.y && v[i].d == s.d){\n      Ls = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nState solve(){\n  //v.push_back(pos);\n\n  int cnt = 0;\n  int dir;\n  for(int i = 0 ; i < 4 ; i++){\n    if(dn[i] == pos.d) dir = i;\n  }\n  \n  while(true){\n    int nx = pos.x + dx[dir];\n    int ny = pos.y + dy[dir];\n    \n    if(field[ny][nx] == '#' || nx < 0 || nx >= W || ny < 0 || ny >= H){\n      dir = (dir+1) % 4;\n      continue;\n    }\n    pos.y = ny, pos.x = nx, pos.d = dn[dir];\n    cnt++;\n    if(isVisited(pos)) break;\n\n    v.push_back(pos);\n    if(cnt == L) return pos;\n  }\n  \n  ll remain = L - cnt;\n  ll cycle_len = v.size() - Ls;\n  remain %= cycle_len;\n  //cout << \"L = \" << L << endl;\n  //cout << \"cycle_len = \" << cycle_len << endl;\n  //cout << \"remain = \" << remain << endl;\n  //cout << \"Ls = \" << Ls << endl;\n  return v[Ls+remain];\n}\n\nvoid init(){\n  v.clear();\n}\n\nint main(){\n  while(cin >> H >> W >> L){\n    if(H == 0 && W == 0 && L == 0) break;\n    init();\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> field[i][j];\n\tif(isalpha(field[i][j])) pos.x = j, pos.y = i, pos.d = field[i][j];\n      }\n    }\n    \n    int dir;\n    for(int i = 0 ; i < 4 ; i++){\n      if(dn[i] == pos.d) dir = i;\n    }\n    \n    bool canmove = false;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = pos.x + dx[i], ny = pos.y + dy[i];\n      if(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n      if(field[ny][nx] == '.') canmove = true;\n    }\n    \n    if(!canmove){\n      cout << pos.y+1 << ' ' << pos.x+1 << ' ' << dn[(L%4 + dir) % 4] << endl;\n    }\n    else{\n      State ans = solve();\n      cout << ans.y+1 << ' ' << ans.x+1 << ' ' << ans.d << endl;\n      /*\n      for(int i = 0 ; i < v.size() ; i++){\n\tcout << i << \": \" << \"x = \" << v[i].x+1 << \", y = \" << v[i].y+1 << \", d = \" << v[i].d << endl;\n      }\n      cout << endl;\n      */\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\nconst string tmp = \"NEST\";\nconst int vy[] = {-1, 0, 1, 0}, vx[] = {0, 1, 0, -1};\n\nint H, W;\nint64 L;\nstring C[100];\nint sx, sy, sv;\nint nxt[100][100][4];\nvoid dfs(int x, int y, int v, int step)\n{\n  int nx = x + vx[v], ny = y + vy[v], nv = (v + 1) % 4;\n  if(step == 0) {\n    cout << y + 1 << \" \" << x + 1 << \" \" << tmp[v] << endl;\n    return;\n  } else if(0 <= nx && 0 <= ny && nx < W && ny < H && C[ny][nx] != '#') {\n    int loop = ~nxt[nx][ny][v] ? nxt[x][y][v] - nxt[nx][ny][v] : step;\n    nxt[nx][ny][v] = nxt[x][y][v] + 1;\n    return(dfs(nx, ny, v, (step - 1) % loop));\n  } else {\n    nxt[x][y][nv] = nxt[x][y][v];\n    return(dfs(x, y, nv, step));\n  }\n}\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    memset(nxt, -1, sizeof(nxt));\n    for(int i = 0; i < H; i++) {\n      cin >> C[i];\n      for(int j = 0; j < W; j++) {\n        int p = tmp.find(C[i][j]);\n        if(p != string::npos) sx = j, sy = i, sv = p;\n      }\n    }\n    nxt[sx][sy][sv] = 0;\n    dfs(sx, sy, sv, L);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        long long count = 0;\n        string wall = \"\";\n        int memo[101][101][4];\n        fill_n((int *)memo, 101*101*4, -1);\n\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n            }\n        }\n\n        memo[y][x][dir] = 0;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n            }\n            else\n                dir = (dir+1) % 4;\n            if (memo[y][x][dir] != -1) {\n                l = l % (count - memo[y][x][dir]);\n            } else if(vs[y][x] == '.') {\n                memo[y][x][dir] = count;\n            }\n        }\n        cout << y << \" \" << x << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\n\nint main(void){\n\tint dx[4] = {0,1,0,-1}, x, y, j, k, h, w, dy[4] = {-1,0,1,0};\n\tlong long int i, l, flag[100][100][4], d;;\n\tchar str[100][101], dir[5] = {\"NEST\"};\n\twhile(1){\n\t\tscanf(\"%d%d%d%*c\",&h,&w,&l);\n\t\tif(h == 0 && w == 0 && l == 0)\n\t\t\tbreak;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tstr[i][j] = getchar();\n\t\t\t\tif(isupper(str[i][j])){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = (int)i;\n\t\t\t\t\tfor(k = 0;k < 4;k++)\n\t\t\t\t\t\tif(str[i][j] == dir[k]) d = k;\n\t\t\t\t\tstr[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tmemset(flag,-1,sizeof(flag));\n\t\tfor(i = 0;i < l;i++){\n\t\t\tif(flag[y][x][d] == -1)\n\t\t\t\tflag[y][x][d] = (int)i;\n\t\t\telse{\n\t\t\t\ti += (i - flag[y][x][d]) * ((l - i) / (i - flag[y][x][d])) - 1;\n\t\t\t\tmemset(flag,-1,sizeof(flag));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile(1){\n\t\t\t\tif(x + dx[d] >= 0 && x + dx[d] < w && y + dy[d] >= 0 && y + dy[d] < h && str[y + dy[d]][x + dx[d]] == '.'){\n\t\t\t\t\tx = x + dx[d];\n\t\t\t\t\ty = y + dy[d];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",y + 1,x + 1,dir[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (long long i = 0; i < (long long)(n); ++i)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint mem[110][110][4];\n\nint main() {\n  long long h, w, n;\n  string m[110];\n  while (true) {\n    cin >> h >> w >> n;\n    if (h == 0 && w == 0 && n == 0) break;\n    rep (i, h) cin >> m[i + 1];\n    m[0] = m[h + 1] = \"\";\n    rep (i, w) m[0] += \"#\";\n    rep (i, w) m[h + 1] += \"#\";\n    rep (i, h + 2) m[i] = \"#\" + m[i] + \"#\";\n    h += 2;\n    w += 2;\n    int x, y, d;\n    rep (i, h) rep (j, w) {\n      if (m[i][j] == 'E') d = 0;\n      if (m[i][j] == 'S') d = 1;\n      if (m[i][j] == 'W') d = 2;\n      if (m[i][j] == 'N') d = 3;\n      if (isalpha(m[i][j])) {\n\tx = j;\n\ty = i;\n      }\n    }\n    rep (i, 110) rep (j, 110) rep (k, 4) mem[i][j][k] = -1;\n    rep (i, n) {\n      int xx = x + dx[d], yy = y + dy[d];\n      while (m[yy][xx] == '#') {\n\td = (d + 1) % 4;\n\txx = x + dx[d];\n\tyy = y + dy[d];\n      }\n      x = xx;\n      y = yy;\n      if (mem[y][x][d] != -1) {\n\tint k = i - mem[y][x][d];\n\tint a = (n - i) / k;\n\tif (a > 1) i += (a - 1) * k;\n      } else {\n\tmem[y][x][d] = i;\n      }\n    }\n    cout << y << \" \" << x << \" \" << \"ESWN\"[d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst lint INF = 1LL << 60;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\nbool solve() {\n    int H, W;\n    lint L;\n    cin >> H >> W >> L;\n    if (H == 0) return false;\n\n    vector<string> S(H);\n    for (auto& s : S) cin >> s;\n\n    vector<vector<vector<lint>>> dist(H, vector<vector<lint>>(W, vector<lint>(4, INF)));\n    int sx, sy, sd;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            for (int d = 0; d < 4; ++d) {\n                if (S[x][y] == \"NESW\"[d]) {\n                    sx = x;\n                    sy = y;\n                    sd = d;\n                }\n            }\n        }\n    }\n\n    dist[sx][sy][sd] = 0;\n    lint step = 0;\n    bool skipped = false;\n    while (step < L) {\n        int nx = sx + dx[sd], ny = sy + dy[sd];\n        if (nx < 0 || H <= nx || ny < 0 || W <= ny ||\n            S[nx][ny] == '#') {\n            sd = (sd + 1) % 4;\n        } else {\n            sx = nx, sy = ny;\n            ++step;\n        }\n\n        if (!skipped && dist[sx][sy][sd] < INF) {\n            lint diff = step - dist[sx][sy][sd];\n            step += (L - step) / diff * diff;\n            skipped = true;\n        }\n        dist[sx][sy][sd] = step;\n    }\n    assert(step == L);\n\n    cout << sx + 1 << \" \" << sy + 1 << \" \"\n         << \"NESW\"[sd] << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\n// Header under development {{{\n\nint LCM(int a, int b) {\n\t// FIXME\n\treturn a * b;\n}\n\n// Fraction class {{{\n// ref: http://martin-thoma.com/fractions-in-cpp/\nclass Fraction {\n\tpublic:\n\t\tULL numerator;\n\t\tULL denominator;\n\t\tFraction(ULL _numerator, ULL _denominator) {\n\t\t\tassert(_denominator > 0);\n\t\t\tnumerator = _numerator;\n\t\t\tdenominator = _denominator;\n\t\t};\n\n\t\tFraction operator*(const ULL rhs) {\n\t\t\treturn Fraction(this->numerator * rhs, this->denominator);\n\t\t};\n\n\t\tFraction operator*(const Fraction& rhs) {\n\t\t\treturn Fraction(this->numerator * rhs.numerator, this->denominator * rhs.denominator);\n\t\t}\n\n\t\tFraction operator+(const Fraction& rhs) {\n\t\t\tULL lcm = LCM(this->denominator, rhs.denominator);\n\t\t\tULL numer_lhs = this->numerator * (this->denominator / lcm);\n\t\t\tULL numer_rhs = rhs.numerator * (rhs.numerator / lcm);\n\t\t\treturn Fraction(numer_lhs + numer_rhs, lcm);\n\t\t}\n\n\t\tFraction& operator+=(const Fraction& rhs) {\n\t\t\tFraction result = (*this) + rhs;\n\t\t\tthis->numerator = result.numerator;\n\t\t\tthis->denominator = result.denominator;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream &s, const Fraction &a) {\n\tif (a.denominator == 1) {\n\t\ts << a.numerator;\n\t} else {\n\t\ts << a.numerator << \"/\" << a.denominator;\n\t}\n\treturn s;\n}\n\n// }}}\n\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tULL H, W, L;\n\twhile (cin >> H >> W >> L, H | W | L) {\n\t\tint cy, cx, cd;\n\t\tVVC field(H, VC(W));\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tfield[i][j] = c;\n\t\t\t\tif (c != '.' && c != '#') {\n\t\t\t\t\tcy = i, cx = j;\n\t\t\t\t\tcd =\n\t\t\t\t\t\t(c == 'N') ? 0 :\n\t\t\t\t\t\t(c == 'E') ? 1 :\n\t\t\t\t\t\t(c == 'S') ? 2 :\n\t\t\t\t\t\t(c == 'W') ? 3 : -1;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttypedef vector<VVI> VVVI;\n\t\tVVVI cost(H, VVI(W, VI(4, INF)));\n\t\tULL steps = 0;\n\t\twhile (true) {\n\t\t\tcost[cy][cx][cd] = steps;\n\t\t\tif (steps == L) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint dy4[] = { -1, 0, 1, 0 };\n\t\t\tint dx4[] = { 0, 1, 0, -1 };\n\n\t\t\tbool looped = false;\n\t\t\tbool moved = false;\n\t\t\tREP (d, 4) {\n\t\t\t\tint nd = (cd + d) % 4;\n\t\t\t\tint ny = cy + dy4[nd], nx = cx + dx4[nd];\n\t\t\t\tif (in_field(H, W, P(ny, nx)) && field[ny][nx] != '#') {\n\t\t\t\t\tmoved = true;\n\t\t\t\t\tsteps++;\n\t\t\t\t\tif (!looped && !(cost[ny][nx][nd] == INF)) {\n\t\t\t\t\t\tlooped = true;\n\t\t\t\t\t\tULL rest = L - steps;\n\t\t\t\t\t\tULL loop_len = cost[cy][cx][cd] - cost[ny][nx][nd] + 1;\n\t\t\t\t\t\tsteps += loop_len * (rest / loop_len);\n\t\t\t\t\t}\n\t\t\t\t\tcy = ny; cx = nx; cd = nd;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(moved);\n\t\t}\n\t\tchar dirchars[] = { 'N', 'E', 'S', 'W' };\n\t\tcout << cy + 1 << \" \" << cx + 1 << \" \" << dirchars[cd] << endl;\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n  int h, w, n;\n  string m[110];\n  while (true) {\n    cin >> h >> w >> n;\n    if (h == 0 && w == 0 && n == 0) break;\n    rep (i, h) cin >> m[i + 1];\n    m[0] = m[h + 1] = \"\";\n    rep (i, w) m[0] += \"#\";\n    rep (i, w) m[h + 1] += \"#\";\n    rep (i, h + 2) m[i] = \"#\" + m[i] + \"#\";\n    h += 2;\n    w += 2;\n    int x, y, d;\n    rep (i, h) rep (j, w) {\n      if (m[i][j] == 'E') d = 0;\n      if (m[i][j] == 'S') d = 1;\n      if (m[i][j] == 'W') d = 2;\n      if (m[i][j] == 'N') d = 3;\n      if (isalpha(m[i][j])) {\n\tx = j;\n\ty = i;\n      }\n    }\n    rep (i, n) {\n      int xx = x + dx[d], yy = y + dy[d];\n      while (m[yy][xx] == '#') {\n\td = (d + 1) % 4;\n\txx = x + dx[d];\n\tyy = y + dy[d];\n      }\n      x = xx;\n      y = yy;\n    }\n    cout << y << \" \" << x << \" \" << \"ESWN\"[d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\nenum {NORTH = 'N', EAST = 'E', SOUTH = 'S', WEST = 'W'};\ntypedef pair<int, int> Point;\n\n#define WALL '#'\n#define EMPTY '.'\n#define START 'S'\n\nstruct Robot{\n  Robot(int i=0, int j=0, int d=NORTH){y=i; x=j; dir=d;}\n\n  int y, x;\n  char dir;\n\n  Point next(){\n    return Point((dir==SOUTH)-(dir==NORTH), (dir==EAST)-(dir==WEST));\n  }\n  void move(){\n    y += next().first;\n    x += next().second;\n  }\n  void turn(){\n    switch(dir){\n    case NORTH:\n      dir = EAST;\n      break;\n    case EAST:\n      dir = SOUTH;\n      break;\n    case SOUTH:\n      dir = WEST;\n      break;\n    case WEST:\n      dir = NORTH;\n      break;\n    }\n  }\n};\n\nint main()\n{\n  int H, W, L;\n  map<char,int>DtoI;\n  DtoI['N']=0;\n  DtoI['E']=1;\n  DtoI['S']=2;\n  DtoI['W']=3;\n while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    int visited[102][102][4] = {0};\n    Robot me;\n    int step=0;\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, c[i][j]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L-step>0){\n      if(int t=visited[me.y][me.x][DtoI[me.dir]]){\n        t++;\n        while(L > step+t){step += t;}\n      }\n      visited[me.y][me.x][DtoI[me.dir]] = step;\n\n      while(c[me.y + me.next().first][me.x + me.next().second] == WALL){\n        me.turn();\n      }\n      me.move();\n      step++;\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<me.dir<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {1,0,-1,0};\nconst static int ty[] = {0,1,0,-1};\nconst static char dir_char[] = {'E','S','W','N'};\n \nenum dir {\n  EAST,\n  SOUTH,\n  WEST,\n  NORTH\n};\n\nstatic const double EPS = 1e-8;\n\nvoid printStage(char stage[100][100],int H,int W,\n\t\tint current_x,int current_y,int current_dir){\n\n  char output[100][100];\n\n  //init\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      output[y][x] = '.';\n    }\n  }\n\n  //wall\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(stage[y][x] == '#'){\n\toutput[y][x] = '#';\n      }\n    }\n  }\n\n  //robot\n  output[current_y][current_x] = dir_char[current_dir];\n\n  //write\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      printf(\"%c\",output[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int H,W;\n  ll L;\n  while(~scanf(\"%d %d %ld\",&H,&W,&L)){\n    if(H == 0 && W == 0 && L == 0) break;\n\n    char stage[100][100];\n\n    int current_dir = NORTH;\n    int current_x = 0;\n    int current_y = 0;\n\n    for(int y=0;y<H;y++){\n      char line[120];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] == 'E'){\n\t  current_dir = EAST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'S'){\n\t  current_dir = SOUTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'W'){\n\t  current_dir = WEST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'N'){\n\t  current_dir = NORTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n      }\n    }\n\n    vector<ll> dp[100][100][4];\n    int TTL = 10000000;\n    int MAX_TTL = 10000000;\n    while(TTL-- > 0){\n      int dx = current_x + tx[current_dir];\n      int dy = current_y + ty[current_dir];\n\n      // printStage(stage,H,W,current_x,current_y,current_dir);\n      // cout << dx << \" \" << dy << \" \" << endl;\n      if(dy < 0 || dy >= H || dx < 0 || dx >= W){\n\tcurrent_dir = (current_dir + 1) % 4;\n\tTTL++;\n\tcontinue;\n      }\n      else if(stage[dy][dx] == '#'){\n\tcurrent_dir = (current_dir + 1) % 4;\n\tTTL++;\n\tcontinue;\n      }\n      current_x = dx;\n      current_y = dy;\n      if(dp[current_x][current_y][current_dir].size() < 2){\n\tdp[current_x][current_y][current_dir].push_back(MAX_TTL-TTL);\n      }\n    }\n\n    int res_x = 0;\n    int res_y = 0;\n    int res_dir = 0;\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tfor(int i=0;i<4;i++){\n\t  if(dp[x][y][i].size() < 2) continue;\n\t  ll a0 = dp[x][y][i][0];\n\t  ll a1 = dp[x][y][i][1];\n\t  // L == a0 + k(a1-a0)\n\t  // L - a0 == k(a1-a0)\n\t  // k == (L - a0) / (a1 - a0)\n\n\t  if(L - a0 < 0) continue;\n\t  if(a1 - a0 <= 0) continue;\n\n\t  if((L-a0) % (a1-a0) == 0){\n\t    res_x = x;\n\t    res_y = y;\n\t    res_dir = i;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d %d %c\\n\",res_y+1,res_x+1,dir_char[res_dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define Y first.first\n#define X first.second\n#define D second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst string kDir = \"ESWN\";\nconst vi dx = { 1, 0,-1, 0};\nconst vi dy = { 0, 1, 0,-1};\n\ntypedef pair<pii, int> State;\n\nint main(void){\n    for(int h, w, L; cin >> h >> w >> L, h;){\n        vs field(h + 2);\n        rep(x, w + 2) field[0].pb('#'), field[h + 1].pb('#');\n\n        State cur;\n        \n        range(y, 1, h + 1){\n            string f; cin >> f;\n\n            field[y].pb('#');\n            field[y] += f;\n            field[y].pb('#');\n\n            range(x, 1, w + 1){\n                if(field[y][x] != '.' && field[y][x] != '#'){\n                    int d = kDir.find(field[y][x]);\n                    cur = mp(mp(y, x), d);\n\n                    field[y][x] = '.';\n                }\n            }\n        }\n\n        map<State, int> step;\n        int cnt_step = 0;\n\n        while(step.find(cur) == step.end()){\n            step[cur] = cnt_step;\n            pii next_pos = mp(cur.Y + dy[cur.D], cur.X + dx[cur.D]);\n\n            if(field[next_pos.first][next_pos.second] == '#'){\n               (cur.D += 1) %= kDir.size();\n            }\n            else{\n                cur.first = next_pos;\n                cnt_step++;\n            }\n        }\n\n        cnt_step -= step[cur];\n        L -= step[cur];\n        if(L >= 0) L %= cnt_step;\n        L += step[cur];\n\n        State res;\n        for(auto s : step){\n            if(s.second == L) res = s.first;\n        }\n\n        cout << res.Y << \" \" << res.X << \" \" << kDir[res.D] << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W;\nll L;\nvector<string> maze;\nvector<vector<vector<ll> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<ll> >(W, vector<ll>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    for(ll step=0; step<=L; ++step){\n        if(vis[x][y][d] != -1){\n            L = vis[x][y][d] + (L - step) % (step - vis[x][y][d]);\n            break;\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        while(!inrect(nx, ny) || maze[nx][ny] == '#'){\n            (d += 1) %= 4;\n            nx = x + dx[d]; ny = y + dy[d];\n        }\n        x = nx; y = ny;\n    }\n    rep(i, H)rep(j, W)rep(k, 4)if(vis[i][j][k] == L){\n        x = i; y = j; d = k;\n        break;\n    }\n    return make_tuple(x+1, y+1, \"NESW\"[d]);\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\nusing i32=int;using i64=long long;using ll =i64;\nusing uint=unsigned int;using ull=unsigned long long;\ntemplate<typename T> using matrix=vector<vector<T> >;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\n//ind -> V から V->ind (注:単射)\ntemplate<typename T>\nmap<T,int> rev(const vector<T>& xs){\n\tmap<T,int> rev;\n\tREP(i,(int)xs.size())rev.insert(make_pair(xs[i],i));\n\treturn rev;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nint H,W;\n\nstruct State{\n\tint y,x,d;\n\tState(int y,int x,int d):y(y),x(x),d(d){};\n};\n\nint enc(int y,int x,int d){\n\treturn (y*W+x)*4+d;\n}\nchar encD(int d){\n\tif(d==0)return 'E';\n\tif(d==1)return 'S';\n\tif(d==2)return 'W';\n\tif(d==3)return 'N';\n\treturn '_';\n}\n\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint main(){\n\n\twhile(true){\n\t\tll L;cin >> H >> W >> L;\n\t\tif(H==0)break;\n\t\tvector<string> map(H);\n\t\tREP(y,H)cin >> map[y];\n\n\t\tint py,px,d;\n\t\tREP(y,H)REP(x,W){\n\t\t\tif(map[y][x]=='E'){\n\t\t\t\tpy=y;px=x;d=0;break;\n\t\t\t}\n\t\t\tif(map[y][x]=='S'){\n\t\t\t\tpy=y;px=x;d=1;break;\n\t\t\t}\n\t\t\tif(map[y][x]=='W'){\n\t\t\t\tpy=y;px=x;d=2;break;\n\t\t\t}\n\t\t\tif(map[y][x]=='N'){\n\t\t\t\tpy=y;px=x;d=3;break;\n\t\t\t}\n\t\t}\n\t\tvector<bool> pass(H*W*4);\n\t\tvector<State> ss;\n\t\n\t\tfor(int l=0;true;l++){\n\t\t\tif(l==L){\n\t\t\t\tcout<< (py+1)<<\" \"<<(px+1)<<\" \"<<encD(d)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(pass[enc(py,px,d)]){//loop check\n\t\t\t\tint li=-1;\n\t\t\t\tREP(i,ss.size()){\n\t\t\t\t\tif(enc(ss[i].y,ss[i].x,ss[i].d)==enc(py,px,d)){\n\t\t\t\t\t\tli=i;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//L=li+(l-li)*k+r\n\t\t\t\tint res=(L-li)%(l-li)+li;\n\t\t\t\tcout<<(ss[res].y+1)<<\" \"<<(ss[res].x+1)<<\" \"<<encD(ss[res].d)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpass[enc(py,px,d)]=true;\n\t\t\tss.push_back(State(py,px,d));\n\n\t\t\t//move\n\t\t\tfor(int c=0;c<4;c++){\n\t\t\t\tint nx=px+dx[d],ny=py+dy[d];\n\t\t\t\tif(!IN(0,nx,W)  || !IN(0,ny,H)){\n\t\t\t\t\td=(d+1+4)%4;continue;\n\t\t\t\t}\n\t\t\t\tif(map[ny][nx]=='#'){\n\t\t\t\t\td=(d+1+4)%4;continue;\n\t\t\t\t}\n\t\t\t\tpx=nx;py=ny;break;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nbool passed[101][101][4];\nchar field[101][101];\n\nint h,w;\nll l;\nint sy,sx,sag;\n\n// loopð©Â¯éÜÅTõ\nbool search1(ll &cl,int &cx,int &cy,int &cag,int &step){\n\tpassed[cy][cx][cag]=true;\n\twhile(1){\n\t\t// Ú®I¹\n\t\tif(cl==0){\n\t\t\tcout<<cy+1<<\" \"<<cx+1<<\" \";\n\t\t\tif(cag==0)cout<<'N';\n\t\t\telse if(cag==1)cout<<'E';\n\t\t\telse if(cag==2)cout<<'S';\n\t\t\telse if(cag==3)cout<<'W';\n\t\t\tcout<<endl;\n\t\t\treturn true;\n\t\t}\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\t// Ú®Â\\©\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\t// ·ÅÉÊßÏÝ©\n\t\t\tif(passed[ny][nx][cag]){\n\t\t\t\tcx=nx,cy=ny;\n\t\t\t\tcl--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpassed[ny][nx][cag]=true;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tcl--;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\t// ÊßÏÝ\n\t\t\tif(passed[cy][cx][cag])break;\n\t\t\tpassed[cy][cx][cag]=true;\n\t\t}\n\t}\n\tint gx=cx;\n\tint gy=cy;\n\tint gag=cag;\n\t// Ü¾S[µÄ¢È¢\n\t// [vð¦é\n\tint cnt=0;\n\twhile(1){\n\t\tint nx=cx+dx[cag];\n\t\tint ny=cy+dy[cag];\n\t\tif(nx>=0&&ny>=0&&nx<w&&ny<h&&field[ny][nx]=='.'){\n\t\t\tcnt=0;\n\t\t\tcx=nx;\n\t\t\tcy=ny;\n\t\t\tstep++;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag)break;\n\t\t}\n\t\t// Ú®sÂ\\ÈêAûüðÏ¦é\n\t\telse{\n\t\t\tcag=(cag+1)%4;\n\t\t\tif(gx==cx&&gy==cy&&gag==cag){\n\t\t\t\t// cntª³¾Á½êA-cntµ½àÌðü«ÉZbgµÄ¨­\n\t\t\t\tcag=(cag-cnt+4)%4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn false;\n}\n\n// [vð©Â¯éÜÅTõ.©Â¯½çA»Ì[vÌå«³ð¦é\nvoid solve(){\n\t// loop find\n\tint cx,cy,cag,step;\n\tstep=0;\n\tll cl=l;\n\tcx=sx;\n\tcy=sy;\n\tcag=sag;\n\t// [vBOÉS[\n\tmemset(passed,0,sizeof(passed));\n\tif(search1(cl,cx,cy,cag,step))return;\n\t// [vÉüÁ½ê,loopÌstepªclð¸ç·\n\tcl%=step;\n\tstep=0;\n\t// cèÌXebvÅS[\n\tmemset(passed,0,sizeof(passed));\n\tsearch1(cl,cx,cy,cag,step);\n}\n\nint main(){\n\n\twhile(cin>>h>>w>>l&&!(h==0&&w==0&&l==0)){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]!='#'&&field[i][j]!='.'){\n\t\t\t\t\tif(field[i][j]=='N')sag=0;\n\t\t\t\t\telse if(field[i][j]=='E')sag=1;\n\t\t\t\t\telse if(field[i][j]=='S')sag=2;\n\t\t\t\t\telse if(field[i][j]=='W')sag=3;\n\t\t\t\t\tfield[i][j]='.';\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std; using namespace placeholders;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector< int > VI;\ntypedef vector< vector< int > > VVI;\ntypedef vector< string > VS;\ntypedef stringstream SS;\ntypedef pair< int, int > PII;\ntypedef vector< pair< int, int > > VPII;\n#define VT( T ) vector< T >\n#define VVT( T ) vector< vector< T > >\n#define LIM( T ) numeric_limits< T >\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; };\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); };\n\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &e : c )\n#define ALL( c ) ( c ).begin(), ( c ).end()\n#define AALL( a, t ) ( t* )a, ( t* )a + sizeof( a ) / sizeof( t )\n#define DRANGE( c, p ) ( c ).begin(), ( c ).begin() + p, ( c ).end()\n\n#define SZ( v ) ( (int)( v ).size() )\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconstexpr int dy[] = { -1, 0, 1, 0 };\nconstexpr int dx[] = { 0, 1, 0, -1 };\nconst string dirs( \"NESW\" );\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tfor ( LL H, W, L; cin >> H >> W >> L && ( H | W | L ); )\n\t{\n\t\tVS board( H );\n\t\tcin >> board;\n\n\t\tint y = 0, x = 0, d = 0;\n\t\tREP( i, H )\n\t\t{\n\t\t\tREP( j, W )\n\t\t\t{\n\t\t\t\tif ( isupper( board[i][j] ) )\n\t\t\t\t{\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t\td = dirs.find( board[i][j] );\n\t\t\t\t\tboard[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVT( VVI ) visited( H, VVI( W, VI( 4, -1 ) ) );\n\n\t\tfor ( int i = 0; i < L; ++i )\n\t\t{\n\t\t\tif ( visited[y][x][d] != -1 && ( L - i ) % ( i - visited[y][x][d] ) == 0 )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvisited[y][x][d] = i;\n\n\t\t\twhile ( true )\n\t\t\t{\n\t\t\t\tconst int ny = y + dy[d];\n\t\t\t\tconst int nx = x + dx[d];\n\n\t\t\t\tif ( 0 <= ny && ny < H && 0 <= nx && nx < W && board[ ny ][ nx ] == '.' )\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++d %= 4;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ty += dy[d];\n\t\t\tx += dx[d];\n\t\t}\n\n\t\tFOR( row, board )\n\t\t{\n\t\t\tcout << row << endl;\n\t\t}\n\n\t\tcout << y + 1 << ' ' << x + 1 << ' ' << dirs[d] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e17\n\nll h,w;\nll L;\nstring s[111];\nchar cs[]={'E','N','W','S'};\nmap<char,int> dir;\n\nll dist[111][111][5];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nint main(){\n\tcin.sync_with_stdio(false);\n  dir['E']=0; dir['N']=1; dir['W']=2; dir['S']=3;\n  while(1){\n    cin>>h>>w>>L;\n    if(h==0)break;\n    s[0]=s[h+1]=\"\";\n    rep(j,w+2){\n      s[0]+='#';\n      s[h+1]+='#';\n    }\n    repl(i,1,h+1){\n      string ss;\n      cin>>ss;\n      s[i]='#'+ss+'#';\n    }\n    h+=2; w+=2;\n    ll ni,nj,nd,nl=0;\n    rep(i,h)rep(j,w){\n      if(s[i][j]!='#'&&s[i][j]!='.'){\n        ni=i; nj=j; nd=dir[s[i][j]];\n      }\n    }\n    rep(i,111)rep(j,111)rep(k,5)dist[i][j][k]=INF;\n    while(dist[ni][nj][nd]==INF&&L>0){\n      //dbg(ni); dbg(nj); dbg(nd);\n      //dbg(dist[ni][nj][nd]);\n      dist[ni][nj][nd]=nl;\n      ll ti=ni+dy[nd],tj=nj+dx[nd];\n      if(s[ti][tj]=='#'){\n        nd=(nd+3)%4;\n      }else{\n        ni=ti; nj=tj;\n        nl++; L--;\n      }\n    }\n    if(L==0){\n      printf(\"%lld %lld %c\\n\", ni,nj,cs[nd]);\n    }else{\n      ll loop=nl-dist[ni][nj][nd];\n      L%=loop;\n      //rep(i,111)rep(j,111)rep(k,5)dist[i][j][k]=INF;\n      while(L>0){\n        ll ti=ni+dy[nd],tj=nj+dx[nd];\n        if(s[ti][tj]=='#'){\n          nd=(nd+3)%4;\n        }else{\n          ni=ti; nj=tj;\n          L--;\n        }\n      }\n      printf(\"%lld %lld %c\\n\", ni,nj,cs[nd]);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, L, d[105][105][4]; char c[105][105], w[5] = \"NESW\";\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &L), L) {\n\t\tfor (int i = 0; i < H; i++) scanf(\"%s\", c[i]);\n\t\tint sx = -1, sy = -1, sd = -1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (c[i][j] == w[k]) sx = j, sy = i, sd = k;\n\t\t\t\t\td[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[sy][sx][sd] = 0;\n\t\tint x = sx, y = sy, r = sd;\n\t\twhile (true) {\n\t\t\tint tx = x, ty = y, tr = r;\n\t\t\twhile (!rng(x + dx[r], y + dy[r]) || c[y + dy[r]][x + dx[r]] == '#') r = (r + 1) % 4;\n\t\t\tx += dx[r], y += dy[r];\n\t\t\tif (d[y][x][r] == -1) d[y][x][r] = d[ty][tx][tr] + 1;\n\t\t\telse {\n\t\t\t\tint t = d[ty][tx][tr] + 1, sa = t - d[y][x][r];\n\t\t\t\tif (L >= t) L = t + (L - t) % sa - sa;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (d[i][j][k] == L) printf(\"%d %d %c\\n\", i + 1, j + 1, w[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; LL L;\n  while(cin>>H>>W>>L,H){\n\tvector<string> vs(H);\n\tREP(i,H) cin >> vs[i];\n\tint sx, sy, sd;\n\tREP(y,H) REP(x,W)\n\t  if(vs[y][x] != '.' && vs[y][x] != '#'){\n\t\tsx = x, sy = y;\n\t\tswitch(vs[y][x]){\n\t\tcase 'N': sd = 0; break;\n\t\tcase 'E': sd = 1; break;\n\t\tcase 'S': sd = 2; break;\n\t\tcase 'W': sd = 3; break;\n\t\t}\n\t  }\n\n\tbool vis[100][100][4];\n\tfill((bool*)vis, (bool*)vis+100*100*4, false);\n\tint tx = sx, ty = sy, td = sd;\n\twhile(!vis[ty][tx][td]){\n\t  vis[ty][tx][td] = true;\n\t  int ttx = tx + dx[td], tty = ty + dy[td];\n\t  if(ttx < 0 || W <= ttx || tty < 0 || H <= tty || vs[tty][ttx] == '#'){\n\t\ttd = (td + 1) % 4;\n\t  }\n\t  else{\n\t\ttx = ttx, ty = tty;\n\t  }\n\t}\n\n\tint lx = tx, ly = ty, ld = td;\n\tLL cnt = 0;\n\twhile(vis[ty][tx][td]){\n\t  vis[ty][tx][td] = false;\n\t  int ttx = tx + dx[td], tty = ty + dy[td];\n\t  if(ttx < 0 || W <= ttx || tty < 0 || H <= tty || vs[tty][ttx] == '#'){\n\t\ttd = (td + 1) % 4;\n\t  }\n\t  else{\n\t\ttx = ttx, ty = tty, ++cnt;\n\t  }\n\t}\n\n\ttx = sx, ty = sy, td = sd;\n\twhile(L && (lx != tx || ly != ty || ld != td)){\n\t  int ttx = tx + dx[td], tty = ty + dy[td];\n\t  if(ttx < 0 || W <= ttx || tty < 0 || H <= tty || vs[tty][ttx] == '#'){\n\t\ttd = (td + 1) % 4;\n\t  }\n\t  else{\n\t\ttx = ttx, ty = tty, --L;\n\t  }\n\t}\n\n\tif(L > cnt)\n\t  L %= cnt, L+=cnt;\n\n\twhile(L){\n\t  int ttx = tx + dx[td], tty = ty + dy[td];\n\t  if(ttx < 0 || W <= ttx || tty < 0 || H <= tty || vs[tty][ttx] == '#'){\n\t\ttd = (td + 1) % 4;\n\t  }\n\t  else{\n\t\ttx = ttx, ty = tty, --L;\n\t  }\n\t}\n\tchar ch;\n\tswitch(td){\n\tcase 0: ch = 'N'; break;\n\tcase 1: ch = 'E'; break;\n\tcase 2: ch = 'S'; break;\n\tcase 3: ch = 'W'; break;\n\t}\n\tcout << ty+1 << \" \" << tx+1 << \" \" << ch << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W; LL L;\n  while(cin>>H>>W>>L,H){\n\tvector<string> vs(H);\n\tREP(i,H) cin >> vs[i];\n\tint sx, sy, sd;\n\tREP(y,H) REP(x,W)\n\t  if(vs[y][x] != '.' && vs[y][x] != '#'){\n\t\tsx = x, sy = y;\n\t\tswitch(vs[y][x]){\n\t\tcase 'N': sd = 0; break;\n\t\tcase 'E': sd = 1; break;\n\t\tcase 'S': sd = 2; break;\n\t\tcase 'W': sd = 3; break;\n\t\t}\n\t  }\n\n\tbool vis[100][100][4];\n\tfill((bool*)vis, (bool*)vis+100*100*4, false);\n\tint tx = sx, ty = sy, td = sd;\n\twhile(!vis[ty][tx][td]){\n\t  vis[ty][tx][td] = true;\n\t  int ttx = tx + dx[td], tty = ty + dy[td];\n\t  if(ttx < 0 || W <= ttx || tty < 0 || H <= tty || vs[tty][ttx] == '#'){\n\t\ttd = (td + 1) % 4;\n\t  }\n\t  else{\n\t\ttx = ttx, ty = tty;\n\t  }\n\t}\n\n\tint lx = tx, ly = ty, ld = td;\n\tLL cnt = 0;\n\twhile(vis[ty][tx][td]){\n\t  vis[ty][tx][td] = false;\n\t  int ttx = tx + dx[td], tty = ty + dy[td];\n\t  if(ttx < 0 || W <= ttx || tty < 0 || H <= tty || vs[tty][ttx] == '#'){\n\t\ttd = (td + 1) % 4;\n\t  }\n\t  else{\n\t\ttx = ttx, ty = tty, ++cnt;\n\t  }\n\t}\n\n\ttx = sx, ty = sy, td = sd;\n\twhile(L && (lx != tx || ly != ty || ld != td)){\n\t  int ttx = tx + dx[td], tty = ty + dy[td];\n\t  if(ttx < 0 || W <= ttx || tty < 0 || H <= tty || vs[tty][ttx] == '#'){\n\t\ttd = (td + 1) % 4;\n\t  }\n\t  else{\n\t\ttx = ttx, ty = tty, --L;\n\t  }\n\t}\n\n\tL %= cnt;\n\twhile(L){\n\t  int ttx = tx + dx[td], tty = ty + dy[td];\n\t  if(ttx < 0 || W <= ttx || tty < 0 || H <= tty || vs[tty][ttx] == '#'){\n\t\ttd = (td + 1) % 4;\n\t  }\n\t  else{\n\t\ttx = ttx, ty = tty, --L;\n\t  }\n\t}\n\tchar ch;\n\tswitch(td){\n\tcase 0: ch = 'N'; break;\n\tcase 1: ch = 'E'; break;\n\tcase 2: ch = 'S'; break;\n\tcase 3: ch = 'W'; break;\n\t}\n\tcout << ty+1 << \" \" << tx+1 << \" \" << ch << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nchar dd[] = {'N', 'E', 'S', 'W'};\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nint main() {\n\tll H, W, L;\n\twhile(cin >> H >> W >> L, H) {\n\t\tvs field(H);\n\t\tREP(i, H) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tint cx, cy, cd;\n\t\tREP(i, H) {\n\t\t\tREP(j, W) {\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#') {\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tswitch(field[i][j]) {\n\t\t\t\t\tcase 'N':\n\t\t\t\t\t\tcd = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tcd = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tcd = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tcd = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vvl> turn(H, vvl(W, vl(4)));\n\t\tbool looped = false;\n\t\tfor(ll t = 0; t < L; t++) {\n\t\t\tif(!looped && turn[cy][cx][cd] != 0) {\n\t\t\t\tlooped = true;\n\t\t\t\tll cycle = (t-turn[cy][cx][cd]-1);\n\t\t\t\tt += (L-t)/cycle;\n\t\t\t}\n\n\t\t\tint nx = cx+dx[cd];\n\t\t\tint ny = cy+dy[cd];\n\n\t\t\tif(ny<0 || H<=ny || nx<0 || W<=nx || field[ny][nx]=='#') {\n\t\t\t\tcd = (cd+1)%4;\n\t\t\t\tt--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tturn[cy][cx][cd] = t;\n\t\t\tcy = ny;\n\t\t\tcx = nx;\n\t\t}\n\n\t\tcout << cy+1 << \" \" << cx+1 << \" \" << dd[cd] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nchar cells[100][100];\nint visited[100][100][4];\nint visitt[100][100][4];\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nchar d[4]={'N','E','S','W'};\n\nint main(){\n  while(1){\n    int posx,posy,dir;\n    int h,w,l,walk=0,flag=0;\n    cin >> h >> w >> l;\n    if (h==0)break;\n    rep(i,h){\n      string s;\n      cin >> s;\n      rep(j,w){\n        cells[i][j] = s[j];\n        if (s[j]!='.'&&s[j]!='#'){\n          posx = i;\n          posy = j;\n          if (s[j]=='N'){\n            dir = 0;\n          } else if (s[j]=='E'){\n            dir = 1;\n          } else if (s[j]=='S'){\n            dir = 2;\n          } else {\n            dir = 3;\n          }\n        }\n      }\n    }\n    rep(i,h)rep(j,w)rep(k,4){visited[i][j][k]=0;visitt[i][j][k]=-1;}\n    visited[posx][posy][dir]=1;\n    visitt[posx][posy][dir]=0;\n    while(l>0){\n      if (posx+dx[dir]>=0&&posx+dx[dir]<h&&posy+dy[dir]>=0&&posy+dy[dir]<w){\n        if (cells[posx+dx[dir]][posy+dy[dir]]!='#'){\n          posx += dx[dir];\n          posy += dy[dir];\n          if (visited[posx][posy][dir]==0){\n            l--;\n            visited[posx][posy][dir]=1;\n            visitt[posx][posy][dir]=walk;\n            walk++;\n          } else if (flag==0){\n            l = l%(walk-visitt[posx][posy][dir]+1)-1;\n            flag=1;\n          } else {\n            l--;\n          }\n        } else {\n          dir++;\n          if (dir==4)dir=0;\n          if (visited[posx][posy][dir]==0){\n            visited[posx][posy][dir]=1;\n            visitt[posx][posy][dir]=walk;\n          } else if(flag==0){\n            l = l%(walk-visitt[posx][posy][dir]+1);\n            flag = 1;\n          }\n        }\n      } else {\n        dir++;\n        if (dir==4)dir=0;\n        if (visited[posx][posy][dir]==0){\n          visited[posx][posy][dir]=1;\n          visitt[posx][posy][dir]=walk;\n        } else if (flag==0) {\n          l = l%(walk-visitt[posx][posy][dir]+1);\n          flag = 1;\n        }\n      }\n    }\n    cout << posx+1 << \" \" << posy+1 << \" \" << d[dir]<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W;\nll L;\nvector<string> maze;\nvector<vector<vector<ll> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<ll> >(W, vector<ll>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    bool loop = false;\n    for(ll step=0; step<L;){\n        if(!loop && vis[x][y][d] != -1){\n            loop = true;\n            step = L - (L - step) % (step - vis[x][y][d]);\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        if(!inrect(nx, ny) || maze[nx][ny] == '#')(d += 1) %= 4;\n        else x = nx, y = ny, step++;\n    }\n    return make_tuple(x+1, y+1, \"NESW\"[d]);\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\n#pragma warning(disable : 4996)\nusing namespace std;\nint H, W, L, d[105][105][4]; char c[105][105], w[5] = \"NESW\";\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nint main() {\n\twhile (scanf(\"%d%d%d\", &H, &W, &L), L) {\n\t\tfor (int i = 0; i < H; i++) scanf(\"%s\", c[i]);\n\t\tint sx = -1, sy = -1, sd = -1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (c[i][j] == w[k]) sx = j, sy = i, sd = k;\n\t\t\t\t\td[i][j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[sy][sx][sd] = 0;\n\t\tint x = sx, y = sy, r = sd;\n\t\twhile (true) {\n\t\t\tint tx = x, ty = y, tr = r;\n\t\t\twhile (!rng(x + dx[r], y + dy[r]) || c[y + dy[r]][x + dx[r]] == '#') r = (r + 1) % 4;\n\t\t\tx += dx[r], y += dy[r];\n\t\t\tif (d[y][x][r] == -1) d[y][x][r] = d[ty][tx][tr] + 1;\n\t\t\telse {\n\t\t\t\tint t = d[ty][tx][tr] + 1, sa = t - d[y][x][r];\n\t\t\t\tif (L >= t) L = t + (L - t) % sa - sa;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (d[i][j][k] == L) printf(\"%d %d %c\\n\", i + 1, j + 1, w[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint H, W;\nll L;\nchar c[128][128];\nint dist[4][128][128]; // N E S W\nint dy[]={-1,0,1,0}, dx[]={0,1,0,-1};\n\nint convert(char ch){ return ch=='N'?0:ch=='E'?1:ch=='S'?2:3; }\nchar reconvert(int n){ return n==0?'N':n==1?'E':n==2?'S':'W'; }\n\nvoid solve(int sy, int sx, int sd){\n  int y=sy,x=sx,dir=sd;\n  dist[dir][y][x] = 0;\n  for(int step=1;;step++){\n    int nd = dir;\n    int ny = y+dy[nd], nx = x+dx[nd];\n    while(ny<0||ny>=H||nx<0||nx>=W||c[ny][nx]=='#'){\n      nd = (nd+1)%4;\n      ny = y+dy[nd], nx = x+dx[nd];\n    }\n\n    if(dist[nd][ny][nx]!=-1){\n      ll l = L-dist[nd][ny][nx];\n      l %= (dist[dir][y][x] - dist[nd][ny][nx] + 1);\n      rep(i,4) rep(j,128) rep(k,128){\n\tif(dist[i][j][k] != l + dist[nd][ny][nx]) continue;\n\tprintf(\"%d %d %c\\n\", j+1, k+1, reconvert(i));\n\treturn;\n      }\n    }\n    y = ny, x = nx, dir = nd; \n    if(step==L){\n      printf(\"%d %d %c\\n\", y+1, x+1, reconvert(dir));\n      return;\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d%lld\", &H,&W, &L) && H+W+L){\n    int sy, sx, sd;\n    memset(dist, -1, sizeof(dist));\n    rep(i,H){\n      scanf(\"%s\", c[i]);\n      rep(j,W){\n\tif(c[i][j]=='#'||c[i][j]=='.') continue;\n\tsy = i; sx = j;\n\tsd = convert(c[i][j]);\n\tc[i][j] = '.';\n      }\n    }\n    \n    //int y = sy, x = sx, dir = sd;\n    //    for(int step=0;;step++){\n    //    }\n    solve(sy, sx, sd);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <queue>\n#define N 110\nusing namespace std;\nstruct num\n{\n    int x,y,op;\n}a[1000000];\nint b[N][N],Top = 0;\nbool ch[N][N][5];\nint chv[N][N][5];\nchar s1[N];\nint pt[500];\nint X[]={-1,0,1,0};\nint Y[]={0,1,0,-1};\nint main()\n{\n    int n,m;\n    long long int k;\n    while(scanf(\"%d %d %lld\",&n,&m,&k)!=EOF)\n    {\n        if(n==0&&m==0&&k==0)\n        {\n            break;\n        }\n        int x,y;\n        int op;\n        memset(b,0,sizeof(b));\n        pt['N'] = 0;\n        pt['E'] = 1;\n        pt['S'] = 2;\n        pt['W'] = 3;\n        for(int i=0;i<=n-1;i++)\n        {\n            scanf(\"%s\",s1);\n            int l = strlen(s1);\n            for(int j=0;j<=l-1;j++)\n            {\n                if(s1[j]!='#')\n                {\n                    b[i][j] = 1;\n                }\n                if(s1[j]=='N'||s1[j]=='E'||s1[j]=='S'||s1[j]=='W')\n                {\n                    x = i;\n                    y = j;\n                    op = pt[s1[j]];\n                }\n            }\n        }\n        Top = 0;\n        memset(ch,false,sizeof(ch));\n        int uv = 0;\n        while(!ch[x][y][op])\n        {\n            if(uv)\n            {\n                chv[x][y][op] = Top;\n                a[Top].x = x;\n                a[Top].y = y;\n                a[Top++].op = op;\n                ch[x][y][op] = true;\n            }\n            int op2=op;\n            for(int i=0;i<=3;i++)\n            {\n                int x1 = x+X[op2];\n                int y1 = y+Y[op2];\n                if(x1>=0&&x1<=n-1&&y1>=0&&y1<=m-1&&b[x1][y1]!=0)\n                {\n                    x = x1;\n                    y = y1;\n                    op = op2;\n                    break;\n                }else\n                {\n                    op2 =(op2+1)%4;\n                }\n            }\n            uv = 1;\n        }\n        int pos=chv[x][y][op];\n        int sum = Top-pos;\n        int sum2=Top-sum;\n        if((long long int)sum2>=k)\n        {\n            pos = k-1;\n        }else\n        {\n            k = k-(long long int)sum2;\n            pos = k%(long long int)sum;\n            if(pos==0)\n            {\n                pos = Top-1;\n            }else\n            {\n                pos =  sum2-1+pos;\n            }\n        }\n        printf(\"%d %d \",a[pos].x+1,a[pos].y+1);\n        op = a[pos].op;\n        char c;\n        if(op==0)\n        {\n            c = 'N';\n        }else if(op==1)\n        {\n            c = 'E';\n        }else if(op==2)\n        {\n            c = 'S';\n        }else\n        {\n            c = 'W';\n        }\n        printf(\"%c\\n\",c);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef long long lint;\n\nint H, W, dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nlint L;\nstring grid[110], dir = \"NESW\";\n\nint visit[110][110][4], px[41000], py[41000], pd[41000];\n\nbool able(int x, int y) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return false;\n\treturn grid[y][x] == '.';\n}\n\nint main() {\n\twhile (cin >> H >> W >> L, H) {\n\t\tint x = 0, y = 0, d = 0;\n\t\t\n\t\tfor_(i,0,H) {\n\t\t\tcin >> grid[i];\n\t\t\tfor_(j,0,W) if (grid[i][j] != '.' && grid[i][j] != '#') {\n\t\t\t\tx = j; y = i;\n\t\t\t\td = dir.find(grid[i][j]);\n\t\t\t\tgrid[i][j] = '.';\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(visit, -1, sizeof(visit));\n\t\t\n\t\tlint s = 0;\n\t\twhile (visit[y][x][d] < 0) {\n\t\t\tvisit[y][x][d] = s;\n\t\t\tpx[s] = x; py[s] = y; pd[s] = d;\n\t\t\twhile (!able(x + dx[d], y + dy[d])) d = (d + 1) % 4;\n\t\t\tx += dx[d]; y += dy[d];\n\t\t\t++s;\n\t\t}\n\t\t\n\t\tlint t = visit[y][x][d], id = L;\n\t\tif (s < L) id = t + (L - t) % (s - t);\n\t\t\n\t\tcout << py[id] + 1 << \" \" << px[id] + 1 << \" \" << dir[pd[id]] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef long long lint;\ntypedef pair< int, int > pii;\ntypedef pair< pii, int > piii;\n\nint H, W, dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nlint L;\nstring grid[110];\n\nint ctd(char c) {\n\tint res = 0;\n\tif (c == 'E') res = 1;\n\tif (c == 'S') res = 2;\n\tif (c == 'W') res = 3;\n\treturn res;\n}\n\nchar dtc(int d) {\n\tchar res = 'N';\n\tif (d == 1) res = 'E';\n\tif (d == 2) res = 'S';\n\tif (d == 3) res = 'W';\n\treturn res;\n}\n\nbool able(int x, int y) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return false;\n\treturn grid[y][x] == '.';\n}\n\nint main() {\n\twhile (cin >> H >> W >> L, H) {\n\t\tint x = 0, y = 0, d = 0;\n\t\t\n\t\tfor_(i,0,H) {\n\t\t\tcin >> grid[i];\n\t\t\tfor_(j,0,W) if (grid[i][j] != '.' && grid[i][j] != '#') {\n\t\t\t\tx = j; y = i;\n\t\t\t\td = ctd(grid[i][j]);\n\t\t\t\tgrid[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\t\n\t\tset< piii > visit;\n\t\tvector< piii > root;\n\t\twhile (visit.find(piii(pii(y, x), d)) == visit.end()) {\n\t\t\tvisit.insert(piii(pii(y, x), d));\n\t\t\troot.push_back(piii(pii(y, x), d));\n\t\t\twhile (!able(x+dx[d], y+dy[d])) d = (d + 1) % 4;\n\t\t\tx += dx[d]; y += dy[d];\n\t\t}\n\t\t\n\t\tint ind = -1, roots = root.size();\n\t\tfor_(i,0,roots) if (root[i] == piii(pii(y, x), d)) { ind = i; break; }\n\t\t\n\t\tint id = ((int)(L - (lint)ind) % (roots - ind)) + ind;\n\t\tpiii ans = root[id];\n\t\tcout << ans.first.first + 1 << \" \" << ans.first.second + 1 << \" \" << dtc(ans.second) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int MAX = 105;\nstatic const string DIR = \"NESW\";\nstatic const int di[4] = {-1, 0, 1, 0};\nstatic const int dj[4] = {0, 1, 0, -1};\n\nint H, W, pi, pj, dir;\nlong long L;\nchar G[MAX][MAX];\n\nvoid input(){\n  REP(i, 1, H+1) REP(j, 1, W+1){\n    cin >> G[i][j];\n    if ( G[i][j] != '.' && G[i][j] != '#' ){\n      pi = i; pj = j;\n      rep(r, 4)\tif ( G[i][j] == DIR[r] ) dir = r;\n      G[i][j] = '.';\n    }\n  }\n}\n\nvoid simulate(){\n  int v[MAX][MAX][4];\n  rep(i, H+2) rep(j, W+2) rep(r, 4) v[i][j][r] = -1;\n  int pos = 0;\n  v[pi][pj][dir] = pos++;\n  bool cycle = false;\n  for ( bool cycle = false; pos <= L; pos++){\n    int ni = pi + di[dir];\n    int nj = pj + dj[dir];\n    while(G[ni][nj] == '#'){\n      dir = (dir+1)%4;\n      ni = pi + di[dir];\n      nj = pj + dj[dir];\n    } \n    pi = ni;\n    pj = nj;\n    if ( v[pi][pj][dir] < 0 || cycle ) {\n      v[pi][pj][dir] = pos;\n    } else {\n      long long cycle_len = pos - v[pi][pj][dir];\n      long long remain = L - pos;\n      pos = L - remain%cycle_len;\n      cycle = true;\n    }\n  }\n\n  cout << pi << \" \" << pj << \" \" << DIR[dir] << endl;\n}\n\nmain(){\n  while(1){\n    cin >> H >> W >> L;\n    if ( H == 0 ) break;\n    rep(i, H+2) rep(j, W+2 ) G[i][j] = '#';\n    input();\n    simulate();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 110\n#define M 100100\nusing namespace std;\n\nconst int dx[5]={-1,0,1,0};\nconst int dy[5]={0,1,0,-1};\nconst char fa[5]={'N','E','S','W'};\n\nlong long dp[N][N][5];\nint h,w,ansx,ansy,ansf;\nlong long ll;\nint map[N][N];\nint stackx[M],stacky[M],stackf[M];\n\nvoid dfs(int x,int y,int f,long long l)\n{\n\tif (l==ll) { ansx=x,ansy=y,ansf=f; return;}\n\tif (dp[x][y][f])\n\t{\n\t\tlong long loop= l-dp[x][y][f];\n\t\tlong long rest=ll-dp[x][y][f]+1;\n\t\t//tofind(x,y,f,rest%loop-1);\n\t\tlong long toxy=dp[x][y][f]+rest%loop-1;\n\t\tansx=stackx[toxy]; ansy=stacky[toxy]; ansf=stackf[toxy];\n\t\treturn;\n\t}\n\tstackx[l]=x; stacky[l]=y; stackf[l]=f;\n\tdp[x][y][f]=l; int tof=f;\n\twhile (map[x+dx[tof]][y+dy[tof]]==0)\n\t\ttof=(tof+1)%4;\n\t//stackx[l]=x; stacky[l]=y; stackf[l]=tof;\n\tdfs(x+dx[tof],y+dy[tof],tof,l+1);\n}\n\nvoid dfs1(int x,int y,int f,long long l)\n{\n    int tof=f,loop=0;\n    while (l<ll)\n    {\n        while (map[x+dx[tof]][y+dy[tof]]==0)\n            tof=(tof+1)%4;\n        x+=dx[tof]; y+=dy[tof];\n        l++;\n        if (dp[x][y][tof]!=-1)\n        {\n            //long long loop= l-dp[x][y][f];\n            //long long rest=ll-dp[x][y][f]+1;\n            //long long toxy=dp[x][y][f]+rest%loop-1;\n            //ansx=stackx[toxy]; ansy=stacky[toxy]; ansf=stackf[toxy];\n            /*long long loo=l-dp[x][y][tof];\n            long long rest=ll-l;\n            rest%=loo;\n            l=ll-rest;*/\n            long long loo=l-dp[x][y][tof];\n            long long rest=ll-l;\n            long long div=rest/loo;\n            //rest%=loo;\n            //l=ll-rest;\n            l+=div*loo;\n            memset(dp,-1,sizeof dp);\n            //loop=1;\n        }\n        else dp[x][y][tof]=l;\n\n    }\n    ansx=x; ansy=y; ansf=tof;\n}\n\nint main()\n{\n\tint sx,sy,sf;\n\tchar c;\n\t//freopen(\"in.txt\",\"r\",stdin);\n\twhile (scanf(\"%d%d%lld\",&h,&w,&ll),h|w|ll)\n\t{\n\t\t//cout<<123123<<endl;\n\t\tmemset(map,0,sizeof map);\n\t\tfor (int i=1;i<=h;i++)\n\t\t{\n\t\t\tgetchar();\n\t\t\tfor (int j=1;j<=w;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%c\",&c);\n\t\t\t\tif (c=='.') map[i][j]=1;\n\t\t\t\telse if (c=='#') map[i][j]=0;\n\t\t\t\telse if (c=='N') map[i][j]=1,sx=i,sy=j,sf=0;\n\t\t\t\telse if (c=='E') map[i][j]=1,sx=i,sy=j,sf=1;\n\t\t\t\telse if (c=='S') map[i][j]=1,sx=i,sy=j,sf=2;\n\t\t\t\telse if (c=='W') map[i][j]=1,sx=i,sy=j,sf=3;\n\t\t\t}\n\t\t}\n\t\t//cout<<123123<<endl;\n\t\tmemset(dp,-1,sizeof dp); dp[sx][sy][sf]=0;\n\t\tdfs1(sx,sy,sf,0);\n\t\tprintf(\"%d %d %c\\n\",ansx,ansy,fa[ansf]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define minus(a) memset(a, -1, sizeof a)\ntypedef long long ll;\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\nint main() {\n\n  int dy[] = {0,-1,0,1};\n  int dx[] = {-1,0,1,0};\n  string WNES = \"WNES\";\n  int H, W; ll L;\n  for(; cin >> H >> W >> L && (H|W|L);) {\n    string G[100]; rep(i, H) cin >> G[i];\n    int y = 0, x = 0, k = 0, c = 0;\n    rep(i, H) rep(j, W) if(isalpha(G[i][j])) y = i, x = j, k = WNES.find(G[i][j]);\n    int T[100][100][4]; minus(T);\n    vector<int> ys, xs, ds;\n\n    while(1) {\n      int ny = y + dy[k], nx = x + dx[k];\n      while(!in_range(ny, nx, H, W) || G[ny][nx] == '#')\n        (k += 1) %= 4, ny = y + dy[k], nx = x + dx[k];\n      y = ny, x = nx;\n      c++;\n      if(~T[y][x][k]) {\n        int len = c - T[y][x][k];\n        (L -= T[y][x][k]) %= len;\n        L += T[y][x][k] - 1;\n        cout << ys[L] + 1 << \" \" << xs[L] + 1 << \" \" << WNES[ds[L]] << endl;\n        break;\n      }\n      if(c == L) {\n        cout << y + 1 << \" \" << x + 1 << \" \" << WNES[k] << endl;\n        break;\n      }\n      ys.push_back(y), xs.push_back(x), ds.push_back(k);\n      T[y][x][k] = c;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#include <map>\n#define FI first\n#define SE second\nusing namespace std;\nconst double EPS = 1e-8;\nconst int MAXN = 105;\nconst int INF = 1111111111;\nchar g[MAXN][MAXN];\nint h,w;\nint dir[][2] = {{0,1},{1,0},{0,-1},{-1,0}};\nchar dirc[] = {'E','S','W','N'};\nlong long l;\npair<int,int> st;\nint way[MAXN][MAXN][4];\nint main() {\n   // freopen(\"F:\\\\code\\\\in.txt\",\"r\",stdin);\n\n    while (scanf (\"%d%d%lld\",&h,&w,&l)&&(h+w+l)) {\n        memset(way,0,sizeof(way));\n        for (int i = 1; i <= h; ++i) {\n            scanf (\"%s\",g[i]+1);\n            for (int j = 1; j <= w; ++j) {\n                if (g[i][j] >= 'A'&& g[i][j] <='Z') {\n                    st.first = i;\n                    st.second = j;\n                }\n            }\n            g[i][0] = g[i][w+1] = '#';\n            g[i][w+2] = '\\0';\n            //printf(\"%s\\n\",g[i]);\n        }\n        for (int i = 0; i <= w+1; ++i)\n            g[h+1][i] = g[0][i] = '#';\n        w+=2;\n        h+=2;\n        int dx,dy;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                if (g[i][j] == '#') continue;\n                for (int k = 0; k < 4; ++k) {\n\n                    dx = i + dir[k][0];\n                    dy = j + dir[k][1];\n                    int len = 0;\n                    while (dx >= 0&& dx< h &&dy >=0 &&dy < w&&g[dx][dy]!='#') {\n                        ++len;\n                        dx += dir[k][0];\n                        dy += dir[k][1];\n                    }\n                    way[i][j][k] = len;\n                }\n            }\n        }\n        int sdir;\n        int sx = st.first;\n        int sy = st.second;\n        if (g[sx][sy] == 'E') sdir = 0;\n        else if (g[sx][sy] == 'S') sdir = 1;\n        else if (g[sx][sy] == 'W') sdir = 2;\n        else if (g[sx][sy] == 'N') sdir = 3;\n        int tmp ;\n        while (l) {\n            tmp = way[sx][sy][sdir];\n            if (tmp < l) {\n                l -= tmp;\n                sx = sx + dir[sdir][0]*tmp;\n                sy = sy + dir[sdir][1]*tmp;\n                sdir = (sdir+1)%4;\n            } else {\n                sx += dir[sdir][0]*l;\n                sy += dir[sdir][1]*l;\n                if (tmp == l) sdir = (sdir+1)%4;\n                break;\n            }\n        }\n        printf(\"%d %d %c\\n\",sx,sy,dirc[sdir]);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nint W,H,L;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar DtoS[] = {'N', 'E', 'S', 'W'};\nbool visited[100][100][4];\nstring field[100];\nint table[40005];\n\npair<int, int> bfs(int sx, int sy, int sd)\n{\n    memset(visited, 0, sizeof(visited));\n    memset(table, 0, sizeof(table));\n    \n    int x = sx, y = sy, d = sd, tmp=sd;\n    int cost = 0;\n    \n    while(1) {\n\n\tif(visited[x][y][d]) break;\n\tvisited[x][y][d] = true;\n\n\tint h = d*10000 + y*100 + x;\n\t\n\ttable[h] = cost;\n\tcost++;\n\t\n\tfor(int i=0; i<4; i++) {\n\t    int td = (d + i)%4;\n\t    int tx = x + dx[td];\n\t    int ty = y + dy[td];\n\n\t    if(tx < 0 || ty < 0 || tx >= W || ty >= H) continue;\n\t    if(field[ty][tx] == '#') continue;\n\t    \n\t    d = td;\n\t    \n\t    break;\n\t}\n\n\t\n\tx += dx[d];\n\ty += dy[d];\t\n    }\n\n    \n    int ret = table[d*10000 + y*100 + x];\n\n    return make_pair(cost, ret);\n}\n\nint solve() \n{\n    pair<int, int> bfsres;\n\t\n    for(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t    for(int k=0; k<4; k++) {\n\t\tif(DtoS[k] == field[i][j])\n\t\t    bfsres = bfs(j, i, k);\n\t    }\n\n    int length = bfsres.first;\n    int bias = bfsres.second;\n    int loopL = length - bias;\n\n    if ( L < bias) return table[L];\n    int pos = (L-bias)%loopL + bias;    \n\n    int res = 0;\n    for(int i=0; i<40000; i++)\n\tif(table[i]==pos) res = i;\n\n    return res;\n}\n\nint main() \n{\n    while(cin >> H >> W >> L, (W||H||L)) {\n\tfor(int i=0; i<H; i++)\n\t    cin >> field[i];\n\n\tint res = solve();\n\tcout << ((res/100)%100 + 1) << \" \" << (res%100) + 1 << \" \" << DtoS[res/10000] << endl;\n    \n    }\n}\n\n\n\t\n\t\n\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef complex<double> P;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m;for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\nbool deq(double a,double b) {return abs(a-b)<eps;}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nll h, w, l, d[100][100][4], x, y, di, m;\nstring s[100];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> h >> w >> l;\n\t\tif (h==0) break;\n\t\trep(i,h) {\n\t\t\tcin >> s[i];\n\t\t\trep(j,w) if (s[i][j]!='.' && s[i][j]!='#') {\n\t\t\t\t\tx = i, y = j;\n\t\t\t\t\tif (s[i][j]=='E') di = 0;\n\t\t\t\t\telse if (s[i][j]=='S') di = 1;\n\t\t\t\t\telse if (s[i][j]=='W') di = 2;\n\t\t\t\t\telse di = 3;\n\t\t\t}\n\t\t}\n\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k] = linf;\n\t\td[x][y][di] = 0;\n\t\tm = 0;\n\t\twhile (1) {\n\t\t\tif (m==l) break;\n\t\t\tchmin(d[x][y][di], m);\n\t\t\tint xx = x + dx[di], yy = y + dy[di];\n\t\t\tif (ool(xx,yy,h,w) || s[xx][yy]=='#') di++, di %= 4;\n\t\t\telse {\n\t\t\t\tx = xx, y = yy;\n\t\t\t\tm++;\n\t\t\t\tchmin(d[x][y][di], m);\n\t\t\t\tif (d[x][y][di]<m) {\n\t\t\t\t\tm += (l-m)/(m-d[x][y][di])*(m-d[x][y][di]);\n\t\t\t\t\trep(i,h) rep(j,w) rep(k,4) d[i][j][k] = linf;\n\t\t\t\t\td[x][y][di] = m;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring t = \"ESWN\";\n\t\tcout << x+1 << ' ' << y+1 << ' ' << t[di] << ln << flush;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nint main() {\n    int h, w; ll l;\n    while(cin >> h >> w >> l, h){\n        vector<vector<int>> v(h+2, vector<int>(w+2, 0));\n        auto d = make_v(h+2, w+2, 4, -1);\n        int y = -1, x = -1, deg = 0;\n        string t  = \"NESW\";\n        for (int i = 0; i < h; ++i) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < w; ++j) {\n                v[i+1][j+1] = (s[j] != '#');\n                if(isalpha(s[j])){\n                    y = i, x = j;\n                    for (int k = 0; k < 4; ++k) {\n                        if(s[j] == t[k]){\n                            deg = k;\n                        }\n                    }\n                }\n            }\n        }\n        y++; x++;\n        array<int, 4> dy{-1, 0, 1, 0}, dx{0, 1, 0, -1};\n        ll turn = 0;\n        while(!(~d[y][x][deg]) && turn < l){\n            d[y][x][deg] = turn;\n            while(!v[y+dy[deg]][x+dx[deg]]) deg = (deg+1)%4;\n            y += dy[deg]; x += dx[deg];\n            turn++;\n        }\n        if(turn == l){\n            printf(\"%d %d %c\\n\", y, x, t[deg]);\n            continue;\n        }\n        l -= d[y][x][deg];\n        l %= (turn-d[y][x][deg]);\n        for (int i = 0; i < l; ++i) {\n            while(!v[y+dy[deg]][x+dx[deg]]) deg = (deg+1)%4;\n            y += dy[deg]; x += dx[deg];\n            turn++;\n        }\n        printf(\"%d %d %c\\n\", y, x, t[deg]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nchar dd[] = {'N', 'E', 'S', 'W'};\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nint main() {\n\tll H, W, L;\n\twhile(cin >> H >> W >> L, H) {\n\t\tvs field(H);\n\t\tREP(i, H) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tint cx, cy, cd;\n\t\tREP(i, H) {\n\t\t\tREP(j, W) {\n\t\t\t\tif(field[i][j] != '.' && field[i][j] != '#') {\n\t\t\t\t\tcx = j;\n\t\t\t\t\tcy = i;\n\t\t\t\t\tswitch(field[i][j]) {\n\t\t\t\t\tcase 'N':\n\t\t\t\t\t\tcd = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tcd = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tcd = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tcd = 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vvl> turn(H, vvl(W, vl(4)));\n\t\tbool looped = false;\n\t\tfor(ll t = 0; t < L; t++) {\n\t\t\tif(!looped && turn[cy][cx][cd] != 0) {\n\t\t\t\tlooped = true;\n\t\t\t\tll cycle = (t-turn[cy][cx][cd]);\n\t\t\t\tt += ((L-t)/cycle)*cycle;\n\t\t\t\tif(t == L) {\n\t\t\t\t\tt -= cycle;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint nx = cx+dx[cd];\n\t\t\tint ny = cy+dy[cd];\n\n\t\t\tif(ny<0 || H<=ny || nx<0 || W<=nx || field[ny][nx]=='#') {\n\t\t\t\tcd = (cd+1)%4;\n\t\t\t\tt--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tturn[cy][cx][cd] = t;\n\t\t\tcy = ny;\n\t\t\tcx = nx;\n\t\t}\n\n\t\tcout << cy+1 << \" \" << cx+1 << \" \" << dd[cd] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll h,w,l;\n  ll i,j,k;\n  ll dp[200][200][4]={{{}}};\n  string st[200];\n  char c[]={'E','S','W','N'};\n  ll rx,ry,rd;\n  ll ax[]={1,0,-1,0};\n  ll ay[]={0,1,0,-1};\n  bool f;\n  ll s;\n  while(cin>>h>>w>>l,h||w||l){\n    for(i=0;i<=h+1;i++) st[i]=\"\";\n    for(i=0;i<w+2;i++) st[0]+=\"#\";\n    for(i=1;i<=h;i++) {\n      cin >> st[i];\n      st[i]=\"#\"+st[i]+\"#\";\n    }\n    for(i=0;i<w+2;i++) st[h+1]+=\"#\";\n    rx=0;ry=0;rd=0;\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tfor(k=0;k<4;k++){\n\t  if(st[i][j]==c[k]){\n\t    st[i][j]='.';\n\t    ry=i;rx=j;rd=k;\n\t  }\n\t}\n      }\n    }\n    fill(dp[0][0],dp[104][104],-1);\n    f = true;\n    for(i=1;i<=l;i++){\n      while(st[ry+ay[rd]][rx+ax[rd]]=='#'){\n\trd=(rd+1)%4;\n      }\n      if(st[ry+ay[rd]][rx+ax[rd]]=='.'){\n\trx+=ax[rd];ry+=ay[rd];\n      }\n      if(dp[ry][rx][rd]==-1){\n\tdp[ry][rx][rd]=i;\n      }else if(f){\n\ts = i - dp[ry][rx][rd];\n\tl=i+(l-i)%s;\n\tf=false;\n      }\n    }\n    cout << ry << ' ' << rx << ' ' << c[rd] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint H, W; ll L;\nint dir, y, x, cost;\nstring const ds = \"WNES\";\n\nmap<tuple<int, int, int>, int> vis;\nvector<tuple<int, int, int>> data_;\nchar G[111][111];\n\nbool in_range(int y, int x, int H, int W) {\n  if(!(0<=y&&y<H&&0<=x&&x<W)) return false;\n  if(G[y][x] == '#') return false;\n  return true;\n}\n\nvoid adjust_dir() {\n  while(!in_range(y + dy[dir], x + dx[dir], H, W)) {\n    dir ++;\n    dir %= 4;\n  }\n}\n\nbool step() {\n  adjust_dir();\n  y += dy[dir], x += dx[dir];\n  cost ++;\n  if(vis.find(make_tuple(y, x, dir)) != vis.end()) {\n    int len = cost - vis[make_tuple(y, x, dir)];\n    L -= cost;\n    L %= len;\n    int y, x, d; tie(y, x, d) = data_[L];\n    cout << y+1 << \" \" << x+1 << \" \" << ds[d] << endl;\n    return false;\n  }\n  if(cost == L) {\n    cout << y+1 << \" \" << x+1 << \" \" << ds[dir] << endl;\n    return false;\n  }\n  return true;\n}\n\nvoid simulate() {\n\n  vis.clear();\n  data_.clear();\n  cost = 0;\n\n  while(step());\n}\n\nint main() {\n\n  for(; cin >> H >> W >> L && (H | W | L);) {\n    rep(i, H) rep(j, W) {\n      cin >> G[i][j];\n      if(isalpha(G[i][j])) {\n        y = i, x = j;\n        dir = ds.find(G[i][j]);\n      }\n    }\n\n    simulate();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n\nchar dir[4] = {'N', 'E', 'S', 'W'};\nint dx[4]   = {-1, 0, 1, 0};\nint dy[4]   = {0, 1, 0, -1};\n\nchar field[110][110];\nll memo[110][110][4];\n\nint main(){\n  ll H, W, L;\n  while(cin >>H >> W >> L && H + W + L){\n    \n    fill(&field[0][0], &field[0][0] + 110 * 110, '#');\n    memset(memo, -1, sizeof(memo));\n    \n    int x, y, d;\n    REP(i, H)REP(j, W){\n      cin >> field[i+1][j+1];\n      if(isalpha(field[i+1][j+1])){\n        x = i + 1;\n        y = j + 1;\n        d = find(dir, dir + 4, field[i+1][j+1]) - dir;\n      }\n    }\n\n    ll T = 0;\n    bool flag = false;\n    \n    while(L > 0){    \n      int nx = x + dx[d];\n      int ny = y + dy[d];\n      memo[x][y][d] = T++;\n      \n      while(field[nx][ny] == '#'){\n        d = (d + 1) % 4;\n        nx = x + dx[d];\n        ny = y + dy[d];\n      } \n\n      L--;\n      x = nx;\n      y = ny;\n      if(memo[x][y][d] >= 0 && !flag){\n        ll S = T - memo[x][y][d];\n        L %= S;\n        flag = true;\n      }\n    }\n    cout << x<< \" \" << y<< \" \" << dir[d] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\ntypedef long long int ll;\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint H, W;\n\t\tll L;\n\t\tchar C[100][100];\n\n\t\tcin >> H >> W >> L;\n\t\tif (H == 0) return 0;\n\n\t\tint sx, sy, sd;\n\n\t\trep(y, 0, H) rep(x, 0, W)\n\t\t{\n\t\t\tchar c; cin >> c;\n\t\t\tif (c != '.' && c != '#')\n\t\t\t{\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tswitch (c)\n\t\t\t\t{\n\t\t\t\tcase 'N': sd = 0; break;\n\t\t\t\tcase 'E': sd = 1; break;\n\t\t\t\tcase 'S': sd = 2; break;\n\t\t\t\tcase 'W': sd = 3; break;\n\t\t\t\t}\n\t\t\t\tC[y][x] = '.';\n\t\t\t}\n\t\t\telse\n\t\t\t\tC[y][x] = c;\n\t\t}\n\n\t\tll memo[100][100][4];\n\t\trep(y, 0, H) rep(x, 0, W) rep(i, 0, 4) memo[y][x][i] = -1;\n\t\tbool noloop = true;\n\n\t\tint dx[4] = { 0, 1, 0, -1 };\n\t\tint dy[4] = { -1, 0, 1, 0 };\n\n\t\tfor (ll l = 0; l < L;l++)\n\t\t{\n\t\t\trep(i, 0, 4)\n\t\t\t{\n\t\t\t\tint d = (sd + i) % 4;\n\t\t\t\tif (noloop)\n\t\t\t\t{\n\t\t\t\t\tif (memo[sy][sx][d] < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemo[sy][sx][d] = l;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tint dl = l - memo[sy][sx][d];\n\t\t\t\t\t\tl = l + ((L - 1 - l) / dl) * dl;\n\t\t\t\t\t\tnoloop = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint x = sx + dx[d];\n\t\t\t\tint y = sy + dy[d];\n\t\t\t\tif (x < 0 || W <= x) continue;\n\t\t\t\tif (y < 0 || H <= y) continue;\n\t\t\t\tif (C[y][x] == '#') continue;\n\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tsd = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << (sy + 1) << \" \" << (sx + 1) << \" \";\n\t\tswitch (sd)\n\t\t{\n\t\tcase 0: cout << \"N\"; break;\n\t\tcase 1: cout << \"E\"; break;\n\t\tcase 2: cout << \"S\"; break;\n\t\tcase 3: cout << \"W\"; break;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        int count = 0;\n        string wall = \"\";\n        bool used[101][101];\n        fill_n((bool *)used, 101*101, true);\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n                if (vs[j][i] == '.') {\n                    used[j][i] = false;\n                }\n            }\n        }\n\n        int sx, sy, sdir;\n        sx = x;\n        sy = y;\n        sdir = dir;\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n                used[y][x] = true;\n                int allused = true;\n                for (int j = 0; j < h+2; j++) {\n                    for (int i = 0; i < w+2; i++) {\n                        allused &= used[j][i];\n                    }\n                }\n                if (x == sx && y == sy && dir == sdir && allused) {\n                    l /= count;\n                }\n            }\n            else\n                dir = (dir+1) % 4;\n        }\n        cout << y << \" \" << x << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\nusing namespace std;\n\ntypedef long long LL;\n\nint h, w;\nLL L;\nint visit[102][102][4];\nint log[41000];\nchar c[102][102];\n\nint main(){\n\tconst string dirstr = \"NESW\";\n\tint dy[] = {-1, 0, 1, 0};\n\tint dx[] = {0, 1, 0, -1};\n\n\twhile(scanf(\"%d%d%lld\", &h, &w, &L), h){\n\t\tmemset(visit, -1, sizeof visit);\n\t\tmemset(c, '#', sizeof c);\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tscanf(\"%s\", c[i] + 1);\n\t\t\tc[i][w + 1] = '#';\n\t\t}\n\n\t\tint y, x, d;\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif(c[i][j] != '.' && c[i][j] != '#'){\n\t\t\t\ty = i;\n\t\t\t\tx = j;\n\t\t\t\td = dirstr.find(c[i][j]);\n\t\t\t\tc[i][j] = '.';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(LL t = 0; ;){\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tif(c[ny][nx] != '#'){\n\t\t\t\t++t;\n\t\t\t\tlog[t] = (ny << 10) | (nx << 2) | d;\n\t\t\t\ty = ny;\n\t\t\t\tx = nx;\n\n\t\t\t\tif(t == L){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tint p = visit[y][x][d];\n\t\t\t\tif(p < 0){\n\t\t\t\t\tvisit[y][x][d] = t;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tLL dif = t - p;\n\t\t\t\t\tLL rem = (L - t) % dif;\n\t\t\t\t\tint q = log[p + rem];\n\t\t\t\t\ty = q >> 10;\n\t\t\t\t\tx = (q >> 2) & 0xff;\n\t\t\t\t\td = q & 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\td = (d + 1) & 3;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d %c\\n\", y, x, dirstr[d]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};\n\nint H, W, L;\nvector<string> maze;\nvector<vector<vector<int> > > vis;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\ntuple<int, int, char> solve(){\n    vis.assign(H, vector<vector<int> >(W, vector<int>(4, -1)));\n    int x = 0, y = 0, d = 0;\n    rep(i, H)rep(j, W)rep(k, 4)if(maze[i][j] == \"NESW\"[k]){\n        x = i; y = j; d = k;\n        break;\n    }\n    int p = L;\n    for(int step=0; step<=L;){\n        if(vis[x][y][d] != -1){\n            p = vis[x][y][d] + (L - step) % (step - vis[x][y][d]);\n            break;\n        }\n        vis[x][y][d] = step;\n        int nx = x + dx[d], ny = y + dy[d];\n        if(!inrect(nx, ny) || maze[nx][ny] == '#')(d += 1) %= 4;\n        else x = nx, y = ny, step++;\n    }\n    // rep(i, H){rep(k, 4){rep(j, W)cout << vis[i][j][k] << ' '; cout << \" |  \";} cout << '\\n';}\n    // FIX LINE (this can't be accepted)\n    rep(i, H)rep(j, W)rep(k, 4)if(vis[i][j][k] == p)return make_tuple(i+1, j+1, \"NESW\"[k]);\n    return make_tuple(-1, -1, '?');\n}\n\nint main(){\n    while(cin >> H >> W >> L, H|W|L){\n        maze.assign(H, \"\");\n        rep(i, H)cin >> maze[i];\n        int x, y; char d;\n        tie(x, y, d) = solve();\n        cout << x << ' ' << y << ' ' << d << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef long long lint;\n\nint H, W, dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\nlint L;\nstring grid[110], dir = \"NESW\";\n\nint visit[110][110][4], seq[41000];\n\nbool able(int x, int y) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return false;\n\treturn grid[y][x] == '.';\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\twhile (cin >> H >> W >> L, H) {\n\t\tint x = 0, y = 0, d = 0;\n\t\t\n\t\tfor_(i,0,H) {\n\t\t\tcin >> grid[i];\n\t\t\tfor_(j,0,W) if (grid[i][j] != '.' && grid[i][j] != '#') {\n\t\t\t\tx = j; y = i;\n\t\t\t\td = dir.find(grid[i][j]);\n\t\t\t\tgrid[i][j] = '.';\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(visit, -1, sizeof(visit));\n\t\t\n\t\tlint s = 0;\n\t\twhile (visit[y][x][d] < 0) {\n\t\t\tvisit[y][x][d] = s;\n\t\t\tseq[s] = (y << 10) | (x << 2) | d;\n\t\t\twhile (!able(x + dx[d], y + dy[d])) d = (d + 1) % 4;\n\t\t\tx += dx[d]; y += dy[d];\n\t\t\t++s;\n\t\t}\n\t\t\n\t\tint t = visit[y][x][d], id = L;\n\t\tif (s < L) id = t + (L - t) % (s - t);\n\t\t\n\t\ty = seq[id] >> 10;\n\t\tx = (seq[id] >> 2) & 0xff;\n\t\td = seq[id] & 3;\n\t\tcout << y + 1 << \" \" << x + 1 << \" \" << dir[d] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint H, W, L;\n\t\tchar C[100][100];\n\n\t\tcin >> H >> W >> L;\n\t\tif (H == 0) return 0;\n\n\t\tint sx, sy, sd;\n\n\t\trep(y, 0, H) rep(x, 0, W)\n\t\t{\n\t\t\tchar c; cin >> c;\n\t\t\tif (c != '.' && c != '#')\n\t\t\t{\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tswitch (c)\n\t\t\t\t{\n\t\t\t\tcase 'N': sd = 0; break;\n\t\t\t\tcase 'E': sd = 1; break;\n\t\t\t\tcase 'S': sd = 2; break;\n\t\t\t\tcase 'W': sd = 3; break;\n\t\t\t\t}\n\t\t\t\tC[y][x] = '.';\n\t\t\t}\n\t\t\telse\n\t\t\t\tC[y][x] = c;\n\t\t}\n\n\t\tint memo[100][100][4];\n\t\trep(y, 0, H) rep(x, 0, W) rep(i, 0, 4) memo[y][x][i] = -1;\n\t\tbool noloop = true;\n\n\t\tint dx[4] = { 0, 1, 0, -1 };\n\t\tint dy[4] = { -1, 0, 1, 0 };\n\n\t\trep(l, 0, L)\n\t\t{\n\t\t\tif (noloop)\n\t\t\t{\n\t\t\t\tif (memo[sy][sx][sd] < 0)\n\t\t\t\t{\n\t\t\t\t\tmemo[sy][sx][sd] = l;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint dl = l - memo[sy][sx][sd];\n\t\t\t\t\tl = l + ((L - 1 - l) / dl) * dl;\n\t\t\t\t\tnoloop = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(i, 0, 4)\n\t\t\t{\n\t\t\t\tint d = (sd + i) % 4;\n\t\t\t\tint x = sx + dx[d];\n\t\t\t\tint y = sy + dy[d];\n\t\t\t\tif (x < 0 || W <= x) continue;\n\t\t\t\tif (y < 0 || H <= y) continue;\n\t\t\t\tif (C[y][x] == '#') continue;\n\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tsd = d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << (sy + 1) << \" \" << (sx + 1) << \" \";\n\t\tswitch (sd)\n\t\t{\n\t\tcase 0: cout << \"N\"; break;\n\t\tcase 1: cout << \"E\"; break;\n\t\tcase 2: cout << \"S\"; break;\n\t\tcase 3: cout << \"W\"; break;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\nstruct node{\n\tint y,x,dir;\n\tll cost;\n\tnode(int y,int x,int dir,ll cost):y(y),x(x),cost(cost),dir(dir){}\n};\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nchar dirs[]={'W','N','E','S'};\nconst ll MAX=LONG_MAX;\nint main(){\n\tint h,w;\n\tll l;\n\twhile(cin>>h>>w>>l,h|w|l){\n\t\tvs c(h);\n\t\tpii start;\n\t\tint initdir;\n\t\tREP(i,h){\n\t\t\tcin>>c[i];\n\t\t\tREP(j,w){\n\t\t\t\tswitch(c[i][j]){\n\t\t\t\tcase 'W':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tstart=make_pair(i,j);\n\t\t\t\t\tinitdir=3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvvvl cost(h,vvl(w,vl(4,MAX)));\n\t\tqueue<node> q;\n\t\tcost[start.first][start.second][initdir]=l;\n\t\tq.push(node(start.first,start.second,initdir,l));\n\t\twhile(!q.empty()){\n\t\t\tnode cnode=q.front();q.pop();\n\t\t\tif(cnode.cost==0){\n\t\t\t\tcout<<cnode.y+1<<\" \"<<cnode.x+1<<\" \"<<dirs[cnode.dir]<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint d=cnode.dir;\n\t\t\tint y=cnode.y+dy[d];\n\t\t\tint x=cnode.x+dx[d];\n\t\t\twhile(!(y>=0&&x>=0&&y<h&&x<w&&c[y][x]!='#')){\n\t\t\t\td=(d+1)%4;\n\t\t\t\ty=cnode.y+dy[d];\n\t\t\t\tx=cnode.x+dx[d];\n\t\t\t}\n\t\t\tif(cost[y][x][d]!=MAX){\n\t\t\t\tll diff=cost[y][x][d]-(cnode.cost-1);\n\t\t\t\tcost[y][x][d]=(cnode.cost-1)%diff;\n\t\t\t\tq.push(node(y,x,d,(cnode.cost-1)%diff));\n\t\t\t}else{\n\t\t\t\tcost[y][x][d]=cnode.cost-1;\n\t\t\t\tq.push(node(y,x,d,cnode.cost-1));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef long long int Int;\ntypedef pair<Int, Int> P;\ntypedef pair<P, Int> PP;\n\n\nInt H, W, L;\nint my[] = {-1, 0, 1, 0};\nint mx[] = {0, 1, 0, -1};\n\nvoid turn(PP &now, vector< vector<bool> > &v){\n  Int y = now.first.first, x = now.first.second, d = now.second;\n  while(!(y + my[d] >= 0 && x + mx[d] >= 0 && y + my[d] < H && x + mx[d] < W && v[y + my[d]][x + mx[d]] == 0)) d = (d + 1) % 4;\n  now.second = d;\n}\n\nPP solve(vector< vector<bool> > &G, PP &now, Int &L){\n  vector<PP> v;\n  map<PP, Int> M;\n  Int cnt = 0;\n  turn(now, G);\n  while(L-- > 0){\n    turn(now, G);\n    Int &y = now.first.first, &x = now.first.second, &d = now.second;\n    y = (y + my[d]); x = (x + mx[d]);\n    if(L <= 0) return now;\n    else if(M.find(now) != M.end()) break;\n    v.push_back(now);\n    M[now] = cnt++;\n  }\n  Int t = L % ((int)v.size() - M[now]);\n  return v[t + M[now]];\n}\n\n\nint main() {\n  map<char, Int> D;\n  D['N'] = 0; D['E'] = 1; D['S'] = 2; D['W'] = 3;\n  string RD = \"NESW\";\n  while(cin >>H >>W >>L && (H || W || L)){\n    vector< vector<bool> > v(H, vector<bool>(W));\n    PP now;\n    REP(i, H){\n      REP(j, W){\n        char c; cin >>c;\n        if(c == '.') v[i][j] = 0;\n        else if(c == '#') v[i][j] = 1;\n        else{\n          v[i][j] = 0;\n          now.first.second = j; now.first.first = i;\n          now.second = D[c];\n        }\n      }\n    }\n    PP ans = solve(v, now, L);\n    cout <<ans.first.first + 1 <<\" \" <<ans.first.second + 1 <<\" \" <<RD[ans.second] <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> H >> W >> K, H) {\n\t\tvector<string>s(H);\n\t\tfor (auto &i : s)cin >> i;\n\t\tint sy, sx;\n\t\tint d;\n\t\tint dir[] = { -1,0,1,0,-1 };\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == 'N') {\n\t\t\t\t\td = 0;\n\t\t\t\t\tsy = i, sx = j;\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'E') {\n\t\t\t\t\td = 1;\n\t\t\t\t\tsy = i, sx = j;\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'S') {\n\t\t\t\t\td = 2;\n\t\t\t\t\tsy = i, sx = j;\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'W') {\n\t\t\t\t\td = 3;\n\t\t\t\t\tsy = i, sx = j;\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<vector<long long int>>>turn(H, vector<vector<long long int>>(W, vector<long long int>(4, MOD*MOD)));\n\t\tint loop = MOD;\n\t\tturn[sy][sx][d] = 0;\n\t\tint cnt = 1;\n\t\twhile (cnt<=K) {\n\t\t\tbool con = true;\n\t\t\twhile (con) {\n\t\t\t\tint ny = sy + dir[d];\n\t\t\t\tint nx = sx + dir[d + 1];\n\t\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W || s[ny][nx] == '#') {\n\t\t\t\t\td++;\n\t\t\t\t\td %= 4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcon = false;\n\t\t\t}\n\t\t\tsy += dir[d];\n\t\t\tsx += dir[d + 1];\n\t\t\tif (turn[sy][sx][d] == MOD * MOD) {\n\t\t\t\tturn[sy][sx][d] = cnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tloop = cnt - turn[sy][sx][d];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring ans = \"NESW\";\n\t\tint a, b;\n\t\tchar c;\n\t\tint box = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tif (turn[i][j][k]!=MOD*MOD&&(K - turn[i][j][k]) % loop == 0&&box<=turn[i][j][k]) {\n\t\t\t\t\t\ta = i + 1, b = j + 1, c = ans[k];\n\t\t\t\t\t\tbox = turn[i][j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << a << \" \" << b << \" \" << c << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#define llint long long\n#define eps 1e-9\n\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<P, llint> S;\n\nllint h, w, l;\nchar c[105][105];\nstring s = \"NESW\";\nS succ[60][105][105][4];\nllint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0};\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> h >> w >> l;\n\t\tif(h == 0 && w == 0) break;\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tcin >> c[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tS p;\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tif(c[x][y] == '.' || c[x][y] == '#') continue;\n\t\t\t\tp.first.first = x, p.first.second = y;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tif(s[i] == c[x][y]) p.second = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\t\tllint nd = (d+i)%4, nx = x + dx[nd], ny = y + dy[nd];\n\t\t\t\t\t\tif(nx <= 0 || nx > w || ny <= 0 || ny > h) continue;\n\t\t\t\t\t\tif(c[nx][ny] == '#') continue;\n\t\t\t\t\t\tsucc[0][x][y][d] = S(P(nx, ny), nd);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < 60; i++){\n\t\t\tfor(int y = 1; y <= h; y++){\n\t\t\t\tfor(int x = 1; x <= w; x++){\n\t\t\t\t\tfor(int d = 0; d < 4; d++){\n\t\t\t\t\t\tllint mx = succ[i-1][x][y][d].first.first, my = succ[i-1][x][y][d].first.second, md = succ[i-1][x][y][d].second;\n\t\t\t\t\t\tsucc[i][x][y][d] = succ[i-1][mx][my][md];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 59; i >= 0; i--){\n\t\t\tif(l & (1LL<<i)){\n\t\t\t\tp = succ[i][p.first.first][p.first.second][p.second];\n\t\t\t}\n\t\t}\n\t\tcout << p.first.second << \" \" << p.first.first << \" \" << s[p.second] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {1,0,-1,0};\nconst static int ty[] = {0,1,0,-1};\nconst static char dir_char[] = {'E','S','W','N'};\n \nenum dir {\n  EAST,\n  SOUTH,\n  WEST,\n  NORTH\n};\n\nstruct PosInfo{\n  int x;\n  int y;\n  int dir;\n  PosInfo(int _x,int _y,int _dir) : x(_x),y(_y),dir(_dir) {}\n};\n\nstatic const double EPS = 1e-8;\n\n\nvoid printStage(char stage[100][100],int H,int W,\n\t\tint current_x,int current_y,int current_dir){\n\n  char output[100][100];\n\n  //init\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      output[y][x] = '.';\n    }\n  }\n\n  //wall\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      if(stage[y][x] == '#'){\n\toutput[y][x] = '#';\n      }\n    }\n  }\n\n  //robot\n  output[current_y][current_x] = dir_char[current_dir];\n\n  //write\n  for(int y=0;y<H;y++){\n    for(int x=0;x<W;x++){\n      printf(\"%c\",output[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\nint main(){\n  int H,W;\n  ll L;\n  while(~scanf(\"%d %d %ld\",&H,&W,&L)){\n    if(H == 0 && W == 0 && L == 0) break;\n\n    char stage[100][100];\n\n    int current_dir = NORTH;\n    int current_x = 0;\n    int current_y = 0;\n\n    for(int y=0;y<H;y++){\n      char line[120];\n      scanf(\"%s\",line);\n      for(int x=0;x<W;x++){\n\tstage[y][x] = line[x];\n\tif(stage[y][x] == 'E'){\n\t  current_dir = EAST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'S'){\n\t  current_dir = SOUTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'W'){\n\t  current_dir = WEST;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n\telse if(stage[y][x] == 'N'){\n\t  current_dir = NORTH;\n\t  current_x = x;\n\t  current_y = y;\n\t}\n      }\n    }\n\n    int dp[4][100][100];\n    for(int i=0;i<4;i++){\n      memset(dp[i],-1,sizeof(dp[i]));\n    }\n\n    ll round = 0;\n    for(;round < L;round++){\n      if(dp[current_dir][current_x][current_y] >= 0) break;\n      \n      dp[current_dir][current_x][current_y]=round;\n      // printStage(stage,H,W,current_x,current_y,current_dir);\n      // cout << dx << \" \" << dy << \" \" << endl;\n\n      for(int i=0;i<4;i++){\n\t//i==0 : not rotating\n\tint next_dir = (current_dir + i) % 4;\n\tint dx = current_x + tx[next_dir];\n\tint dy = current_y + ty[next_dir];\n\n\tif(dy < 0 || dy >= H || dx < 0 || dx >= W){\n\t  continue;\n\t}\n\telse if(stage[dy][dx] == '#'){\n\t  continue;\n\t}\n\n\tcurrent_dir = next_dir;\n\tcurrent_x = dx;\n\tcurrent_y = dy;\n\tbreak;\n      }\n    }\n\n    int res_x = current_x;\n    int res_y = current_y;\n    int res_dir = current_dir;\n\n    //start:0 3 6 9 ... start:96\n    ll last_round = round;\n    ll cycle_begining_round = dp[current_dir][current_x][current_y];\n\n    if(last_round < L){\n      ll cycle_length = last_round - cycle_begining_round;\n      ll cycle_relative_pos = (L - cycle_begining_round) % cycle_length;\n      ll cycle_abs_pos = cycle_relative_pos + cycle_begining_round;\n\n      for(int i=0;i<4;i++){\n\tfor(int x=0;x<W;x++){\n\t  for(int y=0;y<H;y++){\n\t    printf(\"i:%d x:%d y:%d %d\\n\",i,x,y,dp[i][x][y]);\n\t    if(dp[i][x][y] == cycle_abs_pos){\n\t      res_x = x;\n\t      res_y = y;\n\t      res_dir = i;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    printf(\"%d %d %c\\n\",res_y+1,res_x+1,dir_char[res_dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint H,W,L;\nstring maze[110];\nstruct State {\n    int dir,y,x,cnt;\n    State(int dir,int y,int x,int cnt) :\n        dir(dir),y(y),x(x),cnt(cnt){}\n};\n\nvoid solve(P &ans_p,int &ans_dir) {\n    queue<State> que;\n    map<char,int> dir;\n    dir['E']=0;\n    dir['S']=1;\n    dir['W']=2;\n    dir['N']=3;\n    int d[4][110][110];\n    rep(y,110) rep(x,110) d[0][y][x]=d[1][y][x]=d[2][y][x]=d[3][y][x]=INF;\n    rep(y,H) rep(x,W) if(maze[y][x]!='.'&&maze[y][x]!='#') {\n        d[dir[maze[y][x]]][y][x]=0;\n        que.push(State(dir[maze[y][x]],y,x,0));\n    }\n\n    while(que.size()) {\n        State s=que.front(); que.pop();\n        //printf(\"%d %d %d : %d\\n\",s.dir,s.y,s.x,s.cnt);\n        if(L==s.cnt) {\n            ans_p=P(s.y,s.x);\n            ans_dir=s.dir;\n            return;\n        }\n        if(d[s.dir][s.y][s.x]!=s.cnt) {\n            int diff=s.cnt-d[s.dir][s.y][s.x];\n            s.cnt+=L/diff*diff;\n        }\n        int ny=s.y+dy[s.dir];\n        int nx=s.x+dx[s.dir];\n        if(!(0<=ny&&ny<H&&0<=nx&&nx<W)) {\n            que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n            d[(s.dir+1)%4][s.y][s.x]=s.cnt;\n        }\n        else {\n            if(maze[ny][nx]=='#') {\n                que.push(State((s.dir+1)%4,s.y,s.x,s.cnt));\n                d[(s.dir+1)%4][s.y][s.x]=s.cnt;\n            }\n            else {\n                que.push(State(s.dir,ny,nx,s.cnt+1));\n                d[s.dir][ny][nx]=s.cnt+1;\n            }\n        }\n    }\n}\n\nint main() {\n    while(cin>>H>>W>>L) {\n        if(H==0) break;\n        rep(y,H) cin>>maze[y];\n        P ans;\n        int dir;\n        solve(ans,dir);\n        char d;\n        if(dir==0) d='E';\n        if(dir==1) d='S';\n        if(dir==2) d='W';\n        if(dir==3) d='N';\n        printf(\"%d %d %c\\n\",ans.fr+1,ans.sc+1,d);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n\nint32_t main() {\n    while (true) {\n        int n,m,L; cin >> n >> m >> L;\n        if (n == 0 && m == 0 && L == 0) break;\n        vector<string> s(n); cin >> s;\n        auto valid = [&](int i, int j) {\n            return (0 <= i && i < n &&\n                    0 <= j && j < m &&\n                    s[i][j] != '#');\n        };\n\n        struct state { int dir,x,y; };\n\n        state st = {-1,-1,-1};\n        rep (i,n) rep (j,m) {\n            char c = s[i][j];\n            if (c == '.' || c == '#') continue;\n            if (c == 'S') st = {0,i,j};\n            if (c == 'E') st = {1,i,j};\n            if (c == 'N') st = {2,i,j};\n            if (c == 'W') st = {3,i,j};\n        }\n\n        const int LG = 62;\n        auto dp = make_v<state,4>(LG,4,n,m);\n        rep (dir,4) rep (i,n) rep (j,m) {\n            dp[0][dir][i][j] = {dir,i,j};\n            if (not valid(i,j)) continue;\n            rep (k,4) {\n                int ndir = (dir-k+4)%4;\n                int ni = i+dx[ndir], nj = j+dy[ndir];\n                if (valid(ni,nj)) {\n                    dp[0][dir][i][j] = {ndir,ni,nj};\n                    break;\n                }\n            }\n        }\n\n        rep (k,LG-1) rep (dir,4) rep (i,n) rep (j,m) {\n            auto nxt = dp[k][dir][i][j];\n            dp[k+1][dir][i][j] = dp[k][nxt.dir][nxt.x][nxt.y];\n        }\n\n        rep (k,LG) if (L>>k&1) st = dp[k][st.dir][st.x][st.y];\n\n        cout << st.x+1 << \" \" << st.y+1 << \" \";\n        if (st.dir == 0) cout << 'S';\n        if (st.dir == 1) cout << 'E';\n        if (st.dir == 2) cout << 'N';\n        if (st.dir == 3) cout << 'W';\n        cout << \"\\n\";\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst string hougaku = \"ESWN\";\n\nconst int MAXH = 128;\nint H, W;\nll L;\nstring field[MAXH];\nint num[4][MAXH][MAXH];\n\nint main(void) {\n    while (cin >> H >> W >> L) {\n        if (H == 0 && W == 0 && L == 0) break;\n        int y = 0, x = 0, dir = 0;\n        for (int i = 0; i < H; i++) {\n            cin >> field[i];\n            for (int j = 0; j < W; j++) {\n                if (field[i][j] != '#' && field[i][j] != '.') {\n                    y = i; x = j;\n                    switch (field[i][j]) {\n                        case 'E':\n                            dir = 0;\n                            break;\n                        case 'S':\n                            dir = 1;\n                            break;\n                        case 'W':\n                            dir = 2;\n                            break;\n                        case 'N':\n                            dir = 3;\n                            break;\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                for (int k = 0; k < 4; k++) {\n                    num[k][i][j] = INF;\n                }\n            }\n        }\n        int cycle = 0, first = 0;\n        num[dir][y][x] = 0;\n        while (1) {\n            //cout << dir << \"  \" << y << \"  \" << x << endl;\n            int ny = y+dy[dir];\n            int nx = x+dx[dir];\n            if (ny < 0 || ny >= H || nx < 0 || nx >= W || field[ny][nx] == '#') {\n                int ndir = (dir + 1) % 4;\n                if (num[ndir][y][x] != INF) {\n                    cycle = num[dir][y][x] - num[ndir][y][x];\n                    first = num[ndir][y][x];\n                    num[ndir][y][x] = num[dir][y][x];\n                    break;\n                }\n                num[ndir][y][x] = num[dir][y][x];\n                dir = ndir;\n                continue;\n            }\n            if (num[dir][ny][nx] == INF) {\n                num[dir][ny][nx] = num[dir][y][x] + 1;\n                y = ny; x = nx;\n            } else {\n                cycle = num[dir][y][x] + 1 - num[dir][ny][nx];\n                first = num[dir][ny][nx];\n                num[dir][ny][nx] = num[dir][y][x] + 1;\n                break;\n            }\n        }\n        //cout << cycle << endl;\n        //cout << first << endl;\n        // ループがどうとか考えなくて良い場合\n        if (first+cycle > L) {\n            // LとL-1を探す\n            int yl, xl, yll, xll;\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < H; j++) {\n                    for (int l = 0; l < W; l++) {\n                        if (num[i][j][l] == L) {\n                            yl = j;\n                            xl = l;\n                        } else if (num[i][j][l] == L-1) {\n                            yll = j;\n                            xll = l;\n                        }\n                    }\n                }\n            }\n            //cout << yl << xl << yll << xll << endl;\n            int dd;\n            for (dd = 0; dd < 4; dd++) {\n                if (yll + dy[dd] == yl && xll + dx[dd] == xl) break;\n            }\n            cout << yl+1 << \" \" << xl+1 << \" \" << hougaku[dd] << endl;\n        } else {\n            L -= first;\n            L %= cycle;\n            int target = first + L;\n            int before = target - 1;\n            //cout << \"target is \" << target << endl;\n            if (before < 0) before = first + cycle - 1;\n            // LとL-1を探す\n            int yl, xl, yll, xll;\n            for (int i = 0; i < 4; i++) {\n                for (int j = 0; j < H; j++) {\n                    for (int l = 0; l < W; l++) {\n                        if (num[i][j][l] == target) {\n                            yl = j;\n                            xl = l;\n                        } else if (num[i][j][l] == before) {\n                            yll = j;\n                            xll = l;\n                        }\n                    }\n                }\n            }\n            //cout << yl << xl << yll << xll << endl;\n            int dd;\n            for (dd = 0; dd < 4; dd++) {\n                if (yll + dy[dd] == yl && xll + dx[dd] == xl) break;\n            }\n            //cout << dd << endl;\n            cout << yl+1 << \" \" << xl+1 << \" \" << hougaku[dd] << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<cstdlib>\n#include<cmath>\n#define INF 0x3f3f3f3f\n#define MAXN 40010\n#define MAXM 110\n#define MOD 1000000007\n#define MAXNODE 4*MAXN\n#define eps 1e-9\nusing namespace std;\nint T,x,y,dir,pre,xunhuan,K,H,W,d[MAXM][MAXM][4];\nchar a[MAXM][MAXM];\nlong long L;\nstruct path{\n    int x,y,dir;\n}p[MAXN];\nint main(){\n    while(scanf(\"%d%d%lld\",&H,&W,&L),H||W||L){\n        K=0;\n        for(int i=0;i<H;i++){\n            scanf(\"%s\",a[i]);\n            for(int j=0;j<W;j++) if(a[i][j]!='.'&&a[i][j]!='#'){\n                x=i;\n                y=j;\n                if(a[i][j]=='N') dir=1;\n                if(a[i][j]=='E') dir=2;\n                if(a[i][j]=='S') dir=3;\n                if(a[i][j]=='W') dir=4;\n                break;\n            }\n        }\n        memset(d,-1,sizeof(d));\n        d[x][y][dir]=0;\n        p[K].x=x;\n        p[K].y=y;\n        p[K++].dir=dir;\n        int flag=0;\n        while(1){//printf(\"%d %d %d %d\\n\",x,y,dir,d[x][y][dir]);\n            if(d[x][y][dir]==L){\n                flag=1;\n                printf(\"%d %d \",x+1,y+1);\n                if(dir==1) printf(\"N\\n\");\n                if(dir==2) printf(\"E\\n\");\n                if(dir==3) printf(\"S\\n\");\n                if(dir==4) printf(\"W\\n\");\n                break;\n            }\n            if(dir==1){\n                if(x-1>=0&&a[x-1][y]!='#'){\n                    if(d[x-1][y][dir]==-1){\n                        d[x-1][y][dir]=d[x][y][dir]+1;\n                        x--;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x-1][y][dir]-1;\n                        xunhuan=d[x][y][dir]-d[x-1][y][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    dir=2;\n                    d[x][y][2]=d[x][y][1];\n                }\n            }\n            else if(dir==2){\n                if(y+1<W&&a[x][y+1]!='#'){\n                    if(d[x][y+1][dir]==-1){\n                        d[x][y+1][dir]=d[x][y][dir]+1;//printf(\"aaa%d %d %d %d\\n\",x,y+1,dir,d[x][y+1][dir]);\n                        y++;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x][y+1][dir]-1;\n                        xunhuan=d[x][y][dir]-d[x][y+1][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    dir=3;\n                    d[x][y][3]=d[x][y][2];\n                }\n            }\n            else if(dir==3){\n                if(x+1<H&&a[x+1][y]!='#'){\n                    if(d[x+1][y][dir]==-1){\n                        d[x+1][y][dir]=d[x][y][dir]+1;\n                        x++;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x+1][y][dir]-1;\n                        xunhuan=d[x][y][dir]-d[x+1][y][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    dir=4;\n                    d[x][y][4]=d[x][y][3];\n                }\n            }\n            else if(dir==4){\n                if(y-1>=0&&a[x][y-1]!='#'){\n                    if(d[x][y-1][dir]==-1){\n                        d[x][y-1][dir]=d[x][y][dir]+1;\n                        y--;\n                        p[K].x=x;\n                        p[K].y=y;\n                        p[K++].dir=dir;\n                    }\n                    else{\n                        pre=d[x][y-1][dir]-1;\n                        xunhuan=d[x][y][dir]-d[x][y-1][dir]+1;\n                        break;\n                    }\n                }\n                else{\n                    dir=1;\n                    d[x][y][1]=d[x][y][4];\n                }\n            }\n        }\n        //for(int i=0;i<18;i++) printf(\"i=%d %d %d %d\\n\",i,p[i].x,p[i].y,p[i].dir);\n        if(!flag){//printf(\"%d %d\\n\",pre,xunhuan);\n            L=(L-pre)%xunhuan;//cout<<pre<<\" \"<<xunhuan<<endl;\n            int n=pre+L;//cout<<n<<endl;\n            printf(\"%d %d \",p[n].x+1,p[n].y+1);\n            if(p[n].dir==1) printf(\"N\\n\");\n            if(p[n].dir==2) printf(\"E\\n\");\n            if(p[n].dir==3) printf(\"S\\n\");\n            if(p[n].dir==4) printf(\"W\\n\");\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define Y first.first\n#define X first.second\n#define D second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst string kDir = \"ESWN\";\nconst vi dx = { 1, 0,-1, 0};\nconst vi dy = { 0, 1, 0,-1};\n\ntypedef pair<pii, int> State;\n\nint main(void){\n    ll L;\n    for(int h, w; cin >> h >> w >> L, h;){\n        vs field(h + 2);\n        rep(x, w + 2) field[0].pb('#'), field[h + 1].pb('#');\n\n        State cur;\n        \n        range(y, 1, h + 1){\n            string f; cin >> f;\n\n            field[y].pb('#');\n            field[y] += f;\n            field[y].pb('#');\n\n            range(x, 1, w + 1){\n                if(field[y][x] != '.' && field[y][x] != '#'){\n                    int d = kDir.find(field[y][x]);\n                    cur = mp(mp(y, x), d);\n\n                    field[y][x] = '.';\n                }\n            }\n        }\n\n        map<State, int> step;\n        int cnt_step = 0;\n\n        while(step.find(cur) == step.end()){\n            step[cur] = cnt_step;\n            pii next_pos = mp(cur.Y + dy[cur.D], cur.X + dx[cur.D]);\n\n            if(field[next_pos.first][next_pos.second] == '#'){\n               (cur.D += 1) %= kDir.size();\n            }\n            else{\n                cur.first = next_pos;\n                cnt_step++;\n\n                if(cnt_step == L) break;\n            }\n        }\n\n        cnt_step -= step[cur];\n        L -= step[cur];\n        if(L >= 0) L %= cnt_step;\n\n        while(0 < L){\n            pii next_pos = mp(cur.Y + dy[cur.D], cur.X + dx[cur.D]);\n\n            if(field[next_pos.first][next_pos.second] == '#'){\n               (++cur.D) %= kDir.size();\n            }\n            else{\n                cur.first = next_pos;\n                L--;\n            }\n        }\n\n        cout << cur.Y << \" \" << cur.X << \" \" << kDir[cur.D] << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 105\n#define PI acos(-1.0)\n#define MOD 1000000007\n#define REP(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,t) for(int i=s; i<=t; i++)\n#define mem(a,b)  memset(a,b,sizeof(a))\n#define show(x) { cerr<<\">>>\"<<#x<<\" = \"<<x<<endl; }\n#define show2(x,y) { cerr<<\">>>\"<<#x<<\"=\"<<x<<\"  \"<<#y<<\" = \"<<y<<endl; }\nusing namespace std;\n\nint ansx,ansy,ansdir;\nint vis[MAXN][MAXN][4];\nint H,W,L;\nbool G[MAXN][MAXN];\n\nint dx[4] = {0, -1, 0, 1};\nint dy[4] = {-1, 0, 1, 0};\n\nbool out(int x,int y)\n{\n    if(x < 0 && x >= H) return true;\n    if(y < 0 && y >= W) return true;\n    return false;\n}\n\nvoid dfs(int x,int y,int dir,int d)\n{ //show2(x, y); show2(dir,d); printf(\"\\n\");\n    if(L == d)\n    {\n        ansx = x, ansy = y, ansdir = dir; // cout<<ansdir<<endl;\n        return;\n    }\n    for(int i=0; i<4; i++)\n    {\n        int xx = x + dx[dir];\n        int yy = y + dy[dir];\n\n        if(out(xx,yy) || !G[xx][yy])\n        {\n            dir = (dir+1)%4;\n            continue;\n        }\n        else\n        {\n            x = xx, y = yy; d++;\n            break;\n        }\n    }\n    if(vis[x][y][dir])\n    {\n        int diff = d - vis[x][y][dir];\n        L = ( L-d ) % diff + 1;\n        mem(vis,0);\n        d = 1;\n        dfs(x, y, dir, d);\n    }\n    else\n    {\n        vis[x][y][dir] = d;\n        dfs(x, y, dir, d);\n    }\n\n}\n\nint mymap[100];\n\nint main()\n{\n    //freopen(\"E:\\\\acm\\\\input.txt\",\"r\",stdin);\n    //freopen(\"E:\\\\acm\\\\output.txt\",\"w\",stdout);\n    mymap['W'] = 0; mymap['N'] = 1;\n    mymap['E'] = 2; mymap['S'] = 3;\n    mymap['.'] = 4;\n    while(cin>>H>>W>>L)\n    {\n        if(H == 0 && W == 0 && L == 0) break;\n        mem(G, 0);\n        int sx, sy, dir;\n        REP(i, H)\n        {\n            char str[MAXN]; scanf(\"%s\", str);\n            REP(j, W)\n            {\n                if(str[j] != '#')\n                {\n                    G[i][j] = 1;\n                    if(mymap[str[j]] != 4)\n                    {\n                        sx = i; sy = j;\n                        dir = mymap[str[j]];\n                    }\n                }\n            }\n        } //show2(sx, sy); show(dir);\n        mem(vis, 0); L ++;\n        dfs(sx, sy, dir, 1);\n\n        char ch;\n        switch(ansdir)\n        {\n            case 0: ch = 'W'; break;\n            case 1: ch = 'N'; break;\n            case 2: ch = 'E'; break;\n            case 3: ch = 'S'; break;\n        }\n        cout<<ansx+1<<\" \"<<ansy+1<<\" \"<<ch<<endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nvoid solve() {\n\twhile (true) {\n\t\tint h, w, l;\n\t\tcin >> h >> w >> l;\n\t\tif (h == 0) return;\n\t\tmap<tuple<int, int, int>, int> loops;\n\t\tvector<string> inputs;\n\t\tREP(i, h) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tinputs.push_back(s);\n\t\t}\n\t\ttuple<int, int, int> now;\n\t\tstring s = \"NESW\";\n\t\tint dx[4] = { -1,0,1 ,0 };\n\t\tint dy[4] = { 0,1,0,-1 };\n\t\tREP(i,h) {\n\t\t\tREP(q, w) {\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tif (s[j] == inputs[i][q]) {\n\t\t\t\t\t\tnow = make_tuple(i, q, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\twhile (cnt != l) {\n\t\t\tif (loops.find(now) != loops.end()) {\n\t\t\t\tint hoge = (l - cnt - 1) / (cnt - loops[now]);\n\t\t\t\tif(hoge > 0)\n\t\t\t\tcnt += hoge * (cnt - loops[now]);\n\t\t\t}\n\t\t\tloops[now] = cnt;\n\t\t\twhile (true) {\n\t\t\t\tint x = get<0>(now) + dx[get<2>(now)];\n\t\t\t\tint y = get<1>(now) + dy[get<2>(now)];\n\t\t\t\tif (x >= 0 && x < h && y >= 0 && y < w) {\n\t\t\t\t\tif (inputs[x][y] != '#') {\n\t\t\t\t\t\tget<0>(now) = x;\n\t\t\t\t\t\tget<1>(now) = y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tget<2>(now)++;\n\t\t\t\tget<2>(now) %= 4;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\tcout << get<0>(now) + 1 << \" \" << get<1>(now) + 1 << \" \" << s[get<2>(now)] << endl;\n\t}\n}\n#undef int\n\nint main() {\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//11\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(long long h,w,l;cin>>h>>w>>l,h|w|l;){\n    bool s[102][102]={};\n    int x,y,d;\n    string ds=\"NESW\";\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tchar c;\n\tcin>>c;\n\ts[i][j]=c!='#';\n\tif(c!='#'&&c!='.'){\n\t  x=j;\n\t  y=i;\n\t  d=ds.find(c);\n\t}\n      }\n    }\n    long long p[102][102][4];\n    fill(p[0][0],p[102][0],-1);\n    while(l){\n      int dx[]={0,1,0,-1};\n      int dy[]={-1,0,1,0};\n      for(;;){\n\tif(p[y][x][d]!=-1){\n\t  int m=p[y][x][d]-l;\n\t  if(l>m){\n\t    l=l%m+m;\n\t  }\n\t}\n\tp[y][x][d]=l;\n\tif(s[y+dy[d]][x+dx[d]])break;\n\td=(d+1)%4;\n      }\n      y+=dy[d];\n      x+=dx[d];\n      l--;\n    }\n  end:\n    cout<<y<<' '<<x<<' '<<ds[d]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n\nstruct State{\n    int h,w,dir;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nstring dmpi=\"NESW\";\n\nvoid out(State st){\n    cout<<st.h<<\" \"<<st.w<<\" \"<<dmpi[st.dir]<<endl;\n}\n\nint solve(int H,int W,ll L){\n    vector<string> f(H+2);\n    for(int i=0;i<W+2;i++){\n        f[0]+=\"#\";\n        f[H+1]+=\"#\";\n    }\n    State ini={-1,-1,-1};\n    for(int i=0;i<H;i++){\n        cin>>f[i+1];\n        f[i+1]=\"#\"+f[i+1]+\"#\";\n        assert(f[i+1].size()==W+2);\n        for(int j=0;j<W+2;j++){\n            if(f[i+1][j]=='N'){\n                ini=State{i+1,j,0};\n            }\n            else if(f[i+1][j]=='E'){\n                ini=State{i+1,j,1};\n            }\n            else if(f[i+1][j]=='S'){\n                ini=State{i+1,j,2};\n            }\n            else if(f[i+1][j]=='W'){\n                ini=State{i+1,j,3};\n            }\n        }\n    }\n    assert(ini.h!=-1);\n    vector<vector<vector<int>>> dp(H+2,vector<vector<int>>(W+2,vector<int>(4,-1)));\n    int lps=0;\n    State st=ini;\n    int cnt=0;\n    queue<State> que;\n    while(true){\n        if(cnt==L){\n            out(st);\n            return 0;\n        }\n        if(dp[st.h][st.w][st.dir]!=-1){\n            lps=cnt-dp[st.h][st.w][st.dir];\n            break;\n        }\n        dp[st.h][st.w][st.dir]=cnt;\n        if(f[st.h+dh[st.dir]][st.w+dw[st.dir]]=='#'){\n            st.dir=(st.dir+1)%4;\n            continue;\n        }\n        st.h+=dh[st.dir];\n        st.w+=dw[st.dir];\n        que.push(st);\n        cnt++;\n    }\n    L-=cnt+1;\n    vector<State> lpv;\n    while(que.size()>lps) que.pop();\n    while(!que.empty()) lpv.push_back(que.front()),que.pop();\n    assert(lpv.size()==lps);\n    L%=lps;\n    assert(L<lpv.size());\n    out(lpv[L]);\n    return 0;\n}\nint main(){\n    int H,W;\n    ll L;\n    while(cin>>H>>W>>L,H){\n        solve(H,W,L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint getdir(char c) {\n    switch (c) {\n    case 'N':\n        return 0;\n    case 'E':\n        return 1;\n    case 'S':\n        return 2;\n    case 'W':\n        return 3;\n    default:\n        return -1;\n    }\n}\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nchar num2dir[4] = {'N', 'E', 'S', 'W'};\n\nint main(void) {\n    int h, w;\n    long long l;\n    while (cin >> h >> w >> l, h|w|l) {\n        vector<string> vs;\n        long long count = 0;\n        string wall = \"\";\n        bool used[101][101][4];\n        fill_n((bool *)used, 101*101*4, false);\n\n        for (int i = 0; i < w+2; i++) {\n            wall += \"#\";\n        }\n        vs.push_back(wall);\n        string input;\n        for (int i = 0; i < h; i++) {\n            cin >> input;\n            vs.push_back(\"#\"+input+\"#\");\n        }\n        vs.push_back(wall);\n\n        int x, y, dir;\n        for (int j = 0; j < h+2; j++) {\n            for (int i = 0; i < w+2; i++) {\n                if (vs[j][i] != '#' && vs[j][i] != '.') {\n                    x = i;\n                    y = j;\n                    dir = getdir(vs[j][i]);\n                    vs[j][i] = '.';\n                }\n            }\n        }\n\n        while (l > 0) {\n            if (vs[y+dy[dir]][x+dx[dir]] == '.') {\n                y += dy[dir];\n                x += dx[dir];\n                l--;\n                count++;\n            }\n            else\n                dir = (dir+1) % 4;\n            if (used[y][x][dir]) {\n                l = l % count;\n            } else if(vs[y][x] == '.') {\n                used[y][x][dir] = true;\n            }\n        }\n        cout << y << \" \" << x << \" \" << num2dir[dir] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\n#define int long long\nusing namespace std;\nstring s[110];\nvector<pair<pair<int,int>,char> >v;\nint h,w,l,x,y,syuki,pp;\nchar t;\nint used[101][101][25];\nvoid dig(){\n  int sum=1;\n  while(1){\n    int p=0;\n    if(used[y][x][(int)t-'C']){\n      syuki=sum-used[y][x][t-'C'];\n      pp=sum-syuki;\n      break;\n    }\n    used[y][x][t-'C']=sum;\n    if(t=='N'){\n      if(s[y-1][x]=='#')t='E',p++;\n      else y--;\n    }\n    else if(t=='E'){\n      if(s[y][x+1]=='#')t='S',p++;\n      else x++;\n    }\n    else if(t=='S'){\n      if(s[y+1][x]=='#')t='W',p++;\n      else y++;\n    }\n    else{\n      if(s[y][x-1]=='#')t='N',p++;\n      else x--;\n    }\n    if(!p)v.push_back(mk(mk(y,x),t)),sum++;\n    \n  }\n}\nmain(){\n  while(cin>>h>>w>>l,w){\n    r(i,h+2)s[i]=\"\";\n    r(i,h)cin>>s[i+1];\n    r(i,w+2)s[0]+='#',s[h+1]+='#';\n    r(i,h)s[i+1]='#'+s[i+1]+'#';\n    v.clear();\n    memset(used,0,sizeof(used));\n    r(i,h+2)r(j,w+2)if(isalpha(s[i][j]))x=j,y=i,t=s[i][j];\n    dig();\n    int a=syuki;\n    if(l<v.size())cout<<v[l-1].first.first<<' '<<v[l-1].first.second<<' '<<v[l-1].second<<endl;\n    else{\n      while((int)v.size()>syuki)v.erase(v.begin());\n\n      cout<<v[(l-pp)%a].first.first<<' '<<v[(l-pp)%a].first.second<<' '<<v[(l-pp)%a].second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst string dd = \"ESWN\";\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass State\n{\npublic:\n  int x, y, d;\n  State(int _x = 0, int _y = 0, int _d = 0)\n    :x(_x), y(_y), d(_d) {}\n};\n\nint main()\n{\n  int H, W;\n  long long int L;\n  while (cin >> H >> W >> L) {\n    if ((H|W|L) == 0)\n      break;\n\n    State s;\n    vector<string> c(H);\n    for (int i = 0; i < H; ++i) {\n      cin >> c[i];\n      if (c[i].find_first_of(dd) != string::npos) {\n\ts.y = i;\n\ts.x = c[i].find_first_of(dd);\n\ts.d = dd.find_first_of(c[s.y][s.x]);\n\tc[s.y][s.x] = '.';\n      }\n    }\n\n    vector<vector<vector<long long int> > > visited(H, vector<vector<long long int> >(W, vector<long long int>(4, -1)));\n    for (long long int i = 0; i < L; ++i) {\n      if (visited[s.y][s.x][s.d] == -1) {\n\tvisited[s.y][s.x][s.d] = i;\n      } else {\n\tlong long int diff = i - visited[s.y][s.x][s.d];\n\ti = L - ((L - i) % diff);\n\tif (i == L)\n\t  break;\n      }\n      \n      while (s.x+dx[s.d] < 0 || W <= s.x+dx[s.d] ||\n\t     s.y+dy[s.d] < 0 || H <= s.y+dy[s.d] ||\n\t     c[s.y+dy[s.d]][s.x+dx[s.d]] == '#')\n\ts.d = (s.d+1) % 4;\n\n      s.x += dx[s.d];\n      s.y += dy[s.d];\n    }\n\n    cout << s.y+1 << \" \" << s.x+1 << \" \" << dd[s.d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct State {\n  int x, y, d;\n  long long l;\n  State(){}\n  State(int x, int y, int d, long long l):x(x),y(y),d(d),l(l){}\n};\n  \nint H, W;\nlong long L;\nint sx, sy, sd;\nchar maze[101][101];\n\nint dist[4][101][101];\n\nconst string dir = \"NESW\";\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nState bfs()\n{\n  queue<State> que; que.push(State(sx, sy, sd, L));\n  memset(dist, -1, sizeof(dist));\n  dist[sd][sy][sx] = 0;\n  while(!que.empty()) {\n    State p = que.front(); que.pop();\n    if(p.l == 0LL) return p;    \n    int nx = p.x+dx[p.d], ny = p.y+dy[p.d];\n    long long nl = p.l;\n    if(0 <= nx && nx < W && 0 <= ny && ny < H\n       && maze[ny][nx] != '#') {\n      nl--;\n      if(dist[p.d][ny][nx] != -1) {\n\tnl %= (dist[p.d][p.y][p.x] - dist[p.d][ny][nx]);\n\tmemset(dist, -1, sizeof(dist));\n      } \n      dist[p.d][ny][nx] = dist[p.d][p.y][p.x] + 1;\n      que.push(State(nx, ny, p.d, nl));\n    } else {\n      if(dist[(p.d+1)%4][p.y][p.x] != -1) {\n\tnl %= (dist[p.d][p.y][p.x] - dist[(p.d+1)%4][p.y][p.x]);\n\tmemset(dist, -1, sizeof(dist));\t\n      }\n      dist[(p.d+1)%4][p.y][p.x] = dist[p.d][p.y][p.x];\n      que.push(State(p.x, p.y, (p.d+1)%4, nl));\n    }\n  }\n}\n\nint main()\n{\n  while(cin >> H >> W >> L, H) {\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n\tcin >> maze[i][j];\n\tif(dir.find(maze[i][j]) != string::npos) {\n\t  sy = i, sx = j, sd = dir.find(maze[i][j]);\n\t}\n      }\n    }\n    State s = bfs();\n    cout << s.y+1 << \" \" << s.x+1 << \" \" << dir[s.d] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n\nint W,H;\nll L;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar DtoS[] = {'N', 'E', 'S', 'W'};\nbool visited[100][100][4];\nstring field[100];\nint table[40005];\n\npair<int, int> bfs(int sx, int sy, int sd)\n{\n    memset(visited, 0, sizeof(visited));\n    for(int i=0; i<40000; i++) table[i] = -1;\n    \n    int x = sx, y = sy, d = sd;\n    int cost = 0;\n    \n    while(1) {\n\n\tif(visited[x][y][d]) break;\n\tvisited[x][y][d] = true;\n\n\tint h = d*10000 + y*100 + x;\n\t\n\ttable[h] = cost;\n\tcost++;\n\t\n\tfor(int i=0; i<4; i++) {\n\t    int td = (d + i)%4;\n\t    int tx = x + dx[td];\n\t    int ty = y + dy[td];\n\n\t    if(tx < 0 || ty < 0 || tx >= W || ty >= H) continue;\n\t    if(field[ty][tx] == '#') continue;\n\t    \n\t    d = td;\n\t    \n\t    break;\n\t}\n\t\n\tx += dx[d];\n\ty += dy[d];\t\n    }\n\n    \n    int ret = table[d*10000 + y*100 + x];\n\n    return make_pair(cost, ret);\n}\n\nint solve() \n{\n    pair<int, int> bfsres;\n\t\n    for(int i=0; i<H; i++)\n\tfor(int j=0; j<W; j++)\n\t    for(int k=0; k<4; k++) {\n\t\tif(DtoS[k] == field[i][j])\n\t\t    bfsres = bfs(j, i, k);\n\t    }\n\n    ll length = bfsres.first;\n    ll bias = bfsres.second;\n    ll loopL = length - bias;\n\n    if ( L < bias) return table[L];\n    ll pos = (L-bias)%loopL + bias;    \n\n    int res = 0;\n    for(int i=0; i<40000; i++)\n\tif(table[i]==pos) res = i;\n\n    return res;\n}\n\nint main() \n{\n    while(cin >> H >> W >> L, (W||H||L)) {\n\tfor(int i=0; i<H; i++)\n\t    cin >> field[i];\n\n\tint res = solve();\n\tcout << ((res/100)%100 + 1) << \" \" << (res%100) + 1 << \" \" << DtoS[res/10000] << endl;\n    \n    }\n}\n\n\n\t\n\t\n\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define F first\n#define S second\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct Pox\n{\n  int x,y,dir;\n  Pox(int x=-1,int y=-1,int dir=-1):x(x),y(y),dir(dir){}\n};\nint dx[] = {+0,+1,+0,-1};//N,E,S,W\nint dy[] = {-1,+0,+1,+0};\nchar G[100][100];\nint visited[100][100][4];\nP src;\n\nint getDir(char c)\n{\n  switch(c)\n    {\n    case 'N':\n      return 0;\n    case 'E':\n      return 1;\n    case 'S':\n      return 2;\n    case 'W':\n      return 3;\n    }\n}\n\nchar toChar(int c)\n{\n  switch(c)\n    {\n    case 0:\n      return 'N';\n    case 1:\n      return 'E';\n    case 2:\n      return 'S';\n    case 3:\n      return 'W';\n    }\n}\n\nvoid move(int H,int W,int &dir)\n{\n  cout << \"dir = \" << dir << endl;\n  while(true)\t\t\n    {      \n      src.S = src.S + dx[dir];\n      src.F = src.F + dy[dir];\n      if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t{\n\t  src.S = src.S - dx[dir];\n\t  src.F = src.F - dy[dir];\n\t  dir = (dir+1)%4;\n\t}\n      else if(G[src.S][src.F] == '#')\n\t{\n\t  src.S = src.S - dx[dir];\n\t  src.F = src.F - dy[dir];\n\t  dir = (dir+1)%4;\n\t}\n      else \n\t{\n\t  src.S = src.S - dx[dir];\n\t  src.F = src.F - dy[dir];\n\t  break;\n\t}\n    }\n  cout << \"aft = \" << dir << endl;\n}\n \nint main()\n{\n  int H,W,L;\n  while(cin >> H >> W >> L,H|W|L)\n    {\n      if(W == 1 && H == 1)\n\t{\n\t  cout << H << \" \" << W << \" \" << L << endl;\n\t  char c;\n\t  cin >> c;\n\t  cout << c << endl;\n\t  assert(false);\n\t}\n      int dir;\n      rep(i,H)\n\t{\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      G[i][j] = line[j];\n\t      if(!(G[i][j] == '.' || G[i][j] == '#'))src = P(j,i),dir = getDir(G[i][j]),G[i][j] = '.';\n\t      \n\t      rep(k,4)visited[i][j][k] = -1;\n\t    }\n\t}     \n\n      int phase = 0;\n      vector<Pox> path;\n      path.push_back(Pox(src.F,src.S,dir));\n      \n      while(true)\n\t{\n\t  if(phase >= L)\n\t    {\n\t      cout << src.S+1 << \" \" << src.F+1 << \" \" << toChar(dir) << endl;  \n\t      break;\n\t    }\n\t  if(visited[src.S][src.F][dir] != -1)\n\t    {\n\t      L -= phase;\n\t      L %= (phase-visited[src.S][src.F][dir]);\n\t      for(int i=0;i<path.size();i++)\n\t\t{\n\t\t  if(path[i].x == src.F && path[i].y == src.S)\n\t\t    {\n\t\t      cout << path[i+L].y+1 << \" \" << path[i+L].x+1 << \" \" << toChar(path[i+L].dir) << endl;  \n\t\t      break;\n\t\t    }\n\t\t}\n\t      break;\n\t    }     \n \n\t  visited[src.S][src.F][dir] = phase;\n\t  src.F += dx[dir];\n\t  src.S += dy[dir];\n\t  if(!(0 <= src.F && src.F < W && 0 <= src.S && src.S < H))\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n\t  else if(G[src.S][src.F] == '#')\n\t    {\n\t      src.F -= dx[dir];\n\t      src.S -= dy[dir];\n\t      dir = (dir+1)%4;\n\t      continue;\n\t    }\n \n\t  path.push_back(Pox(src.F,src.S,dir));\n\t  phase++;\n\t}\n      \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nchar c[110][110];\nint d[110][110][4];\nint h, w, l;\nstring str = \"NESW\";\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = { 0, 1, 0,-1};\nbool contain(int y, int x){\n   return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> h >> w >> l;\n        if(h + w + l == 0) break;\n        int dr = 0, y = 0, x = 0;\n        rep(i, 0, 110) rep(j, 0, 110) rep(k, 0, 4) d[i][j][k] = -1;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> c[i][j];\n                if(str.find(c[i][j]) != string::npos){\n                    dr = str.find(c[i][j]);\n                    y = i; x = j;\n                }\n            }\n        }\n        d[y][x][dr] = 0;\n        vector<PP> sv;\n        sv.push_back(PP(P(y, x), dr));\n        for(int i = 1;; i++){\n            int ny = 0, nx = 0;\n            while(1){\n                ny = y + dy[dr];\n                nx = x + dx[dr];\n                if(contain(ny, nx) && c[ny][nx] != '#'){\n                    break;\n                }\n                dr = (dr + 1) % 4;\n            }\n            y = ny; x = nx;    \n            if(i == l){\n                cout << y + 1 << ' ' << x + 1 << ' ' << str[dr] << endl;\n                break;\n            }        \n            if(d[y][x][dr] != -1){\n                int loop = i - d[y][x][dr];\n                int step = d[y][x][dr] + (l - d[y][x][dr]) % loop;\n                cerr << loop << ' ' << step << endl;\n                cout << sv[step].first.first + 1 << ' ' << sv[step].first.second + 1 << ' ' << str[sv[step].second] << endl;\n                break;\n            }\n            d[y][x][dr] = i;\n            sv.push_back(PP(P(y, x), dr));\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s[110];\nvector<pair<pair<int,int>,char> >v;\nint h,w,l,x,y,syuki,pp;\nchar t;\nint used[101][101][25];\nvoid dig(){\n  int sum=1;\n  while(1){\n    int p=0;\n    if(used[y][x][(int)t-'C']){\n      syuki=sum-used[y][x][t-'C'];\n      pp=sum-syuki;\n      break;\n    }\n    used[y][x][t-'C']=sum;\n    if(t=='N'){\n      if(s[y-1][x]=='#')t='E',p++;\n      else y--;\n    }\n    else if(t=='E'){\n      if(s[y][x+1]=='#')t='S',p++;\n      else x++;\n    }\n    else if(t=='S'){\n      if(s[y+1][x]=='#')t='W',p++;\n      else y++;\n    }\n    else{\n      if(s[y][x-1]=='#')t='N',p++;\n      else x--;\n    }\n    if(!p)v.push_back(mk(mk(y,x),t)),sum++;\n    \n  }\n}\nint main(){\n  while(cin>>h>>w>>l,w){\n    r(i,h+2)s[i]=\"\";\n    r(i,h)cin>>s[i+1];\n    r(i,w+2)s[0]+='#',s[h+1]+='#';\n    r(i,h)s[i+1]='#'+s[i+1]+'#';\n    v.clear();\n    memset(used,0,sizeof(used));\n    r(i,h+2)r(j,w+2)if(isalpha(s[i][j]))x=j,y=i,t=s[i][j];\n    dig();\n    int a=syuki;\n    if(l<v.size())cout<<v[l].first.first<<' '<<v[l].first.second<<' '<<v[l].second<<endl;\n    else{\n      while((int)v.size()>syuki)v.erase(v.begin());\n\n      cout<<v[(l-pp)%a].first.first<<' '<<v[(l-pp)%a].first.second<<' '<<v[(l-pp)%a].second<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint visit[4][110][110];\nchar field[110][110];\nint w, h;\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nll L;\n\nint main() {\n  char mapfrom[4] = { 'E', 'S', 'W', 'N' };\n  while (scanf(\"%d %d %lld\", &h, &w, &L), w|h|L) {\n    int dir;\n    int px = -1;\n    int py = -1;\n    MEMSET(visit, -1);\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n      REP(x, w) {\n        if (field[y][x] == 'E') { dir = 0; }\n        if (field[y][x] == 'S') { dir = 1; }\n        if (field[y][x] == 'W') { dir = 2; }\n        if (field[y][x] == 'N') { dir = 3; }\n        if (isalpha(field[y][x])) {\n          px = x;\n          py = y;\n        }\n      }\n    }\n    bool first = true;\n    ll turn = 0;\n    while (L > turn) {\n      if (visit[dir][py][px] != -1 && first) {\n        ll cnt = (L - turn) / (turn - visit[dir][py][px]) - 1;\n        turn += cnt * (turn - visit[dir][py][px]);\n        first = false;\n        continue;\n      }\n      visit[dir][py][px] = turn;\n      int nx = px + dx[dir];\n      int ny = py + dy[dir];\n      if (nx < 0 || nx >= w || ny < 0 || ny >= h || field[ny][nx] == '#') {\n        dir = (dir + 1) % 4;\n        continue;\n      }\n      px = nx;\n      py = ny;\n      turn++;\n    }\n    printf(\"%d %d %c\\n\", py + 1, px + 1, mapfrom[dir]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint field_cnt[100][100][4];\nchar field[100][100];\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nstring ds = \"NESW\";\n\nint main() {\n  int h, w;\n  ll n;\n  int x, y, way;\n  while(cin>>h>>w>>n,h|w|n){\n    fill_n((int *)field_cnt, 100*100*4, -1);\n    fill_n((char *)field, 100*100, '#');\n    int way = 0;\n    REP(iy, h){\n      REP(ix, w){\n        cin >> field[iy][ix];\n        char c = field[iy][ix];\n        switch(c){\n          case 'W':\n          way++;\n          case 'S':\n          way++;\n          case 'E':\n          way++;\n          case 'N':\n          x = ix;\n          y = iy;\n        }\n      }\n    }\n    int cnt = 0;\n    while(n>0){\n      // LOG (\"%d -- %d %d %c\\n\",n,y,x,ds[way]);\n      if(field_cnt[y][x][way] != -1){\n        if (n < cnt - field_cnt[y][x][way]){\n        }else{\n          n %= cnt - field_cnt[y][x][way];\n          if(n==0)break;\n        }\n      }\n      n--;\n      field_cnt[y][x][way] = cnt;\n      int nx = x + dx[way];\n      int ny = y + dy[way];\n      while(nx<0 || ny<0 || nx>=w || ny>=h || field[ny][nx] == '#'){\n        way= (way+1)%4;\n        nx = x + dx[way];\n        ny = y + dy[way];\n      }\n      y = ny;\n      x = nx;\n      cnt++;\n    }\n    printf (\"%d %d %c\\n\",y+1,x+1,ds[way]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {0, 1, 0, -1};\n    int dx[] = {1, 0, -1, 0};\n\n    int toD[256];\n    toD['E'] = 0;\n    toD['S'] = 1;\n    toD['W'] = 2;\n    toD['N'] = 3;\n\n    char fromD[] = \"ESWN\";\n\n    for(;;){\n        int h, w;\n        long long l;\n        cin >> h >> w >> l;\n        if(h == 0)\n            return 0;\n\n        int y, x, d;\n        vector<string> grid(h+2, string(w+2, '#'));\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> grid[i][j];\n                if(grid[i][j] != '.' && grid[i][j] != '#'){\n                    d = toD[grid[i][j]];\n                    y = i;\n                    x = j;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n\n        vector<vector<vector<int> > > t(h+2, vector<vector<int> >(w+2, vector<int>(4, -1)));\n        while(--l >= 0){\n            int y1, x1;\n            for(;;){\n                y1 = y + dy[d];\n                x1 = x + dx[d];\n                if(grid[y1][x1] == '.')\n                    break;\n                ++ d;\n                d %= 4;\n            }\n            y = y1;\n            x = x1;\n\n            if(t[y][x][d] != -1){\n                int dt = l - t[y][x][d];\n                l %= dt;\n            }\n            t[y][x][d] = l;\n        }\n\n        cout << y << ' ' << x << ' ' << fromD[d] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define WALL '#'\n#define EMPTY '.'\n\nenum{NORTH, EAST, SOUTH, WEST};\nchar ItoC[4] = {'N', 'E', 'S', 'W'};\nmap<char,int> CtoI;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {-1,0,1,0};\n\nstruct Robot{\n  int y,x,dir;\n\n  Robot(int i=0, int j=0, int d=0){y=i; x=j; dir=d;}\n\n  void move(){\n    y += dy[dir];\n    x += dx[dir];\n  }\n  void turn(){\n    dir = (dir+1)%4;\n  }\n};\n\nint main(){\n  CtoI['N'] = 0;\n  CtoI['E'] = 1;\n  CtoI['S'] = 2;\n  CtoI['W'] = 3;\n  long long int H, W, L;\n  while(cin>>H>>W>>L, H|W|L){\n    vector< vector<char> > c(H+2, vector<char>(W+2, WALL));\n    Robot me;\n    long long int step = 0;\n    long long int visited[102][102][4] = {0};\n    for(int i=1; i<=H; i++){\n      for(int j=1; j<=W; j++){\n        cin>>c[i][j];\n        if(c[i][j]!=WALL && c[i][j]!=EMPTY){\n          me = Robot(i, j, CtoI[c[i][j]]);\n          c[i][j] = EMPTY;\n        }\n      }\n    }\n\n    while(L>step){\n      while(c[me.y+dy[me.dir]][me.x+dx[me.dir]]==WALL){\n        me.turn();\n      }\n      if(visited[me.y][me.x][me.dir]){\n        long long int t = step - visited[me.y][me.x][me.dir];\n        step = L - L%t;\n      }\n      visited[me.y][me.x][me.dir] = step;\n      step++;\n      me.move();\n    }\n\n    cout<<me.y<<\" \"<<me.x<<\" \"<<ItoC[me.dir]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint dist[110][110][4];\nchar v[110][110];\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { -1, 0, 1, 0 };\n\nint main(){\n\tint n, m, L;\n\twhile (cin >> n >> m >> L, n){\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1) cin >> v[i][j];\n\t\tint r, c, d;\n\t\tFOR(i, 1, n + 1) FOR(j, 1, m + 1){\n\t\t\tif (v[i][j] != '.' && v[i][j] != '#'){\n\t\t\t\trep(dir, 4) if (v[i][j] == \"NESW\"[dir]) tie(r, c, d) = MT(i, j, dir);\n\t\t\t\tv[i][j] = '.';\n\t\t\t}\n\t\t}\n\n\t\tMEMSET(dist, -1);\n\t\tint x = 0;\n\t\tdist[r][c][d] = x++;\n\t\tbool loop = true;\n\t\twhile (L){\n\t\t\tr += dy[d], c += dx[d];\n\t\t\twhile (v[r + dy[d]][c + dx[d]] != '.') d = (d + 1) % 4;\n\t\t\tdist[r][c][d] = x++, L--;\n\t\t\tif (loop && dist[r][c][d] >= 0) L %= (x - dist[r][c][d]), loop = false;\n\t\t}\n\t\tcout << r << ' ' << c << ' ' << \"NESW\"[d] << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint H,W,L;\nchar grid[150][150];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};//N,E,S,W\nll int memo[150][150][4];\nint dir,px,py;\n\nint rotate(int a){\n\treturn (a+1)%4;\n}\nbool inrange(int x,int y){\n\treturn (x>-1&&y>-1&&x<H&&y<W);\n}\nint main(){\n\twhile(1){\n\t\tREP(i,150) REP(j,150) REP(k,4) memo[i][j][k] = -1;\n\t\tcin >> H >> W >> L;\n\t\tif(H==0&&W==0&&L==0) break;\n\t\tREP(i,H){\n\t\t\tREP(j,W){\n\t\t\t\tcin >> grid[i][j];\n\t\t\t\tif(grid[i][j]=='N'){dir = 0; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='E'){dir = 1; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='S'){dir = 2; px = i; py = j; grid[i][j] = '.';}\n\t\t\t\tif(grid[i][j]=='W'){dir = 3; px = i; py = j; grid[i][j] = '.';}\n\t\t\t}\n\t\t}\n\t\tll int step = 0;\n\t\tmemo[px][py][dir] = 0;\n\t\twhile(1){\n\t\t\tif(step == L) break;\n\t\t\tint nx = px + dx[dir]; int ny = py + dy[dir];\n\t\t\tif(grid[nx][ny]=='.'){\n\t\t\t\tpx = nx; py = ny;\n\t\t\t\tif(memo[px][py][dir]!=-1){\n\t\t\t\t\t//a,b,c\n\t\t\t\t\tll int a = step-memo[px][py][dir];\n\t\t\t\t\tll int b = L-step;\n\t\t\t\t\tstep += a*(b/a);\n\t\t\t\t\tif(step == L) break;\n\t\t\t\t}else{\n\t\t\t\t\tmemo[px][py][dir] = step;\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tif(!inrange(nx,ny)||grid[nx][ny]=='#'){\n\t\t\t\tdir = rotate(dir);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tstring ans = \"NESW\";\n\t\tcout << px+1 << \" \" << py+1 << \" \" <<  ans[dir] << endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\nchar map[110][110];\ntypedef struct p{\n\tint x,y;\n}P;\ntypedef struct situation{\n\tint x,y,d;\n}situation;\nsituation c,s[10000],n;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint rotate(char  n){\n\tif(n==0)return 1;\n\tif(n==1)return 2;\n\tif(n==2)return 3;\n\tif(n==3)return 0;\n}\nint main(){\n\tint i,j,k,h,w,sn,f;\n\tlong long l;\n\twhile(1){\n\t\tscanf(\"%d%d%lld\",&h,&w,&l);\n\t\tif(h==0)break;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tscanf(\"%s\",map[i]+1);\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(map[i][j]=='E')c=(situation){j,i,0},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='N')c=(situation){j,i,3},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='W')c=(situation){j,i,2},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='S')c=(situation){j,i,1},map[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=w+1;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tsn=0;f=0;\n\t\ts[0]=c;\n\t\twhile(1){\n\t\t\tn.x=s[sn].x+dx[s[sn].d];\n\t\t\tn.y=s[sn].y+dy[s[sn].d];\n\t\t\tn.d=s[sn].d;\n\t\t\tif(map[n.y][n.x]=='.'){\n\t\t\t\ts[++sn]=n;\n\t\t\t\t//printf(\"  %d %d %d\\n\",s[sn].y,s[sn].x,s[sn].d);\n\t\t\t\tfor(i=0;i<sn;i++){\n\t\t\t\t\tif(s[i].x==s[sn].x && s[i].y==s[sn].y && s[i].d==s[sn].d)goto nex;\n\t\t\t\t}\n\t\t\t\tif(sn==l){\n\t\t\t\t\tf=1;\n\t\t\t\t\tprintf(\"%d %d \",s[sn].y,s[sn].x);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ts[sn].d=rotate(s[sn].d);\n\t\t\t\t//printf(\"   %d %d %d\\n\",s[sn].y,s[sn].x,s[sn].d);\n\t\t\t}\n\t\t}\n\t\tnex:\n\t\tif(f==0){\n\t\t\tj=(l-i)%(sn-i)+i;\n\t\t\tprintf(\"%d %d \",s[j].y,s[j].x);\n\t\t}else j=sn;\n\t\tif(s[j].d==0)printf(\"E\\n\");\n\t\telse if(s[j].d==1)printf(\"S\\n\");\n\t\telse if(s[j].d==2)printf(\"W\\n\");\n\t\telse if(s[j].d==3)printf(\"N\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint main(){\n\tint H,W; // マップの縦幅、横幅\n\tlong long L; // この数だけ進んだ後の場所を知りたい\n\t// intは21億まで,long longは920京まで\n\tchar c[111][111]; // マップ。y座標(上から下が正)が先、x座標(左から右が正)が後\n\t// なお、このようなプログラムでは数学と違い、縦方向のy座標を先に書くのが普通\n\t\n\tchar dir[] = \"ESWN\"; // 東南西北 (右回り)\n\t// 以下、向きを数字で表す。東=0,南=1,西=2,北=3\n\tint dy[] = {0,1,0,-1};\n\tint dx[] = {1,0,-1,0};\n\t// dy[0]=0, dx[0]=1 の意味:\n\t// 東(0)に進むとは、y座標を0、x座標を1増やすこと。\n\t\n\tint memo[111][111][4];\n\t// 例: memo[6][4][1] = 3 なら、\n\t// スタートから3歩進んだとき、y=6,x=4の位置にいて、南(1)を向いていた\n\t// memo[6][4][1] = -1 なら、\n\t// y=6,x=4の位置で南(1)を向いていたことがまだない\n\t\n\tint y,x,d,step; // ロボットの現在地(y,x)、向き(d)、スタートからの歩数(step)\n\tint i,j,k; // for文用\n\t\n\t// 実際の処理はここから\n\t\n\twhile(1){ // データセット終了の印が来るまで処理を続ける\n\t\tscanf(\"%d %d %lld\",&H,&W,&L); // Lはlong longなので%lldを使う\n\t\tif(H==0)return 0; // Hが0なら、他も全部0のはずなのでプログラム終了\n\t\t\n\t\t// 入力は c[1〜H][1〜W] の範囲に読み込む。\n\t\t// その前に、この範囲と周囲1マス (c[0〜H+1][0〜W+1]) を壁で埋める。目的は2つ\n\t\t// 1. 迷路から出られなくすることで、「迷路を出てはいけない」という条件を無視する\n\t\t// 2. 前回読み込んだマップの影響を受けないようにする\n\t\tfor(i=0;i<=H+1;i++){\n\t\t\tfor(j=0;j<=W+1;j++){\n\t\t\t\tc[i][j]='#';\n\t\t\t}\n\t\t}\n\t\t\n\t\t// 入力を読み込む\n\t\tfor(i=1;i<=H;i++){\n\t\t\tfor(j=1;j<=W;j++){\n\t\t\t\tscanf(\" %c\",&c[i][j]);\n\t\t\t\t// \" %c\"で空白を読み飛ばし、前の行の終わりの改行文字を無視する\n\t\t\t\t// (詳細… http://www9.plala.or.jp/sgwr-t/c/sec05.html の「５−４」)\n\t\t\t\tif(isalpha(c[i][j])){\n\t\t\t\t// c[i][j]はアルファベットか？\n\t\t\t\t// 使うにはプログラム先頭に\"#include <ctype.h>\"\n\t\t\t\t\ty=i,x=j; // アルファベットなら、そこがロボットの場所\n\t\t\t\t\tfor(k=0;k<4;k++){ // その文字はESWNのどれか？\n\t\t\t\t\t\tif(dir[k]==c[i][j]) d=k; // ロボットの向き\n\t\t\t\t\t}\n\t\t\t\t\tc[i][j]='.'; // 方向を読み取った後は空白にしておく\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// テスト出力\n\t\t/*for(i=0;i<=H+1;i++){\n\t\t\tfor(j=0;j<=W+1;j++){\n\t\t\t\tprintf(\"%c\",c[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\t//printf(\"%d %d %d\\n\",y,x,d);\n\t\t\n\t\tmemset(memo,-1,sizeof(memo));\n\t\t// memset(○○,-1,sizeof(○○)) で配列○○の中身を全て-1に(多次元配列もOK)\n\t\t// 使うにはプログラム先頭に\"#include <string.h>\" (※-1と0以外では使い方が難しい)\n\t\t// -1は、その状態にまだなったことがないという印として使う\n\t\t\n\t\tstep=0; // 現在の歩数を0に\n\t\t\n\t\twhile(1){ // 目的の歩数に達するか、ループするまで続ける\n\t\t\t\n\t\t\tint ny,nx; // 進む先の座標\n\t\t\t//printf(\"%d %d %c\\n\",y,x,dir[d]); // テスト出力\n\t\t\t\n\t\t\tif(step == L){ // 目的の歩数に達した\n\t\t\t\tprintf(\"%d %d %c\\n\",y,x,dir[d]); // 現在の状況を出力\n\t\t\t\tbreak; // 終了\n\t\t\t}\n\t\t\t\n\t\t\tif(memo[y][x][d] != -1){ // ループに入った\n\t\t\t\t// 116行目(★)で、一歩ごとにメモをとっている。\n\t\t\t\t// もし過去に同じ場所で同じ方向を向いていたことがあった(=ループに入った)\n\t\t\t\t// なら、memo[y][x][d]にその時点での歩数が入っていて、-1ではない\n\t\t\t\tlong long cycle = step - memo[y][x][d];\n\t\t\t\t// 現在の歩数 - 過去に同じ状態だったときの歩数 = ループの長さ\n\t\t\t\tlong long rest = (L - step) % cycle;\n\t\t\t\t// 目的の歩数までの残り歩数を、ループの長さで割った余りだけ歩いて終了\n\t\t\t\t\n\t\t\t\t//printf(\"LOOP\\n\"); // テスト出力\n\t\t\t\tfor(i=0;i<rest;i++){ // 上で計算した歩数だけ歩く\n\t\t\t\t\tny = y + dy[d]; // 目の前のマスのy座標\n\t\t\t\t\tnx = x + dx[d]; // 同x座標\n\t\t\t\t\twhile(c[ny][nx] == '#'){\n\t\t\t\t\t// もし目の前が壁なら、目の前が壁でなくなるまで右を向き続ける\n\t\t\t\t\t\td = (d+1) % 4; // 90度右を向く(東=0,南=1,西=2,北=3)\n\t\t\t\t\t\tny = y + dy[d]; // 目の前のマスのy座標\n\t\t\t\t\t\tnx = x + dx[d]; // x座標\n\t\t\t\t\t}\n\t\t\t\t\ty=ny,x=nx; // 目の前は壁ではない。実際に進む\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprintf(\"%d %d %c\\n\",y,x,dir[d]); // 歩き終わったので、現在の状況を出力\n\t\t\t\tbreak; // 終了\n\t\t\t}\n\t\t\t\n\t\t\t// ここまで来た場合、上のif文は実行されなかった\n\t\t\t// つまり、今の場所で今向いている方向を向くのは初めてで、ループに入っていない\n\t\t\tmemo[y][x][d] = step; // (★) 今の状態(y,x,d)に、現時点での歩数(step)を記録\n\t\t\t\n\t\t\t// 上のif文の内部と全く同様に、目の前が壁でなくなるまで右を向き、進む\n\t\t\tny = y + dy[d];\n\t\t\tnx = x + dx[d];\n\t\t\twhile(c[ny][nx] == '#'){\n\t\t\t\td = (d+1) % 4;\n\t\t\t\tny = y + dy[d];\n\t\t\t\tnx = x + dx[d];\n\t\t\t}\n\t\t\ty=ny,x=nx;\n\t\t\tstep++;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2320: Infinity Maze\n// 2017.10.4 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar map[102][102];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint tr[128];\nint mk[102][102][4];\n\nint main()\n{\n\tint h, w, r, c, d, r2, c2, sr, sc, step;\n\tlong long l;\n\tchar dir[5] = \"NESW\";\n\n\ttr['#'] = 10, tr['.'] = 11, tr['N'] = 0, tr['E'] = 1, tr['S'] = 2, tr['W'] = 3;\n\twhile (scanf(\"%d%d%lld\", &h, &w, &l) && l > 0) {\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tfor (sr = -1, r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tif (sr >= 0) continue;\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tif (tr[map[r][c]] < 4) sr = r, sc = c, d = tr[map[r][c]], map[r][c] = '.';\n\t\t\t}\n\t\t}\n\t\tr = sr, c = sc, step = 0;\n\t\twhile (l > 0) {\n\t\t\tif (mk[r][c][d]) {\n\t\t\t\tl = l % (step - mk[r][c][d]);\n\t\t\t\tif (!l) break;\n\t\t\t}\n\t\t\tmk[r][c][d] = step;\n\t\t\twhile (1) {\n\t\t\t\tr2 = r + mv[d][0], c2 = c + mv[d][1];\n\t\t\t\tif (r2 >= 0 && r2 < h && c2 >= 0 && c2 < w && map[r2][c2] == '.') break;\n\t\t\t\tif (++d == 4) d = 0;\n\t\t\t}\n\t\t\tr = r2, c = c2;\n\t\t\tl--, step++;\n\t\t}\n\t\tprintf(\"%d %d %c\\n\", r+1, c+1, dir[d]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\nint main()\n{\n    while(1)\n    {\n        int H,W,x,y; long long int L;\n        scanf(\"%d %d %lld\",&H,&W,&L);\n        if(H==0) break;\n        int i,j; char dir, grid[100][100];\n        for(i=0; i<H; i++) scanf(\"%s\",&grid[i]);\n        for(i=0; i<H; i++)\n            for(j=0; j<W; j++)\n                if(grid[i][j]!='#' && grid[i][j]!='.')\n                {\n                    dir=grid[i][j];\n                    x=i;y=j;\n                }\n        grid[x][y]='.';\n        for(i=0; i<L; i++)\n        {\n            switch(dir){\n\n            case 'E':\n                {\n                    if(grid[x][y+1]=='.') y++;\n                    else if(grid[x+1][y]=='.')\n                    {\n                        x++;\n                        dir='S';\n                    }\n                    else if(grid[x][y-1]=='.')\n                    {\n                        x--;\n                        dir='W';\n                    }\n                    else\n                    {\n                        y--;\n                        dir='N';\n                    }\n                    break;\n                }\n            case 'W':\n                {\n                    if(grid[x][y-1]=='.') y--;\n                    else if(grid[x-1][y]=='.')\n                    {\n                        x--;\n                        dir='N';\n                    }\n                    else if(grid[x][y+1]=='.')\n                    {\n                        y++;\n                        dir='E';\n                    }\n                    else\n                    {\n                        x++;\n                        dir='S';\n                    }\n                    break;\n                }\n            case 'N':\n                {\n                    if(grid[x-1][y]=='.') x--;\n                    else if(grid[x][y+1]=='.')\n                    {\n                        y++;\n                        dir='E';\n                    }\n                    else if(grid[x+1][y]=='.')\n                    {\n                        x++;\n                        dir='S';\n                    }\n                    else\n                    {\n                        x--;\n                        dir='W';\n                    }\n                    break;\n                }\n            case 'S':\n                {\n                    if(grid[x+1][y]=='.') x++;\n                    else if(grid[x][y-1]=='.')\n                    {\n                        y--;\n                        dir='W';\n                    }\n                    else if(grid[x-1][y]=='.')\n                    {\n                        x--;\n                        dir='N';\n                    }\n                    else\n                    {\n                        y++;\n                        dir='E';\n                    }\n                    break;\n                }\n            default: return 0;\n            }\n\n        }\n        printf(\"%d %d %c\\n\",x+1,y+1,dir);\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\nchar map[110][110];\nchar map2[5][110][110];\ntypedef struct p{\n\tint x,y;\n}P;\ntypedef struct situation{\n\tint x,y,d;\n}situation;\nsituation c,s[1000000],n;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint rotate(char  n){\n\tif(n==0)return 1;\n\tif(n==1)return 2;\n\tif(n==2)return 3;\n\tif(n==3)return 0;\n}\nint main(){\n\tint i,j,k,h,w,f;\n\tlong long l,z,sn;\n\twhile(1){\n\t\tscanf(\"%d%d%lld\",&h,&w,&l);\n\t\tif(h==0)break;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tscanf(\"%s\",map[i]+1);\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(map[i][j]=='E')c=(situation){j,i,0},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='N')c=(situation){j,i,3},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='W')c=(situation){j,i,2},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='S')c=(situation){j,i,1},map[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=w+1;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tsn=0;f=0;\n\t\ts[0]=c;\n\t\tmemset(map2,0,sizeof(map2));\n\t\twhile(1){\n\t\t\tn.x=s[sn].x+dx[s[sn].d];\n\t\t\tn.y=s[sn].y+dy[s[sn].d];\n\t\t\tn.d=s[sn].d;\n\t\t\tif(map[n.y][n.x]=='.'){\n\t\t\t\t//s[sn].d=rotate(rotate(rotate(s[sn].d)));\n\t\t\t\tif(s[sn].d!=s[sn-1].d)s[sn].d=rotate(rotate(rotate(s[sn].d)));\n\t\t\t\ts[++sn]=n;\n\t\t\t\tif(map2[n.d][n.y][n.x]==1){\n\t\t\t\t\tfor(i=0;i<sn;i++){\n\t\t\t\t\t\tif(s[i].x==s[sn].x && s[i].y==s[sn].y && s[i].d==s[sn].d)goto nex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap2[n.d][n.y][n.x]=1;\n\t\t\t\t//printf(\"  %d %d %d\\n\",s[sn].y,s[sn].x,s[sn].d);\n\t\t\t\t//for(i=0;i<sn;i++){\n\t\t\t\t//\tif(s[i].x==s[sn].x && s[i].y==s[sn].y && s[i].d==s[sn].d)goto nex;\n\t\t\t\t//}\n\t\t\t\tif(sn==l){\n\t\t\t\t\tf=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ts[sn].d=rotate(s[sn].d);\n\t\t\t\t//printf(\"   %d %d %d\\n\",s[sn].y,s[sn].x,s[sn].d);\n\t\t\t}\n\t\t}\n\t\tnex:\n\t\tif(f==0)z=(l-i)%(sn-i)+i;\n\t\telse z=sn;\n\t\tprintf(\"%d %d \",s[z].y,s[z].x);\n\t\tif(s[z].d==0)printf(\"E\\n\");\n\t\telse if(s[z].d==1)printf(\"S\\n\");\n\t\telse if(s[z].d==2)printf(\"W\\n\");\n\t\telse if(s[z].d==3)printf(\"N\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\nchar map[110][110];\nchar map2[5][110][110];\ntypedef struct p{\n\tint x,y;\n}P;\ntypedef struct situation{\n\tint x,y,d;\n}situation;\nsituation c,s[1000000],n;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint rotate(char  n){\n\tif(n==0)return 1;\n\tif(n==1)return 2;\n\tif(n==2)return 3;\n\tif(n==3)return 0;\n}\nint main(){\n\tint i,j,k,h,w,f;\n\tlong long l,z,sn;\n\twhile(1){\n\t\tscanf(\"%d%d%lld\",&h,&w,&l);\n\t\tif(h==0)break;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tscanf(\"%s\",map[i]+1);\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(map[i][j]=='E')c=(situation){j,i,0},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='N')c=(situation){j,i,3},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='W')c=(situation){j,i,2},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='S')c=(situation){j,i,1},map[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=w+1;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tsn=0;f=0;\n\t\ts[0]=c;\n\t\tmemset(map2,0,sizeof(map2));\n\t\twhile(1){\n\t\t\tn.x=s[sn].x+dx[s[sn].d];\n\t\t\tn.y=s[sn].y+dy[s[sn].d];\n\t\t\tn.d=s[sn].d;\n\t\t\tif(map[n.y][n.x]=='.'){\n\t\t\t\ts[sn].d=rotate(rotate(rotate(s[sn].d)));\n\t\t\t\ts[++sn]=n;\n\t\t\t\tif(map2[n.d][n.y][n.x]==1){\n\t\t\t\t\tfor(i=0;i<sn;i++){\n\t\t\t\t\t\tif(s[i].x==s[sn].x && s[i].y==s[sn].y && s[i].d==s[sn].d)goto nex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap2[n.d][n.y][n.x]=1;\n\t\t\t\t//printf(\"  %d %d %d\\n\",s[sn].y,s[sn].x,s[sn].d);\n\t\t\t\t//for(i=0;i<sn;i++){\n\t\t\t\t//\tif(s[i].x==s[sn].x && s[i].y==s[sn].y && s[i].d==s[sn].d)goto nex;\n\t\t\t\t//}\n\t\t\t\tif(sn==l){\n\t\t\t\t\tf=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ts[sn].d=rotate(s[sn].d);\n\t\t\t\t//printf(\"   %d %d %d\\n\",s[sn].y,s[sn].x,s[sn].d);\n\t\t\t}\n\t\t}\n\t\tnex:\n\t\tif(f==0)z=(l-i)%(sn-i)+i;\n\t\telse z=sn;\n\t\tprintf(\"%d %d \",s[z].y,s[z].x);\n\t\tif(s[z].d==0)printf(\"E\\n\");\n\t\telse if(s[z].d==1)printf(\"S\\n\");\n\t\telse if(s[z].d==2)printf(\"W\\n\");\n\t\telse if(s[z].d==3)printf(\"N\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "X[]={0,1,0,-1},Y[]={-1,0,1,0},f[109][109],g[109][109][4];char s[109],*D=\"NESW\";\nmain(h,w,z,x,y,c,i,j,k){long long l;for(;scanf(\"%d%d%lld\",&h,&w,&l),h;printf(\"%d %d %c\\n\",y,x,D[z])){\n\tmemset(f,1,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(i=0;i<h;i++)for(scanf(\"%s\",s),j=0;j<w;j++){\n\t\tfor(k=0;k<4;k++)if(s[j]==D[k])x=j+1,y=i+1,z=k;\n\t\tif(s[j]!='#')f[i+1][j+1]=0;\n\t}\n\tfor(c=0;l;l--,c++){\n\t\tif(g[y][x][z]&&(l%=c-g[y][x][z])==0)break;\n\t\tfor(g[y][x][z]=c;f[y+Y[z]][x+X[z]];z=(z+1)%4);\n\t\tx+=X[z],y+=Y[z];\n\t}\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nlong long steps;\nint visited[4][102][102];\nchar map[104][104];\n\nconst int dx[4]={ 0, 1, 0,-1};\nconst int dy[4]={-1, 0, 1, 0};\nconst char dirstr[4]={'N','E','S','W'};\n\nstruct {\n\tint x,y,dir;\n} position[4*100*100+10];\n\nint getTheNumber(int offset,int max,long long steps) {\n\tif(steps<offset)return steps;\n\treturn (steps-offset)%(max-offset)+offset;\n}\n\nint main(void) {\n\tint i,j;\n\tint nowstep;\n\tint nowdir;\n\tint x,y;\n\tint offset,max,result;\n\twhile(1) {\n\t\tscanf(\"%d%d%lld\",&height,&width,&steps);\n\t\tif(width==0 && height==0 && steps==0)break;\n\t\tmemset(map,'#',sizeof(map));\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tscanf(\"%s\",&map[i][1]);\n\t\t\tmap[i][width+1]='#';\n\t\t}\n\t\tx=y=0;\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tfor(j=1;j<=width;j++) {\n\t\t\t\tif(map[i][j]=='N'){x=j;y=i;nowdir=0;}\n\t\t\t\telse if(map[i][j]=='E'){x=j;y=i;nowdir=1;}\n\t\t\t\telse if(map[i][j]=='S'){x=j;y=i;nowdir=2;}\n\t\t\t\telse if(map[i][j]=='W'){x=j;y=i;nowdir=3;}\n\t\t\t}\n\t\t}\n\t\tif(x<=0 || y<=0)return 1;\n\t\tmemset(visited,0,sizeof(visited));\n\t\tnowstep=0;\n\t\twhile(1) {\n\t\t\tif(visited[nowdir][y][x]>0)break;\n\t\t\tvisited[nowdir][y][x]=nowstep+1;\n\t\t\tposition[nowstep].x=x;\n\t\t\tposition[nowstep].y=y;\n\t\t\tposition[nowstep].dir=nowdir;\n\t\t\twhile(map[y+dy[nowdir]][x+dx[nowdir]]=='#') {\n\t\t\t\tnowdir=(nowdir+1)%4;/* turn right */\n\t\t\t}\n\t\t\tx+=dx[nowdir];\n\t\t\ty+=dy[nowdir];\n\t\t\tnowstep++;\n\t\t}\n\t\toffset=visited[nowdir][y][x]-1;\n\t\tmax=nowstep;\n\t\tresult=getTheNumber(offset,max,steps);\n\t\tprintf(\"%d %d %c\\n\",position[result].y,position[result].x,\n\t\t\tdirstr[position[result].dir]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar M[105][105],c,D[5]=\"NESW\";\nint H,W,sh,sw,i,j,t[105][105][4],mv[4]={-1,0,1,0},d;\nlong long int L;\nint out(int a,int b){return 0>a||a>=b;}\nint main()\n{\n\tfor(;scanf(\"%d%d%lld\\n\",&H,&W,&L),H;)\n\t{\n\t\tmemset(t,-1,sizeof(t));\n\t\tmemset(M,0,sizeof(M));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<=W;j++)\n\t\t\t{\n\t\t\t\tc=getchar();\n\t\t\t\tif('A'<c&&c<'Z')\n\t\t\t\t{\n\t\t\t\t\td=c=='N'?0:c=='E'?1:c=='S'?2:3;\n\t\t\t\t\tsh=i;sw=j;M[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse M[i][j]=c;\n\t\t\t}\n\t\tfor(i=0;i<L;)\n\t\t{\n\t\t\tif(out(sh+mv[d],H)||out(sw+mv[(d+1)%4],W)||M[sh+mv[d]][sw+mv[(d+1)%4]]=='#')\n\t\t\t{\n\t\t\t\td=(d+1)%4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(t[sh][sw][d]!=-1)\n\t\t\t{\n\t\t\t\tL=(L-i)%(i-t[sh][sw][d]);\n\t\t\t\ti=0;\n\t\t\t\tmemset(t,-1,sizeof(t));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tt[sh][sw][d]=i++;\n\t\t\tsh+=mv[d];\n\t\t\tsw+=mv[(d+1)%4];\n\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",sh+1,sw+1,D[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar M[105][105],c,D[5]=\"NESW\";\nint H,W,sh,sw,i,j,t[105][105][4],mv[4]={-1,0,1,0},d,nh,nw;\nlong long int L;\nint out(int a,int b){return 0>a||a>=b;}\n\nint f(int b)\n{\n\tfor(i=0;i<L;)\n\t{\n\t\tnh=sh+mv[d];nw=sw+mv[(d+1)%4];\n\t\tif(out(nh,H)||out(nw,W)||M[nh][nw]=='#')\n\t\t{\n\t\t\td=(d+1)%4;\n\t\t\tcontinue;\n\t\t}\n\t\tif(b&&t[sh][sw][d]!=-1)\n\t\t{\n\t\t\tL=(L-i)%(i-t[sh][sw][d])+(i-t[sh][sw][d]);\n\t\t\treturn 1;\n\t\t}\n\t\tt[sh][sw][d]=i++;\n\t\tsh=nh;sw=nw;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d%lld\\n\",&H,&W,&L),H;)\n\t{\n\t\tmemset(t,-1,sizeof(t));\n\t\tmemset(M,0,sizeof(M));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<=W;j++)\n\t\t\t{\n\t\t\t\tc=getchar();\n\t\t\t\tif('A'<c&&c<'Z')\n\t\t\t\t{\n\t\t\t\t\td=c=='N'?0:c=='E'?1:c=='S'?2:3;\n\t\t\t\t\tsh=i;sw=j;M[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse M[i][j]=c;\n\t\t\t}\n\t\tif(f(1))f(0);\n\t\tprintf(\"%d %d %c\\n\",sh+1,sw+1,D[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar M[105][105],c,D[5]=\"NESW\";\nint H,W,sh,sw,t[105][105][4],mv[4]={-1,0,1,0},d;\nunsigned long long int L,i,j;\nint out(int a,int b){return 0>a||a>=b;}\nint main()\n{\n\tfor(;scanf(\"%d%d%d\\n\",&H,&W,&L),H;)\n\t{\n\t\tmemset(t,-1,sizeof(t));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<=W;j++)\n\t\t\t{\n\t\t\t\tc=getchar();\n\t\t\t\tif('A'<c&&c<'Z')\n\t\t\t\t{\n\t\t\t\t\td=c=='N'?0:c=='E'?1:c=='S'?2:3;\n\t\t\t\t\tsh=i;sw=j;M[i][j]='.';\n\t\t\t\t\tt[sh][sw][d]=0;\n\t\t\t\t}\n\t\t\t\telse M[i][j]=c;\n\t\t\t}\n\t\tfor(i=0;i<L;)\n\t\t{\n\t\t\tif(out(sh+mv[d],H)||out(sw+mv[(d+1)%4],W)||M[sh+mv[d]][sw+mv[(d+1)%4]]=='#')\n\t\t\t{\n\t\t\t\td=(d+1)%4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//if(t[sh][sw][d]<i)\n\t\t\t//{\n\t\t\t//\tL%=(i-t[sh][sw][d]-1);\n\t\t\t//\ti=t[sh][sw][d];\n\t\t\t//\tcontinue;\n\t\t\t//}\n\t\t\tsh+=mv[d];\n\t\t\tsw+=mv[(d+1)%4];\n\t\t\tt[sh][sw][d]=++i;\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",sh+1,sw+1,D[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar M[105][105],c,D[5]=\"NESW\";\nint H,W,sh,sw,i,j,t[105][105][4],mv[4]={-1,0,1,0},d,nh,nw;\nlong long int L;\nint out(int a,int b){return 0>a||a>=b;}\nint main()\n{\n\tfor(;scanf(\"%d%d%lld\\n\",&H,&W,&L),H;)\n\t{\n\t\tmemset(t,-1,sizeof(t));\n\t\tmemset(M,0,sizeof(M));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<=W;j++)\n\t\t\t{\n\t\t\t\tc=getchar();\n\t\t\t\tif('A'<c&&c<'Z')\n\t\t\t\t{\n\t\t\t\t\td=c=='N'?0:c=='E'?1:c=='S'?2:3;\n\t\t\t\t\tsh=i;sw=j;M[i][j]='.';\n\t\t\t\t}\n\t\t\t\telse M[i][j]=c;\n\t\t\t}\n\t\tfor(i=0;i<L;)\n\t\t{\n\t\t\tnh=sh+mv[d];nw=sw+mv[(d+1)%4];\n\t\t\tif(out(nh,H)||out(nw,W)||M[nh][nw]=='#')\n\t\t\t{\n\t\t\t\td=(d+1)%4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(t[sh][sw][d]!=-1)\n\t\t\t{\n\t\t\t\tL=(L-i)%(i-t[sh][sw][d]);\n\t\t\t\ti=0;\n\t\t\t\tmemset(t,-1,sizeof(t));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tt[sh][sw][d]=i++;\n\t\t\tsh=nh;sw=nw;\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",sh+1,sw+1,D[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\nchar map[110][110];\nchar map2[5][110][110];\ntypedef struct p{\n\tint x,y;\n}P;\ntypedef struct situation{\n\tint x,y,d;\n}situation;\nsituation c,s[10000],n;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint rotate(char  n){\n\tif(n==0)return 1;\n\tif(n==1)return 2;\n\tif(n==2)return 3;\n\tif(n==3)return 0;\n}\nint main(){\n\tint i,j,k,h,w,f;\n\tlong long l,z,sn;\n\twhile(1){\n\t\tscanf(\"%d%d%lld\",&h,&w,&l);\n\t\tif(h==0)break;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tscanf(\"%s\",map[i]+1);\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tif(map[i][j]=='E')c=(situation){j,i,0},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='N')c=(situation){j,i,3},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='W')c=(situation){j,i,2},map[i][j]='.';\n\t\t\t\telse if(map[i][j]=='S')c=(situation){j,i,1},map[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=w+1;i++)map[0][i]=map[h+1][i]='#';\n\t\tfor(i=0;i<=h+1;i++)map[i][0]=map[i][w+1]='#';\n\t\t//for(i=0;i<=h+1;i++)printf(\"%s\\n\",map[i]);\n\t\tsn=0;f=0;\n\t\ts[0]=c;\n\t\tmemset(map2,0,sizeof(map2));\n\t\twhile(1){\n\t\t\tn.x=s[sn].x+dx[s[sn].d];\n\t\t\tn.y=s[sn].y+dy[s[sn].d];\n\t\t\tn.d=s[sn].d;\n\t\t\tif(map[n.y][n.x]=='.'){\n\t\t\t\ts[sn].d=rotate(rotate(rotate(s[sn].d)));\n\t\t\t\ts[++sn]=n;\n\t\t\t\tif(map2[n.d][n.y][n.x]==1){\n\t\t\t\t\tfor(i=0;i<sn;i++){\n\t\t\t\t\t\tif(s[i].x==s[sn].x && s[i].y==s[sn].y && s[i].d==s[sn].d)goto nex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap2[n.d][n.y][n.x]=1;\n\t\t\t\t//printf(\"  %d %d %d\\n\",s[sn].y,s[sn].x,s[sn].d);\n\t\t\t\t//for(i=0;i<sn;i++){\n\t\t\t\t//\tif(s[i].x==s[sn].x && s[i].y==s[sn].y && s[i].d==s[sn].d)goto nex;\n\t\t\t\t//}\n\t\t\t\tif(sn==l){\n\t\t\t\t\tf=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\ts[sn].d=rotate(s[sn].d);\n\t\t\t\t//printf(\"   %d %d %d\\n\",s[sn].y,s[sn].x,s[sn].d);\n\t\t\t}\n\t\t}\n\t\tnex:\n\t\tif(f==0)z=(l-i)%(sn-i)+i;\n\t\telse z=sn;\n\t\tprintf(\"%d %d (%d)\",s[z].y,s[z].x,s[z].d);\n\t\tif(s[z].d==0)printf(\"E\\n\");\n\t\telse if(s[z].d==1)printf(\"S\\n\");\n\t\telse if(s[z].d==2)printf(\"W\\n\");\n\t\telse if(s[z].d==3)printf(\"N\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar M[105][105],c,D[5]=\"NESW\";\nint H,W,sh,sw,t[105][105][4],mv[4]={-1,0,1,0},d;\nunsigned long long int L,i,j;\nint out(int a,int b){return 0>a||a>=b;}\nint main()\n{\n\tfor(;scanf(\"%d%d%lld\\n\",&H,&W,&L),H;)\n\t{\n\t\tmemset(t,-1,sizeof(t));\n\t\tfor(i=0;i<H;i++)\n\t\t\tfor(j=0;j<=W;j++)\n\t\t\t{\n\t\t\t\tc=getchar();\n\t\t\t\tif('A'<c&&c<'Z')\n\t\t\t\t{\n\t\t\t\t\td=c=='N'?0:c=='E'?1:c=='S'?2:3;\n\t\t\t\t\tsh=i;sw=j;M[i][j]='.';\n\t\t\t\t\tt[sh][sw][d]=0;\n\t\t\t\t}\n\t\t\t\telse M[i][j]=c;\n\t\t\t}\n\t\tfor(i=0;i<L;)\n\t\t{\n\t\t\tif(out(sh+mv[d],H)||out(sw+mv[(d+1)%4],W)||M[sh+mv[d]][sw+mv[(d+1)%4]]=='#')\n\t\t\t{\n\t\t\t\td=(d+1)%4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(t[sh][sw][d]<i)\n\t\t\t{\n\t\t\t\tL=(L-i)%(i-t[sh][sw][d]);\n\t\t\t\ti=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsh+=mv[d];\n\t\t\tsw+=mv[(d+1)%4];\n\t\t\tt[sh][sw][d]=++i;\n\t\t}\n\t\tprintf(\"%d %d %c\\n\",sh+1,sw+1,D[d]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "X[]={0,1,0,-1},Y[]={-1,0,1,0},f[109][109],g[109][109][4];char s[109],*D=\"NESW\";\nmain(h,w,z,x,y,c,l,i,j,k){for(;scanf(\"%d%d%d\",&h,&w,&l),h;printf(\"%d %d %c\\n\",y,x,D[z])){\n\tmemset(f,1,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(i=0;i<h;i++)for(scanf(\"%s\",s),j=0;j<w;j++){\n\t\tfor(k=0;k<4;k++)if(s[j]==D[k])x=j+1,y=i+1,z=k;\n\t\tif(s[j]!='#')f[i+1][j+1]=0;\n\t}\n\tfor(c=0;l;l--,c++){\n\t\tif(g[y][x][z]&&(l%=c-g[y][x][z])==0)break;\n\t\tfor(g[y][x][z]=c;;z=(z+1)%4)if(!f[y+Y[z]][x+X[z]]){x+=X[z];y+=Y[z];break;}\n\t}\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "X[]={0,1,0,-1},Y[]={-1,0,1,0},f[109][109],g[109][109][4];char s[109],*D=\"NESW\";\nmain(h,w,z,x,y,c,l,i,j,k){for(;scanf(\"%d%d%d\",&h,&w,&l),h;printf(\"%d %d %c\\n\",y,x,D[z])){\n\tmemset(f,1,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(i=0;i<h;i++)for(scanf(\"%s\",s),j=0;j<w;j++){\n\t\tfor(k=0;k<4;k++)if(s[j]==D[k])x=j+1,y=i+1,z=k;\n\t\tif(s[j]!='#')f[i+1][j+1]=0;\n\t}\n\tfor(c=0;l;l--,c++){\n\t\tif(g[y][x][z]&&(l%=c-g[y][x][z])==0)break;\n\t\tfor(g[y][x][z]=c;;z=(z+1)%4)if(!f[y+Y[z]][x+X[z]]){x+=X[z];y+=Y[z];break;}\n\t}\n}}"
  },
  {
    "language": "C",
    "code": "X[]={0,1,0,-1},Y[]={-1,0,1,0},f[109][109],g[109][109][4];char s[109],*D=\"NESW\";\nmain(h,w,z,x,y,c,i,j,k){long long l;for(;scanf(\"%d%d%lld\",&h,&w,&l),h;printf(\"%d %d %c\\n\",y,x,D[z])){\n\tmemset(f,1,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(i=0;i<h;i++)for(scanf(\"%s\",s),j=0;j<w;j++){\n\t\tfor(k=0;k<4;k++)if(s[j]==D[k])x=j+1,y=i+1,z=k;\n\t\tif(s[j]!='#')f[i+1][j+1]=0;\n\t}\n\tfor(c=0;l;l--,c++){\n\t\tif(g[y][x][z]&&(l%=c-g[y][x][z])==0)break;\n\t\tfor(g[y][x][z]=c;;z=(z+1)%4)if(!f[y+Y[z]][x+X[z]]){x+=X[z];y+=Y[z];break;}\n\t}\n}exit(0);}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    val direction = arrayOf(Point(0, -1), Point(1, 0), Point(0, 1), Point(-1, 0))\n    while(true){\n        val (h, w, l) = readLine()!!.trim().split(' ')\n        if (h == \"0\" && w == \"0\" && l == \"0\") return\n        val height = h.toInt()\n        val width = w.toInt()\n        val step = l.toLong()\n        val state = Array(height){readLine()!!.trim()}\n        val start = (0 until height).mapNotNull { y -> (0 until width).find{ x -> state[y][x] != '#' && state[y][x] != '.'}?.let{Point(it, y)} }.first()\n        val initialDir = when(state[start.y][start.x]){\n            'N' -> 0\n            'E' -> 1\n            'S' -> 2\n            'W' -> 3\n            else -> TODO()\n        }\n        val memo = Array(4){Array(height){IntArray(width){-1}}}\n        var count = 0\n        var pos = start\n        var dir = initialDir\n        var lastMoved = start\n        var lastDir = initialDir\n        while(step > count && memo[dir][pos.y][pos.x] == -1){\n            memo[dir][pos.y][pos.x] = count\n            val suspect = pos + direction[dir]\n            if (suspect.y in state.indices && suspect.x in state[suspect.y].indices && state[suspect.y][suspect.x] != '#') {\n                pos = suspect\n                ++count\n                lastMoved = pos\n                lastDir = dir\n            }else {\n                dir = (dir + 1) % 4\n            }\n        }\n        val rest = (step - count) % (count - memo[dir][pos.y][pos.x])\n        pos = lastMoved\n        dir = lastDir\n        repeat(rest.toInt()){\n            var suspect = pos + direction[dir]\n            while (suspect.y !in state.indices || suspect.x !in state[suspect.y].indices || state[suspect.y][suspect.x] == '#') {\n                dir = (dir + 1) % 4\n                suspect = pos + direction[dir]\n            }\n            pos = suspect\n        }\n        println(\"${pos.y + 1} ${pos.x + 1} ${arrayOf('N', 'E', 'S', 'W')[dir]}\")\n    }\n}\ndata class Point(val x: Int, val y: Int) {\n    operator fun plus(that: Point): Point = Point(x + that.x, y + that.y)\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new B(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass B implements Runnable{\n\t\tB(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tL=sc.nextLong();\n\t\t\t\tif((W|(H|L))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint W,H;\n\t\tlong L;\n\t\tint[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tString[] vv={\"N\",\"E\",\"S\",\"W\"};\n\t\t\n\t\tvoid solve(){\n\t\t\tint sx=-1,sy=-1,sd=-1;\n\t\t\tboolean[][] map=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tmap[x][y]=(line.charAt(x)!='#');\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(x))){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t\tswitch(line.charAt(x)){\n\t\t\t\t\t\tcase 'N':\tsd=0;\tbreak;\n\t\t\t\t\t\tcase 'E':\tsd=1;\tbreak;\n\t\t\t\t\t\tcase 'S':\tsd=2;\tbreak;\n\t\t\t\t\t\tcase 'W':\tsd=3;\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<State> rec=new ArrayList<State>();\n\t\t\tState last=new State(sx,sy,sd,0,0L);\n\t\t\trec.add(last.clone());\n\t\t\tlong cycle=-1L;\n\t\t\tint csidx=-1;\n\t\t\twhile(true){\n\t\t\t\tint xx=last.x,yy=last.y,dd=last.d;\n\t\t\t\twhile(true){\n\t\t\t\t\txx=last.x+vx[dd];\n\t\t\t\t\tyy=last.y+vy[dd];\n\t\t\t\t\tif((0<=xx && xx<W && 0<=yy && yy<H) && map[xx][yy]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdd=(dd+1)%4;\n\t\t\t\t}\n\t\t\t\tint cnt=1;\n\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\txx+=vx[dd];\n\t\t\t\t\tyy+=vy[dd];\n\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H) || !map[xx][yy]){\n\t\t\t\t\t\txx-=vx[dd];\n\t\t\t\t\t\tyy-=vy[dd];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tState next=new State(xx,yy,dd,cnt,last.step+cnt);\n\t\t\t\tfor(int j=0; j<rec.size(); j++){\n\t\t\t\t\tState s=rec.get(j);\n\t\t\t\t\tif(next.x==s.x && next.y==s.y && next.d==s.d){\n\t\t\t\t\t\tcycle=next.step-s.step;\n\t\t\t\t\t\tL-=next.step;\n\t\t\t\t\t\tcsidx=j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trec.add(next);\n\t\t\t\tif(cycle>0)\tbreak;\n\t\t\t\tlast=next.clone();\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(\"L\"+L);\n\t\t\t//System.out.println(rec);\n\t\t\t\n\t\t\tlong remain=L%cycle;\n\t\t\tif(remain==0){\n\t\t\t\tState s=rec.get(rec.size()-1);\n\t\t\t\t// OK\n\t\t\t\t//System.out.println(\"ANS-D\");\n\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=csidx; i<rec.size(); i++){\n\t\t\t\tState s=rec.get(i);\n\t\t\t\tif(remain>s.cnt)\tremain-=s.cnt;\n\t\t\t\telse if(remain==s.cnt){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-B\");\n\t\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// NG\n\t\t\t\t\t//System.out.println(\"ANS-C\");\n\t\t\t\t\tint idx=i-1<csidx?(rec.size()-1):i-1;\n\t\t\t\t\tState s2=rec.get(idx);\n\t\t\t\t\tint r=(int)(s.cnt-remain),xx=s2.x+(vx[s.d]*r)+1,yy=s2.y+(vy[s.d]*r)+1;\n\t\t\t\t\tSystem.out.println(yy+\" \"+xx+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint x,y,d,cnt;\n\t\t\tlong step;\n\t\t\tState(int x,int y,int d,int cnt,long step){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.cnt=cnt;\n\t\t\t\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public State clone(){\n\t\t\t\treturn new State(x,y,d,cnt,step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" D:\"+d+\" STEP:\"+step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass C implements Runnable{\n\t\tC(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tline=sc.next();\n\t\t\t\tif(line.equals(\"#\"))\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n\t\t\tint len=line.length();\n\t\t\tint[][][][] dp=new int[len+1][3][3][2];\n\t\t\tfor(int i=0; i<len; i++)for(int j=0; j<3; j++)for(int k=0; k<3; k++)for(int m=0; m<2; m++)\tdp[i][j][k][m]=1<<29;\n\t\t\tint[] v={1,0,1,2,0,2,0,1,2};\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tint d=line.charAt(i-1)-'0',now=v[d];\n\t\t\t\tfor(int r=0; r<3; r++){\n\t\t\t\t\tfor(int l=0; l<3; l++){\n\t\t\t\t\t\tfor(int b=0; b<2; b++){\n\t\t\t\t\t\t\t// right foot\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// left foot\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new B(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass B implements Runnable{\n\t\tB(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tL=sc.nextLong();\n\t\t\t\tif((W|(H|L))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint W,H;\n\t\tlong L;\n\t\tint[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tString[] vv={\"N\",\"E\",\"S\",\"W\"};\n\t\t\n\t\tvoid solve(){\n\t\t\tint sx=-1,sy=-1,sd=-1;\n\t\t\tboolean[][] map=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tmap[x][y]=(line.charAt(x)!='#');\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(x))){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t\tswitch(line.charAt(x)){\n\t\t\t\t\t\tcase 'N':\tsd=0;\tbreak;\n\t\t\t\t\t\tcase 'E':\tsd=1;\tbreak;\n\t\t\t\t\t\tcase 'S':\tsd=2;\tbreak;\n\t\t\t\t\t\tcase 'W':\tsd=3;\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<State> rec=new ArrayList<State>();\n\t\t\tState last=new State(sx,sy,sd,0,0L);\n\t\t\trec.add(last.clone());\n\t\t\tlong cycle=-1L;\n\t\t\tint csidx=-1;\n\t\t\twhile(true){\n\t\t\t\tint xx=last.x,yy=last.y,dd=last.d;\n\t\t\t\twhile(true){\n\t\t\t\t\txx=last.x+vx[dd];\n\t\t\t\t\tyy=last.y+vy[dd];\n\t\t\t\t\tif((0<=xx && xx<W && 0<=yy && yy<H) && map[xx][yy]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdd=(dd+1)%4;\n\t\t\t\t}\n\t\t\t\tint cnt=1;\n\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\txx+=vx[dd];\n\t\t\t\t\tyy+=vy[dd];\n\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H) || !map[xx][yy]){\n\t\t\t\t\t\txx-=vx[dd];\n\t\t\t\t\t\tyy-=vy[dd];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tState next=new State(xx,yy,dd,cnt,last.step+cnt);\n\t\t\t\tfor(int j=0; j<rec.size(); j++){\n\t\t\t\t\tState s=rec.get(j);\n\t\t\t\t\tif(next.x==s.x && next.y==s.y && next.d==s.d){\n\t\t\t\t\t\tcycle=next.step-s.step;\n\t\t\t\t\t\tL-=next.step;\n\t\t\t\t\t\tcsidx=j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trec.add(next);\n\t\t\t\tif(cycle>0)\tbreak;\n\t\t\t\tlast=next.clone();\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(\"L\"+L);\n\t\t\t//System.out.println(rec);\n\t\t\t\n\t\t\tlong remain=L%cycle;\n\t\t\tif(remain==0){\n\t\t\t\tState s=rec.get(rec.size()-1);\n\t\t\t\t// OK\n\t\t\t\t//System.out.println(\"ANS-D\");\n\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=csidx; i<rec.size(); i++){\n\t\t\t\tState s=rec.get(i);\n\t\t\t\tif(remain>s.cnt)\tremain-=s.cnt;\n\t\t\t\telse if(remain==s.cnt){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-B\");\n\t\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// NG\n\t\t\t\t\t//System.out.println(\"ANS-C\");\n\t\t\t\t\tint idx=i-1<csidx?(rec.size()-1):i-1;\n\t\t\t\t\tState s2=rec.get(idx);\n\t\t\t\t\tint r=(int)remain,xx=s2.x+(vx[s.d]*r)+1,yy=s2.y+(vy[s.d]*r)+1;\n\t\t\t\t\tSystem.out.println(yy+\" \"+xx+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint x,y,d,cnt;\n\t\t\tlong step;\n\t\t\tState(int x,int y,int d,int cnt,long step){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.cnt=cnt;\n\t\t\t\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public State clone(){\n\t\t\t\treturn new State(x,y,d,cnt,step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" D:\"+d+\" STEP:\"+step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass C implements Runnable{\n\t\tC(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tline=sc.next();\n\t\t\t\tif(line.equals(\"#\"))\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n\t\t\tint len=line.length();\n\t\t\tint[][][][] dp=new int[len+1][3][3][2];\n\t\t\tfor(int i=0; i<len; i++)for(int j=0; j<3; j++)for(int k=0; k<3; k++)for(int m=0; m<2; m++)\tdp[i][j][k][m]=1<<29;\n\t\t\tint[] v={1,0,1,2,0,2,0,1,2};\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tint d=line.charAt(i-1)-'0',now=v[d];\n\t\t\t\tfor(int r=0; r<3; r++){\n\t\t\t\t\tfor(int l=0; l<3; l++){\n\t\t\t\t\t\tfor(int b=0; b<2; b++){\n\t\t\t\t\t\t\t// right foot\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// left foot\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic BigInteger one=BigInteger.ONE,two=new BigInteger(\"2\"),zero=BigInteger.ZERO;\n\tstatic String map[];\n\tstatic BigInteger vis[][][];\n\tstatic int h=1,w=1;\n\tstatic boolean modswitch;\n\tprivate static Node dfs(Node n){\n\t\t//System.out.println(n.x+\" \"+n.y+\" \"+n.dir+\" left==\"+n.stepleft);\n\t\tint d=0;\n\t\tswitch(n.dir){\n\t\tcase'N':d=0;break;\n\t\tcase'S':d=1;break;\n\t\tcase'E':d=2;break;\n\t\tcase'W':d=3;\n\t\t}\n\t\tif(n.stepleft.equals(zero))return n;\n\t\tif(!vis[n.x][n.y][d].equals(zero)&&modswitch){\n\t\t\t//System.out.println(\"mod==\"+vis[n.x][n.y][d].subtract(n.stepleft));\n\t\t\tn.stepleft=n.stepleft.mod(vis[n.x][n.y][d].subtract(n.stepleft));\n\t\t\tmodswitch=false;\n\t\t}\n\t\telse vis[n.x][n.y][d]=n.stepleft;\n\t\tif(n.stepleft.equals(zero))return n;\n\t\twhile(!n.goable()){\n\t\t\t//System.out.println(\"turning\");\n\t\t\tn.turn();\n\t\t}\n\t\tswitch(n.dir){\n\t\tcase'N':return dfs(new Node(n.x-1,n.y,n.dir,n.stepleft.subtract(one)));\n\t\tcase'E':return dfs(new Node(n.x,n.y+1,n.dir,n.stepleft.subtract(one)));\n\t\tcase'S':return dfs(new Node(n.x+1,n.y,n.dir,n.stepleft.subtract(one)));\n\t\tdefault:return dfs(new Node(n.x,n.y-1,n.dir,n.stepleft.subtract(one)));\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tBigInteger l=one;\n\t\twhile(h!=0||w!=0||!l.equals(zero)){\n\t\t\tmodswitch=true;\n\t\t\th=in.nextInt();\n\t\t\tw=in.nextInt();\n\t\t\tl=new BigInteger(in.next());\n\t\t\tvis=new BigInteger[h][w][4];\n\t\t\tmap=new String[h];\n\t\t\tNode start = null;\n\t\t\t//System.out.println(h+\" \"+w+\" \"+l);\n\t\t\tin.nextLine();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i]=in.nextLine();\n\t\t\t\t//System.out.println(map[i]);\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tchar c=map[i].charAt(j);\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tvis[i][j][k]=zero;\n\t\t\t\t\t}\n\t\t\t\t\tif(c!='.'&&c!='#'){\n\t\t\t\t\t\tstart=new Node(i,j,c,l);\n\t\t\t\t\t\tmap[i].replace(map[i].charAt(j),'.');\n\t\t\t\t\t\t//System.out.println(i+\" \"+j+\" \"+c+\" \"+l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart=dfs(start);\n\t\t\tSystem.out.println((start.x+1)+\" \"+(start.y+1)+\" \"+start.dir);\n\t\t}\n\t}\nstatic class Node{\n\tint x,y;\n\tchar dir;\n\tBigInteger stepleft;\n\tpublic boolean goable(){\n\t\tswitch(this.dir){\n\t\tcase'N':return x>0&&map[x-1].charAt(y)!='#';\n\t\tcase'S':return x+1<h&&map[x+1].charAt(y)!='#';\n\t\tcase'E':return y+1<w&&map[x].charAt(y+1)!='#';\n\t\tcase'W':return y>0&&map[x].charAt(y-1)!='#';\n\t\t}\n\t\treturn false;\n\t}\n\tprivate void turn(){\n\t\tswitch(this.dir){\n\t\tcase'N':this.dir='E';break;\n\t\tcase'S':this.dir='W';break;\n\t\tcase'E':this.dir='S';break;\n\t\tcase'W':this.dir='N';\n\t\t}\n\t}\n\tpublic Node(int x,int y,char dir,BigInteger stepleft){\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.dir = dir;\n\t\tthis.stepleft = stepleft;\n\t}\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint NORTH = 0, EAST = 1, SOUTH = 2, WEST = 3;\n\tString nesw = \"NESW\";\n\tint MAX = 10000;\n\tint[] vx = {0, 1, 0, -1};\n\tint[] vy = {-1, 0, 1, 0};\n\t\n\tint[] xlist = new int[10010];\n\tint[] ylist = new int[10010];\n\tint[] dirlist = new int[10010];\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\t\n\tlong getKey(long x, long y, long dir) {\n\t\treturn x * MAX * 4 + y * 4 + dir; \n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint H = in.nextInt(), W = in.nextInt();\n\t\t\tlong L = in.nextLong();\n\t\t\tif (H == 0) break;\n\t\t\tint x = -1, y = -1, dir = -1;\n\t\t\tchar[][] c = new char[H][];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tc[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tswitch (c[i][j]) {\n\t\t\t\t\tcase 'E' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'N' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrays.fill(xlist, -1);\n\t\t\tArrays.fill(ylist, -1);\n\t\t\tArrays.fill(dirlist, -1);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\t\twhile (cnt < L) {\n\t\t\t\tif (map.containsKey(getKey(x, y, dir))) break;\n\t\t\t\t\n\t\t\t\tif (xlist[cnt] == -1) {\n\t\t\t\t\txlist[cnt] = x;\n\t\t\t\t\tylist[cnt] = y;\n\t\t\t\t\tdirlist[cnt] = dir;\n//\t\t\t\t\tSystem.out.println(cnt + \" : \" + (y+1) + \" \" + (x+1) + \" \" + nesw.charAt(dir));\n\t\t\t\t}\n\t\t\t\tmap.put(getKey(x, y, dir), cnt++);\n\t\t\t\tint nx = x + vx[dir], ny = y + vy[dir];\n\t\t\t\tif (!inside(nx, ny, W, H) || (inside(nx, ny, W, H) && c[ny][nx] == '#')) {\n\t\t\t\t\tnx = x;\n\t\t\t\t\tny = y;\n\t\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t}\n\t\t\t\n\t\t\tif (cnt != L) {\n\t\t\t\tlong max = cnt, min = map.get(getKey(x, y, dir));\n\t\t\t\tint key = (max == min) ? (int) min : (int) ((L - min) % (max - min) + min);\n//\t\t\t\tSystem.out.println(max + \" \" + min);\n\t\t\t\tx = xlist[key];\n\t\t\t\ty = ylist[key];\n\t\t\t\tdir = dirlist[key];\n\t\t\t}\t\t\n\t\t\tSystem.out.println((y+1) + \" \" + (x+1) + \" \" + nesw.charAt(dir));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { -1, 0, 1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\tstatic int H, W;\n\tstatic boolean[][] f;\n\tstatic int[][] idx, dir;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tlong L = sc.nextLong();\n\t\t\tif (H == 0) break;\n\t\t\tf = new boolean[H + 2][W + 2];\n\t\t\tidx = new int[H + 2][W + 2];\n\t\t\tdir = new int[H + 2][W + 2];\n\t\t\tint cr = 0;\n\t\t\tint cc = 0;\n\t\t\tint cd = 0;\n\t\t\tArrays.fill(f[0], true);\n\t\t\tArrays.fill(f[H + 1], true);\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i + 1][0] = f[i + 1][W + 1] = true;\n\t\t\t\tchar[] row = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (row[j] == '#') {\n\t\t\t\t\t\tf[i + 1][j + 1] = true;\n\t\t\t\t\t} else if (row[j] == '.') {\n\t\t\t\t\t\t// nop\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcr = i + 1;\n\t\t\t\t\t\tcc = j + 1;\n\t\t\t\t\t\tcd = \"NESW\".indexOf(row[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint turn = 0;\n\t\t\tdo {\n\t\t\t\tidx[cr][cc] = turn;\n\t\t\t\tdir[cr][cc] = cd;\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tint nr = cr + DR[(cd + i) % 4];\n\t\t\t\t\tint nc = cc + DC[(cd + i) % 4];\n\t\t\t\t\tif (!f[nr][nc]) {\n\t\t\t\t\t\tcd = (cd + i) % 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcr += DR[cd];\n\t\t\t\tcc += DC[cd];\n\t\t\t\t++turn;\n\t\t\t} while (idx[cr][cc] == 0);\n\t\t\tif (idx[cr][cc] <= L) {\n\t\t\t\tint loop = turn - idx[cr][cc];\n\t\t\t\tL = idx[cr][cc] + (L - idx[cr][cc]) % loop;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\t\tif (idx[i][j] == L) {\n\t\t\t\t\t\tSystem.out.println(i + \" \" + j + \" \" + \"NESW\".charAt(dir[i][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n \n \npublic class Main{\n     \n\tpublic static final int DIRS = 4;\n\t\n\tpublic static final int NORTH = 0;\n\tpublic static final int EAST  = 1;\n\tpublic static final int SOUTH = 2;\n\tpublic static final int WEST  = 3;\n\tpublic static final String[] dir_str = new String[]{\"N\", \"E\", \"S\", \"W\"};\n\t\n\tpublic static final int[] vx = new int[]{0, 1, 0, -1};\n\tpublic static final int[] vy = new int[]{-1, 0, 1, 0};\n\t\n\t\n    public static void main(String[] args){\n    \t\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \twhile(true){\n    \t\tfinal int H = sc.nextInt();\n    \t\tfinal int W = sc.nextInt();\n    \t\tfinal long L = sc.nextLong();\n    \t\t\n    \t\tif(H == 0 && W == 0 && L == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tint sx = -1;\n    \t\tint sy = -1;\n    \t\tint sdir = -1;\n    \t\tboolean[][] is_wall = new boolean[H][W];\n    \t\tfor(int i = 0; i < H; i++){\n    \t\t\tchar[] inputs = sc.next().toCharArray();\n    \t\t\t\n    \t\t\tfor(int j = 0; j < W; j++){\n    \t\t\t\tif(inputs[j] == '#'){\n    \t\t\t\t\tis_wall[i][j] = true;\n    \t\t\t\t}else if(inputs[j] == 'N'){\n    \t\t\t\t\tsx = j;\n    \t\t\t\t\tsy = i;\n    \t\t\t\t\tsdir = NORTH;\n    \t\t\t\t}else if(inputs[j] == 'E'){\n    \t\t\t\t\tsx = j;\n    \t\t\t\t\tsy = i;\n    \t\t\t\t\tsdir = EAST;\n    \t\t\t\t}else if(inputs[j] == 'S'){\n    \t\t\t\t\tsx = j;\n    \t\t\t\t\tsy = i;\n    \t\t\t\t\tsdir = SOUTH;\n    \t\t\t\t}else if(inputs[j] == 'W'){\n    \t\t\t\t\tsx = j;\n    \t\t\t\t\tsy = i;\n    \t\t\t\t\tsdir = WEST;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong[][][] visit_time = new long[H][W][DIRS];\n    \t\tfor(int i = 0; i < H; i++){\n    \t\t\tfor(int j = 0; j < W; j++){\n    \t\t\t\tfor(int k = 0; k < DIRS; k++){\n    \t\t\t\t\tvisit_time[i][j][k] = -1;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tint x = sx;\n    \t\tint y = sy;\n    \t\tint dir = sdir;\n    \t\tlong time = 0;\n    \t\t\n    \t\twhile(time < L){\n    \t\t\t//System.out.println(x + \" \" + y + \" \" + dir + \" \" + time);\n    \t\t\t\n    \t\t\tif(visit_time[y][x][dir] >= 0){\n    \t\t\t\tfinal long diff_time = time - visit_time[y][x][dir];\n    \t\t\t\ttime += ((L - time) / diff_time) * diff_time;\n    \t\t\t\t\n    \t\t\t\tif(time >= L){\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tfor(int i = 0; i < H; i++){\n    \t    \t\t\tfor(int j = 0; j < W; j++){\n    \t    \t\t\t\tfor(int k = 0; k < DIRS; k++){\n    \t    \t\t\t\t\tvisit_time[i][j][k] = -1;\n    \t    \t\t\t\t}\n    \t    \t\t\t}\n    \t    \t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tvisit_time[y][x][dir] = time;\n    \t\t\t\n    \t\t\tfor(int offset = 0; offset < DIRS; offset++){\n    \t\t\t\tfinal int ndir = (dir + offset) % 4;\n    \t\t\t\tfinal int nx = x + vx[ndir];\n    \t\t\t\tfinal int ny = y + vy[ndir];\n    \t\t\t\t\n    \t\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}if(is_wall[ny][nx]){\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}else{\n    \t\t\t\t\tx = nx;\n    \t\t\t\t\ty = ny;\n    \t\t\t\t\tdir = ndir;\n    \t\t\t\t\ttime++;\n    \t\t\t\t\t\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t//System.out.println(time);\n    \t\tSystem.out.println((y + 1) + \" \" + (x + 1) + \" \" + dir_str[dir]);\n    \t\t\n    \t}\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new B(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass C implements Runnable{\n\t\tC(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tline=sc.next();\n\t\t\t\tif(line.equals(\"#\"))\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n//\t\t\tint[][][][] \n\t\t\t\n\t\t}\n\t}\n\t\n\tclass B implements Runnable{\n\t\tB(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tL=sc.nextLong();\n\t\t\t\tif((W|(H|L))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint W,H;\n\t\tlong L;\n\t\tint[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tString[] vv={\"N\",\"E\",\"S\",\"W\"};\n\t\t\n\t\tvoid solve(){\n\t\t\tint sx=-1,sy=-1,sd=-1;\n\t\t\tboolean[][] map=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tmap[x][y]=(line.charAt(x)!='#');\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(x))){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t\tswitch(line.charAt(x)){\n\t\t\t\t\t\tcase 'N':\tsd=0;\tbreak;\n\t\t\t\t\t\tcase 'E':\tsd=1;\tbreak;\n\t\t\t\t\t\tcase 'S':\tsd=2;\tbreak;\n\t\t\t\t\t\tcase 'W':\tsd=3;\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<State> rec=new ArrayList<State>();\n\t\t\tState last=new State(sx,sy,sd,0,0L);\n\t\t\trec.add(last.clone());\n\t\t\tlong cycle=-1L;\n\t\t\tint csidx=-1;\n\t\t\twhile(true){\n\t\t\t\tint xx=last.x,yy=last.y,dd=last.d;\n\t\t\t\twhile(true){\n\t\t\t\t\txx=last.x+vx[dd];\n\t\t\t\t\tyy=last.y+vy[dd];\n\t\t\t\t\tif((0<=xx && xx<W && 0<=yy && yy<H) && map[xx][yy]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdd=(dd+1)%4;\n\t\t\t\t}\n\t\t\t\tint cnt=1;\n\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(xx+\",\"+yy+\" D:\"+dd);\n\t\t\t\t\t\n\t\t\t\t\txx+=vx[dd];\n\t\t\t\t\tyy+=vy[dd];\n\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H) || !map[xx][yy]){\n\t\t\t\t\t\txx-=vx[dd];\n\t\t\t\t\t\tyy-=vy[dd];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tState next=new State(xx,yy,dd,cnt,last.step+cnt);\n\t\t\t\tfor(int j=0; j<rec.size(); j++){\n\t\t\t\t\tState s=rec.get(j);\n\t\t\t\t\tif(next.x==s.x && next.y==s.y && next.d==s.d){\n\t\t\t\t\t\tcycle=next.step-s.step;\n\t\t\t\t\t\tL-=next.step;\n\t\t\t\t\t\tcsidx=j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trec.add(next);\n\t\t\t\tif(cycle>0)\tbreak;\n\t\t\t\tlast=next.clone();\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(\"L\"+L);\n\t\t\t//System.out.println(rec);\n\t\t\t\n\t\t\tlong remain=L%cycle;\n\t\t\tif(remain==0){\n\t\t\t\tState s=rec.get(rec.size()-1);\n\t\t\t\t// OK\n\t\t\t\t//System.out.println(\"ANS-D\");\n\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=csidx; i<rec.size(); i++){\n\t\t\t\tState s=rec.get(i);\n\t\t\t\tif(remain>s.cnt)\tremain-=s.cnt;\n\t\t\t\telse if(remain==s.cnt){\n\t\t\t\t\t// ?\n\t\t\t\t\t//System.out.println(\"ANS-B\");\n\t\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-C\");\n\t\t\t\t\tint idx=i-1<csidx?(rec.size()-1):i-1;\n\t\t\t\t\ts=rec.get(idx);\n\t\t\t\t\tint r=(int)(remain-s.cnt),xx=s.x+(vx[s.d]*r)+1,yy=s.y+(vy[s.d]*r)+1;\n\t\t\t\t\tSystem.out.println(yy+\" \"+xx+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint x,y,d,cnt;\n\t\t\tlong step;\n\t\t\tState(int x,int y,int d,int cnt,long step){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.cnt=cnt;\n\t\t\t\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public State clone(){\n\t\t\t\treturn new State(x,y,d,cnt,step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" D:\"+d+\" STEP:\"+step;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic BigInteger one=BigInteger.ONE,two=new BigInteger(\"2\"),zero=BigInteger.ZERO;\n\tstatic String map[];\n\tstatic BigInteger vis[][][];\n\tstatic int h=1,w=1;\n\tstatic boolean modswitch;\n\tprivate static Node dfs(Node n){\n\t\t//System.out.println(n.x+\" \"+n.y+\" \"+n.dir+\" left==\"+n.stepleft);\n\t\tint d=0;\n\t\tswitch(n.dir){\n\t\tcase'N':d=0;break;\n\t\tcase'S':d=1;break;\n\t\tcase'E':d=2;break;\n\t\tcase'W':d=3;\n\t\t}\n\t\tif(n.stepleft.equals(zero))return n;\n\t\tif(!vis[n.x][n.y][d].equals(zero)&&modswitch){\n\t\t\t//System.out.println(\"mod==\"+vis[n.x][n.y][d].subtract(n.stepleft));\n\t\t\tn.stepleft=n.stepleft.mod(vis[n.x][n.y][d].subtract(n.stepleft));\n\t\t\tmodswitch=false;\n\t\t}\n\t\telse vis[n.x][n.y][d]=n.stepleft;\n\t\tif(n.stepleft.equals(zero))return n;\n\t\twhile(!n.goable()){\n\t\t\t//System.out.println(\"turning\");\n\t\t\tn.turn();\n\t\t}\n\t\tswitch(n.dir){\n\t\tcase'N':return dfs(new Node(n.x-1,n.y,n.dir,n.stepleft.subtract(one)));\n\t\tcase'E':return dfs(new Node(n.x,n.y+1,n.dir,n.stepleft.subtract(one)));\n\t\tcase'S':return dfs(new Node(n.x+1,n.y,n.dir,n.stepleft.subtract(one)));\n\t\tdefault:return dfs(new Node(n.x,n.y-1,n.dir,n.stepleft.subtract(one)));\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tBigInteger l=one;\n\t\twhile(h!=0||w!=0||!l.equals(zero)){\n\t\t\tmodswitch=true;\n\t\t\th=in.nextInt();\n\t\t\tw=in.nextInt();\n\t\t\tl=new BigInteger(in.next());\n\t\t\tif(h==0&&w==0&&l.equals(zero))break;\n\t\t\tvis=new BigInteger[h][w][4];\n\t\t\tmap=new String[h];\n\t\t\tNode start = null;\n\t\t\t//System.out.println(h+\" \"+w+\" \"+l);\n\t\t\tin.nextLine();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i]=in.nextLine();\n\t\t\t\t//System.out.println(map[i]);\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tchar c=map[i].charAt(j);\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tvis[i][j][k]=zero;\n\t\t\t\t\t}\n\t\t\t\t\tif(c!='.'&&c!='#'){\n\t\t\t\t\t\tstart=new Node(i,j,c,l);\n\t\t\t\t\t\tmap[i].replace(map[i].charAt(j),'.');\n\t\t\t\t\t\t//System.out.println(i+\" \"+j+\" \"+c+\" \"+l);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart=dfs(start);\n\t\t\tSystem.out.println((start.x+1)+\" \"+(start.y+1)+\" \"+start.dir);\n\t\t}\n\t}\nstatic class Node{\n\tint x,y;\n\tchar dir;\n\tBigInteger stepleft;\n\tpublic boolean goable(){\n\t\tswitch(this.dir){\n\t\tcase'N':return x>0&&map[x-1].charAt(y)!='#';\n\t\tcase'S':return x+1<h&&map[x+1].charAt(y)!='#';\n\t\tcase'E':return y+1<w&&map[x].charAt(y+1)!='#';\n\t\tcase'W':return y>0&&map[x].charAt(y-1)!='#';\n\t\t}\n\t\treturn false;\n\t}\n\tprivate void turn(){\n\t\tswitch(this.dir){\n\t\tcase'N':this.dir='E';break;\n\t\tcase'S':this.dir='W';break;\n\t\tcase'E':this.dir='S';break;\n\t\tcase'W':this.dir='N';\n\t\t}\n\t}\n\tpublic Node(int x,int y,char dir,BigInteger stepleft){\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.dir = dir;\n\t\tthis.stepleft = stepleft;\n\t}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new B(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass C implements Runnable{\n\t\tC(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tline=sc.next();\n\t\t\t\tif(line.equals(\"#\"))\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n//\t\t\tint[][][][] \n\t\t\t\n\t\t}\n\t}\n\t\n\tclass B implements Runnable{\n\t\tB(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tL=sc.nextLong();\n\t\t\t\tif((W|(H|L))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint W,H;\n\t\tlong L;\n\t\tint[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tString[] vv={\"N\",\"E\",\"S\",\"W\"};\n\t\t\n\t\tvoid solve(){\n\t\t\tint sx=-1,sy=-1,sd=-1;\n\t\t\tboolean[][] map=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tmap[x][y]=(line.charAt(x)!='#');\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(x))){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t\tswitch(line.charAt(x)){\n\t\t\t\t\t\tcase 'N':\tsd=0;\tbreak;\n\t\t\t\t\t\tcase 'E':\tsd=1;\tbreak;\n\t\t\t\t\t\tcase 'S':\tsd=2;\tbreak;\n\t\t\t\t\t\tcase 'W':\tsd=3;\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<State> rec=new ArrayList<State>();\n\t\t\tState last=new State(sx,sy,sd,0,0L);\n\t\t\trec.add(last.clone());\n\t\t\tlong cycle=-1L;\n\t\t\tint csidx=-1;\n\t\t\twhile(true){\n\t\t\t\tint xx=last.x,yy=last.y,dd=last.d;\n\t\t\t\twhile(true){\n\t\t\t\t\txx=last.x+vx[dd];\n\t\t\t\t\tyy=last.y+vy[dd];\n\t\t\t\t\tif((0<=xx && xx<W && 0<=yy && yy<H) && map[xx][yy]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdd=(dd+1)%4;\n\t\t\t\t}\n\t\t\t\tint cnt=1;\n\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(xx+\",\"+yy+\" D:\"+dd);\n\t\t\t\t\t\n\t\t\t\t\txx+=vx[dd];\n\t\t\t\t\tyy+=vy[dd];\n\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H) || !map[xx][yy]){\n\t\t\t\t\t\txx-=vx[dd];\n\t\t\t\t\t\tyy-=vy[dd];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tState next=new State(xx,yy,dd,cnt,last.step+cnt);\n\t\t\t\tfor(int j=0; j<rec.size(); j++){\n\t\t\t\t\tState s=rec.get(j);\n\t\t\t\t\tif(next.x==s.x && next.y==s.y && next.d==s.d){\n\t\t\t\t\t\tcycle=next.step-s.step;\n\t\t\t\t\t\tL-=next.step;\n\t\t\t\t\t\tcsidx=j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trec.add(next);\n\t\t\t\tif(cycle>0)\tbreak;\n\t\t\t\tlast=next.clone();\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(\"L\"+L);\n\t\t\t//System.out.println(rec);\n\t\t\t\n\t\t\tlong remain=L%cycle;\n\t\t\tif(remain==0){\n\t\t\t\tState s=rec.get(rec.size()-1);\n\t\t\t\t// OK\n\t\t\t\t//System.out.println(\"ANS-D\");\n\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=csidx; i<rec.size(); i++){\n\t\t\t\tState s=rec.get(i);\n\t\t\t\tif(remain>s.cnt)\tremain-=s.cnt;\n\t\t\t\telse if(remain==s.cnt){\n\t\t\t\t\t// ?\n\t\t\t\t\t//System.out.println(\"ANS-B\");\n\t\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-C\");\n\t\t\t\t\tint idx=i-1<csidx?rec.size():i-1;\n\t\t\t\t\ts=rec.get(idx);\n\t\t\t\t\tint r=(int)(remain-s.cnt),xx=s.x+(vx[s.d]*r)+1,yy=s.y+(vy[s.d]*r)+1;\n\t\t\t\t\tSystem.out.println(yy+\" \"+xx+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint x,y,d,cnt;\n\t\t\tlong step;\n\t\t\tState(int x,int y,int d,int cnt,long step){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.cnt=cnt;\n\t\t\t\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public State clone(){\n\t\t\t\treturn new State(x,y,d,cnt,step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" D:\"+d+\" STEP:\"+step;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint N = 0, E = 1, S = 2, W = 3;\n\tString nesw = \"NESW\";\n\tint MAX = 10000;\n\tint[] vx = {0, 1, 0, -1};\n\tint[] vy = {-1, 0, 1, 0};\n\t\n\tint[] xlist = new int[10010];\n\tint[] ylist = new int[10010];\n\tint[] dirlist = new int[10010];\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\t\n\tlong getKey(long x, long y, long dir) {\n\t\treturn x * MAX * 4 + y * 4 + dir; \n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint H = in.nextInt(), W = in.nextInt();\n\t\t\tlong L = in.nextLong();\n\t\t\tif (H == 0) break;\n\t\t\tint x = -1, y = -1, dir = -1;\n\t\t\tchar[][] c = new char[H][];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tc[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tswitch (c[i][j]) {\n\t\t\t\t\tcase 'E' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = E;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'N' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = N;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = S;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = W;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrays.fill(xlist, -1);\n\t\t\tArrays.fill(ylist, -1);\n\t\t\tArrays.fill(dirlist, -1);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\t\twhile (true && cnt < L) {\n\t\t\t\tif (map.containsKey(getKey(x, y, dir))) break;\n\t\t\t\t\n\t\t\t\tif (xlist[cnt] == -1) {\n\t\t\t\t\txlist[cnt] = x;\n\t\t\t\t\tylist[cnt] = y;\n\t\t\t\t\tdirlist[cnt] = dir;\n//\t\t\t\t\tSystem.out.println(cnt + \" : \" + (y+1) + \" \" + (x+1) + \" \" + nesw.charAt(dir));\n\t\t\t\t}\n\t\t\t\tmap.put(getKey(x, y, dir), cnt++);\n\t\t\t\tint nx = x + vx[dir], ny = y + vy[dir];\n\t\t\t\tif (!inside(nx, ny, W, H) || (inside(nx, ny, W, H) && c[ny][nx] == '#')) {\n\t\t\t\t\tnx = x;\n\t\t\t\t\tny = y;\n\t\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t}\n\t\t\t\n\t\t\tif (cnt != L) {\n\t\t\t\tlong max = cnt, min = map.get(getKey(x, y, dir));\n\t\t\t\tint key = (max == min) ? (int) min : (int) ((L - min) % (max - min) + min);\n\t\t\t\t\n\t\t\t\tx = xlist[key];\n\t\t\t\ty = ylist[key];\n\t\t\t\tdir = dirlist[key];\n\t\t\t}\t\t\n\t\t\tSystem.out.println((y+1) + \" \" + (x+1) + \" \" + nesw.charAt(dir));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = sc.nextInt();\n\t\t\tlong L = sc.nextLong();\n\t\t\tint[][] dir = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };// 北、東、南、西\n\t\t\tchar[][] maze = new char[H][];\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tmaze[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tlong[][] memo = new long[10000][4];\n\t\t\t// <前のマス, 次のマス>\n\t\t\tint now = 0;\n\t\t\tint d = 0;// 向き N:0, E:1, S:2, W:3\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tfor (int j = 0; j < maze[i].length; j++) {\n\t\t\t\t\tif (maze[i][j] != '#' && maze[i][j] != '.') {\n\t\t\t\t\t\tnow = i * 100 + j;\n\t\t\t\t\t\tif (maze[i][j] == 'N') {\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t} else if (maze[i][j] == 'E') {\n\t\t\t\t\t\t\td = 1;\n\t\t\t\t\t\t} else if (maze[i][j] == 'S') {\n\t\t\t\t\t\t\td = 2;\n\t\t\t\t\t\t} else if (maze[i][j] == 'W') {\n\t\t\t\t\t\t\td = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (L > 0) {\n\t\t\t\tint x = now / 100;\n\t\t\t\tint y = now - x * 100;\n\t\t\t\tx += dir[d][0];\n\t\t\t\ty += dir[d][1];\n\t\t\t\tif (x < 0 || x >= H || y < 0 || y >= W || maze[x][y] == '#') {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint next = x * 100 + y;\n\t\t\t\tL--;\n\t\t\t\tif (memo[next][d] == 0) {\n\t\t\t\t\tmemo[next][d] = L;\n\t\t\t\t} else {\n\t\t\t\t\tlong cycle = memo[next][d] - L;\n\t\t\t\t\tL = L % cycle;\n\t\t\t\t}\n\n\t\t\t\tnow = next;\n\t\t\t}\n\n\t\t\tint x = now / 100;\n\t\t\tint y = now - x * 100;\n\t\t\tchar face = '.';\n\t\t\tif (d == 0) {\n\t\t\t\tface = 'N';\n\t\t\t} else if (d == 1) {\n\t\t\t\tface = 'E';\n\t\t\t} else if (d == 2) {\n\t\t\t\tface = 'S';\n\t\t\t} else if (d == 3) {\n\t\t\t\tface = 'W';\n\t\t\t}\n\n\t\t\tSystem.out.println((x + 1) + \" \" + (y + 1) + \" \" + face);\n\t\t\tSystem.gc();\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint NORTH = 0, EAST = 1, SOUTH = 2, WEST = 3;\n\tString nesw = \"NESW\";\n\tint MAX = 10000;\n\tint[] vx = {0, 1, 0, -1};\n\tint[] vy = {-1, 0, 1, 0};\n\t\n\tint[] xlist = new int[10010];\n\tint[] ylist = new int[10010];\n\tint[] dirlist = new int[10010];\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\t\n\tlong getKey(long x, long y, long dir) {\n\t\treturn x * MAX * 4 + y * 4 + dir; \n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint H = in.nextInt(), W = in.nextInt();\n\t\t\tlong L = in.nextLong();\n\t\t\tif (H == 0) break;\n\t\t\tint x = -1, y = -1, dir = -1;\n\t\t\tchar[][] c = new char[H][];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tc[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tswitch (c[i][j]) {\n\t\t\t\t\tcase 'E' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'N' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrays.fill(xlist, -1);\n\t\t\tArrays.fill(ylist, -1);\n\t\t\tArrays.fill(dirlist, -1);\n\t\t\t\n\t\t\tint cnt = 0, rotateCnt = 0;\n\t\t\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\t\twhile (cnt < L && rotateCnt < 4) {\n\t\t\t\tif (xlist[cnt] == -1) {\n\t\t\t\t\tif (map.containsKey(getKey(x, y, dir))) break;\n\t\t\t\t\txlist[cnt] = x;\n\t\t\t\t\tylist[cnt] = y;\n\t\t\t\t\tdirlist[cnt] = dir;\n\t\t\t\t\tmap.put(getKey(x, y, dir), cnt);\n//\t\t\t\t\tSystem.out.println(cnt + \" : \" + (y+1) + \" \" + (x+1) + \" \" + nesw.charAt(dir));\n\t\t\t\t\trotateCnt = 0;\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tint nx = x + vx[dir], ny = y + vy[dir];\n\t\t\t\tif (!inside(nx, ny, W, H) || (inside(nx, ny, W, H) && c[ny][nx] == '#')) {\n\t\t\t\t\tnx = x;\n\t\t\t\t\tny = y;\n\t\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t\t\tcnt--;\n\t\t\t\t\trotateCnt++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t}\n\t\t\t\n\t\t\tif (cnt != L) {\n\t\t\t\tlong max = cnt, min = map.get(getKey(x, y, dir));\n\t\t\t\tint key = (max == min) ? (int) min : (int) ((L - min) % (max - min) + min);\n//\t\t\t\tSystem.out.println(max + \" \" + min);\n\t\t\t\tx = xlist[key];\n\t\t\t\ty = ylist[key];\n\t\t\t\tdir = dirlist[key];\n\t\t\t}\t\t\n\t\t\tSystem.out.println((y+1) + \" \" + (x+1) + \" \" + nesw.charAt(dir));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = sc.nextInt();\n\t\t\tlong L = sc.nextLong();\n\t\t\tint[][] dir = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };// 北、東、南、西\n\t\t\tchar[][] maze = new char[H][];\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tmaze[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tHashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();\n\t\t\tint now = 0;\n\t\t\tint d = 0;// 向き N:0, E:1, S:2, W:3\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tfor (int j = 0; j < maze[i].length; j++) {\n\t\t\t\t\tif (maze[i][j] != '#' && maze[i][j] != '.') {\n\t\t\t\t\t\tnow = i * 100 + j;\n\t\t\t\t\t\tif (maze[i][j] == 'N') {\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t} else if (maze[i][j] == 'E') {\n\t\t\t\t\t\t\td = 1;\n\t\t\t\t\t\t} else if (maze[i][j] == 'S') {\n\t\t\t\t\t\t\td = 2;\n\t\t\t\t\t\t} else if (maze[i][j] == 'W') {\n\t\t\t\t\t\t\td = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashMap.put(now, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (L > 0) {\n\t\t\t\tint x = now / 100;\n\t\t\t\tint y = now - x * 100;\n\t\t\t\tx += dir[d][0];\n\t\t\t\ty += dir[d][1];\n\t\t\t\tif (x < 0 || x >= H || y < 0 || y >= W || maze[x][y] == '#') {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnow = x * 100 + y;\n\t\t\t\tL--;\n\t\t\t\tif (hashMap.get(now) == null) {\n\t\t\t\t\thashMap.put(now, d);\n\t\t\t\t} else if (hashMap.get(now) != d) {\n\t\t\t\t\thashMap.clear();\n\t\t\t\t\thashMap.put(now, d);\n\t\t\t\t} else {\n\t\t\t\t\tL = L % hashMap.size();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint x = now / 100;\n\t\t\tint y = now - x * 100;\n\t\t\tchar face = '.';\n\t\t\tif (d == 0) {\n\t\t\t\tface = 'N';\n\t\t\t} else if (d == 1) {\n\t\t\t\tface = 'E';\n\t\t\t} else if (d == 2) {\n\t\t\t\tface = 'S';\n\t\t\t} else if (d == 3) {\n\t\t\t\tface = 'W';\n\t\t\t}\n\n\t\t\tSystem.out.println((x + 1) + \" \" + (y + 1) + \" \" + face);\n\t\t\tSystem.gc();\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Infinity Maze\npublic class Main{\n\t\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\tchar[] str = {'N','E','S','W'};\n\t\n\tint h, w;\n\tlong L;\n\t\n\tvoid run()  {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\th = sc.nextInt(); w = sc.nextInt(); L = sc.nextLong();\n\t\t\tif((h|w|L)==0)break;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tint si = 0, sj = 0, d = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j]=='N'){\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\tsi = i; sj = j; d = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]=='E'){\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\tsi = i; sj = j;d = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]=='S'){\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\tsi = i; sj = j;d = 2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(map[i][j]=='W'){\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t\tsi = i; sj = j;d = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong[][][] u = new long[h][w][4];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)for(int k=0;k<4;k++)u[i][j][k] = -1;\n\t\t\tu[si][sj][d] = 0;\n\t\t\tlong step = 1;\n\t\t\tboolean skip = false;\n\t\t\twhile(step<=L){\n\t\t\t\tint ni = si+move[d][0], nj = sj+move[d][1];\n\t\t\t\tfor(;;){\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&map[ni][nj]!='#')break;\n\t\t\t\t\td = (d+1)%4;\n\t\t\t\t\tni = si+move[d][0]; nj = sj+move[d][1];\n\t\t\t\t}\n\t\t\t\tsi = ni; sj = nj;\n\t\t\t\tif(u[ni][nj][d]==-1||skip){\n\t\t\t\t\tu[ni][nj][d] = step;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tskip = true;\n\t\t\t\t\tlong dif = step-u[si][sj][d];\n\t\t\t\t\tlong x = L - step;\n\t\t\t\t\tx%=dif;\n\t\t\t\t\tstep = L-x;\n\t\t\t\t}\n\t\t\t\tstep++;\n\t\t\t}\n\t\t\tSystem.out.println((si+1)+\" \"+(sj+1)+\" \"+str[d]);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\t//2352 start\n\t\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {-1,0,1,0};\n\tint w,h;\n\t\n\tclass State {\n\t\tint x,y,dir,step;\n\n\t\tpublic State(int x, int y, int dir, int step) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.dir = dir;\n\t\t\tthis.step = step;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tlong l = sc.nextLong();\n\t\t\tif((h|w|l) == 0) break;\n\t\t\t\n\t\t\tboolean [][] isNG = new boolean[h][w];\n\t\t\tint sx = -1, sy = -1, sd = -1;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tchar c = s.charAt(j);\n\t\t\t\t\tif(c == '#'){\n\t\t\t\t\t\tisNG[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(Character.isLetter(c)){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tif(c == 'N'){\n\t\t\t\t\t\t\tsd = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c == 'E') sd = 1;\n\t\t\t\t\t\tif(c == 'S') sd = 2;\n\t\t\t\t\t\tif(c == 'W') sd = 3;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<State> open = new LinkedList<Main.State>();\n\t\t\topen.add(new State(sx, sy, sd, 0));\n\t\t\tint INF = 1 << 24;\n\t\t\tint [][][] close = new int[h][w][4];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w;j++){\n\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[sx][sy][sd] = 0;\n\t\t\tArrayList<State> steplist  = new ArrayList<Main.State>();\n\t\t\tsteplist.add(new State(sx, sy, sd, 0));\n\t\t\tint c = 1 << 24;\n\t\t\tint offset = 0;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.removeFirst();\n\t\t\t\tint xx=-1, yy=-1, nd = -1;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\txx = now.x + vx[(now.dir + i) % 4];\n\t\t\t\t\tyy = now.y + vy[(now.dir + i) % 4];\n\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\tif(isNG[yy][xx]) continue;\n\t\t\t\t\tnd = (now.dir + i) % 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(close[yy][xx][nd] != INF){\n\t\t\t\t\tc = now.step +1 - close[yy][xx][nd];\n\t\t\t\t\tl = l - close[yy][xx][nd];\n\t\t\t\t\toffset =  close[yy][xx][nd];\n\t\t\t\t}\n\t\t\t\telse if(now.step + 1 == l){\n\t\t\t\t\tsteplist.add(new State(xx, yy, nd, now.step + 1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\topen.add(new State(xx, yy, nd, now.step + 1));\n\t\t\t\t\tclose[yy][xx][nd] = now.step + 1;\n\t\t\t\t\tsteplist.add(new State(xx, yy, nd, now.step + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tint rotate = (int) (l % c);\n\t\t\tState res = steplist.get(rotate + offset);\n\t\t\tint x = res.x + 1;\n\t\t\tint y = res.y + 1;\n\t\t\tchar [] table = {'N','E','S','W'};\n\t\t\tchar dir = table[res.dir];\n\t\t\tSystem.out.println(y + \" \" + x + \" \" + dir);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0<= yy && yy < h){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { -1, 0, 1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\tstatic int H, W;\n\tstatic boolean[][] f;\n\tstatic int[][][] visit;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tH = sc.nextInt();\n\t\t\tW = sc.nextInt();\n\t\t\tlong L = sc.nextLong();\n\t\t\tif (H == 0) break;\n\t\t\tf = new boolean[H + 2][W + 2];\n\t\t\tvisit = new int[H + 2][W + 2][4];\n\t\t\tint cr = 0;\n\t\t\tint cc = 0;\n\t\t\tint cd = 0;\n\t\t\tArrays.fill(f[0], true);\n\t\t\tArrays.fill(f[H + 1], true);\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tf[i + 1][0] = f[i + 1][W + 1] = true;\n\t\t\t\tchar[] row = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (row[j] == '#') {\n\t\t\t\t\t\tf[i + 1][j + 1] = true;\n\t\t\t\t\t} else if (row[j] == '.') {\n\t\t\t\t\t\t// nop\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcr = i + 1;\n\t\t\t\t\t\tcc = j + 1;\n\t\t\t\t\t\tcd = \"NESW\".indexOf(row[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint turn = 0;\n\t\t\tdo {\n\t\t\t\tvisit[cr][cc][cd] = turn;\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tint nr = cr + DR[(cd + i) % 4];\n\t\t\t\t\tint nc = cc + DC[(cd + i) % 4];\n\t\t\t\t\tif (!f[nr][nc]) {\n\t\t\t\t\t\tcd = (cd + i) % 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcr += DR[cd];\n\t\t\t\tcc += DC[cd];\n\t\t\t\t++turn;\n\t\t\t} while (visit[cr][cc][cd] == 0);\n\t\t\tif (visit[cr][cc][cd] <= L) {\n\t\t\t\tint loop = turn - visit[cr][cc][cd];\n\t\t\t\tL = visit[cr][cc][cd] + (L - visit[cr][cc][cd]) % loop;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\tif (visit[i][j][k] == L) {\n\t\t\t\t\t\t\tSystem.out.println(i + \" \" + j + \" \" + \"NESW\".charAt(k));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = sc.nextInt();\n\t\t\tlong L = sc.nextLong();\n\t\t\tint[][] dir = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };// 北、東、南、西\n\t\t\tchar[][] maze = new char[H][];\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tmaze[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tHashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();\n\t\t\tint now = 0;\n\t\t\tint d = 0;// 向き N:0, E:1, S:2, W:3\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tfor (int j = 0; j < maze[i].length; j++) {\n\t\t\t\t\tif (maze[i][j] != '#' && maze[i][j] != '.') {\n\t\t\t\t\t\tnow = i * 100 + j;\n\t\t\t\t\t\tif (maze[i][j] == 'N') {\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t} else if (maze[i][j] == 'E') {\n\t\t\t\t\t\t\td = 1;\n\t\t\t\t\t\t} else if (maze[i][j] == 'S') {\n\t\t\t\t\t\t\td = 2;\n\t\t\t\t\t\t} else if (maze[i][j] == 'W') {\n\t\t\t\t\t\t\td = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashMap.put(now, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (L > 0) {\n\t\t\t\tint x = now / 100;\n\t\t\t\tint y = now - x * 100;\n\t\t\t\tx += dir[d][0];\n\t\t\t\ty += dir[d][1];\n\t\t\t\tif (x < 0 || x >= H || y < 0 || y >= W || maze[x][y] == '#') {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnow = x * 100 + y;\n\t\t\t\tL--;\n\t\t\t\tif (hashMap.get(now) == null) {\n\t\t\t\t\thashMap.put(now, d);\n\t\t\t\t} else if (hashMap.get(now) != d) {\n\t\t\t\t\thashMap.clear();\n\t\t\t\t\thashMap.put(now, d);\n\t\t\t\t} else {\n\t\t\t\t\tL = L % hashMap.size();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint x = now / 100;\n\t\t\tint y = now - x * 100;\n\t\t\tchar face = '.';\n\t\t\tif (d == 0) {\n\t\t\t\tface = 'N';\n\t\t\t} else if (d == 1) {\n\t\t\t\tface = 'E';\n\t\t\t} else if (d == 2) {\n\t\t\t\tface = 'S';\n\t\t\t} else if (d == 3) {\n\t\t\t\tface = 'W';\n\t\t\t}\n\n\t\t\tSystem.out.println((x + 1) + \" \" + (y + 1) + \" \" + face);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = sc.nextInt();\n\t\t\tlong L = sc.nextLong();\n\t\t\tint[][] dir = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };// 北、東、南、西\n\t\t\tchar[][] maze = new char[H][];\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tmaze[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tHashMap<Integer, ArrayList<Integer>> hashMap = new HashMap<Integer, ArrayList<Integer>>();\n\t\t\t// <前のマス, 次のマス>\n\t\t\tint now = 0;\n\t\t\tint d = 0;// 向き N:0, E:1, S:2, W:3\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tfor (int j = 0; j < maze[i].length; j++) {\n\t\t\t\t\tif (maze[i][j] != '#' && maze[i][j] != '.') {\n\t\t\t\t\t\tnow = i * 100 + j;\n\t\t\t\t\t\tif (maze[i][j] == 'N') {\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t} else if (maze[i][j] == 'E') {\n\t\t\t\t\t\t\td = 1;\n\t\t\t\t\t\t} else if (maze[i][j] == 'S') {\n\t\t\t\t\t\t\td = 2;\n\t\t\t\t\t\t} else if (maze[i][j] == 'W') {\n\t\t\t\t\t\t\td = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean rec = false;\n\t\t\twhile (L > 0) {\n\t\t\t\tint x = now / 100;\n\t\t\t\tint y = now - x * 100;\n\t\t\t\tx += dir[d][0];\n\t\t\t\ty += dir[d][1];\n\t\t\t\tif (x < 0 || x >= H || y < 0 || y >= W || maze[x][y] == '#') {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint next = x * 100 + y;\n\t\t\t\tL--;\n\t\t\t\tif (hashMap.get(now) == null) {\n\t\t\t\t\thashMap.put(now, new ArrayList<Integer>());\n\t\t\t\t\thashMap.get(now).add(next);\n\t\t\t\t} else if (hashMap.get(now).contains(next) && rec) {\n\t\t\t\t\tint size = 0;\n\t\t\t\t\tfor (Map.Entry<Integer, ArrayList<Integer>> e : hashMap.entrySet()) {\n\t\t\t\t\t\tsize += e.getValue().size();\n\t\t\t\t\t}\n\t\t\t\t\tL = L % size;\n\t\t\t\t\thashMap.clear();\n\t\t\t\t} else if (hashMap.get(now).contains(next)) {\n\t\t\t\t\thashMap.clear();\n\t\t\t\t\thashMap.put(now, new ArrayList<Integer>());\n\t\t\t\t\thashMap.get(now).add(next);\n\t\t\t\t\trec = true;\n\t\t\t\t} else {\n\t\t\t\t\thashMap.get(now).add(next);\n\t\t\t\t}\n\t\t\t\tnow = next;\n\t\t\t}\n\n\t\t\tint x = now / 100;\n\t\t\tint y = now - x * 100;\n\t\t\tchar face = '.';\n\t\t\tif (d == 0) {\n\t\t\t\tface = 'N';\n\t\t\t} else if (d == 1) {\n\t\t\t\tface = 'E';\n\t\t\t} else if (d == 2) {\n\t\t\t\tface = 'S';\n\t\t\t} else if (d == 3) {\n\t\t\t\tface = 'W';\n\t\t\t}\n\n\t\t\tSystem.out.println((x + 1) + \" \" + (y + 1) + \" \" + face);\n\t\t\tSystem.gc();\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new B(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass C implements Runnable{\n\t\tC(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tline=sc.next();\n\t\t\t\tif(line.equals(\"#\"))\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n//\t\t\tint[][][][] \n\t\t\t\n\t\t}\n\t}\n\t\n\tclass B implements Runnable{\n\t\tB(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tL=sc.nextLong();\n\t\t\t\tif((W|(H|L))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint W,H;\n\t\tlong L;\n\t\tint[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tString[] vv={\"N\",\"E\",\"S\",\"W\"};\n\t\t\n\t\tvoid solve(){\n\t\t\tint sx=-1,sy=-1,sd=-1;\n\t\t\tboolean[][] map=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tmap[x][y]=(line.charAt(x)!='#');\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(x))){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t\tswitch(line.charAt(x)){\n\t\t\t\t\t\tcase 'N':\tsd=0;\tbreak;\n\t\t\t\t\t\tcase 'E':\tsd=1;\tbreak;\n\t\t\t\t\t\tcase 'S':\tsd=2;\tbreak;\n\t\t\t\t\t\tcase 'W':\tsd=3;\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<State> rec=new ArrayList<State>();\n\t\t\tState last=new State(sx,sy,sd,0,0L);\n\t\t\trec.add(last.clone());\n\t\t\tlong cycle=-1L;\n\t\t\tint csidx=-1;\n\t\t\twhile(true){\n\t\t\t\tint xx=last.x,yy=last.y,dd=last.d;\n\t\t\t\twhile(true){\n\t\t\t\t\txx=last.x+vx[dd];\n\t\t\t\t\tyy=last.y+vy[dd];\n\t\t\t\t\tif((0<=xx && xx<W && 0<=yy && yy<H) && map[xx][yy]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdd=(dd+1)%4;\n\t\t\t\t}\n\t\t\t\tint cnt=1;\n\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(xx+\",\"+yy+\" D:\"+dd);\n\t\t\t\t\t\n\t\t\t\t\txx+=vx[dd];\n\t\t\t\t\tyy+=vy[dd];\n\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H) || !map[xx][yy]){\n\t\t\t\t\t\txx-=vx[dd];\n\t\t\t\t\t\tyy-=vy[dd];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tState next=new State(xx,yy,dd,cnt,last.step+cnt);\n\t\t\t\tfor(int j=0; j<rec.size(); j++){\n\t\t\t\t\tState s=rec.get(j);\n\t\t\t\t\tif(next.x==s.x && next.y==s.y && next.d==s.d){\n\t\t\t\t\t\tcycle=next.step-s.step;\n\t\t\t\t\t\tL-=next.step;\n\t\t\t\t\t\tcsidx=j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trec.add(next);\n\t\t\t\tif(cycle>0)\tbreak;\n\t\t\t\tlast=next.clone();\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(\"L\"+L);\n\t\t\t//System.out.println(rec);\n\t\t\t\n\t\t\tlong remain=L%cycle;\n\t\t\tif(remain==0){\n\t\t\t\tState s=rec.get(rec.size()-1);\n\t\t\t\t// OK\n\t\t\t\t//System.out.println(\"ANS-D\");\n\t\t\t\tSystem.out.println((s.x+1)+\" \"+(s.y+1)+\" \"+vv[s.d]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=csidx; i<rec.size(); i++){\n\t\t\t\tState s=rec.get(i);\n\t\t\t\tif(remain>s.cnt)\tremain-=s.cnt;\n\t\t\t\telse if(remain==s.step){\n\t\t\t\t\t// ?\n\t\t\t\t\t//System.out.println(\"ANS-B\");\n\t\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-C\");\n\t\t\t\t\tint r=(int)(remain-s.cnt),xx=s.x+(vx[s.d]*r)+1,yy=s.y+(vy[s.d]*r)+1;\n\t\t\t\t\tSystem.out.println(xx+\" \"+yy+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint x,y,d,cnt;\n\t\t\tlong step;\n\t\t\tState(int x,int y,int d,int cnt,long step){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.cnt=cnt;\n\t\t\t\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public State clone(){\n\t\t\t\treturn new State(x,y,d,cnt,step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" D:\"+d+\" STEP:\"+step;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n \n \npublic class Main{\n     \n\tpublic static final int DIRS = 4;\n\t\n\tpublic static final int NORTH = 0;\n\tpublic static final int EAST  = 1;\n\tpublic static final int SOUTH = 2;\n\tpublic static final int WEST  = 3;\n\tpublic static final String[] dir_str = new String[]{\"N\", \"E\", \"S\", \"W\"};\n\t\n\tpublic static final int[] vx = new int[]{0, 1, 0, -1};\n\tpublic static final int[] vy = new int[]{-1, 0, 1, 0};\n\t\n\t\n    public static void main(String[] args){\n    \t\n    \tfinal Scanner sc = new Scanner(System.in);\n    \t\n    \twhile(true){\n    \t\tfinal int H = sc.nextInt();\n    \t\tfinal int W = sc.nextInt();\n    \t\tfinal int L = sc.nextInt();\n    \t\t\n    \t\tif(H == 0 && W == 0 && L == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tint sx = -1;\n    \t\tint sy = -1;\n    \t\tint sdir = -1;\n    \t\tboolean[][] is_wall = new boolean[H][W];\n    \t\tfor(int i = 0; i < H; i++){\n    \t\t\tchar[] inputs = sc.next().toCharArray();\n    \t\t\t\n    \t\t\tfor(int j = 0; j < W; j++){\n    \t\t\t\tif(inputs[j] == '#'){\n    \t\t\t\t\tis_wall[i][j] = true;\n    \t\t\t\t}else if(inputs[j] == 'N'){\n    \t\t\t\t\tsx = j;\n    \t\t\t\t\tsy = i;\n    \t\t\t\t\tsdir = NORTH;\n    \t\t\t\t}else if(inputs[j] == 'E'){\n    \t\t\t\t\tsx = j;\n    \t\t\t\t\tsy = i;\n    \t\t\t\t\tsdir = EAST;\n    \t\t\t\t}else if(inputs[j] == 'S'){\n    \t\t\t\t\tsx = j;\n    \t\t\t\t\tsy = i;\n    \t\t\t\t\tsdir = SOUTH;\n    \t\t\t\t}else if(inputs[j] == 'W'){\n    \t\t\t\t\tsx = j;\n    \t\t\t\t\tsy = i;\n    \t\t\t\t\tsdir = WEST;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tlong[][][] visit_time = new long[H][W][DIRS];\n    \t\tfor(int i = 0; i < H; i++){\n    \t\t\tfor(int j = 0; j < W; j++){\n    \t\t\t\tfor(int k = 0; k < DIRS; k++){\n    \t\t\t\t\tvisit_time[i][j][k] = -1;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tint x = sx;\n    \t\tint y = sy;\n    \t\tint dir = sdir;\n    \t\tlong time = 0;\n    \t\t\n    \t\twhile(time < L){\n    \t\t\t//System.out.println(x + \" \" + y + \" \" + dir + \" \" + time);\n    \t\t\t\n    \t\t\tif(visit_time[y][x][dir] >= 0){\n    \t\t\t\tfinal long diff_time = time - visit_time[y][x][dir];\n    \t\t\t\ttime += ((L - time) / diff_time) * diff_time;\n    \t\t\t\t\n    \t\t\t\tif(time >= L){\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tfor(int i = 0; i < H; i++){\n    \t    \t\t\tfor(int j = 0; j < W; j++){\n    \t    \t\t\t\tfor(int k = 0; k < DIRS; k++){\n    \t    \t\t\t\t\tvisit_time[i][j][k] = -1;\n    \t    \t\t\t\t}\n    \t    \t\t\t}\n    \t    \t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tvisit_time[y][x][dir] = time;\n    \t\t\t\n    \t\t\tfor(int offset = 0; offset < DIRS; offset++){\n    \t\t\t\tfinal int ndir = (dir + offset) % 4;\n    \t\t\t\tfinal int nx = x + vx[ndir];\n    \t\t\t\tfinal int ny = y + vy[ndir];\n    \t\t\t\t\n    \t\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H){\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}if(is_wall[ny][nx]){\n    \t\t\t\t\tcontinue;\n    \t\t\t\t}else{\n    \t\t\t\t\tx = nx;\n    \t\t\t\t\ty = ny;\n    \t\t\t\t\tdir = ndir;\n    \t\t\t\t\ttime++;\n    \t\t\t\t\t\n    \t\t\t\t\t\n    \t\t\t\t\t\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t//System.out.println(time);\n    \t\tSystem.out.println((y + 1) + \" \" + (x + 1) + \" \" + dir_str[dir]);\n    \t\t\n    \t}\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\t//2352 start\n\t\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {-1,0,1,0};\n\tint w,h;\n\t\n\tclass State {\n\t\tint x,y,dir,step;\n\n\t\tpublic State(int x, int y, int dir, int step) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.dir = dir;\n\t\t\tthis.step = step;\n\t\t}\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tlong l = sc.nextLong();\n\t\t\tif((h|w|l) == 0) break;\n\t\t\t\n\t\t\tboolean [][] isNG = new boolean[h][w];\n\t\t\tint sx = -1, sy = -1, sd = -1;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tchar c = s.charAt(j);\n\t\t\t\t\tif(c == '#'){\n\t\t\t\t\t\tisNG[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(Character.isLetter(c)){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tif(c == 'N'){\n\t\t\t\t\t\t\tsd = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(c == 'E') sd = 1;\n\t\t\t\t\t\tif(c == 'S') sd = 2;\n\t\t\t\t\t\tif(c == 'W') sd = 3;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<State> open = new LinkedList<Main.State>();\n\t\t\topen.add(new State(sx, sy, sd, 0));\n\t\t\tint INF = 1 << 24;\n\t\t\tint [][][] close = new int[h][w][4];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w;j++){\n\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[sy][sx][sd] = 0;\n\t\t\tArrayList<State> steplist  = new ArrayList<Main.State>();\n\t\t\tsteplist.add(new State(sx, sy, sd, 0));\n\t\t\tint c = 1 << 24;\n\t\t\tint offset = 0;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.removeFirst();\n\t\t\t\tint xx=-1, yy=-1, nd = -1;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\txx = now.x + vx[(now.dir + i) % 4];\n\t\t\t\t\tyy = now.y + vy[(now.dir + i) % 4];\n\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\tif(isNG[yy][xx]) continue;\n\t\t\t\t\tnd = (now.dir + i) % 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(close[yy][xx][nd] != INF){\n\t\t\t\t\tc = now.step +1 - close[yy][xx][nd];\n\t\t\t\t\tl = l - close[yy][xx][nd];\n\t\t\t\t\toffset =  close[yy][xx][nd];\n\t\t\t\t}\n\t\t\t\telse if(now.step + 1 == l){\n\t\t\t\t\tsteplist.add(new State(xx, yy, nd, now.step + 1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\topen.add(new State(xx, yy, nd, now.step + 1));\n\t\t\t\t\tclose[yy][xx][nd] = now.step + 1;\n\t\t\t\t\tsteplist.add(new State(xx, yy, nd, now.step + 1));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tint rotate = (int) (l % c);\n\t\t\tState res = steplist.get(rotate + offset);\n\t\t\tint x = res.x + 1;\n\t\t\tint y = res.y + 1;\n\t\t\tchar [] table = {'N','E','S','W'};\n\t\t\tchar dir = table[res.dir];\n\t\t\tSystem.out.println(y + \" \" + x + \" \" + dir);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0<= yy && yy < h){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new B(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass B implements Runnable{\n\t\tB(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tL=sc.nextLong();\n\t\t\t\tif((W|(H|L))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint W,H;\n\t\tlong L;\n\t\tint[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tString[] vv={\"N\",\"E\",\"S\",\"W\"};\n\t\t\n\t\tvoid solve(){\n\t\t\tint sx=-1,sy=-1,sd=-1;\n\t\t\tboolean[][] map=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tmap[x][y]=(line.charAt(x)!='#');\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(x))){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t\tswitch(line.charAt(x)){\n\t\t\t\t\t\tcase 'N':\tsd=0;\tbreak;\n\t\t\t\t\t\tcase 'E':\tsd=1;\tbreak;\n\t\t\t\t\t\tcase 'S':\tsd=2;\tbreak;\n\t\t\t\t\t\tcase 'W':\tsd=3;\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<State> rec=new ArrayList<State>();\n\t\t\tState last=new State(sx,sy,sd,0,0L);\n\t\t\trec.add(last.clone());\n\t\t\tlong cycle=-1L;\n\t\t\tint csidx=-1;\n\t\t\twhile(true){\n\t\t\t\tint cnt=1,xx=last.x,yy=last.y,dd=last.d;\n\t\t\t\twhile(true){\n\t\t\t\t\txx=last.x+vx[dd];\n\t\t\t\t\tyy=last.y+vy[dd];\n\t\t\t\t\tif((0<=xx && xx<W && 0<=yy && yy<H) && map[xx][yy]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdd=(dd+1)%4;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(xx+\",\"+yy+\" D:\"+dd);\n\t\t\t\t\t\n\t\t\t\t\txx+=vx[dd];\n\t\t\t\t\tyy+=vy[dd];\n\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H) || !map[xx][yy]){\n\t\t\t\t\t\txx-=vx[dd];\n\t\t\t\t\t\tyy-=vy[dd];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif(last.step+cnt>=L){\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\t//System.out.println(\"ANS-A\");\n\t\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tState next=new State(xx,yy,dd,cnt,last.step+cnt);\n\t\t\t\tfor(int j=0; j<rec.size(); j++){\n\t\t\t\t\tState s=rec.get(j);\n\t\t\t\t\tif(next.x==s.x && next.y==s.y && next.d==s.d){\n\t\t\t\t\t\tcycle=next.step-s.step;\n\t\t\t\t\t\tL-=next.step;\n\t\t\t\t\t\tcsidx=j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trec.add(next);\n\t\t\t\tif(cycle>0)\tbreak;\n\t\t\t\tlast=next.clone();\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(\"L\"+L);\n\t\t\t//System.out.println(rec);\n\t\t\t\n\t\t\tlong remain=L%cycle;\n\t\t\tif(remain==0){\n\t\t\t\tState s=rec.get(rec.size()-1);\n\t\t\t\t// OK\n\t\t\t\t//System.out.println(\"ANS-D\");\n\t\t\t\tSystem.out.println((s.x+1)+\" \"+(s.y+1)+\" \"+vv[s.d]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=csidx; i<rec.size(); i++){\n\t\t\t\tState s=rec.get(i);\n\t\t\t\tif(remain>s.cnt)\tremain-=s.cnt;\n\t\t\t\telse if(remain==s.step){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-B\");\n\t\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// NG\n\t\t\t\t\t//System.out.println(\"ANS-C\");\n\t\t\t\t\tint r=(int)(remain-s.cnt),xx=s.x+(vx[s.d]*r)+1,yy=s.y+(vy[s.d]*r)+1;\n\t\t\t\t\tSystem.out.println(xx+\" \"+yy+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint x,y,d,cnt;\n\t\t\tlong step;\n\t\t\tState(int x,int y,int d,int cnt,long step){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.cnt=cnt;\n\t\t\t\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public State clone(){\n\t\t\t\treturn new State(x,y,d,cnt,step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" D:\"+d+\" STEP:\"+step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass C implements Runnable{\n\t\tC(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tline=sc.next();\n\t\t\t\tif(line.equals(\"#\"))\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tfinal long STACK_SIZE=8*1024*1024;\n\t\tnew Thread(null, new B(), \"RUN\", STACK_SIZE).start();\n\t}\n\t\n\tclass B implements Runnable{\n\t\tB(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tH=sc.nextInt();\n\t\t\t\tW=sc.nextInt();\n\t\t\t\tL=sc.nextLong();\n\t\t\t\tif((W|(H|L))==0)\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint W,H;\n\t\tlong L;\n\t\tint[] vx={0,1,0,-1},vy={-1,0,1,0};\n\t\tString[] vv={\"N\",\"E\",\"S\",\"W\"};\n\t\t\n\t\tvoid solve(){\n\t\t\tint sx=-1,sy=-1,sd=-1;\n\t\t\tboolean[][] map=new boolean[W][H];\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tmap[x][y]=(line.charAt(x)!='#');\n\t\t\t\t\tif(Character.isUpperCase(line.charAt(x))){\n\t\t\t\t\t\tsx=x;\n\t\t\t\t\t\tsy=y;\n\t\t\t\t\t\tswitch(line.charAt(x)){\n\t\t\t\t\t\tcase 'N':\tsd=0;\tbreak;\n\t\t\t\t\t\tcase 'E':\tsd=1;\tbreak;\n\t\t\t\t\t\tcase 'S':\tsd=2;\tbreak;\n\t\t\t\t\t\tcase 'W':\tsd=3;\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<State> rec=new ArrayList<State>();\n\t\t\tState last=new State(sx,sy,sd,0,0L);\n\t\t\trec.add(last.clone());\n\t\t\tlong cycle=-1L;\n\t\t\tint csidx=-1;\n\t\t\twhile(true){\n\t\t\t\tint xx=last.x,yy=last.y,dd=last.d;\n\t\t\t\twhile(true){\n\t\t\t\t\txx=last.x+vx[dd];\n\t\t\t\t\tyy=last.y+vy[dd];\n\t\t\t\t\tif((0<=xx && xx<W && 0<=yy && yy<H) && map[xx][yy]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdd=(dd+1)%4;\n\t\t\t\t}\n\t\t\t\tint cnt=1;\n\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twhile(true){\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(xx+\",\"+yy+\" D:\"+dd);\n\t\t\t\t\t\n\t\t\t\t\txx+=vx[dd];\n\t\t\t\t\tyy+=vy[dd];\n\t\t\t\t\tif(!(0<=xx && xx<W && 0<=yy && yy<H) || !map[xx][yy]){\n\t\t\t\t\t\txx-=vx[dd];\n\t\t\t\t\t\tyy-=vy[dd];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++cnt;\n\t\t\t\t\tif(last.step+cnt==L){\n\t\t\t\t\t\t// OK\n\t\t\t\t\t\t//System.out.println(\"ANS-A2\");\n\t\t\t\t\t\tSystem.out.println((yy+1)+\" \"+(xx+1)+\" \"+vv[dd]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tState next=new State(xx,yy,dd,cnt,last.step+cnt);\n\t\t\t\tfor(int j=0; j<rec.size(); j++){\n\t\t\t\t\tState s=rec.get(j);\n\t\t\t\t\tif(next.x==s.x && next.y==s.y && next.d==s.d){\n\t\t\t\t\t\tcycle=next.step-s.step;\n\t\t\t\t\t\tL-=next.step;\n\t\t\t\t\t\tcsidx=j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trec.add(next);\n\t\t\t\tif(cycle>0)\tbreak;\n\t\t\t\tlast=next.clone();\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(\"L\"+L);\n\t\t\t//System.out.println(rec);\n\t\t\t\n\t\t\tlong remain=L%cycle;\n\t\t\tif(remain==0){\n\t\t\t\tState s=rec.get(rec.size()-1);\n\t\t\t\t// OK\n\t\t\t\t//System.out.println(\"ANS-D\");\n\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int i=csidx; i<rec.size(); i++){\n\t\t\t\tState s=rec.get(i);\n\t\t\t\tif(remain>s.cnt)\tremain-=s.cnt;\n\t\t\t\telse if(remain==s.cnt){\n\t\t\t\t\t// OK\n\t\t\t\t\t//System.out.println(\"ANS-B\");\n\t\t\t\t\tSystem.out.println((s.y+1)+\" \"+(s.x+1)+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t// NG\n\t\t\t\t\t//System.out.println(\"ANS-C\");\n\t\t\t\t\tint idx=i-1<csidx?(rec.size()-1):i-1;\n\t\t\t\t\tState s2=rec.get(idx);\n\t\t\t\t\tint r=(int)(s.cnt-remain),xx=s2.x+(vx[s.d]*r)+1,yy=s2.y+(vy[s.d]*r)+1;\n\t\t\t\t\tSystem.out.println(yy+\" \"+xx+\" \"+vv[s.d]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State{\n\t\t\tint x,y,d,cnt;\n\t\t\tlong step;\n\t\t\tState(int x,int y,int d,int cnt,long step){\n\t\t\t\tthis.x=x;\n\t\t\t\tthis.y=y;\n\t\t\t\tthis.d=d;\n\t\t\t\tthis.cnt=cnt;\n\t\t\t\tthis.step=step;\n\t\t\t}\n\t\t\t@Override public State clone(){\n\t\t\t\treturn new State(x,y,d,cnt,step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" D:\"+d+\" STEP:\"+step;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass C implements Runnable{\n\t\tC(){}\n\t\t@Override public void run(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tline=sc.next();\n\t\t\t\tif(line.equals(\"#\"))\tbreak;\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}\n\t\t\n\t\tString line;\n\t\t\n\t\tvoid solve(){\n\t\t\t\n\t\t\tint len=line.length();\n\t\t\tint[][][][] dp=new int[len+1][3][3][2];\n\t\t\tfor(int i=0; i<len; i++)for(int j=0; j<3; j++)for(int k=0; k<3; k++)for(int m=0; m<2; m++)\tdp[i][j][k][m]=1<<29;\n\t\t\tint[] v={1,0,1,2,0,2,0,1,2};\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=1; i<=len; i++){\n\t\t\t\tint d=line.charAt(i-1)-'0',now=v[d];\n\t\t\t\tfor(int r=0; r<3; r++){\n\t\t\t\t\tfor(int l=0; l<3; l++){\n\t\t\t\t\t\tfor(int b=0; b<2; b++){\n\t\t\t\t\t\t\t// right foot\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// left foot\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tif (H == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint W = sc.nextInt();\n\t\t\tlong L = sc.nextLong();\n\t\t\tint[][] dir = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };// 北、東、南、西\n\t\t\tchar[][] maze = new char[H][];\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tmaze[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tHashMap<Integer, ArrayList<Integer>> hashMap = new HashMap<Integer, ArrayList<Integer>>();\n\t\t\t// <前のマス, 次のマス>\n\t\t\tint now = 0;\n\t\t\tint d = 0;// 向き N:0, E:1, S:2, W:3\n\t\t\tfor (int i = 0; i < maze.length; i++) {\n\t\t\t\tfor (int j = 0; j < maze[i].length; j++) {\n\t\t\t\t\tif (maze[i][j] != '#' && maze[i][j] != '.') {\n\t\t\t\t\t\tnow = i * 100 + j;\n\t\t\t\t\t\tif (maze[i][j] == 'N') {\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t} else if (maze[i][j] == 'E') {\n\t\t\t\t\t\t\td = 1;\n\t\t\t\t\t\t} else if (maze[i][j] == 'S') {\n\t\t\t\t\t\t\td = 2;\n\t\t\t\t\t\t} else if (maze[i][j] == 'W') {\n\t\t\t\t\t\t\td = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean rec = false;\n\t\t\twhile (L > 0) {\n\t\t\t\tint x = now / 100;\n\t\t\t\tint y = now - x * 100;\n\t\t\t\tx += dir[d][0];\n\t\t\t\ty += dir[d][1];\n\t\t\t\tif (x < 0 || x >= H || y < 0 || y >= W || maze[x][y] == '#') {\n\t\t\t\t\td = (d + 1) % 4;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint next = x * 100 + y;\n\t\t\t\tL--;\n\t\t\t\tif (hashMap.get(now) == null) {\n\t\t\t\t\thashMap.put(now, new ArrayList<Integer>());\n\t\t\t\t\thashMap.get(now).add(next);\n\t\t\t\t} else if (hashMap.get(now).contains(next) && rec) {\n\t\t\t\t\tint size = 0;\n\t\t\t\t\tfor (Map.Entry<Integer, ArrayList<Integer>> e : hashMap.entrySet()) {\n\t\t\t\t\t\tsize += e.getValue().size();\n\t\t\t\t\t}\n\t\t\t\t\tL = L % size;\n\t\t\t\t\thashMap.clear();\n\t\t\t\t} else if (hashMap.get(now).contains(next)) {\n\t\t\t\t\thashMap.clear();\n\t\t\t\t\thashMap.put(now, new ArrayList<Integer>());\n\t\t\t\t\thashMap.get(now).add(next);\n\t\t\t\t\trec = true;\n\t\t\t\t}\n\t\t\t\tnow = next;\n\t\t\t}\n\n\t\t\tint x = now / 100;\n\t\t\tint y = now - x * 100;\n\t\t\tchar face = '.';\n\t\t\tif (d == 0) {\n\t\t\t\tface = 'N';\n\t\t\t} else if (d == 1) {\n\t\t\t\tface = 'E';\n\t\t\t} else if (d == 2) {\n\t\t\t\tface = 'S';\n\t\t\t} else if (d == 3) {\n\t\t\t\tface = 'W';\n\t\t\t}\n\n\t\t\tSystem.out.println((x + 1) + \" \" + (y + 1) + \" \" + face);\n\t\t\tSystem.gc();\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint N = 0, E = 1, S = 2, W = 3;\n\tString nesw = \"NESW\";\n\tint MAX = 10000;\n\tint[] vx = {0, 1, 0, -1};\n\tint[] vy = {-1, 0, 1, 0};\n\t\n\tint[] xlist = new int[10010];\n\tint[] ylist = new int[10010];\n\tint[] dirlist = new int[10010];\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\t\n\tlong getKey(long x, long y, long dir) {\n\t\treturn x * MAX * 4 + y * 4 + dir; \n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint H = in.nextInt(), W = in.nextInt();\n\t\t\tlong L = in.nextLong();\n\t\t\tif (H == 0) break;\n\t\t\tint x = -1, y = -1, dir = -1;\n\t\t\tchar[][] c = new char[H][];\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tc[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tswitch (c[i][j]) {\n\t\t\t\t\tcase 'E' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = E;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'N' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = N;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = S;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W' :\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tdir = W;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrays.fill(xlist, -1);\n\t\t\tArrays.fill(ylist, -1);\n\t\t\tArrays.fill(dirlist, -1);\n\t\t\t\n\t\t\tint cnt = 0;\n\t\t\tHashMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\t\twhile (true && cnt < L) {\n\t\t\t\tif (map.containsKey(getKey(x, y, dir))) break;\n\t\t\t\t\n\t\t\t\tif (xlist[cnt] == -1) {\n\t\t\t\t\txlist[cnt] = x;\n\t\t\t\t\tylist[cnt] = y;\n\t\t\t\t\tdirlist[cnt] = dir;\n//\t\t\t\t\tSystem.out.println(cnt + \" : \" + (y+1) + \" \" + (x+1) + \" \" + nesw.charAt(dir));\n\t\t\t\t}\n\t\t\t\tmap.put(getKey(x, y, dir), cnt++);\n\t\t\t\tint nx = x + vx[dir], ny = y + vy[dir];\n\t\t\t\tif (!inside(nx, ny, W, H) || (inside(nx, ny, W, H) && c[ny][nx] == '#')) {\n\t\t\t\t\tnx = x;\n\t\t\t\t\tny = y;\n\t\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t}\n\t\t\t\n\t\t\tif (cnt != L) {\n\t\t\t\tlong max = cnt, min = map.get(getKey(x, y, dir));\n\t\t\t\tint key = (int) ((L - min) % (max - min) + min);\n\t\t\t\t\n\t\t\t\tx = xlist[key];\n\t\t\t\ty = ylist[key];\n\t\t\t\tdir = dirlist[key];\n\t\t\t}\t\t\n\t\t\tSystem.out.println((y+1) + \" \" + (x+1) + \" \" + nesw.charAt(dir));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int H, W;\n    static long L;\n    static char[][] C;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        while(true) {\n            H = sc.nextInt();\n            W = sc.nextInt();\n            L = sc.nextLong();\n\n            if( H == 0 ) break;\n\n            C = new char[H][];\n            for (int i = 0; i < H; i++) {\n                C[i] = sc.next().toCharArray();\n            }\n\n            pw.println(solve());\n        }\n        pw.flush();\n    }\n\n    static int[] DH = {-1, 0, 1, 0};\n    static int[] DW = {0, 1, 0, -1};\n    static String NESW = \"NESW\";\n\n    static String solve() {\n        int sh = -1, sw = -1, sd = -1;\n        findStart:\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if( C[i][j] != '#' && C[i][j] != '.' ) {\n                    sh = i;\n                    sw = j;\n                    sd = NESW.indexOf(C[i][j]);\n                    break findStart;\n                }\n            }\n        }\n\n        Map<Key, Integer> cords = new HashMap<>();\n        Key[] keys = new Key[H*W];\n        int ch = sh, cw = sw, cd = sd;\n        int cnt = 0;\n        cords.put(new Key(ch, cw, cd), cnt);\n        keys[cnt] = new Key(ch, cw, cd);\n        cnt++;\n        int loopStart;\n        int loopLength;\n        lo:\n        while(true) {\n            for (int i = 0; i < 4; i++) {\n                int nd = (cd + i)%4;\n                int nh = ch + DH[nd];\n                int nw = cw + DW[nd];\n\n                if( inRange(nh, nw) && C[nh][nw] != '#' ) {\n                    Key key = new Key(nh, nw, nd);\n                    if( cords.containsKey(key) ) {\n                        // loop found\n                        loopStart = cords.get(key);\n                        loopLength = cnt - loopStart;\n                        break lo;\n                    } else {\n                        cords.put(key, cnt);\n                        keys[cnt] = key;\n                        ch = nh;\n                        cw = nw;\n                        cd = nd;\n                        cnt++;\n                        continue lo;\n                    }\n                }\n            }\n            throw new RuntimeException(\"wtf\");\n        }\n\n        Key key;\n        if( L < cnt ) {\n            key = keys[(int)L];\n\n        } else {\n            int r = (int)((L-loopStart) % loopLength);\n            key = keys[loopStart + r];\n        }\n\n        return (key.h+1) + \" \" + (key.w+1) + \" \" + NESW.charAt(key.d);\n    }\n\n    static boolean inRange(int h, int w) {\n        return 0 <= h && h < H && 0 <= w && w < W;\n    }\n\n    static class Key {\n        int h, w, d;\n\n        public Key(int h, int w, int d) {\n            this.h = h;\n            this.w = w;\n            this.d = d;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Key key = (Key) o;\n            return h == key.h &&\n                    w == key.w &&\n                    d == key.d;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(h, w, d);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n    public int step { get; set; }\n    public int d { get; set; }\n}\n\npublic class hello\n{\n    public static int h, w, sx, sy, sd;\n    public static long L;\n    public static int[] dx, dy;\n    public static char[] dir;\n    public static void Main()\n    {\n         dx = new int[] { 0, 1, 0, -1 };\n         dy = new int[] { 1, 0, -1, 0 };\n        dir = new char[] { 'E', 'S', 'W', 'N' };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            h = int.Parse(line[0]);\n            w = int.Parse(line[1]);\n            L = long.Parse(line[2]);\n            if (h == 0 && w == 0 && L == 0) break;\n            var map = new bool[h, w];\n            var map2 = new int[h, w, 4];\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                    for (int k = 0; k < 4; k++) map2[i, j, k] = -1;\n            sx = -1; sy = -1; sd = -1;\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    if (s[j] == '#') map[i, j] = false;\n                    else\n                    {\n                        map[i, j] = true;\n                        if (s[j] != '.')\n                        {\n                            sx = i;\n                            sy = j;\n                            if (s[j] == 'E') sd = 0;\n                            else if (s[j] == 'S') sd = 1;\n                            else if (s[j] == 'W') sd = 2;\n                            else sd = 3;\n                        }\n                    }\n                }\n            }\n            getAns(map, map2);\n        }\n    }\n    static void getAns2(bool[,] map, int prestep, P t)\n    {\n        var nstep = (L - t.step) % (t.step - prestep);\n        if (nstep == 0) { Console.WriteLine(\"{0} {1} {2}\", t.x + 1, t.y + 1, dir[t.d]); return; }\n        t.step = 0;\n        while (true)\n        {\n            if (t.step == nstep)\n            {\n                Console.WriteLine(\"{0} {1} {2}\", t.x + 1, t.y + 1, dir[t.d]);\n                break;\n            }\n            var nd = t.d;\n            while (true)\n            {\n                var nx = t.x + dx[nd];\n                var ny = t.y + dy[nd];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny])\n                {\n                    t.x = nx;\n                    t.y = ny;\n                    t.d = nd;\n                    t.step++;\n                    break;\n                }\n                else\n                {\n                    nd++;\n                    if (nd == 4) nd = 0;\n                }\n            }\n        }\n    }\n    static void getAns(bool[,] map, int[,,] map2)\n    {\n        var t = new P { x = sx, y = sy, d = sd, step = 0 };\n        while (true)\n        {\n            if (t.step == L) { Console.WriteLine(\"{0} {1} {2}\", t.x + 1, t.y + 1, dir[t.d]); return; }\n            var mp2 = map2[t.x, t.y, t.d];\n            if (mp2 != -1) { getAns2(map, mp2, t); return; }\n            map2[t.x, t.y, t.d] = t.step;\n            var nd = t.d;\n            var nstep = t.step + 1;\n            while (true)\n            {\n                var nx = t.x + dx[nd];\n                var ny = t.y + dy[nd];\n                if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny])\n                {\n                    t.x = nx;\n                    t.y = ny;\n                    t.d = nd;\n                    t.step = nstep;\n                    break;\n                }\n                else\n                {\n                    nd++;\n                    if (nd == 4) nd = 0;\n                }\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nwhile (h,w,l=gets.split.map(&:to_i))!=[0,0,0]\nd=[[0,-1],[1,0],[0,1],[-1,0]]\nd0=\"NESW\".split('')\nf=(h+2).times.map{[1]*(w+2)}\ng=(h+2).times.map{(w+2).times.map{[nil]*4}}\nz=x=y=0\nh.times{|i|\n\ts=gets.chomp\n\tw.times{|j|\n\t\tif (k=d0.index(s[j..j]))\n\t\t\tx=j+1;y=i+1;z=k\n\t\tend\n\t\tif s[j..j]!='#'\n\t\t\tf[i+1][j+1]=nil\n\t\tend\n\t}\n}\nc=0\nwhile l>0\n\tbreak if g[y][x][z]&&(l%=c-g[y][x][z])==0\n\tg[y][x][z]=c\n\tz=(z+1)%4 while f[y+d[z][1]][x+d[z][0]]\n\tx+=d[z][0];y+=d[z][1]\n\tl-=1\n\tc+=1\nend\nputs \"#{y} #{x} #{d0[z]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nwhile (h,w,l=gets.split.map(&:to_i))!=[0,0,0]\nd=[[0,-1],[1,0],[0,1],[-1,0]]\nd0=\"NESW\".split('')\nz=0\nx=y=0\nf=(h+2).times.map{[1]*(w+2)}\ng=(h+2).times.map{(w+2).times.map{[nil]*4}}\nh.times{|i|\n\ts=gets.chomp\n\tw.times{|j|\n\t\tif (k=d0.index(s[j..j]))\n\t\t\tx=j+1;y=i+1;z=k\n\t\tend\n\t\tif s[j..j]!='#'\n\t\t\tf[i+1][j+1]=nil\n\t\tend\n\t}\n}\nc=0\nwhile l>0\n\tif g[y][x][z]\n\t\tl%=(c-g[y][x][z])\n\t\tbreak if l==0\n\tend\n\tg[y][x][z]=c\n\twhile true\n\t\tif !f[y+d[z][1]][x+d[z][0]]\n\t\t\tx+=d[z][0];y+=d[z][1]\n\t\t\tbreak\n\t\tend\n\t\tz=(z+1)%4\n\tend\n\tl-=1\n\tc+=1\nend\nputs \"#{y} #{x} #{d0[z]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nwhile (h,w,l=gets.split.map(&:to_i))!=[0,0,0]\nd=[[0,-1],[1,0],[0,1],[-1,0]]\nd0=\"NESW\".split('')\nf=(h+2).times.map{[1]*(w+2)}\ng=(h+2).times.map{(w+2).times.map{[nil]*4}}\nh.times{|i|\n\ts=gets.chomp\n\tw.times{|j|\n\t\tif (k=d0.index(s[j..j]))\n\t\t\tx=j+1;y=i+1;z=k\n\t\tend\n\t\tif s[j..j]!='#'\n\t\t\tf[i+1][j+1]=nil\n\t\tend\n\t}\n}\nc=0\nwhile l>0\n\tbreak if g[y][x][z]&&(l%=c-g[y][x][z])==0\n\tg[y][x][z]=c\n\twhile true\n\t\tif !f[y+d[z][1]][x+d[z][0]]\n\t\t\tx+=d[z][0];y+=d[z][1]\n\t\t\tbreak\n\t\tend\n\t\tz=(z+1)%4\n\tend\n\tl-=1\n\tc+=1\nend\nputs \"#{y} #{x} #{d0[z]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nwhile (h,w,l=gets.split.map(&:to_i))!=[0,0,0]\nd=[[0,-1],[1,0],[0,1],[-1,0]]\nd0=\"NESW\".split('')\nf=(h+2).times.map{[1]*(w+2)}\ng=(h+2).times.map{(w+2).times.map{[nil]*4}}\nz=x=y=0\nh.times{|i|\n\ts=gets.chomp\n\tw.times{|j|\n\t\tif (k=d0.index(s[j..j]))\n\t\t\tx=j+1;y=i+1;z=k\n\t\tend\n\t\tif s[j..j]!='#'\n\t\t\tf[i+1][j+1]=nil\n\t\tend\n\t}\n}\nc=0\nwhile l>0\n\tbreak if g[y][x][z]&&(l%=c-g[y][x][z])==0\n\tg[y][x][z]=c\n\tz=(z+1)%4 while f[y+d[z][1]][x+d[z][0]]\n\tx+=d[z][0];y+=d[z][1]\n\tl-=1\n\tc+=1\nend\nputs \"#{y} #{x} #{d0[z]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "# Header {{{\nrequire 'forwardable'\n\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\nclass MyIO\n  def initialize\n    @source = STDIN\n  end\n\n  # @param filename [String]\n  def set_source(filename)\n    @source = File.open(filename, 'r')\n  end\n\n  def intl\n    splitl.map(&:to_i)\n  end\n\n  def splitl\n    @source.gets.chomp.split(' ')\n  end\n\n  def gets\n    @source.gets.chomp\n  end\nend\n\nclass Field\n  extend Forwardable\n  def_delegators :@field, :[]\n\n  DIRECTIONS = [:up, :right, :down, :left]\n\n  attr_accessor :h, :w\n\n  class DyDx\n    attr_accessor :y, :x\n\n    DYDX_BY_DIRECTIONS = { up: [-1, 0], right: [0, 1], down: [1, 0], left: [0, -1] }\n\n    class << self\n      DIRECTIONS.each do |dir|\n        define_method(dir.to_s) { self.new(dir, *DYDX_BY_DIRECTIONS[dir]) }\n      end\n    end\n\n    def initialize(id, y, x)\n      @id, @y, @x = id, y, x\n    end\n\n    def index\n      DIRECTIONS.find_index(@id)\n    end\n  end\n\n  class << self\n    def dydx4\n      [DyDx.up, DyDx.right, DyDx.down, DyDx.left]\n    end\n  end\n\n  def initialize(field)\n    assert(field.is_a?(Array))\n    assert(field[0].is_a?(Array))\n    @field = field\n    @h, @w = field.size, field[0].size\n  end\n\n  def inside?(y, x)\n    0 <= y && y < @h && 0 <= x && x < @w\n  end\n\n  def to_s\n    str = ''\n    @field.each do |row|\n      row.each do |cell|\n        str += cell.to_s\n      end\n      str += \"\\n\"\n    end\n    str\n  end\nend\n\nio = MyIO.new\n# }}}\n\nio.set_source('inputs/0.txt')\n\ndef dir2i(d)\n  { N: 0, E: 1, S: 2, W: 3 }[d.to_sym]\nend\n\ndef i2dir(i)\n  [ 'N', 'E', 'S', 'W' ][i]\nend\n\nclass Robot\n  attr_accessor :y, :x, :dir\n  def initialize(y, x, dir)\n    @y, @x, @dir = y, x, dir\n  end\n\n  def move(dydx)\n    self.class.new(@y + dydx.y, @x + dydx.x, dydx.index)\n  end\nend\n\nwhile true\n  h, w, l = io.intl\n  break if h == 0\n  robot = nil\n  _field = []\n  h.times do |i|\n    _field << io.gets.split('')\n    w.times do |j|\n      unless ['.', '#'].include?(_field[i][j])\n        robot = Robot.new(i, j, dir2i(_field[i][j]))\n        _field[i][j] = '.'\n      end\n    end\n  end\n  field = Field.new(_field)\n\n  @cost = Array.new(h) { Array.new(w) { Array.new(4, nil) } }\n  def cost_of(rob)\n    @cost[rob.y][rob.x][rob.dir]\n  end\n  def set_cost(rob, val)\n    @cost[rob.y][rob.x][rob.dir] = val\n  end\n\n  looped = false\n  dist = 0\n  while true\n    set_cost(robot, dist)\n    if dist == l\n      break\n    end\n\n    moved = false\n    4.times do |d|\n      di = (robot.dir + d) % 4\n      dydx = Field.dydx4[di]\n      nr = robot.move(dydx)\n      if field.inside?(nr.y, nr.x) && field[nr.y][nr.x] == '.'\n        if !looped && !cost_of(nr).nil?\n          looped = true\n          rest = l - dist\n          loop_len = cost_of(robot) - cost_of(nr) + 1\n          rest %= loop_len\n          l = rest\n          dist = 0\n        end\n\n        robot = nr\n        moved = true\n        dist += 1\n        break\n      end\n    end\n    assert(moved)\n  end\n\n  puts [robot.y + 1, robot.x + 1, i2dir(robot.dir)].join(' ')\nend\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nwhile (h,w,l=gets.split.map(&:to_i))!=[0,0,0]\nd=[[0,-1],[1,0],[0,1],[-1,0]]\nd0=\"NESW\".split('')\nf=(h+2).times.map{[1]*(w+2)}\ng=(h+2).times.map{(w+2).times.map{[nil]*4}}\nz=x=y=0\nh.times{|i|\n\ts=gets.chomp\n\tw.times{|j|\n\t\tif (k=d0.index(s[j..j]))\n\t\t\tx=j+1;y=i+1;z=k\n\t\tend\n\t\tif s[j..j]!='#'\n\t\t\tf[i+1][j+1]=nil\n\t\tend\n\t}\n}\nc=0\nwhile l>0\n\tbreak if g[y][x][z]&&(l%=c-g[y][x][z])==0\n\tg[y][x][z]=c\n\twhile true\n\t\tif !f[y+d[z][1]][x+d[z][0]]\n\t\t\tx+=d[z][0];y+=d[z][1]\n\t\t\tbreak\n\t\tend\n\t\tz=(z+1)%4\n\tend\n\tl-=1\n\tc+=1\nend\nputs \"#{y} #{x} #{d0[z]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#codeeval57\nwhile (h,w,l=gets.split.map(&:to_i))!=[0,0,0]\nd=[[0,-1],[1,0],[0,1],[-1,0]]\nd0=\"NESW\".split('')\nx=y=0\nf=[];(h+2).times{f<<[1]*(w+2)}\nh.times{|i|\n\ts=gets.chomp\n\tw.times{|j|\n\t\tif (k=d0.index(s[j..j]))\n\t\t\tx=j+1;y=i+1;d0.rotate!(k);d.rotate!(k)\n\t\tend\n\t\tif s[j..j]!='#'\n\t\t\tf[i+1][j+1]=nil\n\t\tend\n\t}\n}\nl.times{\n\t4.times{|i|\n\t\tif !f[y+d[i][1]][x+d[i][0]]\n\t\t\td0.rotate!(i);d.rotate!(i)\n\t\t\tx+=d[0][0];y+=d[0][1]\n\t\t\tbreak\n\t\tend\n\t}\n}\nputs \"#{y} #{x} #{d0[0]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "conv = {?N=>[-1,0], ?S=>[1,0], ?W=>[0,-1], ?E=>[0,1]}\n\nloop {\n\th, w, l = gets.split.map &:to_i\n\tbreak if w == 0\n\t\n\tloop_start = nil\n\tx = y = dx = dy = nil\n\n\tmaze = (1..h).map{ \"#\" + gets.chomp + \"#\" }\n\tmaze.unshift \"#\" * (w+1)\n\tmaze << \"#\" * (w+1)\n\t(1..h).each{|i|\n\t\t(1..w).each{|j|\n\t\t\tif maze[i][j] =~ /[NSWE]/\n\t\t\t\tdy, dx = conv[maze[i][j]]\n\t\t\t\ty = i\n\t\t\t\tx = j\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\t}\n\n\thash = {[x, y, dx, dy] => 0}\n\tloop {\n\t\twhile maze[y+dy][x+dx] == ?#\n\t\t\tdx, dy = -dy, dx \n\t\tend\n\t\tx += dx\n\t\ty += dy\n\t\tl -= 1\n\n\t\tbreak if hash[[x, y, dx, dy]] || l == 0\n\t\thash[[x, y, dx, dy]] = hash.size\n\t}\n\n\tif l == 0\n\t\tputs \"#{y} #{x} #{conv.invert[[dy, dx]]}\"\n\telse\n\t\ti = hash[[x, y, dx, dy]]\n\t\tx, y, dx, dy = hash.invert[i + l % (hash.size - i)]\n\t\tputs \"#{y} #{x} #{conv.invert[[dy, dx]]}\"\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\nwhile (h,w,l=gets.split.map(&:to_i))!=[0,0,0]\nd=[[0,-1],[1,0],[0,1],[-1,0]]\nd0=\"NESW\".split('')\nf=(h+2).times.map{[1]*(w+2)}\ng=(h+2).times.map{(w+2).times.map{[nil]*4}}\nz=x=y=0\nh.times{|i|\n\ts=gets.chomp\n\tw.times{|j|\n\t\tif (k=d0.index(s[j..j]))\n\t\t\tx=j+1;y=i+1;z=k\n\t\tend\n\t\tif s[j..j]!='#'\n\t\t\tf[i+1][j+1]=nil\n\t\tend\n\t}\n}\nc=0\nwhile l>0\n\tbreak if g[y][x][z]&&(l%=c-g[y][x][z])==0\n\tg[y][x][z]=c\n\twhile true\n\t\tif !f[y+d[z][1]][x+d[z][0]]\n\t\t\tx+=d[z][0];y+=d[z][1]\n\t\t\tbreak\n\t\tend\n\t\tz=(z+1)%4\n\tend\n\tl-=1\n\tc+=1\nend\nputs \"#{y} #{x} #{d0[z]}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "# Header {{{\nrequire 'forwardable'\n\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\nclass MyIO\n  def initialize\n    @source = STDIN\n  end\n\n  # @param filename [String]\n  def set_source(filename)\n    @source = File.open(filename, 'r')\n  end\n\n  def intl\n    splitl.map(&:to_i)\n  end\n\n  def splitl\n    @source.gets.chomp.split(' ')\n  end\n\n  def gets\n    @source.gets.chomp\n  end\nend\n\nclass Field\n  extend Forwardable\n  def_delegators :@field, :[]\n\n  DIRECTIONS = [:up, :right, :down, :left]\n\n  attr_accessor :h, :w\n\n  class DyDx\n    attr_accessor :y, :x\n\n    DYDX_BY_DIRECTIONS = { up: [-1, 0], right: [0, 1], down: [1, 0], left: [0, -1] }\n\n    class << self\n      DIRECTIONS.each do |dir|\n        define_method(dir.to_s) { self.new(dir, *DYDX_BY_DIRECTIONS[dir]) }\n      end\n    end\n\n    def initialize(id, y, x)\n      @id, @y, @x = id, y, x\n    end\n\n    def index\n      DIRECTIONS.find_index(@id)\n    end\n  end\n\n  class << self\n    def dydx4\n      [DyDx.up, DyDx.right, DyDx.down, DyDx.left]\n    end\n  end\n\n  def initialize(field)\n    assert(field.is_a?(Array))\n    assert(field[0].is_a?(Array))\n    @field = field\n    @h, @w = field.size, field[0].size\n  end\n\n  def inside?(y, x)\n    0 <= y && y < @h && 0 <= x && x < @w\n  end\n\n  def to_s\n    str = ''\n    @field.each do |row|\n      row.each do |cell|\n        str += cell.to_s\n      end\n      str += \"\\n\"\n    end\n    str\n  end\nend\n\nio = MyIO.new\n# }}}\n\nio.set_source('inputs/0.txt')\n\ndef dir2i(d)\n  { N: 0, E: 1, S: 2, W: 3 }[d.to_sym]\nend\n\ndef i2dir(i)\n  [ 'N', 'E', 'S', 'W' ][i]\nend\n\nclass Robot\n  attr_accessor :y, :x, :dir\n  def initialize(y, x, dir)\n    @y, @x, @dir = y, x, dir\n  end\n\n  def move(dydx)\n    self.class.new(@y + dydx.y, @x + dydx.x, dydx.index)\n  end\nend\n\nwhile true\n  h, w, l = io.intl\n  break if h == 0\n  robot = nil\n  _field = []\n  h.times do |i|\n    _field << io.gets.split('')\n    w.times do |j|\n      unless ['.', '#'].include?(_field[i][j])\n        robot = Robot.new(i, j, dir2i(_field[i][j]))\n        _field[i][j] = '.'\n      end\n    end\n  end\n  field = Field.new(_field)\n\n  @cost = Array.new(h) { Array.new(w) { Array.new(4, nil) } }\n  def cost_of(rob)\n    @cost[rob.y][rob.x][rob.dir]\n  end\n  def set_cost(rob, val)\n    @cost[rob.y][rob.x][rob.dir] = val\n  end\n\n  looped = false\n  dist = 0\n  while true\n    set_cost(robot, dist)\n    if dist == l\n      break\n    end\n\n    moved = false\n    4.times do |d|\n      di = (robot.dir + d) % 4\n      dydx = Field.dydx4[di]\n      nr = robot.move(dydx)\n      if field.inside?(nr.y, nr.x) && field[nr.y][nr.x] == '.'\n        if !looped && !cost_of(nr).nil?\n          looped = true\n          rest = l - dist\n          loop_len = cost_of(robot) - cost_of(nr) + 1\n          rest %= loop_len\n          l = rest\n          dist = 0\n        end\n\n        robot = nr\n        moved = true\n        dist += 1\n        break\n      end\n    end\n    assert(moved)\n  end\n\n  puts [robot.y + 1, robot.x + 1, i2dir(robot.dir)].join(' ')\nend\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\n#codeeval57\n\nif RUBY_VERSION<'1.9'\nclass Array\n\tdef rotate(n=1) (self[0,n].reverse+self[n..-1].reverse).reverse end\n\tdef rotate!(n=1) self.replace(rotate(n)) end\nend\nend\n\nwhile (h,w,l=gets.split.map(&:to_i))!=[0,0,0]\nd=[[0,-1],[1,0],[0,1],[-1,0]]\nd0=\"NESW\".split('')\nx=y=0\nf=[];(h+2).times{f<<[1]*(w+2)}\nh.times{|i|\n\ts=gets.chomp\n\tw.times{|j|\n\t\tif (k=d0.index(s[j..j]))\n\t\t\tx=j+1;y=i+1;d0.rotate!(k);d.rotate!(k)\n\t\tend\n\t\tif s[j..j]!='#'\n\t\t\tf[i+1][j+1]=nil\n\t\tend\n\t}\n}\nl.times{\n\t4.times{|i|\n\t\tif !f[y+d[i][1]][x+d[i][0]]\n\t\t\td0.rotate!(i);d.rotate!(i)\n\t\t\tx+=d[0][0];y+=d[0][1]\n\t\t\tbreak\n\t\tend\n\t}\n}\nputs \"#{y} #{x} #{d0[0]}\"\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint H, W; long L;\nstring[] F;\nbool input() {\n    scanf(\"%d %d %lld\\n\", &H, &W, &L);\n    if (H == 0 && W == 0 && L == 0) return false;\n    F = new string[H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp;\n    }\n    return true;\n}\n\nint[char] M;\nstatic this() {\n    M = [ 'N': 0, 'E': 1, 'S': 2, 'W': 3 ];\n}\n\nvoid getPos(out int y, out int x, out int dir) {\n    foreach (int i; 0 .. H) {\n        foreach (int j; 0 .. W) {\n            if (F[i][j] in M) {\n                y = i; x = j; dir = M[ F[i][j] ];\n                return;\n            }\n        }\n    }\n    assert(0);\n}\n\nconst dy = [-1, 0, 1, 0],\n      dx = [0, 1, 0, -1];\n\nvoid turn(int y, int x, ref int dir) {\n    int ndir = dir;\n    int ny = y + dy[ndir],\n        nx = x + dx[ndir];\n    while (ny < 0 || ny >= H || nx < 0 || nx >= W || F[ny][nx] == '#') {\n        ndir = (ndir + 1) % 4;\n        ny = y + dy[ndir];\n        nx = x + dx[ndir];\n    }\n    dir = ndir;\n}\n\nvoid step(ref int y, ref int x, ref int dir) {\n    int ndir = dir;\n    int ny = y + dy[ndir],\n        nx = x + dx[ndir];\n    while (ny < 0 || ny >= H || nx < 0 || nx >= W || F[ny][nx] == '#') {\n        ndir = (ndir + 1) % 4;\n        ny = y + dy[ndir];\n        nx = x + dx[ndir];\n    }\n    y = ny; x = nx; dir = ndir;\n}\n\nvoid solve() {\n    int y, x, dir; getPos(y, x, dir);\n\n    struct P {\n        int y, x, dir;\n        string toString() const {\n            return format(\"%d %d %s\", y + 1, x + 1, \"NESW\"[dir]);\n        }\n    }\n\n    auto U = new int[][][](H, W, 4);\n    foreach (i; 0 .. H) foreach (j; 0 .. W) U[i][j][] = -1;\n    P[long] X; X[0] = P(y, x, dir);\n    int t = 0;\n    int cycle;\n    while (true) {\n        if (U[y][x][dir] >= 0) {\n            cycle = t - U[y][x][dir];\n            t = U[y][x][dir];\n            break;\n        }\n        U[y][x][dir] = t;\n        X[t] = P(y, x, dir);\n        turn(y, x, dir);\n        step(y, x, dir);\n        t++;\n    }\n\n    //writeln([t, cycle]);\n    writeln(X[(L - t) % cycle + t]);\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint H, W; long L;\nstring[] F;\nbool input() {\n    scanf(\"%d %d %lld\\n\", &H, &W, &L);\n    if (H == 0 && W == 0 && L == 0) return false;\n    F = new string[H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp;\n    }\n    return true;\n}\n\nint[char] M;\nstatic this() {\n    M = [ 'N': 0, 'E': 1, 'S': 2, 'W': 3 ];\n}\n\nvoid getPos(out int y, out int x, out int dir) {\n    foreach (int i; 0 .. H) {\n        foreach (int j; 0 .. W) {\n            if (F[i][j] in M) {\n                y = i; x = j; dir = M[ F[i][j] ];\n                return;\n            }\n        }\n    }\n    assert(0);\n}\n\nconst dy = [-1, 0, 1, 0],\n      dx = [0, 1, 0, -1];\n\nvoid turn(int y, int x, ref int dir) {\n    int ndir = dir;\n    int ny = y + dy[ndir],\n        nx = x + dx[ndir];\n    while (ny < 0 || ny >= H || nx < 0 || nx >= W || F[ny][nx] == '#') {\n        ndir = (ndir + 1) % 4;\n        ny = y + dy[ndir];\n        nx = x + dx[ndir];\n    }\n    dir = ndir;\n}\n\nvoid step(ref int y, ref int x, ref int dir) {\n    int ndir = dir;\n    int ny = y + dy[ndir],\n        nx = x + dx[ndir];\n    while (ny < 0 || ny >= H || nx < 0 || nx >= W || F[ny][nx] == '#') {\n        ndir = (ndir + 1) % 4;\n        ny = y + dy[ndir];\n        nx = x + dx[ndir];\n    }\n    y = ny; x = nx; dir = ndir;\n}\n\nstruct P {\n    int y, x, dir;\n    string toString() const {\n        return format(\"%d %d %s\", y + 1, x + 1, \"NESW\"[dir]);\n    }\n}\n\nvoid solve1() {\n    int y, x, dir; getPos(y, x, dir);\n    foreach (i; 0 .. L) {\n        step(y, x, dir);\n    }\n    writeln(P(y, x, dir));\n}\n\nvoid solve() {\n\n    if (L <= H * W * 4) {\n        solve1();\n        return;\n    }\n\n    int y, x, dir; getPos(y, x, dir);\n\n    auto U = new int[][][](H, W, 4);\n    foreach (i; 0 .. H) foreach (j; 0 .. W) U[i][j][] = -1;\n    P[long] X;\n    int t = 0;\n    int cycle;\n    while (true) {\n        if (U[y][x][dir] >= 0) {\n            cycle = t - U[y][x][dir];\n            t = U[y][x][dir];\n            break;\n        }\n        U[y][x][dir] = t;\n        X[t] = P(y, x, dir);\n        turn(y, x, dir);\n        step(y, x, dir);\n        t++;\n    }\n\n    //writeln([t, cycle]);\n    writeln(X[(L - t) % cycle + t]);\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\n\nwhile True:\n    c_ = []\n    H, W, L = map(int, raw_input().split())\n    if H == 0:\n        break\n    m = {}\n    start = 0\n    for i in range(H):\n        S = raw_input()\n        c_.append(S)\n        for d in ['N', 'E', 'S', 'W']:\n            index = S.find(d)\n            if index != -1:\n                start = (i, index, d)\n    \n    def c(y, x):\n        if y < 0 or x < 0 or y >= H or x >= W:\n            return '#'\n        if c_[y][x] == '#':\n            return '#'\n        return '.'\n\n    def func(y, x, d, step):\n        if step == 0:\n            print str(y + 1) + \" \" + str(x + 1) + \" \" + d\n            return\n        if (y, x, d) in m and step < m[(y, x, d)]:\n            step %= m[(y, x, d)] - step\n        m[(y, x, d)] = step\n        if d == 'N':\n            if c(y - 1, x) == '#':\n                d = 'E'\n                return func(y, x, d, step)\n            else:\n                return func(y - 1, x, d, step - 1)\n        if d == 'E':\n            if c(y, x + 1) == '#':\n                d = 'S'\n                return func(y, x, d, step)\n            else:\n                return func(y, x + 1, d, step - 1)\n        if d == 'S':\n            if c(y + 1, x) == '#':\n                d = 'W'\n                return func(y, x, d, step)\n            else:\n                return func(y + 1, x, d, step - 1)\n        if d == 'W':\n            if c(y, x - 1) == '#':\n                d = 'N'\n                return func(y, x, d, step)\n            else:\n                return func(y, x - 1, d, step - 1)\n    func(start[0], start[1], start[2], L)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nwhile True:\n    c_ = []\n    H, W, L = map(int, raw_input().split())\n    if H == 0:\n        break\n    m = {}\n    start = 0\n    for i in range(H):\n        S = raw_input()\n        c_.append(S)\n        for d in ['N', 'E', 'S', 'W']:\n            index = S.find(d)\n            if index != -1:\n                start = (i, index, d)\n    \n    def c(y, x):\n        if y < 0 or x < 0 or y >= H or x >= W:\n            return '#'\n        if c_[y][x] == '#':\n            return '#'\n        return '.'\n\n    def func(y, x, d, step):\n        if step == 0:\n            print str(y + 1) + \" \" + str(x + 1) + \" \" + d\n            return\n        if (y, x, d) in m and step < m[(y, x, d)]:\n            step %= m[(y, x, d)] - step\n        m[(y, x, d)] = step\n        if d == 'N':\n            if c(y - 1, x) == '#':\n                d = 'E'\n                return func(y, x, d, step)\n            else:\n                return func(y - 1, x, d, step - 1)\n        if d == 'E':\n            if c(y, x + 1) == '#':\n                d = 'S'\n                return func(y, x, d, step)\n            else:\n                return func(y, x + 1, d, step - 1)\n        if d == 'S':\n            if c(y + 1, x) == '#':\n                d = 'W'\n                return func(y, x, d, step)\n            else:\n                return func(y + 1, x, d, step - 1)\n        if d == 'W':\n            if c(y, x - 1) == '#':\n                d = 'N'\n                return func(y, x, d, step)\n            else:\n                return func(y, x - 1, d, step - 1)\n    func(start[0], start[1], start[2], L)\n\n"
  },
  {
    "language": "Python",
    "code": "dxy = zip([1,0,-1,0],[0,1,0,-1])\nwhile 1:\n    H,W,L = map(int,raw_input().split())\n    if H == 0: break\n    c = [raw_input() for i in xrange(H)]\n    \n    for h in xrange(H):\n        for w in xrange(W):\n            if c[h][w] in \"ESWN\":\n                x,y = w,h\n                d = \"ESWN\".index(c[h][w])\n\n    visited = [[[-1]*4 for i in xrange(W)] for j in xrange(H)]\n    visited[y][x][d] = 0\n    step = 0\n    inloop = False\n    while L:\n        dx,dy = dxy[d]\n        nx,ny = x+dx,y+dy\n        if not (0 <= nx < W and 0 <= ny < H and c[ny][nx] != \"#\"):\n            d = (d+1)%4\n        else:\n            x,y = nx,ny\n            step += 1\n            L -= 1\n        if visited[y][x][d] > -1 and not inloop:\n            L %= step-visited[y][x][d]\n            L += step-visited[y][x][d]\n            inloop = True\n        visited[y][x][d] = step\n    print y+1,x+1,\"ESWN\"[d]"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    did = {}\n    did['N'] = 0\n    did['E'] = 1\n    did['S'] = 2\n    did['W'] = 3\n\n    while True:\n        h,w,l = LI()\n        if h == 0:\n            break\n\n        a = [[c for c in S()] for _ in range(h)]\n        s = None\n        for i in range(h):\n            for j in range(w):\n                if a[i][j] in 'NEWS':\n                    s = (i,j,did[a[i][j]])\n                    break\n\n        i = 0\n        t = s\n        td = {}\n        tt = 0\n        i,j,dk = t\n        while tt < l:\n            tt += 1\n            for ddi in range(4):\n                di,dj = dd[(dk+ddi) % 4]\n                ni = i + di\n                nj = j + dj\n                if ni < 0 or ni >= h or nj < 0 or nj >= w or a[ni][nj] == '#':\n                    continue\n                dk = (dk + ddi) % 4\n                i = ni\n                j = nj\n                break\n            if (i,j,dk) in td:\n                tt += (l-tt) // (tt - td[(i,j,dk)]) * (tt - td[(i,j,dk)])\n            else:\n                td[(i,j,dk)] = tt\n        rr.append('{} {} {}'.format(i+1,j+1,'NESW'[dk]))\n\n    return '\\n'.join(map(str,rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "dxy = zip([1,0,-1,0],[0,1,0,-1])\nwhile 1:\n    H,W,L = map(int,raw_input().split())\n    if H == 0: break\n    c = [raw_input() for i in xrange(H)]\n    \n    for h in xrange(H):\n        for w in xrange(W):\n            if c[h][w] in \"ESWN\":\n                x,y = w,h\n                d = \"ESWN\".index(c[h][w])\n\n    visited = [[[-1]*4 for i in xrange(W)] for j in xrange(H)]\n    visited[y][x][d] = 0\n    step = 0\n    inloop = False\n    while L:\n        dx,dy = dxy[d]\n        nx,ny = x+dx,y+dy\n        if not (0 <= nx < W and 0 <= ny < H and c[ny][nx] != \"#\"):\n            d = (d+1)%4\n        else:\n            x,y = nx,ny\n            step += 1\n            L -= 1\n        if visited[y][x][d] > -1 and not inloop:\n            L %= step-visited[y][x][d]\n            inloop = True\n        visited[y][x][d] = step\n    print y+1,x+1,\"ESWN\"[d]"
  }
]