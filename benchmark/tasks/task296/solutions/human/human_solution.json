[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(W,n)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {REP(aaa,i){REP(bbb,j)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(segment(A, B), l));\n  }\n  return Q;\n}\n\nint n;\nvector<point> v;\ndouble mi = INF;\ndouble ma = 0;\ndouble sumS,nowS;\n\ndouble triArea(int a,int b,int c){\n\ta %= n;b %= n;c %= n;\n\tif(a == b || b == c || c == a)return 0;\n\tvector<point> tmp = {v[a],v[b],v[c]};\n\treturn area(tmp);\n}\n\nvoid checkVertex(int p,int q) {\n\tp %= n;q %= n;\n\tdouble remain = (sumS / 2) - nowS;\n\tdouble rate = remain / triArea(p,q,q+1);\n\tpoint tmp = v[q] + rate * (v[(q+1)%n] - v[q]);\n\t//cout << \"# p \" << p << \" q \" << q << \" rate \" << rate << \" dist \" << distancePP(v[p],tmp) << endl;\n\tmi = min(mi, distancePP(v[p],tmp));\n\tma = max(ma, distancePP(v[p],tmp));\n}\n\ndouble seica(int a,int b){\n\ta %= n;b %= n;\n\tvector<point> tmp;\n\tint i = a;\n\twhile(1){\n\t\ttmp.EB(v[i]);\n\t\tif(i == b)break;\n\t\ti = (i + 1) % n;\n\t}\n\tif(tmp.size() < 3)return 0;\n\telse return area(tmp);\n}\n\nvoid checkSegment(int p,int q){\n\tp %= n;q %= n;\n\tnowS -= triArea(p,p+1,q);\n\tsegment a(v[(p+1)%n],v[p]);\n\tsegment b(v[q],v[(q+1)%n]);\n\tpoint crossP = crosspoint(a,b);\n\tif(crossP == point(INF,INF)){\n\t\t//cout << \"heikou\" << endl;\n\t\tdouble sqS = area({v[p],v[(p+1)%n],v[q],v[(q+1)%n]});\n\t\tif(nowS + sqS < sumS / 2 + EPS)return;\n\t\tbool flag = false;\n\t\tif(intersectSP(b,projection(b,a[0])) || intersectSP(b,projection(b,a[1])))flag = true;\n\t\tif(intersectSP(a,projection(a,b[0])) || intersectSP(a,projection(a,b[1])))flag = true;\n\t\tif(!flag)return;\n\t\tmi = min(mi,distanceLP(b,a[0]));\n\t\treturn;\n\t}\n\t//cout << \"cross \" << crossP.X << \" \" << crossP.Y << endl;\n\tdouble tmpS;\n\tif(distancePP(crossP,a[0]) > distancePP(crossP,a[1]) + EPS){\n\t\ttmpS = seica(q+1,p);\n\t\tswap(a[0],a[1]);\n\t\tswap(b[0],b[1]);\n\t}\n\telse{\n\t\ttmpS = seica(p+1,q);\n\t}\n\tdouble theta = angle(a, b);\n\tdouble T = distancePP(crossP,a[0]) * distancePP(crossP, b[0]) * sin(theta) / 2;\n\tdouble leg = (2 * (T - tmpS) + sumS) / sin(theta);\n\t//cout << \"T \" << T << \" leg \" << leg << endl;\n\tbool flag = false;\n\tif(leg > distancePP(a[1],crossP) * distancePP(a[1],crossP) + EPS)flag = true;\n\tif(leg + EPS < distancePP(a[0],crossP) * distancePP(a[0],crossP))flag = true;\n\tif(leg > distancePP(b[1],crossP) * distancePP(b[1],crossP) + EPS)flag = true;\n\tif(leg + EPS <  distancePP(b[0],crossP) * distancePP(b[0],crossP))flag = true;\n\tif(flag)return;\n\tmi = min(mi,sqrt(2 * leg * (1 - cos(theta))));\n}\n\nint main() {\n\n\tcin >> n;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.EB(a,b);\n\t}\n\n\tint q = 1;\n\tsumS = area(v);\n\t//cout << \"sumS \" << sumS << endl;\n\tREP(i,n){\n\t\t//cout << \"##################################################\" << endl;\n\t\twhile(nowS + triArea(i,q,q+1) < sumS / 2 + EPS){\n\t\t\tnowS += triArea(i,q,q+1);\n\t\t\tq++;\n\t\t}\n\t\t//cout << \"nowS \" << nowS << \" \" << nowS + triArea(i,q,q+1) << \" \" <<  sumS / 2 + EPS << endl;\n\t\tcheckVertex(i, q);\n\t\tcheckSegment(i, q);\n\t}\n\n\tcout << Decimal << mi << endl;\n\tcout << Decimal << ma << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(W,n)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {REP(aaa,i){REP(bbb,j)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(segment(A, B), l));\n  }\n  return Q;\n}\n\nint n;\nvector<point> v;\ndouble mi = INF;\ndouble ma = 0;\ndouble sumS,nowS;\n\ndouble triArea(int a,int b,int c){\n\ta %= n;b %= n;c %= n;\n\tif(a == b || b == c || c == a)return 0;\n\tvector<point> tmp = {v[a],v[b],v[c]};\n\treturn area(tmp);\n}\n\nvoid checkVertex(int p,int q) {\n\tp %= n;q %= n;\n\tdouble remain = (sumS / 2) - nowS;\n\tdouble rate = remain / triArea(p,q,q+1);\n\tpoint tmp = v[q] + rate * (v[(q+1)%n] - v[q]);\n\t//cout << \"# p \" << p << \" q \" << q << \" rate \" << rate << \" dist \" << distancePP(v[p],tmp) << endl;\n\tmi = min(mi, distancePP(v[p],tmp));\n\tma = max(ma, distancePP(v[p],tmp));\n}\n\ndouble seica(int a,int b){\n\ta %= n;b %= n;\n\tvector<point> tmp;\n\tint i = a;\n\twhile(1){\n\t\ttmp.EB(v[i]);\n\t\tif(i == b)break;\n\t\ti = (i + 1) % n;\n\t}\n\tif(tmp.size() < 3)return 0;\n\telse return area(tmp);\n}\n\nvoid checkSegment(int p,int q){\n\tp %= n;q %= n;\n\tnowS -= triArea(p,p+1,q);\n\tsegment a(v[(p+1)%n],v[p]);\n\tsegment b(v[q],v[(q+1)%n]);\n\tpoint crossP = crosspoint(a,b);\n\tif(crossP == point(INF,INF)){\n\t\t//cout << \"heikou\" << endl;\n\t\tdouble sqS = area({v[p],v[(p+1)%n],v[q],v[(q+1)%n]});\n\t\tif(nowS + sqS < sumS / 2 + EPS)return;\n\t\tbool flag = false;\n\t\tif(intersectSP(b,projection(b,a[0])) || intersectSP(b,projection(b,a[1])))flag = true;\n\t\tif(intersectSP(a,projection(a,b[0])) || intersectSP(a,projection(a,b[1])))flag = true;\n\t\tif(!flag)return;\n\t\tmi = min(mi,distanceLP(b,a[0]));\n\t\treturn;\n\t}\n\t//cout << \"cross \" << crossP.X << \" \" << crossP.Y << endl;\n\tdouble tmpS;\n\tif(distancePP(crossP,a[0]) > distancePP(crossP,a[1]) + EPS){\n\t\ttmpS = seica(q+1,p);\n\t\tswap(a[0],a[1]);\n\t\tswap(b[0],b[1]);\n\t}\n\telse{\n\t\ttmpS = seica(p+1,q);\n\t}\n\tdouble theta = angle(a, b);\n\tdouble T = distancePP(crossP,a[0]) * distancePP(crossP, b[0]) * sin(theta) / 2;\n\tdouble leg = (2 * (T - tmpS) + sumS) / sin(theta);\n\t//cout << \"T \" << T << \" leg \" << leg << endl;\n\tbool flag = false;\n\tif(leg > distancePP(a[1],crossP) * distancePP(a[1],crossP) + EPS)flag = true;\n\tif(leg + EPS < distancePP(a[0],crossP) * distancePP(a[0],crossP))flag = true;\n\tif(leg > distancePP(b[1],crossP) * distancePP(b[1],crossP) + EPS)flag = true;\n\tif(leg + EPS <  distancePP(b[0],crossP) * distancePP(b[0],crossP))flag = true;\n\tif(flag)return;\n\t//cout << \"leg \" << leg << \" theta \" << theta << \" \" << Decimal << cos(theta) << endl;\n\tmi = min(mi,2 * sqrt(leg) * sin(theta / 2));\n}\n\nint main() {\n\n\tcin >> n;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.EB(a,b);\n\t}\n\n\tint q = 1;\n\tsumS = area(v);\n\t//cout << \"sumS \" << sumS << endl;\n\tREP(i,n){\n\t\t//cout << \"##################################################\" << endl;\n\t\twhile(nowS + triArea(i,q,q+1) < sumS / 2 + EPS){\n\t\t\tnowS += triArea(i,q,q+1);\n\t\t\tq++;\n\t\t}\n\t\t//cout << \"nowS \" << nowS << \" \" << nowS + triArea(i,q,q+1) << \" \" <<  sumS / 2 + EPS << endl;\n\t\tcheckVertex(i, q);\n\t\tcheckSegment(i, q);\n\t}\n\n\tcout << Decimal << mi << endl;\n\tcout << Decimal << ma << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(W,n)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {REP(aaa,i){REP(bbb,j)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(segment(A, B), l));\n  }\n  return Q;\n}\n\nint n;\nvector<point> v;\ndouble mi = INF;\ndouble ma = 0;\ndouble sumS,nowS;\n\ndouble triArea(int a,int b,int c){\n\ta %= n;b %= n;c %= n;\n\tif(a == b || b == c || c == a)return 0;\n\tvector<point> tmp = {v[a],v[b],v[c]};\n\treturn area(tmp);\n}\n\nvoid checkVertex(int p,int q) {\n\tp %= n;q %= n;\n\tdouble remain = (sumS / 2) - nowS;\n\tdouble rate = remain / triArea(p,q,q+1);\n\tpoint tmp = v[q] + rate * (v[(q+1)%n] - v[q]);\n\t//cout << \"# p \" << p << \" q \" << q << \" rate \" << rate << \" dist \" << distancePP(v[p],tmp) << endl;\n\tmi = min(mi, distancePP(v[p],tmp));\n\tma = max(ma, distancePP(v[p],tmp));\n}\n\nvoid checkSegment(int p,int q){\n\tp %= n;q %= n;\n\tnowS -= triArea(p,p+1,q);\n\tsegment a(v[(p+1)%n],v[p]);\n\tsegment b(v[q],v[(q+1)%n]);\n\tpoint crossP = crosspoint(a,b);\n\tif(crossP == point(INF,INF)){\n\t//\tcout << \"heikou\" << endl;\n\t\tdouble sqS = area({v[p],v[(p+1)%n],v[q],v[(q+1)%n]});\n\t\tif(nowS + sqS < sumS / 2 + EPS)return;\n\t\tif(!(intersectSP(b,projection(b,a[0])) || intersectSP(b,projection(b,a[1]))))return;\n\t\tmi = min(mi,distanceLP(b,a[0]));\n\t\treturn;\n\t}\n\t//cout << \"cross \" << crossP.X << \" \" << crossP.Y << endl;\n\tif(distancePP(crossP,a[0]) > distancePP(crossP,a[1]) + EPS){\n\t//\tcout << \"!\" << endl;\n\t\treturn;\n\t}\n\tif(distancePP(crossP,b[0]) > distancePP(crossP,b[1]) + EPS){\n\t//\tcout << \"!!\" << endl;\n\t\treturn;\n\t}\n\tdouble theta = angle(a, b);\n\tdouble T = distancePP(crossP,a[0]) * distancePP(crossP, b[0]) * sin(theta) / 2;\n\tdouble leg = (2 * (T - nowS) + sumS) / sin(theta);\n\t//cout << \"T \" << T << \" leg \" << leg << endl;\n\tif(leg > distancePP(a[1],crossP) * distancePP(a[1],crossP) + EPS){\n\t//\tcout << \"!!!\" << endl;\n\t\treturn;\n\t}\n\tif(leg + EPS < distancePP(a[0],crossP) * distancePP(a[0],crossP)){\n\t//\tcout << \"!!!\" << endl;\n\t\treturn;\n\t}\n\tif(leg > distancePP(b[1],crossP) * distancePP(b[1],crossP)){\n\t//\tcout << \"!!!!\" << endl;\n\t\treturn;\n\t}\n\tif(leg + EPS <  distancePP(b[0],crossP) * distancePP(b[0],crossP)){\n\t//\tcout << \"!!!!\" << endl;\n\t\treturn;\n\t}\n\t//cout << \"!!!!!!!!!!! \" << sqrt(2 * leg * (1 - cos(theta))) << endl;\n\tmi = min(mi,sqrt(2 * leg * (1 - cos(theta))));\n}\n\nint main() {\n\n\tcin >> n;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.EB(a,b);\n\t}\n\n\tint q = 1;\n\tsumS = area(v);\n\t//cout << \"sumS \" << sumS << endl;\n\tREP(i,n){\n\t//\tcout << \"##################################################\" << endl;\n\t\twhile(nowS + triArea(i,q,q+1) < sumS / 2 + EPS){\n\t\t\tnowS += triArea(i,q,q+1);\n\t\t\tq++;\n\t\t}\n\t//\tcout << \"nowS \" << nowS << endl;\n\t\tcheckVertex(i, q);\n\t\tcheckSegment(i, q);\n\t}\n\n\tcout << Decimal << mi << endl;\n\tcout << Decimal << ma << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(W,n)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {REP(aaa,i){REP(bbb,j)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(segment(A, B), l));\n  }\n  return Q;\n}\n\nint n;\nvector<point> v;\ndouble mi = INF;\ndouble ma = 0;\ndouble sumS,nowS;\n\ndouble triArea(int a,int b,int c){\n\ta %= n;b %= n;c %= n;\n\tif(a == b || b == c || c == a)return 0;\n\tvector<point> tmp = {v[a],v[b],v[c]};\n\treturn area(tmp);\n}\n\nvoid checkVertex(int p,int q) {\n\tp %= n;q %= n;\n\tdouble remain = (sumS / 2) - nowS;\n\tdouble rate = remain / triArea(p,q,q+1);\n\tpoint tmp = v[q] + rate * (v[(q+1)%n] - v[q]);\n\tmi = min(mi, distancePP(v[p],tmp));\n\tma = max(ma, distancePP(v[p],tmp));\n}\n\ndouble seica(int a,int b){\n\ta %= n;b %= n;\n\tvector<point> tmp;\n\tint i = a;\n\twhile(1){\n\t\ttmp.EB(v[i]);\n\t\tif(i == b)break;\n\t\ti = (i + 1) % n;\n\t}\n\tif(tmp.size() < 3)return 0;\n\telse return area(tmp);\n}\n\nvoid checkSegment(int p,int q){\n\tp %= n;q %= n;\n\tnowS -= triArea(p,p+1,q);\n\tsegment a(v[(p+1)%n],v[p]);\n\tsegment b(v[q],v[(q+1)%n]);\n\tpoint crossP = crosspoint(a,b);\n\tif(crossP == point(INF,INF)){\n\t\tdouble sqS = area({v[p],v[(p+1)%n],v[q],v[(q+1)%n]});\n\t\tif(nowS + sqS < sumS / 2 + EPS)return;\n\t\tbool flag = false;\n\t\tif(intersectSP(b,projection(b,a[0])) || intersectSP(b,projection(b,a[1])))flag = true;\n\t\tif(intersectSP(a,projection(a,b[0])) || intersectSP(a,projection(a,b[1])))flag = true;\n\t\tif(!flag)return;\n\t\tmi = min(mi,distanceLP(b,a[0]));\n\t\treturn;\n\t}\n\tdouble tmpS;\n\tif(distancePP(crossP,a[0]) > distancePP(crossP,a[1]) + EPS){\n\t\ttmpS = seica(q+1,p);\n\t\tswap(a[0],a[1]);\n\t\tswap(b[0],b[1]);\n\t}\n\telse{\n\t\ttmpS = seica(p+1,q);\n\t}\n\tdouble theta = angle(a, b);\n\tdouble T = distancePP(crossP,a[0]) * distancePP(crossP, b[0]) * sin(theta) / 2;\n\tdouble leg = (2 * (T - tmpS) + sumS) / sin(theta);\n\tbool flag = false;\n\tif(leg > distancePP(a[1],crossP) * distancePP(a[1],crossP) + EPS)flag = true;\n\tif(leg + EPS < distancePP(a[0],crossP) * distancePP(a[0],crossP))flag = true;\n\tif(leg > distancePP(b[1],crossP) * distancePP(b[1],crossP) + EPS)flag = true;\n\tif(leg + EPS <  distancePP(b[0],crossP) * distancePP(b[0],crossP))flag = true;\n\tif(flag)return;\n\tmi = min(mi,2 * sqrt(leg) * sin(theta / 2));\n}\n\nint main() {\n\n\tcin >> n;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.EB(a,b);\n\t}\n\n\tint q = 1;\n\tsumS = area(v);\n\tREP(i,n){\n\t\twhile(nowS + triArea(i,q,q+1) < sumS / 2 + EPS){\n\t\t\tnowS += triArea(i,q,q+1);\n\t\t\tq++;\n\t\t}\n\t\tcheckVertex(i, q);\n\t\tcheckSegment(i, q);\n\t}\n\n\tcout << Decimal << mi << endl;\n\tcout << Decimal << ma << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(W,n)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {REP(aaa,i){REP(bbb,j)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(segment(A, B), l));\n  }\n  return Q;\n}\n\nint n;\nvector<point> v;\ndouble mi = INF;\ndouble ma = 0;\ndouble sumS,nowS;\n\ndouble triArea(int a,int b,int c){\n\ta %= n;b %= n;c %= n;\n\tif(a == b || b == c || c == a)return 0;\n\tvector<point> tmp = {v[a],v[b],v[c]};\n\treturn area(tmp);\n}\n\nvoid checkVertex(int p,int q) {\n\tp %= n;q %= n;\n\tdouble remain = (sumS / 2) - nowS;\n\tdouble rate = remain / triArea(p,q,q+1);\n\tpoint tmp = v[q] + rate * (v[(q+1)%n] - v[q]);\n\t//cout << \"# p \" << p << \" q \" << q << \" rate \" << rate << \" dist \" << distancePP(v[p],tmp) << endl;\n\tmi = min(mi, distancePP(v[p],tmp));\n\tma = max(ma, distancePP(v[p],tmp));\n}\n\ndouble seica(int a,int b){\n\ta %= n;b %= n;\n\tvector<point> tmp;\n\tint i = a;\n\twhile(1){\n\t\ttmp.EB(v[i]);\n\t\tif(i == b)break;\n\t\ti = (i + 1) % n;\n\t}\n\tif(tmp.size() < 3)return 0;\n\telse return area(tmp);\n}\n\nvoid checkSegment(int p,int q){\n\tp %= n;q %= n;\n\tnowS -= triArea(p,p+1,q);\n\tsegment a(v[(p+1)%n],v[p]);\n\tsegment b(v[q],v[(q+1)%n]);\n\tpoint crossP = crosspoint(a,b);\n\tif(crossP == point(INF,INF)){\n\t//\tcout << \"heikou\" << endl;\n\t\tdouble sqS = area({v[p],v[(p+1)%n],v[q],v[(q+1)%n]});\n\t\tif(nowS + sqS < sumS / 2 + EPS)return;\n\t\tbool flag = false;\n\t\tif(intersectSP(b,projection(b,a[0])) || intersectSP(b,projection(b,a[1])))flag = true;\n\t\tif(intersectSP(a,projection(a,b[0])) || intersectSP(a,projection(a,b[1])))flag = true;\n\t\tif(!flag)return;\n\t\tmi = min(mi,distanceLP(b,a[0]));\n\t\treturn;\n\t}\n\t//cout << \"cross \" << crossP.X << \" \" << crossP.Y << endl;\n\tdouble tmpS;\n\tif(distancePP(crossP,a[0]) > distancePP(crossP,a[1]) + EPS){\n\t\ttmpS = seica(q+1,p);\n\t\tswap(a[0],a[1]);\n\t\tswap(b[0],b[1]);\n\t}\n\telse{\n\t\ttmpS = seica(p+1,q);\n\t}\n\tdouble theta = angle(a, b);\n\tdouble T = distancePP(crossP,a[0]) * distancePP(crossP, b[0]) * sin(theta) / 2;\n\tdouble leg = (2 * (T - tmpS) + sumS) / sin(theta);\n\t//cout << \"T \" << T << \" leg \" << leg << endl;\n\tbool flag = false;\n\tif(leg > distancePP(a[1],crossP) * distancePP(a[1],crossP) + EPS)flag = true;\n\tif(leg + EPS < distancePP(a[0],crossP) * distancePP(a[0],crossP))flag = true;\n\tif(leg > distancePP(b[1],crossP) * distancePP(b[1],crossP) + EPS)flag = true;\n\tif(leg + EPS <  distancePP(b[0],crossP) * distancePP(b[0],crossP))flag = true;\n\tif(flag)return;\n\tmi = min(mi,sqrt(2 * leg * (1 - cos(theta))));\n}\n\nint main() {\n\n\tcin >> n;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.EB(a,b);\n\t}\n\n\tint q = 1;\n\tsumS = area(v);\n\t//cout << \"sumS \" << sumS << endl;\n\tREP(i,n){\n\t//\tcout << \"##################################################\" << endl;\n\t\twhile(nowS + triArea(i,q,q+1) < sumS / 2 + EPS){\n\t\t\tnowS += triArea(i,q,q+1);\n\t\t\tq++;\n\t\t}\n\t//\tcout << \"nowS \" << nowS << endl;\n\t\tcheckVertex(i, q);\n\t\tcheckSegment(i, q);\n\t}\n\n\tcout << Decimal << mi << endl;\n\tcout << Decimal << ma << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n#define track() cout<<\"AAAAAAAAA\"<<endl;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return equals(x,p.x) ? y-p.y<-eps : x-p.x<-eps; }\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\ndouble Area(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i],p[(i+1)%n]);\n  return area/2.0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\nbool onLine(Line L,Point p){ return getDistanceLP(L,p)<eps; }\nbool onSegment(Segment s,Point p){\n  if(!onLine(s,p))return false;\n  if(dot(s.p2-s.p1,p-s.p1)<-eps)return false;\n  if(dot(s.p1-s.p2,p-s.p2)<-eps)return false;\n  return true;\n}\n\ntypedef pair<Point,Point> pp;\n\nint n,m;\nPolygon P;\nvector<Point> D;\nvector<pp> V;\ndouble area;\n\nPoint cal(Point base,int i){\n  double sum = 0.0,t = 0.0;\n  while(1){\n    t = cross(P[i]-base,P[(i+1)%n]-base)/2.0;\n    if(area<sum+t)break;\n    i = (i+1)%n;\n    sum+=t;\n  }\n  double a = (area-sum)/t;\n  Vector v = P[(i+1)%n]-P[i];\n  return P[i]+v*a;\n}\n\nPoint Search(Point base,Point a,Point b,double X){\n  Vector v = b-a;\n  v = v/abs(b-a);\n  double L = 0.0, R = abs(b-a), M;\n  FOR(i,0,50){\n    M = (L+R)/2.0;\n    Point c = a+v*M;\n    if(X>cross(a-base,c-base)/2.0)L = M;\n    else R = M;\n  }\n  return a+v*M;\n}\n\ndouble Minimum(){\n  double res = inf;\n  FOR(i,0,m){\n    int j = (i+1)%m;\n    Vector v = V[j].f-V[i].f;\n    double dis = abs(v);\n    double X = cross(V[j].f-V[i].f,V[i].s-V[i].f)/2.0;\n    v = v/dis;\n    double L=0.0,R=dis;\n    FOR(k,0,50){\n      double m1=(L*phi+R)/(1.0+phi);\n      double m2=(L+R*phi)/(1.0+phi);\n      Point p1 = V[i].f+v*m1;\n      Point p2 = V[i].f+v*m2;\n      double y1 = cross(V[j].f-p1,V[i].s-p1)/2.0;\n      double y2 = cross(V[j].f-p2,V[i].s-p2)/2.0;\n      Point p3 = Search(p1,V[i].s,V[j].s,X-y1);\n      Point p4 = Search(p2,V[i].s,V[j].s,X-y2);\n      double res1 = abs(p1-p3);\n      double res2 = abs(p2-p4);\n      if(res1<res2)R=m2;\n      else L=m1;\n      res = min(res,res1);\n    }\n  }\n  return res;\n}\n\ndouble Maximum(){\n  double res = 0.0;\n  FOR(i,0,V.size())res = max(res,abs(V[i].f-V[i].s));\n  return res;\n}\n\nvoid solve(){\n  area = Area(P)/2.0;\n  FOR(i,0,n)D.pb(cal(P[i],(i+1)%n));\n  FOR(i,0,n){\n    Segment S = Segment(P[i],P[(i+1)%n]);\n    vector<pair<double,pp> > tmp;\n    V.pb(mp(P[i],D[i]));\n    FOR(j,0,n){\n      if(D[j]==P[i])continue;\n      if(D[j]==P[(i+1)%n])continue;\n      if(onSegment(S,D[j]))tmp.pb(mp(abs(P[i]-D[j]),mp(D[j],P[j])));\n    }\n    sort(all(tmp));\n    FOR(j,0,tmp.size())V.pb(tmp[j].s);\n  }\n  m = V.size();\n  pd(Minimum());\n  pd(Maximum());\n  return;\n}\n\nint main()\n{\n  cin>>n;\n  P.resize(n);\n  FOR(i,0,n)cin>>P[i].x>>P[i].y;\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(W,n)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {REP(aaa,i){REP(bbb,j)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\nint n;\nvector<point> v;\ndouble mi = INF;\ndouble ma = 0;\ndouble sumS,nowS;\n\ndouble triArea(int a,int b,int c){\n\ta %= n;b %= n;c %= n;\n\tif(a == b || b == c || c == a)return 0;\n\tvector<point> tmp = {v[a],v[b],v[c]};\n\treturn area(tmp);\n}\n\nvoid checkVertex(int p,int q) {\n\tp %= n;q %= n;\n\tdouble remain = (sumS / 2) - nowS;\n\tdouble rate = remain / triArea(p,q,q+1);\n\tpoint tmp = v[q] + rate * (v[(q+1)%n] - v[q]);\n\tmi = min(mi, distancePP(v[p],tmp));\n\tma = max(ma, distancePP(v[p],tmp));\n}\n\ndouble seica(int a,int b){\n\ta %= n;b %= n;\n\tvector<point> tmp;\n\tint i = a;\n\twhile(1){\n\t\ttmp.EB(v[i]);\n\t\tif(i == b)break;\n\t\ti = (i + 1) % n;\n\t}\n\tif(tmp.size() < 3)return 0;\n\telse return area(tmp);\n}\n\nvoid checkSegment(int p,int q){\n\tp %= n;q %= n;\n\tnowS -= triArea(p,p+1,q);\n\tsegment a(v[(p+1)%n],v[p]);\n\tsegment b(v[q],v[(q+1)%n]);\n\tpoint crossP = crosspoint(a,b);\n\tif(crossP == point(INF,INF)){\n\t\tdouble sqS = area({v[p],v[(p+1)%n],v[q],v[(q+1)%n]});\n\t\tif(nowS + sqS < sumS / 2 + EPS)return;\n\t\tbool flag = false;\n\t\tif(intersectSP(b,projection(b,a[0])) || intersectSP(b,projection(b,a[1])))flag = true;\n\t\tif(intersectSP(a,projection(a,b[0])) || intersectSP(a,projection(a,b[1])))flag = true;\n\t\tif(!flag)return;\n\t\tmi = min(mi,distanceLP(b,a[0]));\n\t\treturn;\n\t}\n\tdouble tmpS;\n\tif(distancePP(crossP,a[0]) > distancePP(crossP,a[1]) + EPS){\n\t\ttmpS = seica(q+1,p);\n\t\tswap(a[0],a[1]);\n\t\tswap(b[0],b[1]);\n\t}\n\telse{\n\t\ttmpS = seica(p+1,q);\n\t}\n\tdouble theta = angle(a, b);\n\tdouble T = distancePP(crossP,a[0]) * distancePP(crossP, b[0]) * sin(theta) / 2;\n\tdouble leg = (2 * (T - tmpS) + sumS) / sin(theta);\n\tbool flag = false;\n\tif(leg > distancePP(a[1],crossP) * distancePP(a[1],crossP) + EPS)flag = true;\n\tif(leg + EPS < distancePP(a[0],crossP) * distancePP(a[0],crossP))flag = true;\n\tif(leg > distancePP(b[1],crossP) * distancePP(b[1],crossP) + EPS)flag = true;\n\tif(leg + EPS <  distancePP(b[0],crossP) * distancePP(b[0],crossP))flag = true;\n\tif(flag)return;\n\tmi = min(mi,2 * sqrt(leg) * sin(theta / 2));\n}\n\nint main() {\n\n\tcin >> n;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.EB(a,b);\n\t}\n\n\tint q = 1;\n\tsumS = area(v);\n\tREP(i,n){\n\t\twhile(nowS + triArea(i,q,q+1) < sumS / 2 + EPS){\n\t\t\tnowS += triArea(i,q,q+1);\n\t\t\tq++;\n\t\t}\n\t\tcheckVertex(i, q);\n\t\tcheckSegment(i, q);\n\t}\n\n\tcout << Decimal << mi << endl;\n\tcout << Decimal << ma << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(W,n)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {REP(aaa,i){REP(bbb,j)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n//--------geometry original ------------------\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\n#define diff(PP, i) (next(PP, i) - curr(PP, i))\n#define X real()\n#define Y imag()\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const point& a, const point& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\n\tbool operator == (const point& a,const point& b) {\n\t\treturn (abs(a.real() - b.real()) < EPS && abs(a.imag() - b.imag()) < EPS);\n\t}\n}\nstruct circle {\n\tpoint p; double r;\n\tcircle(){}\n\tcircle(const point &p, double r) : p(p), r(r) { }\n};\nstruct segment : public vector<point> {\n\tsegment(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\n\n/*\na → b で時計方向に折れて b → c\na → b で半時計方向に折れて b → c\na → b で逆を向いて a を通り越して b → c\na → b でそのまま b → c\na → b で逆を向いて b → c ( または b == c )\n*/\n\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const segment &l, const segment &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const segment &l, const segment &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const segment &l, const point &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSP(const segment &s, const point &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n//端点の交差も考える\nbool intersectSS(const segment &s, const segment &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint projection(const segment &l, const point &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\npoint reflection(const segment &l, const point &p) {\n\treturn p + 2. * (projection(l, p) - p);\n}\ndouble distanceLP(const segment &l, const point &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const segment &l, const segment &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const segment &l, const segment &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const segment &s, const point &p) {\n\tconst point r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const segment &s, const segment &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP(const point &a,const point &b){\n\treturn abs(a-b);\n}\n\n//交点\npoint crosspoint(const segment &l, const segment &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) return point(INF,INF); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n//凸包\nvector<point> convex_hull(vector<point> ps) {\n\tint n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tvector<point> ch(2*n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n\t\twhile (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tfor (int i = n-2, t = k+1;i >= 0; ch[k++] = ps[i--]) // upper-hull\n\t\twhile (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) == -1) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n/*多角形内包判定\nOUT:0\nON:1\nIN:2\n*/\n\nint contains(const vector<point>& Poly, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < Poly.size(); ++i) {\n\t\tpoint a = curr(Poly, i) - p, b = next(Poly, i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n//見えるか(可視グラフ用)\nbool block_off(const point &a, const point &b, const vector<point> &obj) {\n  point m = (a+b)/2.0;\n  bool on = false, in = false;\n  for (int j = 0; j < obj.size(); ++j) {\n    point c = curr(obj,j), d = next(obj,j);\n    if (imag(d) < imag(c)) swap(c, d);\n    if (cross(a-c,b-c) * cross(a-d,b-d) < 0 &&    // strictly intersect.\n        cross(c-a,d-a) * cross(c-b,d-b) < 0) return true;\n    if (cross(a-c,b-c) == 0 && dot(a-c,b-c) < 0) return true;\n    if (imag(c) <= imag(m) && imag(m) < imag(d))  // strictly contain.\n      if (cross(c-m,d-m) < 0) in = !in;\n    if (cross(c-m,d-m) == 0 && dot(c-m,d-m) <= 0) on = true;\n  }\n  return !on && in;\n}\n\n//面積\ndouble area(const vector<point>& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.;\n}\n\n//角度足し算\ndouble add_rad(double a,double b){\n\tdouble ret = a + b;\n\tif(ret > PI)ret -= 2 * PI;\n\treturn ret;\n}\n\n//なす角(vector)\ndouble angle(const point &a,const point &b) {\n\tauto tmp = abs(arg(a) - arg(b));\n\treturn min(tmp, 2 * PI - tmp);\n}\n\ndouble angle(const segment &s1,const segment &s2) {\n\treturn angle(s1[1] - s1[0], s2[1] - s2[0]);\n}\n\n//点の回転\npoint rotate(const point &p, double rad) {\n\tdouble x = p.real() * cos(rad) - p.imag() * sin(rad);\n\tdouble y = p.imag() * cos(rad) + p.real() * sin(rad);\n\treturn point(x, y);\n}\n\n//並行\nbool isParallel(const point &a, const point &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const segment &a, const segment &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n//直行\nbool isOrthogonal(const point &a,const point &b){\n\treturn abs(angle(a,b) - PI / 2) < EPS;\n}\nbool isOrthogonal(const segment &a,const segment &b){\n\treturn isOrthogonal(a[1]-a[0],b[1]-b[0]);\n}\n//凸包判定\nbool isConvex(vector<point> poly){\n\tint sz = poly.size();\n\tREP(i,sz){\n\t\tint tmp = ccw(poly[i],poly[(i+1)%sz],poly[(i+2)%sz]);\n\t\tif(tmp == -1){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble convex_diameter(const vector<point> &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}\n\nvector<point> convex_cut(const vector<point> P, const segment& l) {\n  vector<point> Q;\n  for (int i = 0; i < P.size(); ++i) {\n    point A = curr(P, i), B = next(P, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(segment(A, B), l));\n  }\n  return Q;\n}\n\nint n;\nvector<point> v;\ndouble mi = INF;\ndouble ma = 0;\ndouble sumS,nowS;\n\ndouble triArea(int a,int b,int c){\n\ta %= n;b %= n;c %= n;\n\tif(a == b || b == c || c == a)return 0;\n\tvector<point> tmp = {v[a],v[b],v[c]};\n\treturn area(tmp);\n}\n\nvoid checkVertex(int p,int q) {\n\tp %= n;q %= n;\n\tdouble remain = (sumS / 2) - nowS;\n\tdouble rate = remain / triArea(p,q,q+1);\n\tpoint tmp = v[q] + rate * (v[(q+1)%n] - v[q]);\n\t//cout << \"# p \" << p << \" q \" << q << \" rate \" << rate << \" dist \" << distancePP(v[p],tmp) << endl;\n\tmi = min(mi, distancePP(v[p],tmp));\n\tma = max(ma, distancePP(v[p],tmp));\n}\n\ndouble seica(int a,int b){\n\ta %= n;b %= n;\n\tvector<point> tmp;\n\tint i = a;\n\twhile(1){\n\t\ttmp.EB(v[i]);\n\t\tif(i == b)break;\n\t\ti = (i + 1) % n;\n\t}\n\tif(tmp.size() < 3)return 0;\n\telse return area(tmp);\n}\n\nvoid checkSegment(int p,int q){\n\tp %= n;q %= n;\n\tnowS -= triArea(p,p+1,q);\n\tsegment a(v[(p+1)%n],v[p]);\n\tsegment b(v[q],v[(q+1)%n]);\n\tpoint crossP = crosspoint(a,b);\n\tif(crossP == point(INF,INF)){\n\t\t//cout << \"heikou\" << endl;\n\t\tdouble sqS = area({v[p],v[(p+1)%n],v[q],v[(q+1)%n]});\n\t\tif(nowS + sqS < sumS / 2 + EPS)return;\n\t\tbool flag = false;\n\t\tif(intersectSP(b,projection(b,a[0])) || intersectSP(b,projection(b,a[1])))flag = true;\n\t\tif(intersectSP(a,projection(a,b[0])) || intersectSP(a,projection(a,b[1])))flag = true;\n\t\tif(!flag)return;\n\t\tmi = min(mi,distanceLP(b,a[0]));\n\t\treturn;\n\t}\n\t//cout << \"cross \" << crossP.X << \" \" << crossP.Y << endl;\n\tdouble tmpS;\n\tif(distancePP(crossP,a[0]) > distancePP(crossP,a[1]) + EPS){\n\t\ttmpS = seica(q+1,p);\n\t\tswap(a[0],a[1]);\n\t\tswap(b[0],b[1]);\n\t}\n\telse{\n\t\ttmpS = seica(p+1,q);\n\t}\n\tdouble theta = angle(a, b);\n\tdouble T = distancePP(crossP,a[0]) * distancePP(crossP, b[0]) * sin(theta) / 2;\n\tdouble leg = (2 * (T - tmpS) + sumS) / sin(theta);\n\t//cout << \"T \" << T << \" leg \" << leg << endl;\n\tbool flag = false;\n\tif(leg > distancePP(a[1],crossP) * distancePP(a[1],crossP) + EPS)flag = true;\n\tif(leg + EPS < distancePP(a[0],crossP) * distancePP(a[0],crossP))flag = true;\n\tif(leg > distancePP(b[1],crossP) * distancePP(b[1],crossP) + EPS)flag = true;\n\tif(leg + EPS <  distancePP(b[0],crossP) * distancePP(b[0],crossP))flag = true;\n\tif(flag)return;\n\t//cout << \"leg \" << leg << \" theta \" << theta << \" \" << Decimal << cos(theta) << endl;\n\tmi = min(mi,2 * sqrt(leg) * sin(theta / 2));\n}\n\nint main() {\n\n\tcin >> n;\n\tREP(i,n){\n\t\tdouble a,b;cin >> a >> b;\n\t\tv.EB(a,b);\n\t}\n\n\tint q = 1;\n\tsumS = area(v);\n\t//cout << \"sumS \" << sumS << endl;\n\tREP(i,n){\n\t\t//cout << \"##################################################\" << endl;\n\t\twhile(nowS + triArea(i,q,q+1) < sumS / 2 + EPS){\n\t\t\tnowS += triArea(i,q,q+1);\n\t\t\tq++;\n\t\t}\n\t\t//cout << \"nowS \" << nowS << \" \" << nowS + triArea(i,q,q+1) << \" \" <<  sumS / 2 + EPS << endl;\n\t\tcheckVertex(i, q);\n\t\tcheckSegment(i, q);\n\t}\n\n\tcout << Decimal << mi << endl;\n\tcout << Decimal << ma << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X,b.X) ? a.X<b.X : a.Y+EPS<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nP unit(const P &p){\n    return p/abs(p);\n}\n\ndouble distanceLP(const L &l, const P &p) {\n    return abs(cross(l[1]-l[0], p-l[0])) /abs(l[1]-l[0]);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\ndouble gettriarea(P a, P b, P c){\n    return (cross(a,b) +cross(b,c) +cross(c,a))*0.5;\n}\nVP convex_cut(const VP& p, const L& l){\n    VP ret;\n    int n = p.size();\n    for(int i=0; i<n; i++){\n        P curr = p[i];\n        P next = p[(i+1)%n];\n        if(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n        if(ccw(l[0], l[1], curr) *ccw(l[0], l[1], next) == -1){\n            ret.push_back(crosspointLL(L(curr, next), l));\n        }\n    }\n    return ret;\n}\n\nvector<L> split_to_lines(VP &p){\n\tint n = p.size();\n    double halfarea = getarea(p)/2;\n    vector<VP> cps(n);\n    for(int i=0; i<n; i++){\n        double currarea = 0;\n        int opp;\n        for(int j=2; j<n; j++){\n        \tdouble tmparea = gettriarea(p[i], p[(i+j-1)%n], p[(i+j)%n]);\n        \tif(currarea +tmparea > halfarea){\n                opp = (i+j-1)%n;\n                break;\n            }\n            currarea += tmparea;\n        }\n        double remarea = halfarea -currarea;\n        double h = distanceLP(L(p[opp], p[(opp+1)%n]), p[i]);\n        cps[opp].push_back(p[opp] +2*remarea/h *unit(p[(opp+1)%n] -p[opp]));\n    }\n    vector<L> ret;\n    for(int i=0; i<n; i++){\n    \tcps[i].push_back(p[i]);\n    \tcps[i].push_back(p[(i+1)%n]);\n    \tsort(cps[i].begin(), cps[i].end());\n    \tcps[i].erase(unique(cps[i].begin(), cps[i].end()), cps[i].end());\n    \tif(cps[i][0] != p[i]){\n    \t\treverse(cps[i].begin(), cps[i].end());\n    \t}\n    \tfor(int j=0; j<(int)cps[i].size()-1; j++){\n    \t\tret.emplace_back(cps[i][j], cps[i][j+1]);\n    \t}\n    }\n    return ret;\n}\n\npair<double, double> minmax_cut(VP &p){\n\tvector<L> lines = split_to_lines(p);\n    int n = lines.size();\n    double halfarea = getarea(p)/2;\n    double ansmin = INF;\n    double ansmax = 0;\n    for(int i=0; i<n/2; i++){\n    \tL s = lines[i];\n    \tL t = lines[(i+n/2)%n];\n        ansmax = max(ansmax, max(abs(t[0]-s[0]), abs(t[1]-s[1])));\n        double remarea = halfarea -getarea(convex_cut(p, L(t[0], s[1])));\n        P lb = s[0];\n        P ub = s[1];\n        for(int r=0; r<100; r++){\n        \tP mid[2];\n        \tmid[0] = (lb+lb+ub) /3.0;\n        \tmid[1] = (lb+ub+ub) /3.0;\n        \tdouble len[2];\n        \tfor(int d=0; d<2; d++){\n        \t\tdouble h = distanceLP(L(t[0], t[1]), mid[d]);\n        \t\tdouble l = 2*(remarea -gettriarea(mid[d], s[1], t[0])) /h;\n        \t\tlen[d] = abs(mid[d] -(t[0] +l*unit(t[1]-t[0])));\n        \t}\n        \tif(len[0] < len[1]){\n                ub = mid[1];\n            }else{\n            \tlb = mid[0];\n            }\n            ansmin = min(ansmin, len[0]);\n        }\n    }\n    return make_pair(ansmin, ansmax);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    VP p(n);\n    for(int i=0; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        p[i] = P(x, y);\n    }\n    auto ans = minmax_cut(p);\n    cout << fixed << setprecision(10);\n    cout << ans.first << endl;\n    cout << ans.second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nfrom decimal import Decimal\nfrom fractions import Fraction\nimport math\nimport os\nimport sys\n\n\ndef main():\n    N = read_int()\n    A = [Vec(*read_ints()) for _ in range(N)]\n    print(*solve(N, A), sep='\\n')\n\n\ndef solve(N, Points):\n    if DEBUG:\n        dprint('polygon({!r}, fill=False)'.format([(v.x, v.y) for v in Points]))\n\n    total_area_2 = 0\n    for i in range(1, N - 1):\n        a = Points[i] - Points[0]\n        b = Points[i + 1] - Points[i]\n        total_area_2 += a.cross(b)\n\n    total_area_4 = 0\n    bi = -1\n    for i in range(1, N - 1):\n        a = Points[i] - Points[0]\n        b = Points[i + 1] - Points[i]\n        area_4 = a.cross(b) * 2\n        if total_area_4 + area_4 <= total_area_2:\n            total_area_4 += area_4\n            continue\n        rest = total_area_2 - total_area_4\n        k = Fraction(total_area_2 - total_area_4, area_4)\n        assert 0 <= k < 1\n\n        bi = i\n        bk = k\n        bv = Points[i] + k * (Points[i + 1] - Points[i])\n        dprint('bi =', bi, 'bk =', bk, 'bv =', bv)\n        break\n\n    assert bi != -1\n\n    ai = 0\n    ak = 0\n\n    maxl = (bv - Points[0]).abs2()\n    minl = maxl\n\n    while bi != 0:\n        assert 0 <= ak < 1\n        assert 0 <= bk < 1\n\n        dprint('***\\nai =', ai, 'ak =', ak, 'bi =', bi, 'bk =', bk)\n        dprint('minl =', minl, 'maxl =', maxl)\n\n        a0 = Points[ai]\n        a1 = Points[(ai + 1) % N]\n        b0 = Points[bi]\n        b1 = Points[(bi + 1) % N]\n\n        a2 = a0 + ak * (a1 - a0)\n        b2 = b0 + bk * (b1 - b0)\n\n        dprint('a0 =', a0, 'a1 =', a1, 'a2 =', a2)\n        dprint('b0 =', b0, 'b1 =', b1, 'b2 =', b2)\n\n        al = 1\n        cross = (b2 - a1).cross(b1 - b0)\n        if cross != 0:\n            bl = Fraction((b0 - a2).cross(b2 - a1), cross)\n        else:\n            bl = 2  # inf\n        assert bk < bl\n        if bl > 1:\n            al = Fraction((b2 - a0).cross(b1 - a2), (a1 - a0).cross(b1 - a2))\n            bl = 1\n\n        assert ak < al <= 1\n        assert bk < bl <= 1\n\n        a3 = a0 + al * (a1 - a0)\n        b3 = b0 + bl * (b1 - b0)\n        dprint('a3 =', a3, 'b3 =', b3)\n\n        b3a3 = b3 - a3\n        l = b3a3.abs2()\n        dprint('l =', l)\n        maxl = max(maxl, l)\n        minl = min(minl, l)\n\n        ####\n        a3a2 = a3 - a2\n        b3b2 = b3 - b2\n        b2a2 = b2 - a2\n\n        A0 = a3a2.cross(b2a2)\n        B0 = b2a2.cross(b3b2)\n        aden = A0.denominator if isinstance(A0, Fraction) else 1\n        bden = B0.denominator if isinstance(B0, Fraction) else 1\n        gden = aden * bden // math.gcd(aden, bden)\n        A0 *= gden\n        B0 *= gden\n        A0 = int(A0)\n        B0 = int(B0)\n        g = math.gcd(A0, B0)\n        A0 //= g\n        B0 //= g\n        dprint('y = ({}) * x / (({}) - ({}) * x)'.format(A0, B0, B0 - A0))\n\n        if A0 == B0:\n            X2 = (a3a2 - b3b2).abs2()\n            X1 = -2 * b2a2.dot(a3a2 - b3b2)\n            C = b2a2.abs2()\n            dprint('L = ({}) * x^2 + ({}) * x + ({})'.format(X2, X1, C))\n            x = Fraction(-X1, 2 * X2)\n            dprint('x =', x)\n            if 0 <= x <= 1:\n                l = x * (X1 + x * X2) + C\n                dprint('l =', l)\n                minl = min(minl, l)\n        else:\n            X2 = a3a2.abs2()\n            X1 = 2 * (-b2a2.dot(a3a2) + Fraction(A0, B0 - A0) * a3a2.dot(b3b2))\n            Y2 = b3b2.abs2()\n            Y1 = 2 * (b2a2.dot(b3b2) - Fraction(B0, B0 - A0) * a3a2.dot(b3b2))\n            L0 = b2a2.abs2()\n            def calc_l(x, y):\n                return x * (X1 + x * X2) + y * (Y1 + y * Y2) + L0\n            A = Fraction(A0, B0 - A0)\n            B = Fraction(B0, B0 - A0)\n            poly = [-2 * A * A * B * B * Y2,\n                    -A * B * (2 * A * Y2 - Y1),\n                    0,\n                    2 * B * X2 + X1,\n                    2 * X2]\n            dprint('poly =', poly)\n            sols = solve_poly(poly, -B, 1 - B)\n            dprint('sols =', sols)\n            for sol_low, sol_high in sols:\n                x0 = sol_low + B\n                x1 = sol_high + B\n                y0 = Fraction(-A * B, x0 - B) - A\n                y1 = Fraction(-A * B, x1 - B) - A\n                l0 = calc_l(x0, y0)\n                l1 = calc_l(x1, y1)\n                dprint('l0 =', l0, 'l1 =', l1)\n                minl = min(minl, l0, l1)\n        ####\n\n        ak = al\n        bk = bl\n        if ak == 1:\n            ai = (ai + 1) % N\n            ak = 0\n        if bk == 1:\n            bi = (bi + 1) % N\n            bk = 0\n\n    dprint('minl', minl)\n    dprint('maxl', maxl)\n    if isinstance(minl, Fraction):\n        minld = Decimal(minl.numerator) / Decimal(minl.denominator)\n    else:\n        minld = Decimal(minl)\n    if isinstance(maxl, Fraction):\n        maxld = Decimal(maxl.numerator) / Decimal(maxl.denominator)\n    else:\n        maxld = Decimal(maxl)\n    return minld.sqrt(), maxld.sqrt()\n\n\ndef sgn(v):\n    if v > 0:\n        return 1\n    if v < 0:\n        return -1\n    return 0\n\n\nEPS = Fraction(1, 10 ** 26)\n\n\ndef solve_poly(poly, minx, maxx):\n    while poly and poly[-1] == 0:\n        del poly[-1]\n    if len(poly) <= 1:\n        return []\n    if len(poly) == 2:\n        b, a = poly\n        x = Fraction(-b, a)\n        if minx <= x <= maxx:\n            return [(x, x)]\n        return []\n\n    df = []\n    for i in range(1, len(poly)):\n        df.append(i * poly[i])\n    segs = [(minx, None)] + solve_poly(df, minx, maxx) + [(None, maxx)]\n    sols = []\n\n    def f(x):\n        v = 0\n        for i, a in enumerate(poly):\n            v += a * (x ** i)\n        return v\n\n    for i in range(len(segs) - 1):\n        lb = segs[i][0]\n        ub = segs[i + 1][1]\n        lbs = sgn(f(lb))\n        ubs = sgn(f(ub))\n        if (lbs >= 0 and ubs >= 0) or (lbs < 0 and ubs < 0):\n            continue\n        while ub - lb > EPS:\n            midf = Fraction(lb + ub, 2)\n            mid = Fraction(Decimal(midf.numerator) / Decimal(midf.denominator))\n            if not (lb < mid < ub):\n                mid = midf\n            v = f(mid)\n            if v >= 0:\n                if lbs >= 0:\n                    lb = mid\n                else:\n                    ub = mid\n            else:\n                if lbs >= 0:\n                    ub = mid\n                else:\n                    lb = mid\n        sols.append((lb, ub))\n    return sols\n\n\n###############################################################################\n\nclass Vec(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        super().__init__()\n\n    def __add__(self, other):\n        return Vec(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Vec(self.x - other.x, self.y - other.y)\n\n    def __mul__(self, scalar):\n        return Vec(self.x * scalar, self.y * scalar)\n\n    def __rmul__(self, scalar):\n        return Vec(self.x * scalar, self.y * scalar)\n\n    def __truediv__(self, scalar):\n        return Vec(self.x / scalar, self.y / scalar)\n\n    def __iadd__(self, other):\n        self.x += other.x\n        self.y += other.y\n        return self\n\n    def __isub__(self, other):\n        self.x -= other.x\n        self.y -= other.y\n        return self\n\n    def __imul__(self, scalar):\n        self.x *= scalar\n        self.y *= scalar\n        return self\n\n    def __idiv__(self, scalar):\n        self.x /= scalar\n        self.y /= scalar\n        return self\n\n    def __neg__(self):\n        return Vec(-self.x, -self.y)\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash(('Vec', self.x, self.y))\n\n    def dot(self, other):\n        return self.x * other.x + self.y * other.y\n\n    def cross(self, other):\n        return self.x * other.y - self.y * other.x\n\n    def abs2(self):\n        return self.x * self.x + self.y * self.y\n\n    def __abs__(self):\n        return math.sqrt(float(self.abs2()))\n\n    def __str__(self):\n        return '({}, {})'.format(self.x, self.y)\n\n    def __repr__(self):\n        return 'Vec({!r}, {!r})'.format(self.x, self.y)\n\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  }
]