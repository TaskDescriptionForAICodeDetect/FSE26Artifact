[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross(Point o, Point a, Point b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n\ndouble area(Point p[], int n) {\n    double res = 0.0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        res += p[i].x * p[j].y - p[j].x * p[i].y;\n    }\n    return fabs(res) / 2.0;\n}\n\nvoid find_intersection(Point a1, Point a2, Point b1, Point b2, double *x, double *y) {\n    double A1 = a2.y - a1.y;\n    double B1 = a1.x - a2.x;\n    double C1 = A1 * a1.x + B1 * a1.y;\n\n    double A2 = b2.y - b1.y;\n    double B2 = b1.x - b2.x;\n    double C2 = A2 * b1.x + B2 * b1.y;\n\n    double det = A1 * B2 - A2 * B1;\n    *x = (B2 * C1 - B1 * C2) / det;\n    *y = (A1 * C2 - A2 * C1) / det;\n}\n\ndouble dist(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\nvoid compute_division(Point p[], int n, double *min_len, double *max_len) {\n    double total_area = area(p, n);\n    double half_area = total_area / 2.0;\n    *min_len = DBL_MAX;\n    *max_len = -DBL_MAX;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            Point a = p[i];\n            Point b = p[j];\n            double current_area = 0.0;\n            int k = i;\n            Point prev = p[k];\n            k = (k + 1) % n;\n            while (k != j) {\n                current_area += cross(a, prev, p[k]);\n                prev = p[k];\n                k = (k + 1) % n;\n            }\n            current_area += cross(a, prev, b);\n            current_area = fabs(current_area) / 2.0;\n\n            if (fabs(current_area - half_area) < 1e-9) {\n                double d = dist(a, b);\n                if (d < *min_len) *min_len = d;\n                if (d > *max_len) *max_len = d;\n            } else {\n                if (current_area < half_area) {\n                    int next_j = (j + 1) % n;\n                    Point c = p[next_j];\n                    double area_triangle = fabs(cross(a, b, c)) / 2.0;\n                    if (current_area + area_triangle >= half_area) {\n                        double ratio = (half_area - current_area) / area_triangle;\n                        double x, y;\n                        x = b.x + ratio * (c.x - b.x);\n                        y = b.y + ratio * (c.y - b.y);\n                        Point new_point = {x, y};\n                        double d = dist(a, new_point);\n                        if (d < *min_len) *min_len = d;\n                        if (d > *max_len) *max_len = d;\n                    }\n                } else {\n                    int prev_i = (i - 1 + n) % n;\n                    Point c = p[prev_i];\n                    double area_triangle = fabs(cross(a, b, c)) / 2.0;\n                    if (current_area - area_triangle <= half_area) {\n                        double ratio = (current_area - half_area) / area_triangle;\n                        double x, y;\n                        x = a.x + ratio * (c.x - a.x);\n                        y = a.y + ratio * (c.y - a.y);\n                        Point new_point = {x, y};\n                        double d = dist(new_point, b);\n                        if (d < *min_len) *min_len = d;\n                        if (d > *max_len) *max_len = d;\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point p[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n    }\n\n    double min_len, max_len;\n    compute_division(p, n, &min_len, &max_len);\n\n    printf(\"%.10lf %.10lf\\n\", min_len, max_len);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble cross(const Point &O, const Point &A, const Point &B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\ndouble area(const vector<Point> &poly) {\n    double res = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; ++i) {\n        Point p = i ? poly[i-1] : poly.back();\n        Point q = poly[i];\n        res += (p.x + q.x) * (p.y - q.y);\n    }\n    return fabs(res) / 2;\n}\n\nvector<Point> convex_polygon_cut(const vector<Point> &poly, const Point &A, const Point &B) {\n    vector<Point> res;\n    int n = poly.size();\n    for (int i = 0; i < n; ++i) {\n        Point p = poly[i], q = poly[(i+1)%n];\n        double cp1 = cross(A, B, p);\n        double cp2 = cross(A, B, q);\n        if (cp1 >= 0) res.push_back(p);\n        if (cp1 * cp2 < 0) {\n            Point r;\n            double den = (q.x - p.x) * (B.y - A.y) - (q.y - p.y) * (B.x - A.x);\n            double t = ((q.x - p.x) * (A.y - p.y) - (q.y - p.y) * (A.x - p.x)) / den;\n            r.x = A.x + t * (B.x - A.x);\n            r.y = A.y + t * (B.y - A.y);\n            res.push_back(r);\n        }\n    }\n    return res;\n}\n\ndouble segment_length(const Point &A, const Point &B) {\n    return hypot(A.x - B.x, A.y - B.y);\n}\n\nvoid find_min_max_divisions(const vector<Point> &poly, double &min_len, double &max_len) {\n    min_len = 1e20;\n    max_len = 0;\n    double total_area = area(poly);\n    int n = poly.size();\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            Point A = poly[i], B = poly[j];\n            vector<Point> left = convex_polygon_cut(poly, A, B);\n            double left_area = area(left);\n            \n            if (fabs(left_area - total_area / 2) > 1e-8) continue;\n            \n            double len = segment_length(A, B);\n            if (len < min_len) min_len = len;\n            if (len > max_len) max_len = len;\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> poly(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> poly[i].x >> poly[i].y;\n    }\n    \n    double min_len, max_len;\n    find_min_max_divisions(poly, min_len, max_len);\n    \n    cout << fixed << setprecision(10) << max_len << \" \" << min_len << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:59:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ChocolateCutter {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static double cross(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    static double area(List<Point> polygon) {\n        double area = 0.0;\n        int n = polygon.size();\n        for (int i = 0; i < n; i++) {\n            Point p1 = polygon.get(i);\n            Point p2 = polygon.get((i + 1) % n);\n            area += p1.x * p2.y - p2.x * p1.y;\n        }\n        return Math.abs(area) / 2.0;\n    }\n\n    static List<Point> intersect(Point a1, Point a2, Point b1, Point b2) {\n        List<Point> result = new ArrayList<>();\n        double a = a2.x - a1.x;\n        double b = b1.x - b2.x;\n        double c = a2.y - a1.y;\n        double d = b1.y - b2.y;\n        double e = b1.x - a1.x;\n        double f = b1.y - a1.y;\n        double det = a * d - b * c;\n        if (Math.abs(det) < 1e-10) {\n            return result;\n        }\n        double t = (d * e - b * f) / det;\n        double s = (-c * e + a * f) / det;\n        if (t >= 0 && t <= 1 && s >= 0 && s <= 1) {\n            double x = a1.x + t * (a2.x - a1.x);\n            double y = a1.y + t * (a2.y - a1.y);\n            result.add(new Point(x, y));\n        }\n        return result;\n    }\n\n    static double distance(Point a, Point b) {\n        double dx = a.x - b.x;\n        double dy = a.y - b.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    static double[] findMinMaxCutLength(List<Point> polygon) {\n        double totalArea = area(polygon);\n        double halfArea = totalArea / 2.0;\n        int n = polygon.size();\n        double minLength = Double.MAX_VALUE;\n        double maxLength = 0.0;\n\n        for (int i = 0; i < n; i++) {\n            Point a = polygon.get(i);\n            Point b = polygon.get((i + 1) % n);\n            double low = 0.0;\n            double high = 1.0;\n            for (int iter = 0; iter < 100; iter++) {\n                double mid1 = (2 * low + high) / 3;\n                double mid2 = (low + 2 * high) / 3;\n                Point p1 = new Point(a.x + mid1 * (b.x - a.x), a.y + mid1 * (b.y - a.y));\n                Point p2 = new Point(a.x + mid2 * (b.x - a.x), a.y + mid2 * (b.y - a.y));\n                double area1 = computeArea(polygon, p1, halfArea);\n                double area2 = computeArea(polygon, p2, halfArea);\n                if (Math.abs(area1 - halfArea) < Math.abs(area2 - halfArea)) {\n                    high = mid2;\n                } else {\n                    low = mid1;\n                }\n            }\n            Point p = new Point(a.x + low * (b.x - a.x), a.y + low * (b.y - a.y));\n            Point q = findOppositePoint(polygon, p, halfArea);\n            if (q != null) {\n                double length = distance(p, q);\n                minLength = Math.min(minLength, length);\n                maxLength = Math.max(maxLength, length);\n            }\n        }\n        return new double[]{minLength, maxLength};\n    }\n\n    static double computeArea(List<Point> polygon, Point p, double targetArea) {\n        int n = polygon.size();\n        double totalArea = 0.0;\n        for (int i = 0; i < n; i++) {\n            Point a = polygon.get(i);\n            Point b = polygon.get((i + 1) % n);\n            totalArea += Math.abs(cross(p, a, b));\n        }\n        return totalArea / 2.0;\n    }\n\n    static Point findOppositePoint(List<Point> polygon, Point p, double targetArea) {\n        int n = polygon.size();\n        for (int i = 0; i < n; i++) {\n            Point a = polygon.get(i);\n            Point b = polygon.get((i + 1) % n);\n            List<Point> intersections = intersect(p, new Point(p.x + (b.y - a.y), p.y - (b.x - a.x)), a, b);\n            if (!intersections.isEmpty()) {\n                Point q = intersections.get(0);\n                double area = computeArea(polygon, q, targetArea);\n                if (Math.abs(area - targetArea) < 1e-6) {\n                    return q;\n                }\n            }\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n        List<Point> polygon = new ArrayList<>();\n        polygon.add(new Point(0, 0));\n        polygon.add(new Point(2, 0));\n        polygon.add(new Point(2, 2));\n        polygon.add(new Point(0, 2));\n        double[] result = findMinMaxCutLength(polygon);\n        System.out.println(\"Minimum length: \" + result[0]);\n        System.out.println(\"Maximum length: \" + result[1]);\n    }\n}",
    "timestamp": "2025-08-05 21:00:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\n\npublic class ChocolateCutting {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static double polygonArea(Point[] polygon) {\n        int n = polygon.length;\n        double area = 0.0;\n        for (int i = 0; i < n; i++) {\n            int j = (i + 1) % n;\n            area += polygon[i].x * polygon[j].y - polygon[j].x * polygon[i].y;\n        }\n        return Math.abs(area) / 2.0;\n    }\n\n    static double distanceBetweenPoints(Point p1, Point p2) {\n        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n    }\n\n    static boolean isPointInPolygon(Point point, Point[] polygon) {\n        int n = polygon.length;\n        boolean inside = false;\n        double eps = 1e-9;\n\n        for (int i = 0; i < n; i++) {\n            int j = (i + 1) % n;\n            if (Math.abs(crossProduct(polygon[i], polygon[j], point)) < eps) {\n                Line2D.Double line = new Line2D.Double(polygon[i].x, polygon[i].y, polygon[j].x, polygon[j].y);\n                if (line.ptLineDist(point.x, point.y) < eps) return true;\n            }\n\n            if (((polygon[i].y > point.y) != (polygon[j].y > point.y)) &&\n                (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / \n                (polygon[j].y - polygon[i].y) + polygon[i].x)) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    }\n\n    static double crossProduct(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    static double[] findMinMaxCutLengths(Point[] polygon) {\n        double totalArea = polygonArea(polygon);\n        double minLength = Double.MAX_VALUE;\n        double maxLength = 0;\n        int n = polygon.length;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                Point p1 = polygon[i];\n                Point p2 = polygon[j];\n                Point midpoint = new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);\n\n                double[] cutAreas = calculateCutAreas(polygon, p1, p2);\n                double area1 = cutAreas[0];\n                double area2 = cutAreas[1];\n\n                if (Math.abs(area1 - area2) < 1e-9) {\n                    double length = distanceBetweenPoints(p1, p2);\n                    minLength = Math.min(minLength, length);\n                    maxLength = Math.max(maxLength, length);\n                }\n            }\n        }\n\n        return new double[]{minLength, maxLength};\n    }\n\n    static double[] calculateCutAreas(Point[] polygon, Point start, Point end) {\n        int n = polygon.length;\n        Point[] poly1 = new Point[2 * n];\n        Point[] poly2 = new Point[2 * n];\n        int idx1 = 0, idx2 = 0;\n\n        poly1[idx1++] = start;\n        poly1[idx1++] = end;\n        poly2[idx2++] = start;\n        poly2[idx2++] = end;\n\n        for (int i = 0; i < n; i++) {\n            Point current = polygon[i];\n            if (!isPointOnLine(current, start, end)) {\n                if (isPointLeftOfLine(current, start, end)) {\n                    poly1[idx1++] = current;\n                } else {\n                    poly2[idx2++] = current;\n                }\n            }\n        }\n\n        Point[] trimmedPoly1 = Arrays.copyOf(poly1, idx1);\n        Point[] trimmedPoly2 = Arrays.copyOf(poly2, idx2);\n\n        return new double[]{polygonArea(trimmedPoly1), polygonArea(trimmedPoly2)};\n    }\n\n    static boolean isPointOnLine(Point p, Point start, Point end) {\n        double eps = 1e-9;\n        return Math.abs(crossProduct(start, end, p)) < eps;\n    }\n\n    static boolean isPointLeftOfLine(Point p, Point start, Point end) {\n        return crossProduct(start, end, p) > 0;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        Point[] polygon = {\n            new Point(0, 0),\n            new Point(0, 4),\n            new Point(4, 4),\n            new Point(4, 0)\n        };\n\n        double[] result = findMinMaxCutLengths(polygon);\n        System.out.println(\"Minimum cut length: \" + result[0]);\n        System.out.println(\"Maximum cut length: \" + result[1]);\n    }\n}",
    "timestamp": "2025-08-05 21:00:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble polygon_area(Point* polygon, int n) {\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += polygon[i].x * polygon[j].y - polygon[j].x * polygon[i].y;\n    }\n    return fabs(area) / 2.0;\n}\n\nint point_inside_polygon(Point* polygon, int n, Point p) {\n    int inside = 0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        if (((polygon[i].y > p.y) != (polygon[j].y > p.y)) &&\n            (p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / \n             (polygon[j].y - polygon[i].y) + polygon[i].x)) {\n            inside = !inside;\n        }\n    }\n    return inside;\n}\n\nPoint line_intersection(Point a, Point b, Point c, Point d) {\n    Point result;\n    double denom = ((b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x));\n    double t = ((c.x - a.x) * (d.y - c.y) - (c.y - a.y) * (d.x - c.x)) / denom;\n    result.x = a.x + t * (b.x - a.x);\n    result.y = a.y + t * (b.y - a.y);\n    return result;\n}\n\nvoid solve_equal_area_cut(Point* polygon, int n) {\n    double total_area = polygon_area(polygon, n);\n    double min_length = DBL_MAX;\n    double max_length = 0.0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            Point a = polygon[i];\n            Point b = polygon[j];\n\n            Point mid = {(a.x + b.x) / 2.0, (a.y + b.y) / 2.0};\n            double dist = sqrt((b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y));\n\n            for (double offset = -total_area; offset <= total_area; offset += total_area / 100.0) {\n                Point perp = {\n                    mid.x + offset * (a.y - b.y) / dist,\n                    mid.y + offset * (b.x - a.x) / dist\n                };\n\n                int count_left = 0, count_right = 0;\n                for (int k = 0; k < n; k++) {\n                    if (cross_product(a, b, polygon[k]) < 0) {\n                        count_left++;\n                    } else {\n                        count_right++;\n                    }\n                }\n\n                if (count_left == count_right) {\n                    min_length = fmin(min_length, dist);\n                    max_length = fmax(max_length, dist);\n                }\n            }\n        }\n    }\n\n    printf(\"%.6f %.6f\\n\", min_length, max_length);\n}\n\nint main() {\n    int n;\n    Point polygon[MAX_VERTICES];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &polygon[i].x, &polygon[i].y);\n    }\n\n    solve_equal_area_cut(polygon, n);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:00:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble cross(const Point& a, const Point& b, const Point& c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble polygonArea(const vector<Point>& polygon) {\n    int n = polygon.size();\n    double area = 0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += polygon[i].x * polygon[j].y - polygon[j].x * polygon[i].y;\n    }\n    return abs(area) / 2.0;\n}\n\nbool isPointInside(const vector<Point>& polygon, const Point& p) {\n    int n = polygon.size();\n    bool inside = false;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        if (((polygon[i].y > p.y) != (polygon[j].y > p.y)) &&\n            (p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / \n             (polygon[j].y - polygon[i].y) + polygon[i].x)) {\n            inside = !inside;\n        }\n    }\n    return inside;\n}\n\nPoint lineIntersection(const Point& a, const Point& b, const Point& c, const Point& d) {\n    double det = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);\n    double t = ((c.x - a.x) * (d.y - c.y) - (c.y - a.y) * (d.x - c.x)) / det;\n    return Point(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));\n}\n\nvector<Point> cutPolygon(const vector<Point>& polygon, const Point& a, const Point& b) {\n    vector<Point> result;\n    int n = polygon.size();\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        bool iInside = cross(a, b, polygon[i]) >= 0;\n        bool jInside = cross(a, b, polygon[j]) >= 0;\n        \n        if (iInside) result.push_back(polygon[i]);\n        \n        if (iInside != jInside) {\n            Point intersect = lineIntersection(a, b, polygon[i], polygon[j]);\n            result.push_back(intersect);\n        }\n    }\n    return result;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    \n    vector<Point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n    \n    double totalArea = polygonArea(polygon);\n    double minLen = numeric_limits<double>::max();\n    double maxLen = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            Point a = polygon[i], b = polygon[j];\n            \n            for (int k = 0; k < n; k++) {\n                int l = (k + 1) % n;\n                Point c = polygon[k], d = polygon[l];\n                Point cut1 = lineIntersection(a, b, c, d);\n                \n                if (!isPointInside(polygon, cut1)) continue;\n                \n                vector<Point> left = cutPolygon(polygon, a, b);\n                vector<Point> right = cutPolygon(polygon, b, a);\n                \n                double leftArea = polygonArea(left);\n                double rightArea = polygonArea(right);\n                \n                if (abs(leftArea - rightArea) > 1e-9) continue;\n                \n                double len = sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n                minLen = min(minLen, len);\n                maxLen = max(maxLen, len);\n            }\n        }\n    }\n    \n    cout << fixed << setprecision(10) << minLen << \" \" << maxLen << endl;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:00:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from shapely.geometry import Polygon, LineString\nfrom shapely.ops import unary_union\n\ndef find_dividing_line(polygon_points):\n    polygon = Polygon(polygon_points)\n    \n    if not polygon.is_valid or not polygon.is_convex:\n        raise ValueError(\"The input must be a convex polygon.\")\n    \n    total_area = polygon.area\n    half_area = total_area / 2\n    \n    min_length = float('inf')\n    max_length = 0\n\n    for i in range(len(polygon_points)):\n        for j in range(i + 1, len(polygon_points)):\n            line = LineString([polygon_points[i], polygon_points[j]])\n            \n            cut_polygon1, cut_polygon2 = polygon.cut(line)\n            \n            if abs(cut_polygon1.area - half_area) < 1e-9 or abs(cut_polygon2.area - half_area) < 1e-9:\n                length = line.length\n                min_length = min(min_length, length)\n                max_length = max(max_length, length)\n\n    return min_length, max_length\n\n# Example usage:\npolygon_points = [(0, 0), (4, 0), (4, 3), (0, 4)]\nmin_length, max_length = find_dividing_line(polygon_points)\nprint(f\"Minimum length: {min_length}, Maximum length: {max_length}\")",
    "timestamp": "2025-08-13 04:20:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ChocolateDivider {\n\n    static class Point {\n        double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distance(Point other) {\n            return Point2D.distance(x, y, other.x, other.y);\n        }\n    }\n\n    private static double cross(Point a, Point b, Point c) {\n        double y1 = b.y - a.y;\n        double y2 = c.y - a.y;\n        double x1 = b.x - a.x;\n        double x2 = c.x - a.x;\n        return x1 * y2 - x2 * y1;\n    }\n\n    private static double area(List<Point> points) {\n        int n = points.size();\n        double area = 0;\n        for (int i = 0; i < n; i++) {\n            area += cross(points.get(0), points.get(i), points.get((i + 1) % n));\n        }\n        return Math.abs(area) / 2;\n    }\n\n    private static Point interpolate(Point a, Point b, double ratio) {\n        return new Point(a.x + ratio * (b.x - a.x), a.y + ratio * (b.y - a.y));\n    }\n\n    private static double calculateCrossing(Point a, Point b, List<Point> points, double halfArea, int totalPoints) {\n        int n = totalPoints;\n        double currentArea = 0;\n        Point ref = points.get(0);\n        for (int i = 0; i < n; i++) {\n            currentArea += cross(ref, points.get(i), points.get((i + 1) % n));\n            if (currentArea / 2 >= halfArea) {\n                double targetArea = halfArea - (currentArea - cross(ref, points.get(i), points.get((i + 1) % n))) / 2;\n                double startCross = cross(ref, a, points.get(i + 1));\n                double endCross = cross(ref, b, points.get(i + 1));\n                double totalCross = cross(a, b, points.get(i + 1));\n                double ratio = targetArea / totalCross;\n                return interpolate(a, b, ratio).distance(points.get(i + 1));\n            }\n        }\n        return 0;\n    }\n\n    public static double[] findMaxMinLengths(List<Point> points) {\n        double totalArea = area(points);\n        double halfArea = totalArea / 2;\n        double minLength = Double.POSITIVE_INFINITY;\n        double maxLength = Double.NEGATIVE_INFINITY;\n        int n = points.size();\n\n        for (int i = 0; i < n; i++) {\n            Point a = points.get(i);\n            for (int j = i + 1; j < n; j++) {\n                Point b = points.get(j);\n                double lineLength = a.distance(b);\n                double crossA = calculateCrossing(a, b, points, halfArea, n);\n                double crossB = calculateCrossing(b, a, points, halfArea, n);\n\n                lineLength = Math.min(crossA, crossB);\n                minLength = Math.min(minLength, lineLength);\n                maxLength = Math.max(maxLength, lineLength);\n            }\n        }\n\n        return new double[] { minLength, maxLength };\n    }\n\n    public static void main(String[] args) {\n        List<Point> polygon = new ArrayList<>();\n        polygon.add(new Point(0, 0));\n        polygon.add(new Point(4, 0));\n        polygon.add(new Point(4, 3));\n        polygon.add(new Point(0, 3));\n\n        double[] lengths = findMaxMinLengths(polygon);\n        System.out.println(\"Minimum Length: \" + lengths[0]);\n        System.out.println(\"Maximum Length: \" + lengths[1]);\n    }\n}",
    "timestamp": "2025-08-13 04:20:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point* points;\n    int num_points;\n} Polygon;\n\ndouble polygon_area(Polygon* polygon) {\n    double area = 0;\n    int n = polygon->num_points;\n    for (int i = 0; i < n; ++i) {\n        Point p1 = polygon->points[i];\n        Point p2 = polygon->points[(i + 1) % n];\n        area += (p1.x * p2.y - p2.x * p1.y);\n    }\n    return fabs(area) / 2.0;\n}\n\ndouble distance(Point p1, Point p2) {\n    return hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nvoid find_line(Point p1, Point p2, double* a, double* b, double* c) {\n    *a = p2.y - p1.y;\n    *b = p1.x - p2.x;\n    *c = p1.x * p2.y - p2.x * p1.y;\n}\n\ndouble line_length(Point p1, Point p2, double a, double b, double c) {\n    double base = distance(p1, p2);\n    double height = fabs(a * p1.x + b * p1.y + c) / sqrt(a * a + b * b);\n    return height / base;\n}\n\ndouble find_min_max_length(Polygon* polygon, int is_max) {\n    double target_area = polygon_area(polygon) / 2.0;\n    double result_length = is_max ? 0 : HUGE_VAL;\n    int n = polygon->num_points;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double a, b, c;\n            find_line(polygon->points[i], polygon->points[j], &a, &b, &c);\n            double length = line_length(polygon->points[i], polygon->points[j], a, b, c);\n            if ((is_max && length > result_length) || (!is_max && length < result_length)) {\n                result_length = length;\n            }\n        }\n    }\n    return result_length;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Polygon polygon;\n    polygon.num_points = n;\n    polygon.points = (Point*)malloc(n * sizeof(Point));\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%lf %lf\", &polygon.points[i].x, &polygon.points[i].y);\n    }\n\n    double max_length = find_min_max_length(&polygon, 1);\n    double min_length = find_min_max_length(&polygon, 0);\n\n    printf(\"Max Length: %.9lf\\n\", max_length);\n    printf(\"Min Length: %.9lf\\n\", min_length);\n\n    free(polygon.points);\n    return 0;\n}",
    "timestamp": "2025-08-13 04:20:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nimport itertools\n\ndef polygon_area(polygon):\n    n = len(polygon)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += polygon[i][0] * polygon[j][1]\n        area -= polygon[j][0] * polygon[i][1]\n    return abs(area) / 2.0\n\ndef line_polygon_intersection(polygon, point1, point2):\n    intersections = []\n    n = len(polygon)\n    for i in range(n):\n        j = (i + 1) % n\n        intersection = line_segment_intersection(\n            polygon[i], polygon[j], point1, point2\n        )\n        if intersection:\n            intersections.append(intersection)\n    return intersections\n\ndef line_segment_intersection(p1, p2, p3, p4):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n\n    denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n    if denom == 0:\n        return None\n\n    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom\n    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom\n\n    if 0 <= ua <= 1 and 0 <= ub <= 1:\n        x = x1 + ua * (x2 - x1)\n        y = y1 + ua * (y2 - y1)\n        return (x, y)\n    return None\n\ndef compute_cut_lengths(polygon):\n    total_area = polygon_area(polygon)\n    min_length = float('inf')\n    max_length = 0\n\n    n = len(polygon)\n    for i in range(n):\n        for j in range(i + 1, n):\n            point1 = polygon[i]\n            point2 = polygon[j]\n\n            intersections = line_polygon_intersection(polygon, point1, point2)\n            if len(intersections) == 2:\n                cut_length = math.sqrt(\n                    (intersections[0][0] - intersections[1][0])**2 +\n                    (intersections[0][1] - intersections[1][1])**2\n                )\n\n                # Calculate areas on both sides of the cut\n                new_polygon1 = []\n                new_polygon2 = []\n                for point in polygon:\n                    if point_on_side(point, point1, point2):\n                        new_polygon1.append(point)\n                    else:\n                        new_polygon2.append(point)\n                \n                for intersection in intersections:\n                    new_polygon1.append(intersection)\n                    new_polygon2.append(intersection)\n\n                area1 = polygon_area(new_polygon1)\n                area2 = polygon_area(new_polygon2)\n\n                if abs(area1 - area2) < 1e-9:\n                    min_length = min(min_length, cut_length)\n                    max_length = max(max_length, cut_length)\n\n    return min_length, max_length\n\ndef point_on_side(point, point1, point2):\n    x, y = point\n    x1, y1 = point1\n    x2, y2 = point2\n\n    # Cross product to determine which side of the line the point is on\n    return (x2 - x1) * (y - y1) - (y2 - y1) * (x - x1) >= 0\n\n# Example usage\npolygon = [(0, 0), (4, 0), (4, 4), (0, 4)]\nmin_len, max_len = compute_cut_lengths(polygon)\nprint(f\"Minimum length: {min_len}\")\nprint(f\"Maximum length: {max_len}\")",
    "timestamp": "2025-08-13 04:21:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef point_on_segment(a, b, c):\n    # Check if point c lies on segment ab\n    cross = (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0])\n    if abs(cross) > 1e-12:\n        return False\n    dot = (c[0] - a[0]) * (b[0] - a[0]) + (c[1] - a[1]) * (b[1] - a[1])\n    if dot < 0:\n        return False\n    sq_len = (b[0] - a[0])**2 + (b[1] - a[1])**2\n    if (c[0] - a[0])**2 + (c[1] - a[1])**2 > sq_len:\n        return False\n    return True\n\ndef line_intersection(a1, a2, b1, b2):\n    # Find intersection point of lines a1a2 and b1b2\n    A1 = a2[1] - a1[1]\n    B1 = a1[0] - a2[0]\n    C1 = A1 * a1[0] + B1 * a1[1]\n\n    A2 = b2[1] - b1[1]\n    B2 = b1[0] - b2[0]\n    C2 = A2 * b1[0] + B2 * b1[1]\n\n    det = A1 * B2 - A2 * B1\n    if det == 0:\n        return None  # parallel or coincident\n    x = (B2 * C1 - B1 * C2) / det\n    y = (A1 * C2 - A2 * C1) / det\n\n    # Check if intersection is within both segments\n    if (min(a1[0], a2[0]) <= x <= max(a1[0], a2[0]) and\n        min(a1[1], a2[1]) <= y <= max(a1[1], a2[1]) and\n        min(b1[0], b2[0]) <= x <= max(b1[0], b2[0]) and\n        min(b1[1], b2[1]) <= y <= max(b1[1], b2[1])):\n        return (x, y)\n    return None\n\ndef polygon_area(points):\n    area = 0.0\n    n = len(points)\n    for i in range(n):\n        x_i, y_i = points[i]\n        x_j, y_j = points[(i + 1) % n]\n        area += (x_i * y_j) - (x_j * y_i)\n    return abs(area) / 2.0\n\ndef find_division_segments(polygon):\n    n = len(polygon)\n    total_area = polygon_area(polygon)\n    target_area = total_area / 2.0\n    min_len = float('inf')\n    max_len = 0.0\n\n    for i in range(n):\n        a = polygon[i]\n        b = polygon[(i + 1) % n]\n        current_area = 0.0\n        j = (i + 1) % n\n        while True:\n            c = polygon[j]\n            d = polygon[(j + 1) % n]\n            # Compute area of polygon a, b, c, d, etc.\n            # Using the shoelace formula for the partial polygon\n            partial_polygon = [a, b]\n            k = j\n            while k != i:\n                partial_polygon.append(polygon[k])\n                k = (k + 1) % n\n            area = polygon_area(partial_polygon)\n            if area >= target_area:\n                break\n            j = (j + 1) % n\n\n        c = polygon[j]\n        d = polygon[(j + 1) % n]\n        # Now find the exact point on cd that divides the area\n        # Compute area up to c\n        partial_polygon = [a, b]\n        k = (i + 1) % n\n        while k != j:\n            partial_polygon.append(polygon[k])\n            k = (k + 1) % n\n        partial_polygon.append(c)\n        area_before = polygon_area(partial_polygon)\n        remaining_area = target_area - area_before\n\n        # Compute area of triangle b, c, d\n        triangle_area = 0.5 * abs(\n            (b[0]*(c[1] - d[1]) + c[0]*(d[1] - b[1]) + d[0]*(b[1] - c[1]))\n        )\n        t = remaining_area / triangle_area\n        if t < 0 or t > 1:\n            continue  # shouldn't happen for convex polygons\n        intersection = (\n            c[0] + t * (d[0] - c[0]),\n            c[1] + t * (d[1] - c[1])\n        )\n\n        # Check if the intersection point is on the segment cd\n        if not point_on_segment(c, d, intersection):\n            continue\n\n        # Now compute the length of the segment from a to intersection\n        dx = intersection[0] - a[0]\n        dy = intersection[1] - a[1]\n        length = math.sqrt(dx*dx + dy*dy)\n\n        if length < min_len:\n            min_len = length\n        if length > max_len:\n            max_len = length\n\n    return (min_len, max_len)\n\n# Example usage:\n# polygon = [(0, 0), (2, 0), (2, 2), (0, 2)]  # Square\n# min_len, max_len = find_division_segments(polygon)\n# print(min_len, max_len)",
    "timestamp": "2025-08-13 04:21:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <limits>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS = 1e-9;\n\n// Helper function to calculate the cross product of vectors OA and OB\ndouble cross(const Point &O, const Point &A, const Point &B) {\n    return (A.real() - O.real()) * (B.imag() - O.imag()) - (A.imag() - O.imag()) * (B.real() - O.real());\n}\n\n// Helper function to calculate the area of a polygon using the shoelace formula\ndouble polygon_area(const vector<Point> &points) {\n    double area = 0.0;\n    int n = points.size();\n    for (int i = 0; i < n; ++i) {\n        area += cross(Point(0, 0), points[i], points[(i + 1) % n]);\n    }\n    return fabs(area) / 2.0;\n}\n\n// Function to find the centroid of the polygon\nPoint centroid(const vector<Point> &points) {\n    double cx = 0, cy = 0;\n    double signedArea = 0.0;\n    int n = points.size();\n    for (int i = 0; i < n; ++i) {\n        double a = cross(Point(0, 0), points[i], points[(i + 1) % n]);\n        signedArea += a;\n        cx += (points[i].real() + points[(i + 1) % n].real()) * a;\n        cy += (points[i].imag() + points[(i + 1) % n].imag()) * a;\n    }\n    signedArea *= 0.5;\n    cx /= (6.0 * signedArea);\n    cy /= (6.0 * signedArea);\n    return Point(cx, cy);\n}\n\n// Function to compute the length of segment AB\ndouble segment_length(const Point &A, const Point &B) {\n    return abs(A - B);\n}\n\n// Function to determine the maximum and minimum length of the line segment dividing the polygon into two equal areas\npair<double, double> find_cut_lengths(const vector<Point> &points) {\n    int n = points.size();\n    double total_area = polygon_area(points);\n    double half_area = total_area / 2.0;\n    Point centro = centroid(points);\n    \n    double min_length = numeric_limits<double>::max();\n    double max_length = 0.0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            Point A = points[i];\n            Point B = points[j];\n            vector<Point> left, right;\n\n            for (int k = 0; k < n; ++k) {\n                Point C = points[k];\n                double side = cross(A, B, C);\n                if (side > EPS) {\n                    left.push_back(C);\n                } else if (side < -EPS) {\n                    right.push_back(C);\n                } else {  // the point is on the line AB\n                    left.push_back(C);\n                    right.push_back(C);\n                }\n            }\n\n            left.push_back(A);\n            left.push_back(B);\n            right.push_back(A);\n            right.push_back(B);\n\n            double area_left = polygon_area(left);\n            double area_right = polygon_area(right);\n\n            if (fabs(area_left - half_area) < EPS || fabs(area_right - half_area) < EPS) {\n                double segmentLen = segment_length(A, B);\n                min_length = min(min_length, segmentLen);\n                max_length = max(max_length, segmentLen);\n            }\n        }\n    }\n\n    return make_pair(min_length, max_length);\n}\n\nint main() {\n    int n;\n    cout << \"Enter the number of vertices: \";\n    cin >> n;\n    vector<Point> polygon(n);\n    cout << \"Enter the coordinates of the vertices in clockwise or counterclockwise order:\\n\";\n    for (int i = 0; i < n; ++i) {\n        double x, y;\n        cin >> x >> y;\n        polygon[i] = Point(x, y);\n    }\n\n    pair<double, double> result = find_cut_lengths(polygon);\n    cout << fixed << setprecision(6);\n    cout << \"Minimum length: \" << result.first << \"\\n\";\n    cout << \"Maximum length: \" << result.second << \"\\n\";\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:18:43"
  }
]