[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100100\nusing namespace std;\nint msk[N];\nvector<int> g[N];\nvoid DFS(int u,int p){\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v!=p) DFS(v,u);\n\t}\n\tint d=1<<20;\n\twhile(d){\n\t\tint c=0;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(v!=p&&(msk[v]&d)) c++;\n\t\t}\n\t\tif(c>1){\n\t\t\tmsk[u]+=d<<1;\n\t\t\tbreak;\n\t\t}\n\t\telse if(c==1) msk[u]|=d;\n\t\td>>=1;\n\t}\n\tif(d==0) msk[u]++;\n}\nint main(){\n\tint n,a,b;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tDFS(1,0);\n\tint ans=0;\n\twhile((1<<ans+1)<=msk[1]) ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 10000;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tsrand(clock());\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t}\n\t\n\tcout << ANS << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define iter(v, i) for (__typeof__((v).begin()) i = (v).begin(); i != (v).end(); i++)\n#define fast_io_without_cstdio ios_base::sync_with_stdio(false), cin.tie(NULL)\n#define all(v) (v).begin(), (v).end()\n\n#ifdef __linux__\n#define gc getchar_unlocked\n#define pc putchar_unlocked\n#else\n#define gc getchar\n#define pc putchar\n#endif\n\n#if __cplusplus <= 199711L\ntemplate<class BidirIt>\nBidirIt prev(BidirIt it, typename iterator_traits<BidirIt>::difference_type n = 1) {\n    advance(it, -n);\n    return it;\n}\n\ntemplate<class ForwardIt>\nForwardIt next(ForwardIt it, typename iterator_traits<ForwardIt>::difference_type n = 1) {\n    advance(it, n);\n    return it;\n}\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\n\nconst double EPS = 1e-9;\nconst double PI = 3.141592653589793238462;\n\ntemplate<typename T>\ninline T sq(T a) { return a * a; }\n\nconst int MAXN = 1e5 + 5;\nconst int LOGN = 20;\n\nint ans[MAXN];\nvi gr[MAXN];\n\nvoid dfs(int u, int par) {\n    int cnt[LOGN] = {0};\n    for (auto v : gr[u])\n        if (v != par) {\n            dfs(v, u);\n            for (int i = 0; i < LOGN; i++)\n                cnt[i] += ((ans[v] >> i) & 1);\n        }\n    int pos = -1;\n    for (int i = LOGN-1; i >= 0; i--)\n        if (cnt[i] >= 2) {\n            // there is a path starting in one child and ending in another\n            // => there cannot be a path a - b - a where b <= a\n            pos = i;\n            break;\n        }\n    for (int i = pos+1; i < LOGN; i++)\n        if (cnt[i] == 0) {\n            ans[u] = (1 << i);\n            for (int j = i+1; j < LOGN; j++)\n                if (cnt[j]) ans[u] |= (1 << j);\n            break;\n        }\n}\n\nint main() {\n    //freopen(\"\", \"rt\", stdin);\n    //freopen(\"\", \"wt\", stdout);\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    dfs(1, -1);\n    printf(\"%d\\n\", 31 - __builtin_clz(ans[1]));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\n\nint dp[MAXn], dp2[MAXn], ans = MAXn;\nvector<int> g[MAXn];\n//dp1 halati ke v ro joz raas speciala bezarim\n//dp2 halati ke v joz raas special ha nabashe va lozomn be yekishon motasel bashem\n//dp3 maximum dp2 haye motasel be v\nvoid dfs(int v, int par) {\n\tint mx = 0;\n\tvector<int> vec;\n\tif (g[v].size() == 1 && par)\n\t\treturn;\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tdfs(g[v][i], v);\n\t\t\tdp2[v] = max(dp2[v], dp[g[v][i]]);\n\t\t\tvec.push_back(dp[g[v][i]]);\n\t\t}\n\t\n\tdp[v] = dp2[v] + 1;\n\tif ((g[v].size() == 1 && !par) || (par && g[v].size() == 2)) {\n\t\tfor (int i = 0; i < g[v].size(); i++)\n\t\t\tif (g[v][i] != par) {\n\t\t\t\tdp[v] = min(dp[v], dp2[g[v][i]] + 1);\n\t\t\t}\n\t}\n\n}\n\nvoid dfs2(int v, int par, int ans1) {\n\tmultiset<int> st;\n\tst.insert(ans1);\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par)\n\t\t\tst.insert(dp[g[v][i]]);\n\t//cout << v << ' ' << ans1 << endl;\n\tans = min(ans, (*st.rbegin()) + 1);\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tst.erase(st.find(dp[g[v][i]]));\n\t\t\tif (st.size() > 1)\n\t\t\tdfs2(g[v][i], v, (*st.rbegin()) + 1);\n\t\t\telse if (st.size() == 1)\n\t\t\tdfs2(g[v][i], v, (*st.rbegin()));\n\t\t\tst.insert(dp[g[v][i]]);\n\t\t}\n\t\n\t\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tsrand(time(0));\n\treturn cout << rand() % 10,0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tdfs2(1,0, 0);\n\tcout << min(ans, dp[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, x, n) for (int i = int(x); i <= int(n); ++i)\n#define for1(i, n, x) for (int i = int(n); i >= int(x); --i)\n#define F first\n#define S second\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef long double ld;\ntypedef vector <ll> vi;\n\nconst int N = 2e6 + 1;\nconst ll INF = 1e18 + 9;\nconst int B = 1e9 + 7;\n\nint n;\nvi g[N];\nint c[N][21];\n\nvoid dfs(int x, int p = -1) {\n    for (auto to : g[x]) {\n        if (to == p) continue;\n        dfs(to, x);\n        forn(i, 0, 20) c[x][i] += c[to][i];\n    }\n    int y = 21;\n    for1(i, 20, 0) {\n        if (c[x][i] > 1) break;\n        if (!c[x][i]) y = i;\n    }\n    ++c[x][y];\n    for1(i, y - 1, 0) c[x][i] = 0;\n}\n\nint main() {\n    #ifdef black\n    freopen(\"in\", \"r\", stdin);\n    #endif // black\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n;\n    forn(i, 1, n - 1) {\n        int f, t;\n        cin >> f >> t;\n        g[f].pb(t);\n        g[t].pb(f);\n    }\n\n    dfs(1);\n    int ans = 0;\n    forn(i, 0, 20)\n        if (c[1][i]) ans = i;\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1 << 18;\nint col[N], ans, n;\nvector<int> G[N];\nvoid DFS(int v = 1, int par = 0) {\n\tint mx = 0, b = 0;\n\tfor (auto u : G[v])\n\t\tif (u ^ par) \n\t\t\tDFS(u, v), mx |= col[v] & col[u], col[v] |= col[u];\n\twhile (1 << b <= mx || col[v] & 1 << b) b ++;\n\tans = max(ans, 31 - __builtin_clz(col[v] = col[v] & ~(1 << b - 1) | 1 << b));\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, v, u; i < n; i ++) {\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tDFS();\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int NV=202020;\nint N;\nvector<int> E[NV];\nint num[NV];\n\npair<int,int> dfs_center(int cur,int pre) {\n\tpair<int,int> res=make_pair(1<<30,-1);\n\tint ma=0;\n\tnum[cur]=1;\n\t\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tres=min(res,dfs_center(r,cur));\n\t\tma=max(ma,num[r]);\n\t\tnum[cur]+=num[r];\n\t}\n\treturn min(res,make_pair(max(ma,N-num[cur]),cur));\n}\n\nint dfs(int cur,int pre) {\n\tint cnt[32]={};\n\tint mi=-1;\n\tint mask=0,i;\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tint ret = dfs(r,cur);\n\t\tmask |= ret;\n\t\tFOR(i,30) if(mask&(1<<i)) {\n\t\t\tcnt[i]++;\n\t\t\tif(cnt[i]>=2) mi=max(mi,i);\n\t\t}\n\t}\n\tmi++;\n\twhile(cnt[mi]) mi++;\n\tmask |= 1<<mi;\n\tmask &= ~((1<<mi)-1);\n\treturn mask;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto center=dfs_center(0,-1);\n\tx = dfs(center.second,-1);\n\tFOR(i,32) if(x&(1<<i)) return _P(\"%d\\n\",i);\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge{int s,t,n;}e[200010];\nint n,h[200010],f[200010];\n\nvoid dfs(int x,int fa)\n{\n\tint s=0,sum=0,k=1;\n\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\tif (y!=fa)  dfs(y,x),s|=sum&f[y],sum|=f[y];\n\twhile ((k<s)||(sum&k))  k<<=1;\n\tf[x]=(sum^(sum&(k-1)))|k;\n}\n\nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t}\n\tdfs(1,0);\n\tprintf(\"%d\",int(log2(f[1])));\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\nconst int maxSize=4000;\nvector<int> graph[maxSize];\nmap<int, int> result;\nint amount;\nvoid fillingGraph()\n{\n\tint vertex0, vertex1;\n\tcin>>amount;\n\tfor(int i=1; i<=amount; ++i)\n\t{\n\t\tcin>>vertex0>>vertex1;\n\t\tgraph[vertex0].push_back(vertex1);\n\t\tgraph[vertex1].push_back(vertex0);\n\t}\n\treturn;\n}\nvoid dfs(int first, int parent)\n{\n\tint value=0;\n\tresult.insert({first, value});\n\tfor(int second : graph[first])\n\t{\n\t\tif(second==parent)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(second, first);\n\t}\n\tfor(int nextDot : graph[first])\n\t{\n\t\tif(nextDot==parent)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(auto iterator=result.begin(); iterator!=result.end(); ++iterator)\n\t\t{\n\t\t\tif(((*iterator).first==nextDot) && ((*iterator).second<2))\n\t\t\t{\n\t\t\t\tresult[first]=(++(*iterator).second);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult[first]=value;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tfillingGraph();\n\tdfs(1, -1);\n\tint answer=0;\n\tfor(auto iterator=result.begin(); iterator!=result.end(); ++iterator)\n\t{\n\t\t//cout<<(*iterator).first<<\" : \"<<(*iterator).second<<endl;\n\t\tif((*iterator).second==2)\n\t\t{\n\t\t\t++answer;\n\t\t}\n\t}\n\tcout<<endl<<answer;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nvector<int> g[100000];\nbool del[100000];\nint sz[100000];\n\nvoid csz(int v, int p) {\n    sz[v] = 1;\n    for (int to : g[v]) if (to != p && !del[to]) {\n        csz(to, v);\n        sz[v] += sz[to];\n    }\n}\n\nint cd(int v) {\n    csz(v, -1);\n    int par = -1;\n    int szv = sz[v];\n    while (true) {\n        bool done = true;\n        for (int to : g[v]) if (to != par && !del[to] && 2 * sz[to] >= szv) {\n            par = v;\n            v = to;\n            done = false;\n            break;\n        }\n        if (done) break;\n    }\n    int res, worst, wcnt;\n    par = -1;\n    bool firstTime = true;\n    do {\n        if (firstTime) {\n            firstTime = false;\n        } else {\n            del[v] = false;\n            par = v;\n            v = worst;\n        }\n        del[v] = true;\n        res = 0;\n        worst = -1;\n        wcnt = 0;\n        for (int to : g[v]) if (!del[to]) {\n            int val = cd(to) + 1;\n            if (val > res) {\n                res = val;\n                worst = to;\n                wcnt = 1;\n            } else if (val == res) {\n                ++wcnt;\n            }\n        }\n    } while (wcnt == 1 && worst != par);\n    del[v] = false;\n    return res;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n - 1) {\n        int from, to;\n        scanf(\"%d%d\", &from, &to), --from, --to;\n        g[from].pb(to);\n        g[to].pb(from);\n    }\n\n//    n = 100000;\n//    mt19937 mt(123);\n//    for (int i = 1; i < n; ++i) {\n//        int to = i - 1;\n//        g[i].pb(to);\n//        g[to].pb(i);\n//    }\n//\n    cout << cd(0) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n,x,y,hd[100001],cnt,d[100001],f[100001],t[200001],v[100001],num[21],fa[100001],mx;\n\nstruct node\n{\n\tint to,next,ans;\n}e[200001];\n\nvoid addedge(int x,int y)\n{\n\te[++cnt].next=hd[x];\n\thd[x]=cnt;\n\te[cnt].to=y;\n\te[cnt].ans=0;\n}\n\nint calc(int x) {return ((x-1)^1)+1;}\nint getmax(int a,int b) {return a>b?a:b;}\n\nvoid dfs(int x)\n{\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tif (e[i].to!=fa[x]) fa[e[i].to]=x,dfs(e[i].to);\n\tmemset(num,0,sizeof(num));\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tif (e[i].to!=fa[x]) \n\t\t\tfor (int j=0; j<21; j++)\n\t\t\t\tif ((f[e[i].to]>>j)&1) num[j]++;\n\tmx=-1;\n\tfor (int i=20; i>=0; i--) \n\t\tif (num[i]>1) {mx=i; break;}\n\tv[x]=mx+1;\n\twhile (num[v[x]]) v[x]++;\n\tf[x]=(1<<v[x]);\n\tfor (int i=v[x]+1; i<=20; i++)\n\t\tif (num[i]) f[x]|=(1<<i);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n); cnt=0;\n\tmemset(hd,0,sizeof(hd));\n\tmemset(d,0,sizeof(d));\n\tfor (int i=1; i<n; i++) \n\t\tscanf(\"%d%d\",&x,&y),addedge(x,y),addedge(y,x),d[x]++,d[y]++;\n\tmemset(f,0,sizeof(f));\n\tmemset(fa,0,sizeof(fa));\n\tdfs(1); mx=0;\n\tfor (int i=1; i<=n; i++) mx=getmax(mx,v[i]);\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define rs (x<<1|1)\n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) (int((x).size()))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=1e5+5;\nint n,tot;\nint head[maxn],des[maxn<<1],nxt[maxn<<1];\nint S[maxn],id[maxn];\nvoid adde(int x,int y){\n\tdes[++tot]=y;nxt[tot]=head[x];head[x]=tot;\n}\nvoid dfs(int x,int fa){\n\tint sum=0,common=0;\n\tRep(p,x)if(des[p]!=fa){\n\t\tdfs(des[p],x);\n\t\tcommon|=S[des[p]]&sum;\n\t\tsum|=S[des[p]];\n\t}\n\tint k=0;\n\tfor(;(common>>k)||(sum>>k&1);k++);\n\tid[x]=k;\n\tS[x]=((sum>>k)|1)<<k;\n}\nint main(){\n\tread(n);\n\trep(i,1,n-1){\n\t\tint x,y;read(x);read(y);\n\t\tadde(x,y);adde(y,x);\n\t}\n\tdfs(1,0);\n\tsort(id+1,id+n+1);\n\tprintf(\"%d\\n\",id[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint f[100100][20],n,ans,h[101000],len,t,mid,flag;\nvector<int> e[101000];\nvoid dfs(int x,int dad,int dis){\n\tif(dis>len) len=dis,t=x;\n\tfor(int v:e[x]) if(v!=dad&&!h[v]) dfs(v,x,dis+1);\n}\nvoid getmid(int x,int dad,int pos,int p){\n\tif(x==pos) flag=1;\n\tif(flag) return;\n\tfor(int v:e[x]) if(v!=dad&&!h[v]){\n\t\tgetmid(v,x,pos,p-1);\n\t\tif(flag&&!p){mid=x;return;}\n\t}\n}\nint solve(int x){\n\tlen=0;t=0;dfs(x,0,1);\n\tint s=t;len=0;dfs(s,0,1);\n\tif(len>2){\n\t\tflag=0;mid=0;getmid(s,0,t,len/2);\n\t}\n\telse mid=t;\n\tint now=mid,mx=-1;h[mid]=1;\n\tfor(int v:e[now]) if(!h[v]) mx=max(mx,solve(v));\n\treturn mx+1;\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x);read(y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tcout<<solve(1)<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int maxn=1e5+5;\n\nint n,tot,ans;\nint bit[maxn];\nint now[maxn],pre[maxn*2],son[maxn*2];\n\nint read() {\n\tint x=0,f=1;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\treturn x*f;\n}\n\nvoid add(int a,int b) {\n\tpre[++tot]=now[a];\n\tnow[a]=tot,son[tot]=b;\n}\n\nvoid dfs(int fa,int u) {\n\tint limit=0;\n\tfor(int p=now[u],v=son[p];p;p=pre[p],v=son[p])\n\t\tif(v!=fa) {\n\t\t\tdfs(u,v);\n\t\t\tlimit|=bit[u]&bit[v];\n\t\t\tbit[u]|=bit[v];\n\t\t}\n\tint mx=20;\n\twhile(mx>=0&&(!(limit&(1<<mx))))mx--;\n\tmx++;\n\twhile(bit[u]&(1<<mx))mx++;\n\tbit[u]|=1<<mx;\n\tans=max(ans,mx),bit[u]=bit[u]>>mx<<mx;\n}\n\nint main() {\n\tn=read();\n\tfor(int i=1;i<n;i++) {\n\t\tint a=read(),b=read();\n\t\tadd(a,b),add(b,a);\n\t}\n\tdfs(0,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100100\nusing namespace std;\nvector<int>G[maxn];\nint n,dp[maxn],len;\nint dfs(int u,int f){\n\tint mx=0,y=0,z=0,s;\n\tfor(int i=0,x;i<G[u].size();++i)if(G[u][i]!=f)\n\t\ts=dfs(G[u][i],u),mx=max(mx,__lg(y&s)),y|=s;\n//\tprintf(\"<%d,%d>\",u,mx);\n\tfor(int i=mx;;i++)if(!(y>>i&1))\n\t\treturn (y&(-1<<i))|(1<<i);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),\n\t\tG[v].push_back(u),\n\t\tG[u].push_back(v);\n\tprintf(\"%d\",__lg(dfs(1,0)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> G[100000];\nbool used[100000];\nint sz[100000];\nvoid dfs(int x, int p) {\n  sz[x] = 1;\n  for (int t : G[x]) if (t != p && !used[t]) dfs(t, x), sz[x] += sz[t];\n}\nP dfs2(int x, int p, int all) {\n  int mc = all-sz[x];\n  P m = P(INF, -1);\n  for (int t : G[x]) if (t != p && !used[t]) {\n    m = min(m, dfs2(t, x, all));\n    mc = max(mc, sz[t]);\n  }\n  return min(m, P(mc, x));\n}\nint find_centroid(int s) {\n  dfs(s, -1);\n  return dfs2(s, -1, sz[s])._2;\n}\n\nint solve(int s) {\n  int g = find_centroid(s);\n  used[g] = true;\n  int m = -1;\n  for (int t : G[g]) if (!used[t]) m = max(m, solve(t));\n  return m+1;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n  cout << solve(0) << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100000;\nint n, f[maxn + 10];\nvector<int> g[maxn + 10];\n\nvoid dfs(int p, int fa) {\n\tint cnt[20]; memset(cnt, 0, sizeof cnt);\n\tfor (int i = 0; i < g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (e != fa) {\n\t\t\tdfs(e, p);\n\t\t\tfor (int j = 0; j < 20; ++j) cnt[j] += (f[e] >> j & 1);\n\t\t}\n\t}\n\tint now;\n\tfor (int i = 19; i >= 0; --i)\n\t\tif (cnt[i] > 1) break; else if (!cnt[i]) now = i;\n\tfor (int i = 0; i <= 19; ++i)\n\t\tif (i == now) f[p] |= 1 << i;\n\t\telse if (i > now) f[p] |= (bool(cnt[i]) * (1 << i));\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tg[l].push_back(r); g[r].push_back(l);\n\t}\n\tdfs(1, 0);\n\tfor (int i = 19; i >= 0; --i)\n\t\tif (f[1] >> i & 1) {\n\t\t\tprintf(\"%d\", i); return 0;\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 13;\nint n, ans, val[maxN][50 + 13];\nvector<int> adj[maxN];\nvoid dfs (int x, int par) {\n    for (auto a : adj[x]) {\n\tif (a != par) {\n\t    dfs(a, x);\n\t    for (int i = 0; i <= 50; i++)\n\t\tval[x][i] += val[a][i];\n\t}\n    }\n    int cur = 0;\n    for (int i = 0; i <= 50; i++) {\n\t//cout << x << \" \" << i << \" \" << val[x][i] << endl;\n\tif (val[x][i] >= 2)\n\t    cur = i + 1;\n    }\n    while (val[x][cur])\n\tcur++;\n    ans = max(ans, cur);\n    for (int i = 0; i < cur; i++)\n\tval[x][i] = 0;\n    //cout << x << \" \" << cur << endl;\n    val[x][cur] = 1;\n}\n\nint main () {\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n\tint a, b;\n\tcin >> a >> b;\n\tadj[a].push_back(b);\n\tadj[b].push_back(a);\n    }\n\n    dfs(1, 1);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,oo=1e18,N=1e5+100;\n\nvi g[N], f[N];\n\nnamespace centroid{\n    int sz[N];\n    bool used[N];\n\n    void dfs(int v, int pr){\n        sz[v]=1;\n        for(auto to:g[v]){\n            if(to==pr||used[v])\n                continue;\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n\n    int find_centroid(int v, int pr, int k){\n        for(auto to:g[v]){\n            if(to==pr||used[to])\n                continue;\n            if(sz[to]>=k/2)\n                return find_centroid(to,v,k);\n        }\n        return v;\n    }\n\n\n    void build_centroid(int v, int parent){\n        dfs(v,v);\n        int centroid=find_centroid(v,v,sz[v]);\n        used[centroid]=true;\n        f[parent].push_back(centroid);\n        for(auto to:g[centroid]){\n            if(!used[to])\n                build_centroid(to,centroid);\n        }\n    }\n}\n\nint lol[N];\n\nint ans=0;\nvoid kek_dfs(int v, int u){\n    inmax(ans,u);\n    for(auto to:f[v]){\n        kek_dfs(to,u+1);\n    }\n}\n\nvoid smain() {\n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++){\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    centroid::build_centroid(1,0);\n    int y=f[0][0];\n    kek_dfs(y,0);\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "//#define  NDEBUG\n\n//#pragma optimize(\"tree-vectorize\")\n//#pragma optimize (\"fast-math\")\n//#pragma optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v)                  v.begin(), v.end()\n#define db(x)                   cout << #x << \" = \" << (x) << \"\\n\"\n#define fend(x)                 ((x) & ((x)+1)) - 1\n#define fenu(x)                 (x) | ((x)+1)\n#define forn(i, n)              for (int i = 0; i < (int)n; ++i)\n#define forr(i, b, e)           for (int i = b; i < (int)e; ++i)\n#define ft                      first\n#define len(s)                  s.length()\n#define mp                      std::make_pair\n#define pob                     pop_back\n#define pof                     pop_front\n#define pub                     push_back\n#define puf                     push_front\n#define sc                      second\n\ntypedef double dbl;\ntypedef long double ldbl;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst long long MILLER_RABIN = 3215031751;\nconst long double PI = acos(-1);\n\n#if __cplusplus >= 201103L\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nstruct config_io {\n    config_io() {\n        cin.tie(nullptr);\n        cout.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n    }\n} cnf_io;\n\nstruct config_rand {\n    config_rand() {\n        srand(chrono::duration_cast<chrono::nanoseconds>(\n                chrono::high_resolution_clock::now().time_since_epoch()).count());\n    }\n} cnf_rand;\n\nnamespace std {\n    template<>\n    struct hash<pair<int, int> > {\n        size_t operator()(const pair<int, int> &x) const {\n            return (x.first * 71ll + x.second) % ((int) 1e9 + 7);\n        }\n    };\n\n    template<>\n    struct hash<vector<int>> {\n        size_t operator()(const vector<int> &v) const {\n            size_t hsh = 0;\n            for (int i = 0; i < v.size(); ++i) {\n                hsh = (hsh * 71ll + v[i]) % (int) (1e9 + 7);\n            }\n            return hsh;\n        }\n    };\n}\n\ntemplate<class T>\nusing ordered_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n//ordered_set<int>  s;\n//s.insert(3);\n//cout << s.order_of_key(2) << endl; // the number of elements in the s less than 2\n//cout << *s.find_by_order(0) << endl; // print the 0-th smallest number in s(0-based)\n\n// __builtin_popcount(x) - Returns the number of 1-bits in x.\n// __builtin_parity(x) - Returns the parity of x, i.e. the number of 1-bits in x modulo 2.\n// __builtin_ffs(x) - Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero.\n// __builtin_clz(x) - Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.\n// __builtin_ctz(x) - Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.\n\n//inline string tobin(long long x) { bitset<63>(x).to_string(); }\n\ntemplate<class T>\nvoid trace(T collection) {\n    for (auto elem : collection) { cout << elem << \" \"; }\n    cout << endl;\n}\n\n#endif\n\nconst int ML = 1e5 + 10;\nvector<int> g[ML];\nint f[ML];\n\nint most_sign_bit(int x) {\n    return 31 - __builtin_clz(x);\n}\n\nint first_zero_bit(int x) {\n    int i = 0;\n    while (x & (1 << i)) ++i;\n    return i;\n}\n\nvoid dfs(int v, int par = -1) {\n    f[v] = 0;\n    forn(i, g[v].size()) {\n        int to = g[v][i];\n        if (to == par) continue;\n        dfs(to, v);\n    }\n    int d = 1 << 20;\n    while (d) {\n        int cnt = 0;\n        forn(i, g[v].size()) {\n            int to = g[v][i];\n            if (to == par) continue;\n            if (f[to] & d) cnt++;\n        }\n        if (cnt > 1) {\n            f[v] += d << 1;\n            return;\n        }\n        if (cnt == 1) f[v] |= d;\n        d >>= 1;\n    }\n    f[v] += 1;\n}\n\nvoid solve(int test) {\n    int n;\n    cin >> n;\n    forn(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0);\n    //cout << bitset<32>(f[0]) << endl;\n    cout << most_sign_bit(f[0]) << endl;\n}\n\nint main() {\n#ifdef HOME\n    freopen(\"home.in\", \"r\", stdin);\n    freopen(\"home.out\", \"w\", stdout);\n#endif\n\n    int tests = 1;\n    //cin >> tests;\n    for (int test = 1; test <= tests; ++test) {\n        solve(test);\n    }\n\n#ifdef HOME\n    cout << \"\\n\\nTime: \" << clock() / (double) CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct node {\n\tint to, next;\n} edge[MAXN*2];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nint n, a, b;\nint siz[MAXN], vis[MAXN];\n\nvoid dfs_siz(int nd, int f)\n{\n\tsiz[nd] = 1;\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (vis[to] || to == f) continue;\n\t\tdfs_siz(to, nd), siz[nd] += siz[to];\n\t}\n}\n\nvoid dfs_find(int nd, int f, const int totsiz, int &cur, int &ans)\n{\n\tint maxsiz = totsiz-siz[nd];\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (vis[to] || to == f) continue;\n\t\tdfs_find(to, nd, totsiz, cur, ans);\n\t\tmaxsiz = max(maxsiz, siz[to]);\n\t}\n\tif (maxsiz < cur) cur = maxsiz, ans = nd;\n}\n\nint dfs(int nd)\n{\n\tdfs_siz(nd, 0);\n\tint tot = 1e9, cen;\n\tdfs_find(nd, 0, siz[nd], tot, cen), nd = cen;\n\tvis[nd] = 1;\n\tint ans = 0;\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (vis[to]) continue;\n\t\tans = max(ans, dfs(to)+1);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpush(a, b), push(b, a);\n\t}\n\tcout << dfs(1)-1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=200010;\nint i,j,k,n,m,x,y,t,b[20];\nint fi[N*2],ne[N*2],la[N*2],a[N*2],w[N];\nint f[N][20],g[N][20];\nvoid add(int x,int y){\n\tk++;a[k]=y;\n\tif (fi[x]==0)fi[x]=k;else ne[la[x]]=k;\n\tla[x]=k;\n}\nvoid dfs(int x,int fa){\n\tfor (j=0;j<20;j++)f[x][j]=1;\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa){\n\t\tdfs(a[i],x);\n\t\tfor (j=0;j<20;j++)f[x][j]&=f[a[i]][j],g[x][j]+=g[a[i]][j];\n\t}\n\tmemset(b,0,sizeof b);\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa)b[w[a[i]]]++;\n\tfor (j=19;j>=0;j--)if (b[j]>1){\n\t\tfor (k=j;k<20;k++)if (f[x][k]){w[x]=k;break;}\n\t\tbreak;\n\t}\n\tif (!w[x]){for (j=0;j<20;j++)if (f[x][j]){w[x]=max(w[x],j);break;}}\n\tf[x][w[x]]=0;g[x][w[x]]++;\n\tfor (j=0;j<w[x];j++)f[x][j]=1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,-1);\n\tint ans=0;\n\tfor (i=1;i<=n;i++)ans=max(ans,w[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <list>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <assert.h>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\nconst int SZ = 1e5 + 10;\nconst int INF = 1e9;\n\nvector<int> child[SZ];\nint d[SZ], diam;\nbool v[SZ];\n\nvoid dfs(int h) {\n\tv[h] = true;\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tdfs(i);\n\t\t\td[h] = max(d[h], d[i] + 1);\n\t\t}\n}\n\nvoid dfs1(int h, int top) {\n\tv[h] = true;\n\tint mx1 = top, mx2 = 0;\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tif (d[i] + 1 >= mx1) {\n\t\t\t\tmx2 = mx1;\n\t\t\t\tmx1 = d[i] + 1;\n\t\t\t} else if (d[i] + 1 >= mx2)\n\t\t\t\tmx2 = d[i] + 1;\n\t\t}\n\tdiam = max(diam, mx1 + mx2);\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tif (d[i] + 1 == mx1)\n\t\t\t\tdfs1(i, mx2 + 1);\n\t\t\telse\n\t\t\t\tdfs1(i, mx1 + 1);\n\t\t}\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tchild[a].push_back(b);\n\t\tchild[b].push_back(a);\n\t}\n\tdfs(0);\n\tfor (int i = 0; i < n; i++)\n\t\tv[i] = false;\n\tdfs1(0, 0);\n\n\tdiam++;\n\tint ans = 0, p = 1;\n\twhile (p < diam) {\n\t\tans++;\n\t\tp = 2 * p;\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n\nusing std::max_element;\nconst int N = 100010;\nconst int M = 30;\nint _w;\n\nnamespace Tree {\n\tint head[N], nxt[N*2], to[N*2], eid;\n\tvoid init() {\n\t\teid = 0;\n\t\tmemset(head, -1, sizeof head);\n\t}\n\tvoid link( int u, int v ) {\n\t\tto[eid] = v, nxt[eid] = head[u], head[u] = eid++;\n\t\tto[eid] = u, nxt[eid] = head[v], head[v] = eid++;\n\t}\n}\n\nint n, f[N][M], g[N];\n\nvoid dfs( int u, int fa ) {\n\tusing namespace Tree;\n\tfor( int i = head[u]; ~i; i = nxt[i] ) {\n\t\tint v = to[i];\n\t\tif( v == fa ) continue;\n\t\tdfs(v, u);\n\t\tfor( int j = 0; j < M; ++j )\n\t\t\tf[u][j] += f[v][j];\n\t}\n\tint i;\n\tfor( i = M-1; i; --i )\n\t\tif( f[u][i] >= 2 )\n\t\t\tbreak;\n\twhile( f[u][i] ) ++i;\n\tg[u] = i, f[u][i] = 1;\n\tfor( int j = 0; j < i; ++j )\n\t\tf[u][j] = 0;\n}\n\nint main() {\n\t_w = scanf( \"%d\", &n );\n\tTree::init();\n\tfor( int i = 1; i < n; ++i ) {\n\t\tint u, v;\n\t\t_w = scanf( \"%d%d\", &u, &v );\n\t\tTree::link(u, v);\n\t}\n\tdfs(1, 0);\n\tprintf( \"%d\\n\", *max_element(g+1, g+n+1) );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nstd::vector<int> edges[100005];\n\nint uninity[100005];\n\nint msb[1<<20];\n\nvoid dfs(int node,int parent){\n  int once=0,twice=0;\n  for(int child:edges[node]){\n    if(child==parent) continue;\n    dfs(child,node);\n    twice|=(uninity[child]&once);\n    once|=uninity[child];\n  }\n  uninity[node]=(once&~((1<<msb[twice])-1))+(1<<msb[twice]);\n  //printf(\"uninity[%d]=%d\\n\",node,uninity[node]);\n}\n\nint main(){\n  for(int i=1;i<(1<<20);i++){\n    msb[i]=msb[i>>1]+1;\n  }\n  int N;\n  scanf(\"%d\",&N);\n  for(int i=0;i<N-1;i++){\n    int A,B;\n    scanf(\"%d %d\",&A,&B);\n    A--,B--;\n    edges[A].push_back(B);\n    edges[B].push_back(A);\n  }\n  dfs(0,0);\n  printf(\"%d\\n\",msb[uninity[0]]-1);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\nint Adj[MAXN],V[MAXN*2],nxt[MAXN*2],c;\nvoid AddEdge(int u,int v)\n{\n\tc++;V[c]=v,nxt[c]=Adj[u];Adj[u]=c;\n}\nint dp[MAXN][21],n,ans;\nvoid dfs(int u,int p)\n{\n\tfor(int i=Adj[u];i;i=nxt[i])\n\t\tif(V[i]!=p)\n\t\t{\n\t\t\tint v=V[i];\n\t\t\tdfs(v,u);\n\t\t\tfor(int j=0;j<=20;j++)\n\t\t\t\tdp[u][j]+=dp[v][j];\n\t\t}\n\tint k=0;\n\tfor(int i=20;i>=0;i--)\n\t\tif(dp[u][i]>1)\n\t\t{\n\t\t\tk=i+1;\n\t\t\tbreak;\n\t\t}\n\twhile(dp[u][k]) k++;\n\tdp[u][k]++;\n\tfor(int i=0;i<k;i++)\n\t\tdp[u][i]=0;\n\tans=max(ans,k);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint u,v;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tAddEdge(u,v);\n\t\tAddEdge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/* ***************************************\nAuthor        :Scau.ion\nCreated Time  :2017/01/22 21:30:57 UTC+8\nFile Name     :ion.cpp\n*************************************** */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define ULL unsigned long long\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<PII>\n#define X first\n#define Y second\n#define IOS ios::sync_with_stdio(0);cin.tie(0);\n#define IN freopen(\"in\", \"r\", stdin);\n#define OUT freopen(\"out\", \"w\", stdout);\n\nconst int maxn=100010;\n\nVI son[maxn];\nint ma,id;\n\nvoid dfs(int st,int fa,int dep)\n{\n    if (dep>ma)\n    {\n        ma=dep;\n        id=st;\n    }\n    for (int j=0;j<son[st].size();++j)\n    {\n        if (son[st][j]==fa) continue;\n        dfs(son[st][j],st,dep+1);\n    }\n    return;\n}\n\nint main()\n{\n    IOS;\n    int n;\n    cin>>n;\n    for (int j=1;j<n;++j)\n    {\n        int a,b;\n        cin>>a>>b;\n        son[a].PB(b);\n        son[b].PB(a);\n    }\n    dfs(1,0,1);\n    dfs(id,0,1);\n    int ans=0;\n    int mx=1;\n    while (ma>mx)\n    {\n        ++ans;\n        mx=mx*2+1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 100005;\n\nmultiset<int> G[NMAX];\nint chain[NMAX], diam[NMAX];\n\nvoid dfs1(int node, int prev) {\n    int vmax1 = 0, vmax2 = 0;\n    for (int to: G[node]) {\n        if (to == prev) {\n            continue;\n        }\n        dfs1(to, node);\n        if (vmax1 < chain[to]) {\n            vmax2 = vmax1;\n            vmax1 = chain[to];\n        } else if (vmax2 < chain[to]) {\n            vmax2 = chain[to];\n        }\n        diam[node] = max(diam[node], diam[to]);\n    }\n    diam[node] = vmax1 + vmax2 + 1;\n    chain[node] = vmax1 + 1;\n}\n\nint maxDiam[NMAX];\nint allMin;\n\nint nextRoot = -1;\n\nvoid dfs2(int node, int prev, int chainUp = 0, int diamUp = 0) {\n    int vmax1 = chainUp, vmax2 = 0, vmax3 = 0;\n    int dmax1 = diamUp, dmax2 = 0;\n    maxDiam[node] = diamUp;\n    for (int to: G[node]) {\n        if (to == prev) {\n            continue;\n        }\n        maxDiam[node] = max(maxDiam[node], diam[to]);\n        if (chain[to] > vmax1) {\n            vmax3 = vmax2;\n            vmax2 = vmax1;\n            vmax1 = chain[to];\n        } else if (chain[to] > vmax2) {\n            vmax3 = vmax2;\n            vmax1 = chain[to];\n        } else if (chain[to] > vmax3) {\n            vmax3 = chain[to];\n        }\n        if (diam[to] > dmax1) {\n            dmax2 = dmax1;\n            dmax1 = diam[to];\n        } else if (diam[to] > dmax2) {\n            dmax2 = diam[to];\n        }\n    }\n    if (maxDiam[node] < allMin) {\n        nextRoot = node;\n        allMin = maxDiam[node];\n    }\n    for (int to: G[node]) {\n        if (to == prev) {\n            continue;\n        }\n        int chainDown = (chain[to] == vmax1 ? vmax2: vmax1) + 1;\n        int diamDown1;\n        if (diam[to] == dmax1) {\n            diamDown1 = dmax2;\n        } else {\n            diamDown1 = dmax1;\n        }\n        int diamDown2;\n        if (chain[to] == vmax1) {\n            diamDown2 = vmax2 + vmax3 + 1;\n        } else {\n            diamDown2 = vmax1 + vmax2 + 1;\n        }\n        int diamDown = max(diamDown1, diamDown2);\n        dfs2(to, node, chainDown, diamDown);\n    }\n}\n\nint solve(int root) {\n    dfs1(root, -1);\n    allMin = 0x3f3f3f3f;\n    nextRoot = -1;\n    dfs2(root, -1);\n    root = nextRoot;\n    int ans = 0;\n    for (int to: G[root]) {\n        G[to].erase(root);\n        ans = max(ans, solve(to) + 1);\n    }\n    return ans;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].insert(y);\n        G[y].insert(x);\n    }\n\n    cout << solve(1) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=100000+10;\nint h[maxn],go[maxn*2],nxt[maxn*2],bit[maxn],f[maxn];\nint i,j,k,l,t,n,m,tot,top,ans;\nvoid add(int x,int y){\n    go[++tot]=y;\n    nxt[tot]=h[x];\n    h[x]=tot;\n}\nvoid dfs(int x,int y){\n    bit[x]=f[x]=0;\n    int t=h[x],l=0;\n    while (t){\n        if (go[t]!=y){\n            dfs(go[t],x);\n            l|=(bit[x]&bit[go[t]]);\n            bit[x]|=bit[go[t]];\n        }\n        t=nxt[t];\n    }\n    if (!bit[x]) bit[x]=1;\n    else{\n        while ((1<<f[x])<=l||(1<<f[x])&bit[x]) f[x]++;\n        bit[x]=(bit[x]>>f[x]<<f[x])|(1<<f[x]);\n    }\n    ans=max(ans,f[x]);\n}\nint main(){\n    scanf(\"%d\",&n);\n    fo(i,1,n-1){\n        scanf(\"%d%d\",&j,&k);\n        add(j,k);add(k,j);\n    }\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\n///////////////////////\n\nint const N = 3e5 + 41;\nint const M = 25;\n\nint n;\nint d[N];\nvector<int> e[N];\n\nint dfs(int u, int p){\n\tint atleastOne = 0;\n\tint atleastTwo = 0;\n\trep(i, 0, sz(e[u])){\n\t\tint to = e[u][i];\n\t\tif(to == p) continue;\n\t\tint res = dfs(to, u);\n\t\tatleastTwo|= (atleastOne & res);\n\t\tatleastOne |= res;\n\t}\n\tint ret;\n\trep(i, 0, M){\n\t\tif( ((1<<i) > atleastTwo) && !(atleastOne&(1<<i)) ){\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint result = (1 << ret);\n\trep(i, ret, M){\n\t\tresult |= ((1 << i) & atleastOne);\n\t}\n\n\treturn d[u] = result;\n}\n\nvoid solve(){\n\tcin >> n;\n\trep(i, 0, n-1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u;--v;\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tint ansMask = dfs(0, 0);\n\tint ans = 0;\n\twhile(ansMask){\n\t\t++ans;\n\t\tansMask /= 2;\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned int uint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=100010;\ninline uint lowbit(uint x){\n\treturn x&-x;\n}\ninline uint highbit(uint x){\n\tfor(;x!=(x&-x);x^=x&-x);\n\treturn x;\n}\nnamespace T{\n\tconst int E=N<<1;\n\tint to[E],bro[E],head[N],e=0;\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tuint dfs(int x,int fa){\n\t\tuint ans=0,hb=0;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])!=fa){\n\t\t\t\tuint cur=dfs(v,x);\n\t\t\t\tapmax(hb,lowbit(~cur));\n\t\t\t\tapmax(hb,highbit(cur&ans));\n\t\t\t\tans|=cur;\n\t\t\t}\n\t\t}\n\t\thb=hb?hb<<1:1;\n\t\treturn hb|(ans&~(hb-1));\n\t}\n}\nint main(){\n\tint n=ni;\n\tT::init();\n\tfor(int i=1;i<n;T::add(ni,ni),i++);\n\tuint tmp=T::dfs(1,0);\n\tint ans=0;\n\tfor(;tmp>1;tmp>>=1,ans++);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>pat[100000];\nbool flag[100000];\nint dfs(int node)\n{\n\tflag[node] = true;\n\tint d[20];\n\tfill(d, d + 20, 0);\n\tfor (int i = 0; i < pat[node].size(); i++)\n\t{\n\t\tif (!flag[pat[node][i]])\n\t\t{\n\t\t\tint t = dfs(pat[node][i]);\n\t\t\tfor (int j = 0; j < 20; j++)if ((t&(1 << j)) != 0)d[j]++;\n\t\t}\n\t}\n\tint lb = 0;\n\tfor (int i = 0; i < 20; i++)if (d[i] >= 2)lb = i + 1;\n\tint r = 0;\n\tfor (int i = lb; i < 20; i++)\n\t{\n\t\tif (d[i] == 0)\n\t\t{\n\t\t\tr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ret = (1 << r);\n\tfor (int i = r + 1; i < 20; i++)if (d[i]>0)ret += 1 << i;\n\treturn ret;\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num - 1; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tfill(flag, flag + num, false);\n\tint r = dfs(0);\n\tint maxi = 0;\n\tfor (int i = 0; i < 20; i++)if ((r&(1 << i)) != 0)maxi = i;\n\tprintf(\"%d\\n\", maxi);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n - 1) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    function<int (int, int)> go = [&](int i, int parent) {\n        int p = 0;\n        for (int j : g[i]) if (j != parent) {\n            p |= go(j, i);\n        }\n        return p + 1;\n    };\n    int p = go(0, -1);\n    int k = 31 - __builtin_clz(p);\n    // output\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define ll long long\n#define MAX 100100\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next;}e[MAX<<1];\nint h[MAX],cnt=1;\ninline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}\nint f[MAX][25];\nint ans,n;\nvoid dfs(int u,int ff)\n{\n\tfor(int i=h[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;if(v==ff)continue;\n\t\tdfs(v,u);\n\t\tfor(int j=0;j<=20;++j)f[u][j]+=f[v][j];\n\t}\n\tint p=0;\n\tfor(int i=20;~i;--i)\n\t\tif(f[u][i]>1){p=i+1;break;}\n\twhile(f[u][p])++p;++f[u][p];\n\tfor(int i=0;i<p;++i)f[u][i]=0;\n\tans=max(ans,p);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u=read(),v=read();\n\t\tAdd(u,v);Add(v,u);\n\t}\n\tdfs(1,0);printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define PB push_back\n#define MP make_pair\n#define int long long \n\nconst int N=1e5+200;\nconst int NN=20+3;\n\nvector<int> a[N];\nvector<int> b[N];\nint h[N],dp[N];\nint maxi=1; \n\nvoid dfs(int v,int par=-1){\n\tfor(int i=0,u;i<a[v].size();i++){\n\t\tu=a[v][i];\n\t\tif(u!=par){\n\t\t\th[u]=h[v]+1;\n\t\t\tdfs(u,v);\n\t\t\tdp[v]=max(dp[v],dp[u]+1);\n\t\t\tb[v].PB(dp[u]);\n\t\t}\n\t}\n\tmaxi=max(maxi,dp[v]);\n\tsort(b[v].begin(),b[v].end(),greater<int> () );\n\tif(b[v].size()>1){\n\t\tmaxi=max(maxi,b[v][0]+b[v][1]+2);\n\t}\n}\nint nesf(int x){\n\tif(x%2==0)return x/2; \n\treturn x/2+1;\n}\nint f(int x){\n\tif(x==0)return 0; \n\tif(x==1)return 1; \n\tint ans=f(nesf(x)-1)+1;\n\treturn ans;\n}\nint32_t main(){\n    ios::sync_with_stdio(0);cin.tie(0);\n \tint n; \n\tcin>>n; \n\tfor(int i=0,u,v;i<n-1;i++){\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\ta[u].PB(v);\n\t\ta[v].PB(u);\n\t}\n\tdfs(0);\n\tint ans=f(maxi);\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200000 +10;\nconst int lim = 18;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nstack <int> s;\nvoid out(int x){\n\tif(!x)s.push(0);\n\twhile(x){s.push(x%2);x/=2;}\n\tfor(int i=lim;i>(int)s.size();i--)printf(\"0\");\n\twhile(!s.empty()){printf(\"%d\",s.top()%2);s.pop();}\n\tputs(\"\");\n}\nint n,ans,cnte;\nint f[maxn],f2[maxn];\nint ai[maxn],label[maxn];\nint head[maxn],to[maxn*2],nxt[maxn*2];\nint lowbit(int x){return x&(-x);}\nvoid AddEdge(int x,int y){ ++cnte;to[cnte]=y;nxt[cnte]=head[x];head[x]=cnte; }\nvoid init(){\n\tai[0] = (1<<lim)-1;\n\tfor(int i=1;i<=lim;i++)ai[i]=ai[i-1]-lowbit(ai[i-1]);\n}\nint find(int x,int first){ \n\tfor(int i=first;i<=lim;i++)if(!((1<<i)&x))return i; return -1; \n}\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];i;i=nxt[i])if(to[i]^fa){\n\t\tdfs(to[i],x);\n\t\tf2[x] |= f[to[i]] & f[x];\n\t\tf[x] = f[to[i]] ^ f[x];\n\t}\n\n//\tprintf(\"pro_x:%d\\n\",x);\n//\tprintf(\"f1:\");out(f[x]);\n//\tprintf(\"f2:\");out(f2[x]);\n\n\tlabel[x] = find(f[x],(!f2[x])?0:32-__builtin_clz(f2[x]));\n//\tprintf(\"label[x]:%d\\n\",label[x]);\n\n\tans=max(ans,label[x]);\n\n\tf[x] = f[x] & ai[ label[x] ];\n\tf2[x] = f2[x] & ai[ label[x] ];\n\n\tf[x] |= (1<<label[x]);\n\n//\tprintf(\"updated_x:%d\\n\",x);\n//\tprintf(\"f1:\");out(f[x]);\n//\tprintf(\"f2:\");out(f2[x]);\n//\tputs(\"\");\n\n}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin),freopen(\"test.out\",\"w\",stdout);\n\tinit();\n\n\tn=read();\n\tfor(int i=1;i<=n-1;i++){\n\t\tint x,y;\n\t\tx=read();y=read();\n\t\tAddEdge(x,y);AddEdge(y,x);\n\t}\n\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nint N;\nvector <int> adjList[100005];\nint dp[100005];\n\nii getFurthest(int u, int prevP, int prevDist)\n{\n    ii furthest = ii(prevDist, u);\n    for (int v : adjList[u])\n    {\n        if (v == prevP) continue;\n        ii cur = getFurthest(v, u, prevDist + 1);\n        if (furthest.first <= cur.first) furthest = cur;\n    }\n    return furthest;\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    for (int i = 1; i < N; i++)\n    {\n        int a, b; scanf(\"%d%d\", &a, &b);\n        adjList[a].push_back(b), adjList[b].push_back(a);\n    }\n    int diameter = getFurthest(getFurthest(1, -1, 0).second, -1, 0).first + 1;\n    dp[0] = 1;\n    for (int i = 1; i <= N; i++) dp[i] = dp[i - 1] * 2 + 1;\n    int k = lower_bound(dp, dp + N, diameter) - dp;\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define next nxt\n\nint n,x[N],y[N],next[N],p[N],f[N],g[N],ans;\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nvoid travel(int x){\n\tint tmp=0,t=0;\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (f[x]!=y[t]){\n\t\t\tf[y[t]]=x;travel(y[t]);\n\t\t\ttmp|=g[x]&g[y[t]];g[x]|=g[y[t]];\n\t\t}\n\twhile ((1<<t)<=tmp||(1<<t)&g[x]) t++;\n\tg[x]=(g[x]>>t<<t)|(1<<t);\n\tans=max(ans,t);\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n-1;i++){\n\t\tx[2*i-1]=y[2*i]=read();\n\t\ty[2*i-1]=x[2*i]=read();\n\t\tnext[2*i-1]=p[x[2*i-1]];p[x[2*i-1]]=2*i-1;\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t}\n\ttravel(1);printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n = num_in<int>();\n    vector<vector<int>> adj(n);\n    for (int _ : in(n - 1)) {\n        int a = num_in<int>() - 1, b = num_in<int>() - 1;\n        adj[a].emplace_back(b);\n        adj[b].emplace_back(a);\n    }\n    const int LOGN = 18;\n    function<int(int, int)> dfs = [&](int cur, int par)-> int {\n        vector<int> count(LOGN);\n        for (int nxt : adj[cur]) {\n            if (nxt == par) continue;\n            int ret = dfs(nxt, cur);\n            for (int i : in(LOGN))\n                if ((ret & (1 << i)) != 0)\n                    count[i] += 1;\n        }\n        int lower = [&]()-> int {\n            for (int i : in(LOGN).rev()) {\n                if (count[i] >= 2) {\n                    for (int j : in(i, LOGN)) \n                        if (count[j] == 0)\n                            return j;\n                }\n            }\n            for (int i : in(LOGN))\n                if (count[i] == 0)\n                    return i;\n            assert(0);\n        }();\n        int res = 1 << lower;\n        for (int i : in(lower + 1, LOGN))\n            if (count[i] == 1)\n                res |= 1 << i;\n        return res;\n    };\n    int val = dfs(0, -1);\n    cout << 31 - __builtin_clz(val) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nvector<int> G[N];\nint n,a[N];\nvoid dfs(int t,int fa)\n{\n\tint i,j,u=0,v=0;\n\tfor(i=0;i<G[t].size();i++)\n\t\tif(G[t][i]!=fa){\n\t\t\tdfs(G[t][i],t);\n\t\t\tv|=u&a[G[t][i]];\n\t\t\tu|=a[G[t][i]];\n\t\t  }\n\tv=(v<<1)|1;\n\tfor(i=30;i>=0;i--)\n\t\tif((v>>i)&1)\n\t\t\tfor(j=i;j<=30;j++)\n\t\t\t\tif((~u>>j)&1){\n\t\t\t\t\ta[t]=(u^(u&((1<<j)-1)))|(1<<j);\n\t\t\t\t\treturn ;\n\t\t\t\t  }\n}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t  }\n\tdfs(1,0);\n\tfor(i=30;i>=0;i--)\n\t\tif((a[1]>>i)&1){\n\t\t\tprintf(\"%d\",i);\n\t\t\treturn 0;\n\t\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Gene template< class\n#define Rics printer& operator,\nGene c> struct rge{c b, e;};\nGene c> rge<c> range(c i, c j){ return {i, j};}\nstruct printer{\n    ~printer(){cerr<<endl;}\n    Gene c >Rics(c x){ cerr<<boolalpha<<x; return *this;}\n    Rics(string x){cerr<<x;return *this;}\n    Gene c, class d >Rics(pair<c, d> x){ return *this,\"(\",x.first,\", \",x.second,\")\";}\n    Gene ... d, Gene ...> class c >Rics(c<d...> x){ return *this, range(begin(x), end(x));}\n    Gene c >Rics(rge<c> x){\n        *this,\"[\"; for(auto it = x.b; it != x.e; ++it)\n            *this,(it==x.b?\"\":\", \"),*it; return *this,\"]\";}\n};\n#define debug() cerr<<\"LINE \"<<__LINE__<<\" >> \", printer()\n#define dbg(x) \"[\",#x,\": \",(x),\"] \"\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint my_rand(int l, int r) {\n    return uniform_int_distribution<int>(l, r) (rng);\n}\n\n\nconst int N = 1e5+100, lim = 22;\n\nvector<int> g[N];\nint dp[N];\n\nvoid dfs(int u, int p) {\n    vector<int> cnt(lim);\n    for(int v : g[u]) {\n        if(v == p) continue;\n        dfs(v, u);\n        int x = dp[v];\n        for(int k = 0; k < lim; k++) {\n            if((x >> k) & 1) cnt[k]++;\n        }\n    }\n    int t = 0;\n    int mask = 0;\n    for(int k = lim-1; k >= 0; k--) {\n        if(cnt[k] >= 2) {\n            t = k+1;\n            break;\n        }\n    }\n    for(int k = t; k < lim; k++) {\n        if(cnt[k] == 0) {\n            mask |= (1<<k);\n            for(int kk = k+1; kk < lim; kk++) {\n                if(cnt[kk]) {\n                    mask |= (1<<kk);\n                }\n            }\n            break;\n        }\n    }\n    dp[u] = mask;\n}\n\n\nint main() {\n//    freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(1, -1);\n//\n//    for(int i = 1; i <= n; i++){\n//        cout << i << \" -> \" << dp[i] << endl;\n//    }\n//\n\n    int mask = dp[1];\n    int msb = -1;\n    for(int k = 0; k < lim; k++) {\n        if((mask >> k) & 1) {\n            msb = k;\n        }\n    }\n    cout << msb << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\nconst int oo=(1<<30)-1;\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\nint las[N],vis[N],fa[N],pre[N],suf[N],A[N],chk[N],len[N];\nint n,cnt,mx,w,ans;\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid dfs(int x,int d){\n\tif (d>mx) mx=d,w=x;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]&&y!=fa[x]){\n\t\t\tfa[y]=x;\n\t\t\tdfs(y,d+1);\n\t\t}\n}\nint calc(int x,int fa){\n\tint res=0;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]&&!chk[y]&&y!=fa){\n\t\t\tres=max(res,calc(y,x)+1);\n\t\t}\n\treturn res;\n}\nvoid solve(int x,int dep){\n\tans=max(ans,dep);\n\tmx=-1;fa[x]=0;\n\tdfs(x,0);\n\tint u=w;\n\tmx=-1;fa[w]=0;\n\tdfs(w,0);\n\t*A=0;\n\tfor (int i=w;i!=u;i=fa[i]) A[++*A]=i;\n\tA[++*A]=u;\n\tFor(i,1,*A+1) chk[A[i]]=1;\n\tFor(i,1,*A+1) len[i]=calc(A[i],-1);\n\tint tmp=0;\n\tpre[0]=suf[*A+1]=0;\n\tfor (int i=1;i<=*A;i++){\n\t\tpre[i]=max(pre[i-1],len[i]+1+tmp);\n\t\ttmp=max(tmp+1,len[i]+1);\n\t}\n\ttmp=0;\n\tfor (int i=*A;i>=1;i--){\n\t\tsuf[i]=max(suf[i+1],len[i]+1+tmp);\n\t\ttmp=max(tmp+1,len[i]+1);\n\t}\n\tint mn=oo;\n\tFor(i,1,*A+1){\n\t\ttmp=max(max(pre[i-1],suf[i+1]),len[i]);\n\t\tif (tmp<mn) mn=tmp,x=A[i];\n\t\tchk[A[i]]=0;\n\t}\n\tvis[x]=1;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]){\n\t\t\tsolve(y,dep+1);\n\t\t}\n}\n\nint main(){\n\t//freopen(\"01.txt\",\"r\",stdin);\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n) Link(IN(),IN());\n\tsolve(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 50000000;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q--) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t\t\n\t\tif (clock() > 1960)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ANS - rand() % 2 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//¹Ø¼üÐÔÖÊ£ºÁ½¸öÉî¶ÈÏàÍ¬µÄµãµÄÂ·¾¶ÉÏ±ØÓÐÒ»¸öÉî¶È¸üÐ¡µÄµã \n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN=1e5+5;\n\nint N,Ans;\nint Cnt[MaxN][20];\n\nvector<int> To[MaxN];\n\nvoid DFS(int u,int fa){\n\tint i,k;\n\tfor(auto v:To[u])\n\t\tif(v^fa){\n\t\t\tDFS(v,u);\n\t\t\tfor(i=0;i<20;i++)\n\t\t\t\tCnt[u][i]+=Cnt[v][i];\n\t\t}\n\tfor(i=19;~i;i--)\n\t\tif(Cnt[u][i]>1){\n\t\t\tk=i+1;\n\t\t\tbreak;\n\t\t}\n\tfor(;Cnt[u][k];k++);\n\tAns=max(Ans,k);\n\tfor(i=0;i<k;i++)\n\t\tCnt[u][i]=0;\n\tCnt[u][k]++;\n}\n\nint main(){\n\tint i,u,v;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tTo[u].push_back(v);\n\t\tTo[v].push_back(u);\n\t}\n\tDFS(1,0);\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n;\nvector<vector<ll>> v(111111);\nll mp[111111];\n\nll dfs(ll s,ll pre){\n\tll ret = 0;\n\tvector<ll> tmp;\n\tREP(i,v[s].size()){\n\t\tif(v[s][i] != pre){\n\t\t\ttmp.PB(dfs(v[s][i],s));\n\t\t\tret |= tmp[tmp.size()-1];\n\t\t}\n\t}\n\t\n\tif(tmp.size() == 0){\n\t\treturn mp[s] = 1;\n\t}\n\tll cou = 60;\n\tfor(;cou > 0;cou--){\n\t\tint flag = 0;\n\t\tREP(i,tmp.size()){\n\t\t\tif(!(tmp[i] & (1LL << cou)))flag++;\n\t\t}\n\t\tif(flag > 1)break;\n\t}\n\t\n\tfor(;;cou++){\n\t\tif(!(ret & (1LL <<cou))){\n\t\t\tret |= (1LL << cou);\n\t\t\tret &= ((1LL << 60)-1) - ((1LL << cou) - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mp[s] = ret;\n}\n\nint main(){\n\t\n\tcin >> n;\n\tREP(i,n-1){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv[a].PB(b);\n\t\tv[b].PB(a);\n\t}\n\t\t\n\tll ans = dfs(0,-1);\n\tfor(ll i = 60;i >= 0;i--){\n\t\tif(ans & (1LL << i)){\n\t\t\tcout << i << endl;\n\t\t\t//return 0;\n\t\t\tbreak;\n\t\t}\n\t}\t\n\t\n\t/*\n\tREP(i,n){\n\t\tREP(j,10){\n\t\t\tcout << ((mp[i] & (1LL << j)) > 0) << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"vector\"\n#include \"string\"\n#include \"map\"\n#include \"algorithm\"\n#include \"functional\"\n#include \"set\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007; \n\nlong long int N, M, K, H, W, L, R;\n\nvoid Calculate_Depth(vector<vector<int>>&edge, vector<int>&depth, int stnode) {\n\tdepth[stnode] = 0;\n\tqueue<int>Q;\n\tQ.push(stnode);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front();\n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (depth[i] > depth[cn] + 1) {\n\t\t\t\tdepth[i] = depth[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid Search(vector<vector<int>>&edge, vector<int>&num, vector<long long int>&dp, vector<int>&depth, int node = 0) {\n\tvector<int>fig(50);\n\tlong long int bag = 0;\n\tfor (auto i : edge[node]) {\n\t\tif (depth[i] < depth[node])continue;\n\t\tif (num[i] == -1)Search(edge, num, dp, depth, i);\n\t\tfor (int j = 0; j < 50; j++) {\n\t\t\tfig[j] += (dp[i] >> j) & 1;\n\t\t\tbag |= dp[i];\n\t\t}\n\t}\n\tint nx = -1;\n\tfor (int i = 0; i < 50; i++) {\n\t\tif (!fig[i]) {\n\t\t\tif (nx == -1)nx = i;\n\t\t}\n\t\tif (fig[i] >= 2)nx = -1;\n\t}\n\tnum[node] = nx;\n\tdp[node] = ((bag >> nx) | 1) << nx;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--;\n\t\tR--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tvector<int>num(N, -1);\n\tvector<long long int>dp(N, -1);\n\tvector<int>depth(N, MOD);\n\tCalculate_Depth(edge, depth, 0);\n\tSearch(edge, num, dp, depth);\n\tint ans = 0;\n\tfor (auto i : num)ans = max(ans, i);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100010;\nint n, ans, mask[maxn];\nvector<int> G[maxn];\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1, u, v; i < n; i++) {\n        scanf(\"%d %d\", &u, &v);\n        G[u].push_back(v), G[v].push_back(u);\n    }\n    function<void(int, int)> dfs = [&](int v, int fa) {\n        vector<int> cnt(20);\n        for (int u : G[v]) if (u ^ fa) {\n            dfs(u, v), mask[v] |= mask[u];\n            for (int i = 0; i < 20; i++) {\n                if (mask[u] >> i & 1) cnt[i]++;\n            }\n        }\n        int cur = 0;\n        for (int i = 19; ~i; i--) {\n            if (cnt[i] > 1) { cur = i + 1; break; }\n        }\n        while (mask[v] >> cur & 1) cur++;\n        mask[v] |= (1 << cur), ans = max(ans, cur);\n        mask[v] = mask[v] >> cur << cur;\n    };\n    dfs(1, 0), printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvector<int> edge[216000];\nInt cnt[216000][20];\nInt val[216000];\nInt n, u, v;\nvoid solve(Int x, Int last = -1){\n  for(Int to:edge[x]){\n    if(to == last)continue;\n    solve(to, x);\n    for(Int i = 0;i < 20;i++){\n      cnt[x][i] += cnt[to][i];\n    }\n  }\n  val[x] = 19;\n  while(val[x] > 0 && cnt[x][val[x]] <= 1)val[x]--;\n  while(cnt[x][val[x]] > 0)val[x]++;\n  for(int i = 0;i < 20;i++){\n    cnt[x][i] = !!cnt[x][i];\n    if(i < val[x])cnt[x][i] = 0;\n  }\n  cnt[x][val[x]] = 1;\n}\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n-1;i++){\n    cin >> u >> v;u--,v--;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\t\t   \n  }\n  solve(0);\n  cout << *max_element(val, val + n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=1e5+5;\nint n,ans,BB[N],B[N<<1][2],B0,f[N],bit[N];\nvoid link(int u,int v){B[++B0][1]=v,B[B0][0]=BB[u],BB[u]=B0;}\nvoid dfs(int v,int fr=1)\n{\n\tefo(i,v,u) if(u!=fr)\n\t{\n\t\tdfs(u,v);\n\t\tfo(j,0,20)\n\t\t\tif((bit[v]&bit[u])&(1<<j)) f[v]=max(f[v],j+1);\n\t\tbit[v]|=bit[u];\n\t}\n\twhile(bit[v]&(1<<f[v])) f[v]++;\n\tbit[v]|=(1<<f[v]);\n\tfo(j,0,f[v]-1)\n\t\tif(bit[v]&(1<<j)) bit[v]^=(1<<j);\n\tans=max(ans,f[v]);\n}\nint main()\n{\n\tint x,y;\n\tn=read();\n\tfo(i,1,n-1) x=read(),y=read(),link(x,y),link(y,x);\n\tdfs(1);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nnamespace nmy\n{\n\ttemplate<typename T>inline void check_max(T a,T &b){if(a>b)b=a;}\n\ttemplate<typename T>inline void check_min(T a,T &b){if(a<b)b=a;}\n\tconst int N=101000,M=N*2,K=20;\n\tint begin[N],next[M],to[M];\n\tint kjd[N],hdd[N];\n\tint n,e,ans;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1,u,v;i<n;i++)\n\t\t\tscanf(\"%d%d\",&u,&v),add(u,v);\n\t}\n\tvoid dfs(int p=1,int h=0)\n\t{\n\t\tint cnt[K+1];\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif((q=to[i])!=h)\n\t\t\t{\n\t\t\t\tdfs(q,p);\n\t\t\t\tfor(int k=0;k<=K;k++)\n\t\t\t\t\tif(kjd[q]&(1<<k))cnt[k]++;\n\n\t\t\t\tfor(int k=hdd[q];k<=K;k++)\n\t\t\t\t\tkjd[p]|=kjd[q]&(1<<k);\n\t\t\t}\n\n\t\thdd[p]=K;\n\t\tfor(int k=K;k>=0 && cnt[k]<=1;k--)\n\t\t\tif(!cnt[k])check_min(k,hdd[p]);\n\t\tkjd[p]|=1<<hdd[p];\n\n\t\tfor(int k=0;k<hdd[p];k++)kjd[p]^=kjd[p]&(1<<k);\n\n//\t\tprintf(\"f[%d] = %d\\n\",p,hdd[p]);\n\n\t\tcheck_max(hdd[p],ans);\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tans=0,dfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\nint main()\n{\n\tnmy::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nenum {\n  MAXN = 100000 + 5\n};\n\ntypedef std::vector<int> vi;\n\nint n;\nvi e[MAXN];\nint deep[MAXN];\n\nint dfs(int u, int pa) {\n  int res(u), t;\n  if (!~pa) deep[u] = 0;\n  for (int v: e[u]) {\n    if (v != pa) {\n      deep[v] = deep[u]+1;\n      t = dfs(v, u);\n      if (deep[t] > deep[res])\n\tres = t;\n    }\n  }\n  return res;\n}\n\nint calc(int x) {\n  if (x == 1) return 1;\n  return calc(x/2) + 1;\n}\n\nvoid exec() {\n  int i, u, v, dis;\n  scanf(\"%d\", &n);\n  for (i=0; i<n-1; ++i) {\n    scanf(\"%d%d\", &u, &v), --u, --v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  v = dfs(u = dfs(0, -1), -1);\n  dis = deep[v];\n  printf(\"%d\\n\", calc(dis+1)-1);\n}\n\nint main() {\n  if (fopen(\"D.in\", \"r\") != NULL) {\n    freopen(\"D.in\", \"r\", stdin);\n    freopen(\"D.out\", \"w\", stdout);\n  }\n  exec();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e5+50,P=1e9+7,K=22;\n\nint n,ans;\nvector<int> g[N]; \n\nstruct Number { \n\tint a[K]; \n\tNumber(){ mem(a,0); }\n} lab[N];\n\nNumber operator+(const Number &x,const Number &y){\n\tNumber c; \n\tlop(i,0,K)c.a[i]=x.a[i]+y.a[i]; \n\treturn c;\n}\n\nvoid dfs(int v,int p){\n\tNumber &t=lab[v];\n\tfor(int d:g[v])if(d!=p){\n\t\tdfs(d,v); \n\t\tt=t+lab[d];\n\t}\n\tp=0; \n\tlop(i,0,K)if(t.a[i]>1)p=i+1;\n\tlop(i,p,K)if(t.a[i]==0){\n\t\tt.a[i]=1;\n\t\tlop(j,0,i)t.a[j]=0; \n\t\tcmax(ans,i); \n\t\tbreak;\n\t}\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"dat.in\",\"r\",stdin);\n\t//freopen(\"my.out\",\"w\",stdout);\n#endif\n\tread(n); \n\trep(i,1,n-1){\n\t\tint u,v;\n\t\tread(u),read(v); \n\t\tg[u].pb(v); \n\t\tg[v].pb(u); \n\t}\n\tdfs(1,0); \n\tprintf(\"%d\\n\",ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int N = 1e5 + 10;\n\nVI edge[N];\n\nint n, bit[N], f[N];\n\nvoid dfs(int u, int fa)\n{\n\tint l = 0;\n\tfor (auto v : edge[u])\n\t{\n\t\tif (v == fa) continue;\n\t\tdfs(v, u);\n\t\tl |= bit[u] & bit[v];\n\t\tbit[u] |= bit[v];\n\t}\n\tif (!bit[u]) bit[u] = 1;\n\telse\n\t{\n\t\twhile ((1 << f[u]) < l || ((1 << f[u]) & bit[u])) ++f[u];\n\t\tbit[u] = ((bit[u] >> f[u]) << f[u]) | (1 << f[u]);\n\t}\n\tf[0] = max(f[0], f[u]);\n}\n\nint main()\n{\n\tgi(n);\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tgii(u, v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<cmath>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<ctype.h>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<math.h>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<stdio.h>\n#include<stdlib.h>\n#include<streambuf>\n#include<string.h>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\nusing namespace std;\nvector<int> adj[100010];\nint dist[100010];\nint mxid;\nvoid dfs(int fa,int i){\n\tfor (int j=adj[i].size()-1;~j;j--){\n\t\tif (adj[i][j]!=fa){\n\t\t\tdist[adj[i][j]]=dist[i]+1;\n\t\t\tif (dist[i]+1>dist[mxid]) mxid=adj[i][j];\n\t\t\tdfs(i,adj[i][j]);\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tdfs(-1,1);\n\tmemset(dist,0,sizeof(dist));\n\tdfs(-1,mxid);\n\tprintf(\"%d\",dist[mxid]>>1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 1e5 + 5;\nint n;\nint a , b;\nvector < int > v[N];\nint dfs(int node , int parent){\n\tint curor = 0;\n\tint two = 0;\n\tfor(int next : v[node]){\n\t\tif(next == parent){\n\t\t\tcontinue;\n\t\t}\n\t\tint tmp = dfs(next , node);\n\t\ttwo |= tmp & curor;\n\t\tcuror |= tmp;\n\t}\n\ttwo |= two >> 8;\n\ttwo |= two >> 4;\n\ttwo |= two >> 2;\n\ttwo |= two >> 1;\n\tint allowed = (~two) & (~curor);\n\tint me = allowed & -allowed;\n\treturn (curor | me) & (~(me - 1));\n}\nint main(){\n\tscanf(\"%d\" , &n);\n\tfor(int i = 1 ; i < n ; ++i){\n\t\tscanf(\"%d %d\" , &a , &b);\n\t\tv[a].emplace_back(b);\n\t\tv[b].emplace_back(a);\n\t}\n\tint ans = dfs(1 , 0);\n\tfor(int i = 16 ; ; --i){\n\t\tif((ans >> i) & 1){\n\t\t\tprintf(\"%d\\n\" , i);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 100000;\nvector<int> G[maxn + 1];\nint dp[maxn + 1];\nint add(int u, int v){\n    int res = 0;\n    for(int k = 19; ~k; k -= 1){\n        if(((u >> k) & 1) and ((v >> k) & 1)) return res + (1 << (k + 1));\n        if(((u >> k) & 1) or ((v >> k) & 1)) res += 1 << k;\n    }\n    return res + 1;\n}\nvoid DFS(int u, int par = 0){\n    vector<int> w;\n    for(int v : G[u]) if(v != par){\n        DFS(v, u);\n        w.push_back(dp[v]);       \n    }\n    if(w.empty()) dp[u] = 1;\n    else if(w.size() == 1u) dp[u] = w[0] + 1;\n    else{\n        sort(w.begin(), w.end(), greater<int>());\n        dp[u] = add(w[0], w[1]);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int N;\n    cin >> N;\n    for(int i = 1, a, b; i < N; i += 1){\n        cin >> a >> b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    DFS(1);\n    cout << 31 - __builtin_clz(dp[1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n);\n    rep(i,0,n-1){\n        int a,b;\n        cin >> a >> b;\n        --a;\n        --b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }                                                                                                                                                                                                                        \n\n    function<int(int,int)> rec=[&](int u,int p){\n        int count[32]={},mask=0;\n        for(int v:graph[u]){\n            if(v==p) continue;\n            int tmp=rec(v,u);\n            mask|=tmp;\n            rep(i,0,32) if((tmp>>i)&1) ++count[i];\n        }\n        int low=0;\n        for(int i=31; i>=0; --i) if(count[i]>=2) low=i+1;\n        rep(i,low,32) if(!count[i]) return ((mask>>(i+1))<<(i+1))|(1<<i);\n    };\n\n    int tmp=rec(0,-1);\n    for(int i=31; i>=0; --i) if((tmp>>i)&1){\n        cout << i << endl;\n        return;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define foreach( gg,ii ) for( typeof(gg.begin()) ii=gg.begin();ii!=gg.end();ii++)\n#define mp make_pair\n#define pb push_back\n#define X first\n#define Y second\n#define sz(a) int((a).size())\n#define N 1000010\n#define MAX 30\n#define mod 1000000007\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define all(a) a.begin(),a.end()\nconst ll INF = 1e18+1;\n\nint a=-1,maxv=0;\nint vis[N];\nvector <int> G[N];\n\nint dfs(int v){\n\tvis[v]=1;\n\tint w,ans=0;\n\tREP(i,sz(G[v])){\n\t\tw=G[v][i];\n\t\tif (!vis[w]) ans=max(ans,1+dfs(w));\n\t}\n\tmaxv=max(ans,maxv);\n\tif (maxv==ans) a=v;\n\treturn ans;\n}\n\nint main()\n{\n\tll n,x,y;\n\tscanf(\"%lld\",&n);\n\tREP(i,n-1){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tdfs(0);\n\tFILL(vis,0);\n\tx=dfs(a);\n\t//printf(\"%d\\n\",x);\n\ty=0;\n\twhile((1<<(y+1))-2<x) y++;\n\tprintf(\"%lld\\n\",y);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  Int first=1;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(first){\n      first=0;\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]&&belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<assert.h>\n#include<tuple>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<ctype.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef tuple<int,int,int> t3;\n\nconst int MX = 1 << 18;\nconst int MM = 1000000007;\n\nint val[50005];\nint bit[30]={0,1};\nint ans,st=1;\nbool check[50005];\nstd::vector<int> way[50005];\n\nvoid input()\n{\n\tint n,a,b;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tway[a].push_back(b);\n\t\tway[b].push_back(a);\n\t}\n\tfor(st=1;st<=n;st++)if(way[st].size()==1)break;\n\tfor(int i=2;i<30;i++)bit[i]=bit[i-1]*2;\n}\n\nvoid fill(int x)\n{\n\tint j;\n\tcheck[x]=true;\n\tfor(int i=0;i<way[x].size();i++){\n\t\tif(check[way[x][i]])continue;\n\t\tfill(way[x][i]);\n\t\tfor(j=25;j>=1;j--){\n\t\t\tif((val[x]&val[way[x][i]]&bit[j]) != 0){\n\t\t\t\tval[x]|=bit[j]-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tval[x]|=val[way[x][i]];\n\t}\n\tval[x]++;\n\tint tmp=29;\n\twhile((bit[tmp]&val[x]) == 0)tmp--;\n\tans=std::max(ans,tmp);\n}\n\nint main()\n{\n\t//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinput();\n\tfill(st);\n\tprintf(\"%d\",ans-1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nset<int> dp[MAX];\nint over[MAX];\n\n\ninline void dfs(int b,int pr=-1){\n\tover[b] = -1;\n\tdp[b].clear();\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] == pr)continue;\n\t\tdfs(v[b][i],b);\n\t\tif (dp[b].size() < dp[v[b][i]].size()){\n\t\t\tswap(dp[b], dp[v[b][i]]);\n\t\t}\n\t\tfor (int i2 : dp[v[b][i]]){\n\t\t\tif (dp[b].count(i2)){\n\t\t\t\tover[b] = max(over[b], i2);\n\t\t\t}\n\t\t\tdp[b].insert(i2);\n\t\t}\n\t\tdp[v[b][i]].clear();\n\t}\n\tauto it = dp[b].begin();\n\tint ex = 0;\n\twhile (it != dp[b].end()){\n\t\tif (ex == (*it)){\n\t\t\tit = dp[b].erase(it);\n\t\t\tex++;\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tif ((*it) <= over[b]){\n\t\t\t\tit = dp[b].erase(it);\n\t\t\t\tex = over[b]+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[b].insert(ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tdp[b].insert(ex);\n}\n\nint main(){\n\tcin >> n;\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0);\n\tauto r = (*dp[0].rbegin());\n\tcout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, lg = 17;\npair<int, int> mx;\nint dp[lg + 2], n, sd;\nvector<int> gr[N];\nvoid dfs(int v, int par, int dis) {\n\tmx = max(mx, {dis, v});\n\tfor (auto u : gr[v]) \n\t\tif (u != par)\n\t\t\tdfs(u, v, dis + 1);\n}\nint main() {\n\tdp[0] = 0;\n\tfor (int i = 1; i < lg; i++)\n\t\tdp[i] = dp[i - 1] * 2 + 2;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\tgr[x].push_back(y), gr[y].push_back(x);\n\t}\n\tdfs(0, -1, 0);\n\tdfs(mx.second, -1, 0);\n\tfor (int i = 0; i < lg; i++) {\n\t\tif (mx.first <= dp[i]) {\n\t\t\tcout << i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n \nconst int N = 1e5 + 7;\n \nvector <int> ad[N];\nint gone[N], n, mrk[N],\tsz[N];\n\nvoid dfs(int v, int p = 0) {\n\tsz[v] = 1;\n\tmrk[v] = 1;\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tdfs(u, v);\n\t\t\tsz[v] += sz[u];\n\t\t}\n\t}\n}\npair <int, int> get(int v, int p, int sall) {\n\tpair <int, int> res;\n\tres.first = v;\n\tres.second = sall - sz[v];\n\tfor (auto u: ad[v])\n\t   \tif (!gone[u] && u != p)\t\n\t\t\tres.second = max(res.second, sz[u]);\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tpair <int, int> t = get(u, v, sall);\n\t\t\tif (t.second < res.second)\n\t\t\t\tres = t;\n\t\t}\n\t}\n\treturn res;\n}\npair <int, int> ffs(int v, int p) {\n\tpair <int, int> mx = {v, 1};\n\tfor (auto u: ad[v])\n\t\tif (u != p) {\n\t\t\tauto t = ffs(u, v);\n\t\t\tt.second++;\n\t\t\tif (t.second > mx.second)\n\t\t\t\tmx = t;\n\t\t}\n\treturn mx;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tad[v].push_back(u);\n\t\tad[u].push_back(v);\n\t}\n\tint res = 0;\n\twhile (1) {\n\t\tbool was = 0;\n\t\tmemset(sz, 0, sizeof sz);\n\t\tmemset(mrk, 0, sizeof mrk);\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tif (!gone[i] && !mrk[i]) {\n\t\t\t\twas = 1;\n\t\t\t\tdfs(i);\n\t\t\t\tint v = get(i, 0, sz[i]).first;\n\t\t\t\tgone[v] = 1;\n\t\t\t}\n\t\tif (!was)\n\t\t\tbreak;\n\t\tres++;\n\t}\n\tint v = ffs(1, 0).first;\n\tint d = ffs(v, 0).second;\n\tint r2 = ((int)log2(d));\n\tif (res - r2 > 2) {\n\t\tcout << 1 / 0;\n\t}\n\tcout << (r2 + res - 1) / 2;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=200010;\nint N;\nstruct edge{int to;edge*next;}E[MaxN*2],*ne,*fir[MaxN];\nvoid link(int u,int v){*ne=(edge){v,fir[u]};fir[u]=ne++;}\nchar mx1[MaxN],mn0[MaxN];\nint dfs(int i,int f=0){\n\tint a=0,b=0;\n\tfor(edge*e=fir[i];e;e=e->next)if(e->to!=f){\n\t\tint x=dfs(e->to,i);\n\t\tb|=a&x;a|=x;\n\t}\n\tb=mx1[b];a>>=b;\n\treturn(a>>mn0[a]|1)<<mn0[a]+b;\n}\nint main(){\n\twhile(scanf(\"%d\",&N)==1){\n\t\tne=E;\n\t\tfor(int i=1;i<=N;i++)fir[i]=0;\n\t\tfor(int i=1,u,v;i<N;i++)scanf(\"%d%d\",&u,&v),link(u,v),link(v,u);\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tmx1[i]=mx1[i/2]+1;\n\t\t\tmn0[i]=i%2?mn0[i/2]+1:0;\n\t\t}\n\t\tint ans=mx1[dfs(1)]-1;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\npair<int,int> dfs(int v,int pre,Graph& g){\n    pair<int,int> res={0,v};\n    for(auto to:g[v]){\n        if(to==pre) continue;\n        auto ret=dfs(to,v,g);\n        ret.first++;\n        res=max(res,ret);\n    }\n    return res;\n}\n\nint diameter(Graph& g){\n    auto p=dfs(0,-1,g);\n    return dfs(p.second,-1,g).first;\n}\nint main(){\n    int N;\n    cin>>N;\n    Graph g(N);\n    for(int i=0;i+1<N;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int d=diameter(g);\n    int sum=0;\n    for(int i=1;;i++){\n        sum=sum*2+2;\n        if(d<=sum){\n            cout<<i<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1000000010\n#define INFLL ((1LL<<62)-5)\n#define FO(i,a,b) for (int (i) = (a); (i) < (b); ++(i))\n#define OF(i,a,b) for (int (i) = (a)-1; (i) >= (b); --(i))\n#define SZ(v) int(v.size())\n#define pb push_back\n\nusing namespace std;\n//PAIRS:\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n/*~~~~TEMPLATE END~~~~*/\n\nconst int MAXN = 100005;\nint N;\nvector<int> allE[MAXN];\nint par[MAXN];\n\nvector<int> dfs (int c) {\n    int cnt[20];\n    fill(cnt, cnt+20, 0);\n    for (int nxt : allE[c]) {\n        if (nxt == par[c]) continue;\n        par[nxt] = c;\n        auto chV = dfs(nxt);\n        for (int v : chV) {\n            cnt[v]++;\n        }\n    }\n    int endSpot = 0;\n    for (int c = 19; c >= 0; c--) {\n        if (c == 0 || cnt[c] > 1) {\n            endSpot = c;\n            while (cnt[endSpot]) endSpot++;\n            break;\n        }\n    }\n    cnt[endSpot] = 1;\n    vector<int> ret;\n    for (int c = 19; c >= endSpot; c--) {\n        if (cnt[c]) ret.push_back(c);\n    }\n    return ret;\n}\n\n\nint main() {\n    scanf (\"%d\", &N);\n    FO (i,0,N-1) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        allE[a].pb(b);\n        allE[b].pb(a);\n    }\n    auto v = dfs(1);\n    printf (\"%d\\n\", v[0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<19)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\t// while((f[u]>>mn&1) || ((1<<mn)<=mx))++mn;\n\twhile(f[u]>>mn&1)++mn;\n\t// f[u]=(f[u]>>mn<<mn)|(1<<mn);\n\t// ans=max(ans,mn);\n\tfor(int i=25;;--i)\n\t\tif(i<mn || (mx>>i&1))\n\t\t{\n\t\t\t++i;\n\t\t\t// f[u]&=S-((1<<i)-1);\n\t\t\t// f[u]|=1<<i;\n\t\t\tf[u]=(f[u]>>i<<i)|(1<<i);\n\t\t\tans=max(ans,i);\n\t\t\t// cerr<<u<<\" \"<<i<<endl;\n\t\t\tbreak;\n\t\t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n4 8\n8 9\n9 10\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint last_vert, cd[MAXN];\nvector <int> vis;\nset <int> G[MAXN];\nvoid dfs2(int pos, int par)\n{\n\tlast_vert = pos;\n\tvis.push_back(pos);\n\tfor (int v: G[pos])\n\t{\n\t\tif(v != par)\n\t\t{\n\t\t\tcd[v] = 1 + cd[pos];\n\t\t\tdfs2(v,pos);\n\t\t}\n\t}\n}\nint dfs1(int pos)\n{\n\tcd[pos] = 0;\n\tvis.clear();\n\tdfs2(pos,-1);\n\tcd[last_vert] = 0;\n\tvis.clear();\n\tdfs2(last_vert,-1);\n\tvector <int> dia;\n\tfor (int i = 0; i < vis.size(); ++i)\n\t{\n\t\tif(cd[vis[i]] == (cd[last_vert]/2) || cd[vis[i]] == (cd[last_vert] + 1)/2)\n\t\t\tdia.push_back(vis[i]);\n\t}\n\tif(dia.size() == 2)\n\t{\n\t\tint u = dia[0], v = dia[1];\n\t\tG[u].erase(v);\n\t\tG[v].erase(u);\n\t\t// cout<<\"break \"<<u<<\" \"<<v<<\"\\n\";\n\t\treturn (max(dfs1(u),dfs1(v)) + 1);\n\t}\n\telse\n\t{\n\t\tint u = dia[0], ans = 0;\n\t\t// cout<<\"remove \"<<u<<\"\\n\";\n\t\tfor (set <int>::iterator it = G[u].begin(); it != G[u].end(); ++it)\n\t\t{\n\t\t\tG[*it].erase(u);\n\t\t\tans = max(ans, 1 + dfs1(*it));\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tG[u].insert(v);\n\t\tG[v].insert(u);\n\t}\n\tcout<<dfs1(1)<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 2e5 + 7;\nconst int LOG = 25;\n\nint n;\nvector<int> adj[N];\nint ans;\n\nint dfs(int u, int from) {\n\tint all = 0, least = 0;\n\tfor (int v : adj[u]) {\n\t\tif (v == from) continue;\n\t\tint mask = dfs(v, u);\n\t\tfor (int j = 0; j < LOG; j++) {\n\t\t\tif ((all >> j & 1) && (mask >> j & 1)) {\n\t\t\t\tleast = j + 1;\n\t\t\t}\n\t\t}\n\t\tall |= mask;\n\t}\n\tfor (int i = least; ; i++) {\n\t\tif (~all >> i & 1) {\n\t\t\tans = max(ans, i);\n\t\t\tall ^= (1 << i);\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (all >> j & 1) {\n\t\t\t\t\tall ^= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn all;\n\t\t}\n\t}\n}\n\nint solve() {\n\tans = 0;\n\tdfs(rand() % n + 1, 0);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tint ret = n;\n\tfor (int r = 1; r <= 5; r++) {\n\t\tret = min(ret, solve());\n\t}\n\tprintf(\"%d\\n\", ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\nint main()\n{\n#ifdef jcg\n\tassert(freopen(\"input.in\", \"r\", stdin));\n\t// assert(freopen(\"output.out\", \"w\", stdout));\n#endif\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> adj(n);\n\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[--u].push_back(--v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tfunction<int(int, int)> dfs = [&](int u, int p)\n\t{\n\t\tint used = 0, more = 0;\n\n\t\tfor (int v : adj[u]) if (v != p)\n\t\t{\n\t\t\tint mask = dfs(v, u);\n\t\t\tmore |= mask & used;\n\t\t\tused |= mask;\n\t\t}\n\n\t\tfor (int k : {1, 2, 4, 8, 16}) more |= more >> k; ++more;\n\n\t\tint possible = (~used) & (-more);\n\t\tused |= possible & -possible;\n\t\tused &= -(possible & -possible);\n\n\t\treturn used;\n\t};\n\n\tcout << __lg(dfs(0, 0)) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/stack:16777216\")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\n//const int MAX = 1000007;\n\nint n, a, b;\nvector<int> g[100000];\nbool used[100000];\nbool fix[100000];\nPII resw = MP(-1,-1);\nint qwe = -1;\nvector<int> R;\n\nvoid dfs(int v, int p = -1, int len = 0)\n{\n    //cout << v << \" \"<<len << endl;\n    R.PB(v);\n    if (len > resw.second)\n    {\n        resw = MP(v,len);\n        qwe = R[SZ(R)/2];\n    }\n    FOR (i,0,g[v].size())\n    if (!fix[g[v][i]] && g[v][i] != p)\n    {\n        dfs(g[v][i],v,len+1);\n    }\n    R.pop_back();\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"/Users/Taras/Downloads/big_top.txt\", \"r\", stdin);\n    //freopen(\"/Users/Taras/Downloads/mout.txt\", \"w\", stdout);\n    \n    cin >> n;\n    FOR (i,1,n)\n    {\n        cin >> a >> b;\n        //a = 1;\n        //b = i+1;\n        a--; b--;\n        g[a].PB(b);\n        g[b].PB(a);\n    }\n    vector<int> v, cv;\n    v.PB(0);\n    int res = 0;\n    while (v.size())\n    {\n        res++;\n        FOR (i,0,v.size())\n        {\n            //cout << v[i]<<endl;\n            \n            resw = MP(-1,-1);\n            dfs(v[i]);\n            int fr1 = resw.first;\n            //cout << fr1<<\"()\"<<endl;\n            resw = MP(-1,-1);\n            dfs(fr1);\n            //cout << resw.first<<endl;\n            //cout << qwe << endl;\n            fix[qwe] = true;\n            FOR (j,0,g[qwe].size())\n            if (!fix[g[qwe][j]])\n                cv.PB(g[qwe][j]);\n        }\n        //FOR (i,0,v.size()) fix[v[i]] = true;\n        //cout << \"-----\"<<endl;\n        v = cv;\n        cv.clear();\n    }\n    cout << res-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = inF, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tsrand(time(0));\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << max(0, solve(0) - rand() % 3);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = inF, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) <= mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tsrand(time(0));\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\n\nconst int N=100005;\n\nvector<int>e[N];\nint mask[N],ans,n,m,cnt[20];\n\nvoid dfs(int x,int fa){\n\tfor(int v:e[x])if(v!=fa)dfs(v,x);\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int v:e[x])if(v!=fa)for(int i=0;i<m;i++)cnt[i]+=mask[v]>>i&1;\n\tint p=-1,q=-1;\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(cnt[i]>1){p=i;break;}\n\t\tif(cnt[i]==0)q=i;\n\t}\n\tif(p==-1)p=q;\n\tmask[x]+=1<<p;\n\tfor(int i=p;i<m;i++)if(cnt[i])mask[x]+=1<<i;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tm=log(n)/log(2)+1;\n\tfor(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),e[u].pb(v),e[v].pb(u);\n\tdfs(1,0);\n\twhile((1<<ans)<mask[1])ans++;\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\nconst int oo=(1<<30)-1;\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\nint las[N],A[N];\nint n,cnt,ans;\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid dfs(int x,int fa){\n\tint tmp=0,val=0;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif ((y=E[i].y)!=fa){\n\t\t\tdfs(y,x);\n\t\t\ttmp|=A[x]&A[y];\n\t\t\tA[x]|=A[y];\n\t\t}\n\twhile ((1<<val)<=tmp||(A[x]>>val&1)) val++;\n\tans=max(ans,val);\n\tA[x]=(A[x]>>val<<val)|(1<<val);\n}\n\nint main(){\n\t//freopen(\"01.txt\",\"r\",stdin);\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n) Link(IN(),IN());\n\tdfs(1,-1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 10000;\n\nint n;\nvector<int> edg[MAXN];\nint f[MAXN], v[MAXN];\n\nvoid dfs(int x, int fa)\n{\n\tf[x] = 0, v[x] = 0;\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(edg[x][i] != fa)\n\t\t{\n\t\t\tint y = edg[x][i];\n\t\t\tdfs(y, x);\n\t\t\tf[x] |= f[y];\n\t\t}\n\twhile(f[x] & (1 << v[x]))\n\t\tf[x] ^= 1 << v[x], v[x]++;\n\tf[x] |= 1 << v[x];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tedg[x].push_back(y), edg[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tans = max(ans, v[i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb push_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int N = 100000;\nconst int oo = 0x3f3f3f3f;\n \ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nint n;\nint st[N + 5], nxt[(N << 1) + 5], to[(N << 1) + 5], e = 1;\n\nvoid addedge(int u, int v) {\n    to[++ e] = v; nxt[e] = st[u]; st[u] = e;\n    to[++ e] = u; nxt[e] = st[v]; st[v] = e;\n}\n\nint id[N + 5], ans;\nbool vis[N + 5][30];\n\nvoid dfs(int u, int f = 0) {\n    id[u] = 1;\n\n    for(int i = st[u]; i; i = nxt[i]) {\n        int v = to[i];\n        if(v == f) continue;\n\n        dfs(v, u);\n\n        for(int j = 1; j <= 25; ++j) if(vis[v][j]) {\n            if(vis[u][j]) \n                chkmax(id[u], j + 1);\n            else vis[u][j] = true;\n        }\n    }\n\n    while(vis[u][id[u]]) ++ id[u];\n    chkmax(ans, id[u]);\n\n    vis[u][id[u]] = true;\n    for(int i = 1; i < id[u]; ++i) vis[u][i] = false;\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif \n\n    scanf(\"%d\", &n);\n    for(int i = 1; i < n; ++i) {\n        static int u, v;\n        scanf(\"%d%d\", &u, &v); addedge(u, v);\n    }\n\n    dfs(1);\n    printf(\"%d\\n\", ans - 1);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*  ***  In The Name of God ... ***  */\n#include <bits/stdc++.h>\n\nusing namespace std ;\n \ntypedef long long ll ;\ntypedef long double ld ;\n\n\n#define int long long\n#define all(v) v.begin() , v.end()\n\ntemplate<typename T> inline bool smin(T &a, const T &b){ return b < a ? a = b,1:0;}\ntemplate<typename T> inline bool smax(T &a, const T &b){ return a < b ? a = b,1:0;}\n\nconst int N = ( int ) 1e5 + 10 ;\n\nint n , sz [ N ] , all = 0 ; \nvector < int > adj [ N ] ; \nbool mark [ N ] ;\n\nvoid dfs ( int v , int p = -1 ) {\n\tsz [ v ] = 1 ;\n\tfor ( int u : adj [ v ] ) {\n\t\tif ( u == p ) continue ;\n\t\tif ( !mark [ u ] ) {\n\t\t\tdfs ( u , v ) ;\n\t\t\tsz [ v ] += sz [ u ] ; \n\t\t}\n\t}\n}\n\nint get_centroid ( int v , int p = -1 ) {\n\tfor ( int u : adj [ v ] ) {\n\t\tif ( mark [ u ] ) continue ;\n\t\tif ( sz [ u ] >= all / 2 && u != p )\n\t\t\treturn get_centroid ( u , v ) ;  \n\t}\n\treturn v ; \n}\n\nint solve ( int v = 0 ) {\n\tdfs ( v ) ;\n\tall = sz [ v ] ; \n\tint c = get_centroid ( v ) ;\n\tmark [ c ] = true ;\n\tint ret = 0 ;\n\tfor ( int u : adj [ c ] ) {\n\t\tif ( !mark [ u ] ) {\n\t\t\tsmax ( ret , solve ( u ) + 1 ) ; \n\t\t}\n\t}\n\treturn ret ; \n}\n\nint32_t main()                     \n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n ;\n\tfor ( int j = 0 ; j < n - 1 ; ++ j ) {\n\t\tint u , v ;\n\t\tcin >> u >> v ;\n\t\t-- u , -- v ;\n\t\tadj [ u ] . push_back ( v ) ;\n\t\tadj [ v ] . push_back ( u ) ; \n\t}\n\tcout << solve ( ) << '\\n' ; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define ll long long\n#define MAX 100100\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next;}e[MAX<<1];\nint h[MAX],cnt=1;\ninline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}\nint f[MAX][20];\nint ans,n;\nvoid dfs(int u,int ff)\n{\n\tfor(int i=h[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;if(v==ff)continue;\n\t\tdfs(v,u);\n\t\tfor(int j=0;j<=18;++j)f[u][j]+=f[v][j];\n\t}\n\tint p=0;\n\tfor(int i=18;~i;--i)\n\t\tif(f[u][i]>1){p=i-1;break;}\n\twhile(f[u][p])++p;\n\t++f[u][p];\n\tfor(int i=0;i<p;++i)f[u][i]=0;\n\tans=max(ans,p);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u=read(),v=read();\n\t\tAdd(u,v);Add(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nvector<int> gr[114514];\nint dp[114514];\nint out=0;\nint dfs(int v,int u){\n\tvector<int> cal(36,0);\n\trep(i,gr[v].size()){\n\t\tint w=gr[v][i];\n\t\tif(u==w) continue;\n\t\tint t=dfs(w,v);\n\t\trep(j,30){\n\t\t\tif((t&(1<<j))) cal[j]++;\n\t\t}\n\t}\n\tint ma=-1,mi=36;\n\trep(i,30){\n\t\tif(cal[i]>1) ma=max(ma,i);\n\t}\n\tREP(j,ma+1,30){\n\t\tif(cal[j]<1) mi=min(mi,j);\n\t}\n\tout=max(out,mi);\n\tdp[v]=0;\n\trep(i,30){\n\t\tif(i==mi) dp[v]+=(1<<i);\n\t\telse if(i>mi && cal[i]>0) dp[v]+=(1<<i);\n\t}\n\t//cout<<v<<' '<<u<<' '<<dp[v]<<endl;\n\treturn dp[v];\n}\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a>>b;a--;b--;gr[a].pb(b);gr[b].pb(a);\n\t}\n\tdfs(0,-1);\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define ll long long\n#define MAX 100100\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next;}e[MAX<<1];\nint h[MAX],cnt=1;\ninline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;}\nint f[MAX][25];\nint ans,n;\nvoid dfs(int u,int ff)\n{\n\tfor(int i=h[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;if(v==ff)continue;\n\t\tdfs(v,u);\n\t\tfor(int j=0;j<=20;++j)f[u][j]+=f[v][j];\n\t}\n\tint p=0;\n\tfor(int i=20;~i;--i)\n\t\tif(f[u][i]>1){p=i-1;break;}\n\twhile(f[u][p])++p;++f[u][p];\n\tfor(int i=0;i<p;++i)f[u][i]=0;\n\tans=max(ans,p);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u=read(),v=read();\n\t\tAdd(u,v);Add(v,u);\n\t}\n\tdfs(1,0);printf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 50000000;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q--) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t\t\n\t\tif (clock() > 1960)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ANS - 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e+5+5;\n\nint n;\nstruct edge{\n\tint x,nxt;\n}e[N*2];\nint h[N],tot;\nint ans;\nint f[N];\n\nvoid inse(int x,int y){\n\te[++tot].x=y;\n\te[tot].nxt=h[x];\n\th[x]=tot;\n}\n\nbool bz[N];\n\nvoid dfs(int x){\n\tbz[x]=1;\n\tint pre=0,a=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (!bz[e[p].x]){\n\t\tdfs(e[p].x);\n\t\ta|=(f[e[p].x]&pre);\n\t\tpre|=f[e[p].x];\n\t}\n\tfo(i,0,17)\n\tif ((1<<i)>a&&(pre&(1<<i))==0){\n\t\tpre=pre^(pre&((1<<i)-1));\n\t\tpre^=1<<i;\n\t\tans=max(ans,i);\n\t\tbreak;\n\t}\n\tf[x]=pre;\n}\n\nint main(){\n\tn=get();\n\tfo(i,2,n){\n\t\tint x=get(),y=get();\n\t\tinse(x,y),inse(y,x);\n\t}\n\tdfs(1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N];\nll mask [MAX_N];\n\nvoid dfs (int u, int p) {\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      dfs(nxt, u);\n      mask[u] |= mask[nxt];\n    }\n  }\n  mask[u]++;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  dfs(1, 0);\n\n  cout << 63 - __builtin_clzll(mask[1]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 1e5 + 100, maxlg = 30;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n;\nvector<int> graph[maxn];\n\nint solve(int u, int prev = -1)\n{\n\tint cnt[maxlg] = {0}, res = 0;\n\tfor (int i : graph[u])\n\t\tif (i != prev)\n\t\t{\n\t\t\tint val = solve(i, u);\n\t\t\tfor (int j = 0; j < maxlg; j++)\n\t\t\t\tcnt[j] += ((val >> j) & 1);\n\t\t}\n\n\tint pos = -1;\n\tfor (int i = 0; i < maxlg; i++)\n\t\tif (cnt[i] > 1)\n\t\t\tpos = i;\n\n\tfor (int i = pos + 1; i < maxlg; i++)\n\t\tif (!cnt[i])\n\t\t{\n\t\t\tres += (1 << i);\n\t\t\tfor (int j = i; j < maxlg; j++)\n\t\t\t\tif (cnt[j])\n\t\t\t\t\tres += (1 << j);\n\t\t\tbreak;\n\t\t}\n\t\n\treturn res;\n}\n\nint highBit(int mask)\n{\n\tfor (int i = maxlg - 1; i >= 0; i--)\n\t\tif ((mask >> i) & 1)\n\t\t\treturn i;\n\treturn -1;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tgraph[--u].pb(--v);\n\t\tgraph[v].pb(u);\n\t}\n\n\tcout << highBit(solve(0)) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      //if(belong[i]<0) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint n;\nvector<int> g[100005];\nint lsb(int a){\n  return __builtin_ctz(a);\n}\nint dfs(int v,int p){\n  int mask=0,incr=-1;\n  for(auto to:g[v]){\n    if(to==p) continue;\n    int tmp=dfs(to,v);\n    if(tmp&mask) chmax(incr,lsb(tmp&mask));\n    mask|=tmp;\n  }\n  if(incr==-1) incr=0;\n  for(int i=incr;;++i) if(!(mask>>i&1)){\n    mask|=(1<<i);\n    mask&=~((1<<i)-1);\n    break;\n  }\n  return mask;\n}\n\n\nint main(){\n  cin>>n;\n  REP(i,n-1){\n    int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n  int res=dfs(0,-1);\n  int ans=0;\n  REP(i,30) if(res>>i&1) ans=i;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=100010;\nconst int inf=1e9;\nint n,k,val[maxn],first[maxn],nxt[maxn<<1],to[maxn<<1],e;\nvoid AddEdge(int u,int v) {\n\tto[++e]=v;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;nxt[e]=first[v];first[v]=e;\n}\nint f[maxn],siz[maxn],vis[maxn],size,root;\nvoid getroot(int x,int fa) {\n\tint maxs=0;siz[x]=1;\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa&&!vis[to[i]]) {\n\t\tgetroot(to[i],x);siz[x]+=siz[to[i]];\n\t\tmaxs=max(maxs,siz[to[i]]);\n\t}\n\tf[x]=max(maxs,size-siz[x]);\n\tif(f[root]>f[x]) root=x;\n}\nvoid dfs(int x,int fa) {\n\tsiz[x]=1;\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa&&!vis[to[i]]) dfs(to[i],x),siz[x]+=siz[to[i]];\n}\nint ans;\nvoid solve(int x,int dep) {\n\tans=max(ans,dep);vis[x]=1;\n\tfor(int i=first[x];i;i=nxt[i]) if(!vis[to[i]]) {\n\t\tdfs(to[i],x);\n\t\tf[0]=size=siz[to[i]];getroot(to[i],root=0);\n\t\tsolve(root,dep+1);\n\t}\n}\nint main() {\n\tn=read();\n\trep(i,2,n) AddEdge(read(),read());\n\tf[0]=size=n;getroot(1,root=0);\n\tsolve(root,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 100100;\n\nvector<int> g[MAX];\n\nint D[MAX];\nint mx;\n\nvoid go(int x, int p, int val, int diff)\n{\n\t//cout<<x<<' '<<val<<' '<<mx<<endl;\n\tif (val == -1)\n\t{\n\t\tmx++;\n\t\tD[x] = mx;\n\t\tdiff = 1;\n\t}\n\telse\n\t{\n\t\tif (val == mx - 1) diff = -1;\n\t\tD[x] = val;\n\t}\n\n\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (to == p) continue;\n\n\t\tgo(to, x, val + diff, diff);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n-1)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\t}\nmx = 0;\n\tgo(0, -1, 0, -1);\n\tint res = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tres = max(res, D[i]);\n\t//\tcout<<i+1<<' '<<D[i]<<endl;\n\t}\n\n\tcout<<res<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<cmath>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<ctype.h>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<math.h>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<stdio.h>\n#include<stdlib.h>\n#include<streambuf>\n#include<string.h>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\nusing namespace std;\nvector<int> adj[100010];\nint dist[100010];\nint mxid;\nvoid dfs(int fa,int i){\n\tfor (int j=adj[i].size()-1;~j;j--){\n\t\tif (adj[i][j]!=fa){\n\t\t\tdist[adj[i][j]]=dist[i]+1;\n\t\t\tif (dist[i]+1>dist[mxid]) mxid=adj[i][j];\n\t\t\tdfs(i,adj[i][j]);\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tdfs(-1,1);\n\tmemset(dist,0,sizeof(dist));\n\tdfs(-1,mxid);\n\tint i=1,j=2;\n\twhile(j<dist[mxid]){\n\t\ti++;\n\t\tj<<=1;\n\t\tj|=1;\n\t}\n\tprintf(\"%d\",i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      //if(cnt[v]==0) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      //assert(cnt[v]==1);\n      //assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n      //if(c<0) continue;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n\n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nint n,w[N],head[N],nxt[N];\nvoid add(int f,int t){\n\tstatic int cnt=0;\n\tw[++cnt]=t;\n\tnxt[cnt]=head[f];\n\thead[f]=cnt;\n}\n//问题等价于给点标号,若k(u)=k(v),则(u,v)路径上存在一点x使得k(x)>k(v) \n//贪心选择最小的标号 \nint S[N],ans;\nvoid dfs(int x,int fa){\n\tint K=0;\n\tfor (int i=head[x];i;i=nxt[i]){\n\t\tint v=w[i];\n\t\tif (v==fa) continue;\n\t\tdfs(v,x);\n\t\tfor (int i=0;i<20;i++)\n\t\tif ((S[x]&S[v])>>i&1) K=max(K,i+1);\n\t\tS[x]|=S[v];\n\t}\n\twhile (S[x]>>K&1) K++;\n\tans=max(ans,K);\n\tS[x]&=~((1<<K)-1);\n\tS[x]|=(1<<K);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);add(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n#define INT long long\n#define MOD 1000000007\nusing namespace std;\nINT n, d, unido[100010] = {0, 1, 1};\nvector<INT> g[100010];\nint solve(int x)\n{\n    int chk[100010] = {0};\n    int ret = x;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        ret = v;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return ret;\n}\nint f(int x, int y)\n{\n    int chk[100010] = {0};\n    int ret = 0;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        if( v == y ) return chk[v]-1;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n;\n    for(int i = 1 ; i < n ; i++ )\n    {\n        INT a, b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int v = solve(1);\n    int w = solve(v);\n    int d = f(v, w);\n    for(int i = 3 ; i <= d ; i++ )\n        unido[i] = unido[i/2] + 1;\n    cout<<unido[d]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 200055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,fa[N],ans;\nbitset <22> a[N],b[N];\nint nedge,Next[N*2],head[N],to[N*2];\n#define V to[i]\nvoid add(int a,int b){\n\tNext[++nedge]=head[a];head[a]=nedge;to[nedge]=b;\n}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tgo(i,x){\n\t\tif (fa[x]==V) continue;\n\t\tfa[V]=x;dfs(V);b[x]|=a[x]&a[V];a[x]|=a[V];\n\t}\n\tint num=0;\n\tF(i,0,20) if (b[x][num]) num=i+1;\n\tF(i,num,20) if (a[x][i]==0) {num=i;break;}\n\tif (a[x][num]==1) while(1);\n\ta[x][num]=1;\n\tans=max(ans,num);\n\tF(i,0,num-1) a[x].reset(i);\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n-1) add_ne(read(),read());\n\tdfs(1);\n\tif (ans==21) while(1);\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nset<int> S[MAX_N];\nvector<int> G[MAX_N];\nint cnt[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\tcnt[a]++;\n\t\tcnt[b]++;\n\t}\n\tqueue<int> que;\n\trep(i, 0, N) {\n\t\tif(cnt[i] == 1) que.push(i);\n\t}\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tint at = 0;\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] != 0) continue;\n\t\t\tif(sz(S[n]) > sz(S[v])) swap(S[n], S[v]);\n\t\t\tfor(auto d : S[n]) {\n\t\t\t\tif(S[v].count(d)) {\n\t\t\t\t\twhile((*(S[v].begin())) < d) S[v].erase(S[v].begin());\n\t\t\t\t\tat = d;\n\t\t\t\t}\n\t\t\t\telse if(d > at) S[v].insert(d);\n\t\t\t}\n\t\t}\n\t\twhile(!S[v].empty() && (*(S[v].begin())) == at) {\n\t\t\tS[v].erase(S[v].begin());\n\t\t\tat++;\n\t\t}\n\t\tS[v].insert(at);\n\t\tMAX(ans, at);\n\n\t\t// debug(v, vi(all(S[v])));\n\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] == 0) continue;\n\t\t\tcnt[n]--;\n\t\t\tcnt[v]--;\n\t\t\tif(cnt[n] == 1) que.push(n);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector <int> des[100010];\nint dfs(int s,int pre=0)\n{\n\tint all=0,dou=0,p=0;\n\tfor (int k=0;k<des[s].size();k++) if (des[s][k]!=pre) {int p=dfs(des[s][k],s);dou|=all&p;all|=p;}\n\twhile (((1<<p)<dou)||(all&(1<<p))) p++;\n\treturn (all>>p<<p)|(1<<p);\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tdes[u].push_back(v);\n\t\tdes[v].push_back(u);\n\t}\n\tprintf(\"%d\\n\",(int)log2(dfs(1)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int MN = 100005;\n\nint N;\nstd::vector<int> G[MN];\n\nint f[MN];\nvoid DFS(int u, int p) {\n\tint x = 0, y = 0;\n\tfor (int v : G[u]) if (v != p) {\n\t\tDFS(v, u);\n\t\tint z = x & f[v];\n\t\tif (z) y = std::max(y, __builtin_ctz(z) + 1);\n\t\tx |= f[v];\n\t}\n\tx &= ~((1 << y) - 1);\n\tf[u] = x + (1 << y);\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, x, y; i < N; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tDFS(1, 0);\n\tprintf(\"%d\\n\", 31 - __builtin_clz(f[1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nint ft[100005][20], as;\nstruct node {\n\tint vs[100005];\n\tint hd[100005], vr[200005], nt[200005], tt, rt;\n\tvoid push(int x, int y) {\n\t\tvr[++tt] = y; nt[tt] = hd[x]; hd[x] = tt;\n\t}\n\tvoid dfs(int nw, int en) {\n\t\tfor(int i = hd[nw]; i; i = nt[i]) {\n\t\t\tif(vr[i] == en) continue;\n\t\t\tdfs(vr[i], nw);\n\t\t\trop(j, 0, 20) ft[nw][j] += ft[vr[i]][j];\n\t\t}\n\t\tint x = 0;\n\t\tper(j, 19, 0) {\n\t\t\tif(ft[nw][j] > 1) break;\n\t\t\tif(!ft[nw][j]) x = j;\n\t\t}\n\t\tas = max(as, x);\n\t\trep(j, 0, x) ft[nw][j] = 0;\n\t\tft[nw][x] = 1;\n\t\treturn;\n\t}\n}T;\nint n, x, y;\nint main() {\n\tscanf(\"%d\", &n);\n\trop(i, 1, n) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT.push(x, y);\n\t\tT.push(y, x);\n\t}\n\tT.dfs(1, 0);\n\tcout << as << endl; \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MaxN = 100010;\nconst int MaxLabel = 20;\n\nint n, ans, f[MaxN]; vector<int> edge[MaxN];\n\nvoid dfs(int x, int fa) {\n  int all = 0;\n  for (int y : edge[x]) {\n    if (y == fa)\n      continue;\n    dfs(y, x);\n    all |= (f[x] & f[y]);\n    f[x] |= f[y];\n  }\n  \n  int t = 0;\n  while (f[x] >> t & 1)\n    ++t;\n  ans = max(ans, t);\n  f[x] >>= t;\n  f[x] <<= t;\n  f[x] |= (1 << t);\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1, u, v; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n  \n  dfs(1, 0);\n  cout << ans << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 100010\n#define MAXD 21\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1];\n\nint n;\nint g[MAXN],nume;\nint f[MAXN],h[MAXN];\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid dfs(int x,int p){\n\tint maxf=0;\n\tstatic int tr[MAXD];\n\tmemset(tr,0,sizeof tr);\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdfs(e[i].to,x);\n\t\t\tif(f[e[i].to]>maxf)\n\t\t\t\tmaxf=f[e[i].to];\n\t\t\tif(tr[f[e[i].to]]) tr[f[e[i].to]]=-1;\n\t\t\telse tr[f[e[i].to]]=h[e[i].to];\n\t\t}\n\tif(!maxf){\n\t\tf[x]=h[x]=1;\n\t\treturn;\n\t}\n\tint now=maxf;\n\tbool flag=0;\n\twhile(tr[now]){\n\t\tif(tr[now]==-1){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\tint temp=tr[now];\n\t\twhile((--now)>=temp)\n\t\t\tif(tr[now]){\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(flag) break;\n\t}\n\tif(!flag){\n\t\tf[x]=maxf;\n\t\th[x]=now;\n\t}else{\n\t\tf[x]=h[x]=maxf+1;\n\t}\n}\n\nint main(){\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",f[1]-1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (!isdigit(ch)) f=ch=='-'?-1:f,ch=getchar();\n\twhile (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\n\nconst int N=100005;\nconst int E=N<<1;\n\nint tov[E],nxt[E];\nint last[N];\nint n,tot,ans;\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\nint dfs(int x,int fa=0)\n{\n\tint ret=0,uni=0;\n\tfor (int i=last[x],y,bit;i;i=nxt[i])\n\t\tif ((y=tov[i])!=fa) bit=dfs(y,x),uni|=bit&ret,ret|=bit;\n\tint d=1;\n\tfor (int tmp=uni;tmp;d=tmp<<1,tmp-=tmp&-tmp);\n\tfor (;ret&d;d<<=1);\n\tint res=0;\n\tfor (int tmp=d;tmp;++res,tmp>>=1);\n\tans=max(ans,res-1),ret=(ret^d)&((-1)^(d-1));\n\treturn ret;\n}\n\nint main()\n{\n\t//freopen(\"uninity.in\",\"r\",stdin),freopen(\"uninity.out\",\"w\",stdout);\n\tn=read();\n\tfor (int i=1,x,y;i<n;++i) x=read(),y=read(),insert(x,y),insert(y,x);\n\tdfs(1),printf(\"%d\\n\",ans);\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)n; ++i)\n\nvector<int> tr[100001];\n\npair<int, int> go(int v = 1, int p = 0){\n\tint a = 0, b = 0, an = 0;\n\tf(i, 0, tr[v].size()){\n\t\tint u = tr[v][i];\n\t\tif (u == p)continue;\n\t\tpair<int, int> t = go(u, v);\n\t\tan = max(an, t.first);\n\t\tif (t.second > a)b = a, a = t.second;\n\t\telse if (t.second > b)b = t.second;\n\t}\n\treturn make_pair(max(an, a + b + 1), a + 1);\n}\n\nint lg(int x) { for (int i = 16; i >= 0; --i)if (x >> i & 1)return i; }\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tf(i, 1, n){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ttr[a].push_back(b);\n\t\ttr[b].push_back(a);\n\t}\n\tprintf(\"%d\\n\", lg(go().first));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n//#define rf(x) (x)=0;while(*p<48)im=*p=='-';while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);if(im)(x)=-(x);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define befv(V) ((V)[(sz(V)-2)])\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define cb(x) (x)=(!(x))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\n#define INFST (0x7f7f7f7f)\n#define INFLLST (0x7f7f7f7f7f7f7f7fll)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ld, ld> pdd;\ntypedef complex<ld> base;\nconst ld EPS = (ld)1e-7;\nconst ld PI = acos(0) * 2;\nbool isZero(const ld& x) { return abs(x) <= EPS; }\nint sign(const ld& x) { return isZero(x) ? 0 : (0 < x ? 1 : -1); }\nll gcd(ll a, ll b) { for(;b;a%=b,swap(a,b)){} return abs(a); }\npll operator + (const pll& a, const pll& b) { return pll(a.first+b.first, a.second+b.second); }\npll operator - (const pll& a, const pll& b) { return pll(a.first-b.first, a.second-b.second); }\npll operator * (const pll& a, const ll& b) { return pll(a.first*b, a.second*b); }\nll operator * (const pll& a, const pll& b) { return a.first*b.second - b.first*a.second; }\nll ccw(const pll& a, const pll& b, const pll& c) { return a*b + b*c + c*a; }\nvoid fg(vector<int> G[], int a, int b) { G[a].pb(b); G[b].pb(a); }\nvoid fg(vector<pii> G[], int a, int b, int c) { G[a].pb({b, c}); G[b].pb({a, c}); }\n\nconst int MAXN = 100005;\n\nvector<int> G[MAXN];\n\nint dp[3][MAXN];\nint dep[MAXN];\n\nint A[MAXN], B[MAXN];\n\nint N, Ans = INF;\n\nvoid f(int i) {\n\tint a[3] = {-1, -1, -1};\n\tfor(int v : G[i]) if(!dep[v]) {\n\t\tdep[v] = dep[i] + 1;\n\t\tf(v);\n\t\tupmax(dp[1][i], dp[0][v]);\n\t\tupmax(dp[2][i], dp[1][v]);\n\t\t\n\t\ta[2] = dp[0][v];\n\t\tsort(a, a+3);\n\t\treverse(a, a+3);\n\t}\n\tif(a[0] < 0) return;\n\n\tint &ret = dp[0][i];\n\tret = dp[2][i] + 1;\n\t//printf(\"i=%d, ret=%d\\n\", i, ret);\n\n\tfor(int v : G[i]) if(dep[i] < dep[v]) {\n\t\tint x = (a[0] == dp[0][v] ? a[1] : a[0]);\n\t\tupmin(ret, max(x, dp[2][v]) + 1);\n\t\t//printf(\"i=%d, v=%d :: x=%d, dp=%d\\n\", i, v, x, dp[2][v]);\n\t}\n}\n\nvoid g(int i, int x) {\n\tint a[3] = {-1, -1, -1};\n\tfor(int v : G[i]) if(dep[i] < dep[v]) {\n\t\ta[2] = dp[0][v];\n\t\tsort(a, a+3);\n\t\treverse(a, a+3);\n\t}\n\tif(a[0] < 0) {\n\t\tupmin(Ans, max(0, x));\n\t\treturn;\n\t}\n\tfor(int v : G[i]) if(dep[i] < dep[v]) {\n\t\tint t = (a[0] == dp[0][v] ? a[1] : a[0]);\n\t\tg(v, max(t, x) + 1);\n\t\tupmin(Ans, max(dp[0][v], max(t, x)) + 1);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\tfor(int i = 1; i < N; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tfg(G, A[i], B[i]);\n\t}\n\n\t{\n\t\tdep[1] = 1;\n\t\tf(1);\n\t}\n\n/*\n\tfor(int i = 1; i <= N; i++)\n\t\tprintf(\"%d : %d\\n\", i, dp[0][i]);\n*/\n\t\n\tAns = dp[0][1];\n\n\tg(1, -1);\n\n\tcout << dp[0][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Parent[500000], Dist[500000];\nset<int> G[500000];\n\nint DFS(int node, int par, int dist) {\n\tParent[node] = par;\n\tDist[node] = dist;\n\n\tint ret = node;\n\tfor(auto vec : G[node])\n\t\tif(vec != par) \n\t\t\tret = max(ret, DFS(vec, node, dist + 1), [&](int a, int b) {\n\t\t\t\treturn Dist[a] < Dist[b]; \n\t\t\t});\n\t\t\n\treturn ret;\n}\n\nint GetCenter(int node) {\n\tint last = DFS(node, 0, 0);\n\tlast = DFS(last, 0, 0);\n\n\tint d = Dist[last];\n\tfor(int i = 0; i < d / 2; ++i)\n\t\tlast = Parent[last];\n\tif(d % 2 == 1 && rand() % 2)\n\t\tlast = Parent[last];\n\t\n\tint ret = last;\n\n\tlast = DFS(last, 0, 0);\n\tassert(Dist[last] == (d + 1) / 2);\n\n\treturn ret;\n}\n\nint GetDiam(int node) {\n\tint last = DFS(node, 0, 0);\n\tlast = DFS(last, 0, 0);\n\treturn Dist[last];\n}\n\nint Decomp(int node) {\n\tint cen = GetCenter(node);\n\tfor(auto vec : G[cen]) {\n\t\tG[vec].erase(cen);\n\t}\n\n\tint ans = 0;\n\tfor(auto vec : G[cen])\n\t\tans = max(ans, Decomp(vec) + 1);\n\treturn ans;\n}\n\nint GetDP(int n) {\n\tif(n == 1) return 0;\n\treturn GetDP(n / 2) + 1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tsrand(time(0));\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 1; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tG[a].insert(b);\n\t\tG[b].insert(a);\n\t}\n\n\tcout << GetDP(GetDiam(1)) << endl;\n\n\t// cout << Decomp(1) << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint N,head[MAXN],sumE;\nint mask[MAXN],ans;\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid dfs(int u,int fa) {\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(v != fa) {\n            dfs(v,u);\n        }\n    }\n    mask[u] = 0;\n    vector<int> vec;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(v != fa) {\n            mask[u] |= mask[v];\n            vec.pb(mask[v]);\n        }\n    }\n    int t = 0;\n    for(int i = 0 ; i <= 20 ; ++i) {\n        if(mask[u] >> i & 1) {\n            if(t == i) ++t;\n            int cnt = 0;\n            for(auto k : vec) {\n                if(k >> i & 1) ++cnt;\n            }\n            if(cnt > 1) t = max(t,i + 1);\n        }\n    }\n    mask[u] |= (1 << t);\n    ans = max(ans,t);\n    for(int i = 0 ; i < t ; ++i) {\n        if(mask[u] >> i & 1) mask[u] ^= (1 << i);\n    }\n    return ;\n}\nvoid Solve() {\n    read(N);\n    int a,b;\n    for(int i = 1 ; i < N ; ++i) {\n        read(a);read(b);add(a,b);add(b,a);\n    }\n    dfs(1,0);\n    out(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int maxn = 100000;\nvector<int> G[maxn + 1];\nint dp[maxn + 1];\nint add(int u, int v){\n    int res = 0;\n    for(int k = 20; ~k; k -= 1){\n        if(((u >> k) & 1) and ((v >> k) & 1)) return res + (1 << (k + 1));\n        if(((u >> k) & 1) or ((v >> k) & 1)) res += 1 << k;\n    }\n    return res + 1;\n}\nvoid DFS(int u, int par = 0){\n    vector<int> w;\n    for(int v : G[u]) if(v != par){\n        DFS(v, u);\n        w.push_back(dp[v]);       \n    }\n    if(w.empty()) dp[u] = 1;\n    else if(w.size() == 1u) dp[u] = w[0] + 1;\n    else{\n        sort(w.begin(), w.end(), greater<int>());\n        dp[u] = add(w[0], w[1]);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int N;\n    cin >> N;\n    for(int i = 1, a, b; i < N; i += 1){\n        cin >> a >> b;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    DFS(1);\n    cout << 31 - __builtin_clz(dp[1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n/*\ntane adami sharifast be jane adamiat\nna hamin lebase zibast neshane adamiat\nagar adami be cheshmasto dahano goosho bini\nche miane naghshe divaro miane adamiat\nkhoro khabo khashmo shahvat shaghab asto jahlo zolmat\nhayavan khabar nadarad ze jahane adamiat\nbe haghighat adami bash vagarna morgh bashad\nke hami sokhan begooyad be zabane adamiat\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); }\n#define MKP make_pair\n#define RETD(x) { cout << fixed << setprecision(15) << x; } //exit(0); }\n#define GEI(x) scanf(\"%d\",&x)\n#define GEL(x) scanf(\"%lld\",&x)\n#define ALL(x) x.begin(),x.end()\nconst ll M=5e4+5,LG=32,SM=2e4+5,inf=1e9+5;\nll mod=1e9+7;\n#define MOK(x) if(x>mod) x-=mod;\nll pw(ll x,ll n) { return (n==0?1:pw(x*x%mod,n/2)*(n&1?x:1)%mod); }\n\nll n;\nvll g[M];\nll cm[M],cn[M];\nll res;\n\nll lasb(ll x) { return (x<2?x:lasb(x>>1)+1); }\nll firb(ll x) { return (x&1?0:firb(x>>1)+1); }\n\nvoid dfs(ll x,ll p)\n{\n    ll ba=0;\n    for (ll y:g[x])\n    {\n        if (y==p) continue;\n        dfs(y,x);\n        ba|=cm[x]&cm[y];\n        cm[x]|=cm[y];\n    }\n    ll nd=lasb(ba);\n    cm[x]&=-(1<<nd);\n    cm[x]+=(1<<nd);\n    cn[x]=firb(cm[x]);\n    smax(res,cn[x]);\n}\n \nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n;\n    For(i,1,n)\n    {\n        ll a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].PB(b);g[b].PB(a);\n    }\n    dfs(0,0);\n    RET(res);\n} "
  },
  {
    "language": "C++",
    "code": "/** MIT License Copyright (c) 2018-2019 Vasilev Daniil **/\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> using v = vector<T>;\n#define int long long\ntypedef double ld;\ntypedef string str;\ntypedef vector<int> vint;\n#define rep(a, l, r) for(int a = (l); a < (r); a++)\n#define pb push_back\n#define fs first\n#define sc second\n#define sz(a) ((int) a.size())\nconst long long inf = 4611686018427387903; //2^62 - 1\nconst long double EPS = 1e-11;\n#if 0  //FileIO\nconst string fileName = \"\";\nifstream fin ((fileName == \"\" ? \"input.txt\"  : fileName + \".in\" ));\nofstream fout((fileName == \"\" ? \"output.txt\" : fileName + \".out\"));\n#define get fin >>\n#define put fout <<\n#else\n#define get cin >>\n#define put cout <<\n#endif\n#define eol put endl\nvoid read() {} template<typename Arg,typename... Args> void read (Arg& arg,Args&... args){get (arg)     ;read(args...) ;}\nvoid print(){} template<typename Arg,typename... Args> void print(Arg  arg,Args...  args){put (arg)<<\" \";print(args...);}\nint getInt(){int a; get a; return a;}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//code starts here\nconst int N = 1e5 + 1;\nvint t[N];\nint h[N];\nint mx[N], submx[N];\n\nvoid calcH(int cur, int p) {\n\th[cur] = 1;\n\tfor (int i : t[cur]) \n\t\tif (i != p) {\n\t\t\tcalcH(i, cur);\n\t\t\th[cur] = max(h[cur], h[i] + 1);\n\t\t}\n\t\n\tmx[cur] = 0; submx[cur] = 0;\n\tfor (int i : t[cur]) \n\t\tif (i != p) {\n\t\t\tif (mx[cur] == -1 || h[mx[cur]] < h[i]) {\n\t\t\t\tsubmx[cur] = mx[cur];\n\t\t\t\tmx[cur] = i;\n\t\t\t} else if (submx[cur] == -1 || h[submx[cur]] < h[i])\n\t\t\t\tsubmx[cur] = i;\n\t\t}\n}\n\nint ans[N];\nvoid calcAns(int cur, int p, int upperHeight) {\n\tans[cur] = max(h[cur] - 1, upperHeight) + 1;\n\tfor (int i : t[cur]) \n\t    if (i != p) {\n    \t\tif (mx[cur] == i)\n    \t\t\tcalcAns(i, cur, max(upperHeight, h[submx[cur]]) + 1);\n    \t\telse\n    \t\t\tcalcAns(i, cur, max(upperHeight, h[mx[cur]]) + 1);\n    \t}\n}\n\nvoid run() {\n\th[0] = -1;\n\tint n;\n\tget n;\n\t\n\trep(i, 1, n) {\n\t\tint v, u;\n\t\tread(v, u);\n\t\tt[v].pb(u);\n\t\tt[u].pb(v);\n\t}\n\t\n\tcalcH(1, -1);\n\tcalcAns(1, -1, 0);\n\tint res = n;\n\trep(i, 1, n + 1)\n\t\tres = min(res, ans[i]);\n\t\n\tint out = 0;\n\twhile ((1 << out) < res)\n\t\tout++;\n\tput out;\n}\nsigned main() {srand(time(0)); ios::sync_with_stdio(0); cin.tie(0); put fixed << setprecision(12); run();}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge\n{\n\tint v,next;\n}vs[N];\nint n,mask[N][30],st[N],ee,Ans;\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt,int pr)\n{\n\tint cur=-1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt);\n\t\tfor(int j=0;j<30;j++)\n\t\t{\n\t\t\tif(mask[rt][j]&&mask[vs[i].v][j]) cur=max(cur,j);\n\t\t\tmask[rt][j]|=mask[vs[i].v][j];\n\t\t}\n\t}\n\tfor(++cur;cur<30;++cur) if(!mask[rt][cur]) break;\n\tAns=max(Ans,cur); mask[rt][cur]=1;\n\tfor(--cur;cur>=0;cur--) mask[rt][cur]=0;\n}\nint main()\n{\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v);\n\t\taddedge(v,u);\n\t}\n\tdfs(1,0); cout << Ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 101000\nusing namespace std;\nint last[N],nxt[N*2],to[N*2],n,tot=1,f[N],g[N],ans=0;\nvoid putin(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nvoid dg(int x,int fa)\n{\n\tint jy=0;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];if(y==fa) continue;\n\t\tdg(y,x);\n\t\tjy|=g[x]&g[y];\n\t\tg[x]=g[x]|g[y];\n\t}\n\tfor(f[x]=0;jy>0&&(((1<<f[x])-1)&jy)==0;f[x]++);\n\tf[x]++;\n\tans=max(ans,f[x]);\n\tg[x]=g[x]>>f[x]<<f[x];\n\tg[x]|=1<<f[x];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tputin(x,y);putin(y,x);\n\t}\n\tdg(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nconst int N = 100010;\nint n;\n\nstruct edge{ int to, pre; }e[N << 1]; int u[N], l = 0;\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\n\nint w[N];\nvoid dfs(int x, int f) {\n\tint least = (1<<20)-1, vis = 0, c = 0;\n\treg(i,x) if (v != f) dfs(v, x), (least &= w[v]), (vis |= w[v]), c++;\n\tif (c <= 1) least = 0;\n\tint t = 0;\n\tdep(j,19,0) if (least >> j & 1) break; else if (!(vis >> j & 1)) t = j;\n\tw[x] = 1 << t; rep(j,t+1,19) w[x] |= vis & (1 << j);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n - 1) { int a, b; scanf(\"%d%d\",&a,&b); ins(a, b), ins(b, a); }\n\tdfs(1,0);\t\n\tdep(j,19,0) if (w[1] >> j & 1) { printf(\"%d\\n\",j); break; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\nint ans;\n\nint dfs(int v, int p=-1) {\n  int a = 0, b = 0;\n  rep(i,sz(to[v])) {\n    int u = to[v][i];\n    if (u == p) continue;\n    int r = dfs(u,v);\n    b |= a&r;\n    a |= r;\n  }\n  while (pcnt(b) > 1) b += b&-b;\n  if (b) a |= b-1;\n  ++a;\n  return a;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  int x = dfs(0);\n  int ans = -1;\n  while (x) ++ans, x >>= 1;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*  ***  In The Name of God ... ***  */\n#include <bits/stdc++.h>\n\nusing namespace std ;\n \ntypedef long long ll ;\ntypedef long double ld ;\n\n\n#define int long long\n#define all(v) v.begin() , v.end()\n\ntemplate<typename T> inline bool smin(T &a, const T &b){ return b < a ? a = b,1:0;}\ntemplate<typename T> inline bool smax(T &a, const T &b){ return a < b ? a = b,1:0;}\n\nconst int N = ( int ) 1e5 + 10 ;\n\nint n , sz [ N ] , all = 0 ; \nvector < int > adj [ N ] ; \nbool mark [ N ] ;\n\nvoid dfs ( int v , int p = -1 ) {\n\tsz [ v ] = 1 ;\n\tfor ( int u : adj [ v ] ) {\n\t\tif ( u == p ) continue ;\n\t\tif ( !mark [ u ] ) {\n\t\t\tdfs ( u , v ) ;\n\t\t\tsz [ v ] += sz [ u ] ; \n\t\t}\n\t}\n}\n\nint get_centroid ( int v , int p = -1 ) {\n\tfor ( int u : adj [ v ] ) {\n\t\tif ( mark [ u ] ) continue ;\n\t\tif ( sz [ u ] > all / 2 && u != p )\n\t\t\treturn get_centroid ( u , v ) ;  \n\t}\n\treturn v ; \n}\n\nint solve ( int v = 0 ) {\n\tdfs ( v ) ;\n\tall = sz [ v ] ;\n\tv = get_centroid ( v ) ;\n\tmark [ v ] ++ ; \n\tint ret = 0 ;\n\tfor ( int u : adj [ v ] ) {\n\t\tif ( !mark [ u ] ) {\n\t\t\tsmax ( ret , solve ( u ) + 1 ) ; \n\t\t}\n\t}\n\treturn ret ; \n}\n\nint32_t main()                     \n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n ;\n\tfor ( int j = 0 ; j < n - 1 ; ++ j ) {\n\t\tint u , v ;\n\t\tcin >> u >> v ;\n\t\t-- u , -- v ;\n\t\tadj [ u ] . push_back ( v ) ;\n\t\tadj [ v ] . push_back ( u ) ; \n\t}\n\tcout << solve ( ) << '\\n' ; \n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc009/tasks/agc009_d\n/*<head>*/\n// #include \"lib/Template.hpp\"\n// #include \"lib/Graph.hpp\"\n/*</head>*/\n\n/*<body>*/\n/* #region header */\n/**\n* @file Template.hpp\n* @brief 競技プログラミング用テンプレート\n* @author btk15049\n* @date 2019/05/02\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* #region macro */\n#ifdef BTK\n#    define DEBUG if (1)\n#    define CIN_ONLY if (0)\n#else\n#    define DEBUG if (0)\n#    define CIN_ONLY if (1)\n#endif\n/** @def\n* ALLマクロ\n*/\n#define ALL(v) (v).begin(), (v).end()\n\n/** @def\n* 再帰ラムダをするためのマクロ\n*/\n#define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n/* #endregion */\n\nnamespace _Template_ {\n/**\n* @brief cin高速化処理を行うための構造体\n* @details CIN_ONLYマクロで動作が変わる\n*/\nstruct cww {\ncww() {\nCIN_ONLY {\nios::sync_with_stdio(false);\ncin.tie(0);\n}\n}\n} star;\n/**\n* @brief change min\n* @tparam T 型\n* @param l 参照\n* @param r 非参照\n* @return 更新があればtrue\n*/\ntemplate <typename T>\ninline bool chmin(T& l, T r) {\nbool a = l > r;\nif (a) l = r;\nreturn a;\n}\n/**\n* @brief chminのmax版\n* @see chmin\n*/\ntemplate <typename T>\ninline bool chmax(T& l, T r) {\nbool a = l < r;\nif (a) l = r;\nreturn a;\n}\n/**\n* @brief\n* vectorに直接cin流すためのやつ\n* @tparam T\n* @param is\n* @param v\n* @return istream&\n*/\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v) {\nfor (auto& it : v) is >> it;\nreturn is;\n}\n/**\n* @brief\n* rangeを逆向きに操作したいとき用\n* @details\n* ループの範囲は[bg,ed)なので注意\n* @see range\n*/\nclass reverse_range {\nprivate:\nstruct I {\nint x;\nint operator*() { return x - 1; }\nbool operator!=(I& lhs) { return x > lhs.x; }\nvoid operator++() { --x; }\n};\nI i, n;\n\npublic:\nreverse_range(int n) : i({0}), n({n}) {}\nreverse_range(int i, int n) : i({i}), n({n}) {}\nI& begin() { return n; }\nI& end() { return i; }\n};\n/**\n* @brief\n* python みたいな range-based for を実現\n* @details\n* ループの範囲は[bg,ed)なので注意\n* !つけると逆向きにループが回る (reverse_range)\n* 空間計算量はO(1)\n* 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n*/\nclass range {\nprivate:\nstruct I {\nint x;\nint operator*() { return x; }\nbool operator!=(I& lhs) { return x < lhs.x; }\nvoid operator++() { ++x; }\n};\nI i, n;\n\npublic:\nrange(int n) : i({0}), n({n}) {}\nrange(int i, int n) : i({i}), n({n}) {}\nI& begin() { return i; }\nI& end() { return n; }\nreverse_range operator!() { return reverse_range(*i, *n); }\n};\n/**\n* @brief\n* rangeで生まれる使わない変数を消す用（警告消し）\n*/\ntemplate <typename T>\ninline T& unused_var(T& v) {\nreturn v;\n}\nusing LL = long long;\n} // namespace _Template_\nusing namespace _Template_;\n\n\n/**\n* @file Graph.hpp\n* @brief グラフクラス\n* @author btk15049\n* @date 2019/03/11\n* @datails\n*  verify: WUPC C\n*/\nnamespace _Graph_ {\n/**\n* @brief 辺を扱う構造体の例\n* @details\n辺に重みなどを加えたい場合は変数とかを増やして作る．\nGraphに使うために必要な要件:\n- id,a,bは必須，他のパラメータ増やすときはコンストラクタを忘れずに\n- versusは必須，基本的にコピペでOK\n*/\nstruct Edge {\nint id, a, b;\n/**\n* @brief Construct a new Edge object\n* @param id 辺番号\n* @param a 辺に接続する頂点番号\n* @param b 辺に接続する頂点番号\n*/\nEdge(int id = 0, int a = 0, int b = 0) : id(id), a(a), b(b) {}\n/**\n* @brief 辺における，vの対になってる頂点番号を取得する\n* @param v 頂点番号\n* @return int vじゃない方の頂点番号\n*/\ninline int versus(const int v) const { return a ^ b ^ v; }\n};\n/**\n* @brief グラフクラス\n* @tparam E=Edge 新たなグラフクラス作るときは書き換える\n* @details 0-indexedで使うことしか考えてないので注意．\n*/\ntemplate <typename E = Edge>\nclass Graph {\nprivate:\n//! 辺集合\nvector<E> edges;\n//! 隣接リスト\nvector<vector<int>> g;\n\npublic:\n/**\n* @brief Construct a new Graph object\n* @param reserved_vertex_size 頂点数の最大値，vectorのサイズ確保用\n* @param reserved_edge_size 辺数の最大値，vectorのサイズ確保用\n*/\nGraph(int reserved_vertex_size = 1, int reserved_edge_size = -1) {\ng.reserve(reserved_vertex_size);\nedges.reserve(max(reserved_vertex_size, reserved_edge_size));\n}\n\n/**\n* @brief グラフの頂点数を返す\n* @return int 頂点数\n*/\ninline int size() { return g.size(); }\n\n/**\n* @brief vの次数を返す\n* @param v 頂点番号\n* @return int 次数\n*/\ninline int degree(const int v) { return g[v].size(); }\n\n/**\n* @brief グラフ全体の辺の数を返す\n* @return int グラフ全体の辺の数\n*/\ninline int degree() { return edges.size(); }\n\n/**\n* @brief \"無向\"辺(a,b)を追加する．\n* @param a 頂点番号\n* @param b 頂点番号\n* @param params 重みとか，容量とか\n* @details paramsはemplace_backと同じノリで続けて足してけばOK\n*/\ntemplate <typename... Ts>\ninline void add_edge(int a, int b, Ts&&... params) {\nconst int id = edges.size();\nif ((int)g.size() <= max(a, b)) {\ng.resize(max(a, b) + 1);\n}\ng[a].emplace_back(id);\ng[b].emplace_back(id);\nedges.emplace_back(id, a, b, forward<Ts>(params)...);\n}\n\n/**\n* @brief \"有向\"辺(a,b)を追加する．\n* @param a 頂点番号\n* @param b 頂点番号\n* @param params 重みとか，容量とか\n* @details paramsはemplace_backと同じノリで続けて足してけばOK\n*/\ntemplate <typename... Ts>\ninline void add_arc(int a, int b, Ts&&... params) {\nconst int id = edges.size();\nif ((int)g.size() <= max(a, b)) {\ng.resize(max(a, b) + 1);\n}\ng[a].emplace_back(id);\nedges.emplace_back(id, a, b, forward<Ts>(params)...);\n}\n\n/**\n* @brief vの隣接頂点を返す\n* @param v int\n* @return vector<int>\n*/\ninline vector<int> Ns(const int v) {\nvector<int> ns(g[v].size());\nfor (int i = 0; i < degree(v); i++) {\nns[i] = edges[g[v][i]].versus(v);\n}\nreturn ns;\n}\n\n/**\n* @brief vに隣接する辺番号の集合を返す\n* @param v int\n* @return vector<int>\n*/\ninline const vector<int>& operator[](const int v) { return g[v]; }\n\n/**\n* @brief 辺番号から辺の参照を取得する\n* @param edge_id\n* @return E&\n*/\ninline E& i2e(const int edge_id) { return edges[edge_id]; }\n};\n} // namespace _Graph_\nusing namespace _Graph_;\n\n/* #endregion */\n/*</body>*/\n\ntemplate <typename E=Edge>\nclass Tree : public Graph<E> {\n    private:\n    using Graph<E>::add_edge;\n    void build(Graph<E>& g, int v,int p) {\n        for(int edge_id:g[v]){\n            auto e = g.i2e(edge_id);\n            const int u = e.versus(v);\n            if(p==u)continue;\n            //add_arc(e);\n            this->add_arc(v,u);\n            build(g,u,v);\n        }\n    }\n    public:\n    const int root;\n    Tree(int reserved_vertex_size = 1, int reserved_edge_size = -1, const int root = 0)\n    : Graph<E>(reserved_vertex_size, reserved_edge_size) , root(root) {}\n    Tree(Graph<E>& g, const int root = 0)\n    : Graph<E>(g.size(), g.size()-1), root(root){\n        build(g,root,root);\n    }\n};\n\nusing X = array<int,32>;\nX dfs(Tree<>& tree, int v){\n    X ret;\n    for(int i:range(32))ret[i]=0;\n    for(int u:tree.Ns(v)){\n        X cld = dfs(tree,u);\n        for(int i:range(32))ret[i]+=cld[i];\n    }\n    int low = -1;\n    for(int i:range(32)){\n        if(ret[i]>=2)low = i;\n    }\n    int up = low+1;\n    while(ret[up]>0){\n        up++;\n    }\n    for(int i:range(up)){\n        ret[i]=0;\n    }\n    ret[up]++;\n    //cerr << v << \" \" << up << \" \";\n    //for(int i:range(32))cerr<<ret[i];\n    //cerr << endl;\n    return ret;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    Graph<> g(N,N-1);\n    for(int i:range(N-1)){\n        unused_var(i);\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        g.add_edge(a,b);\n    }\n    Tree tree(g);\n    auto st = dfs(tree,tree.root);\n    for(int i:!range(32)){\n        if(st[i]){\n            cout << i << endl;\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\t\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nstruct edge\n{\n\tint to;\n\tint next;\n}e[666666];\nint pe=222222;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n}\nint f[222222],g[222222];\nint top[555555];\nvoid dfs(int o,int fa)\n{\n\tint s=0;\n\tint min=-1;\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)\n\t\t{\n\t\t\tdfs(e[p].to,o);\n\t\t\tcmax(min,top[s&g[e[p].to]]);\n\t\t\ts|=g[e[p].to];\n\t\t}\n\tfor(register int i=min+1;i<=20;++i)\n\t\tif(!(s&1<<i)){f[o]=i;break;}\n\tg[o]=1<<f[o];\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)g[o]|=g[e[p].to]&~((1<<f[o])-1);\n}\nint main()\n{\n\ttop[0]=-1;\n\tfor(register int i=2;i<=524287;++i)\n\t\ttop[i]=top[i>>1]+1;\n\twhile(1)\n\t{\n\t\tint n=io::F();\n\t\tif(n==0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(register int i=1;i<n;++i)\n\t\t{\n\t\t\tint x=io::F(),y=io::F();\n\t\t\tinsert(x,y);\n\t\t\tinsert(y,x);\n\t\t}\n\t\tdfs(1,0);\n\t\tint max=0;\n\t\tfor(register int i=1;i<=n;++i)cmax(max,f[i]);\n\t\tprintf(\"%d\\n\",max);\n\t\tpe=222222;\n\t\tfor(register int i=1;i<=n;++i)e[i].next=0;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 100000\nstruct edge{int nx,t;}e[MN*2+5];\nint h[MN+5],en,f[MN+5];\ninline void ins(int x,int y)\n{\n\te[++en]=(edge){h[x],y};h[x]=en;\n\te[++en]=(edge){h[y],x};h[y]=en;\n}\nint cal(int x){for(int i=17;i;--i)if(x&(1<<i))return i;return -1;}\nvoid dfs(int x,int fa)\n{\n\tint mx=0;\n\tfor(int i=h[x];i;i=e[i].nx)if(e[i].t!=fa)\n\t{\n\t\tdfs(e[i].t,x);\n\t\tmx=max(mx,cal(f[x]&f[e[i].t])+1);\n\t\tf[x]|=f[e[i].t];\n\t}\n\tfor(int i=0;;++i)if(i>=mx&&!(f[x]&(1<<i)))\n\t\t{f[x]=(f[x]|(1<<i))&((-1)<<i);return;}\n}\nint main()\n{\n\tint n=read(),i;\n\tfor(i=1;i<n;++i)ins(read(),read());\n\tdfs(1,0);\n\tprintf(\"%d\",cal(f[1]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=1e5+50, L=20;\nint n,ans,f[N];\nvector <int> edge[N]; \ninline void dfs(int x,int fa) {\n\tint sta=0,lim=0; \n\tint *cnt=new int[L];\n\tfor(int i=0;i<L;i++) cnt[i]=0;\n\tfor(int e=edge[x].size()-1;~e;e--) {\n\t\tint v=edge[x][e]; if(v==fa) continue;\n\t\tdfs(v,x); sta|=f[v];\n\t\tfor(int j=0;j<L;++j) if(f[v]&(1<<j)) if((++cnt[j])>=2) lim=max(lim,j+1); \n\t}\n\tif(edge[x].size()+(x==1)==1) f[x]=1; //leaf\n\telse if(edge[x].size()+(x==1)==2) {\n\t\tint j;\n\t\tfor(j=0;j<L;++j) if(!(sta&(1<<j))) break;\n\t\tf[x]=sta|(1<<j); ans=max(ans,j);\n\t\tfor(--j;~j;--j) if(f[x]&(1<<j)) f[x]^=(1<<j);\n\t} else {\n\t\tint j;\n\t\tfor(j=lim;j<L;++j) if(!(sta&(1<<j))) break;\n\t\tf[x]=sta|(1<<j); ans=max(ans,j);\n\t\tfor(--j;~j;--j) if(f[x]&(1<<j)) f[x]^=(1<<j);\n\t}\n\tdelete cnt;\n}\nint main() {\n\tn=rd();\n\tfor(int i=1;i<n;i++) {\n\t\tint x=rd(), y=rd();\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t} cout<<(dfs(1,0),ans)<<'\\n';\n\t\n}"
  },
  {
    "language": "C++",
    "code": "/*\ncontest <- \"AtCoder Grand Contest 009\",\ntask <- \"D - Uninity\".\n*/\n#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 100005;\nconst int KMAX = 30;\nvector<int> G[NMAX];\ntemplate<typename Type>\nvoid showContent(Type input)\n{\n\tfor(auto iterator=input.begin(); iterator!=input.end(); ++iterator)\n\t{\n\t\tcout<<(*iterator)<<\", \";\n\t}\n\treturn;\n}\narray<int, KMAX> dfs(int node, int prev) {\n    array<int, KMAX> ret;\n    fill(ret.begin(), ret.end(), 0);\n    ret[0] = 1;\n    for (int to: G[node]) {\n        if (to != prev) {\n            array<int, KMAX> son = dfs(to, node);\n            //->\n            //cout<<\"Next Is Not Equal To Previous <- <- Next Is Not Equal To Previous\"<<endl;\n            /*\n          \tcout<<\"Current point node <- \"<<node<<\", prev <- \"<<prev<<\", to <- \"<<to<<endl;\n            cout<<\"son <- \";\n            showContent(son);\n            cout<<endl;\n            */\n    \t\t//cout<<\"Next Is Not Equal To Previous <- <- Next Is Not Equal To Previous\"<<endl<<endl<<endl;\n            //<-\n            for (int i = 0; i < KMAX; ++i) {\n                ret[i] += son[i];\n            }\n            /*\n          \t//->\n            cout<<\"ret <- \";\n            showContent(ret);\n            cout<<endl;\n            cout<<\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n            //<-\n            */\n        }\n    }\n    //for (int i = KMAX - 1; i >= 0; --i) {\n    for(int i=0; i<KMAX; ++i)\n    {\n        if (ret[i] > 1) {\n            fill(ret.begin(), ret.begin() + i + 1, 0);\n            for (int j = i + 1; j < KMAX; ++j) {\n                //->\n                //cout<<\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n                /*\n              \tcout<<\"node <- \"<<node<<\", prev <- \"<<prev<<endl;\n                cout<<\"i <- \"<<i<<\", j <- \"<<j<<endl;\n                */\n                //cout<<\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n                //<-\n                if (ret[j] > 0) {\n                    ret[j] = 0;\n                } else {\n                    ret[j] = 1;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    //->\n  \t/*\n  \tcout<<\"node <- \"<<node<<\", prev <- \"<<prev<<endl;\n    cout<<\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n    */\n    //<-\n  \treturn ret;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    array<int, KMAX> ans = dfs(1, -1);\n    int fans = 0;\n    for (int i = 0; i < KMAX; ++i) {\n        if (ans[i] > 0) {\n            fans = i;\n        }\n    }\n    cout<<fans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,fst[N],to[N*2],nxt[N*2],l,fa[N],b[N],Ans;\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n}\nvoid dfs(int x)\n{\n\tint tmp=0;\n\tfor (int i=fst[x];i;i=nxt[i])\n\tif (to[i]!=fa[x])\n\t{\n\t\tfa[to[i]]=x;\n\t\tdfs(to[i]);\n\t\ttmp|=b[to[i]];\n\t}\n\tint t=(~tmp)&(-(~tmp));\n\tb[x]=tmp^t^(tmp&(t-1));\n\tAns=max(Ans,t);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tdfs(1);\n\tint ans=0;\n\twhile(Ans>=1)Ans>>=1,ans++;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100010;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint e, st[MAXN], to[MAXN];\nint nxt[MAXN], l[MAXN][20];\ninline void Add(int u, int v) {\n\tto[++e] = v, nxt[e] = st[u];\n\tst[u] = e;\n}\n\nint n, ans;\n\nvoid dfs(int u, int fa) {\n\tint i, j;\n\tfor(i = st[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tif(v == fa) continue;\n\t\tdfs(v, u);\n\t\tfor(j = 0; j < 20; j++) l[u][j] += l[v][j];\n\t}\n\tint loc = -1;\n\tfor(j = 0; j < 20; j++) if(l[u][j] >= 2) loc = j;\n\tfor(j = loc+1; j < 20; j++) if(!l[u][j]) break;\n\tloc = j;\n\tans = max(ans, loc);\n\tl[u][loc] = 1;\n\tfor(j = 0; j < loc; j++) l[u][j] = 0;\n}\n\nint main() {\n\n\tint i;\n\n\tn = read();\n\tfor(i = 1; i < n; i++) {\n\t\tint u = read(), v = read();\n\t\tAdd(u, v), Add(v, u);\n\t}\n\n\tdfs(1, 0);\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\ntypedef long long llint;\nconst llint inf = 1000000000000000000LL;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\nconst int MAXN = 100005;\n\nvector<int> T[MAXN];\nint dad[MAXN];\nbool alive[MAXN];\nint L[MAXN];\nint R[MAXN];\n\npair<int,int> far_dfs(int i, int d = 0, int cur_dad = -1) {\n  pair<int,int> ret = {d, i};\n  dad[i] = cur_dad;\n  for (int j : T[i])\n    if (alive[j] && j != cur_dad)\n      ret = max(ret, far_dfs(j, d + 1, i));\n  return ret;\n}\n\nint depth(int i, int dad) {\n  int ret = 0;\n\n  for (int j : T[i]) {\n    if (alive[j] && j == dad) continue;\n    ret = max(ret, 1 + depth(j, i));\n  }\n\n  return ret;\n}\n\nint solve(int i) {\n  auto a = far_dfs(i);\n  auto b = far_dfs(a.second);\n\n  if (b.first <= 1)\n    return b.first;\n\n  vector<int> path;\n\n  for (int i = b.second; i != -1; i = dad[i]) \n    path.push_back(i);\n\n  int cd = 0;\n  for (int i = 0; i < (int)path.size() - 1; ++i) {\n    for (int j : T[path[i]]) {\n      if (!alive[j] || j == path[i + 1] || i && j == path[i - 1]) continue;\n      cd = max(cd, depth(j, path[i]) + 1);\n    }\n    L[i] = cd;\n    ++cd;\n  }\n\n  cd = 0;\n  for (int i = (int)path.size() - 1; i >= 1; --i) {\n    for (int j : T[path[i]]) {\n      if (!alive[j] || j == path[i - 1]\n\t  || i + 1 < (int)path.size() && j == path[i + 1]) continue;\n      cd = max(cd, depth(j, path[i]) + 1);\n    }\n    R[i] = cd;\n    ++cd;\n  }\n\n  int best = 1;\n  int best_len = 1e9;\n  for (int i = 1; i < (int)path.size() - 1; ++i) {\n    if (max(L[i - 1], R[i + 1]) < best_len) {\n      best_len = max(L[i - 1], R[i + 1]);\n      best = i;\n    }\n  }\n\n  alive[path[best]] = 0;\n\n  return 1 + max(solve(path[best - 1]), solve(path[best + 1]));\n}\n\nint main(void) \n{\n  int N;\n  scanf(\"%d\", &N);\n\n  FOR(i, 1, N + 1) alive[i] = 1;\n\n  FOR(i, 1, N) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    T[a].push_back(b);\n    T[b].push_back(a);\n  }\n\n  printf(\"%d\\n\", solve(1));\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 100010\nint he[N],ne[N<<1],e[N<<1],cnt,bit[N],mark[N],ans,n;\nvoid dfs(int x,int fa){\n    for (int i=he[x];i;i=ne[i]){\n        if (e[i]!=fa) dfs(e[i],x);\n    }\n    int S1=0,S2=0,S3=0;\n    for (int i=he[x];i;i=ne[i]){\n        S3=S1&bit[e[i]];\n        S2|=S3;\n        S1|=bit[e[i]];\n    }\n    S1^=S2;\n    for (int i=0;i<20;i++){\n        if ((1<<i)>S2 && !(S1&(1<<i))){\n            mark[x]=i;\n            ans=max(ans,i);\n            break;\n        }\n    }\n    bit[x]=(S1>>mark[x])<<mark[x];\n    bit[x]|=(1<<mark[x]);\n}\nvoid add(int u,int v){ne[++cnt]=he[u];he[u]=cnt;e[cnt]=v;}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){\n        int u,v; scanf(\"%d%d\",&u,&v);\n        add(u,v); add(v,u);\n    }\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Èå äÇã Çæ */\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int MAX_N = 100 * 1000 + 5;\nint n, max_path;\nset<int> adj[MAX_N];\n\nvoid read_input() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tadj[u].insert(v);\n\t\tadj[v].insert(u);\n\t}\t\n}\n\nint dfs(int v, int pr = -1) {\n\tint x = 0, y = 0;\n\tfor (int u: adj[v])\n\t\tif (u != pr) {\n\t\t\ty = max(y, dfs(u, v) + 1);\n\t\t\tif (x < y)\n\t\t\t\tswap(x, y);\n\t\t}\n\tmax_path = max(max_path, x + y);\n\treturn x;\n}\n\nvoid solve() {\n\tdfs(0);\n}\n\nvoid print_output() {\n\tcout << (int) log2(max_path + 1);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tread_input();\n\tsolve();\n\tprint_output();\n}"
  },
  {
    "language": "C++",
    "code": "//cwystc <--> 陈威宇是天才  --by cwy\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst double PI=acos(-1);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n#define travel_set(it,a) for (set<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_map(it,a) for (map<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_vec(it,a) for (vector<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define p(x) cout << x << endl;\n#define def cout << \"find\" << endl;\n#define what_is(x) cout << #x << \" is \" << x << endl;\ntemplate <class T>T sqr(T x){return x*x;}\ntemplate <class T>T alex(T x){return (x>0)?x:-x;}\ntemplate <class T>void read(T&x){\n\tx=0;T f=1;char ch=getchar();\n\twhile ((ch<48||ch>57)&&ch!=45)ch=getchar();\n\tif (ch==45)f=-1,ch=getchar();\n\twhile (ch>=48&&ch<=57)x=x*10+ch-48,ch=getchar();\n\tx*=f;\n}\n\n//-------------------------------------------------head-------------------------------------------------\n\n#define maxn 100005\nint n;\nvector<int>E[maxn];\nint sign[maxn];bool vis[maxn];\nbool gbit(int x,int bit){return (x>>bit)&1;}\nvoid dfs(int x){\n\tvis[x]=true;int _sign=0;int s=0;\n\tRep(i,0,E[x].size())if (!vis[E[x][i]]){\n\t\tdfs(E[x][i]);s|=(_sign&sign[E[x][i]]);_sign|=sign[E[x][i]];\n\t}\n\tRep(i,(int)log2(s),20){_sign^=(1<<i);if (gbit(_sign,i)==1)break;}\n\tsign[x]=_sign;\n}\nint main(){\n\t// freopen(\"D.in\",\"r\",stdin);\n\t// freopen(\"D.out\",\"w\",stdout);\n\tread(n);\n\tRep(i,1,n){\n\t\tint x,y;read(x);read(y);\n\t\tE[x].pb(y);E[y].pb(x);\n\t}\n\tdfs(1);int res=0;\n\trep(i,1,n)res=max(res,sign[i]);/*\n\tcerr << (int)log2(1<<0) << endl;\n\tcerr << (int)log2(1<<1) << endl;\n\tcerr << (int)log2(1<<2) << endl;\n\tcerr << (int)log2(1<<3) << endl;\n\tcerr << (int)log2(1<<4) << endl;\n\tcerr << (int)log2(1<<5) << endl;\n\tcerr << (int)log2(1<<6) << endl;\n\tcerr << (int)log2(1<<7) << endl;\n\tcerr << (int)log2(1<<8) << endl;\n\tcerr << (int)log2(1<<9) << endl;\n\tcerr << (int)log2(1<<10) << endl;\n\tcerr << (int)log2(1<<11) << endl;\n\tcerr << (int)log2(1<<12) << endl;\n\tcerr << (int)log2(1<<13) << endl;\n\tcerr << (int)log2(1<<14) << endl;\n\tcerr << (int)log2(1<<15) << endl;\n\tcerr << (int)log2(1<<16) << endl;\n\tcerr << (int)log2(1<<17) << endl;\n\tcerr << (int)log2(1<<18) << endl;\n\tcerr << (int)log2(1<<19) << endl;*/\n\tres=(int)log2(res);printf(\"%d\\n\",res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n#define INT long long\n#define MOD 1000000007\nusing namespace std;\nINT n, d;\nvector<INT> g[100010];\nint solve(int x)\n{\n    int chk[100010] = {0};\n    int ret = x;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        ret = v;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return ret;\n}\nint f(int x, int y)\n{\n    int chk[100010] = {0};\n    int ret = 0;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        if( v == y ) return chk[v]-1;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n;\n    for(int i = 1 ; i < n ; i++ )\n    {\n        INT a, b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int v = solve(1);\n    int w = solve(v);\n    int d = f(v, w);\n    cout<<(d+1)/2-1<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int K=20;\nconst int N=1e6;\nint n,head[N+10],tot=0;\nstruct data {\n    int next,num;\n}edge[N+10];\nvoid Add(int u,int v) {\n    edge[++tot].next=head[u];\n    edge[tot].num=v;\n    head[u]=tot;\n}\nint dfs(int x,int fat) {\n    int nowx=0,maxbit=-1;\n    for (int i=head[x];i!=-1;i=edge[i].next) {\n        int kx=edge[i].num;\n        if (kx==fat) continue;\n        int nowv=dfs(kx,x);\n        for (int j=0;j<=K;j++)\n            if ((nowv&(1<<j))&&(nowx&(1<<j)))\n                maxbit=max(maxbit,j);\n        nowx|=nowv;\n    }\n    for (int j=0;j<=maxbit;j++)\n        if (nowx&(1<<j)) nowx^=(1<<j);\n    for (int j=maxbit+1;j<=K;j++)\n        if ((nowx&(1<<j))==0) {\n            nowx|=(1<<j);\n            return nowx;\n        }\n        else nowx^=(1<<j);\n    return 233;\n}\nint main() {\n    memset(head,-1,sizeof(head));\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++) {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        Add(u,v);\n        Add(v,u);\n    }\n    int ans=dfs(1,-1);\n    for (int i=K;i>=0;i--)\n        if (ans&(1<<i)) {\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\nconst int N=100500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint B[2*N][2],A[N],B0;\nint dp[N];\nbool z[N];\nvoid link(int q,int w)\n{\n\tB[++B0][0]=A[q],A[q]=B0,B[B0][1]=w;\n\tB[++B0][0]=A[w],A[w]=B0,B[B0][1]=q;\n}\nvoid dfsf(int q,int c,int fa)\n{\n\tdp[q]=1;\n\tefo(i,q)if(B[i][1]!=fa&&!z[B[i][1]])dfsf(B[i][1],c+1,q),dp[q]=max(dp[q],dp[B[i][1]]+1);\n}\nint zx,zx1;\nvoid dfs(int q,int mx,int fa)\n{\n\tint mx1=0,mxz=0;\n\tefo(i,q)if(B[i][1]!=fa&&!z[B[i][1]])\n\t{\n\t\tif(dp[B[i][1]]>mx)mx1=mx,mx=dp[B[i][1]],mxz=B[i][1];\n\t\telse if(dp[B[i][1]]>mx1)mx1=dp[B[i][1]];\n\t}\n\tif(zx1>mx)zx1=mx,zx=q;\n\tefo(i,q)if(B[i][1]!=fa&&!z[B[i][1]])dfs(B[i][1],(mxz==B[i][1]?mx1:mx),q);\n}\nvoid divide(int q,int ansc)\n{\n\tans=max(ans,ansc);\n\tdfsf(q,1,0);zx1=1e9;\n\tdfs(q,0,0);q=zx;\n\tz[q]=1;//printf(\"%d\\n\",q);\n\tefo(i,q)if(!z[B[i][1]])divide(B[i][1],ansc+1);\n}\nint main()\n{\n\tint q,w;\n\tread(n);\n\tfo(i,1,n-1)read(q),read(w),link(q,w);\n\tdivide(1,0);\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n;\nvector<vector<ll>> v(111111);\nll mp[111111];\n\nll dfs(ll s,ll pre){\n\tll ret = 0;\n\tvector<ll> tmp;\n\tREP(i,v[s].size()){\n\t\tif(v[s][i] != pre){\n\t\t\ttmp.PB(dfs(v[s][i],s));\n\t\t\tret |= tmp[tmp.size()-1];\n\t\t}\n\t}\n\t\n\tif(tmp.size() == 0){\n\t\treturn mp[s] = 1;\n\t}\n\tll cou = 60;\n\tfor(;cou > 0;cou--){\n\t\tint flag = 0;\n\t\tREP(i,tmp.size()){\n\t\t\tif(tmp[i] & (1LL << cou))flag++;\n\t\t}\n\t\tif(flag > 1)break;\n\t}\n\t\n\tfor(;;cou++){\n\t\tif(!(ret & (1LL <<cou))){\n\t\t\tret |= (1LL << cou);\n\t\t\tret &= ((1LL << 60)-1) - ((1LL << cou) - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mp[s] = ret;\n}\n\nint main(){\n\t\n\tcin >> n;\n\tREP(i,n-1){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv[a].PB(b);\n\t\tv[b].PB(a);\n\t}\n\t\t\n\tll ans = dfs(0,-1);\n\tfor(ll i = 60;i >= 0;i--){\n\t\tif(ans & (1LL << i)){\n\t\t\tcout << i << endl;\n\t\t\t//return 0;\n\t\t\tbreak;\n\t\t}\n\t}\t\n\t\n\t/*\n\tREP(i,n){\n\t\tREP(j,10){\n\t\t\tcout << ((mp[i] & (1LL << j)) > 0) << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconst int maxSize=4000;\nvector<int> graph[maxSize];\nint amount, dp[maxSize];\nbool visited[maxSize];\n/*\ntemplate<typename Type>\nvoid showContent(Type input)\n{\n\tfor(int i=0; i<=20; ++i)\n\t{\n\t\tcout<<input[i]<<\", \";\n\t}\n\treturn;\n}\n*/\nvoid fillingGraph()\n{\n\tcin>>amount;\n\tint vertex0, vertex1;\n\tfor(int i=1; i<=amount; ++i)\n\t{\n\t\tcin>>vertex0>>vertex1;\n\t\tgraph[vertex0].push_back(vertex1);\n\t\tgraph[vertex1].push_back(vertex0);\n\t}\n\treturn;\n}\nint dfs(int current, int parent)\n{\n\tint value=1;\n\tvisited[current]=true;\n\tfor(int next : graph[current])\n\t{\n\t\tif(!visited[next])\n\t\t{\n\t\t\tint firstResult=dfs(next, current);\n\t\t\tvalue+=firstResult;\n\t\t}\n\t}\n\tdp[current]=value;\n\treturn value;\n}\nint main()\n{\n\tfillingGraph();\n\tint result=dfs(1, -1);\n\tint answer = 0;\n\twhile((1<<answer)<=result)\n\t{\n\t\tanswer++;\n\t}\n\tcout<<endl<<(answer-1);\n  \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Wrong answer on test inf.\n#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define per(i,x,y) for (int i=(x);i>=(y);i--)\n#define ll long long\n#define inf 1000000001\n#define y1 y1___\nusing namespace std;\nchar gc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\nll read(){\n\tchar ch=gc();ll x=0;int op=1;\n\tfor (;!isdigit(ch);ch=gc()) if (ch=='-') op=-1;\n\tfor (;isdigit(ch);ch=gc()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn x*op;\n}\n#define N 100005\nint n,cnt,head[N],bit[N][25],ans;\nstruct edge{int to,nxt;}e[N<<1];\nvoid adde(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid dfs(int u,int pr){\n\tfor (int i=head[u];i;i=e[i].nxt) if (e[i].to!=pr){\n\t\tint v=e[i].to;\n\t\tdfs(v,u);\n\t\trep (j,0,20) bit[u][j]+=bit[v][j];\n\t}\n\tint Min=0;\n\tper (i,20,0) if (bit[u][i]>=2){Min=i+1;break;}\n\twhile (bit[u][Min]) Min++;\n\tans=max(ans,Min);\n\tbit[u][Min]=1;\n\trep (i,0,Min-1) bit[u][i]=0;\n}\nint main(){\n\tn=read();\n\trep (i,1,n-1){\n\t\tint x=read(),y=read();\n\t\tadde(x,y);adde(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=200010;\nint i,j,k,n,m,x,y,t,b[20];\nint fi[N*2],ne[N*2],la[N*2],a[N*2],w[N];\nint f[N][20],g[N][20];\nvoid add(int x,int y){\n\tk++;a[k]=y;\n\tif (fi[x]==0)fi[x]=k;else ne[la[x]]=k;\n\tla[x]=k;\n}\nvoid dfs(int x,int fa){\n\tfor (j=0;j<20;j++)f[x][j]=1;\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa){\n\t\tdfs(a[i],x);\n\t\tfor (j=0;j<20;j++)f[x][j]&=f[a[i]][j],g[x][j]+=g[a[i]][j];\n\t}\n\tmemset(b,0,sizeof b);\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa)\n\t\tfor (int j=0;j<20;j++)\n\t\t\tif (g[a[i]][j]&&!f[a[i]][j])\n\t\t\t\tb[j]++;\n\tfor (j=19;j>=0;j--)if (b[j]>1){\n\t\tfor (k=j;k<20;k++)if (f[x][k]){w[x]=k;break;}\n\t\tbreak;\n\t}\n\tif (!w[x]){for (j=0;j<20;j++)if (f[x][j]){w[x]=max(w[x],j);break;}}\n\tf[x][w[x]]=0;g[x][w[x]]++;\n\tfor (j=0;j<w[x];j++)f[x][j]=1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,-1);\n\tint ans=0;\n\tfor (i=1;i<=n;i++)ans=max(ans,w[i]);\n//\tfor (i=1;i<=n;i++)printf(\"%d \",w[i]);printf(\"\\n\");\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n - 1) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    function<int (int, int)> go = [&](int i, int parent) {\n        vector<int> qs;\n        int sum_q = 0;\n        for (int j : g[i]) if (j != parent) {\n            int q = go(j, i);\n            qs.push_back(q);\n            sum_q |= q;\n        }\n        int sum_and_q = 0;\n        repeat (x, qs.size()) repeat (y, x) sum_and_q |= qs[x] & qs[y];\n        int p = 1;\n        while (p <= sum_and_q or sum_q & p) p <<= 1;\n        return (sum_q & ~ (p - 1)) | p;\n    };\n    int p = go(0, -1);\n    int k = 31 - __builtin_clz(p);\n    // output\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _LOCAL_\n\t#define cout cerr\n#endif\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define FORalld(it, a) for (__typeof((a).rbegin()) it = (a).rbegin(); it != (a).rend(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ntemplate<class T> inline T isqrt(T k) {T r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ntemplate<class T> inline T icbrt(T k) {T r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n\nconst int maxn = 100000 + 5;\nint n;\nvi adj[maxn];\n\nint dfs(int u, int p = -1) {\n\tint res = 0;\n\tint cnt[30] = {}, mx = 0;\n\tFOR(i, 0, sz(adj[u])) {\n\t\tint v = adj[u][i];\n\t\tif (v != p) {\n\t\t\tint r = dfs(v, u);\n\t\t\tres |= r;\n\t\t\tFOR(j, 0, 30) {\n\t\t\t\tif (bit(r, j)) {\n\t\t\t\t\tcnt[j]++;\n\t\t\t\t}\n\t\t\t\tif (cnt[j] > 1) chkmax(mx, j + 1);\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i, mx, 30) if (!bit(res, i)) {\n\t\tFOR(j, 0, i) res |= 1 << j, res ^= 1 << j;\n\t\tres |= 1 << i;\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> n;\n\tFOR(i, 0, n - 1) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tcout << __lg(dfs(0)) << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst ll mask = 0xAAAAAAAA;\nint n, ans;\nvector<vi> e;\nll rec(int c, int p){\n\tll s = 0, t = 0;\n\tfor(int i : e[c]) if(i != p){\n\t\tll x = rec(i, c);\n\t\ts |= x;\n\t\tt += x;\n\t\tt &= ~((t & mask) >> 1);\n\t}\n\tt &= mask;\n\tint l = t ? 64 - __builtin_clzll(t) : 0;\n\tl = __builtin_ctzll((s | (s & ~mask) << 1 | (1ll << l) - 1) + 1);\n\t\n\tans = max(ans, l / 2);\n\ts |= 1ll <<l;\n\ts &= ~((1ll << l) - 1);\n\treturn s;\n}\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tscanf(\"%d\", &n);\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; scanf(\"%d%d\", &a, &b); a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\trec(0, 0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n;\nvector<int> g[maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    v--;\n    u--;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  return true;\n}\n\nint dfs(int v, int p) {\n  int msk = 0;\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (u == p) {\n      continue;\n    }\n    msk |= dfs(u, v);\n  }\n  return msk + 1;\n}\n\nvoid solve() {\n  printf(\"%d\\n\", (31 - __builtin_clz(dfs(0, -1))));\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {//cerr << \"solving \" << v + 1 << '\\n';\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tif(vec.size() == 1)\n\t\treturn 0;\n\tfind_up(v);\n\t//for (int u: vec)\n\t//\tcerr << u + 1 << \" -> \" << up[u] << ' ' << down[u] << '\\n';\n\tint mini = N, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\t//cerr << mini << \" cen = \" << cen + 1 << '\\n';\n\tmark[cen] = true;\n\tint maxi = 0;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nconst int MAXN = 100 * 1000 + 23, MXLN = 17 + 3;\n\n\n\n\n\n\n\n\n\n\n\nint n, mx, dp[MAXN], cnt[MAXN][MXLN];\nvector<int> g[MAXN];\n\n\nvoid dfs(int v = 0, int p = -1) {\n\tfor (auto u : g[v]) if (u != p) {\n\t\tdfs(u, v);\n\t\tdp[v] |= dp[u];\n\t\tfor (int i = 0; i < MXLN; i++) cnt[v][i] += ((dp[u] >> i) & 1);\n\t}\n\tint e = 1, b = -1, f = 1;\n\tfor (int i = 0; i < MXLN; i++) {\n\t\tif (cnt[v][i] > 1) {\n\t\t\te = 1;\n\t\t\tb = i;\n\t\t\tf = 1;\n\t\t}\n\t\tif (cnt[v][i]) e += f;\n\t\telse f = 0;\n\t}\n\tb += e;\n\tdp[v] &= (((1 << MXLN) - 1) ^ ((1 << b) - 1));\n\tdp[v] |= (1 << b);\n\tmx = max(mx, b);\n}\n\n\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[--u].push_back(--v), g[v].push_back(u);\n\t}\n\tdfs();\n\tcout << mx;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=2e5;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint head[N],nxt[N],to[N];\nint D,rt;\ninline void dfs(int k,int fa,int s) {\n\tif (s>D) D=s,rt=k;\n\tfor (int i=head[k];i;i=nxt[i])\n\t\tif (to[i]!=fa) dfs(to[i],k,s+1);\n}\nint main()\n{\n\tint n=gi(),i,k,a,b,tot=0;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi();\n\t\tto[++tot]=b,nxt[tot]=head[a],head[a]=tot;\n\t\tto[++tot]=a,nxt[tot]=head[b],head[b]=tot;\n\t}\n\tdfs(1,0,0);\n\tD=0;\n\tdfs(rt,0,0);\n\tk=0;\n\twhile (D)\n\t\tk++,(--D)>>=1;\n\tprintf(\"%d\\n\",k);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 101000;\n\nint n, f[N][61];\n\nstruct Edge\n{\n    int nxt, to;\n} eg[N << 1];\nint head[N], en;\n\nvoid setEdge(int u, int v)\n{\n    eg[++en] = (Edge) {head[u], v};\n    head[u] = en;\n}\n\nvoid dfs(int u, int fa)\n{\n    for (int e = head[u]; e; e = eg[e].nxt)\n    {\n        int v = eg[e].to;\n        if (v == fa) continue;\n        dfs(v, u);\n        for (int i = 0; i <= 60; i++)\n            f[u][i] += f[v][i];\n    }\n    for (int i = 0; i <= 60; i++)\n        if (f[u][i] == 0)\n        {\n            f[u][i] = 1;\n            for (int j = 0; j < i; j++)\n                f[u][j] = 0;\n            for (int j = i + 1; j <= 60; j++)\n                if (f[u][j]) f[u][j] = 1;\n            break;\n        }\n}\n\nint main()\n{\n    n = read();\n    for (int i = 1; i < n; i++)\n    {\n        int u = read(), v = read();\n        setEdge(u, v);\n        setEdge(v, u);\n    }\n    dfs(1, 0);\n    for (int i = 60; i >= 0; i--)\n        if (f[1][i])\n        {\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nint bsr(int x) { return 31 - __builtin_clz(x); }\nbool B(int x,int i){return (x>>i)&1;}\nconst int MN = 100000;\nint N;\nvector<int> G[MN];\nint dfs(int v,int p=-1){\n\tint b[20]={};\n\tfor(int u:G[v]) if(u!=p){\n\t\tint tmp=dfs(u,v);\n\t\trep(i,20) if(B(tmp,i)) b[i]++;\n\t}\n\tint ret=1e9;\n\tfor(int i=19;i>=0;i--){\n\t\tif(b[i]>=2) break;\n\t\tif(b[i]==0){\n\t\t\tint x=0;\n\t\t\tfor(int j=19;j>i;j--) if(b[j]) x|=1<<j;\n\t\t\tx|=1<<i;\n\t\t\tret=x;\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>N;\n\trep(i,N-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tint tmp=dfs(0);\n\tcout<<bsr(tmp)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 1000010\n#define MAXD 21\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1];\n\nint n;\nint g[MAXN],nume;\nint f[MAXN][MAXD];\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid dfs(int x,int p){\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p)\n\t\t\tdfs(e[i].to,x);\n\tstatic int cnt[MAXD];\n\tmemset(cnt,0,sizeof cnt);\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p)\n\t\t\tfor(int j=0;j<MAXD;j++)\n\t\t\t\tif(f[e[i].to][j])\n\t\t\t\t\tcnt[j]++;\n\tint pos=MAXD-1;\n\twhile(pos>=0 && cnt[pos]<=1) pos--;\n\twhile(cnt[++pos]);\n\tf[x][pos]=1;\n\tfor(int i=pos+1;i<MAXD;i++)\n\t\tf[x][i]=cnt[i];\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"D.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\tfor(int i=MAXD-1;i>=0;i--)\n\t\tif(f[1][i]){\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn 0;\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nvector<vector<int> > G;\nvector<vector<int> > T;\nvector<int> V;\n\nvoid build(int a, int p) {\n    for (int i = 0;i < G[a].size();i++) {\n        if (G[a][i] == p) continue;\n        T[a].push_back(G[a][i]);\n        build(G[a][i], a);\n    }\n    return;\n}\n\nint cal(int n) {\n    if (V[n] != 0) return V[n];\n    if (T[n].size() == 0) return 1;\n    int v = 0;\n    for (int i = 0;i < T[n].size();i++) {\n        v = (v | cal(T[n][i]));\n    }\n    int x = 1;\n    for (int i = 0;i < 31;i++) {\n        if ((x & v) == 0) {\n            int num = (x | v);\n            int y = 1;\n            for (int j = 0;j < i;j++) {\n                if (num & y) num -= y;\n                y *= 2;\n            }\n            V[n] = num;\n            return num;\n        }\n        x *= 2;\n    }\n    return 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    G.resize(N);\n    for (int i = 1;i < N;i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    T.resize(N);\n    build(0, -1);\n    V.resize(N, 0);\n    int v = cal(0);\n    int x = 1;\n    int sol = 0;\n    for (int i = 0;i < 31;i++) {\n        if (v & x) sol = i;\n        x *= 2;\n    }\n    cout << sol << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nint i,j,k,n,m,x,y,t,b[20];\nint fi[N*2],ne[N*2],la[N*2],a[N*2],w[N];\nint f[N][20],g[N][20];\nvoid add(int x,int y){\n\tk++;a[k]=y;\n\tif (fi[x]==0)fi[x]=k;else ne[la[x]]=k;\n\tla[x]=k;\n}\nvoid dfs(int x,int fa){\n\tw[x]=1;g[x][1]=1;\n\tfor (j=1;j<20;j++)f[x][j]=1;\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa){\n\t\tdfs(a[i],x);\n\t\tfor (j=1;j<20;j++)f[x][j]&=f[a[i]][j],g[x][j]|=g[a[i]][j];\n\t}\n\tfor (j=1;j<20;j++)if (f[x][j]){w[x]=j;break;}\n\tfor (int i=1;i<w[x];i++)f[x][i]=1;g[x][w[x]]=1;f[x][w[x]]=0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,-1);\n\tint ans=0;\n\tfor (i=1;i<=n;i++)ans=max(ans,w[i]);\n//\tfor (i=1;i<=n;i++)printf(\"%d \",w[i]);printf(\"\\n\");\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nenum {\n  MAXN = 100000 + 5\n};\n\ntypedef std::vector<int> vi;\n\nint n;\nvi e[MAXN];\nint deep[MAXN];\n\nint dfs(int u, int pa) {\n  int res(u), t;\n  if (!~pa) deep[u] = 0;\n  for (int v: e[u]) {\n    if (v != pa) {\n      deep[v] = deep[u]+1;\n      t = dfs(v, u);\n      if (deep[t] > deep[res])\n\tres = t;\n    }\n  }\n  return res;\n}\n\nint calc(int x) {\n  if (x == 0) return 1;\n  return calc((x-1)/2) + 1;\n}\n\nvoid exec() {\n  int i, u, v, dis;\n  scanf(\"%d\", &n);\n  for (i=0; i<n-1; ++i) {\n    scanf(\"%d%d\", &u, &v), --u, --v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  v = dfs(u = dfs(0, -1), -1);\n  dis = deep[v];\n  printf(\"%d\\n\", calc(dis)-1);\n}\n\nint main() {\n  if (fopen(\"D.in\", \"r\") != NULL) {\n    freopen(\"D.in\", \"r\", stdin);\n    freopen(\"D.out\", \"w\", stdout);\n  }\n  exec();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\nint lst[100005], to[200005], pre[200005], app[100005][25], tot, ans;\ninline void add_edge(int u, int v)\n{\n\tto[tot] = v; \n\tpre[tot] = lst[u];\n\tlst[u] = tot++;\n}\nvoid dfs(int u, int fa = -1)\n{\n\tfor (int i = lst[u]; ~i; i = pre[i])\n\t{\n\t\tif (to[i] != fa)\n\t\t{\n\t\t\tdfs(to[i], u);\n\t\t\tfor (int j = 0; j < 20; j++)\n\t\t\t\tapp[u][j] += app[to[i]][j];\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 19; i >= 0; i--)\n\t{\n\t\tif (app[u][i] > 1)\n\t\t{\n\t\t\tres = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (app[u][res])\n\t\tres++;\n\tfor (int j = 0; j < res; j++)\n\t\tapp[u][j] = 0;\n\tapp[u][res]++;\n\tif (res > ans)\n\t\tans = res;\n}\nint main()\n{\n\t// freopen(\"AGC009-D.in\", \"r\", stdin);\n\tmemset(lst, -1, sizeof(lst));\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd_edge(--u, --v);\n\t\tadd_edge(v, u);\n\t}\n\tdfs(0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N;\nint a[110000], b[110000];\nvint G[110000];\nbool centroid[110000];\nint sos[110000];\n\nint size_of_subtree(int v, vector<bool>& used, int p) {\n    int ret = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || used[cur] || cur == p)continue;\n        ret += size_of_subtree(cur, used, v);\n    }\n    return sos[v] = ret;\n}\n\nint search_centroid(int v, int t, vector<bool>& used) {\n    if (used[v])return -1;\n    int p = -1;\n    while (true) {\n        int ch, s = 0;\n        for (int i = 0; i < G[v].size(); i++) {\n            int cur = G[v][i];\n            if (centroid[cur] || used[cur] || cur == p)continue;\n            if (s <= sos[cur])s = sos[cur], ch = cur;\n        }\n        if (s <= t / 2)break;\n        p = v;\n        v = ch;\n    }\n    return v;\n}\n\nint u(int v) {\n    vector<bool> used(N);\n    int ret = LLONG_MAX;\n    while (true) {\n        size_of_subtree(v, used, -1);\n        int cidx = search_centroid(v, sos[v], used);\n        if (cidx == -1)return ret;\n        centroid[cidx] = true;\n        used[cidx] = true;\n        int mu = -1, m2 = -1;\n        for (int i = 0; i < G[cidx].size(); i++) {\n            if (centroid[G[cidx][i]])continue;\n            int cu = u(G[cidx][i]);\n\n            if (mu <= cu)m2 = mu, mu = cu, v = G[cidx][i];\n        }\n        ret = min(ret, mu + 1);\n        centroid[cidx] = false;\n        if (mu == m2) return ret;\n    }\n}\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++)cin >> a[i] >> b[i], a[i]--, b[i]--, G[a[i]].push_back(b[i]), G[b[i]].push_back(a[i]);\n    cout << u(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100009\nusing namespace std;\n\nint n,ans,tot,fst[N],pnt[N<<1],nxt[N<<1],fa[N],tg[N];\nvoid add(int x,int y){\n\tpnt[++tot]=y; nxt[tot]=fst[x]; fst[x]=tot;\n}\nvoid dfs(int x){\n\tint i,j,tmp,y;\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (y!=fa[x]){\n\t\t\tfa[y]=x; dfs(y);\n\t\t\ttmp=tg[x]&tg[y];\n\t\t\tfor (j=1; j<=tmp; j<<=1) tg[x]|=j;\n\t\t\ttg[x]|=tg[y];\n\t\t}\n\t}\n\tfor (i=1; tg[x]&i; i<<=1) tg[x]^=i;\n\ttg[x]|=i;\n\tans=max(ans,tg[x]);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,x,y;\n\tfor (i=1; i<n; i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tdfs(1);\n\tfor (i=-1; ans; ans>>=1) i++;\n\tprintf(\"%d\\n\",i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1 << 18;\nint col[N], ans, n;\nvector<int> G[N];\nvoid DFS(int v = 1, int par = 0) {\n\tint mx = 0, b = 0;\n\tfor (auto u : G[v])\n\t\tif (u ^ par) {\n\t\t\tDFS(u, v);\n\t\t\tmx |= col[v] & col[u];\n\t\t\tcol[v] |= col[u];\n\t\t}\n\twhile ((1 << b) <= mx || col[v] & (1 << b))\n\t\tb ++;\n\tans = max(ans, 31 - __builtin_clz(col[v] = col[v] & ~((1 << b) - 1) | (1 << b)));\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, v, u; i < n; i ++) {\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tDFS();\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 100 * 1000 + 10;\n\nvector<int> g[N];\nint diam;\n\nint dfs(int v, int p) {\n    int mx = 0; \n    for (int to : g[v])\n        if (to != p) {\n            int h = dfs(to, v) + 1;\n            diam = max(diam, h + mx);\n            mx = max(mx, h);\n        }\n    return mx;\n}\n\nint f(int h) {\n    return (1 << (h + 1)) - 1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);    \n    }\n    dfs(0, 0);\n    int h = 0;\n    diam++;\n    while (f(h) < diam)\n        h++;\n    cout << h << endl;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct node {\n\tint to, next;\n} edge[MAXN*2];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nint n, a, b;\nint vis[MAXN], depth[MAXN], fa[MAXN];\nint len = 0, pos = 0;\n\nvoid dfs_len(int nd, int f)\n{\n\tfa[nd] = f;\n\tif (depth[nd] > len) len = depth[nd], pos = nd;\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (to == f || vis[to]) continue;\n\t\tdepth[to] = depth[nd]+1;\n\t\tdfs_len(to, nd);\n\t}\n}\n\nint find_center(int nd)\n{\n\tlen = 0, pos = 0, depth[nd] = 0, dfs_len(nd, 0);\n\tint cur = pos;\n\tlen = 0, pos = 0, depth[cur] = 0, dfs_len(cur, 0);\n\tfor (int i = 1; i <= len/2; i++)\n\t\tpos = fa[pos];\n\treturn len;\n}\n\nint lg[MAXN];\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpush(a, b), push(b, a);\n\t}\n\tint len = find_center(1);\n\tlg[1] = 0;\n\tfor (int i = 2; i <= n; i++) lg[i] = lg[i>>1]+1;\n\tcout << lg[len] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//¹Ø¼üÐÔÖÊ£ºÁ½¸öÉî¶ÈÏàÍ¬µÄµãµÄÂ·¾¶ÉÏ±ØÓÐÒ»¸öÉî¶È¸üÐ¡µÄµã \n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN=1e5+5;\n\nint N,Ans;\nint Cnt[MaxN][20];\n\nvector<int> To[MaxN];\n\nvoid DFS(int u,int fa){\n\tint i,k;\n\tfor(auto v:To[u])\n\t\tif(v^fa){\n\t\t\tDFS(v,u);\n\t\t\tfor(i=0;i<20;i++)\n\t\t\t\tCnt[u][i]+=Cnt[v][i];\n\t\t}\n\tfor(i=20;~i;i--)\n\t\tif(Cnt[u][i]>2){\n\t\t\tk=i+1;\n\t\t\tbreak;\n\t\t}\n\tfor(;Cnt[u][k];k++);\n\tAns=max(Ans,k);\n\tfor(i=0;i<k;i++)\n\t\tCnt[u][i]=0;\n\tCnt[u][k]++;\n}\n\nint main(){\n\tint i,u,v;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tTo[u].push_back(v);\n\t\tTo[v].push_back(u);\n\t}\n\tDFS(1,0);\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\nconst int maxn = 100010;\n#define pb push_back\n\nvi g[maxn];\n\nint dp[maxn];\nint c[maxn];\nint bt[1024 + 2];\n\nint low_bit(int x) { return x & -x; }\nint lg(int x) { return x >= 1024 ? 10 + lg(x >> 10) : bt[x]; }\n\nvoid dfs(int u,int par) {\n\tint &val = dp[u];\n\tval = 0;\n\tfor(auto v: g[u]) if(v != par) {\n\t\tdfs(v, u);\n\t\tval |= dp[v];\n\t}\n\tc[u] = lg(low_bit(~val));\n\tval ^= val & ((2 << c[u]) - 1);\n\tval |= 1 << c[u];\n}\n\nint main() {\n\tfor(int i = 0; i <= 10; ++i) bt[1 << i] = i;\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v); g[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tcout << *max_element(c + 1, c + n + 1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n}\nint n;\nvector<int>E[N];\n#define pb push_back\nvoid input()\n{\n\tint x,y;\n\tn=read<int>();\n\tFor(i,2,n)\n\t{\n\t\tx=read<int>(),y=read<int>();\n\t\tE[x].pb(y),E[y].pb(x);\n\t}\n}\nint dp[N],s[N],ans;\nvoid DP(int u,int pre)\n{\n\tint p=0;\n\tfor(int v:E[u])if(v^pre)\n\t{\n\t\tDP(v,u);\n\t\tp|=s[u]&s[v];\n\t\ts[u]|=s[v];\n\t}\n\twhile((1<<dp[u])<=p||((1<<dp[u])&s[u]))dp[u]++;\n\tcmax(ans,dp[u]);\n\t//cerr<<u<<' '<<s[u]<<endl;\n\ts[u]=(s[u]>>dp[u]<<dp[u])|(1<<dp[u]);\n}\nvoid work()\n{\n\tDP(1,0);\n\twrite(ans,'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=11e4,M=N<<1;\n\nint f[N],fa[N];\nint ne[M],lb[M],la[N];\nint n,oo;\n\ninline void llb(int a,int b)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b;}\n \ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+ch-48;\n\treturn o;\n} \n\nvoid dfs(int o)\n{\n\tint u=0;\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o,dfs(lb[y]);\n\t\tu|=(f[o]&f[lb[y]]);\n\t\tf[o]|=f[lb[y]];\n\t}\n\tint k=1;\n\twhile(k<=u||(f[o]&k)>0)f[o]^=(k&f[o]),k<<=1;\n\tf[o]^=k;\n}\n\nint main()\n{\n\tcin>>n; int a,b;\n\tfo(i,1,n-1)a=read(),b=read(),llb(a,b),llb(b,a);\n\tfa[1]=-1; dfs(1);\n\tint k=1,p=0;\n\twhile(k<f[1])k<<=1,++p;\n\tcout<<p-1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tmemset(down, 0, sizeof down);\n\tmemset(up, 0, sizeof up);\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = N, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\nconst int N=1e5+5;\nint n;\n\ninline int nxi(){\n\tint x=0;\n\tchar c;\n\twhile((c=getchar())>'9'||c<'0');\n\twhile(x=x*10-48+c,(c=getchar())>='0'&&c<='9');\n\treturn x;\n}\n\ninline int hbit(int x){\n\tint ans=0;\n\tfor(int i=16; i; i>>=1){\n\t\tif(x>>i) x>>=i,ans+=i;\n\t}\n\treturn ans;\n}\n\nnamespace G{\n\tint cnt,ans,fir[N];\n\tstruct edge{\n\t\tint to,nx;\n\t}eg[N<<1];\n\n\tinline void add(const int a,const int b){\n\t\teg[++cnt]=(edge){b,fir[a]};\n\t\tfir[a]=cnt;\n\t}\n\n\tinline int dfs(const int x,const int fa){\n\t\tint cand=0,cor=0;\n\t\tfor(int i=fir[x]; i; i=eg[i].nx){\n\t\t\tconst int y=eg[i].to;\n\t\t\tif(y!=fa){\n\t\t\t\tint tmp=dfs(y,x);\n\t\t\t\tcand|=cor&tmp;\n\t\t\t\tcor|=tmp;\n\t\t\t}\n\t\t}\n\t\tint ans=-1;\n\t\tfor(int i=0; i<30; ++i){\n\t\t\tif(!(cand>>i)&&!(cor>>i&1)){\n\t\t\t\tans=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint tmp=((1<<30)-1)^((1<<ans)-1);\n\t\tassert(~ans);\n\t\treturn (cor&tmp)|1<<ans;\n\t}\n}\n\nint main(){\n\tn=nxi();\n\tfor(int i=1; i<n; ++i){\n\t\tconst int a=nxi(),b=nxi();\n\t\tG::add(a,b);\n\t\tG::add(b,a);\n\t}\n\tprintf(\"%d\\n\",hbit(G::dfs(1,0)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nth_bit(int64_t num, int n){\n    return (num >> n) & 1;\n}\n\nint N;\nvector<int> edges[100000];\n\nint dfs(int i, int p){\n    vector<int> values;\n    for(int j : edges[i]) if(j != p) values.push_back(dfs(j, i));\n\n    int myvalue = -1;\n    for(int k=0; k<30; k++){\n        int num = 0;\n        for(int n : values) if(nth_bit(n, k)) num++;\n        if(num >= 2){\n            myvalue = -1;\n        }else if(num == 0 && myvalue == -1){\n            myvalue = 1<<k;\n        }\n    }\n    int ret = myvalue;\n    for(int n : values) ret |= n;\n    ret = ret / myvalue * myvalue;\n    return ret;\n}\n\nint main(){\n    cin >> N;\n    for(int i=0; i<N-1; i++){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    int ret = dfs(0, -1);\n    for(int k=29; k>=0; k--) if(nth_bit(ret, k)){\n        cout << k << endl;\n        return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  \n  function<Int(Int, Int)> dfs=[&](Int v,Int p){\n    Int one=0,two=0;\n    for(Int u:G[v]){\n      if(u==p) continue;\n      Int tmp=dfs(u,v);\n      two|=(one&tmp);\n      one|=tmp;\n    }\n    Int res=1;\n    while(res<=two||(one&res)) res<<=1;\n    return (one&~(res-1))|res;\n  };\n  \n  Int res=dfs(0,-1);\n  Int ans=31-__builtin_clzll(res);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint N;\nvector<int> G[100010];\n\npii DFS(int v,int p)\n{\n    pii res = pii(0,v);\n    for(int i = 0; i < G[v].size(); i++)if(G[v][i] != p)\n        res = max(res,DFS(G[v][i],v));\n\n    return pii(res.first + 1,res.second);\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    pii MAX = DFS(1,0);\n\n    MAX = DFS(MAX.second,0);\n\n    int now = 1;\n\n    for(int i = 0; i < N; i++)\n    {\n        if(MAX.first <= now)\n        {\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n        now = now * 2 + 1;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 200055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,fa[N],ans;\nbitset <32> a[N],b[N];\nint nedge,Next[N*2],head[N],to[N*2];\n#define V to[i]\nvoid add(int a,int b){\n\tNext[++nedge]=head[a];head[a]=nedge;to[nedge]=b;\n}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tgo(i,x){\n\t\tif (fa[x]==V) continue;\n\t\tfa[V]=x;dfs(V);b[x]|=(a[x]&a[V]);a[x]|=a[V];\n\t}\n\tint num=0;\n\tF(i,0,30) if (b[x][num]) num=i+1;\n\twhile (a[x][num]) num++;\n\ta[x][num]=1;\n\tans=max(ans,num);\n\tF(i,0,num-1) a[x][i]=0;\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n-1) add_ne(read(),read());\n\tdfs(1);\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nconst int N = 100010;\nint n;\n\nstruct edge{ int to, pre; }e[N << 1]; int u[N], l = 0;\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\n\nint w[N];\nvoid dfs(int x, int f) {\n\tint least = (1<<20)-1, vis = 0, c = 0;\n\treg(i,x) if (v != f) dfs(v, x), least &= w[v], vis |= w[v], c++;\n\tif (c <= 1) least = 0;\n\tint t = 0;\n\tdep(j,19,0) if (least >> j & 1) break; else if (!(vis >> j & 1)) t = j;\n\tw[x] = 1 << t; rep(j,t+1,19) w[x] |= vis & (1 << j);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n - 1) { int a, b; scanf(\"%d%d\",&a,&b); ins(a, b), ins(b, a); }\n\tdfs(1,0);\t\n\tdep(j,19,0) if (w[1] >> j & 1) { printf(\"%d\\n\",j); break; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nvector<int> graph[limit];\n\n\nint opr(vector<int> val){\n\tint last = -1;\n\n\trep(i, 30){\n\t\tif(val[i] >= 2){\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tint start = 30;\n\trep(i, last + 1, 30){\n\t\tif(val[i] == 0){\n\t\t\tstart = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tval[start] = 1;\n\trrep(i, start){\n\t\tval[i] = 0;\n\t}\n\n\tint ret = 0;\n\trep(i, 30) if(val[i] > 0) ret |= (1 << i);\n\treturn ret;\n}\n\nint dfs(int v, int p){\n\tvector<int> res(30, 0);\n\n\tfor(auto &v2: graph[v]){\n\t\tif(v2 == p) continue;\n\t\tconst int val = dfs(v2, v);\n\t\trep(i, 30) if(val >> i & 1) res[i]++;\n\t}\n\n\treturn opr(res);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i, n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\n\tconst int val = dfs(0, -1);\n\n\trrep(ans, 30){\n\t\tif(val >> ans & 1) {\n\t\t\tcout << ans << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) \n#endif\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"No\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=5e6+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=1e6+10;\n\t//------------------FIXED------------------\n\tvc<int> to[N];int ans=0,S[N];\n\tvoid solve(int x,int fa)\n\t{\n\t\tint U=0;for(auto y:to[x]) if(y!=fa) solve(y,x),U|=S[x]&S[y],S[x]|=S[y];\n\t\tint c=0;while(S[x]&bin(c) or bin(c)<=U) c++;chmax(ans,c),S[x]=bin(c)|(S[x]-(S[x]&(bin(c+1)-1)));\n\t}\n\tvoid main()\n\t{\n\t\tint n=qread();fo(i,2,n){ int x=qread(),y=qread();to[x].PB(y),to[y].PB(x); }\n\t\tsolve(1,0);write(ans);\n\t}\n};//����������\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//����Ԥ����ģ����\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned int uint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=100010;\ninline uint lowbit(uint x){\n\treturn x&-x;\n}\ninline uint highbit(uint x){\n\tfor(;x!=(x&-x);x^=x&-x);\n\treturn x;\n}\nnamespace T{\n\tconst int E=N<<1;\n\tint to[E],bro[E],head[N],e=0;\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tuint dfs(int x,int fa){\n\t\tuint ans=0,hb=0;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])!=fa){\n\t\t\t\tuint cur=dfs(v,x);\n\t\t\t\tapmax(hb,highbit(cur&ans)<<1);\n\t\t\t\tans|=cur;\n\t\t\t}\n\t\t}\n\t\tapmax(hb,lowbit(~ans));\n\t\treturn hb|(ans&~(hb-1));\n\t}\n}\nint main(){\n\tint n=ni;\n\tT::init();\n\tfor(int i=1;i<n;T::add(ni,ni),i++);\n\tuint tmp=T::dfs(1,0);\n\tint ans=0;\n\tfor(;tmp>1;tmp>>=1,ans++);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(a) (int)(a.size())\n#define ALL(a) a.begin(),a.end()\n#define SET(a,b) memset(a,b,sizeof(a))\n#define MOD 1000000007\n\n#define SI(n) scanf(\"%d\",&n)\n#define PI(n) printf(\"%d\\n\",n)\n#define SL(n) scanf(\"%lld\",&n)\n#define PL(n) printf(\"%lld\\n\",n)\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define TCS() int testcase; SI(testcase);while(testcase--)\n\n\n#define TRACE\n\n#ifdef TRACE\n#define TR(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n    cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n    const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define TR(...)\n#endif\n\n//FILE *fin = freopen(\"in\",\"r\",stdin);\n//FILE *fout = freopen(\"out\",\"w\",stdout);\ntypedef long long int \tLL;\ntypedef long double \tLD;\ntypedef pair<int,int>   II;\ntypedef vector< II >    VII;\ntypedef vector<int>     VI;\n\nconst int N = 100011;\nint n;\nVI gr[N];\nint dp[N][2], dia;\n\nvoid dfs(int v, int p) {\n    int mx1 = 0,mx2 = 0;\n    for(int u : gr[v]) {\n        if(u == p) continue;\n        dfs(u, v);\n        if(dp[u][0] + 1 > mx1) {\n            mx2 = mx1;\n            mx1 = dp[u][0] + 1;\n        }\n        else if(dp[u][0] + 1 > mx2)\n            mx2 = dp[u][0] + 1;\n    }\n    dp[v][0] = mx1, dp[v][1] = mx2;\n    dia = max(dia , mx1 + mx2);\n}\n\nint main() {\n    SI(n);\n    for(int i = 1;i < n; ++i) {\n        int u, v;\n        SI(u), SI(v);\n        gr[u].PB(v), gr[v].PB(u);\n    }\n    dfs(1, 0);\n    PI((dia+1)/2 - 1);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\nusing namespace std; \n\nconst int maxN = 100 * 1000 + 10;\nvector<int> c[maxN]; \n\nint dis[5][maxN]; \n\nvoid dfs( int s , int p , int h , int * dis ) { \n    dis[s] = h; \n    for( auto x : c[s] ) \n        if( x != p ) \n            dfs( x , s , h + 1 , dis ); \n}\n\nint main() { \n    ios::sync_with_stdio(false); \n    int n; cin >> n; \n\n    for( int i = 0 ; i < n - 1 ; i++ ) { \n        int u,v; cin >> u >> v; \n        u--; v--; \n        c[u].push_back( v ); \n        c[v].push_back( u ); \n    }\n\n    dfs( 0 , -1 , 0 , dis[0] ) ; \n    int u = max_element( dis[0] , dis[0] + n ) - dis[0]; \n    dfs( u , -1 , 0 , dis[1] ); \n    int val = ( *max_element( dis[0] , dis[0] + n ) + 1 ) / 2; \n    int z = 0; \n    for( int i = 0 ; ; i++ , z += z + 1 ) \n        if( val <= z ) { \n            cout << i << endl;\n            return 0; \n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n\nint n,head[100010],nxt[200010],b[200010],k,ans;\nvoid push(int s,int t){\n\tnxt[++k]=head[s];\n\thead[s]=k;\n\tb[k]=t;\n}\nstd::set<int>set[100010];\nvoid dfs(int x,int f){\n\tint mx=0;\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(b[i]!=f){\n\t\t\tdfs(b[i],x);\n\t\t\tif(set[b[i]].size()>mx)mx=b[i];\n\t\t}\n\tset[x]=set[mx];\n\tint v=0;\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(b[i]!=mx){\n\t\t\tfor(auto it=set[b[i]].begin();it!=set[b[i]].end();++it)\n\t\t\t\tif(set[x].count(*it)){\n\t\t\t\t\tset[x].erase(*it);\n\t\t\t\t\tv=std::max(v,*it+1);\n\t\t\t\t}\n\t\t\t\telse if(v<=*it){\n\t\t\t\t\tset[x].insert(*it);\n\t\t\t\t}\n\t\t}\n\twhile(set[x].count(v))++v;\n\twhile(!set[x].empty()&&*set[x].begin()<v)set[x].erase(*set[x].begin());\n\tset[x].insert(v);\n//\tprintf(\"%d %d\\n\",x,v);\n\tans=std::max(ans,v);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),push(u,v),push(v,u);\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 100000\nstruct edge{int nx,t;}e[MN*2+5];\nint h[MN+5],en,f[MN+5],v[1<<17];\ninline void ins(int x,int y)\n{\n\te[++en]=(edge){h[x],y};h[x]=en;\n\te[++en]=(edge){h[y],x};h[y]=en;\n}\nint cal(int x){for(int i=17;i;--i)if(x&(1<<i))return i;return -1;}\nvoid dfs(int x,int fa)\n{\n\tint mx=0;\n\tfor(int i=h[x];i;i=e[i].nx)if(e[i].t!=fa)\n\t{\n\t\tdfs(e[i].t,x);\n\t\tmx=max(mx,v[f[x]&f[e[i].t]]+1);\n\t\tf[x]|=f[e[i].t];\n\t}\n\tfor(int i=0;;++i)if(i>=mx&&!(f[x]&(1<<i)))\n\t\t{f[x]=(f[x]|(1<<i))&((-1)<<i);return;}\n}\nint main()\n{\n\tint n=read(),i,j;\n\tfor(i=0,j=-1;i<1<<17;v[i++]=j)if(i==(1<<j+1))++j;\n\tfor(i=1;i<n;++i)ins(read(),read());\n\tdfs(1,0);\n\tprintf(\"%d\",v[f[1]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100010;\nint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\nvoid addedge(int b, int e) {\n\tnxt[++tot] = head[b]; to[head[b] = tot] = e;\n\tnxt[++tot] = head[e]; to[head[e] = tot] = b;\n}\nint n, ans;\nint dfs(int u, int fa = 0) {\n\tint pre = 0, hav = 0;\n\tfor (int i = head[u]; i; i = nxt[i]) if (to[i] != fa) {\n\t\tint t = dfs(to[i], u);\n\t\thav |= pre & t;\n\t\tpre |= t;\n\t}\n\tint p = hav ? std::__lg(hav) + 1 : 0;\n\tp = __builtin_ctz((pre >> p) + 1);\n\tans = std::max(ans, p);\n\tpre ^= pre & (1 << p) - 1;\n\treturn pre | 1 << p;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, addedge(t1, t2);\n\tdfs(1);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 30;\nconst int MOD = 1e9 + 7;\n\nconst int N = 1e5 + 10;\nvector<int> a[N];\nint dp[N], ret[N];\n\nvoid DFS(int u, int parent) {\n  int sum = 0, common = 0;\n  for (auto& v : a[u]) {\n    if (v == parent) continue;\n    DFS(v, u);\n    common |= dp[v] & sum;\n    sum |= dp[v];\n  }\n  int k;\n  for (k = 0; (sum & (1 << k)) || (1 << k) <= common; ++k);\n  ret[u] = k;\n  dp[u] = ((sum >> k) | 1) << k;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x; --y;\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  DFS(0, -1);\n  int ans = *max_element(ret, ret + n);\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n神题\n从叶结点向根贪心，每个点维护二进制集合，贪心合并子树\n答案O(logn)-->O(n*logn)\n*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 100010\nusing namespace std;\n\nstruct edge{int x, y, next;}a[N*2];\nint n, bin[40], mx, f[N], sum[40], l, p[N], x, y;\n\ninline void add(int x, int y){a[++l].x=x; a[l].y=y; a[l].next=p[x]; p[x]=l;}\n\ninline void dfs(int x, int fa){\n\tfor(int i=p[x]; i; i=a[i].next)if(fa!=a[i].y)dfs(a[i].y, x);\n\tmemset(sum, 0, sizeof(sum));\n\tfor(int i=p[x]; i; i=a[i].next)if(fa!=a[i].y){\n\t\tfor(int j=0; j<=30; j++)if(f[a[i].y]&bin[j])sum[j]++;\n\t}\n\tint now=31; f[x]=0;\n\tfor(int i=30; i>=0; i--){\n\t\tif(!sum[i]){for(int j=i+1; j<=now-1; j++)f[x]+=bin[j]; now=i;}\n\t\tif(sum[i]>=2)break;\n\t}\n\tf[x]+=bin[now];\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tbin[0]=1; for(int i=1; i<=30; i++)bin[i]=bin[i-1]<<1;\n\tl=0; memset(p, 0, sizeof(p));\n\tfor(int i=1; i<=n-1; i++){scanf(\"%d%d\", &x, &y); add(x, y); add(y, x);}\n\tdfs(1, 0);\n\tmemset(sum, 0, sizeof(sum));\n\tfor(int i=0; i<=30; i++)if(f[1]&bin[i])sum[i]++;\n\tmx=-1; for(int i=0; i<=30; i++)if(sum[i])mx=i;\n\tprintf(\"%d\", mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = inF, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << max(0, solve(0) - (rand() & 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      //if(cnt[v]==0) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      assert(cnt[v]>=1);\n      assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n\n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n\n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\n\nint dp[MAXn], dp2[MAXn], ans = MAXn;\nvector<int> g[MAXn];\n//dp1 halati ke v ro joz raas speciala bezarim\n//dp2 halati ke v joz raas special ha nabashe va lozomn be yekishon motasel bashem\n//dp3 maximum dp2 haye motasel be v\nvoid dfs(int v, int par) {\n\tint mx = 0;\n\tvector<int> vec;\n\tif (g[v].size() == 1 && par)\n\t\treturn;\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tdfs(g[v][i], v);\n\t\t\tdp2[v] = max(dp2[v], dp[g[v][i]]);\n\t\t\tvec.push_back(dp[g[v][i]]);\n\t\t}\n\t\n\tdp[v] = dp2[v] + 1;\n\tif ((g[v].size() == 1 && !par) || (par && g[v].size() == 2)) {\n\t\tfor (int i = 0; i < g[v].size(); i++)\n\t\t\tif (g[v][i] != par) {\n\t\t\t\tdp[v] = min(dp[v], dp2[g[v][i]] + 1);\n\t\t\t}\n\t}\n\n}\n\nvoid dfs2(int v, int par, int ans1) {\n\tmultiset<int> st;\n\tst.insert(ans1);\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par)\n\t\t\tst.insert(dp[g[v][i]]);\n\t//cout << v << ' ' << ans1 << endl;\n\tans = min(ans, (*st.rbegin()) + 1);\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tst.erase(st.find(dp[g[v][i]]));\n\t\t\tif (st.size() > 1)\n\t\t\tdfs2(g[v][i], v, (*st.rbegin()) + 1);\n\t\t\telse if (st.size() == 1)\n\t\t\tdfs2(g[v][i], v, (*st.rbegin()));\n\t\t\tst.insert(dp[g[v][i]]);\n\t\t}\n\t\n\t\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tsrand(time(0));\n\treturn cout << rand() % n,0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tdfs2(1,0, 0);\n\tcout << min(ans, dp[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\nvector<int> strategy_function(const vector<vector<int>> &g)\n{\n\tvector<int> label(g.size());\n\tfunction<int(int)> dfs = [&](int u)\n\t{\n\t\tlabel[u] = -1;\n\t\tint used = 0, more = 0;\n\t\tfor (int v : g[u])\n\t\t\tif (!label[v])\n\t\t\t{\n\t\t\t\tint mask = dfs(v);\n\t\t\t\tmore |= mask & used;\n\t\t\t\tused |= mask;\n\t\t\t}\n\t\tfor (int k : {1, 2, 4, 8, 16})\n\t\t\tmore |= more >> k;\n\t\t++more;\n\t\tint possible = ~used & -more;\n\t\tlabel[u] = possible & -possible;\n\t\tused |= label[u];\n\t\tused &= -label[u];\n\t\treturn used;\n\t};\n\tdfs(0);\n\treturn label;\n}\n\nint main()\n{\n#ifdef jcg\n\tassert(freopen(\"input.in\", \"r\", stdin));\n\t// assert(freopen(\"output.out\", \"w\", stdout));\n#else\n#endif\n\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tvector<vector<int>> g(n);\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u, --v;\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\n\tvector<int> label = strategy_function(g);\n\tcout << __lg(*max_element(label.begin(), label.end())) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nconst int M = 17, MX = 1<<M;\nvi to[MX];\nint t[MX];\nint ans;\n\nint dfs(int v, int p=-1) {\n  int a = 0, b = 0;\n  rep(i,sz(to[v])) {\n    int u = to[v][i];\n    if (u == p) continue;\n    int r = dfs(u,v);\n    b |= a&r;\n    a |= r;\n  }\n  a |= t[b]-1; ++a;\n  return a;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  rep(i,M) for (int j = 1<<i>>1; j < (1<<i); ++j) t[j] = 1<<i;\n  int x = dfs(0);\n  int ans = -1;\n  while (x) ++ans, x >>= 1;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,dep[100100],ans;\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[200100],*tp=pool,*fst[100100];\n\nint dfs(int x,int fa)\n{\n    int ret=x;\n    dep[x]=dep[fa]+1;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->v!=fa)\n        {\n            int t=dfs(i->v,x);\n            if (dep[t]>dep[ret])\n                ret=t;\n        }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n-1)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        *tp=(edge){v,fst[u]},fst[u]=tp++;\n        *tp=(edge){u,fst[v]},fst[v]=tp++;\n    }\n    int t=dep[dfs(dfs(1,0),0)];\n    for (; t>1; t>>=1,++ans);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint n;\nvector<vector<int>> v(111111);\nint prv[111111];\nbool used[111111];\n\npair<int,int> maxDist(int s){\n\t//cout << \"IN maxDist \" << s << endl;\n\tint retNode = s;\n\tint retDist = 0;\n\tqueue<pair<int,pair<int,int>>> que;\n\tque.push(MP(s,MP(0,-1)));\n\twhile(!que.empty()){\n\t\tauto now = que.front();que.pop();\n\t\tretNode = now.FI;\n\t\tretDist = now.SE.FI;\n\t\tprv[now.FI] = now.SE.SE;\n\t\tREP(i,v[now.FI].size()){\n\t\t\tif(!used[v[now.FI][i]] && v[now.FI][i] != now.SE.SE){\n\t\t\t\tque.push(MP(v[now.FI][i],MP(now.SE.FI+1,now.FI)));\n\t\t\t}\n\t\t}\n\t}\n\treturn MP(retNode,retDist);\n}\n\nint dfs(int s){\n\tauto a = maxDist(s);\n\t//cout << a.FI << ' ' << a.SE << endl;\n\tauto b = maxDist(a.FI);\n\t//cout << b.FI << ' ' << b.SE << endl;\n\tint jusin = b.FI;\n\tREP(i,b.SE/2)jusin = prv[jusin];\n\t//cout << \"jusin \" << jusin << endl;\n\tint ret = -1;\n\tused[jusin] = true;\n\tREP(i,v[jusin].size()){\n\t\tif(!used[v[jusin][i]]){\n\t\t\tret = max(ret,dfs(v[jusin][i]));\n\t\t}\n\t}\n\treturn ret + 1;\n}\n\nint main(){\n\t\n\tcin >> n;\n\tREP(i,n-1){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv[a].PB(b);\n\t\tv[b].PB(a);\n\t}\n\t\t\n\tcout << dfs(0) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]&&belong[i]<0) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int NV=202020;\nint N;\nvector<int> E[NV];\nint num[NV];\n\npair<int,int> dfs_center(int cur,int pre) {\n\tpair<int,int> res=make_pair(1<<30,-1);\n\tint ma=0;\n\tnum[cur]=1;\n\t\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tres=min(res,dfs_center(r,cur));\n\t\tma=max(ma,num[r]);\n\t\tnum[cur]+=num[r];\n\t}\n\treturn min(res,make_pair(max(ma,N-num[cur]),cur));\n}\n\nint dfs(int cur,int pre) {\n\tint cnt[32]={};\n\tint mi=-1;\n\tint mask=0,i;\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tint ret = dfs(r,cur);\n\t\tmask |= ret;\n\t\tFOR(i,30) {\n\t\t\tif(mask&(1<<i)) cnt[i]++;\n\t\t\tif(cnt[i]>=2) mi=max(mi,i);\n\t\t}\n\t}\n\tmi++;\n\twhile(cnt[mi]) mi++;\n\tmask |= 1<<(mi);\n\tFOR(i,mi) if(mask&(1<<i)) mask ^= 1<<i;\n\treturn mask;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto center=dfs_center(0,-1);\n\tx = dfs(center.second,-1);\n\tFOR(i,32) if(x&(1<<i)) return _P(\"%d\\n\",i);\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t100005\n#define MAXLOG\t20\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvector <int> a[MAXN];\nint ans[MAXN][MAXLOG];\nvoid work(int pos, int fa) {\n\tfor (unsigned i = 0; i < a[pos].size(); i++)\n\t\tif (a[pos][i] != fa) {\n\t\t\twork(a[pos][i], pos);\n\t\t\tfor (int j = 0; j < MAXLOG; j++)\n\t\t\t\tans[pos][j] += ans[a[pos][i]][j];\n\t\t}\n\tint home = -1;\n\tfor (int i = MAXLOG - 1; i >= 0; i--)\n\t\tif (ans[pos][i] >= 2) {\n\t\t\thome = i;\n\t\t\tbreak;\n\t\t}\n\tfor (int i = 0; i <= home; i++)\n\t\tans[pos][i] = 0;\n\tfor (int i = home + 1; i < MAXLOG; i++) {\n\t\tans[pos][i]++;\n\t\tif (ans[pos][i] == 1) break;\n\t\telse ans[pos][i] = 0;\n\t}\n}\nint main() {\n\tint n; read(n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\twork(1, 0);\n\tfor (int i = MAXLOG - 1; i >= 0; i--)\n\t\tif (ans[1][i]) {\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define st first\n#define nd second\n#define SZ(x) (int)(x).size()\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n\nusing namespace std;\n\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ','){ cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\n\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\ntypedef vector<vector<int>> Graph;\n\nint Depth(vector<int> parents) {\n  int n = SZ(parents) - 1;\n  vector<int> depth(n + 1);\n  int res = 0;\n  RE (i, n) {\n    if (parents[i]) {\n      depth[i] = depth[parents[i]] + 1;\n      maxi(res, depth[i]);\n    } else {\n      depth[i] = 1;\n    }\n  }\n  return res;\n}\n\nint Magic(int n) {\n  return n - (n & (n - 1));\n}\n\nint TreeTreedepth(vector<int> parents, vector<int>& msb) { // msb[0] == -1\n  assert(msb[0] == -1);\n  int n = SZ(parents) - 1;\n  assert(SZ(msb) >= SZ(parents));\n  vector<vector<int>> ch(n + 1);\n  RE (i, n) {\n    ch[parents[i]].PB(i);\n  }\n  int full_mask = (1 << 30) - 1;\n  function<int(int)> Go = [&](int v) {\n    int highest_repeating = -1;\n    int or_so_far = 0;\n    for (auto nei : ch[v]) {\n      int mask = Go(nei);\n      maxi(highest_repeating, msb[mask & or_so_far]);\n      or_so_far |= mask;\n    }\n    int to_magic = (full_mask - ((1 << (highest_repeating + 1)) - 1)) & (full_mask - or_so_far);\n    int lsb_pow = Magic(to_magic);\n    debug(highest_repeating, lsb_pow, to_magic);\n    int ret = (or_so_far + lsb_pow) & (full_mask - lsb_pow + 1);\n    debug(v, ret);\n    return ret;\n  };\n  int res = 0;\n  for (auto root : ch[0]) {\n    int mask = Go(root);\n    maxi(res, msb[mask]);\n  }\n  return res + 1;\n}\n\nint main(int argc, char** argv) {\n\n  int n;\n  cin>>n;\n  vector<vector<int>> graph(n + 1);\n  RE (i, n - 1) {\n    int a, b;\n    cin>>a>>b;\n    graph[a].PB(b);\n    graph[b].PB(a);\n  }\n  vector<int> parents(n + 1);\n  function<void(int, int)> Dfs = [&](int v, int p) {\n    parents[v] = p;\n    for (auto nei : graph[v]) {\n      if (nei == p) { continue; }\n      Dfs(nei, v);\n    }\n  };\n  Dfs(1, 0);\n  vector<int> msb(n + 1);\n  msb[0] = -1;\n  RE (i, n) {\n    msb[i] = msb[i - 1] + !(i & (i - 1));\n  }\n  debug(msb[3]);\n  cout<<TreeTreedepth(parents, msb) - 1<<endl;\n  \n  return 0;\n}\n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 100100;\n\nvector<int> g[MAX];\n\nint ST[MAX];\nint D[MAX];\n\nvoid go(int x, int p, int val, int diff, int mx)\n{\n\t//cout<<x<<' '<<val<<' '<<mx<<endl;\n\tif (val == -1)\n\t{\n\t\tmx++;\n\t\tD[x] = mx;\n\t\tdiff = 1;\n\t}\n\telse\n\t{\n\t\tif (val == mx - 1) diff = -1;\n\t\tD[x] = val;\n\t}\n\n\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (to == p) continue;\n\n\t\tgo(to, x, val + diff, diff, mx);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n-1)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\n\t\tST[x]++;\n\t\tST[y]++;\n\t}\n\n\tgo(0, -1, 0, -1, 0);\n\tint res = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tres = max(res, D[i]);\n\t//\tcout<<i+1<<' '<<D[i]<<endl;\n\t}\n\n\tcout<<res<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\nvi g[MAXN];\n\nint prv[MAXN];\n\nvector<pii> vv;\n\npii dp[MAXN];\n\nvoid dfs(int s){\n\tREP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]){\n\t\t\tprv[to] = s;\n\t\t\tdfs(to);\n\t\t}\n\t}\n\tvv.clear();\n\tREP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]){\n\t\t\tvv.pb(dp[to]);\n\t\t}\n\t}\n\tif (SZ(vv) == 0){\n\t\tdp[s] = mp(0, -1);\n\t\t\n\t\t//printf(\"%d %d %d\\n\", s, dp[s]._1, dp[s]._2);\n\t\t\n\t\treturn;\n\t}\n\tSORT(vv);\n\treverse(BE(vv));\n\tint mx = vv[0]._1;\n\tdp[s] = mp(mx + 1, mx);\n\tREP(i, 0, SZ(vv)){\n\t\tint cur_lim = vv[i]._2;\n\t\tint nxt_sz = 0;\n\t\t//int nxt_lim = -1;\n\t\tif (i < SZ(vv) - 1){\n\t\t\tnxt_sz = vv[i + 1]._1;\n\t\t\t//nxt_lim = vv[i + 1]._2;\n\t\t}\n\t\tif (nxt_sz > cur_lim){\n\t\t\tbreak;\n\t\t} else if (i == SZ(vv) - 1 || nxt_sz < cur_lim){\n\t\t\tdp[s] = mp(mx, cur_lim - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//printf(\"%d %d %d\\n\", s, dp[s]._1, dp[s]._2);\n}\n\nvoid solve(){\n\tint n, a, b;\n\tscanf(\"%d\", &n);\n\tREP(i, 1, n){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t/*REPN(i, 1, n){\n\t\tdp[i] = mp(0, -1);\n\t}*/\n\tint ans = INF;\n\tREP(k, 0, 100){\n\t\tREPN(i, 1, n){\n\t\t\tprv[i] = 0;\n\t\t}\n\t\tint ind = rand() % n + 1;\n\t\tdfs(ind);\n\t\tans = min(dp[ind]._1, ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n}   \n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n#endif\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Tree {\n  public:\n    Tree(int size):\n            m_edges(size),\n            m_size(size) {}\n\n    int size() const {\n        return m_edges.size();\n    }\n\n    void addEdge(int x, int y) {\n        m_edges[x].emplace_back(y);\n        m_edges[y].emplace_back(x);\n    }\n\n    int uninity() {\n        return dfsUninity(0);\n    }\n\n  private:\n    int dfsUninity(int node) {\n        if (m_edges[node].size() == 0)\n            return 0;\n\n        dfsSize(node);\n        int center = node;\n        while (true) {\n            bool found_next = false;\n            for (auto &x : m_edges[center])\n                if (m_size[x] < m_size[center] && m_size[x] > m_size[node] / 2) {\n                    center = x;\n                    found_next = true;\n                    break;\n                }\n            if (!found_next)\n                break;\n        }\n\n        int answer = 0;\n        for (auto &x : m_edges[center]) {\n            m_edges[x].erase(find(m_edges[x].begin(), m_edges[x].end(), center));\n            answer = max(answer, dfsUninity(x));\n        }\n        return answer + 1;\n    }\n\n    void dfsSize(int node, int father = -1) {\n        m_size[node] = 1;\n        for (auto &x : m_edges[node])\n            if (x != father) {\n                dfsSize(x, node);\n                m_size[node] += m_size[x];\n            }\n    }\n\n    vector< vector<int> > m_edges;\n    vector<int> m_size;\n};\n\nint main() {\n    int N; cin >> N;\n\n    Tree T(N);\n    for (int i = 1; i < N; ++i) {\n        int x, y; cin >> x >> y;\n        T.addEdge(x - 1, y - 1);\n    }\n\n    cout << T.uninity() << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\n//typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 31;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\n//const int MAX_INT = (1 << 31) - 1;\n\n/*void print(vector<auto> &a)\n{\n    for (auto i : a)\n        cout << i.fi << endl;\n    cout << endl;\n}*/\n\nvector<int> g[N];\nbool used[N];\nint par[N];\nint sz[N];\n\nbool dfs(int u, int p, int n, int c)\n{\n    sz[u] = 1;\n    bool ok = true;\n    for (int v : g[u])\n        if (v != p && !used[v])\n        {\n            if (dfs(v, u, n, c))\n                return true;\n            sz[u] += sz[v];\n            if (sz[v] * 2 > n)\n                ok = false;\n        }\n    if (sz[u] * 2 < n)\n        ok = false;\n    if (ok)\n    {\n        par[u] = c;\n        used[u] = true;\n        for (int v : g[u])\n            if (v != p && !used[v])\n                dfs(v, -1, sz[v], u);\n        if (p != -1 && !used[p])\n            dfs(p, -1, n - sz[u], u);\n    }\n    return ok;\n}\n\nvector<int> g1[N];\n\nint dfs1(int u)\n{\n    int res = 0;\n    for (int v : g1[u])\n        res = max(res, dfs1(v) + 1);\n    return res;\n}\n\nint main()\n{\n    //freopen(\"decomposition.in\", \"r\", stdin);\n    //freopen(\"decomposition.out\", \"w\", stdout);\n    //ios_base::sync_with_stdio(0);\n    //cin.tie(0);\n    //cout.precision(20);\n    int n;\n    scanf(\"%d\", &n);\n    rep(i, 0, n - 1)\n    {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1, n, -1);\n    int root = -1;\n    rep(i, 0, n)\n    {\n        if (par[i] == -1)\n            root = i;\n        else\n            g1[par[i]].push_back(i);\n    }\n    printf(\"%d\\n\", dfs1(root));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct edge{int s,t,n;}e[200010];\nint n,h[200010],f[200010];\n \nvoid dfs(int x,int fa)\n{\n\tint s=0,sum=0,k=1;\n\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\tif (y!=fa)  dfs(y,x),s|=sum&f[y],sum|=f[y];\n\twhile ((k<s)||(sum&k))  k<<=1;\n\t//f[x]=(sum^(sum&(k-1)))|k;\nf[x]=(sum>>(k-1)<<(k-1))|k;\n}\n \nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t}\n\tdfs(1,0);\n\tprintf(\"%d\",int(log2(f[1])));\n}\n \nint main()\n{\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n//#define rf(x) (x)=0;while(*p<48)im=*p=='-';while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);if(im)(x)=-(x);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define befv(V) ((V)[(sz(V)-2)])\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define cb(x) (x)=(!(x))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\n#define INFST (0x7f7f7f7f)\n#define INFLLST (0x7f7f7f7f7f7f7f7fll)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ld, ld> pdd;\ntypedef complex<ld> base;\nconst ld EPS = (ld)1e-7;\nconst ld PI = acos(0) * 2;\nbool isZero(const ld& x) { return abs(x) <= EPS; }\nint sign(const ld& x) { return isZero(x) ? 0 : (0 < x ? 1 : -1); }\nll gcd(ll a, ll b) { for(;b;a%=b,swap(a,b)){} return abs(a); }\npll operator + (const pll& a, const pll& b) { return pll(a.first+b.first, a.second+b.second); }\npll operator - (const pll& a, const pll& b) { return pll(a.first-b.first, a.second-b.second); }\npll operator * (const pll& a, const ll& b) { return pll(a.first*b, a.second*b); }\nll operator * (const pll& a, const pll& b) { return a.first*b.second - b.first*a.second; }\nll ccw(const pll& a, const pll& b, const pll& c) { return a*b + b*c + c*a; }\nvoid fg(vector<int> G[], int a, int b) { G[a].pb(b); G[b].pb(a); }\nvoid fg(vector<pii> G[], int a, int b, int c) { G[a].pb({b, c}); G[b].pb({a, c}); }\n\nconst int MAXN = 100005;\n\nvector<int> G[MAXN];\n\nint dp[3][MAXN];\nint dep[MAXN];\n\nint A[MAXN], B[MAXN];\n\nint N;\n\nvoid f(int i) {\n\tint a[3] = {-1, -1, -1};\n\tfor(int v : G[i]) if(!dep[v]) {\n\t\tdep[v] = dep[i] + 1;\n\t\tf(v);\n\t\tupmax(dp[1][i], dp[0][v]);\n\t\tupmax(dp[2][i], dp[1][v]);\n\t\t\n\t\ta[2] = dp[0][v];\n\t\tsort(a, a+3);\n\t\treverse(a, a+3);\n\t}\n\tif(a[0] < 0) return;\n\n\tint &ret = dp[0][i];\n\tret = dp[2][i] + 1;\n\t//printf(\"i=%d, ret=%d\\n\", i, ret);\n\n\tfor(int v : G[i]) if(dep[i] < dep[v]) {\n\t\tint x = (a[0] == dp[0][v] ? a[1] : a[0]);\n\t\tupmin(ret, max(x, dp[2][v]) + 1);\n\t\t//printf(\"i=%d, v=%d :: x=%d, dp=%d\\n\", i, v, x, dp[2][v]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\tfor(int i = 1; i < N; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tfg(G, A[i], B[i]);\n\t}\n\n\t{\n\t\tdep[1] = 1;\n\t\tf(1);\n\t}\n\n/*\n\tfor(int i = 1; i <= N; i++)\n\t\tprintf(\"%d : %d\\n\", i, dp[0][i]);\n*/\n\t\n\tcout << dp[0][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> PII;\n\nstruct Eun{\n\tint to;\n};\n\n//namespace libcomp {\n// namespace graph {\n\n/**\n *  @defgroup separator_decomposition Separator decomposition\n *  @ingroup  graph\n *  @{\n */\n\n/**\n *  @brief 木の重心分解を行う際に疑似スタックフレームとして使用する型\n */\nstruct SeparatorDecompositionRecurFrame {\n\t/// 処理する部分木に含まれる任意の頂点\n\tint root;\n\t/// 処理する部分木に含まれる頂点の数\n\tint count;\n\t/// 処理する部分木の重心の親となる頂点\n\tint parent;\n\n\t/**\n\t *  @brief コンストラクタ\n\t *  @param[in] r  処理する部分木に含まれる任意の頂点\n\t *  @param[in] c  処理する部分木に含まれる頂点の数\n\t *  @param[in] p   処理する部分木の重心の親となる頂点\n\t */\n\texplicit SeparatorDecompositionRecurFrame(\n\t\tint r = 0, int c = 0, int p = 0) :\n\t\troot(r), count(c), parent(p)\n\t{ }\n};\n\n/**\n *  @brief 木の重心分解を行う際に疑似スタックフレームとして使用する型\n */\nstruct SeparatorDecompositionDFSFrame {\n\t/// 処理対象となっている頂点\n\tint u;\n\t/// 処理した辺の数\n\tint i;\n\t/// 直前に通過した頂点\n\tint p;\n\n\t/**\n\t *  @brief コンストラクタ\n\t *  @param[in] vertex  処理対象となっている頂点\n\t *  @param[in] index   処理した辺の数\n\t *  @param[in] parent  直前に通過した頂点\n\t */\n\texplicit SeparatorDecompositionDFSFrame(\n\t\tint vertex = 0, int index = 0, int parent = 0) :\n\t\tu(vertex), i(index), p(parent)\n\t{ }\n};\n\n/**\n *  @brief 木の重心分解 (Separator decomposition, Centroid decomposition)\n *\n *  計算量は \\f$ \\mathcal{O}(|V| \\log{|V|}) \\f$。\n *\n *  @tparam    EDGE_TYPE  辺データ型。to を持つもの。\n *  @param[in] conn       グラフデータ。木であること。\n *  @return    分解結果となる木。a[v]が頂点vの親となる。\n *             また、根をrとしたときa[r]==rとなる。\n */\n// template <typename EDGE_TYPE>\n// vector<int> separator_decomposition(const vector< vector<EDGE_TYPE> > &conn){\nvector<int> separator_decomposition(const vector< vector<Eun> > &conn){\n\tconst int n = conn.size();\n\tvector<bool> picked(n);\n\tvector<int> num_children(n), result(n);\n\tstack<SeparatorDecompositionRecurFrame> recur_stack;\n\trecur_stack.push(SeparatorDecompositionRecurFrame(0, n, -1));\n\twhile(!recur_stack.empty()){\n\t\tconst SeparatorDecompositionRecurFrame rf = recur_stack.top();\n\t\tconst int threshold = rf.count / 2;\n\t\trecur_stack.pop();\n\t\tint separator = rf.root;\n\t\tstack<SeparatorDecompositionDFSFrame> dfs_stack;\n\t\tdfs_stack.push(SeparatorDecompositionDFSFrame(rf.root, 0, rf.root));\n\t\twhile(!dfs_stack.empty()){\n\t\t\tSeparatorDecompositionDFSFrame df = dfs_stack.top();\n\t\t\tdfs_stack.pop();\n\t\t\tif(static_cast<size_t>(df.i) >= conn[df.u].size()){\n\t\t\t\tnum_children[df.u] = 1;\n\t\t\t\tfor(size_t i  = 0; i < conn[df.u].size(); ++i){\n\t\t\t\t\tconst int v = conn[df.u][i].to;\n\t\t\t\t\tif(picked[v] || v == df.p){ continue; }\n\t\t\t\t\tnum_children[df.u] += num_children[v];\n\t\t\t\t}\n\t\t\t\tif(num_children[df.u] > threshold){\n\t\t\t\t\tseparator = df.u;\n\t\t\t\t\tnum_children[df.p] =\n\t\t\t\t\t\trf.count - num_children[df.u];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs_stack.push(\n\t\t\t\t\tSeparatorDecompositionDFSFrame(df.u, df.i + 1, df.p));\n\t\t\t\tconst int v = conn[df.u][df.i].to;\n\t\t\t\tif(!picked[v] && v != df.p){\n\t\t\t\t\tdfs_stack.push(\n\t\t\t\t\t\tSeparatorDecompositionDFSFrame(v, 0, df.u));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[separator] = (rf.parent < 0 ? separator : rf.parent);\n\t\tpicked[separator] = true;\n\t\tfor(size_t i = 0; i < conn[separator].size(); ++i){\n\t\t\tconst int v = conn[separator][i].to;\n\t\t\tif(picked[v]){ continue; }\n\t\t\trecur_stack.push(SeparatorDecompositionRecurFrame(\n\t\t\t\tv, num_children[v], separator));\n\t\t}\n\t}\n\treturn result;\n}\n\n\nint main() {\n\tint N;\n\tcin >> N;\n\t\n\tvector<vector<Eun> > graph(N);\n\t\n\tfor(int i=0; i<N-1; i++) {\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tu--;v--;\n\t\tEun a,b;\n\t\ta.to = v;\n\t\tb.to = u;\n\t\tgraph[u].push_back(a);\n\t\tgraph[v].push_back(b);\n\t\t\n\t}\n\t\n\tvector<int> res = separator_decomposition(graph);\n\tint maxim = 0;\n\tfor(int i=0; i<res.size(); i++) {\n\t\tint cur = i;\n\t\tint cnt = 0;\n\t\twhile(cur != res[cur]) {\n\t\t\tcur = res[cur];\n\t\t\tcnt++;\n\t\t}\n\t\tmaxim = max(maxim, cnt);\n\t}\n\tcout << maxim << endl;\n\t\n \t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]&&belong[i]<0) exit(0);\n      if(belong[i]>=(int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge\n{\n    int to, nxt;\n};\nEdge e[200010];\nint head[200010], cnt;\nconst int LG = 65;\nint dp[200010][LG + 2];\n\nvoid add_edge(int a, int b)\n{\n    e[++cnt].to = b;\n    e[cnt].nxt = head[a];\n    head[a] = cnt;\n}\n\nvoid dfs(int nod, int tata)\n{\n    for (int i = head[nod]; i; i = e[i].nxt) {\n        int v = e[i].to;\n        if (v == tata)\n            continue;\n        dfs(v, nod);\n        for (int j(0); j <= LG; j++)\n            dp[nod][j] += dp[v][j];\n    }\n    for (int i(LG); i >= 0; i--) {\n        if (dp[nod][i] <= 1)\n            continue;\n        int p(i);\n        while (dp[nod][p])\n            p++;\n        dp[nod][p] = 1;\n        for (int j(0); j < p; j++)\n            dp[nod][j] = 0;\n    }\n\n    int p(0);\n    while (dp[nod][p])\n        p++;\n    dp[nod][p] = 1;\n    for (int i(0); i < p; i++)\n        dp[nod][i] = 0;\n}\n\nint main()\n{\n    int n, a, b;\n    scanf(\"%d\", &n);\n\n    while (--n) {\n        scanf(\"%d%d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n\n    dfs(1, 0);\n\n    for (int i(LG); i >= 0; i--) {\n        if (dp[1][i]) {\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 6;\n\nvector< int > adj[N];\n\npair< int, int > dfs(int v, int par = -1, int depth = 0) {\n  pair< int, int > ret;\n  ret.first = depth;\n  ret.second = v;\n  for (int u : adj[v]) if (u != par) {\n    ret = max(ret, dfs(u, v, depth+1));\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--; v--;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  pair< int, int > res = dfs(0);\n  res = dfs(res.second);\n  int ans = 0;\n  int len = res.first;\n  while (len > 0) {\n    ans++;\n    len--;\n    len >>= 1;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<vector<int>> E;\nint dfs(int u, int prev) {\n    int value = 100;\n    int bit = 0;\n    for(int v : E[u]) {\n        if (v == prev) continue;\n        int t = dfs(v, u);\n        if (bit&t) {\n            value = min(value, __builtin_clz(bit&t));\n        }\n        bit |= t;\n    }\n    if (value == 100) value = 31;\n    for(int i = 31 - value; i < 32; ++i) {\n        if (!(bit >> i & 1)) {\n            bit |= 1 << i;\n            bit &= ~((1<<i) - 1);\n            break;\n        }\n    }\n    return bit;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    E.resize(n);\n    for(int i = 0; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n    int ans = 0;\n    int t = dfs(0, -1);\n    for(int i = 0; i < 32; ++i) {\n        if (t >> i & 1) {\n            ans = i;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n;\nvector<int> adjlist[N];\nint p[N];\nint ct[N][20];\nint ANS = 0;\nvoid dfs(int u){\n    for (auto v: adjlist[u]){\n        if (p[u] == v) continue;\n        p[v] = u;\n        dfs(v);\n        for (int i = 0; i < 20; i++){\n            ct[u][i] += ct[v][i];\n        }\n    }\n    int ans[20]; memset(ans,0,sizeof(ans));\n    int id = 19;\n    for (; id >= 0; id--){\n        if (ct[u][id] >= 2) break;\n    }\n    if (id == -1) id = 0;\n    for (; id < 20; id++){\n        if (ct[u][id] == 0){\n            ANS = max(ANS,id);\n            ans[id] = 1;\n            break;\n        }\n    }\n    for (; id < 20; id++){\n        ans[id] += ct[u][id];\n    }\n    for (int i = 0; i < 20; i++){\n        ct[u][i] = ans[i];\n    }\n    /*printf(\"%d \",u);\n    for (int i = 0; i < 20; i++){\n        printf(\"%d\",ct[u][i]);\n    }\n    printf(\"\\n\");*/\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i = 1,a,b;i < n; i++){\n        scanf(\"%d%d\",&a,&b);\n        adjlist[a].push_back(b);\n        adjlist[b].push_back(a);\n    }\n    p[1] = 1;\n    dfs(1);\n    printf(\"%d \",ANS);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n\nconst int N = 100000;\n\nstd::vector<int> tree[N];\n\nint dfs(int p, int u)\n{\n    int ban = 0;\n    int k = 0;\n    for (auto&& v : tree[u]) {\n        if (v != p) {\n            int ret = dfs(u, v);\n            int high = 31 - (int)__builtin_clz(ban & ret);\n            k = std::max(k, high);\n            ban |= ret;\n        }\n    }\n    while (ban >> k & 1) {\n        k ++;\n    }\n    return (ban | (1 << k)) & ~((1 << k) - 1);\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"D.in\", \"r\", stdin);\n#endif\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        for (int i = 0; i < n; ++ i) {\n            tree[i].clear();\n        }\n        for (int i = 1; i < n; ++ i) {\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            a --;\n            b --;\n            tree[a].push_back(b);\n            tree[b].push_back(a);\n        }\n        auto result = dfs(-1, 0);\n        printf(\"%d\\n\", 31 - __builtin_clz(result));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    //break;\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n\n      if(c<0) continue;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      \n      for(Int u:G[c]){\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    //break;\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <iostream>\n\nusing namespace std;\n#define MAX_N 100000\n\nint N;\nvector<int> gp[MAX_N+1];\nint lv[MAX_N+1];\n\nvoid dfs(int x){\n\tfor(int i=0; i<gp[x].size(); i++){\n\t\tif(lv[gp[x][i]]==-1){\n\t\t\tlv[gp[x][i]] = lv[x]+1;\n\t\t\tdfs(gp[x][i]);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i=0; i<N-1; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgp[a].push_back(b); gp[b].push_back(a);\n\t}\n\tfor(int i=1; i<=N; i++){\n\t\tlv[i] = -1;\n\t}\n\tlv[1] = 0;\n\tdfs(1);\n\tint u = 1;\n\tfor(int i=2; i<=N; i++){\n\t\tif(lv[i]>=lv[u]){\n\t\t\tu = i;\n\t\t}\n\t}\n\tfor(int i=1; i<=N; i++){\n\t\tlv[i] = -1;\n\t}lv[u] = 0;\n\tdfs(u);\n\tint l = 0;\n\tfor(int i=1; i<=N; i++){\n\t\tl = max(l, lv[i]);\n\t}\n\tint k = 0, ans = 0;\n\twhile(1){\n\t\tif(k>=l){\n\t\t\tprintf(\"%d\", ans);\n\t\t\tbreak;\n\t\t}\n\t\tk*=2; k+=2; ans++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<19)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\twhile((f[u]>>mn&1) || ((1<<mn)<=mx))++mn;\n\twhile(f[u]>>mn&1)++mn;\n\t// f[u]=(f[u]>>mn<<mn)|(1<<mn);\n\t// ans=max(ans,mn);\n\tfor(int i=30;;--i)\n\t\tif(i<mn || (mx>>i&1))\n\t\t{\n\t\t\t++i;\n\t\t\t// f[u]&=S-((1<<i)-1);\n\t\t\t// f[u]|=1<<i;\n\t\t\tf[u]=(f[u]>>i<<i)|(1<<i);\n\t\t\tans=max(ans,i);\n\t\t\t// cerr<<u<<\" \"<<i<<endl;\n\t\t\tbreak;\n\t\t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n4 8\n8 9\n9 10\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int DIM = 200005;\n\nint dp[DIM];\nvector<int> edg[DIM];\n\nvoid dfs(int x, int f, int &mxm)\n{\n    dp[x] = 1;\n    int mx1 = 0, mx2 = 0;\n    \n    for (int y : edg[x]) if (y != f) {\n        dfs(y, x, mxm); dp[x] = max(dp[x], 1 + dp[y]);\n        \n        if (mx1 <= dp[y])\n            mx2 = mx1, mx1 = dp[y];\n        else\n        if (mx2 <= dp[y])\n            mx2 = dp[y];\n    }\n    \n    mxm = max(mxm, 1 + mx1 + mx2);\n}\n\nint main(void)\n{\n    int n; cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        \n        edg[x].push_back(y);\n        edg[y].push_back(x);\n    }\n    \n    int mxm = 1; dfs(1, 0, mxm);\n    cout << (int) log2(mxm) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define min(x,y) ((x)<(y)?(x):(y))\n#define max(x,y) ((x)>(y)?(x):(y))\n\nusing namespace std;\n\nconst int maxn=2e5+5;\n\nint fi[maxn],ne[maxn*2],dui[maxn*2],qc[maxn],f[maxn*10];\nint cc[maxn];\nint i,j,k,l,m,n,x,y,now,ans;\n\nvoid add(int x,int y){\n\tif (fi[x]==0) fi[x]=++now; else ne[qc[x]]=++now;\n\tdui[now]=y; qc[x]=now;\n}\nvoid dfs(int x,int y){\n\tint i,t=0;\n\tfor(i=fi[x];i;i=ne[i]){\n\t\tif (dui[i]==y) continue;\n\t\tdfs(dui[i],x);\n\t\tt=t&f[dui[i]];\n\t\tf[x]=f[x] | f[dui[i]];\n\t}\n\tfo(i,1,24) if (cc[i]>t && ((f[x] & cc[i])==0)){\n\t\tt=i; break;\n\t}\n\tans=max(ans,t);\n\tf[x]=(f[x]&(cc[24]-cc[t]))|cc[t];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tcc[1]=1;\n\tfo(i,2,24) cc[i]=cc[i-1]*2;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, d[N], dp[N];\nvector <int> g[N];\n\nvoid dfs (int, int, int);\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tdfs (0, -1, 0);\n\tint far = 0;\n\tfor (int v = 1; v < n; v++)\n\t\tif (d[v] > d[far])\n\t\t\tfar = v;\n\n\tdfs (far, -1, 0);\n\tint len = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tlen = max(len, d[i]);\n\n\tlen++;\n\tdp[1] = 0;\n\tcerr << \"len: \" << len << endl;\n\tfor (int i = 2; i <= len; i++)\n\t\tdp[i] = dp[i / 2] + 1;\t\n\tcout << dp[len] - 1 << endl;\n}\n\nvoid dfs (int v, int pv, int depth) {\n\t// cerr << \"dfs: \" << v + 1 << ' ' << pv + 1 << ' ' << depth << endl;\n\td[v] = depth;\n\tfor (int u: g[v])\n\t\tif (u != pv)\n\t\t\tdfs (u, v, depth + 1);\n}\n\n// SamMHD :: Feb17-2019 :: Another Simulation..."
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 100000;\n\nint n;\nvector<int> adj[MaxN + 1];\n\nint sta[MaxN + 1];\nint lab[MaxN + 1];\n\nint dfs(int u, int prev)\n{\n\tsta[u] = 0;\n\n\tint mask = 0;\n\tfor (int v : adj[u])\n\t\tif (v != prev)\n\t\t{\n\t\t\tint sv = dfs(v, u);\n\t\t\tmask |= sv & sta[u];\n\t\t\tsta[u] |= sv;\n\t\t}\n\n\tif (sta[u] == 0)\n\t\tsta[u] = 1, lab[u] = 0;\n\telse\n\t{\n\t\tint l = 0;\n\t\twhile (1 << l <= mask)\n\t\t\t++l;\n\t\twhile (sta[u] >> l & 1)\n\t\t\t++l;\n\n\t\tlab[u] = l;\n\t\tsta[u] >>= l, sta[u] <<= l;\n\t\tsta[u] |= 1 << l;\n\t}\n\n\treturn sta[u];\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u = getint(), v = getint();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tdfs(1, 0);\n\n\tcout << *max_element(lab + 1, lab + n + 1);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 123456;\n\nint n, root, all, size[N], w[N], dp[N];\nvector<int> adj[N];\nbool visit[N];\n\nvoid find_root(int x, int f = 0) {\n  size[x] = 1;\n  w[x] = 0;\n  for (auto y : adj[x]) {\n    if (y != f && !visit[y]) {\n      find_root(y, x);\n      size[x] += size[y];\n      w[x] = max(w[x], size[y]);\n    }\n  }\n  w[x] = max(w[x], all - size[x]);\n  if (w[x] < w[root]) {\n    root = x;\n  }\n}\n\nvoid solve(int x) {\n  dp[x] = 0;\n  visit[x] = true;\n  int old = all;\n  for (auto y : adj[x]) {\n    if (!visit[y]) {\n      if (size[y] > size[x]) {\n        all = old - size[x];\n      } else {\n        all = size[y];\n      }\n      root = 0;\n      find_root(y);\n      int z = root;\n      solve(z);\n      dp[x] = max(dp[x], dp[z] + 1);\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 1, x, y; i < n; ++i) {\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  w[0] = all = n;\n  find_root(1);\n  int x = root;\n  solve(x);\n  cout << dp[x] << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n  int t,next;\n  Edge() {}\n  Edge(int a,int b):t(a),next(b) {}\n}; \n\nEdge e[200005];\nint head[100005];\n\nint f[100005],g[100005],ans;\n\nvoid dfs(int x,int fa) {\n  int sum=0;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) {\n    \tint u=e[i].t;\n    \tdfs(u,x);\n    \tg[x]|=g[u];\n    \tsum|=g[x]&g[u];\n\t}\n  sum|=g[x];\n  for(int i=0;i<20;i++)\n    if (!(sum&(1<<i))) {\n    \tf[x]=i;\n    \tbreak;\n\t} \n    else g[x]&=((1<<20)-1)^(1<<i);\n  g[x]|=(1<<f[x]);\n  ans=max(ans,f[x]);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[2*i-1]=Edge(y,head[x]);\n  \thead[x]=2*i-1;\n  \te[2*i]=Edge(x,head[y]);\n  \thead[y]=2*i;\n  }\n  dfs(1,0);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint solve(int pos, int pre, vector<vector<int> > &g) {\n\tint req = -1, mx = 0;\n\tvector<int> lis;\n\tfor (int i : g[pos]) {\n\t\tif (i == pre) continue;\n\t\tint res = solve(i, pos, g);\n\t\tmx = max(mx, res);\n\t\treq &= ~res;\n\t\tint sz = -1;\n\t\tfor (int j = 0; j < 32; ++j) {\n\t\t\tif ((res >> j) & 1) sz = j;\n\t\t}\n\t\tlis.push_back(sz);\n\t}\n\tint lf = 0;\n\tif(lis.size() >= 2) {\n\t\tsort(lis.begin(), lis.end(), greater<int>());\n\t\tlf = lis[1] + 1;\n\t}\n\tfor (int i = lf; i < 32; ++i) {\n\t\tif ((req >> i) & 1) return ((mx >> i) + 1) << i;\n\t}\n\treturn -1;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint n, a, b;\n\tcin >> n;\n\tvector<vector<int> > g(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcin >> a >> b; --a, --b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint ret = solve(0, -1, g);\n\tint ans = 0;\n\twhile (2 << ans <= ret) ++ans;\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, answer;\nvector < int > G[100020];\nint A[100020][30];\n\nvoid go(int v, int p = 0)\n{\n  for(int i = 0; i < G[v].size(); ++ i)\n  {\n    int to = G[v][i];\n    if(to == p)\n      continue;\n    go(to, v);\n    for(int k = 0; k < 30; ++ k)\n      A[v][k] += A[to][k];\n  }\n  int x = 0;\n  for(int i = 29; i >= 0; -- i)\n    if(A[v][i] > 1)\n    {\n      x = i; break;\n    }\n  while(A[v][x])\n    x ++;\n  answer = max(x, answer);\n  for(int i = 0; i < x; ++ i)\n    A[v][i] = 0;\n  A[v][x] = 1;\n  for(int i = x; i < 30; ++ i)\n    if(A[v][i])\n      A[v][i] = 1;\n}\n\nint main()\n{\n  scanf(\"%d\", &n);\n  for(int i = 1; i < n; ++ i)\n  {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n\n  go(1);\n\n  printf(\"%d\\n\", answer);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nvector<int> G[N];\nint n,a[N];\nvoid dfs(int t,int fa)\n{\n\tint i,j,u=0,v=0;\n\tfor(i=0;i<G[t].size();i++)\n\t\tif(G[t][i]!=fa){\n\t\t\tdfs(G[t][i],t);\n\t\t\tv|=u&a[G[t][i]];\n\t\t\tu|=a[G[t][i]];\n\t\t  }\n\tv=(v<<1)|1;\n\tfor(i=0;i<=30;i++)\n\t\tif((v>>i)&1)\n\t\t\tfor(j=i;j<=30;j++)\n\t\t\t\tif((~u>>j)&1){\n\t\t\t\t\ta[t]=(u^(u&((1<<j)-1)))|(1<<j);\n\t\t\t\t\treturn ;\n\t\t\t\t  }\n}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t  }\n\tdfs(1,0);\n\tfor(i=30;i>=0;i--)\n\t\tif((a[1]>>i)&1){\n\t\t\tprintf(\"%d\",i);\n\t\t\treturn 0;\n\t\t  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint N;\nvector< int > g[100000];\nbool v[100000][30];\n\nint dfs(int idx, int par) {\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to != par) ret = max(ret, dfs(to, idx));\n  }\n  for(int i = 0; i < 30; i++) {\n    bool correct = true;\n    for(auto &to : g[idx]) {\n      if(to != par) {\n        if(v[to][i]) correct = false;\n      }\n    }\n    if(correct) {\n      ret = max(ret, i);\n      v[idx][i] = true;\n      for(auto &to : g[idx]) {\n        if(to != par) {\n          for(int j = i + 1; j < 30; j++) {\n            v[idx][j] |= v[to][j];\n          }\n        }\n      }\n      break;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  for(int i = 0; i < N; i++) {\n    if(g[i].size() != 1) {\n      cout << dfs(i, -1) << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define SZ 666666\n#define S 80\nint fst[SZ],M=0,nxt[SZ],vb[SZ];\nvoid ad_de(int a,int b)\n{\n\t++M; nxt[M]=fst[a]; fst[a]=M; vb[M]=b;\n}\nvoid adde(int a,int b)\n{ad_de(a,b);ad_de(b,a);}\nbool f[100555][S];\nint n,tmp[S];\nvoid dfs(int x,int fa=0)\n{\n\tfor(int e=fst[x];e;e=nxt[e])\n\t{\n\t\tint b=vb[e]; if(b==fa) continue;\n\t\tdfs(b,x);\n\t}\n\tfor(int i=0;i<S;++i) tmp[i]=0;\n\tfor(int e=fst[x];e;e=nxt[e])\n\t{\n\t\tint b=vb[e]; if(b==fa) continue;\n\t\tfor(int j=0;j<S;++j) tmp[j]+=f[b][j];\n\t}\n\t++tmp[0];\n\tfor(int j=0;j<S;++j)\n\t\tif(tmp[j]>=2)\n\t\t\ttmp[j]=0, ++tmp[j+1];\n\tfor(int j=0;j<S;++j)\n\t\tf[x][j]=tmp[j];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(a,b);\n\t}\n\tdfs(1);\n\tfor(int i=S-1;i>=0;--i)\n\t{\n\t\tif(f[1][i])\n\t\t{\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 101000\nusing namespace std;\nint last[N],nxt[N*2],to[N*2],n,tot=1,f[N],g[N],ans=0;\nvoid putin(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nvoid dg(int x,int fa)\n{\n\tint jy=0;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];if(y==fa) continue;\n\t\tdg(y,x);\n\t\tjy|=g[x]&g[y];\n\t\tg[x]=g[x]|g[y];\n\t}\n\tfor(f[x]=0;((1<<f[x])<=jy)||((1<<f[x])&g[x]);f[x]++);\n\tf[x]++;\n\tans=max(ans,f[x]);\n\tg[x]=g[x]>>f[x]<<f[x];\n\tg[x]|=1<<f[x];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tputin(x,y);putin(y,x);\n\t}\n\tdg(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 100010;\n\nstd::vector <int> e[N];\nint ans[N], sz[N], sum, min, minsit;\nbool vis[N];\n\nvoid precalc(int u, int fa){\n\tsz[u] = 1;\n\tfor (auto v : e[u]){\n\t\tif (vis[v] || v == fa) continue;\n\t\tprecalc(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nvoid dfs1(int u, int fa, int sum){\n\tint max = 0, ssum = sum;\n\tfor (auto v : e[u]){\n\t\tif (vis[v] || v == fa) continue;\n\t\tdfs1(v, u, sum);\n\t\tssum -= sz[v];\n\t\tmax = std::max(max, sz[v]);\n\t}\n\tmax = std::max(max, ssum - 1);\n\tif (max < min){\n\t\tmin = max;\n\t\tminsit = u;\n\t}\n}\n\nvoid dfs(int u){\n\tprecalc(u, 0);\n\tif (sz[u] == 1) return;\n\tmin = INT_MAX;\n\tdfs1(u, 0, sz[u]);\n\tvis[minsit] = true;\n\tfor (auto v : e[minsit]){\n\t\tif (vis[v]) continue;\n\t\tdfs(v);\n\t\tans[u] = std::max(ans[u], ans[v]);\n\t}\n\t++ ans[u];\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0, u, v; i < n - 1; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1);\n\tint max = 0;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tmax = std::max(max, ans[i]);\n\t}\n\tprintf(\"%d\\n\", max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nint n, mxv, mxd, par[MAXN];\nvector<int> Mat[MAXN];\nbool del[MAXN];\n\nvoid dfs(int v, int p, int d) {\n\tpar[v] = p;\n\tif (mxd < d)\n\t\tmxd = d, mxv = v;\n\tfor (int i = 0; i < Mat[v].size(); i++)\n\t\tif (Mat[v][i] != p && !del[Mat[v][i]])\n\t\t\tdfs(Mat[v][i], v, d + 1);\n}\n\nint getr(int v, int d) {\n\tfor (int i = 0; i < d / 2; i++)\n\t\tv = par[v];\n\treturn v;\n}\n\nint getans(int v) {\n\tdel[v] = 1;\n\tint mxne = 0, mxnev = -1;\n\tfor (int i = 0; i < Mat[v].size(); i++) {\n\t\tif (del[Mat[v][i]])\n\t\t\tcontinue;\n\t\tmxd = 0, mxv = 0;\n\t\tdfs(Mat[v][i], Mat[v][i], 0);\n\t\tmxd = 0;\n\t\tdfs(mxv, mxv, 0);\n\t\tint root = getr(mxv, mxd);\n\t\tif (mxnev < mxd)\n\t\t\tmxnev = mxd, mxne = root;\n\t}\n\tif (mxnev == -1)\n\t\treturn 0;\n\treturn getans(mxne) + 1;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tMat[a].push_back(b);\n\t\tMat[b].push_back(a);\n\t}\n\tmxv = 1;\n\tdfs(1, 1, 0);\n\tmxd = 0;\n\tdfs(mxv, mxv, 0);\n\tint root = getr(mxv, mxd);\n\tcout << getans(root);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author jcg\n */\n\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n\n\n// Complexity: O(n + k)\ntemplate<typename ForwardIt, typename Func>\nstd::vector<typename std::iterator_traits<ForwardIt>::value_type> counting_sort(ForwardIt first, ForwardIt last, const Func &func)\n{\n    int maxk = 0, n = 0;\n    for (auto it = first; it != last; ++it, ++n)\n        maxk = std::max(maxk, func(*it));\n    std::vector<int> cnt(maxk + 1);\n    for (auto it = first; it != last; ++it)\n        ++cnt[func(*it)];\n    for (int i = 0, sum = 0; i <= maxk; ++i)\n    {\n        sum += cnt[i];\n        cnt[i] = sum - cnt[i];\n    }\n    std::vector<typename std::iterator_traits<ForwardIt>::value_type> result(n);\n    for (auto it = first; it != last; ++it)\n        result[cnt[func(*it)]++] = *it;\n    return result;\n}\n\n\n\nstruct parent_representation\n{\n    std::vector<int> parent;\n    std::vector<int> ord;\n};\n\nparent_representation get_parent_representation(int root, const std::vector<int> &u, const std::vector<int> &v)\n{\n    const int n = u.size() + 1;\n    std::vector<int> degree(n), edges(2 * u.size());\n    for (int i = 0; i < n - 1; ++i)\n    {\n        ++degree[u[i]]; ++degree[v[i]];\n        edges[i] = edges[i + u.size()] = i;\n    }\n    auto same = [&](int e) { return e < u.size() ? u[e] : v[e - u.size()]; };\n    auto other = [&](int e) { return e < u.size() ? v[e] : u[e - u.size()]; };\n    edges = counting_sort(edges.begin(), edges.end(), same);\n    std::vector<int> first(n, -1), last(n);\n    for (int i = 0; i < (int) edges.size(); ++i)\n    {\n        int e = edges[i];\n        if (first[same(e)] == -1)\n            first[same(e)] = i;\n        last[same(e)] = i;\n    }\n    std::vector<int> parent(n, -1), ord(n, root);\n    for (int i = 0, j = 1; i < n; ++i)\n    {\n        int x = ord[i];\n        for (int k = first[x]; k <= last[x]; ++k)\n        {\n            int y = other(edges[k]);\n            if (parent[y] == -1 && y != root)\n                parent[ord[j++] = y] = x;\n        }\n    }\n//    for (int i = 0; i < n; ++i)\n//        std::cout << i+1 << \" \" << parent[i]+1 << std::endl;\n//    for (int x : ord) std::cout << x+1 << \" \";\n//    std::cout << std::endl;\n    return parent_representation{parent, ord};\n}\n\nstd::vector<int> strategy_function(const std::vector<int> &u, const std::vector<int> &v)\n{\n    parent_representation rep = get_parent_representation(0, u, v);\n    const auto &parent = rep.parent;\n    const auto &ord = rep.ord;\n    const int n = ord.size();\n    std::vector<int> label(n), used(n), more(n);\n    for (int i = n - 1; i >= 0; --i)\n    {\n        int u = ord[i];\n        for (int k : {1, 2, 4, 8, 16})\n            more[u] |= more[u] >> k;\n        ++more[u];\n        int possible = ~used[u] & -more[u];\n        label[u] = possible & -possible;\n        used[u] |= label[u];\n        used[u] &= -label[u];\n        if (parent[u] != -1)\n        {\n            int p = parent[u];\n            more[p] |= used[u] & used[p];\n            used[p] |= used[u];\n        }\n    }\n    return label;\n}\n\nclass DUninity\n{\npublic:\n    void solve(std::istream& in, std::ostream& out)\n    {\n        using std::vector;\n\n        int n;\n        in >> n;\n\n        vector<int> u(n - 1), v(n - 1);\n        for (int i = 0; i < n - 1; ++i)\n        {\n            in >> u[i] >> v[i];\n            --u[i], --v[i];\n        }\n\n        auto label = strategy_function(u, v);\n        out << std::__lg(*std::max_element(label.begin(), label.end())) << '\\n';\n    }\n};\n\n\nint main()\n{\n    std::ios_base::sync_with_stdio(0);\n    std::istream& in(std::cin);\n    std::ostream& out(std::cout);\n    in.tie(0);\n    DUninity solver;\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n \nconst int N = 1e5 + 7;\n \nvector <int> ad[N];\nint gone[N], n, mrk[N],\tsz[N];\n\nvoid dfs(int v, int p = 0) {\n\tsz[v] = 1;\n\tmrk[v] = 1;\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tdfs(u, v);\n\t\t\tsz[v] += sz[u];\n\t\t}\n\t}\n}\npair <int, int> get(int v, int p, int sall) {\n\tpair <int, int> res;\n\tres.first = v;\n\tres.second = sall - sz[v];\n\tfor (auto u: ad[v])\n\t   \tif (!gone[u] && u != p)\t\n\t\t\tres.second = max(res.second, sz[u]);\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tpair <int, int> t = get(u, v, sall);\n\t\t\tif (t.second < res.second)\n\t\t\t\tres = t;\n\t\t}\n\t}\n\treturn res;\n}\npair <int, int> ffs(int v, int p) {\n\tpair <int, int> mx = {v, 1};\n\tfor (auto u: ad[v])\n\t\tif (u != p) {\n\t\t\tauto t = ffs(u, v);\n\t\t\tt.second++;\n\t\t\tif (t.second > mx.second)\n\t\t\t\tmx = t;\n\t\t}\n\treturn mx;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tad[v].push_back(u);\n\t\tad[u].push_back(v);\n\t}\n\tint res = 0;\n\twhile (1) {\n\t\tbool was = 0;\n\t\tmemset(sz, 0, sizeof sz);\n\t\tmemset(mrk, 0, sizeof mrk);\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tif (!gone[i] && !mrk[i]) {\n\t\t\t\twas = 1;\n\t\t\t\tdfs(i);\n\t\t\t\tint v = get(i, 0, sz[i]).first;\n\t\t\t\tgone[v] = 1;\n\t\t\t}\n\t\tif (!was)\n\t\t\tbreak;\n\t\tres++;\n\t}\n\tint v = ffs(1, 0).first;\n\tint d = ffs(v, 0).second;\n\tint r2 = ((int)log2(d));\n\tcout << (r2 + res) / 2;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nconst int N = 100010;\nint n;\n\nstruct edge{ int to, pre; }e[N << 1]; int u[N], l = 0;\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\n\nint w[N];\nvoid dfs(int x, int f) {\n\tint least = (1<<20)-1, vis = 0, c = 0; w[x] = 0;\n\treg(i,x) if (v != f) dfs(v, x), least &= w[v], vis |= w[v], c++;\n\tif (c <= 1) least = 0;\n\tint t = 0;\n\tdep(j,18,0) if (least >> j & 1) break; else if (!(vis >> j & 1)) t = j;\n\tw[x] = 1 << t; rep(j,t+1,18) w[x] |= vis & (1 << j);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n - 1) { int a, b; scanf(\"%d%d\",&a,&b); ins(a, b), ins(b, a); }\n\tdfs(1,0);\t\n\tdep(j,18,0) if (w[1] >> j & 1) { printf(\"%d\\n\",j); break; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\n\nconst int N=100005;\n\nvector<int>e[N],E[N];\nbool del[N];\nint sz[N],n,ans,mx[N],se[N];\n\nvoid dfs(int x,int fa){sz[x]=1;for(int v:e[x])if(v!=fa&&!del[v])dfs(v,x),sz[x]+=sz[v];}\nint get(int x){\n\tdfs(x,0);\n\tint b,t=x;\n\tdo{b=t,t=-1;for(int v:e[b])if(!del[v]&&sz[v]<sz[b]&&sz[v]>sz[x]/2)t=v;}while(~t);\n\treturn b;\n}\nint work(int x){\n\tx=get(x),del[x]=true;\n\tfor(int v:e[x])if(!del[v]){\n\t\tint d=mx[work(v)]+1;\n\t\tif(d>mx[x])se[x]=mx[x],mx[x]=d;else if(d>se[x])se[x]=d;\n\t}\n\tans=max(ans,mx[x]+se[x]);\n\treturn x;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),e[u].pb(v),e[v].pb(u);\n\twork(1);\n\tprintf(\"%d\\n\",(ans+1)/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 200200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n;\nstd::vector<int> to[maxn];\nint cnt[maxn][20],id[maxn];\nvoid dfs(int x,int f=0){\n\tfor(auto i:to[x])if(i!=f){\n\t\tdfs(i,x);\n\t\trep(j,0,19)cnt[x][j]+=cnt[i][j];\n\t}\n\tint&min=id[x]=0;\n\trep(j,0,19)if(cnt[x][j]>=2)min=j+1;\n\tfor(;min<20&&cnt[x][min];)++min;\n\trep(j,0,min-1)cnt[x][j]=0;\n\tcnt[x][min]=1;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\trep(i, 1, n - 1) {\n\t\tint x, y; cin >> x >> y;\n\t\tto[x].push_back(y);\n\t\tto[y].push_back(x);\n\t}\n\tdfs(1), cout<<*std::max_element(id+1,id+n+1)<<'\\n';;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define ll long long \n#define ret return\n#define PB push_back\n#define lc 2 * v\n#define rc 2 * v + 1\n#define mid (s + e) / 2\n#define pii pair <int,  int>\n#define pll pair <long long , long long>  \n#define FAST ios::sync_with_stdio(false);cin.tie(0);\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n\nconst int maxn = 3e6 + 50 , K = 25;\nvector <int> edges[maxn];\nll a[maxn] , n , ans;\n\nvoid dfs(int v, int p = -1) {\n    int b = 0;\n    for (auto u : edges[v]) {\n        if (u == p) continue;\n        dfs(u , v);\n        for (int i = b; i < K; ++i) {\n            if ((a[v] & a[u]) & (1 << i)) {\n                b = i + 1;\n            }\n        }\n        a[v] |= a[u];\n        while (a[v] & (1 << b)) {\n            b++;\n        }\n    }\n    for (int i = 0; i < b; ++i) {\n        if (a[v] & (1 << i)) {\n            a[v] -= (1 << i);\n        }\n    }\n    a[v] |= (1 << b);\n}\nint main() {\n    FAST\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        edges[u].PB(v);\n        edges[v].PB(u);\n    }\n    dfs(1);\n    for (int i = 0; i < K; ++i) {\n        if (a[1] & (1 << i)) {\n            ans = i;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <fstream>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n//ifstream cin(\"tema.in\");\n//ofstream cout(\"tema.out\");\n\nconst int MAXN = 100000;\n\nvector<int> g[1 + MAXN];\nbool marked[1 + MAXN];\nint weight[1 + MAXN], dad[1 + MAXN], nodes[1 + MAXN];\n\nvoid DFS(int node, int father) {\n    nodes[0]++;\n    nodes[nodes[0]] = node;\n    weight[node] = 1;\n    dad[node] = father;\n    for (auto &son : g[node])\n        if (son != father && !marked[son]) {\n            DFS(son, node);\n            weight[node] += weight[son];\n        }\n}\n\nint Solve(int node) {\n    nodes[0] = 0;\n    DFS(node, 0);\n    if (nodes[0] == 1)\n        return 0;\n    int centroid = 0;\n    for (int i = 1; i <= nodes[0]; i++) {\n        int now = nodes[i], biggest;\n        biggest = nodes[0] - weight[now];\n        for (auto &son : g[now])\n            if (son != dad[now] && !marked[son])\n                biggest = max(biggest, weight[son]);\n        if (biggest <= nodes[0] / 2) {\n            centroid = now;\n            break;\n        }\n    }\n    marked[centroid] = true;\n    int answer = 0;\n    for (auto &son : g[centroid])\n        if (!marked[son])\n            answer = max(answer, Solve(son));\n    return answer + 1;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    cout << Solve(1) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\nconst int nmax=100010;\nconst int L=20;\n\nvi g[nmax];\nbool dp[nmax][L];\n\nvoid dfs(int v,int p){\n\tint cnt[L]{};\n\tfor(auto c:g[v])if(c!=p){\n\t\tdfs(c,v);\n\t\trep(i,L)if(dp[c][i])cnt[i]++;\n\t}\n\tint two=-1;\n\trep(i,L)if(cnt[i]>=2)two=i;\n\tint s=-1;\n\trng(i,two+1,L)if(cnt[i]==0){\n\t\ts=i;\n\t\tbreak;\n\t}\n\tdmp(s);\n\tdp[v][s]=1;\n\trng(i,s+1,L)\n\t\tdp[v][i]=cnt[i];\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\trep(_,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t\n\tdfs(0,-1);\n\tint ans=0;\n\trep(i,L)if(dp[0][i])ans=i;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 1e5 + 10;\n\nint n;\nvi g[maxn];\nunsigned int dp[maxn];\n\nvoid dfs(int u = 1, int par = 0) {\n\tunsigned int s1 = 0, s2 = 0, &s = dp[u];\n\tfor (int v: g[u]) {\n\t\tif(v != par) {\n\t\t\tdfs(v, u);\n\t\t\ts2 |= (dp[v] & s1);\n\t\t\ts1 |= dp[v];\n\t\t}\n\t}\n\ts = 1;\n\twhile(s <= s2) {\n\t\ts <<= 1;\n\t}\n\twhile(s & s1) {\n\t\ts <<= 1;\n\t}\n\ts = ((s > 1) ? (s1 & ~(s - 1)) : s1) | s;\n\treturn;\n}\n\nint main() {\n\tscf(n);\n\trep (i, n - 1) {\n\t\tint u, v;\n\t\tscf(u, v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs();\n\tunsigned int s = 1;\n\tint ans = -1;\n\twhile(s <= dp[1]) {\n\t\ts <<= 1;\n\t\t++ans;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nint n,lg2[100111];\nvector<int>con[100111];\nint dfs(int x,int pre=-1)\n{\n\tint tmp=0,ret=0;\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i];\n\t\tif(u==pre)continue;\n\t\tint nxt=dfs(u,x);\n\t\ttmp|=nxt&ret;\n\t\tret|=nxt;\n\t}\n\tif(tmp==0)return ret+1;\n\tint cur=lg2[tmp]+1;\n\treturn ret&(~((1<<cur)-1))|(1<<cur);\n}\nint main()\n{\n\tfor(int i=2;i<=100005;i++)lg2[i]=lg2[i>>1]+1;\n\tgeti(n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tgetii(x,y);\n\t\tcon[x].PB(y);\n\t\tcon[y].PB(x);\n\t}\n\tcout<<lg2[dfs(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint N;\nvector< int > g[100000];\nbool v[100000][30];\n\nint dfs(int idx, int par) {\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to != par) ret = max(ret, dfs(to, idx));\n  }\n  for(int i = 0; i < 30; i++) {\n    bool correct = true;\n    for(auto &to : g[idx]) {\n      if(to != par) {\n        if(v[to][i]) correct = false;\n      }\n    }\n    if(correct) {\n      ret = max(ret, i);\n      v[idx][i] = true;\n      for(auto &to : g[idx]) {\n        for(int j = i + 1; j < N; j++) {\n          v[idx][j] |= v[to][j];\n        }\n      }\n      break;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  cout << dfs(0, -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define rep(i,j,k) for (i=j;i<=k;i++)\n#define down(i,j,k) for (i=j;i>=k;i--)\nusing namespace std;\nconst int N=1e5+5,K=20;\nint n,i,j,u,v,ans;\nint En,used[N][K],fst[N],nxt[N*2],to[N*2];\nvoid add(int u,int v) { En++; nxt[En]=fst[u]; fst[u]=En; to[En]=v; }\nvoid dfs(int x,int fa)\n{\n\tint i,j,v,g;\n\tfor (j=fst[x];j;j=nxt[j])\n\tif (to[j]!=fa)\n\t{\n\t\tv=to[j];\n\t\tdfs(v,x);\n\t\trep(i,0,K-1)\n\t\t  used[x][i]+=used[v][i];\n\t}\n\tdown(g,K-1,0)\n\t\tif (used[x][g]>1) break;\n\tg++;\n\twhile (used[x][g]) g++;\n\tused[x][g]=1;\n\trep(i,0,g-1) used[x][i]=0;\n\tans=max(ans,g);\n}\nint main()\n{\n//\tfreopen(\"uninity.in\",\"r\",stdin);\n//\tfreopen(\"uninity.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\trep(i,1,n-1)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\n\t}\n\tdfs(1,1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 100 * 1000 + 10;\n\nvector<int> g[N];\nbool del[N];\nint size[N];\nint max_s[N];\nvector<int> cur;\nint ans = 0;\n\nvoid dfs(int v, int par) {\n    size[v] = 1;\n    max_s[v] = 0;\n    cur.push_back(v);\n    for (int to : g[v])\n        if (!del[to] && to != par) {\n            dfs(to, v);\n            size[v] += size[to];\n            max_s[v] = max(max_s[v], size[to]);\n        }\n}\n\nvoid build(int st, int curh) {\n    ans = max(ans, curh);\n    cur.clear();\n    dfs(st, st);\n    if (cur.size() == 1)\n        return;\n    int v = -1;\n    int tot = cur.size();\n    for (int x : cur)\n        if (max_s[x] * 2 <= tot && (tot - size[x]) * 2 <= tot)\n            v = x;\n    assert (v != -1);\n    del[v] = true;\n    for (int to : g[v])\n        if (!del[to])\n            build(to, curh + 1); \n}\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);    \n    }\n    build(0, 0);\n    cout << ans << endl;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nconst int M=101000;\n#define A(a,b) y[++t]=b,N[t]=F[a],F[a]=t\nint n,i,u,v,x,t,y[2*M],N[2*M],F[2*M],Q[2*M];\ninline int DFS(int u,int f) {\n\tint K=0,P=0,S=0;\n\tfor (int j=F[u];j;j=N[j])if(y[j]!=f)S|=((K=DFS(y[j],u))&P),P|=K;\n\treturn(P|((1<<Q[S]+1)-1))+1;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor (i=0;i<n-1;i++) scanf(\"%d%d\",&u,&v),A(u,v),A(v,u);\n\tfor (Q[0]=-1,i=2;!(i>>17);i++) Q[i]=Q[i>>1]+1;\n\tprintf(\"%d\\n\",Q[DFS(1,0)]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nvector<int>V[N];\n\nint n, ans[N];\n\nvoid Dfs (int u, int fa) {\n\tint f = 0, g = 0;\n\tfor (auto v : V[u]) if (v != fa) {\n\t\tDfs(v, u);\n\t\tif (min(ans[v], f) > g) g = min(ans[v], f);\n\t\tif (ans[v] > f) f = ans[v];\n\t}\n\tans[u] = max(f, g + 1); \n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, a, b; i < n; ++i) scanf(\"%d%d\", &a, &b), V[a].push_back(b), V[b].push_back(a);\n\tDfs(1, 0);\n\tprintf(\"%d\\n\", ans[1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nvector<vector<int> > g;\nvector<int> c;\nvector<int> res;\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > pq;\nint main(){\n    int n;\n    cin >> n;\n    g.resize(n);\n    c.resize(n);\n    res.resize(n);\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n        c[a]++;\n        c[b]++;\n    }\n    rep(i,n){\n        if(c[i]==1){\n            pq.push(MP(1,i));\n        }\n    }\n    while(!pq.empty()){\n        auto x = pq.top();\n        pq.pop();\n        int id = x.second;\n        for(auto y:g[id]){\n            res[id] |= res[y];\n        }\n        if(res[id]==0){\n            res[id] = 1;\n        }else{\n            int kkk = 31 - __builtin_clz(res[id]) ;\n            int cc = 0;\n            for(auto y:g[id]){\n                if((res[y]>>kkk)&1)cc++;\n            }\n            int bit = 0;\n            if(cc==1){\n                for(int i=0;i<=20;i++){\n                    bit ^= (1<<i);\n                    if((res[id]>>i)&1){\n                    }else{\n                        res[id] ^= bit; \n                        break;\n                    }\n                }\n            }else{\n                res[id] = (1<<(kkk+1));\n            }\n        }\n        for(auto y:g[id]){\n            c[y]--;\n            if(c[y]==1){\n                pq.push(MP(res[id],y));\n            }\n        }\n    }\n    int mx = 0;\n    rep(i,n){\n        chmax(mx,res[i]);\n        // cerr << i+1 << \" \" << res[i] << endl;\n    }\n    cout << 31 - __builtin_clz(mx) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,fst[N],to[N*2],nxt[N*2],l,fa[N],b[N],Ans;\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n}\nvoid dfs(int x)\n{\n\tint tmp=0;\n\tfor (int i=fst[x];i;i=nxt[i])\n\tif (to[i]!=fa[x])\n\t{\n\t\tfa[to[i]]=x;\n\t\tdfs(to[i]);\n\t\ttmp|=b[to[i]];\n\t}\n\tint t=((~tmp)^((-1<<31)))&(-((~tmp)^((-1<<31))));\n\t//cout<<t<<endl;\n\tb[x]=tmp^t^(tmp&(t-1));\n\tAns=max(Ans,t);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tdfs(1);\n\tint ans=0;\n\twhile(Ans>1)Ans>>=1,ans++;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nvector<int> g[100000];\nbool del[100000];\nint sz[100000];\n\nvoid csz(int v, int p) {\n    sz[v] = 1;\n    for (int to : g[v]) if (to != p && !del[to]) {\n        csz(to, v);\n        sz[v] += sz[to];\n    }\n}\n\nint tmp = 1234;\nint zzz = 0;\n\nint cd(int v, bool root = false) {\n    csz(v, -1);\n    zzz += sz[v];\n    if (zzz > 100000) {\n        zzz = 0;\n        if (clock() > 1.9 * CLOCKS_PER_SEC) {\n            cout << tmp << endl;\n            exit(0);\n        }\n    }\n    int par = -1;\n    int szv = sz[v];\n    while (true) {\n        bool done = true;\n        for (int to : g[v]) if (to != par && !del[to] && 2 * sz[to] >= szv) {\n            par = v;\n            v = to;\n            done = false;\n            break;\n        }\n        if (done) break;\n    }\n    int res, worst, wcnt;\n    par = -1;\n    bool firstTime = true;\n    do {\n        if (firstTime) {\n            firstTime = false;\n        } else {\n            del[v] = false;\n            par = v;\n            v = worst;\n        }\n        del[v] = true;\n        res = 0;\n        worst = -1;\n        wcnt = 0;\n        if (par != -1) {\n            res = cd(par) + 1;\n            worst = par;\n            wcnt = 1;\n        }\n        for (int to : g[v]) if (!del[to] && to != par) {\n            int val = cd(to) + 1;\n            if (val > res) {\n                res = val;\n                worst = to;\n                wcnt = 1;\n            } else if (val == res) {\n                ++wcnt;\n            }\n        }\n        if (root) {\n            tmp = min(tmp, res);\n        }\n    } while (wcnt == 1 && worst != par);\n    del[v] = false;\n    return res;\n}\n\nint cd2(int v, bool root = false) {\n    csz(v, -1);\n    zzz += sz[v];\n    if (zzz > 100000) {\n        zzz = 0;\n        if (clock() > 1.9 * CLOCKS_PER_SEC) {\n            cout << tmp << endl;\n            exit(0);\n        }\n    }\n    int par = -1;\n    int szv = sz[v];\n    while (true) {\n        bool done = true;\n        for (int to : g[v]) if (to != par && !del[to] && 2 * sz[to] >= szv) {\n            par = v;\n            v = to;\n            done = false;\n            break;\n        }\n        if (done) break;\n    }\n    int res, worst, wcnt;\n    par = -1;\n    bool firstTime = true;\n    do {\n        if (firstTime) {\n            firstTime = false;\n        } else {\n            del[v] = false;\n            par = v;\n            v = worst;\n        }\n        del[v] = true;\n        res = 0;\n        worst = -1;\n        wcnt = 0;\n        if (par != -1) {\n            res = cd2(par) + 1;\n            worst = par;\n            wcnt = 1;\n        }\n        for (int to : g[v]) if (!del[to] && to != par) {\n            int val = cd2(to) + 1;\n            if (val > res) {\n                res = val;\n                worst = to;\n                wcnt = 1;\n            } else if (val == res) {\n                ++wcnt;\n            }\n        }\n        if (root) {\n            tmp = min(tmp, res);\n        }\n    } while (false);\n    del[v] = false;\n    return res;\n}\n\nint main() {\n//    scanf(\"%d\", &n);\n//    forn(i, n - 1) {\n//        int from, to;\n//        scanf(\"%d%d\", &from, &to), --from, --to;\n//        g[from].pb(to);\n//        g[to].pb(from);\n//    }\n\n    n = 100000;\n    mt19937 mt(123);\n    for (int i = 1; i < n; ++i) {\n        int to = i / 4 + mt() % (i - i / 4);\n        g[i].pb(to);\n        g[to].pb(i);\n    }\n\n    cd2(0, true);\n    //cerr << clock() << endl;\n    int res = cd(0, true);\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Optimise\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n// #define MULTI_TEST\n#ifdef LOCAL\n#define db(...) ZZ(#__VA_ARGS__, __VA_ARGS__);\n#define pc(...) PC(#__VA_ARGS__, __VA_ARGS__);\ntemplate <typename T, typename U>\nostream &operator<<(ostream &out, const pair<T, U> &p)\n{\n    out << '[' << p.first << \", \" << p.second << ']';\n    return out;\n}\ntemplate <typename Arg>\nvoid PC(const char *name, Arg &&arg)\n{\n    while (*name == ',' || *name == ' ')\n        name++;\n    std::cerr << name << \" { \";\n    for (const auto &v : arg)\n        cerr << v << ' ';\n    cerr << \" }\\n\";\n}\ntemplate <typename Arg1, typename... Args>\nvoid PC(const char *names, Arg1 &&arg1, Args &&... args)\n{\n    while (*names == ',' || *names == ' ')\n        names++;\n    const char *comma = strchr(names, ',');\n    std::cerr.write(names, comma - names) << \" { \";\n    for (const auto &v : arg1)\n        cerr << v << ' ';\n    cerr << \" }\\n\";\n    PC(comma, args...);\n}\ntemplate <typename Arg1>\nvoid ZZ(const char *name, Arg1 &&arg1)\n{\n    std::cerr << name << \" = \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid ZZ(const char *names, Arg1 &&arg1, Args &&... args)\n{\n    const char *comma = strchr(names + 1, ',');\n    std::cerr.write(names, comma - names) << \" = \" << arg1;\n    ZZ(comma, args...);\n}\n#else\n#define db(...)\n#define pc(...)\n#endif\n\nusing ll = long long;\ntemplate <typename T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define f first\n#define s second\n#define pb push_back\n#define all(v) v.begin(), v.end()\nauto TimeStart = chrono::steady_clock::now();\nauto seed = TimeStart.time_since_epoch().count();\nstd::mt19937 rng(seed);\ntemplate <typename T>\nusing Random = std::uniform_int_distribution<T>;\n\nconst int NAX = 2e5 + 5, MOD = 1000000007;\nvector<int> adj[NAX];\nint dp[NAX][20];\nint ans = 0;\n\nvoid dfs(int node, int par)\n{\n    for (auto child : adj[node])\n        if (child != par)\n        {\n            dfs(child, node);\n            for (int i = 0; i < 20; ++i)\n                dp[node][i] += dp[child][i];\n        }\n    int st = 0;\n    for (int i = 19; i >= 0; --i)\n        if (dp[node][i] >= 2)\n        {\n            st = i;\n            break;\n        }\n    for (int i = st;; ++i)\n        if (dp[node][i] == 0)\n        {\n            dp[node][i] = 1;\n            ans = max(ans, i);\n            for (int j = i - 1; j >= 0; --j)\n                dp[node][j] = 0;\n            return;\n        }\n}\n\nvoid solveCase(int caseNo)\n{\n    int n, u, v;\n    cin >> n;\n    for (int i = 1; i < n; ++i)\n    {\n        cin >> u >> v;\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n    dfs(1, 0);\n    cout << ans << '\\n';\n#ifdef LOCAL\n    for (int i = 1; i <= n; ++i)\n    {\n        cout << i << '\\n';\n        for (int j = 0; j < 20; ++j)\n            cout << dp[i][j] << ' ';\n        cout << '\\n';\n    }\n#endif\n}\n\nint main()\n{\n#ifndef LOCAL\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#endif\n    int t = 1;\n#ifdef MULTI_TEST\n    cin >> t;\n#endif\n    for (int i = 1; i <= t; ++i)\n    {\n        solveCase(i);\n#ifdef TIME\n        cerr << \"Case #\" << i << \": Time \" << chrono::duration<double>(chrono::steady_clock::now() - TimeStart).count() << \" s.\\n\";\n        TimeStart = chrono::steady_clock::now();\n#endif\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nint n,w[N],head[N],nxt[N];\nvoid add(int f,int t){\n\tstatic int cnt=0;\n\tw[++cnt]=t;\n\tnxt[cnt]=head[f];\n\thead[f]=cnt;\n}\nint dep[N];\nvoid dfs(int x,int fa){\n\tfor (int i=head[x];i;i=nxt[i])\n\tif (w[i]!=fa) dep[w[i]]=dep[x]+1,dfs(w[i],x);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);add(v,u);\n\t}\n\tdep[1]=1;dfs(1,0);\n\tint v=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (dep[i]>dep[v]) v=i;\n\tdep[v]=1;dfs(v,0);\n\tint len=0;\n\tfor (int i=1;i<=n;i++) len=max(len,dep[i]);\n\t//printf(\"%d\\n\",len);\n\tint k=1,ans=0;\n\twhile (k<len) k=k*2+1,ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++) assert(used[i]);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    //break;\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n\n      if(c<0){\n\tused[v]=1;\n\tbelong[v]=t;\n\tcontinue;\n      }\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      \n      for(Int u:G[c]){\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    //break;\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PPI;\ntypedef pair<ll,P> PIP;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\n#define PQ(T) priority_queue<T,vector<T>,greater<T>>\n#define PQ2(T) priority_queue<T>\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define REP(i,a,b) for(ll (i)=a;(i)<(ll)(b);++(i))\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n+1)\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) ((x)=min((x),(y)))\n#define chmax(x,y) ((x)=max((x),(y)))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\n#define DEBUG(x) cerr<<\"line (\"<<__LINE__<<\")  \"<<#x<<\": \"<<x<<endl;\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\n#define N 100010\nvector<int> g[N];\nint n, d[N];\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v; u--; v--;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tqueue<int> q;\n\trep(i, n) if(g[i].size()==1) q.push(i);\n\tint cnt = 0;\n\twhile(q.size()>1){\n\t\tqueue<int> q2;\n\t\twhile(!q.empty()){\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(auto v: g[u]){\n\t\t\t\td[v]++;\n\t\t\t\tif(g[v].size()-d[v]==1) q2.push(v);\n\t\t\t}\n\t\t}\n\t\tq.swap(q2);\n\t\tcnt++;\n\t}\n\tint res = 0;\n\twhile(cnt){\n\t\tcnt >>= 1;\n\t\tres++;\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, f[105000], g[22];\nvector<int>G[105000];\n\nvoid dfs(int x,int fff){\n  for (auto y:G[x])\n    if (y!=fff)\n      dfs(y,x);\n  memset(g,0,sizeof g);\n  for (auto y:G[x])\n    if (y!=fff){\n      for (int i=0;i<=20;++i){\n\tint tmp=f[y]>>i<<i;\n\tif (tmp>>i&1) tmp+=1<<i;\n\tg[i]=max(g[i],tmp);\n      }\n    }\n  f[x]=998244353;\n  for (int i=0;i<=20;++i)\n    f[x]=min(f[x],g[i]|1<<i);\n}\n\nint main(){\n  cin>>n; int x, y;\n  for (int tim=n-1;tim--;){\n    cin>>x>>y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  dfs(1,0);\n  int ans=0;\n  for (int t=f[1];t;t>>=1) ++ans;\n  cout<<ans-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/hash_map>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define REP(i,n) for( (i)=0 ; (i)<(n) ; (i)++ )\n#define rep(i,x,n) for( (i)=(x) ; (i)<(n) ; (i)++ )\n#define REV(i,n) for( (i)=(n) ; (i)>=0 ; (i)-- )\n#define FORIT(it,x) for( (it)=(x).begin() ; (it)!=(x).end() ; (it)++ )\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define rforeach(it,c) for(__typeof((c).rbegin()) it=(c).rbegin();it!=(c).rend();++it)\n#define foreach2d(i, j, v) foreach(i,v) foreach(j,*i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define SZ(x) ((int)(x).size())\n#define MMS(x,n) memset(x,n,sizeof(x))\n#define mms(x,n,s) memset(x,n,sizeof(x)*s)\n#define pb push_back\n#define mp make_pair\n#define NX next_permutation\n#define UN(x) sort(all(x)),x.erase(unique(all(x)),x.end())\n#define CV(x,n) count(all(x),(n))\n#define FIND(x,n) find(all(x),(n))-(x).begin()\n#define ACC(x) accumulate(all(x),0)\n#define PPC(x) __builtin_popcountll(x)\n#define LZ(x) __builtin_clz(x)\n#define TZ(x) __builtin_ctz(x)\n#define mxe(x) *max_element(all(x))\n#define mne(x) *min_element(all(x))\n#define low(x,i) lower_bound(all(x),i)\n#define upp(x,i) upper_bound(all(x),i)\n#define NXPOW2(x) (1ll << ((int)log2(x)+1))\n#define PR(x) cout << #x << \" = \" << (x) << endl ;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\n\nconst int OO = (int) 2e9;\nconst double eps = 1e-9;\n\nconst int N = 300005;\n\nint n;\nvi adj[N];\nint res;\nint leaf[N];\n\nint getMaxBit(int x) {\n\tfor (int i = 30; i >= 0; i--) {\n\t\tif (x & (1 << i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint solve(int cur, int par = -1) {\n\tint msk = 0;\n\tint doubleMask = 0;\n\tfor (auto to : adj[cur]) {\n\t\tif (to == par)\n\t\t\tcontinue;\n\t\tint ch = solve(to, cur);\n\t\tdoubleMask |= (ch & msk);\n\t\tmsk |= ch;\n\t}\n\tif (doubleMask > 0) {\n\t\tmsk |= getMaxBit(doubleMask << 1) - 1;\n\t}\n\t++msk;\n\tres = max(res, msk);\n\treturn msk;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"rt\", stdin);\n//\tfreopen(\"out.txt\", \"wt\", stdout);\n#endif\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--, t--;\n\t\tadj[f].pb(t);\n\t\tadj[t].pb(f);\n\t\tleaf[f]++;\n\t\tleaf[t]++;\n\t}\n\tint root = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (leaf[i] == 1) {\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsolve(root);\n\tcout << getMaxBit(res) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n// manually set n = number of vertices \n// vertex index from 1 to n\n// first call tree_init();\n// ae(u,v) only one direction\n\nconst int TREE_MAXV=300000+5;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pre[TREE_MAXV];\nint n;\nint f[333333];\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpre[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t}\n\t}\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\nvoid readedge(){\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;gn(x);gn(y);\n\t\tae(x,y);ae(y,x);\n\t}\n}\n\n\nvoid work(int u){\n\tint gg=0,tmp=0;\n\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\tgg^=f[e[i].v]&tmp;\n\t\ttmp|=f[e[i].v];\n\t}\n\tif(gg>0){\n\t\twhile(gg&(gg-1))gg&=gg-1;\n\t\ttmp|=gg&(gg-1);\n\t}\n\tf[u]=tmp+1;\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);\n\ttree_init();\n\treadedge();\n\n\tbfs(1);\n\tfor(int i=n-1;i>=0;i--)work(qu[i]);\n\tint ret=1;\n\twhile(pw(ret)<=f[1])ret++;\n\tprintf(\"%d\\n\",ret-1);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 100;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tsrand(clock());\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t}\n\t\n\tcout << ANS << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,s[100005];\nbool b[100005];\nvector<int> v[100005];\nvoid dfs(int x,int y){\n    s[x]=1;\n    for(int i=0;i<v[x].size();++i){\n        int z=v[x][i];\n        if(b[z]||z==y) continue;\n        dfs(z,x);\n        s[x]+=s[z];\n    }\n}\nint solve(int x){\n    dfs(x,0);\n    int o=s[x]/2,y=0;\n    while(1){\n        bool ok=0;\n        for(int i=0;i<v[x].size();++i){\n            int z=v[x][i];\n            if(b[z]||z==y) continue;\n            if(s[z]>o){\n                y=x,x=z,ok=1;\n                break;\n            }\n        }\n        if(!ok) break;\n    }\n    b[x]=1;\n    int ret=-1;\n    for(int i=0;i<v[x].size();++i){\n        int z=v[x][i];\n        if(!b[z])ret=max(ret,solve(z));\n    }\n    return ret+1;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    printf(\"%d\\n\",solve(1));\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<19)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\t// while((f[u]>>mn&1) || ((1<<mn)<=mx))++mn;\n\twhile(f[u]>>mn&1)++mn;\n\t// f[u]=(f[u]>>mn<<mn)|(1<<mn);\n\t// ans=max(ans,mn);\n\tfor(int i=30;;--i)\n\t\tif(i<mn || (mx>>i&1))\n\t\t{\n\t\t\t++i;\n\t\t\t// f[u]&=S-((1<<i)-1);\n\t\t\t// f[u]|=1<<i;\n\t\t\tf[u]=(f[u]>>i<<i)|(1<<i);\n\t\t\tans=max(ans,i);\n\t\t\t// cerr<<u<<\" \"<<i<<endl;\n\t\t\tbreak;\n\t\t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n4 8\n8 9\n9 10\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define queue QQQ\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 1e5+233;\nvector<int> edge[maxn];\nint n,bit[maxn],f[maxn],ans=0;\nvoid dfs(int u,int fa){\n\tint l = 0;\n\tfor(auto v:edge[u]){\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tl |= bit[u] & bit[v];\n\t\tbit[u] |= bit[v];\n\t}\n\tif(!bit[u]) bit[u] = 1;\n\telse{\n\t\twhile ((1<<f[u])<l || (1<<f[u])&bit[u]) f[u]++;\n\t\tbit[u]=(bit[u]>>f[u]<<f[u])|(1<<f[u]);\n    }\n    ans=max(ans,f[u]);\n}\nint main(){\n\tn = rd();\n\tRep(i,1,n) edge[i] . clear();\n\trep(i,1,n){\n\t\tint a = rd(),b = rd();\n\t\tedge[a] . push_back(b);\n\t\tedge[b] . push_back(a);\n\t}\n\tdfs(1,-1);\n\twriteln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <cstdio>\n#include <limits>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <fstream>\n#include <numeric>\n#include <sstream>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define f first\n#define s second\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n#define ll long long\n#define ld long double\n#define ull unsigned long long\n#define PI pair < int, int > \n\nconst ld Pi = acos(-1);\nconst ll Inf = 1e18;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nconst ld eps = 1e-12;\nconst int N = 1e5 + 123;\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) a -= mod;\n}\nint mult(int a, int b) {\n  return 1ll * a * b % mod;\n}\nint sum(int a, int b) {\n  add(a, b);\n  return a;\n}\n\nint t;\nint n, ans[N], cnt[30];\nvector < int > g[N];\n\nvoid dfs(int v = 1, int p = -1) {\n  for (auto to : g[v]) {\n    if (to != p) {\n      dfs(to, v);\n    }\n  }\n  memset(cnt, 0, sizeof cnt);\n  for (auto to : g[v]) {\n    if (to != p) {\n      for (int j = 0;j < 30;j++) cnt[j] += ((ans[to] >> j) & 1);\n    }\n  }\n  int id = -1;\n  for (int j = 0;j < 30;j++) {\n    if (cnt[j] > 1) {\n      id = j;\n    }\n  }\n  int pos = -1;\n  for (int j = id + 1;j < 30;j++) {\n    if (cnt[j] == 0) {\n      pos = j;\n      break;\n    }\n  }\n  ans[v] += 1 << pos;\n  for (int j = pos + 1;j < 30;j++) {\n    if (cnt[j]) ans[v] += 1 << j;\n  } \n}\nvoid solve() {\n  cin >> n;\n  for (int i = 1, u, v;i < n;i++) {\n    cin >> u >> v;\n    g[u].pb(v);\n    g[v].pb(u);\n  }\n  dfs();\n  int id = -1;\n  for (int i = 0;i < 30;i++) {\n    if ((ans[1] >> i) & 1) {\n      id = i;\n    }\n  }\n  cout << id << endl;\n}\nint main() {\n  #ifdef wws\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout); \n  #endif \n  ios_base::sync_with_stdio(0);\n  t = 1;\n  while(t--) solve();\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 1e5 + 20 ;\nint n , val[N] ;\nvector <int> g[N] ;\n\ninline int best (int x) {\n\tfor (int i = 20 ; i >= 0 ; i --)\n\t\tif (x >> i & 1) return i ;\n\n\treturn -1 ;\n}\n\nvoid dfs (int v , int par = -1) {\n\tint mx = -1 ;\n\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue ;\n\n\t\tdfs(u , v) ;\n\n\t\tmx = max(mx , best(val[v] & val[u])) ;\n\n\t\tval[v] |= val[u] ;\n\t}\n\n\tfor (int i = 0 ; i <= 20 ; i ++) {\n\t\tif (i <= mx || (val[v] & (1 << i))) {\n\t\t\tval[v] = ((val[v] | (1 << i)) ^ (1 << i)) ;\n\t\t\tcontinue ;\n\t\t}\n\n\t\tval[v] = (val[v] | (1 << i)) ;\n\t\tbreak ;\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tfor (int i = 0 , u , v ; i < n - 1 ; i ++) {\n\t\tcin >> u >> v ;\n\t\tu -- , v -- ;\n\t\tg[u].push_back(v) ;\n\t\tg[v].push_back(u) ;\n\t}\n\n\tdfs(0) ;\n\n\tcout << best(val[0]) << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=100010;\nint n,e,first[maxn],to[maxn<<1],nxt[maxn<<1];\nvoid AddEdge(int u,int v) {\n\tto[++e]=v;nxt[e]=first[u];first[u]=e;\n\tto[++e]=u;nxt[e]=first[v];first[v]=e;\n}\nint f[maxn],ans;\nvoid dp(int x,int fa) {\n\tint g=0;\n\tfor(int i=first[x];i;i=nxt[i]) if(to[i]!=fa) {\n\t\tdp(to[i],x);\n\t\tg|=f[x]&f[to[i]];\n\t\tf[x]|=f[to[i]];\n\t}\n\tint j=0;\n\twhile((1<<j)<g||(f[x]>>j&1)) j++;\n\tans=max(ans,j);\n\tf[x]=((f[x]>>j)<<j)|(1<<j);\n}\nint main() {\n\tn=read();\n\trep(i,2,n) AddEdge(read(),read());\n\tdp(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _LOCAL_\n\t#define cout cerr\n#endif\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define FORalld(it, a) for (__typeof((a).rbegin()) it = (a).rbegin(); it != (a).rend(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ntemplate<class T> inline T isqrt(T k) {T r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ntemplate<class T> inline T icbrt(T k) {T r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n\nconst int MAXN = 100000 + 5;\nint n;\nvector<int> adj[MAXN];\nint del[MAXN];\nint size[MAXN];\nvoid dfs(int u, int p) {\n\tsize[u] = 1;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v != p && !del[v]) {\n\t\t\tdfs(v, u);\n\t\t\tsize[u] += size[v];\n\t\t}\n\t}\n}\nint findcentroid(int u) {\n\tint p = -1; dfs(u, -1);\n\tint cap = size[u] >> 1;\n\twhile (1) {\n\t\tbool found = false;\n\t\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\t\tint v = adj[u][i];\n\t\t\tif (v != p && !del[v] && size[v] > cap) {\n\t\t\t\tfound = true;\n\t\t\t\tp = u; u = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) return u;\n\t}\n}\nint divide(int u) {\n\tu = findcentroid(u);\n\tdel[u] = 1;\n\tint res = 0;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i];\n\t\tif (!del[v]) {\n\t\t\tres |= divide(v);\n\t\t}\n\t}\n\tFOR(i, 0, 30) if (!bit(res, i)) {\n\t\tFOR(j, 0, i) res |= 1 << j, res ^= 1 << j;\n\t\tres |= 1 << i;\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> n;\n\tFOR(i, 0, n - 1) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tint res = divide(0);\n\tif (!res) {\n\t\tcout << 0 << \"\\n\";\n\t\treturn;\n\t}\n\tFOR(i, 0, 30) if (!bit(res, i)) {\n\t\tcout << max(i, __lg(res)) << \"\\n\";\n\t\treturn;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct node {\n\tint to, next;\n} edge[MAXN*2];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nint n, a, b;\nint vis[MAXN], depth[MAXN], fa[MAXN];\nint len = 0, pos = 0;\n\nvoid dfs_len(int nd, int f)\n{\n\tfa[nd] = f;\n\tif (depth[nd] > len) len = depth[nd], pos = nd;\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (to == f || vis[to]) continue;\n\t\tdepth[to] = depth[nd]+1;\n\t\tdfs_len(to, nd);\n\t}\n}\n\nint find_center(int nd)\n{\n\tlen = 0, pos = 0, depth[nd] = 0, dfs_len(nd, 0);\n\tint cur = pos;\n\tlen = 0, pos = 0, depth[cur] = 0, dfs_len(cur, 0);\n\tfor (int i = 1; i <= len/2; i++)\n\t\tpos = fa[pos];\n\treturn pos;\n}\n\nint dfs(int nd)\n{\n\tnd = find_center(nd);\n\tif (nd == 0) return 0;\n\tvis[nd] = 1;\n\tint ans = 0;\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (vis[to]) continue;\n\t\tans = max(ans, dfs(to)+1);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpush(a, b), push(b, a);\n\t}\n\tcout << dfs(1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#define MAXN 100000\nusing namespace std;\ntypedef long long LL;\nvector<int> G[MAXN+5];\nint N,ans;\nint cnt[MAXN+5][21];\nvoid DFS(int u,int fa)\n{\n\tfor(int i=0;i<(int)G[u].size();i++)\n\t{\n\t\tint v=G[u][i];\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tDFS(v,u);\n\t\tfor(int j=0;j<20;j++)\n\t\t\tcnt[u][j]+=cnt[v][j];\n\t}\n\tint val=0;\n\tfor(int i=20;i>=0;i--)\n\t\tif(cnt[u][i]>=2)\n\t\t{\n\t\t\tval=i+1;\n\t\t\tbreak;\n\t\t}\n\twhile(cnt[u][val]==1)\n\t\tval++;\n\tans=max(ans,val);\n\tcnt[u][val]++;\n\tfor(int i=0;i<val;i++)\n\t\tcnt[u][i]=0;\n}\nint main()\n{\n//\tfreopen(\"uninity.in\",\"r\",stdin);\n//\tfreopen(\"uninity.out\",\"w\",stdout);\n\tscanf(\"%d\",&N);\n\tint u,v;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tDFS(1,-1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint getv(int a)\n{\n    if(a==1) return 0;\n    return getv(a/2) + 1;\n}\nvoid dfs(vector<set<int> >& graph, int a, int pa, bool fillflag, vector<bool>& rm)\n{\n    if(graph[a].size() >= 3) fillflag = false;\n    rm[a] = fillflag;\n    for(auto x: graph[a])\n    {\n        if(x==pa) continue;\n        dfs(graph, x, a, !fillflag, rm);\n    }\n}\nint solve(vector<set<int> > graph)\n{\n    if(graph.size() == 1) return 0;\n    if(graph.size() <= 3) return 1;\n    int degover2 = 0;\n    for(int i=0; i<graph.size(); ++i)\n    {\n        if(graph[i].size() > 2) degover2 = i;\n    }\n    if(degover2 == 0)\n    {\n        return getv(graph.size());\n    }\n    vector<bool> rm(graph.size(), false);\n    dfs(graph, degover2, -1, false, rm);\n    \n    \n    int tp = 0;\n    vector<int> acc(graph.size(), -1);\n    vector<int> invacc;\n    for(int i=0; i<graph.size(); ++i)\n        if(!rm[i])\n        {\n            acc[i] = tp++;\n            invacc.push_back(i);\n        }\n    for(int i=0; i<graph.size(); ++i)\n    {\n        if(!rm[i]) continue;\n        assert(graph[i].size() == 1 || graph[i].size() == 2);\n        if(graph[i].size() == 1)\n        {\n            int t = *graph[i].begin();\n            graph[t].erase(i);\n        }\n        else if(graph[i].size() == 2)\n        {\n            int t = *graph[i].begin();\n            int u = *graph[i].rbegin();\n            graph[t].erase(i); graph[u].erase(i);\n            graph[t].insert(u); graph[u].insert(t);\n        }\n    }\n    vector<set<int> > newgraph(tp);\n    for(int i=0; i<tp; ++i)\n    {\n        int targ = invacc[i];\n        for(auto x: graph[targ])\n        {\n            assert(acc[x] != -1);\n            newgraph[i].insert(acc[x]);\n        }\n    }\n    return 1 + solve(newgraph);\n}\nint main()\n{\n    int N;\n    scanf(\"%d\", &N);\n    vector<set<int> > graph(N);\n    for(int i=0; i<N-1; ++i)\n    {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        graph[u].insert(v);\n        graph[v].insert(u);\n    }\n    printf(\"%d\\n\", solve(graph));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint head[100001], next[199999], to[199999], q[100001], fa[100001], N, E, f[100001][20];\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, u, v; i < N; i++)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tnext[++E] = head[u], to[E] = v, head[u] = E;\n\t\tnext[++E] = head[v], to[E] = u, head[v] = E;\n\t}\n\tint H = 0, T = 1, u;\n\tq[1] = 1;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\tfor (int i = N; i; i--)\n\t{\n\t\tint u = q[i];\n\t\tfor (int e = head[u]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t\tfor (int j = 0; j < 20; j++)\n\t\t\t\t\tf[u][j] += f[to[e]][j];\n\t\tf[u][0]++;\n\t\tfor (int j = 0; j < 19; j++)\n\t\t\tif (f[u][j] > 1)\n\t\t\t{\n\t\t\t\tf[u][j] = 0;\n\t\t\t\tf[u][j + 1]++;\n\t\t\t}\n\t}\n\tint D = 19;\n\twhile (!f[1][D])\n\t\tD--;\n\tprintf(\"%d\\n\", D);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned int uint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=100010;\ninline uint lowbit(uint x){\n\treturn x&-x;\n}\ninline uint highbit(uint x){\n\tfor(;x!=(x&-x);x^=x&-x);\n\treturn x;\n}\nnamespace T{\n\tconst int E=N<<1;\n\tint to[E],bro[E],head[N],e=0;\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tuint dfs(int x,int fa){\n\t\tuint ans=0,hb=1;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])!=fa){\n\t\t\t\tuint cur=dfs(v,x);\n\t\t\t\tapmax(hb,highbit(cur&ans)<<1);\n\t\t\t\tans|=cur;\n\t\t\t}\n\t\t}\n\t\tfor(;hb&ans;hb<<=1);\n\t\treturn hb|(ans&~(hb-1));\n\t}\n}\nint main(){\n\tint n=ni;\n\tT::init();\n\tfor(int i=1;i<n;T::add(ni,ni),i++);\n\tuint tmp=T::dfs(1,0);\n\tint ans=0;\n\tfor(;tmp>1;tmp>>=1,ans++);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nvector<int> g[101010];\nint d[101010];\nint del[101010];\n\nint md=0;\n\nvoid dfs1(int x, int p){\n\td[x]=0;\n\tfor (int nx:g[x]){\n\t\tif (del[nx]) continue;\n\t\tif (nx!=p){\n\t\t\tdfs1(nx, x);\n\t\t\tmd=max(md, d[x]+d[nx]+1);\n\t\t\td[x]=max(d[x], d[nx]+1);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x, int p, int pd, vector<int>& cdv){\n\tint d1=pd;\n\tint d2=0;\n\tint d1v=0;\n\tfor (int nx:g[x]){\n\t\tif (del[nx]) continue;\n\t\tif (nx!=p){\n\t\t\tif (d[nx]+1>d1){\n\t\t\t\td2=d1;\n\t\t\t\td1=d[nx]+1;\n\t\t\t\td1v=nx;\n\t\t\t}\n\t\t\telse if(d[nx]+1>d2){\n\t\t\t\td2=d[nx]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif (d1+d2==md&&min(d1, d2)>=md/2){\n\t\tcdv.push_back(x);\n\t}\n\tfor (int nx:g[x]){\n\t\tif (del[nx]) continue;\n\t\tif (nx!=p){\n\t\t\tif (d1v==nx){\n\t\t\t\tdfs2(nx, x, d2+1, cdv);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdfs2(nx, x, d1+1, cdv);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int x){\n\tmd=0;\n\tdfs1(x, 0);\n\tvector<int> cdv;\n\tif (md==0) return 0;\n\tif (md<=2) return 1;\n\tdfs2(x, 0, 0, cdv);\n\tassert((int)cdv.size()<=2);\n\tassert((int)cdv.size()>=1);\n\tif (cdv.size()==1){\n\t\tdel[cdv[0]]=1;\n\t\tint v=0;\n\t\tfor (int nx:g[cdv[0]]){\n\t\t\tif (!del[nx]){\n\t\t\t\tv=max(v, solve(nx)+1);\n\t\t\t}\n\t\t}\n\t\tdel[cdv[0]]=0;\n\t\treturn v;\n\t}\n\telse{\n\t\tdel[cdv[0]]=1;\n\t\tint v1=solve(cdv[1])+1;\n\t\tdel[cdv[0]]=0;\n\t\tdel[cdv[1]]=1;\n\t\tint v2=solve(cdv[0])+1;\n\t\tdel[cdv[1]]=0;\n\t\treturn min(v1, v2);\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor (int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint v=solve(1);\n\tcout<<v<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> bool chkmax(T &a, const T &b) { return a < b ? a = b, true : false; }\ntemplate <typename T> bool chkmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\ntypedef long long LL;\ntypedef long double LD;\nconst int BUF_SIZE = (int)2e7 + 10;\nstruct fastIO {\n    char buf[BUF_SIZE], buf1[BUF_SIZE];\n    int cur, cur1; FILE *in, *out;\n    fastIO() { cur = BUF_SIZE, in = stdin, out = stdout; cur1 = 0; __builtin_prefetch(buf);__builtin_prefetch(buf1);}\n    inline char getchar() { if(cur == BUF_SIZE) fread(buf, BUF_SIZE, 1, in), cur = 0; return *(buf + (cur++)); }\n    inline void putchar(char ch) { *(buf1 + (cur1++)) = ch; if (cur1 == BUF_SIZE) fwrite(buf1, BUF_SIZE, 1, out), cur1 = 0; }\n    inline int flush() { if (cur1 > 0) fwrite(buf1, cur1, 1, out); return cur1 = 0; }\n}IO;\n#define getchar IO.getchar\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n} \n\nconst int Maxn = 1e5 + 9;\nstruct edge {\n\tint to, nxt;\n}g[Maxn << 1];\nint n, head[Maxn];\nvoid add(int u, int v) { \n\tstatic int e = 0;\n\tg[++e] = (edge){v, head[u]}, head[u] = e; \n}\n\nint ans = 0;\nstatic int bit[Maxn];\n\nint calc(int limit) {\n    int mx=20;\n    while(mx>=0&&(!(limit&(1<<mx))))mx--;\n    mx++;\n\treturn mx;\n}\n\nvoid dfs(int u, int pa) {\n\tint same = 0;\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tdfs(v, u);\n\t\t\tsame |= bit[u] & bit[v];\n\t\t\tbit[u] |= bit[v];\n\t\t}\n\t}\n\tint mx = same ? 32 - __builtin_clz(same) : 0;\n\twhile (bit[u] & (1 << mx)) ++mx;\n\tbit[u] |= (1 << mx);\n\tchkmax(ans, mx), bit[u] = bit[u] >> mx << mx;\n}\n\nint main() {\n\n\tclar(head, -1);\n\tn = read();\n\trep (i, 1, n - 1) {\n\t\tint u = read(), v = read();\n\t\tadd(u, v), add(v, u);\n\t}\n\tdfs(1, 0);\n\tcout << ans << endl;\n\n#ifdef Qrsikno\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n\nvector<int> tree[100100];\nint finished[100100];\nint sz[100100];\n\nvoid dfs(int v,int p = -1) {\n\tsz[v] = 1;\n\tfor(auto u : tree[v]) {\n\t\tif(finished[u] || u == p)\n\t\t\tcontinue;\n\t\tdfs(u,v);\n\t\tsz[v] += sz[u];\n\t}\n}\n\nint root;\nint get_root(int v,int p = -1) {\n\tfor(auto u : tree[v]) {\n\t\tif(finished[u] || u == p)\n\t\t\tcontinue;\n\t\tif(sz[u] * 2 > sz[root])\n\t\t\treturn get_root(u,v);\n\t}\n\treturn v;\n}\n\nint res = 0;\n\nvoid centroid(int v,int dep = 0) {\n\tdfs(v);\n\troot = v;\n\tint new_root = get_root(v);\n\tres = max(res,dep);\n\tfinished[new_root] = true;\n\tfor(auto u : tree[new_root]) {\n\t\tif(finished[u])\n\t\t\tcontinue;\n\t\tcentroid(u,dep+1);\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint N,u,v;\n\tcin>>N;\n\tfor(int i = 1;i < N;i++) {\n\t\tcin>>u>>v;\n\t\tu--,v--;\n\t\ttree[u].push_back(v);\n\t\ttree[v].push_back(u);\n\t}\n\tcentroid(0);\n\tcout<<res<<'\\n';\n\treturn 0;\n}\n/**/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const N = 1234567;\n\nvector<int> edges[N];\nint down[N];\n\nint ans;\n\nvoid dfs(int v, int pv) {\n  down[v] = 0;\n  int mx = 0;\n  int mx2 = 0;\n  for (int to : edges[v]) {\n    if (to == pv) continue;\n    dfs(to, v);\n    down[v] = std::max(down[v], down[to] + 1);\n    if (down[to] + 1 > mx) {\n      mx2 = mx;\n      mx = down[to] + 1;\n    } else if (down[to] + 1 > mx2) {\n      mx2 = down[to] + 1;\n    }\n  }\n  ans = std::max(ans, mx + mx2);\n}\n\n// void dfs2(int v, int pv, int cUp) {\n//   int mx = cUp;\n//   int mx2 = -1;\n//   for (int to : edges[v]) {\n//     if (to == pv) continue;\n//     if (down[to] > mx) {\n//       mx2 = mx;\n//       mx = down[to];\n//     } else if (down[to] > mx2) {\n//       mx2 = down[to];\n//     }\n//   }\n//   ans = std::min(ans, mx + 1);\n//   for (int to : edges[v]) {\n//     if (to == pv) continue;\n//     dfs2(to, v, mx == down[to] ? (mx2 + 1) : (mx + 1));\n//   }\n// }\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i + 1 < n; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    --v;\n    --u;\n    edges[v].push_back(u);\n    edges[u].push_back(v);\n  }\n  dfs(0, -1);\n  // for (int i = 0; i < n; i++) {\n    // printf(\"down[%d] = %d\\n\", i + 1, down[i]);\n  // }\n  // ans = 1 << 30;\n  // dfs2(0, -1, -1);\n  // printf(\"%d\\n\", ans);\n  ++ans;\n  int r = 0;\n  while (ans > 0) {\n    ans = (ans - 1) / 2;\n    r++;\n  }\n  printf(\"%d\\n\", r);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n#define INT long long\n#define MOD 1000000007\nusing namespace std;\nINT n, d, unido[100010] = {1, 3, 7};\nvector<INT> g[100010];\nint solve(int x)\n{\n    int chk[100010] = {0};\n    int ret = x;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        ret = v;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return ret;\n}\nint f(int x, int y)\n{\n    int chk[100010] = {0};\n    int ret = 0;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        if( v == y ) return chk[v]-1;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n;\n    for(int i = 1 ; i < n ; i++ )\n    {\n        INT a, b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int v = solve(1);\n    int w = solve(v);\n    int d = f(v, w);\n    int z = 0;\n    for(int i = 3 ; unido[i] <= n ; i++ ) unido[i] = unido[i-1]*2+1;\n    for(int i = 0 ; unido[i] <= n ; i++ )\n    {\n        if( unido[i] > d+1 )\n        {\n            cout<<i<<endl;\n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/std++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint ans = 0;\n\nvector <int> graph[N];\nint dp[N];\nint cnt[N][25];\nbool mark[N];\n\n\nvoid dfs(int v) \n{\n    mark[v] = true;\n    for (auto u : graph[v]) \n    {\n        if (!mark[u]) \n        {\n            dfs(u);\n            dp[v] =  dp[v] | dp[u];\n            for (int i = 0; i < 20; i++) \n            {\n                if ((dp[u] >> i) % 2) \n                {\n                    cnt[v][i]++;\n                }\n            }\n        }\n    }\n    int check = -1;\n    for (int i = 0; i < 20; i++) \n    {\n        if (cnt[v][i] > 1) \n        {\n            check = i;\n        }\n    }\n    check++;\n    while (cnt[v][check]) \n    {\n        check++;\n    }\n    ans = max(ans, check);\n    for (int i = 0; i < check; i++) \n    {\n        dp[v] &= (1 << 20) - 1 - (1 << i);\n    }\n    dp[v] = dp[v] | (1 << check);\n}\n\nint main() \n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) \n    {\n        int u, v;\n        cin >> u >> v;\n        graph[u - 1].push_back(v - 1);\n        graph[v - 1].push_back(u - 1);\n    }\n    dfs(0);\n    cout << ans << endl;;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#define MAXN 100000\nusing namespace std;\ntypedef long long LL;\nvector<int> G[MAXN+5];\nint N,ans;\nint cnt[MAXN+5][21];\nvoid DFS(int u,int fa)\n{\n\tfor(int i=0;i<(int)G[u].size();i++)\n\t{\n\t\tint v=G[u][i];\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tDFS(v,u);\n\t\tfor(int j=0;j<20;j++)\n\t\t\tcnt[u][j]+=cnt[v][j];\n\t}\n\tint val=0;\n\tfor(int i=20;i>=0;i--)\n\t\tif(cnt[u][i]>=2)\n\t\t{\n\t\t\tval=i+1;\n\t\t\tbreak;\n\t\t}\n\twhile(cnt[u][val]==1)\n\t\tval++;\n\tans=max(ans,val);\n\tcnt[u][val]++;\n\tfor(int i=0;i<val;i++)\n\t\tcnt[u][i]=0;\n}\nint main()\n{\n//\tfreopen(\"uninity.in\",\"r\",stdin);\n//\tfreopen(\"uninity.out\",\"w\",stdout);\n\tscanf(\"%d\",&N);\n\tint u,v;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tDFS(1,-1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nvector<int> g[100000];\nbool del[100000];\nint sz[100000];\n\nvoid csz(int v, int p) {\n    sz[v] = 1;\n    for (int to : g[v]) if (to != p && !del[to]) {\n        csz(to, v);\n        sz[v] += sz[to];\n    }\n}\n\nint tmp = 1234;\nint zzz = 0;\n\nint cd(int v, bool root = false) {\n    csz(v, -1);\n    zzz += sz[v];\n    if (zzz > 100000) {\n        zzz = 0;\n        if (clock() > 1.9 * CLOCKS_PER_SEC) {\n            cout << tmp << endl;\n            exit(0);\n        }\n    }\n    int par = -1;\n    int szv = sz[v];\n    while (true) {\n        bool done = true;\n        for (int to : g[v]) if (to != par && !del[to] && 2 * sz[to] >= szv) {\n            par = v;\n            v = to;\n            done = false;\n            break;\n        }\n        if (done) break;\n    }\n    int res, worst, wcnt;\n    par = -1;\n    bool firstTime = true;\n    do {\n        if (firstTime) {\n            firstTime = false;\n        } else {\n            del[v] = false;\n            par = v;\n            v = worst;\n        }\n        del[v] = true;\n        res = 0;\n        worst = -1;\n        wcnt = 0;\n        if (par != -1) {\n            res = cd(par) + 1;\n            worst = par;\n            wcnt = 1;\n        }\n        for (int to : g[v]) if (!del[to] && to != par) {\n            int val = cd(to) + 1;\n            if (val > res) {\n                res = val;\n                worst = to;\n                wcnt = 1;\n            } else if (val == res) {\n                ++wcnt;\n            }\n        }\n        if (root) {\n            tmp = min(tmp, res);\n        }\n    } while (wcnt == 1 && worst != par);\n    del[v] = false;\n    return res;\n}\n\nint main() {\n//    scanf(\"%d\", &n);\n//    forn(i, n - 1) {\n//        int from, to;\n//        scanf(\"%d%d\", &from, &to), --from, --to;\n//        g[from].pb(to);\n//        g[to].pb(from);\n//    }\n\n    n = 100000;\n    mt19937 mt(123);\n    for (int i = 1; i < n; ++i) {\n        int to = i / 4 + mt() % (i - i / 4);\n        g[i].pb(to);\n        g[to].pb(i);\n    }\n\n    int res = cd(0, true);\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100009\nusing namespace std;\n\nint n,ans,tot,fst[N],pnt[N<<1],nxt[N<<1],fa[N],tg[N];\nvoid add(int x,int y){\n\tpnt[++tot]=y; nxt[tot]=fst[x]; fst[x]=tot;\n}\nvoid dfs(int x){\n\tint i,y;\n\tfor (i=fst[x]; i; i=nxt[i]){\n\t\ty=pnt[i];\n\t\tif (y!=fa[x]){\n\t\t\tfa[y]=x; dfs(y);\n\t\t\ttg[x]|=tg[y];\n\t\t}\n\t}\n\tfor (i=1; tg[x]&i; i<<=1) tg[x]^=i;\n\ttg[x]|=i;\n\tans=max(ans,tg[x]);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,x,y;\n\tfor (i=1; i<n; i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tdfs(1);\n\tfor (i=-1; ans; ans>>=1) i++;\n\tprintf(\"%d\\n\",i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1000000010\n#define INFLL ((1LL<<62)-5)\n#define FO(i,a,b) for (int (i) = (a); (i) < (b); ++(i))\n#define OF(i,a,b) for (int (i) = (a)-1; (i) >= (b); --(i))\n#define SZ(v) int(v.size())\n#define pb push_back\n\nusing namespace std;\n//PAIRS:\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n/*~~~~TEMPLATE END~~~~*/\n\nconst int MAXN = 100005;\nint N;\nvector<int> allE[MAXN];\nint par[MAXN];\n\nvector<int> dfs (int c) {\n    int cnt[20];\n    fill(cnt, cnt+20, 0);\n    for (int nxt : allE[c]) {\n        if (nxt == par[c]) continue;\n        par[nxt] = c;\n        auto chV = dfs(nxt);\n        for (int v : chV) {\n            cnt[v]++;\n        }\n    }\n    int endSpot = 0;\n    for (int c = 19; c >= 0; c--) {\n        if (c == 0 || cnt[c] > 1) {\n            while (cnt[endSpot]) endSpot++;\n            break;\n        }\n    }\n    cnt[endSpot] = 1;\n    vector<int> ret;\n    for (int c = 19; c >= endSpot; c--) {\n        if (cnt[c]) ret.push_back(c);\n    }\n    return ret;\n}\n\n\nint main() {\n    scanf (\"%d\", &N);\n    FO (i,0,N-1) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        allE[a].pb(b);\n        allE[b].pb(a);\n    }\n    auto v = dfs(1);\n    printf (\"%d\\n\", v[0]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tvector<vector<UL>> E;\n\n\tUL ans = 0;\n\tunsigned Solve2(UL p, UL pre) {\n\t\tUL first = 0, second = 0;\n\t\tfor (auto next : E[p]) {\n\t\t\tif (next == pre) continue;\n\t\t\tUL d = Solve2(next, p);\n\t\t\tsecond = max(second, min(first, d));\n\t\t\tfirst = max(first, d);\n\t\t}\n\t\tans = max(ans, first + second + 1);\n\t\treturn first + 1;\n\t}\n\n\tvoid Solve() {\n\t\tUL N; cin >> N;\n\t\tE.resize(N);\n\t\trep(i, N - 1) {\n\t\t\tUL a, b; cin >> a >> b; a--; b--;\n\t\t\tE[a].push_back(b); E[b].push_back(a);\n\t\t}\n\t\tUL ans = Solve2(0, (UL)-1);\n\t\tUL M = 0;\n\t\tUL uninity = 0;\n\t\twhile (M < ans) { M = M * 2 + 2; uninity++; }\n\t\tcout << uninity << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, A[1 << 17], B[1 << 17], dp[1 << 17], ret; vector<int>X[1 << 17], G[1 << 17];\nbool used[1 << 17];\n\nvoid dfs(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tG[pos].push_back(X[pos][i]);\n\t\tdfs(X[pos][i]);\n\t}\n}\n\nvector<int> solve(int pos) {\n\tbool used[20]; for (int i = 0; i < 20; i++) used[i] = false;\n\n\tfor (int i = 0; i < G[pos].size(); i++) {\n\t\tvector<int> E = solve(G[pos][i]);\n\t\tfor (int j = 0; j < E.size(); j++) used[E[j]] = true;\n\t}\n\n\tint c = -1;\n\tfor (int i = 0; i < 20; i++) {\n\t\tif (used[i] == false) { c = i; break; }\n\t}\n\tdp[pos] = c;\n\tvector<int>L; L.push_back(c);\n\tfor (int i = c + 1; i < 20; i++) { if (used[i] == true) L.push_back(i); }\n\treturn L;\n}\n\nint main() {\n\t//FILE *in = freopen(\"in1.txt\", \"r\", stdin);\n\tcin >> N;\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tX[A[i]].push_back(B[i]);\n\t\tX[B[i]].push_back(A[i]);\n\t}\n\tdfs(1);\n\tsolve(1);\n\n\tint maxn = 0; for (int i = 1; i <= N; i++) maxn = max(maxn, dp[i]);\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define SZ(a) (int)(a.size())\n#define ALL(a) a.begin(),a.end()\n#define SET(a,b) memset(a,b,sizeof(a))\n#define MOD 1000000007\n\n#define SI(n) scanf(\"%d\",&n)\n#define PI(n) printf(\"%d\\n\",n)\n#define SL(n) scanf(\"%lld\",&n)\n#define PL(n) printf(\"%lld\\n\",n)\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define TCS() int testcase; SI(testcase);while(testcase--)\n\n\n#define TRACE\n\n#ifdef TRACE\n#define TR(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n    cerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n    const char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define TR(...)\n#endif\n\n//FILE *fin = freopen(\"in\",\"r\",stdin);\n//FILE *fout = freopen(\"out\",\"w\",stdout);\ntypedef long long int \tLL;\ntypedef long double \tLD;\ntypedef pair<int,int>   II;\ntypedef vector< II >    VII;\ntypedef vector<int>     VI;\n\nconst int N = 100011;\nint n;\nVI gr[N];\nint dp[N][2], dia;\n\nvoid dfs(int v, int p) {\n    int mx1 = 0,mx2 = 0;\n    for(int u : gr[v]) {\n        if(u == p) continue;\n        dfs(u, v);\n        if(dp[u][0] + 1 > mx1) {\n            mx2 = mx1;\n            mx1 = dp[u][0] + 1;\n        }\n        else if(dp[u][0] + 1 > mx2)\n            mx2 = dp[u][0] + 1;\n    }\n    dp[v][0] = mx1, dp[v][1] = mx2;\n    dia = max(dia , mx1 + mx2);\n}\n\nint main() {\n    SI(n);\n    for(int i = 1;i < n; ++i) {\n        int u, v;\n        SI(u), SI(v);\n        gr[u].PB(v), gr[v].PB(u);\n    }\n    dfs(1, 0);\n    PI(dia/2);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N(222222);\nint vst[N], msk[N], label[N];\nvector<int> adj[N];\nvoid dfs(int v) {\n\tvst[v] = 1;\n\tmsk[v] = 0;\n\tfor(int y : adj[v]) {\n\t\tif(vst[y]) continue;\n\t\tdfs(y);\n\t\tmsk[v] |= msk[y] & (~((1 << label[y]) - 1));\n\t}\n\twhile(msk[v] >> label[v] & 1) {\n\t\tlabel[v]++;\n\t}\n\tmsk[v] |= 1 << label[v];\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i(0); i < n - 1; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tdfs(1);\n\tint ans(0);\n\twhile(msk[1]) {\n\t\tans++;\n\t\tmsk[1] /= 2;\n\t}\n\tcout << ans-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <set>\nusing namespace std;\n\nint finder(const vector<vector<int> >& G, int now, int prv) {\n  vector<int> bits;\n  for (auto nxt : G[now]) {\n    if (nxt == prv) continue;\n    bits.push_back(finder(G, nxt, now));\n  }\n  int res = 0;\n  for (int bit=20; bit>=0; bit--) {\n    int cnt = 0;\n    for (auto p : bits) {\n      if (p&(1<<bit)) cnt ++;\n    }\n    if (cnt == 1) res += 1<<bit;\n    else if (cnt > 1) {\n      res += 1<<(bit+1);\n      return res;\n    }\n  }\n  res ++;\n  return res;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > G(N);\n  for (int i=0; i<N-1; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  int res = finder(G, 0, -1);\n  int ret = 0;\n  while (res > 1) {\n    res /= 2;\n    ret ++;\n  }\n  printf(\"%d\\n\", ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nconst int maxn = 1e5 + 20;\n\nint sz[maxn];\n\nbool hide[maxn];\n\nvector<int> adj[maxn];\n\nvoid plant(int v , int p = -1)\n{\n\tsz[v] = 1;\n\tfor(auto u : adj[v])\n\t\tif(!hide[u] && u != p)\n\t\t{\n\t\t\tplant(u , v);\n\t\t\tsz[v] += sz[u];\n\t\t}\n}\n\nint find_centroid(int v , int n , int p = -1)\n{\n\tfor(auto u : adj[v])\n\t\tif(!hide[u] && u != p && 2 * sz[u] > n)\n\t\t\treturn find_centroid(u , n , v);\n\n\treturn v;\n}\n\nint solve(int v)\n{\n\tplant(v);\n\tv = find_centroid(v , sz[v]);\n\thide[v] = 1;\n\n\tint mx = -1;\n\tfor(auto u : adj[v])\n\t\tif(!hide[u])\n\t\t\tmx = max(mx , solve(u));\n\n\treturn mx + 1;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b;\n\t\tcin >> a >> b;\n\t\ta-- , b--;\n\t\t\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\n\tcout << solve(0) << endl;\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]&&belong[i]<0) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N(222222);\nint vst[N], msk[N], label[N];\nvector<int> adj[N];\nvoid dfs(int v) {\n\tvst[v] = 1;\n\tmsk[v] = 0;\n\tint ban(0);\n\tfor(int y : adj[v]) {\n\t\tif(vst[y]) continue;\n\t\tdfs(y);\n\t\tint k(msk[y] & (~((1 << label[y]) - 1)));\n\t\tfor(int j(0); j <= 30; j++)\n\t\t\tif(msk[v] >> j & 1)\n\t\t\t\tif(k >> j & 1) \n\t\t\t\t\tban |= 1 << j;\n\t\tmsk[v] |= k;\n\t}\n\twhile((msk[v] >> label[v] & 1) || (1 << label[v]) <= ban) {\n\t\tlabel[v]++;\n\t}\n\tmsk[v] |= 1 << label[v];\n}\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i(0); i < n - 1; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t}\n\tdfs(1);\n\tint ans(0);\n\twhile(msk[1]) {\n\t\tans++;\n\t\tmsk[1] /= 2;\n\t}\n\tcout << ans-1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = inF, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) <= mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tsrand(time(0));\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define N (100000+1000)\nusing namespace std;\n\nstruct Edge{int to,next;}edge[N<<1];\nint n,u,v,dep[N],f[N][22],ans;\nint head[N],num_edge;\n\nvoid add(int u,int v)\n{\n\tedge[++num_edge].to=v;\n\tedge[num_edge].next=head[u];\n\thead[u]=num_edge;\n}\n\nvoid Dfs(int x,int fa)\n{\n\tfor (int i=head[x]; i; i=edge[i].next)\n\t\tif (edge[i].to!=fa)\n\t\t{\n\t\t\tDfs(edge[i].to,x);\n\t\t\tfor (int j=0; j<=20; ++j)\n\t\t\t\tf[x][j]+=f[edge[i].to][j];\n\t\t}\n\tint lim=0;\n\tfor (int i=20; i>=0; --i)\n\t\tif (f[x][i]>1) {lim=i+1; break;}\n\twhile (f[x][lim]) lim++;\n\tdep[x]=lim;\n\tfor (int j=0; j<=lim-1; ++j) f[x][j]=0;\n\tf[x][lim]++; ans=max(ans,dep[x]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n-1; ++i)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\n\t}\n\tDfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 5e4 + 5;\n\nint S[N][22] , ans[N] , n , m , x , y , res , Tay[N][22];\n\nvector <int> G[N];\n\nvoid dfs(int x , int f) {\n  for(int i = 0;i < (int) G[x].size();++ i) {\n    int V = G[x][i];\n    if(V == f)  continue;\n    dfs(V , x);\n    ++ S[x][ans[V]];\n    for(int i = ans[V] + 1;i < 22;++ i) S[x][i] += S[V][i];\n  }\n  \n  for(int i = 21;i >= 0;-- i) if(S[x][i]){\n      if(S[x][i] >= 2) {\n        for(int j = i;j >= 0;-- j) Tay[x][j] = 1;\n        break;\n      }\n      else Tay[x][i] = 1;\n  }\n  for(ans[x] = 0;Tay[x][ans[x]];++ ans[x]);\n  res = max(res , ans[x]);\n}\n\nint main(void) {\n  cin.sync_with_stdio(0);\n  cin >> n;\n  for(int i = 1;i < n;++ i) {\n    cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  dfs(1 , 0);\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, D[101000];\nvector<int>E[101000];\nvoid DFS(int a, int pp){\n    int i;\n    int g=0,h=0,tp=0;\n    for(i=0;i<E[a].size();i++){\n        int x = E[a][i];\n        if(x==pp)continue;\n        DFS(x, a);\n        h |= g&D[x];\n        g |= D[x];\n    }\n    while(h){\n        tp=(h&-h);\n        h^=tp;\n    }\n    if(!tp)tp=1;\n    while(tp&g)tp<<=1;\n    D[a] = (tp|g)/tp*tp;\n}\nint main(){\n    int i, a, b;\n    scanf(\"%d\",&n);\n    for(i=1;i<n;i++){\n        scanf(\"%d%d\",&a,&b);\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n    DFS(1,0);\n    for(i=30;i>=0;i--)if((1<<i)&D[1])break;\n    printf(\"%d\\n\",i);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\nconst int N = 1e5 + 7, K = 20;\nvector <int> g[N];\nint dp[N][K];\nvoid dfs(int u, int par) {\n    for (int v : g[u]) {\n        if (v != par) {\n            dfs(v, u);\n            for (int i = 0; i < K; ++i)\n                dp[u][i] += dp[v][i];\n        }   \n    }   \n    int pos = -1;\n    for (int i = 0; i < K; ++i)\n        if (dp[u][i] > 1)\n            pos = i;\n    if (pos != -1) {\n        for (int i = 0; ; ++i) {\n            if (dp[u][i] == 0 && i > pos) {\n                dp[u][i] = 1;\n                break;\n            }   \n            dp[u][i] = 0;\n        }   \n    }   \n    else {\n        ++dp[u][0];\n        int ptr = 0;\n        while (dp[u][ptr] == 2) {\n            dp[u][ptr] = 0;\n            ++dp[u][ptr + 1];\n            ++ptr;\n        }   \n    }   \n\n    #ifdef HOME\n    cout << \"dp \" << u << \" : \";\n    for (int i = 0; i < K; ++i)\n        cout << dp[u][i] << ' ';\n    cout << endl;\n    #endif\n}   \nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        g[u].app(v); g[v].app(u);\n    }   \n    dfs(1, 1);\n    for (int i = K - 1; ; --i) {\n        if (dp[1][i]) {\n            cout << i << endl;\n            exit(0);\n        }   \n    }   \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<62;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\nvector<int> adj[100009];\n\nint dfs(int x,int p){//returns bitmask of visible positions\n\tbool hasc=0;\n\tint visible=0;\n\tint doubleup=0;\n\tfor(int i:adj[x]){\n\t\tif(i==p)continue;\n\t\thasc=1;\n\t\tint dfsv=dfs(i,x);\n\t\tdoubleup|=(visible&dfsv);\n\t\tvisible|=dfsv;\n\t}\n\tif(!hasc)return 1;\n\tint m1=0,m2=0;\n\tREP(i,20){\n\t\tif(!(visible&(1<<i))){m1=i;break;}\n\t}\n\tfor(int i=19;i>=0;i--){\n\t\tif(doubleup&(1<<i)){m2=i+1;break;}\n\t}\n\tint v=max(m1,m2);\n\tvisible|=(1<<v);\n\tREP(i,v){\n\t\tif(visible&(1<<i))\n\t\tvisible^=(1<<i);\n\t}\n\treturn visible;\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tadj[a].PB(b);adj[b].PB(a);\n\t}\n\tint vv=dfs(0,-1);\n\t//printf(\"%d \",vv);\n\tfor(int i=20;i>=0;i--){\n\t\tif(vv&(1<<i)){printf(\"%d\",i);return 0;}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, dp[100009];\nchar col[100009], lg[400009], sml[400009];\nvector < int > v[100009];\n\nvoid dfs (int nod, int tata)\n{\n    int sau = 0;\n    for (auto son : v[nod])\n        if (son != tata)\n        {\n            dfs (son, nod);\n            int curr = dp[son] & sau;\n            if (curr > 0)\n                sau |= ((1 << (lg[curr] + 1)) - 1);\n            sau |= dp[son];\n        }\n    col[nod] = sml[sau];\n    dp[nod] = ((sau >> col[nod]) << col[nod]) | (1 << col[nod]);\n}\n\n\nint main ()\n{\nscanf (\"%d\", &N);\nfor (int i=1; i<N; i++)\n{\n    int x, y;\n    scanf (\"%d %d\", &x, &y);\n    v[x].push_back (y);\n    v[y].push_back (x);\n}\nfor (int i=2; i<=4 * N; i++)\n    lg[i] = lg[i >> 1] + 1;\nfor (int i=1; i<=4 * N; i++)\n    if (i & 1) sml[i] = sml[i >> 1] + 1;\n    else sml[i] = 0;\ndfs (1, -1);\nprintf (\"%d\\n\", lg[dp[1]]);\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\nint c[MX];\n\nP cfs(int v, int d=0, int p=-1) {\n  P res(d,v);\n  for (int u : to[v]) {\n    if (c[u] || u == p) continue;\n    maxs(res, cfs(u,d+1,v));\n  }\n  return res;\n}\nvi vs;\nbool vfs(int v, int t, int p=-1) {\n  if (v == t) {\n    vs.pb(v);\n    return true;\n  }\n  for (int u : to[v]) {\n    if (c[u] || p == u) continue;\n    if (vfs(u,t,v)) {\n      vs.pb(v);\n      return true;\n    }\n  }\n  return false;\n}\nint dfs(int v) {\n  v = cfs(v).se;\n  P p = cfs(v);\n  vs = vi();\n  vfs(v,p.se);\n  v = vs[p.fi/2];\n  c[v] = 1;\n  int res = 0;\n  for (int u : to[v]) {\n    if (c[u]) continue;\n    maxs(res,dfs(u)+1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\nvi adj[100001];\nvi dp[100001];\nint best[100001];\nint par[100001];\nvoid dfs(int u, int p)\n{\n\tpar[u]=p;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tdfs(v,u);\n\t}\n\tint a = -1;\n\tmap<int,int> ma;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tfor(vit it = dp[v].begin(); it != dp[v].end(); it++)\n\t\t{\n\t\t\tma[(*it)]++;\n\t\t}\n\t}\n\tfor(mit it = ma.begin(); it != ma.end(); it++)\n\t{\n\t\tif(it->se>=2) a = it->fi;\n\t}\n\tint b = a + 1;\n\twhile(ma[b]>0)\n\t{\n\t\tb++;\n\t}\n\tdp[u].pb(b);\n\tfor(mit it = ma.begin(); it != ma.end(); it++)\n\t{\n\t\tif(it->fi>b) dp[u].pb(it->fi);\n\t}\n}\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tdfs(0,-1);\n\tvit it = dp[0].end();it--;\n\tcout<<(*it)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct edge{int s,t,n;}e[200010];\nint n,h[200010],f[200010];\n \nvoid dfs(int x,int fa)\n{\n\tint s=0,sum=0,k=1,p=0;\n\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\tif (y!=fa)  dfs(y,x),s|=sum&f[y],sum|=f[y];\n\twhile ((k<s)||(sum&k))  {k<<=1;p++;}\n\t//f[x]=(sum^(sum&(k-1)))|k;\nf[x]=(sum>>(p)<<(p))|k;\n}\n \nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t}\n\tdfs(1,0);\n\tprintf(\"%d\",int(log2(f[1])));\n}\n \nint main()\n{\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nID: bqi3431\nPROG: ~\nLANG: C++11 \n*/\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N;\nvi adj[MX];\n\nint dfs(int a, int b) {\n    int cur = 0, extra = 0;\n    trav(t,adj[a]) if (t != b) {\n        int x = dfs(t,a);\n        extra |= cur&x; cur |= x;\n    }\n    int bit = 17; while (bit > 0 && !(extra&(1<<bit))) bit --;\n    while (cur&(1<<bit)) bit ++;\n    cur |= 1<<bit; cur ^= cur&((1<<bit)-1);\n    return cur;\n}\n\nint main() {\n    setIO(); re(N);\n    F0R(i,N-1) {\n        int a,b; re(a,b);\n        adj[a].pb(b), adj[b].pb(a);\n    }\n    ps(31-__builtin_clz(dfs(1,0)));\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n  int t,next;\n  Edge() {}\n  Edge(int a,int b):t(a),next(b) {}\n}; \n\nEdge e[200005];\nint head[100005];\n\nint f[100005],g[100005],ans;\n\nvoid dfs(int x,int fa) {\n  int sum=0;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) {\n    \tint u=e[i].t;\n    \tdfs(u,x);\n    \tsum|=(g[x]&g[u]);\n    \tg[x]|=g[u];\n\t}\n  for(int i=0;i<30;i++)\n    if (!((1<<i)<sum)&&!(g[x]&(1<<i))) {\n    \tf[x]=i;\n    \tbreak;\n\t} \n  g[x]=((g[x]>>f[x]<<f[x])|(1<<f[x]));\n  ans=max(ans,f[x]);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[2*i-1]=Edge(y,head[x]);\n  \thead[x]=2*i-1;\n  \te[2*i]=Edge(x,head[y]);\n  \thead[y]=2*i;\n  }\n  dfs(1,0);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 30000;\nvector <int> bi[N];\nint dfs(int t, int f = 0)\n{\n    int c = 0, d = 0;\n    for (int i = 0; i < bi[t].size(); ++ i)\n        if (bi[t][i] != f)\n        {\n            int v = dfs(bi[t][i], t);\n            d |= c & v;\n            c ^= v;\n        }\n    for (int i = 20; ~i; -- i)\n        if (i == 0 || (d & (1 << (i - 1))))\n            for (int j = i; ; ++ j)\n                if (!(c & (1 << j)))\n                    return (c | (1 << j)) ^ (c & ((1 << j) - 1));\n}\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; ++ i)\n    {\n        int a, b;\n        cin >> a >> b;\n        bi[a].push_back(b);\n        bi[b].push_back(a);\n    }\n    int v = dfs(1);\n    for (int i = 20; ~i; -- i)\n        if (v & (1 << i))\n        {\n            cout << i << endl;\n            return 0;\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<62;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\nvector<int> adj[100009];\n\nint dfs(int x,int p){//returns bitmask of visible positions\n\tbool hasc=0;\n\tint visible=0;\n\tint doubleup=0;\n\tfor(int i:adj[x]){\n\t\tif(i==p)continue;\n\t\thasc=1;\n\t\tint dfsv=dfs(i,x);\n\t\tdoubleup|=(visible&dfsv);\n\t\tvisible|=dfsv;\n\t}\n\tif(!hasc)return 1;\n\tint m2=0;\n\tfor(int i=19;i>=0;i--){\n\t\tif(doubleup&(1<<i)){m2=i+1;break;}\n\t}\n\tint v=0;\n\tREPP(i,m2,20){\n\t\tif(!(visible&(1<<i))){v=i;break;}\n\t}\n\tvisible|=(1<<v);\n\tREP(i,v){\n\t\tif(visible&(1<<i))\n\t\tvisible^=(1<<i);\n\t}\n\treturn visible;\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tadj[a].PB(b);adj[b].PB(a);\n\t}\n\tint vv=dfs(0,-1);\n\t//printf(\"%d \",vv);\n\tfor(int i=20;i>=0;i--){\n\t\tif(vv&(1<<i)){printf(\"%d\",i);return 0;}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct node {\n\tint to, next;\n} edge[MAXN*2];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nint n, a, b;\nint siz[MAXN], vis[MAXN];\n\nvoid dfs_siz(int nd, int f)\n{\n\tsiz[nd] = 1;\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (vis[to] || to == f) continue;\n\t\tdfs_siz(to, nd), siz[nd] += siz[to];\n\t}\n}\n\nvoid dfs_find(int nd, int f, const int totsiz, int &cur, int &ans)\n{\n\tint maxsiz = totsiz-siz[nd];\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (vis[to] || to == f) continue;\n\t\tdfs_find(to, nd, totsiz, cur, ans);\n\t\tmaxsiz = max(maxsiz, siz[to]);\n\t}\n\tif (maxsiz < cur) cur = maxsiz, ans = nd;\n}\n\nint dfs(int nd)\n{\n\tdfs_siz(nd, 0);\n\tint tot = 1e9, cen;\n\tdfs_find(nd, 0, siz[nd], tot, cen), nd = cen;\n\tvis[nd] = 1;\n\tint ans = 0;\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (vis[to]) continue;\n\t\tans = max(ans, dfs(to)+1);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpush(a, b), push(b, a);\n\t}\n\tcout << dfs(1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector <int> V[101010];\nint K[101010];\nint n, ans;\n\nint dfs(int p, int r)\n{\n\tint k, f1, f2;\n\t\n\tf1 = f2 = 0;\n\t\n\tfor(int &t: V[p]){\n\t\tif(t != r){\n\t\t\tk = dfs(t, p);\n\t\t\tf2 |= (f1 & k);\n\t\t\tf1 |= k;\n\t\t}\n\t}\n\t\n\treturn (f1 | K[f2]) + 1;\n}\n\nint main()\n{\n\tint i, a, b, s, k;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor(s=0, i=1; i<=n; i++){\n\t\tif(!(i & (i-1))) s ++;\n\t\tK[i] = (1 << s) - 1;\n\t}\n\t\n\tfor(i=1; i<n; i++){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tV[a].push_back(b);\n\t\tV[b].push_back(a);\n\t}\n\t\n\tk = dfs(1, 0);\n\t\n\tfor(i=0; i<20; i++){\n\t\tif(k & (1 << i)){\n\t\t\tans = i;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n    freopen(\"input\",\"r\",stdin);\n    freopen(\"output\",\"w\",stdout);\n*/\n\nvector<vector<int> > G;\nvector<vector<int> > T;\nvector<int> V;\n\nvoid build(int a, int p) {\n    for (int i = 0;i < G[a].size();i++) {\n        if (G[a][i] == p) continue;\n        T[a].push_back(G[a][i]);\n        build(G[a][i], a);\n    }\n    return;\n}\n\nint cal(int n) {\n    if (V[n] != 0) return V[n];\n    if (T[n].size() == 0) {\n        V[n] = 1;\n        return 1;\n    }\n    int v = 0;\n    int t[31];\n    memset(t, 0, sizeof(t));\n    for (int i = 0;i < T[n].size();i++) {\n        int z = cal(T[n][i]);\n        int x = 1;\n        for (int j = 0;j < 31;j++) {\n            if (z & x) t[j]++;\n            x *= 2;\n        }\n    }\n    int m_v = -1;\n    for (int i = 0;i < 31;i++) {\n        if (t[i] > 1) m_v = i;\n    }\n    m_v++;\n    for (int i = m_v;i < 31;i++) {\n        if (t[i] == 0) {\n            for (int j = 0;j < i;j++) t[j] = 0;\n            t[i] = 1;\n            break;\n        }\n    }\n    int sol = 0;\n    for (int i = 0;i < 31;i++) {\n        if (t[i]) sol += (1 << i);\n    }\n    V[n] = sol;\n    return sol;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    G.resize(N);\n    for (int i = 1;i < N;i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    T.resize(N);\n    build(0, -1);\n    V.resize(N, 0);\n    int v = cal(0);\n    int x = 1;\n    int sol = 0;\n    for (int i = 0;i < 31;i++) {\n        if (v & x) sol = i;\n        x *= 2;\n    }\n    cout << sol << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nDate: 2017/01/22 21:00:01 Sunday\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,n) for(int i=(a);i<=(n);++i)\n#define dep(i,a,n) for(int i=(a);i>=(n);--i)\n#define eps 1e-8\n#define pi 3.1415926535897\n#define sqr(x) ((x)*(x))\n#define MAX(a,b) a=max(a,b)\n#define MIN(a,b) a=min(a,b)\n#define SZ(x) ((int)(x).size())\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define CLR(a) memset(a,0,sizeof(a))\n#define POSIN(x,y) (1<=(x)&&(x)<=n&&1<=(y)&&(y)<=m)\n#define all(x) (x).begin(),(x).end()\n#define COUT(S,x) cout<<fixed<<setprecision(x)<<S<<endl\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#ifdef LOCAL\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<lf,lf> pff;\ntypedef complex<double> CD;\nconst int inf=0x3f3f3f3f;\nconst int mo=1000000007;\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ntemplate<class T1,class T2>inline void gn(T1&r,T2&s){gn(r),gn(s);}\ntemplate<class T1,class T2,class T3>inline void gn(T1&r,T2&s,T3&t){gn(r),gn(s),gn(t);}\ntemplate<class T1,class T2,class T3,class T4>inline void gn(T1&r,T2&s,T3&t,T4&u){gn(r),gn(s),gn(t),gn(u);}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\nconst int DX[]={1,0,-1,0},DY[]={0,1,0,-1};\nll powmod(ll a,ll b) {ll res=1;a%=mo;for(;b;b>>=1){if(b&1)res=res*a%mo;a=a*a%mo;}return res;}\nll powmod(ll a,ll b,ll mo) {ll res=1;a%=mo;for(;b;b>>=1){if(b&1)res=res*a%mo;a=a*a%mo;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n//*******************************************\n\nconst int N=111111,M=111111;\nint l,m,n,t,C,x,y;\nvector<int>a[N];\nint dfs(int x,int f){\n\tint sum[33];\n\trep(i,0,30)sum[i]=0;\n\tint msk=0;\n\tfor(auto i:a[x])if(i!=f){\n\t\tint p=dfs(i,x);\n\t\tmsk|=p;\n\t\trep(i,0,30)if(p&(1<<i))sum[i]++;\n\t}\n\tint q=-1;rep(i,0,30)if(sum[i]>1)q=i;\n\trep(i,0,30)if((!(msk&(1<<i)))&&i>q)return msk|(1<<i);\n\telse msk&=~(1<<i);\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"D.in\",\"r\",stdin);//freopen(\"D.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\trep(i,2,n)scanf(\"%d%d\",&x,&y),a[x].pb(y),a[y].pb(x);\n\tint p=dfs(1,0);\n\tdep(i,30,0)if((1<<i)&p){printf(\"%d\\n\",i);return 0;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define ull unsigned ll\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 10\n#define MOD 1000000007\n\nll n,a,b;\nll data[MAXN];\n\nint main(){\n\tcin >> n >> a >> b;\n\tfor(int i = 1;i <= n;i++)\n\t\tcin >> data[i];\n\t\n\tfor(int i = 3;i <= n;i++)\n\t\tif(data[i] - data[i-2] < min(a,b)){\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nenum {\n  MAXN = 100000 + 5\n};\n\ntypedef std::vector<int> vi;\n\nint n;\nvi e[MAXN];\nint msk[MAXN];\n\nvoid dfs(int u, int pa) {\n  int d, c;\n  for (int v: e[u]) if (v != pa) dfs(v, u);\n  for (d=20; ~d; --d) {\n    c = 0;\n    for (int v: e[u]) if (v != pa && msk[v]>>d&1) ++c;\n    if (c >= 2) {\n      msk[u] += (1<<(d+1));\n      break;\n    } else if (c == 1)\n      msk[u] |= 1<<d;\n  }\n  if (d == -1) ++msk[u];\n}\n\nvoid clear() {\n  memset(msk, 0, sizeof msk);\n}\n\nvoid exec() {\n  int i, u, v, ans;\n  clear();\n  scanf(\"%d\", &n);\n  for (i=0; i<n-1; ++i) {\n    scanf(\"%d%d\", &u, &v), --u, --v;\n    e[u].push_back(v);\n    e[v].push_back(u);\n  }\n  dfs(0, -1);\n  ans = 0;\n  while ((1<<(ans+1)) <= msk[0]) ++ans;\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  if (fopen(\"D.in\", \"r\") != NULL) {\n    freopen(\"D.in\", \"r\", stdin);\n    freopen(\"D.out\", \"w\", stdout);\n  }\n  exec();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\n\nint dp[MAXn], dp2[MAXn], ans = MAXn;\nvector<int> g[MAXn];\n//dp1 halati ke v ro joz raas speciala bezarim\n//dp2 halati ke v joz raas special ha nabashe va lozomn be yekishon motasel bashem\n//dp3 maximum dp2 haye motasel be v\nvoid dfs(int v, int par) {\n\tint mx = 0;\n\tvector<int> vec;\n\tif (g[v].size() == 1 && par)\n\t\treturn;\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tdfs(g[v][i], v);\n\t\t\tdp2[v] = max(dp2[v], dp[g[v][i]]);\n\t\t\tvec.push_back(dp[g[v][i]]);\n\t\t}\n\t\n\tdp[v] = dp2[v] + 1;\n\tif ((g[v].size() == 1 && !par) || (par && g[v].size() == 2)) {\n\t\tfor (int i = 0; i < g[v].size(); i++)\n\t\t\tif (g[v][i] != par) {\n\t\t\t\tdp[v] = min(dp[v], dp2[g[v][i]] + 1);\n\t\t\t}\n\t}\n\n}\n\nvoid dfs2(int v, int par, int ans1) {\n\tmultiset<int> st;\n\tst.insert(ans1);\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par)\n\t\t\tst.insert(dp[g[v][i]]);\n\t//cout << v << ' ' << ans1 << endl;\n\tans = min(ans, (*st.rbegin()) + 1);\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tst.erase(st.find(dp[g[v][i]]));\n\t\t\tif (st.size() > 1)\n\t\t\tdfs2(g[v][i], v, (*st.rbegin()) + 1);\n\t\t\telse if (st.size() == 1)\n\t\t\tdfs2(g[v][i], v, (*st.rbegin()));\n\t\t\tst.insert(dp[g[v][i]]);\n\t\t}\n\t\n\t\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tsrand(time(0));\n//\treturn cout << rand() % 10,0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tdfs2(1,0, 0);\n\tif (rand() % 2) {\n\t\tans--;\n\t\tdp[1]--;\n\t}\n\tcout << min(ans, dp[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PII;\nconst int N = 100010;\nstruct Edge{\n\tint a,b;\n\tvoid Input(){\n\t\tscanf(\"%d%d\",&a,&b);\n\t}\n}e[N];\nint n,ans,f[N],size;\nPII q[N];\nbool pd[N];\nvector<int> v[N];\n\nvoid dfs(int x,int fa){\n\tf[x] = 1;\n\tint t;\n\tfor(int i=0;i<v[x].size();i++) if((t=e[v[x][i]].a^e[v[x][i]].b^x)!=fa && pd[t]){\n\t\tdfs(t,x);\n\t\tf[x] += f[t];\n\t}\n}\nint dfs2(int x,int fa){\n\tint t,ret = 0,tmp,cnt = 0;\n\tbool Pd = true;\n\tfor(int i=0;i<v[x].size();i++) if((t=e[v[x][i]].a^e[v[x][i]].b^x)!=fa && pd[t]){\n\t\ttmp = dfs2(t,x);\n\t\tif(tmp) ret = tmp;\n\t\tcnt += f[t];\n\t\tif(f[t]<<1>size) Pd = false;\n\t}\n\tif(Pd && (size-cnt-1)<<1<=size) ret = x;\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++) {\n\t\te[i].Input();\n\t\tv[e[i].a].push_back(i);\n\t\tv[e[i].b].push_back(i);\n\t}\n\tint head = 0,tail = 0;\n\tans = 0;\n\tq[0] = PII(1,0);\n\tmemset(pd,true,sizeof(pd));\n\twhile(head<=tail){\n\t\tint t =q[head].first;\n\t\tint tmp = q[head++].second;\n\t\t//cout<<t<<' '<<tmp<<endl;\n\t\tdfs(t,0);\n\t\tsize = f[t];\n\t\tt =dfs2(t,0);\n\t\tpd[t] = false;\n\t\t//cout<<t<<' '<<tmp<<endl;\n\t\tint x;\n\t\tfor(int i = 0;i<v[t].size();i++) if((x=e[v[t][i]].a^e[v[t][i]].b^t) && pd[x]){\n\t\t\tq[++tail] = PII(x,tmp+1); \n\t\t}\n\t\tans = max(ans,tmp);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Parent[500000], Dist[500000];\nset<int> G[500000];\n\nint DFS(int node, int par, int dist) {\n\tParent[node] = par;\n\tDist[node] = dist;\n\n\tint ret = node;\n\tfor(auto vec : G[node])\n\t\tif(vec != par) \n\t\t\tret = max(ret, DFS(vec, node, dist + 1), [&](int a, int b) {\n\t\t\t\treturn Dist[a] < Dist[b]; \n\t\t\t});\n\t\t\n\treturn ret;\n}\n\nint GetCenter(int node) {\n\tint last = DFS(node, 0, 0);\n\tlast = DFS(last, 0, 0);\n\n\tint d = Dist[last];\n\tfor(int i = 0; i < d / 2; ++i)\n\t\tlast = Parent[last];\n\treturn last;\n}\n\nint Decomp(int node) {\n\tint cen = GetCenter(node);\n\tfor(auto vec : G[cen]) {\n\t\tG[vec].erase(cen);\n\t}\n\n\tint ans = 0;\n\tfor(auto vec : G[cen])\n\t\tans = max(ans, Decomp(vec) + 1);\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 1; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tG[a].insert(b);\n\t\tG[b].insert(a);\n\t}\n\n\tcout << Decomp(1) << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint p = 1, l;\nint dis[MAX_N];\nint Arr[MAX_N];\nint L, R;\nvector <int> g[MAX_N];\n\nvoid bfs (int v) {\n\tmemset(dis, 127, sizeof dis);\n\tdis[v] = 0;\n\tL = R = 0;\n\tArr[R++] = v;\n\t\n\twhile (L < R) {\n\t\tint u = Arr[L++];\n\t\tfor (int i = 0; i < g[u].size(); i++)\n\t\t\tif (1 + dis[u] < dis[g[u][i]]) {\n\t\t\t\tdis[g[u][i]] = 1 + dis[u];\n\t\t\t\tArr[R++] = g[u][i];\n\t\t\t}\n\t}\n}\n\nint main() {\n\tsrand(clock());\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\t\n\twhile (true) {\n\t\tans++;\n\t\tmemset(Mark, 0, sizeof Mark);\n\t\tmemset(down, 0, sizeof down);\n\t\tmemset(up, 0, sizeof up);\n\t\tbool change = false;\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\tchange = true;\n\t\t\t\t\n\t\t\t\tdfs1(i, i);\n\t\t\t\tdfs2(i, i, 0);\n\t\t\t\tfindS(i, i);\n\t\t\t\tdel[S] = true;\n\t\t\t\t//cout << \"&   \" << S << \"\\n\";\n\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!d[i]) {\n\t\t\t\t//cout << \"^ \" << i << \"\\n\";\n\t\t\t\tdel[i] = true;\n\t\t\t}\n\t\t\t\t\n\t\tif (!change)\n\t\t\tbreak;\n\t}\n\t\n\tbfs(0);\n\tint k = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dis[k] < dis[i])\n\t\t\tk = i;\n\t\t\t\n\tbfs(k);\n\tfor (int i = 0; i < n; i++)\n\t\tif (ans < dis[i])\n\t\t\tans = dis[i];\n\t\t\t\n\tans++;\n\t\n\twhile (p <= ans) {\n\t\tl++;\n\t\tp <<= 1;\n\t}\n\t\n\tcout << max(ans, l) - 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct edges\n{\n\tint to,next;\n}edge[202020];\nint first[101010],now;\nvoid adde(int x,int y)\n{\n\tnow++;\n\tedge[now].to=y;\n\tedge[now].next=first[x];\n\tfirst[x]=now;\n}\nint s[101010],al=(1<<20)-1;\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nvoid work(int p,int fa)\n{\n\tint mk=1;\n\ts[p]=0;\n\tfor(int e=first[p];e;e=edge[e].next)\n\t\tif(edge[e].to!=fa)\n\t\t{\n\t\t\twork(edge[e].to,p);\n\t\t\tmk=max(mk,lowbit(s[p]&s[edge[e].to]));\n\t\t\ts[p]|=s[edge[e].to];\n\t\t}\n\twhile(mk&s[p])\n\t\tmk<<=1;\n\ts[p]&=(al^(mk-1));\n\ts[p]^=mk;\n}\nint main()\n{\n\tint n,x,y,ans;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadde(x,y);\n\t\tadde(y,x);\n\t}\n\twork(1,0);\n\tans=-1;\n\twhile(s[1])\n\t{\n\t\tans++;\n\t\ts[1]>>=1;\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 2e5 + 7;\nconst int LOG = 25;\n\nint n;\nvector<int> adj[N];\nint ans;\n\nint dfs(int u, int from) {\n\tint all = 0, least = 0;\n\tfor (int v : adj[u]) {\n\t\tif (v == from) continue;\n\t\tint mask = dfs(v, u);\n\t\tfor (int j = 0; j < LOG; j++) {\n\t\t\tif ((all >> j & 1) && (mask >> j & 1)) {\n\t\t\t\tleast = max(least, j + 1);\n\t\t\t}\n\t\t}\n\t\tall |= mask;\n\t}\n\tassert(least + 1 < LOG);\n\tfor (int i = least; ; i++) {\n\t\tif (~all >> i & 1) {\n\t\t\tans = max(ans, i);\n\t\t\tall ^= (1 << i);\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (all >> j & 1) {\n\t\t\t\t\tall ^= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn all;\n\t\t}\n\t}\n}\n\nint solve() {\n\tans = 0;\n\tdfs(rand() % n + 1, 0);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\t//n = 1e5;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tint ret = n;\n\tfor (int r = 1; r <= 1; r++) {\n\t\tret = min(ret, solve());\n\t}\n\tprintf(\"%d\\n\", ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int N = 1e5 + 5;\nVI slo[N];\nint dep[N], diam[N], vis[N];\nvoid Dfs(int v) {\n  vis[v] = 1;\n  for (auto nei : slo[v]) {\n    if (vis[nei]) { continue; }\n    Dfs(nei);\n    maxi(diam[v], diam[nei]);\n    maxi(diam[v], dep[v] + dep[nei] + 1);\n    maxi(dep[v], dep[nei] + 1);\n  }\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  RE (i, n - 1) {\n    int a, b;\n    cin>>a>>b;\n    slo[a].PB(b);\n    slo[b].PB(a);\n  }\n  Dfs(1);\n  debug(diam[1]);\n  int k = 0;\n  while ((1 << (k + 1)) - 2 < diam[1]) {\n    k++;\n  }\n  cout<<k<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint p = 1, l;\nint dis[MAX_N];\nint Arr[MAX_N];\nint L, R;\nvector <int> g[MAX_N];\n\nvoid bfs (int v) {\n\tmemset(dis, 127, sizeof dis);\n\tdis[v] = 0;\n\tL = R = 0;\n\tArr[R++] = v;\n\t\n\twhile (L < R) {\n\t\tint u = Arr[L++];\n\t\tfor (int i = 0; i < g[u].size(); i++)\n\t\t\tif (1 + dis[u] < dis[g[u][i]]) {\n\t\t\t\tdis[g[u][i]] = 1 + dis[u];\n\t\t\t\tArr[R++] = g[u][i];\n\t\t\t}\n\t}\n}\n\nint main() {\n\tsrand(clock());\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\t\n\twhile (true) {\n\t\tans++;\n\t\tmemset(Mark, 0, sizeof Mark);\n\t\tmemset(down, 0, sizeof down);\n\t\tmemset(up, 0, sizeof up);\n\t\tbool change = false;\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\tchange = true;\n\t\t\t\t\n\t\t\t\tdfs1(i, i);\n\t\t\t\tdfs2(i, i, 0);\n\t\t\t\tfindS(i, i);\n\t\t\t\tdel[S] = true;\n\t\t\t\t//cout << \"&   \" << S << \"\\n\";\n\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!d[i]) {\n\t\t\t\t//cout << \"^ \" << i << \"\\n\";\n\t\t\t\tdel[i] = true;\n\t\t\t}\n\t\t\t\t\n\t\tif (!change)\n\t\t\tbreak;\n\t}\n\tint U = ans;\n\tans = 0;\n\t\n\tbfs(0);\n\tint k = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dis[k] < dis[i])\n\t\t\tk = i;\n\t\t\t\n\tbfs(k);\n\tfor (int i = 0; i < n; i++)\n\t\tif (ans < dis[i])\n\t\t\tans = dis[i];\n\t\t\t\n\tans++;\n\t\n\twhile (p <= ans) {\n\t\tl++;\n\t\tp <<= 1;\n\t}\n\t\n\tcout << max(U, l) - 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i <= (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n\n// 木構造を作る。\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tint a[N-1],b[N-1];\n\tint G[N+1][N],W[N+1],D[N+1];//Wは幅,Dは深さ なんと，G[N+1][1]では上手くいかない！！！\n\tbool F[N+1];//Fは探索完了フラグ\n\tFOR(i,1,N){//初期化\n\t\tW[i] = 0;\n\t\tF[i] = false;\n\t}\n\tREP(i,N-1){\n\t\tcin >> a[i] >> b[i];\n\t\tG[a[i]][W[a[i]]] = b[i];\n\t\tG[b[i]][W[b[i]]] = a[i];\n\t\tW[a[i]] += 1;\n\t\tW[b[i]] += 1;\n\t}\n\tqueue <int> Q;\n\tQ.push(1); //とりあえず1を始点にする。\n\tint depth_max = 0;\n\tint depth_max_id = 1;\n\tD[1] = 0;\n\tF[1] = true;\n\twhile(1){\n\t\t//Q.front()が今の位置。\n\t\tREP(i,W[Q.front()]){\n\t\t\t//G[Q.front()][i]が今の位置\n\t\t\tif(F[G[Q.front()][i]]==false){ //双方向。すでに探索した場所は探索しない。\n\t\t\t\tF[G[Q.front()][i]] = true;//探索完了\n\t\t\t\tQ.push(G[Q.front()][i]);\n\t\t\t\tD[G[Q.front()][i]] = D[Q.front()] + 1;\n\t\t\t\tif(depth_max<D[G[Q.front()][i]]){\n\t\t\t\t\tdepth_max = D[G[Q.front()][i]];\n\t\t\t\t\tdepth_max_id = G[Q.front()][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop(); //これを忘れるな\n\t\tif(Q.empty()){\n\t\t\tbreak;\n\t\t}\n\t}\n\tQ.push(depth_max_id);\n\tdepth_max = 0;\n\tD[depth_max_id] = 0;\n\tFOR(i,1,N)F[i] = false;//初期化\n\tF[depth_max_id] = true;\n\twhile(1){\n\t\t//Q.front()が今の位置。\n\t\tREP(i,W[Q.front()]){\n\t\t\t//G[Q.front()][i]が今の位置\n\t\t\tif(F[G[Q.front()][i]]==false){ //双方向。すでに探索した場所は探索しない。\n\t\t\t\tF[G[Q.front()][i]] = true;//探索完了\n\t\t\t\tQ.push(G[Q.front()][i]);\n\t\t\t\tD[G[Q.front()][i]] = D[Q.front()] + 1;\n\t\t\t\tif(depth_max<D[G[Q.front()][i]]){\n\t\t\t\t\tdepth_max = D[G[Q.front()][i]];\n\t\t\t\t\tdepth_max_id = G[Q.front()][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.pop(); //これを忘れるな\n\t\tif(Q.empty()){\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << depth_max/2 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//¹Ø¼üÐÔÖÊ£ºÁ½¸öÉî¶ÈÏàÍ¬µÄµãµÄÂ·¾¶ÉÏ±ØÓÐÒ»¸öÉî¶È¸üÐ¡µÄµã \n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN=1e5+5;\n\nint N,Ans;\nint Cnt[MaxN][20];\n\nvector<int> To[MaxN];\n\nvoid DFS(int u,int fa){\n\tint i,k;\n\tfor(auto v:To[u])\n\t\tif(v^fa){\n\t\t\tDFS(v,u);\n\t\t\tfor(i=0;i<20;i++)\n\t\t\t\tCnt[u][i]+=Cnt[v][i];\n\t\t}\n\tfor(i=20;~i;i--)\n\t\tif(Cnt[u][i]>1){\n\t\t\tk=i+1;\n\t\t\tbreak;\n\t\t}\n\tfor(;Cnt[u][k];k++);\n\tAns=max(Ans,k);\n\tfor(i=0;i<k;i++)\n\t\tCnt[u][i]=0;\n\tCnt[u][k]++;\n}\n\nint main(){\n\tint i,u,v;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tTo[u].push_back(v);\n\t\tTo[v].push_back(u);\n\t}\n\tDFS(1,0);\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\nvi g[MAXN];\n\nint prv[MAXN];\n\nvector<pii> vv;\n\npii dp[MAXN];\n\nvoid dfs(int s){\n\tREP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]){\n\t\t\tprv[to] = s;\n\t\t\tdfs(to);\n\t\t}\n\t}\n\tvv.clear();\n\tREP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]){\n\t\t\tvv.pb(dp[to]);\n\t\t}\n\t}\n\tif (SZ(vv) == 0){\n\t\tdp[s] = mp(0, -1);\n\t\t\n\t\t//printf(\"%d %d %d\\n\", s, dp[s]._1, dp[s]._2);\n\t\t\n\t\treturn;\n\t}\n\tSORT(vv);\n\treverse(BE(vv));\n\tint mx = vv[0]._1;\n\tdp[s] = mp(mx + 1, mx);\n\tREP(i, 0, SZ(vv)){\n\t\tint cur_lim = vv[i]._2;\n\t\tint nxt_sz = 0;\n\t\t//int nxt_lim = -1;\n\t\tif (i < SZ(vv) - 1){\n\t\t\tnxt_sz = vv[i + 1]._1;\n\t\t\t//nxt_lim = vv[i + 1]._2;\n\t\t}\n\t\tif (nxt_sz > cur_lim){\n\t\t\tbreak;\n\t\t} else if (i == SZ(vv) - 1 || nxt_sz < cur_lim){\n\t\t\tdp[s] = mp(mx, cur_lim - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//printf(\"%d %d %d\\n\", s, dp[s]._1, dp[s]._2);\n}\n\nvoid solve(){\n\tint n, a, b;\n\tscanf(\"%d\", &n);\n\tREP(i, 1, n){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t/*REPN(i, 1, n){\n\t\tdp[i] = mp(0, -1);\n\t}*/\n\tint ans = INF;\n\tREP(k, 0, 10){\n\t\tREPN(i, 1, n){\n\t\t\tprv[i] = 0;\n\t\t}\n\t\tint ind = rand() % n + 1;\n\t\tdfs(ind);\n\t\tans = min(dp[ind]._1, ans);\n\t}\n\tprintf(\"%d\\n\", ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n \n          A FAN OF FIZZYDAVID\n \n*/\n \n#include<bits/stdc++.h>\n \n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n#define FILL(a,b) memset((a),(b),sizeof((a)))\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<LL> vl;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\n \nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n \ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n \ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n \ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n \ntemplate <typename T1,typename T2,typename T3,typename T4>\nvoid scf(T1 &x,T2 &y,T3 &z,T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n \n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n \n//---------------------------head----------------------------\n \nconst int N = 1e5 + 100;\nconst int mod = 1e9 + 7;\n \nint n;\nLL x,y;\nLL a[N];\n \nvoid add(int &x,int y)\n{\n    x += y;\n    if(x >= mod) x -= mod;\n    return;\n}\n \nstruct BIT\n{\n    vi not_zero;\n    int num[N];\n    void init()\n    {\n        for(int i:not_zero) num[i] = 0;\n        not_zero.clear();\n        return;\n    }\n    int lowbit(int i){ return i & (-i); }\n    void modify(int i,int x)\n    {\n        i++;\n        for(; i <= n + 1; i += lowbit(i))\n        {\n            add(num[i],x);\n            not_zero.pb(i);\n        }\n        return;\n    }\n    int query(int i)\n    {\n        i++;\n        int ret = 0;\n        for(; i; i ^= lowbit(i)) add(ret,num[i]);\n        return ret;\n    }\n}X,Y;\n \nint Find(int lb,int rb,LL x)\n{\n    while(lb <= rb)\n    {\n        int mid = lb + rb >> 1;\n        if(a[mid] > x) rb = mid - 1;\n        else lb = mid + 1;\n    }\n    return rb;\n}\n \norz yjz()\n{\n    scf(n,x,y);\n    forn(i,1,n) scf(a[i]);\n    X.modify(0,1); Y.modify(0,1);\n    forn(i,2,n)\n    {\n        int xj = Find(1,i - 1,a[i] - y);\n        int yj = Find(1,i - 1,a[i] - x);\n        int sx = X.query(xj), sy = Y.query(yj);\n        if(a[i] - a[i - 1] < x) X.init();\n        if(a[i] - a[i - 1] < y) Y.init();\n        X.modify(i - 1,sy);\n        Y.modify(i - 1,sx);\n    }\n    int ans = X.query(n);\n    add(ans,Y.query(n));\n    printf(\"%d\\n\",ans);\n\tfizzydavid ak la\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,x,y,f[100005][30],ans;\nvector <int> a[100005];\nvoid dfs(int x,int fa){\n\tint z=-1,y;\n\tfor (int i=0;i<a[x].size();++i)\n\tif (a[x][i]!=fa){\n\t\tdfs(y=a[x][i],x);\n\t\tfor (int j=0;j<30;++j){\n\t\t\tif (f[y][j]&f[x][j]) z=max(z,j);\n\t\t\tf[x][j]|=f[y][j];\n\t\t}\n\t}\n\tfor (++z;z<30;++z)\n\tif (!f[x][z]) break;\n\tf[x][z]=1; ans=max(ans,z);\n\tfor (--z;~z;--z) f[x][z]=0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n关于点分治的层数，有一个经典的转化方法：将点分治的层数看成点的编号，那么任意两个编号相等的不同点之间一定有一个编号小于它们的点\n这里为了方便，可以把点的编号看作max层数 - 点的层数，叶子的编号是0，根的编号是max层数\n那么任意两个编号相等的不同点之间一定有一个编号大于它们的点\n直接点分治一定是一个合法的方案，故答案是O(log N)级别的\n考虑直接从叶子到根贪心决策每个点的编号，在树上dfs，对于每个x，记录子树中是否有编号为x的点，满足其到子树的根的路径上没有编号大于x的点\n对于当前点的编号，只要找到满足以其为lca的路径均合法的最小编号即可\n（当前点的所有儿子的子树中所有的路径均合法，以其为lca的路径也合法，就可以保证当前点的子树中的所有路径均合法）\n*/\n\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nvoid Get_Val(int &Ret)\n{\n\tRet = 0;\n\tchar ch;\n\twhile (ch = getchar(), ch > '9' || ch < '0')\n\t\t;\n\tdo\n\t{\n\t\t(Ret *= 10) += ch - '0';\n\t}\n\twhile (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nconst int Max_N(100050);\n\nint N, Head[Max_N], Total, To[Max_N << 1], Next[Max_N << 1], Val[Max_N];\n\ninline void Add_Edge(const int &s, const int &t)\n{\n\t++Total, To[Total] = t, Next[Total] = Head[s], Head[s] = Total;\n}\n\nvoid init()\n{\n\tGet_Val(N);\n\tfor (int i = 1, u, v;i != N;++i)\n\t\tGet_Val(u), Get_Val(v), Add_Edge(u, v), Add_Edge(v, u);\n}\n\nint Ans;\n\nvoid dfs(const int &u, const int &fa)\n{\n\tint All(0), Lca(0);\n\tfor (int i = Head[u], v;i;i = Next[i])\n\t\tif ((v = To[i]) != fa)\n\t\t{\n\t\t\tdfs(v, u);\n\t\t\tLca |= (All & Val[v]);\n\t\t\tAll |= Val[v];\n\t\t}\n\tfor (int x = 0;;++x)\n\t{\n\t\tif (x - 1 >= 0)\n\t\t\tif (Lca & (1 << (x - 1)))\n\t\t\t\tLca ^= (1 << (x - 1));\n\t\tif (Lca == 0 && (All & (1 << x)) == 0)\n\t\t{\n\t\t\tVal[u] = (All | (1 << x));\n\t\t\tfor (int j = 0;j <= x - 1;++j)\n\t\t\t\tif (Val[u] & (1 << j))\n\t\t\t\t\tVal[u] ^= (1 << j);\n\t\t\tAns = max(Ans, x);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinit();\n\tdfs(1, -1);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MaxN = 100010;\nconst int MaxLabel = 20;\n\nint n, ans, f[MaxN]; vector<int> edge[MaxN];\n\nvoid dfs(int x, int fa) {\n  int all = 0;\n  for (int y : edge[x]) {\n    if (y == fa)\n      continue;\n    dfs(y, x);\n    all |= (f[x] & f[y]);\n    f[x] |= f[y];\n  }\n  \n  int t = 0;\n  while ((1 << t) <= all || f[x] >> t & 1)\n    ++t;\n  ans = max(ans, t);\n  f[x] >>= t;\n  f[x] <<= t;\n  f[x] |= (1 << t);\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1, u, v; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n  \n  dfs(1, 0);\n  cout << ans << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nint N;\nvector<int> g[100010];\nint a[100010];\nint res=0;\n\nvoid dfs(int v,int pre){\n  int cnt[20];\n  memset(cnt,0,sizeof(cnt));\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    dfs(nv,v);\n    rep(i,20){\n      if((a[nv]>>i)&1)cnt[i]++;\n    }\n  }\n  int lst=-1;\n  for(int i=19;i>=0;i--){\n    if(cnt[i]>=2){\n      lst=i; break;\n    }\n  }\n  repl(i,lst+1,20){\n    if(cnt[i]==0){\n      int mask=(1<<i);\n      maxch(res,i);\n      repl(j,i+1,20){\n        if(cnt[j]>0)mask|=1<<j;\n      }\n      a[v]=mask; return ;\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N;\n  rep(i,N-1){\n    int b,c;\n    cin>>b>>c;\n    b--;c--;\n    g[b].push_back(c); g[c].push_back(b); \n  }\n\n  dfs(0,-1);\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nvector<vector<int> > g;\nvector<int> c;\nvector<int> res;\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > pq;\nint main(){\n    int n;\n    cin >> n;\n    g.resize(n);\n    c.resize(n);\n    res.resize(n);\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n        c[a]++;\n        c[b]++;\n    }\n    rep(i,n){\n        if(c[i]==1){\n            pq.push(MP(1,i));\n        }\n    }\n    while(!pq.empty()){\n        auto x = pq.top();\n        pq.pop();\n        int id = x.second;\n        vector<int> cnt(21);\n        for(auto y:g[id]){\n            res[id] |= res[y];\n            rep(i,20){\n                if((res[y]>>i)&1){\n                    cnt[i]++;\n                }\n            }\n        }\n        if(res[id]==0){\n            res[id] = 1;\n        }else{\n            int k = -1;\n            for(int i=20;i>=0;i--){\n                if(cnt[i]>=2){\n                    k = i;\n                    break;\n                }\n            }\n            int bits = (1<<(k+1))-1;\n            res[id] &= ~bits;\n            res[id] += bits+1;\n        }\n        for(auto y:g[id]){\n            c[y]--;\n            if(c[y]==1){\n                pq.push(MP(res[id],y));\n            }\n        }\n    }\n    int mx = 0;\n    rep(i,n){\n        chmax(mx,res[i]);\n        // cerr << i+1 << \" \" << res[i] << endl;\n    }\n    cout << 31 - __builtin_clz(mx) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 101010 \n\ttypedef long long ll;\n\ttypedef double db;\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n\tvoid file()\n\t{\n\t\t#ifdef NTFOrz\n\t\tfreopen(\"a.in\",\"r\",stdin);\n\t\t#endif\n\t}\n\tinline void chktime()\n\t{\n\t\t#ifdef NTFOrz\n\t\tcout<<(clock()-t)/1000.0<<'\\n';\n\t\t#endif\n\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nint n;\nstruct hh{int t,nxt;}edge[sz<<1];\nint head[sz],ecnt;\nvoid make_edge(int f,int t)\n{\n\tedge[++ecnt]=(hh){t,head[f]};\n\thead[f]=ecnt;\n\tedge[++ecnt]=(hh){f,head[t]};\n\thead[t]=ecnt;\n}\n\nint vis[sz][25];\nint ans;\nvoid dfs(int x,int fa)\n{\n\t#define v edge[i].t\n\tgo(x) if (v!=fa)\n\t{\n\t\tdfs(v,x);\n\t\trep(j,0,20) vis[x][j]+=vis[v][j];\n\t}\n\t#undef v\n\tint k=0;\n\trep(i,0,20) if (vis[x][i]>=2) k=i+1;\n\twhile (vis[x][k]) ++k;\n\t++vis[x][k];\n\trep(i,0,k-1) vis[x][i]=0;\n\tchkmax(ans,k);\n}\n\nint main()\n{\n\tfile();\n\tread(n);\n\tint x,y;\n\trep(i,1,n-1) read(x,y),make_edge(x,y);\n\tdfs(1,0);\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = inF, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << max(0, solve(0) + 1);// (rand() & 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define  NDEBUG\n\n//#pragma optimize(\"tree-vectorize\")\n//#pragma optimize (\"fast-math\")\n//#pragma optimize (\"O3\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\n\n#define all(v)                  v.begin(), v.end()\n#define db(x)                   cout << #x << \" = \" << (x) << \"\\n\"\n#define fend(x)                 ((x) & ((x)+1)) - 1\n#define fenu(x)                 (x) | ((x)+1)\n#define forn(i, n)              for (int i = 0; i < (int)n; ++i)\n#define forr(i, b, e)           for (int i = b; i < (int)e; ++i)\n#define ft                      first\n#define len(s)                  s.length()\n#define mp                      std::make_pair\n#define pob                     pop_back\n#define pof                     pop_front\n#define pub                     push_back\n#define puf                     push_front\n#define sc                      second\n\ntypedef double dbl;\ntypedef long double ldbl;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst long long MILLER_RABIN = 3215031751;\nconst long double PI = acos(-1);\n\n#if __cplusplus >= 201103L\n\nstruct config_io {\n    config_io() {\n        cin.tie(nullptr);\n        cout.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n    }\n} cnf_io;\n\nstruct config_rand {\n    config_rand() {\n        srand(chrono::duration_cast<chrono::nanoseconds>(\n                chrono::high_resolution_clock::now().time_since_epoch()).count());\n    }\n} cnf_rand;\n\nnamespace std {\n    template<>\n    struct hash<pair<int, int> > {\n        size_t operator()(const pair<int, int> &x) const {\n            return (x.first * 71ll + x.second) % ((int) 1e9 + 7);\n        }\n    };\n\n    template<>\n    struct hash<vector<int>> {\n        size_t operator()(const vector<int> &v) const {\n            size_t hsh = 0;\n            for (int i = 0; i < v.size(); ++i) {\n                hsh = (hsh * 71ll + v[i]) % (int) (1e9 + 7);\n            }\n            return hsh;\n        }\n    };\n}\n\ntemplate<class T>\nusing ordered_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n//ordered_set<int>  s;\n//s.insert(3);\n//cout << s.order_of_key(2) << endl; // the number of elements in the s less than 2\n//cout << *s.find_by_order(0) << endl; // print the 0-th smallest number in s(0-based)\n\n// __builtin_popcount(x) - Returns the number of 1-bits in x.\n// __builtin_parity(x) - Returns the parity of x, i.e. the number of 1-bits in x modulo 2.\n// __builtin_ffs(x) - Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero.\n// __builtin_clz(x) - Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.\n// __builtin_ctz(x) - Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.\n\n//inline string tobin(long long x) { bitset<63>(x).to_string(); }\n\ntemplate<class T>\nvoid trace(T collection) {\n    for (auto elem : collection) { cout << elem << \" \"; }\n    cout << endl;\n}\n\n#endif\n\nconst int ML = 1e5 + 10;\nvector<int> g[ML];\nint f[ML];\n\nvoid dfs(int v, int par = -1) {\n    f[v] = 0;\n    forn(i, g[v].size()) {\n        int to = g[v][i];\n        if (to == par) continue;\n        dfs(to, v);\n        f[v] |= f[to];\n    }\n    int free_bit = 0;\n    while (f[v] & (1 << free_bit)) ++free_bit;\n    f[v] |= (1 << free_bit);\n    forn(i, free_bit) f[v] -= (1 << i);\n}\n\nvoid solve(int test) {\n    int n;\n    cin >> n;\n    forn(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0);\n    //cout << bitset<32>(f[0]) << endl;\n    cout << 31 - __builtin_clz(f[0]) << endl;\n}\n\nint main() {\n#ifdef HOME\n    freopen(\"home.in\", \"r\", stdin);\n    freopen(\"home.out\", \"w\", stdout);\n#endif\n\n    int tests = 1;\n    //cin >> tests;\n    for (int test = 1; test <= tests; ++test) {\n        solve(test);\n    }\n\n#ifdef HOME\n    cout << \"\\n\\nTime: \" << clock() / (double) CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PII;\nconst int N = 100010;\nstruct Edge{\n\tint a,b;\n\tvoid Input(){\n\t\tscanf(\"%d%d\",&a,&b);\n\t}\n}e[N];\nint n,ans,f[N],Next[N];\nPII q[N];\nbool pd[N];\nvector<int> v[N];\n\nvoid dfs(int x,int fa){\n\tf[x] = 0;\n\tNext[x] = 0;\n\tint t;\n\tfor(int i=0;i<v[x].size();i++) if((t=e[v[x][i]].a^e[v[x][i]].b^x)!=fa && pd[t]){\n\t\tdfs(t,x);\n\t\tif(f[t]>f[x]) {\n\t\t\tf[x] = f[t];\n\t\t\tNext[x] = t;\n\t\t}\n\t}\n\tf[x]++;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++) {\n\t\te[i].Input();\n\t\tv[e[i].a].push_back(i);\n\t\tv[e[i].b].push_back(i);\n\t}\n\tint head = 0,tail = 0;\n\tans = 0;\n\tq[0] = PII(1,0);\n\tmemset(pd,true,sizeof(pd));\n\twhile(head<=tail){\n\t\tint t =q[head].first;\n\t\tint tmp = q[head++].second;\n\t\t//cout<<t<<' '<<tmp<<endl;\n\t\tdfs(t,0);\n\t\twhile(Next[t]!=0) t =Next[t];\n\t\tdfs(t,0);\n\t\tint cnt = (f[t]+1)/2-1;\n\t\twhile(cnt) {\n\t\t\tcnt--;\n\t\t\tt=Next[t];\n\t\t}\n\t\tpd[t] = false;\n\t\t//cout<<t<<' '<<tmp<<endl;\n\t\tint x;\n\t\tfor(int i = 0;i<v[t].size();i++) if((x=e[v[t][i]].a^e[v[t][i]].b^t) && pd[x]){\n\t\t\tq[++tail] = PII(x,tmp+1); \n\t\t}\n\t\tans = max(ans,tmp);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10, lg = 19;\nint mask[N], cnt[N][lg + 2], ans, n;\nvector<int> gr[N];\nvoid dfs(int v, int par = -1) {\n\tint rn = 0;\n\tfor (auto u : gr[v]) {\n\t\tif (u != par) {\n\t\t\tdfs(u, v), mask[v] |= mask[u];\n\t\t\tfor (int i = 0; i < lg; i++) {\n\t\t\t\tif ((mask[u] >> i) & 1)\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\tif (cnt[v][i] > 1)\n\t\t\t\t\trn = max(rn, i + 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = rn; i < lg; i++) {\n\t\tif (!((mask[v] >> i) & 1)) {\n\t\t\trn = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tans = max(ans, rn);\n\tmask[v] = mask[v] & (((1 << lg) - 1) ^ ((1 << rn) - 1));\n\tmask[v] |= (1 << rn);\n}\t\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx--, y--;\n\t\tgr[x].push_back(y), gr[y].push_back(x);\n\t}\n\tdfs(0);\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nint n, mxv, mxd, par[MAXN];\nvector<int> Mat[MAXN];\nbool del[MAXN];\n\nvoid dfs(int v, int p, int d) {\n\tpar[v] = p;\n\tif (mxd < d)\n\t\tmxd = d, mxv = v;\n\tfor (int i = 0; i < Mat[v].size(); i++)\n\t\tif (Mat[v][i] != p && !del[Mat[v][i]])\n\t\t\tdfs(Mat[v][i], v, d + 1);\n}\n\nint getr(int v, int d) {\n\tfor (int i = 0; i < d / 2; i++)\n\t\tv = par[v];\n\treturn v;\n}\n\nint getans(int v) {\n\tdel[v] = 1;\n\tint mxne = 0, mxnev = -1, mxnee = 0;\n\tfor (int i = 0; i < Mat[v].size(); i++) {\n\t\tif (del[Mat[v][i]])\n\t\t\tcontinue;\n\t\tmxd = -1, mxv = 0;\n\t\tdfs(Mat[v][i], Mat[v][i], 0);\n\t\tmxd = -1;\n\t\tdfs(mxv, mxv, 0);\n\t\tint root = getr(mxv, mxd);\n\t\tif (mxnev < mxd)\n\t\t\tmxnev = mxd, mxne = root, mxnee = par[root];\n\t}\n\tif (mxnev == -1)\n\t\treturn 0;\n\tint k = getans(mxne) + 1;\n\tk = min(k, getans(mxnee) + 1);\n\tdel[v] = 0;\n\treturn k;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tMat[a].push_back(b);\n\t\tMat[b].push_back(a);\n\t}\n\tmxv = 1, mxd = -1;\n\tdfs(1, 1, 0);\n\tmxd = -1;\n\tdfs(mxv, mxv, 0);\n\tint root = getr(mxv, mxd);\n\tint pt = par[root];\n\tif (mxd % 2 == 0)\n\t\tcout << getans(root);\n\telse\n\t\tcout << min(getans(root), getans(pt));\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\ntypedef long long LL;\nconst int maxn = 100005;\n\nint ehead[maxn],ecnt;\nstruct edge {\n\tint u,v,next;\n}edg[maxn<<1];\nvoid add(int u,int v) {\n\tedg[++ecnt]=(edge){u,v,ehead[u]};\n\tehead[u]=ecnt;\n\tedg[++ecnt]=(edge){v,u,ehead[v]};\n\tehead[v]=ecnt;\n}\nint n,bit[maxn],f[maxn],ans;\nvoid dfs(int u,int fa)\n{\n\tint conf=0;\n\tfor (int v,j=ehead[u];j;j=edg[j].next)\n\tif ((v=edg[j].v)!=fa) {\n\t\tdfs(v,u);conf|=bit[u]&bit[v];bit[u]|=bit[v];\n\t}\n\twhile ((conf>>f[u])||(bit[u]>>f[u]&1)) ++f[u];\n\tbit[u]=(bit[u]>>f[u]<<f[u])|(1<<f[u]);\n\tans=max(ans,f[u]);\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc009d.in\",\"r\",stdin);\n\t\tfreopen(\"agc009d.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor (int u,v,i=1;i<n;i++)\n\t\tscanf(\"%d %d\",&u,&v),add(u,v);\n\tdfs(1,0);printf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\nint las[N];\nint n,cnt,mx,w,ans;\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid dfs(int x,int fa,int d){\n\tif (d>mx) mx=d,w=x;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif ((y=E[i].y)!=fa){\n\t\t\tdfs(y,x,d+1);\n\t\t}\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n) Link(IN(),IN());\n\tmx=-1;\n\tdfs(1,-1,1);\n\tmx=-1;\n\tdfs(w,-1,1);\n\twhile ((1<<ans+1)<=mx) ans++;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.11.2019 16:54:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> mask(n);\n  int ans = 0;\n  function<void(int, int)> Dfs = [&](int v, int pr) {\n    int lowest = 0;\n    for (int u : g[v]) {\n      if (u == pr) {\n        continue;\n      }\n      Dfs(u, v);\n      lowest |= (mask[u] & mask[v]);\n      mask[v] |= mask[u];\n    }\n    int bit = 1 << (lowest == 0 ? 0 : 32 - __builtin_clz(lowest));\n    while (mask[v] & bit) {\n      bit <<= 1;\n    }\n    mask[v] &= ~(bit - 1);\n    mask[v] |= bit;\n    ans = max(ans, 31 - __builtin_clz(mask[v]));\n  };\n  Dfs(0, -1);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <set>\nusing namespace std;\n\nint finder(vector<vector<int> > G, int now, int prv) {\n  vector<int> bits;\n  for (auto nxt : G[now]) {\n    if (nxt == prv) continue;\n    bits.push_back(finder(G, nxt, now));\n  }\n  int res = 0;\n  for (int bit=20; bit>=0; bit--) {\n    int cnt = 0;\n    for (auto p : bits) {\n      if (p&(1<<bit)) cnt ++;\n    }\n    if (cnt == 1) res += 1<<bit;\n    else if (cnt > 1) {\n      res += 1<<(bit+1);\n      return res;\n    }\n  }\n  res ++;\n  return res;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > G(N);\n  for (int i=0; i<N-1; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  int res = finder(G, 0, -1);\n  int ret = 0;\n  while (res > 1) {\n    res /= 2;\n    ret ++;\n  }\n  printf(\"%d\\n\", ret);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\n \n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n#define pb push_back\n \nusing namespace std;\n \nconst int N = 100010;\n \nvector<int> G[N];\nint n, mask[N];\n \nvoid DFS(int o, int f){\n\tint label = 0, s = 0;\n\t//for(int v : G[o]){\n\tfor (int i=0;i<G[o].size();++i)\n\t{\n\tint v=G[o][i];\n\t\tif(v == f) continue;\n\t\tDFS(v, o);\n\t\tlabel |= s & mask[v];// 值域> \n\t\ts |= mask[v];//子树的前缀值域 或 \n\t}\n\tlabel = label << 1 | 1;\n\tForr(i, 30, 0) if(label & (1 << i))\n\t\tFor(j, i, 30) if(!(s & (1 << j))){//不能等于s中的值 \n\t\t\tmask[o] = //(s ^ (s & ((1 << j) - 1))) | (1 << j);\n\t\t\t  (s>>j<<j)|(1<<j);\n\t\t\treturn;\n\t\t}\n}\n \nint main(){\n\tscanf(\"%d\", &n);\n\tFor(i, 2, n){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v), G[v].pb(u);\n\t}\n\tDFS(1, 0);\n\t//for(int i=1;i<=n;++i) printf(\"%d\\n\",mask[i]) ;\n\tForr(i, 30, 0) if(mask[1] & (1 << i)){\n\t\tprintf(\"%d\\n\", i);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,cnt,last[N],bit[N],ans,bin[25];\nstruct edge{int to,next;}e[N*2];\n\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nvoid addedge(int u,int v)\n{\n\te[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;\n\te[++cnt].to=u;e[cnt].next=last[v];last[v]=cnt;\n}\n\nvoid dfs(int x,int fa)\n{\n\tint l=0;\n\tfor (int i=last[x];i;i=e[i].next)\n\t{\n\t\tif (e[i].to==fa) continue;\n\t\tdfs(e[i].to,x);\n\t\tl|=bit[x]&bit[e[i].to];\n\t\tbit[x]|=bit[e[i].to];\n\t}\n\tint mx=20;\n\twhile (mx>=0&&!(l&bin[mx])) mx--;\n\tmx++;\n\twhile (bit[x]&bin[mx]) mx++;\n\tbit[x]|=bin[mx];bit[x]=bit[x]>>mx<<mx;\n\tans=max(ans,mx);\n}\n\nint main()\n{\n\tbin[0]=1;\n\tfor (int i=1;i<=20;i++) bin[i]=bin[i-1]*2;\n\tn=read();\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\taddedge(x,y);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (!isdigit(ch)&&ch!='-')\n\t\tch=getchar();\n\tif (ch=='-')\n\t\tf=-1,ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nint n;\nvector <int> e[N];\nint Log[N],ans=0,f[N];\nvoid solve(int x,int pre){\n\tint t=0;\n\tfor (auto y : e[x])\n\t\tif (y!=pre){\n\t\t\tsolve(y,x);\n\t\t\tt|=f[x]&f[y];\n\t\t\tf[x]|=f[y];\n\t\t}\n\tint k=t?Log[t]+1:0;\n\twhile (k<30&&(f[x]>>k&1))\n\t\tk++;\n\tans=max(ans,k);\n\tf[x]|=1<<k;\n\tf[x]&=~((1<<k)-1);\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t\te[i].clear();\n\tfor (int i=1;i<n;i++){\n\t\tint a=read(),b=read();\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tLog[1]=0;\n\tfor (int i=2;i<=n;i++)\n\t\tLog[i]=Log[i>>1]+1;\n\tsolve(1,0);\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef pair<ii, int> ri3;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define sc second\n#define SZ(x) (int)(x).size()\n#define ALL(x) begin(x), end(x) \n#define REP(i, n) for (int i = 0; i < n; ++i) \n#define FOR(i, a, b) for (int i = a; i <= b; ++i)\n#define RFOR(i, a, b) for (int i = a; i >= b; --i)\n\nconst int MX_N = 1e5+5;\n\nint N;\nvector<int> al[MX_N];\nint k[MX_N], bm[MX_N];\n\nvoid dfs(int u, int p) {\n    int cnt[20] = {0};\n    for (int v : al[u]) if (v != p) {\n        dfs(v,u);\n        FOR(i,0,19){\n            cnt[i] += ((bm[v]&(1<<i)) > 0 ? 1 : 0);\n            bm[u] |= bm[v];\n        }\n    }\n\n    int j = 19;\n    RFOR(i,19,0){\n        if (cnt[i] == 2) break;\n        else if (cnt[i] == 0) j = i;\n    }\n    bm[u] &= ~((1<<j)-1);\n    bm[u] |= (1<<j);\n    k[u] = j;\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N;\n    FOR(i,1,N-1){\n        int A, B; cin >> A >> B;\n        al[A].push_back(B);\n        al[B].push_back(A);\n    }\n\n    dfs(1,-1);\n    int ans = 0;\n    FOR(i,1,N) ans = max(ans,k[i]);\n    cout << ans;\n\n    //cout << endl;\n    //FOR(i,1,N){\n    //    cout << k[i] << ' ';\n    //}\n    //cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<cmath>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<ctype.h>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<math.h>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<stdio.h>\n#include<stdlib.h>\n#include<streambuf>\n#include<string.h>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\nusing namespace std;\nconst int maxn=100010;\nvector<int> adj[maxn];\nint dp[maxn];\nint st[maxn];\nint res;\nvoid dfs(int i,int fa){\n\tint curst=0;\n\tint mn=0;\n\tfor (int j=adj[i].size()-1;~j;--j){\n\t\tint nxt=adj[i][j];\n\t\tif (nxt==fa) continue;\n\t\tdfs(nxt,i);\n\t\tint nxst=st[nxt];\n\t\tmn|=(curst&nxst);\n\t\tcurst|=nxst;\n\t}\n\tfor (int j=0;j<=20;++j){\n\t\tif (!mn&&!(curst&(1<<j))){\n\t\t\tdp[i]=j;\n\t\t\tst[i]=curst&(~((1<<j)-1));\n\t\t\tst[i]|=(1<<j);\n\t\t\tbreak;\n\t\t}\n\t\tif (mn&(1<<j)) mn^=(1<<j);\n\t}\n\tif (res<dp[i]) res=dp[i];\n}\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tdfs(1,-1);\n\tprintf(\"%d\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef unordered_set<ll> set;\n#define N 100010\n#define D 40\nll n;\nvector<ll> g[N];\nset solve(ll x,ll from){\n  ll cnt[D]; for(int i=0;i<D;i++)cnt[i]=0;\n  for(auto y:g[x])if(y!=from){\n    for(auto z:solve(y,x))cnt[z]++;\n  }\n  ll clash=-1;\n  for(ll i=0;i<D;i++){\n    if(cnt[i]>=2)clash=i;\n  }\n  ll gen;\n  for(ll i=clash+1;;i++){\n    if(cnt[i]==0){gen=i; break;}\n  }\n  set res; res.insert(gen);\n  for(ll i=gen+1;i<D;i++){\n    if(cnt[i]>0)res.insert(i);\n  }\n  return res;\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    ll a,b;cin>>a>>b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  set res=solve(1,0);\n  ll ans=0;\n  for(auto x:res)ans=max(ans,x);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN (100010)\n\nint n;\nint sz[MAXN];\nbool vis[MAXN];\nstd::vector<int> mat[MAXN];\n\nint getroot(int u, int fa, int &root, int &rootsz, int nown){\n\tsz[u] = 1;\n\tint maxsz = 0;\n\tfor(auto v : mat[u]){\n\t\tif(vis[v] || v == fa) continue;\n\t\tgetroot(v, u, root, rootsz, nown);\n\t\tsz[u] += sz[v];\n\t\tmaxsz = std::max(maxsz, sz[v]);\n\t}\n\tmaxsz = std::max(maxsz, nown - sz[u]);\n\tif(rootsz > maxsz){\n\t\trootsz = maxsz;\n\t\troot = u;\n\t}\n}\n\nint solve(int u){\n\tvis[u] = true;\n\tint ret = 0;\n\tfor(auto v : mat[u]){\n\t\tif(vis[v]) continue;\n\t\tint root = 0, rootsz = n;\n\t\tgetroot(v, u, root, rootsz, sz[v]);\n\t\tret = std::max(ret, solve(root));\n\t}\n\treturn ret + 1;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++ i){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tmat[u].push_back(v);\n\t\tmat[v].push_back(u);\n\t}\n\tint root = 0, rootsz = n;\n\tgetroot(1, 0, root, rootsz, n);\n\tprintf(\"%d\\n\", solve(root) - 1);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<assert.h>\n#include<tuple>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<ctype.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef tuple<int,int,int> t3;\n\nconst int MX = 1 << 18;\nconst int MM = 1000000007;\n\nint val[MX];\nint bit[30]={0,1};\nint ans,st=1;\nbool check[MX];\nstd::vector<int> way[MX];\n\nvoid input()\n{\n\tint n,a,b;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tway[a].push_back(b);\n\t\tway[b].push_back(a);\n\t}\n\tfor(st=1;st<=n;st++)if(way[st].size()==1)break;\n\tfor(int i=2;i<30;i++)bit[i]=bit[i-1]*2;\n}\n\nvoid fill(int x)\n{\n\tint j;\n\tcheck[x]=true;\n\tfor(int i=0;i<way[x].size();i++){\n\t\tif(check[way[x][i]])continue;\n\t\tfill(way[x][i]);\n\t\tfor(j=25;j>=1;j--){\n\t\t\tif((val[x]&val[way[x][i]]&bit[j]) != 0){\n\t\t\t\tval[x]|=bit[j]-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tval[x]|=val[way[x][i]];\n\t}\n\tval[x]++;\n\tint tmp=29;\n\twhile((bit[tmp]&val[x]) == 0)tmp--;\n\tans=std::max(ans,tmp);\n}\n\nint main()\n{\n\t//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinput();\n\tfill(st);\n\tprintf(\"%d\",ans-1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, d1, d2, dis[N], mark[N];\nvector <int> adj[N];\n\nvoid _dfs(int v, int c) {\n\tdis[v] = c;\n\tmark[v] = 1;\n\tfor (int i : adj[v])\n\t\tif (!mark[i])\n\t\t\t_dfs(i, c + 1);\n}\n\nvoid dfs(int s) {\n\tmemset(mark, 0, sizeof mark);\n\t_dfs(s, 0);\n}\n\nint solve(int x) {\n\tif (!x)\n\t\treturn 0;\n\tif (x == 1)\n\t\treturn 1;\n\t\n\tx -= 2;\n\tint x1 = x / 2, x2 = x - x1;\n\treturn 1 + max(solve(x1), solve(x2));\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t}\n\t\n\tdfs(0);\n\tfor (int i = 0, mx = 0; i < n; i++)\n\t\tif (dis[i] > mx) {\n\t\t\tmx = dis[i];\n\t\t\td1 = i;\n\t\t}\n\tdfs(d1);\n\tfor (int i = 0, mx = 0; i < n; i++)\n\t\tif (dis[i] > mx) {\n\t\t\tmx = dis[i];\n\t\t\td2 = i;\n\t\t}\n\t\n//\tcout << dis[d2] << endl;\n\tcout << solve(dis[d2]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nvector<int> g[N];\nint ant[N];\nint n;\n\n\nstatic int compute(int arg) {\n\tfor (int lg = 0; ; ++lg)\n\t\tif ((1 << lg + 1) > arg)\n\t\t\treturn lg;  }\n\nstatic int dfs(int u, int far = 0) {\n\tint viz(0), force(0);\n\n\tfor (auto v: g[u]) if (v != far) {\n\t\tint msk = dfs(v, u);\n\t\tforce|= (viz & msk);\n\t\tviz|= msk; }\n\n\tant[u] = compute(force);\n\twhile ((1 << ant[u]) & viz)\n\t\t++ant[u];\n\n\tviz = viz & ~((1 << ant[u]) - 1);\n\tviz|= 1 << ant[u];\n\n\treturn viz; }\n\nint main() {\n#ifdef HOME\n\tfreopen(\"agc9d.in\", \"r\", stdin);\n\tfreopen(\"agc9d.out\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\n\tcin >> n;\n\tfor (int u, v, i = 1; i < n; ++i) {\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u); }\n\n\tdfs(1);\n\tcout << *max_element(ant + 1, ant + n + 1) << endl;\n\n\treturn 0; }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 100000\nint r[MN+5],ans;\nint main()\n{\n\tint n=read(),i;\n\tfor(i=1;i<n;++i)++r[read()],++r[read()];\n\tfor(i=1;i<=n;++i)ans=max(ans,r[i]);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\ntypedef pair<ii, int> ri3;\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define sc second\n#define SZ(x) (int)(x).size()\n#define ALL(x) begin(x), end(x) \n#define REP(i, n) for (int i = 0; i < n; ++i) \n#define FOR(i, a, b) for (int i = a; i <= b; ++i)\n#define RFOR(i, a, b) for (int i = a; i >= b; --i)\n\nconst int MX_N = 1e5+5;\n\nint N;\nvector<int> al[MX_N];\nint k[MX_N], bm[MX_N];\n\nvoid dfs(int u, int p) {\n    int cnt[20] = {0};\n    for (int v : al[u]) if (v != p) {\n        dfs(v,u);\n        FOR(i,0,19){\n            cnt[i] += ((bm[v]&(1<<i)) > 0 ? 1 : 0);\n            bm[u] |= bm[v];\n        }\n    }\n\n    int j = 19;\n    RFOR(i,19,0){\n        if (cnt[i] >= 2) break;\n        else if (cnt[i] == 0) j = i;\n    }\n    bm[u] &= ~((1<<j)-1);\n    bm[u] |= (1<<j);\n    k[u] = j;\n}\n\nint main() {\n    //freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N;\n    FOR(i,1,N-1){\n        int A, B; cin >> A >> B;\n        al[A].push_back(B);\n        al[B].push_back(A);\n    }\n\n    dfs(1,-1);\n    int ans = 0;\n    FOR(i,1,N) ans = max(ans,k[i]);\n    cout << ans;\n\n    //cout << endl;\n    //FOR(i,1,N){\n    //    cout << k[i] << ' ';\n    //}\n    //cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nconst int maxn = 4;\nconst int maxm = (1 << maxn) + 20;\nconst int maxN = 1e5 + 20;\n\nint dp[maxN][maxm] , tmp[maxm] , hb[maxm];\n\nvector<int> adj[maxN];\n\nvoid dfs(int v , int p = -1)\n{\n\tmemset(dp[v] , 63 , sizeof dp[v]);\n\tfor(int i = 0; i < maxn; i++)\n\t\tdp[v][1 << i] = i;\n\n\tfor(auto u : adj[v])\n\t\tif(u != p)\n\t\t{\n\t\t\tdfs(u , v);\n\t\t\tmemset(tmp , 63 , sizeof tmp);\n\n\t\t\tfor(int mask = 1; mask < (1 << maxn); mask++)\n\t\t\t\tfor(int masku = 1; masku < (1 << maxn); masku++)\n\t\t\t\t\tif((mask & masku) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint shit = (masku & ((1 << hb[mask]) - 1));\n\t\t\t\t\t\tshit |= mask;\n\t\t\t\t\t\ttmp[shit] = min(tmp[shit] , max(dp[v][mask] , dp[u][masku]));\n\t\t\t\t\t}\n\n\t\t\tfor(int mask = 0; mask < (1 << maxn); mask++)\n\t\t\t\tdp[v][mask] = tmp[mask];\n\t\t}\n\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tfor(int i = 1; i < maxm; i++)\n\t\thb[i] = hb[i / 2] + 1;\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b;\n\t\tcin >> a >> b;\n\t\ta-- , b--;\n\t\t\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\n\tdfs(0);\n\n\tcout << *min_element(dp[0] , dp[0] + maxm) << endl;\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint getv(int a)\n{\n    if(a==1) return 0;\n    return getv(a/2) + 1;\n}\nvoid dfs(vector<set<int> >& graph, int a, int pa, bool fillflag, vector<bool>& rm)\n{\n    if(graph[a].size() >= 3) fillflag = false;\n    rm[a] = fillflag;\n    for(auto x: graph[a])\n    {\n        if(x==pa) continue;\n        dfs(graph, x, a, !fillflag, rm);\n    }\n}\nint solve(vector<set<int> > graph)\n{\n    if(graph.size() == 1) return 0;\n    if(graph.size() <= 3) return 1;\n    int degover2 = -1;\n    for(int i=0; i<graph.size(); ++i)\n    {\n        if(graph[i].size() > 2) degover2 = i;\n    }\n    if(degover2 == -1)\n    {\n        return getv(graph.size());\n    }\n    vector<bool> rm(graph.size(), false);\n    dfs(graph, degover2, -1, false, rm);\n    \n    \n    int tp = 0;\n    vector<int> acc(graph.size(), -1);\n    vector<int> invacc;\n    for(int i=0; i<graph.size(); ++i)\n        if(!rm[i])\n        {\n            acc[i] = tp++;\n            invacc.push_back(i);\n        }\n    for(int i=0; i<graph.size(); ++i)\n    {\n        if(!rm[i]) continue;\n        assert(graph[i].size() == 1 || graph[i].size() == 2);\n        if(graph[i].size() == 1)\n        {\n            int t = *graph[i].begin();\n            graph[t].erase(i);\n        }\n        else if(graph[i].size() == 2)\n        {\n            int t = *graph[i].begin();\n            int u = *graph[i].rbegin();\n            graph[t].erase(i); graph[u].erase(i);\n            graph[t].insert(u); graph[u].insert(t);\n        }\n    }\n    vector<set<int> > newgraph(tp);\n    for(int i=0; i<tp; ++i)\n    {\n        int targ = invacc[i];\n        for(auto x: graph[targ])\n        {\n            assert(acc[x] != -1);\n            newgraph[i].insert(acc[x]);\n        }\n    }\n    return 1 + solve(newgraph);\n}\nint main()\n{\n    int N;\n    scanf(\"%d\", &N);\n    vector<set<int> > graph(N);\n    for(int i=0; i<N-1; ++i)\n    {\n        int u, v; scanf(\"%d%d\", &u, &v);\n        --u; --v;\n        graph[u].insert(v);\n        graph[v].insert(u);\n    }\n    printf(\"%d\\n\", solve(graph));\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Author       : Sun YaoFeng\n//============================================================================\n\n//#pragma \tcomment(linker, \"/STACK:100240000,100240000\")\n//#include\t<cstdio>\n//#include\t<cstdlib>\n//#include\t<cstring>\n//#include\t<algorithm>\n\n#include\t<bits/stdc++.h>\n\nusing\tnamespace\tstd;\n\n#define DB\t\tdouble\n#define\tlf\t\telse if\n#define I64\t\tlong long\n#define\tRd()\t(rand()<<15|rand())\n#define For(i,a,b)\tfor(int i=a,lim=b;i<=lim;i++)\n#define Rep(i,a,b)\tfor(int i=a,lim=b;i>=lim;i--)\n\n#define\tfi\tfirst\n#define se\tsecond\n#define MK\tmake_pair\n#define PA\tpair<int, int>\n\n//#define\tmin(a,b)\t((a)<(b)?(a):(b))\n//#define\tmax(a,b)\t((a)<(b)?(b):(a))\n\n#define\tCH\t(ch=getchar())\nint\t\tIN()\t{\n\t\tint x= 0, f= 0, ch;\n\t\tfor\t(; CH < '0' || ch > '9';)\tf= (ch == '-');\n\t\tfor\t(; ch >= '0' && ch <= '9'; CH)\tx= x*10 + ch -'0';\n\t\treturn\tf? -x : x;\n}\n\n#define n\t100005\n\nint\t\tN, D, st[n], Num[n];\n\nstruct\tLin{\n\t\tint v, next;\n}E[n << 1];\n\nvoid\tLink(int u, int v)\t{\n\t\tE[++ D]= (Lin){v, st[u]};\tst[u]= D;\n\t\tE[++ D]= (Lin){u, st[v]};\tst[v]= D;\n}\n\nset<int>\tG[n];\n\nvoid\tMerge(int u, set<int>&a, set<int>&b)\t{\n\t\tif\t(a.size() > b.size())\tswap(a, b);\n\t\tfor (set<int>::iterator it= b.begin(); it != b.end(); it++)\t{\n\t\t\tif\t(a.find(*it) != a.end())\tNum[u]= max(Num[u], (*it) + 1);\n\t\t\t\telse\ta.insert(*it);\n\t\t}\n}\n\nvoid\tDFS(int u, int f)\t{\n\t\tNum[u]= 0;\n\t\t\n\t\tfor (int i= st[u], v; i; i= E[i].next)\n\t\t\tif\t((v= E[i].v) != f)\tDFS(v, u);\n\t\t\n\t\tfor (int i= st[u], v; i; i= E[i].next)\n\t\t\tif\t((v= E[i].v) != f)\tMerge(u, G[u], G[v]);\n\t\t\n\t\tfor (; G[u].find(Num[u]) != G[u].end(); )\tG[u].erase(Num[u]), Num[u]++;\n\t\tG[u].insert(Num[u]);\n\t\t\n\t//\tprintf(\"# %d %d\\n\", u, Num[u]);\n}\n\nint\t\tmain(int argc, char* argv[]){\n\t\tN= IN();\n\t\tFor(i, 2, N)\tLink(IN(), IN());\n\t\t\n\t\tDFS(1, 0);\n\t\t\n\t\tint\tAns= 0;\n\t\tFor(i, 1, N)\tAns= max(Ans, Num[i]);\n\t\t\n\t\tcout << Ans << endl;\n\t\t\n\t\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ***********************************************\nAuthor        :axp\nCreated Time  :2017/1/23 10:14:37\nTASK\t\t  :D.cpp\nLANG          :C++\n************************************************ */\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\nconst int inf = 1<<30;\nconst int md = 1e9+7;\nconst int N = 1e5+10;\nint n,m;\nint T;\nvector<int> ve[N];\nint d[N];\n\nint f(int x)\n{\n\tif(x<=1)return 0;\n\treturn f((x-2)/2+1)+1;\n}\n\nint dfs(int p,int x)\n{\n\tint re=d[x];\n\tfor(int i=0;i<ve[x].size();i++)\n\t{\n\t\tint &y=ve[x][i];\n\t\tif(y==p)continue;\n\t\td[y]=d[x]+1;\n\t\tre=max(re,dfs(x,y));\n\t}\n\treturn re;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    scanf(\"%d\",&n);\n\tint x,y;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tve[x].push_back(y);\n\t\tve[y].push_back(x);\n\t}\n\tint dep;\n\td[1]=1;\n\tdep=dfs(0,1);\n\tfor(int i=1;i<=n;i++)if(d[i]==dep)x=i;\n\td[x]=1;\n\tdep=dfs(0,x);\n\tint ans=f(dep);\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint n;\nvector<int> g[100005];\nint lsb(int a){\n  return __builtin_ctz(a);\n}\nint dfs(int v,int p){\n  int mask=0,incr=-1;\n  for(auto to:g[v]){\n    if(to==p) continue;\n    int tmp=dfs(to,v);\n    if(tmp&mask) chmax(incr,lsb(tmp&mask));\n    mask|=tmp;\n  }\n  if(incr==-1) incr=0;\n  for(int i=incr;;++i) if(!(mask>>i&1)){\n    mask|=(1<<i);\n    mask&=~((1<<i)-1);\n    break;\n  }\n  return mask;\n}\n\n\nint main(){\n  cin>>n;\n  REP(i,n-1){\n    int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n  int res=dfs(0,-1);\n  int ans=0;\n  REP(i,20) if(res>>i&1) ans=i;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define SZ 666666\n#define S 80\nint fst[SZ],M=0,nxt[SZ],vb[SZ];\nvoid ad_de(int a,int b)\n{\n\t++M; nxt[M]=fst[a]; fst[a]=M; vb[M]=b;\n}\nvoid adde(int a,int b)\n{ad_de(a,b);ad_de(b,a);}\nbool f[100555][S];\nint n,tmp[S];\nvoid dfs(int x,int fa=0)\n{\n\tfor(int e=fst[x];e;e=nxt[e])\n\t{\n\t\tint b=vb[e]; if(b==fa) continue;\n\t\tdfs(b,x);\n\t}\n\tfor(int i=0;i<S;++i) tmp[i]=0;\n\tfor(int e=fst[x];e;e=nxt[e])\n\t{\n\t\tint b=vb[e]; if(b==fa) continue;\n\t\tfor(int j=0;j<S;++j) tmp[j]+=f[b][j];\n\t}\n\t++tmp[0]; int r=-1;\n\tfor(int j=0;j<S;++j)\n\t\tif(tmp[j]>=2)\n\t\t\t++tmp[j+1], r=j;\n\tfor(int j=0;j<=r;++j) tmp[j]=0;\n\tfor(int j=0;j<S;++j)\n\t\tf[x][j]=tmp[j];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(a,b);\n\t}\n\tdfs(1);\n\tfor(int i=S-1;i>=0;--i)\n\t{\n\t\tif(f[1][i])\n\t\t{\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef long long LL;\nconst int N=2e5;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint head[N],nxt[N],to[N];\nint f[N];\n//给每个点一个标号，使得任意两个相同标号的点的路径上存在点标号大于这两个点\n//每次贪心选择最小的标号\ninline void dfs(int k,int fa) {\n\tint s=0,all=0;\n\tfor (int i=head[k];i;i=nxt[i])\n\t\tif (to[i]!=fa) {\n\t\t\tdfs(to[i],k);\n\t\t\tall|=s&f[to[i]];\n\t\t\ts|=f[to[i]];\n\t\t}\n\t(all<<=1)|=1;\n\tfor (int i=30;i>=0;i--)\n\t\tif (all>>i&1) {\n\t\t\twhile (s>>i&1) i++;\n\t\t\tf[k]=(s^(s&((1<<i)-1)))|(1<<i);\n\t\t\treturn;\n\t\t}\n}\nint main()\n{\n\tint n=gi(),i,a,b,tot=0;\n\tfor (i=1;i<n;i++) {\n\t\ta=gi(),b=gi();\n\t\tto[++tot]=b,nxt[tot]=head[a],head[a]=tot;\n\t\tto[++tot]=a,nxt[tot]=head[b],head[b]=tot;\n\t}\n\tdfs(1,0);\n\tfor (i=30;i>=0;i--)\n\t\tif (f[1]>>i&1)\n\t\t\treturn printf(\"%d\\n\",i),0;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && up[G[v][i].first] < 1 + down[G[v][i].first]) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\twhile (true) {\n\t\tans++;\n\t\tmemset(Mark, 0, sizeof Mark);\n\t\tmemset(down, 0, sizeof down);\n\t\tmemset(up, 0, sizeof up);\n\t\tbool change = false;\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\tchange = true;\n\t\t\t\t\n\t\t\t\tdfs1(i, i);\n\t\t\t\tdfs2(i, i, 0);\n\t\t\t\tfindS(i, i);\n\t\t\t\tdel[S] = true;\n\t\t\t\t//cout << \"&   \" << S << \"\\n\";\n\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!d[i]) {\n\t\t\t\t//cout << \"^ \" << i << \"\\n\";\n\t\t\t\tdel[i] = true;\n\t\t\t}\n\t\t\t\t\n\t\tif (!change)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ans - 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nint n,i,j,k,u,v,ans;\nint son[100005],Next[200005],ed[200005],tot;\nint S[100005];\n\nvoid dfs(int x,int y)\n{\n\tint i,j,k,A=0,B=0;\n\tfor(i=son[x];i;i=Next[i])if(ed[i]!=y)dfs(ed[i],x);\n\tfor(i=son[x];i;i=Next[i])\n\tif(ed[i]!=y)\n\t{\n\t\tB|=(A&S[ed[i]]);\n\t\tA|=S[ed[i]];\n\t}\n\tfor(k=20;k>=0;--k)if(B&(1<<k))break;\n\tfor(++k;(1<<k)&A;++k);\n\tif(k>ans)ans=k;\n\tS[x]=A|(1<<k);\n\tS[x]-=(S[x]&((1<<k)-1));\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\t++tot;Next[tot]=son[u];son[u]=tot;ed[tot]=v;\n\t\t++tot;Next[tot]=son[v];son[v]=tot;ed[tot]=u;\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _LOCAL_\n\t#define cout cerr\n#endif\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define FORalld(it, a) for (__typeof((a).rbegin()) it = (a).rbegin(); it != (a).rend(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ntemplate<class T> inline T isqrt(T k) {T r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ntemplate<class T> inline T icbrt(T k) {T r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n\nconst int MAXN = 100000 + 5;\nint n;\nvector<int> adj[MAXN];\nint del[MAXN];\nint size[MAXN];\nvoid dfs(int u, int p) {\n\tsize[u] = 1;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v != p && !del[v]) {\n\t\t\tdfs(v, u);\n\t\t\tsize[u] += size[v];\n\t\t}\n\t}\n}\nint findcentroid(int u) {\n\tint p = -1; dfs(u, -1);\n\tint cap = size[u] >> 1;\n\twhile (1) {\n\t\tbool found = false;\n\t\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\t\tint v = adj[u][i];\n\t\t\tif (v != p && !del[v] && size[v] > cap) {\n\t\t\t\tfound = true;\n\t\t\t\tp = u; u = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) return u;\n\t}\n}\nint divide(int u) {\n\tu = findcentroid(u);\n\tdel[u] = 1;\n\tint res = 0;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i];\n\t\tif (!del[v]) {\n\t\t\tres |= divide(v);\n\t\t}\n\t}\n\tFOR(i, 0, 30) if (!bit(res, i)) {\n\t\tFOR(j, 0, i) res |= 1 << j, res ^= 1 << j;\n\t\tres |= 1 << i;\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> n;\n\tFOR(i, 0, n - 1) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tint res = divide(0);\n\tcout << bitcount(res) << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct node {\n\tint to, next;\n} edge[MAXN*2];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nint n, a, b;\n\nint dp[MAXN], lg[MAXN];\n\ninline int lowbit(int i)\n{ return i&(-i); }\n\nvoid dfs(int nd, int f)\n{\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (to == f) continue;\n\t\tdfs(to, nd);\n\t\tdp[nd] |= dp[to];\n\t}\n\tdp[nd]++;\n\t\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tlg[1] = 0;\n\tfor (int i = 2; i <= n; i++) lg[i] = lg[i>>1]+1;\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpush(a, b), push(b, a);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tans = max(ans, lg[lowbit(dp[i])]);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nll N;\nvvll g;\n\nll dfs(ll u, ll v) {\n\tvll lis;\n\tfor (ll w : g[v]) {\n\t\tif (u == w) { continue; }\n\t\tlis.push_back(dfs(v, w));\n\t}\n\n\tll k = 30;\n\tfor (ll i = 30; i >= 0; i--) {\n\t\tll count = 0;\n\t\tfor (ll x : lis) { if ((x >> i) & 1) { count++; } }\n\t\tif (count >= 2) { break; }\n\t\tif (count == 0) { k = i; }\n\t}\n\n\tll ret = 1<<k;\n\tfor (ll x : lis) { ret |= x; }\n\tret &= ~((1 << k) - 1);\n\n\t//cout << v << \" \" << ret << endl;\n\treturn ret;\n}\n\nint main() {\n\tcin >> N;\n\tg.resize(N + 1);\n\trepn(i, N-1) {\n\t\tll x, y;\n\t\tcin >> x >> y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\n\tll t = dfs(0, 1);\n\t//cout << t << endl;\n\n\tll ans = 0;\n\trep(i, 30) {\n\t\tif ((t >> i) == 0) { ans = i - 1; break; }\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge\n{\n    int nxt, to;\n};\nEdge e[200010];\nint head[200010], cnt;\nconst int LG = 65;\nint dp[200010][LG + 2];\n\nvoid add_edge(int a, int b)\n{\n    e[++cnt] = (Edge){ head[a], b };\n    head[a] = cnt;\n}\n\nvoid dfs(int nod, int tata)\n{\n    for (int i = head[nod]; i; i = e[i].nxt) {\n        int v = e[i].to;\n        if (v == tata)\n            continue;\n        dfs(v, nod);\n        for (int j(0); j <= LG; j++)\n            dp[nod][j] += dp[v][j];\n    }\n    for (int i(LG); i >= 0; i--) {\n        if (dp[nod][i] <= 1)\n            continue;\n        int p(i);\n        while (dp[nod][p])\n            p++;\n        dp[nod][p] = 1;\n        for (int j(0); j < p; j++)\n            dp[nod][j] = 0;\n        return;\n    }\n\n    int p(0);\n    while (dp[nod][p])\n        p++;\n    dp[nod][p] = 1;\n    for (int i(0); i < p; i++)\n        dp[nod][i] = 0;\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    while (--n) {\n        cin >> a >> b;\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n\n    dfs(1, 0);\n\n    for (int i(LG); i >= 0; i--) {\n        if (dp[1][i]) {\n            cout << i;\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-13;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nvector<int>g[110000];\nint dp[110000];\nint ret=0;\nint dfs(int a,int b){\n\tint d[30];\n\tfor(int i=0;i<30;i++)d[i]=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\tint tmp=dfs(g[a][i],a);\n\t\tfor(int j=0;j<30;j++){\n\t\t\tif(tmp&(1<<j))d[j]++;\n\t\t}\n\t}\n\tint num=0;\n\tfor(int i=29;i>=0;i--){\n\t\tif(d[i]>=2)break;\n\t\tif(d[i]==0)num=i;\n\t}\n\tret=max(ret,num);\n\tint to=(1<<num);\n\tfor(int i=num+1;i<30;i++){\n\t\tif(d[i])to+=(1<<i);\n\t}\n\treturn to;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t}\n\tdfs(0,-1);\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n//#define int long long\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\n#define X first\n#define Y second\n#define endl '\\n'\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\n#define all(o) o.begin(), o.end()\nconst int maxn = 1e5 + 10;\nbool bad[maxn];\nvi adj[maxn];\nint sz[maxn];\nvi comp;\nbool mark[maxn];\nvoid dfs(int v,int p){\n\tif(bad[v]) return;\n\tif(v == p) comp.clear();\n\tcomp.push_back(v);\n\tsz[v] = 1;\n\tmark[v] = true;\n\tfor(auto u : adj[v]){\n\t\tif(u == p) continue;\n\t\tdfs(u, v);\n\t\tsz[v] += sz[u];\n\t}\n}\nmain(){\n\tIOS;\n\tint n;\n\tcin >> n;\n\tfor(int i=0; i<n-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tint rem = n;\n\tint tim = 0;\n\twhile(rem){\n\t\tmemset(sz, 0, sizeof sz);\n\t\tmemset(mark, 0, sizeof mark);\n\t\ttim++;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(bad[i] || mark[i]) continue;\n\t\t\tdfs(i, i);\n\t\t\tint mn = 1e9, id = -1;\n\t\t\tfor(auto v : comp){\n\t\t\t\tint mx = 0;\n\t\t\t\tfor(auto u : adj[v]){\n\t\t\t\t\tif(bad[u]) continue;\n\t\t\t\t\tint t;\n\t\t\t\t\tif(sz[v] > sz[u]) t = sz[u];\n\t\t\t\t\telse t = sz[i] - 1 - sz[v];\n\t\t\t\t\tmx = max(mx, t);\n\t\t\t\t}\n\t\t\t\tif(mx < mn){\n\t\t\t\t\tmn = mx;\n\t\t\t\t\tid = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbad[id] = true;\n\t\t\trem--;\n\t\t}\n\t}\n\tcout << tim - 1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 724249387, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nvector <int> g[N] ;\nint dp[N] ;\n \nvoid dfs(int u, int par) {\n    int cnt[25] ;\n    memset(cnt,0,sizeof(cnt));\n    for(int i = 0; i < (int)g[u].size(); i++) {\n        int v = g[u][i] ;\n        if(v == par) \n\t\t\tcontinue;\n        dfs(v,u);\n        for(int j = 0; j < 20; j++) \n            if((dp[v] & (1 << j))) \n\t\t\t\tcnt[j]++ ;\n    }\n    int myCol = 0;\n    for(int i= 20 - 1; i >= 0; i--) {\n        if(cnt[i] > 1) {\n            myCol = i + 1;\n            break;\n        }\n    }\n    while(cnt[myCol]) \n\t\tmyCol++ ;\n    dp[u] |= (1 << myCol) ;\n    for(int i = myCol + 1; i < 20; i++) \n        if(cnt[i]) \n\t\t\tdp[u] |= (1 << i);\n}\n \nint32_t main() {\n    int n;\n    cin >> n;\n    for(int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v); \n\t\tg[v].pb(u);\n    }\n    dfs(1,0) ;\n    int ans = 0;\n    while(dp[1] > 0) {\n        dp[1] /= 2 ;\n        ans++ ;\n    }\n    cout << ans - 1;\n    return 0 ;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint N;\nvector< int > g[100000];\nbool v[100000][30];\n\nint dfs(int idx, int par) {\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to != par) ret = max(ret, dfs(to, idx));\n  }\n  for(int i = 0; i < 30; i++) {\n    bool correct = true;\n    for(auto &to : g[idx]) {\n      if(to != par) {\n        if(v[to][i]) correct = false;\n      }\n    }\n    if(correct) {\n      ret = max(ret, i);\n      v[idx][i] = true;\n      for(auto &to : g[idx]) {\n        if(to != par) {\n          for(int j = i + 1; j < 30; j++) {\n            v[idx][j] |= v[to][j];\n          }\n        }\n      }\n      break;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  cout << dfs(0, -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nvector<int> v[100005];\nint dp[100005][20];\nint ans;\nvoid dfs(int x,int f){\n    for(auto it:v[x]){\n        if(it!=f){\n            dfs(it,x);\n            for(int i = 0;i<20;i++){\n                dp[x][i]+=dp[it][i];\n            }\n        }    \n    }\n    int st=0;\n    for(int  i = 19;i>=0;i--){\n        if(dp[x][i]>=2){\n            st=i;\n            break;\n        }\n    }\n    for(int i = st;;i++){\n        if(dp[x][i]==0){\n            dp[x][i]=1;\n            ans=max(ans,i);\n            for(int j=i-1;j>=0;j--)\n                dp[x][j]=0;\n            return;\n        }\n    }\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 1;i<n;i++){\n        int x,y;\n        scanf(\"%d %d\",&x,&y);\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/*  ***  In The Name of God ... ***  */\n#include <bits/stdc++.h>\n\nusing namespace std ;\n \ntypedef long long ll ;\ntypedef long double ld ;\n\n\n#define int long long\n#define all(v) v.begin() , v.end()\n\ntemplate<typename T> inline bool smin(T &a, const T &b){ return b < a ? a = b,1:0;}\ntemplate<typename T> inline bool smax(T &a, const T &b){ return a < b ? a = b,1:0;}\n\nconst int N = ( int ) 1e5 + 10 ;\n\nint n , sz [ N ] , all = 0 ; \nvector < int > adj [ N ] ; \nbool mark [ N ] ;\n\nvoid dfs ( int v , int p = -1 ) {\n\tsz [ v ] = 1 ;\n\tfor ( int u : adj [ v ] ) {\n\t\tif ( u == p ) continue ;\n\t\tif ( !mark [ u ] ) {\n\t\t\tdfs ( u , v ) ;\n\t\t\tsz [ v ] += sz [ u ] ; \n\t\t}\n\t}\n}\n\nint get_centroid ( int v , int p = -1 ) {\n\tfor ( int u : adj [ v ] ) {\n\t\tif ( mark [ u ] ) continue ;\n\t\tif ( sz [ u ] >= all / 2 && u != p )\n\t\t\treturn get_centroid ( u , v ) ;  \n\t}\n\treturn v ; \n}\n\nint solve ( int v ) {\n\tdfs ( v ) ;\n\tall = sz [ v ] ; \n\tint c = get_centroid ( v ) ;\n\t//cout << \"here \" << v + 1 << ' ' << c + 1 << ' ' << all << endl ; \n\tmark [ c ] = true ;\n\tint ret = 0 ;\n\tfor ( int u : adj [ c ] ) {\n\t\tif ( !mark [ u ] ) {\n\t\t\tsmax ( ret , solve ( u ) ) ; \n\t\t}\n\t}\n\treturn ret + 1 ; \n}\n\nint32_t main()                     \n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n ;\n\tfor ( int j = 0 ; j < n - 1 ; ++ j ) {\n\t\tint u , v ;\n\t\tcin >> u >> v ;\n\t\t-- u , -- v ;\n\t\tadj [ u ] . push_back ( v ) ;\n\t\tadj [ v ] . push_back ( u ) ; \n\t}\n\tcout << solve ( 0 ) - 1 << '\\n' ; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n\nconst int N = 100000;\n\nstd::vector<int> tree[N];\n\nint dfs(int p, int u)\n{\n    auto ban = 0;\n    auto uni = 0;\n    for (auto&& v : tree[u]) {\n        if (v != p) {\n            auto ret = dfs(u, v);\n            ban |= ret;\n            ban |= uni & ret;\n            uni |= ret;\n        }\n    }\n    int k = 0;\n    while (ban >> k & 1) {\n        k ++;\n    }\n    return (uni | (1 << k)) & ~((1 << k) - 1);\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"D.in\", \"r\", stdin);\n#endif\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        for (int i = 0; i < n; ++ i) {\n            tree[i].clear();\n        }\n        for (int i = 1; i < n; ++ i) {\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            a --;\n            b --;\n            tree[a].push_back(b);\n            tree[b].push_back(a);\n        }\n        auto result = dfs(-1, 0);\n        printf(\"%d\\n\", 31 - __builtin_clz(result));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef vector<int>VI;\nint n,a,b,i;\nvector<int>e[N];\nbool f[N][20];\ninline void uni(bool*a,bool*b){\n\tstatic bool ans[20];memset(ans,0,20);int i=0,x;\n\tfor(;!a[i];)b[i++]=0;\n\tfor(;i<19;++i)\n\t\tif(x=a[i]+b[i]+ans[i],x>1)memset(ans,0,i+1),ans[i+1]=1;\n\t\t\telse ans[i]=x;\n\tmemcpy(a,ans,20);\n}\nvoid dfs(int u,int fa){\n\tf[u][0]=1;\n\tfor(int v:e[u])if(v!=fa)\n\t\tdfs(v,u),uni(f[u],f[v]);\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;for(i=1;i<n;++i)cin>>a>>b,e[a].push_back(b),e[b].push_back(a);\n\tdfs(1,0);for(i=19;!f[1][i];--i);cout<<i<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long LL;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts(\"\");\n}\nconst int N=100005;\nvector<int> v[N];\nint n,ans,f[N],high[N];\nvoid dfs(int p,int fa){\n\tint mx=0;\n\tfor(unsigned i=0;i<v[p].size();i++)if(v[p][i]!=fa){\n\t\tdfs(v[p][i],p);\n\t\tint t=f[p]&f[v[p][i]];\n\t\tif(t)mx=max(mx,high[t]+1); \n\t\tf[p]|=f[v[p][i]];\n\t}\n\twhile(f[p]>>mx&1)mx++;\n\tans=max(ans,mx);\n\tf[p]|=1<<mx;\n\tf[p]^=f[p]&((1<<mx)-1);\n\t//cout<<p<<\" \"<<mx<<endl;\n}\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=20;j>=0;j--)if(i>>j&1){high[i]=j; break;}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint s=read(),t=read();\n\t\tv[s].push_back(t); v[t].push_back(s);\n\t}\n\tdfs(1,0);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 200000 +10;\nconst int lim = 18;\nint read(){\n\tint x=0,flag=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')flag=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*flag;\n}\nstack <int> s;\nvoid out(int x){\n\tif(!x)s.push(0);\n\twhile(x){s.push(x%2);x/=2;}\n\tfor(int i=lim;i>(int)s.size();i--)printf(\"0\");\n\twhile(!s.empty()){printf(\"%d\",s.top()%2);s.pop();}\n\tputs(\"\");\n}\nint n,ans,cnte;\nint f[maxn],f2[maxn];\nint ai[maxn],label[maxn];\nint head[maxn],to[maxn*2],nxt[maxn*2];\nint lowbit(int x){return x&(-x);}\nvoid AddEdge(int x,int y){ ++cnte;to[cnte]=y;nxt[cnte]=head[x];head[x]=cnte; }\nvoid init(){\n\tai[0] = (1<<lim)-1;\n\tfor(int i=1;i<=lim;i++)ai[i]=ai[i-1]-lowbit(ai[i-1]);\n}\nint find(int x,int first){ \n\tfor(int i=first;i<=lim;i++)if(!((1<<i)&x))return i; return -1; \n}\nvoid dfs(int x,int fa){\n\tfor(int i=head[x];i;i=nxt[i])if(to[i]^fa){\n\t\tdfs(to[i],x);\n\t\tf2[x] |= f[to[i]] & f[x];\n\t\tf[x] = f[to[i]] ^ f[x];\n\t}\n\n//\tprintf(\"pro_x:%d\\n\",x);\n//\tprintf(\"f1:\");out(f[x]);\n//\tprintf(\"f2:\");out(f2[x]);\n\n\tlabel[x] = find(f[x],(!f2[x])?0:32-__builtin_clz(f2[x]));\n//\tprintf(\"label[x]:%d\\n\",label[x]);\n\n\tans=max(ans,label[x]);\n\n\tf[x] = f[x] & ai[ label[x] ];\n\tf2[x] = f2[x] & ai[ label[x] ];\n\n\tf[x] |= (1<<label[x]);\n\n//\tprintf(\"updated_x:%d\\n\",x);\n//\tprintf(\"f1:\");out(f[x]);\n//\tprintf(\"f2:\");out(f2[x]);\n//\tputs(\"\");\n\n}\nint main(){\n\tfreopen(\"test.in\",\"r\",stdin),freopen(\"test.out\",\"w\",stdout);\n\tinit();\n\n\tn=read();\n\tfor(int i=1;i<=n-1;i++){\n\t\tint x,y;\n\t\tx=read();y=read();\n\t\tAddEdge(x,y);AddEdge(y,x);\n\t}\n\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\ntypedef vector<int>VI;\nint n,a,b,i;\nVI e[N],f[N];\ninline VI uni(const VI&a,const VI&b){\n\tVI ans;int i=0,j=0,x;\n\tfor(;i<a.size() || j<b.size();){\n\t\tx=i<a.size() && (j==b.size() || a[i]<b[j])?a[i++]:b[j++];\n\t\tif(ans.empty() || ans.back()<x)ans.push_back(x);\n\t\t\telse if(ans.back()==x)++ans.back();\n\t}\n\treturn ans;\n}\nvoid dfs(int u,int fa){\n\tf[u]={0};\n\tfor(int v:e[u])if(v!=fa)dfs(v,u),f[u]=uni(f[u],f[v]);\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;for(i=1;i<n;++i)cin>>a>>b,e[a].push_back(b),e[b].push_back(a);\n\tdfs(1,0);cout<<f[1].back()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _LOCAL_\n\t#define cout cerr\n#endif\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define FORalld(it, a) for (__typeof((a).rbegin()) it = (a).rbegin(); it != (a).rend(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ntemplate<class T> inline T isqrt(T k) {T r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ntemplate<class T> inline T icbrt(T k) {T r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n\nconst int MAXN = 100000 + 5;\nint n;\nvector<int> adj[MAXN];\nint del[MAXN];\nint size[MAXN];\nvoid dfs(int u, int p) {\n\tsize[u] = 1;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i];\n\t\tif (v != p && !del[v]) {\n\t\t\tdfs(v, u);\n\t\t\tsize[u] += size[v];\n\t\t}\n\t}\n}\nint findcentroid(int u) {\n\tint p = -1; dfs(u, -1);\n\tint cap = size[u] >> 1;\n\twhile (1) {\n\t\tbool found = false;\n\t\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\t\tint v = adj[u][i];\n\t\t\tif (v != p && !del[v] && size[v] > cap) {\n\t\t\t\tfound = true;\n\t\t\t\tp = u; u = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) return u;\n\t}\n}\nint divide(int u) {\n\tu = findcentroid(u);\n\tdel[u] = 1;\n\tint res = 0;\n\tfor (int i = 0; i < adj[u].size(); i++) {\n\t\tint v = adj[u][i];\n\t\tif (!del[v]) {\n\t\t\tres |= divide(v);\n\t\t}\n\t}\n\tFOR(i, 0, 30) if (!bit(res, i)) {\n\t\tFOR(j, 0, i) res |= 1 << j, res ^= 1 << j;\n\t\tres |= 1 << i;\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> n;\n\tFOR(i, 0, n - 1) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tint res = divide(0);\n\tcout << __lg(res) << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG printf(\"Hi\\n\")\n#define i64 long long int\n#define ui64 unsigned long long int\n#define eps (1e-6)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\n#define sq(x) ((x)*(x))\n\n#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL)\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<int,int> pii;\n\n#define log 20\n#define mod 1000000007LL\n#define INF 1000000000\n#define maxn 200005\n\nvector <int> g[maxn] ;\nint dp[maxn] ;\n\nvoid dfs(int u, int par)\n{\n    int cnt[25] ;\n    memset(cnt,0,sizeof(cnt)) ;\n\n    for(int i=0 ; i<g[u].size() ; i++)\n    {\n        int v = g[u][i] ;\n        if(v==par) continue ;\n        dfs(v,u) ;\n\n        for(int j=0 ; j<20 ; j++)\n        {\n            if( (dp[v]&(1<<j)) ) cnt[j]++ ;\n        }\n    }\n    int myCol = 0;\n    for(int i=20-1 ; i>=0 ; i--)\n    {\n        if(cnt[i]>1)\n        {\n            myCol = i+1 ;\n            break ;\n        }\n    }\n    while(cnt[myCol]) myCol++ ;\n    dp[u] |= (1<<myCol) ;\n    for(int i=myCol+1 ; i<20 ; i++)\n    {\n        if(cnt[i]) dp[u] |= (1<<i) ;\n    }\n}\n\nint main()\n{\n    int n ;\n\n    scanf(\"%d\",&n) ;\n\n    for(int i=1 ; i<n ; i++)\n    {\n        int u , v ;\n        scanf(\"%d %d\",&u,&v) ;\n        g[u].pb(v) ; g[v].pb(u) ;\n    }\n\n    dfs(1,0) ;\n\n    int ans = 0 ;\n    while( dp[1] > 0 )\n    {\n        dp[1] /= 2 ;\n        ans++ ;\n    }\n\n    printf(\"%d\\n\",ans-1) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* by Natsu Kinmoe */\n#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x)               ((int)(x).size())\n#define all(x)              (x).begin(), (x).end()\n#define loop(i, n)          for(int i = 0; i < (n); i++)\n#define cont(i, n)          for(int i = 1; i <= (n); i++)\n#define circ(i, a, b)       for(int i = (a); i <= (b); i++)\n#define range(i, a, b, c)   for(int i = (a); ((c) > 0 ? i <= (b) : i >= (b)); i += (c))\n#define foreach(it, v)      for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)\n#define y0          y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1          y1II11II11III11I1III11II111IIII1II1I1\n#define pub         push_back\n#define pob         pop_back\n#define mak         make_pair\ntypedef long long   ll;\ntypedef long double lf;\nconst int   Inf = 0x3f3f3f3f;\nconst ll    INF = 0x3f3f3f3f3f3f3f3fll;\n/* Source code starts here */\n\nint n;\nvector<int> nei[1 << 17];\nint msk[1 << 17], ans;\n\nvoid dfs(int now, int lst) {\n\tvector<int> cnt(20);\n\tloop(i, SZ(nei[now])) {\n\t\tint to = nei[now][i];\n\t\tif(to == lst) continue;\n\t\tdfs(to, now);\n\t\tmsk[now] |= msk[to];\n\t\tloop(i, 20) if((msk[to] >> i) & 1) cnt[i]++;\n\t}\n\tint sel = 19;\n\twhile(sel > 0 && cnt[sel] < 2) sel--;\n\twhile(cnt[sel]) sel++;\n\tans = max(ans, sel);\n\tmsk[now] = (msk[now] >> sel << sel) | (1 << sel);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tcont(i, n - 1) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\tnei[a].pub(b); nei[b].pub(a);\n\t}\n\tdfs(1, 0);\n\treturn 0 & printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint val[100005];\nvector<int> adj[100005];\nvoid DFS(int v, int p){\n\tval[v] = 0;\n\tfor (int j: adj[v]){\n\t\tif (j != p){\n\t\t\tDFS(j, v);\n\t\t\tval[v] |= val[j];\n\t\t}\n\t}\n\tval[v]++;\n}\n\nint main(){\n\tint N; cin >> N;\n\tfor (int i = 0; i < N - 1; i++){\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tDFS(1, 0);\n\tint lg = 0;\n\twhile (val[1]/2){\n\t\tval[1] /= 2;\n\t\tlg++;\n\t}\n\tcout << lg << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 120000\n\nint n,ans,f[N];\nvector<int> g[N];\n\nvoid dfs(int u,int fa){\n\tint mx=0;\n\tfor (int v:g[u])\n\t\tif (v!=fa){\n\t\t\tdfs(v,u);\n\t\t\tfor (int i=0;i<20;++i)\n\t\t\t\tif ((f[u]&f[v])>>i&1) mx=max(mx,i+1);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tfor (;f[u]>>mx&1;++mx);\n\tf[u]=(f[u]>>mx|1)<<mx;\n\tans=max(ans,mx);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\tg[x].push_back(y); g[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define SF scanf\n#define PF printf\n#define MAXN 100010\nusing namespace std;\nint n,u,v,ans;\nvector<int> a[MAXN];\nint bit[MAXN],f[MAXN];\nvoid dfs(int x,int fa){\n\tint l=0;\n\tfor(int i=0;i<int(a[x].size());i++){\n\t\tint u=a[x][i];\n\t\tif(u==fa)\n\t\t\tcontinue;\n\t\tdfs(u,x);\n\t\tl|=(bit[x]&bit[u]);\n\t\tbit[x]|=bit[u];\n\t}\n\tif(bit[x]==0)\n\t\tbit[x]=1;\n\telse{\n\t\twhile((1<<f[x])<l||(1<<f[x])&bit[x])\n\t\t\tf[x]++;\n\t\tbit[x]=(bit[x]/(1<<f[x])*(1<<f[x]))|(1<<f[x]);\n\t}\n\tans=max(ans,f[x]);\n}\nint main(){\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tSF(\"%d%d\",&u,&v);\t\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\tdfs(1,0);\n\tPF(\"%d\",ans);\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\n\nint dp[MAXn], dp2[MAXn];\nvector<int> g[MAXn];\n//dp1 halati ke v ro joz raas speciala bezarim\n//dp2 halati ke v joz raas special ha nabashe va lozomn be yekishon motasel bashem\n//dp3 maximum dp2 haye motasel be v\nvoid dfs(int v, int par) {\n\tint mx = 0;\n\tvector<int> vec;\n\tif (g[v].size() == 1 && par)\n\t\treturn;\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tdfs(g[v][i], v);\n\t\t\tdp2[v] = max(dp2[v], dp[g[v][i]]);\n\t\t\tvec.push_back(dp[g[v][i]]);\n\t\t}\n\t\n\tdp[v] = dp2[v] + 1;\n\tif ((g[v].size() == 1 && !par) || (par && g[v].size() == 2)) {\n\t\tfor (int i = 0; i < g[v].size(); i++)\n\t\t\tif (g[v][i] != par) {\n\t\t\t\tdp[v] = min(dp[v], max(1, dp[g[v][i]]));\n\t\t\t}\n\t}\n\n}\n\n//void dfs2(int v, int par, int ans) {\n//\tmulti_set<int> st;\n//\tst.insert(ans);\n//\tfor (int i = 0; i < g[v].size(); i++)\n//\t\tif (g[v][i] != par)\n//\t\t\tst.insert(dp[g[v][i]]);\n//\tfor (int i = 0; i < g[v].size(); i++)\n//\t\tif (g[v][i] != par) {\n//\t\t\tdfs(g[v][i], v);\n//\t\t\tdp2[v] = max(dp2[v], dp[g[v][i]]);\n//\t\t\tvec.push_back(dp[g[v][i]]);\n//\t\t}\n//\t\n//\t\n//}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tcout << dp[1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<int> label;\n\nint dfs_init(int node, int par) {\n    int mask = 0, beat = 0;\n    for (auto vec : graph[node]) {\n        if (vec == par) continue;\n        int now = dfs_init(vec, node);\n        beat |= (mask & now);\n        mask |= now;\n    }\n    int need = 32 - __builtin_ctz(beat);\n    mask |= (1 << need) - 1;\n    label[node] = __builtin_ctz(~mask);\n    mask ^= (2 << label[node]) - 1;\n    return mask;\n}\n\nint main() {\n    int n; cin >> n;\n    label.resize(n);\n    graph.resize(n);\n    for (int i = 1; i < n; ++i) {\n        int a, b; cin >> a >> b;\n        graph[a - 1].push_back(b - 1);\n        graph[b - 1].push_back(a - 1);\n    }\n    dfs_init(0, -1);\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        res = max(res, label[i]);\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\n#include <numeric>\nusing namespace std;\ntypedef unsigned long long int ulint;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=(int)1e9+7;\nconst llint big=(llint)44e15;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else{return gcd(b,a%b);}}\nllint lcm(llint a,llint b){return a/gcd(a,b) *b;}\ntemplate<class T,class U> auto LB(T& ve,U in){return lower_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto UB(T& ve,U in){return upper_bound(ve.begin(),ve.end(),in);}\ntemplate<class T,class U> auto LBI(T& ve,U in){return LB(ve,in)-ve.begin();}\ntemplate<class T,class U> auto UBI(T& ve,U in){return UB(ve,in)-ve.begin();}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nint main(void){\n\tint n,i;cin>>n;\n\tvector<vector<int>> go(n);\n\t//どうせ直径logなんでしょ\n\tfor(i=0;i<n-1;i++){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tgo[a].pub(b);\n\t\tgo[b].pub(a);\n\t}\n\tqueue<int>que;que.push(0);\n\tvector<int>dis(n,mod);dis[0]=0;\n\twhile(que.size()>0){\n\t\tint ter=que.front();\n\t\tque.pop();\n\t\tfor(auto it:go[ter]){\n\t\t\tif(dis[it]!=mod){continue;}\n\t\t\tdis[it]=dis[ter]+1;que.push(it);\n\t\t}\n\t}\n\tint bas=0,sai=0;\n\tfor(i=0;i<n;i++){if(maxeq(sai,dis[i])){bas=i;}}\n\tque.push(bas);\n\tfor(i=0;i<n;i++){dis[i]=mod;}dis[bas]=0;\n\twhile(que.size()>0){\n\t\tint ter=que.front();\n\t\tque.pop();\n\t\tfor(auto it:go[ter]){\n\t\t\tif(dis[it]!=mod){continue;}\n\t\t\tdis[it]=dis[ter]+1;que.push(it);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){if(maxeq(sai,dis[i])){bas=i;}}\n\t//saiは木の直径\n\tsai++;\n\t//cerr<<sai<<endl;\n\tint ans=0;\n\twhile((1<<ans)<=sai){ans++;}\n\tcout<<ans-1<<endl;RE;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nint n, mxv, mxd, par[MAXN];\nvector<int> Mat[MAXN];\nbool del[MAXN];\n\nvoid dfs(int v, int p, int d) {\n\tpar[v] = p;\n\tif (mxd < d)\n\t\tmxd = d, mxv = v;\n\tfor (int i = 0; i < Mat[v].size(); i++)\n\t\tif (Mat[v][i] != p && !del[Mat[v][i]])\n\t\t\tdfs(Mat[v][i], v, d + 1);\n}\n\nint getr(int v, int d) {\n\tfor (int i = 0; i < d / 2; i++)\n\t\tv = par[v];\n\treturn v;\n}\n\nint getans(int v) {\n\tdel[v] = 1;\n\tint mxne = 0, mxnev = -1, mxnee = 0;\n\tfor (int i = 0; i < Mat[v].size(); i++) {\n\t\tif (del[Mat[v][i]])\n\t\t\tcontinue;\n\t\tmxd = -1, mxv = 0;\n\t\tdfs(Mat[v][i], Mat[v][i], 0);\n\t\tmxd = -1;\n\t\tdfs(mxv, mxv, 0);\n\t\tint root = getr(mxv, mxd);\n\t\tif (mxnev < mxd)\n\t\t\tmxnev = mxd, mxne = root, mxnee = par[root];\n\t}\n\tif (mxnev == -1)\n\t\treturn 0;\n\tint k = 1e9;\n\tif (mxnev % 2 == 1) {\n\t\tk = getans(mxne) + 1;\n\t\tk = min(k, getans(mxnee) + 1);\n\t} \n\telse\n\t\tk = getans(mxne) + 1;\n\tdel[v] = 0;\n\treturn k;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tMat[a].push_back(b);\n\t\tMat[b].push_back(a);\n\t}\n\tmxv = 1;\n\tdfs(1, 1, 0);\n\tmxd = -1;\n\tdfs(mxv, mxv, 0);\n\tint root = getr(mxv, mxd);\n\tint pt = par[root];\n\tif (mxd % 2 == 0)\n\t\tcout << getans(root);\n\telse\n\t\tcout << min(getans(root), getans(pt));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 100100;\nconst int K = 20;\n\nvector<int> g[N];\nvector<pii> dp[N];\nvector<pii> a[K];\nint n;\n\nvoid dfs(int v, int par)\n{\n    int d = 0;\n    for (int u : g[v])\n    {\n        if (u == par) continue;\n        dfs(u, v);\n        d = max(d, dp[u][0].second);\n    }\n    for (int i = 0; i < K; i++)\n        a[i].clear();\n    for (int u : g[v])\n        if (u != par)\n            a[dp[u][0].second].push_back(mp(u, 0));\n//    printf(\"solving %d\\n\", v);\n    int goodLen = 0;\n    int goodD = d + 1;\n    while(true)\n    {\n//        printf(\"d = %d\\n\", d);\n        if (d < 0)\n        {\n            break;\n        }\n        if (a[d].empty())\n        {\n            while(d > 0 && a[d - 1].empty()) d--;\n            goodLen = dp[v].size();\n            goodD = d;\n            d--;\n            continue;\n        }\n        if ((int)a[d].size() >= 2)\n        {\n            break;\n        }\n        int u = a[d][0].first;\n        int p = a[d][0].second;\n//        printf(\"%d %d\\n\", u, p);\n        dp[v].push_back(dp[u][p]);\n        p++;\n        if (p < (int)dp[u].size())\n            a[dp[u][p].second].push_back(mp(u, p));\n        d--;\n    }\n    while((int)dp[v].size() > goodLen) dp[v].pop_back();\n    dp[v].push_back(mp(v, goodD));\n    return;\n}\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++)\n    {\n        int v, u;\n        scanf(\"%d%d\", &v, &u);\n        v--;u--;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(0, -1);\n    printf(\"%d\\n\", dp[0][0].second);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=100000+10;\nint h[maxn],go[maxn*2],nxt[maxn*2],bit[maxn],f[maxn];\nint i,j,k,l,t,n,m,tot,top,ans;\nvoid add(int x,int y){\n    go[++tot]=y;\n    nxt[tot]=h[x];\n    h[x]=tot;\n}\nvoid dfs(int x,int y){\n    bit[x]=f[x]=0;\n    int t=h[x],l=0;\n    while (t){\n        if (go[t]!=y){\n            dfs(go[t],x);\n            l=max(l,(bit[x]&bit[go[t]]));\n            bit[x]|=bit[go[t]];\n        }\n        t=nxt[t];\n    }\n    if (!bit[x]) bit[x]=1;\n    else{\n        while ((1<<f[x])<=l||(1<<f[x])&bit[x]) f[x]++;\n        bit[x]=(bit[x]>>f[x]<<f[x])|(1<<f[x]);\n    }\n    ans=max(ans,f[x]);\n}\nint main(){\n    scanf(\"%d\",&n);\n    fo(i,1,n-1){\n        scanf(\"%d%d\",&j,&k);\n        add(j,k);add(k,j);\n    }\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int64> vi;\n\nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\nconst int maxn = 100000 + 10;\n\nvi adj[maxn];\n\nint dfs(int s, int p){\n\tint vis = 0, two = 0;\n\n\tfor (int i = 0; i < (int)adj[s].size(); ++i){\n\t\tint u = adj[s][i]; if (u == p) continue;\n\t\tint tree = dfs(u, s);\n\n\t\ttwo |= tree & vis;\n\t\tvis |= tree;\n\t}\n\n\tif (two)\n\t\ttwo |= (1 << __lg(two)) - 1;\n\n\tint tmp = ~two & ~vis;\n\tint me = tmp & -tmp;\n\tvis |= me;\n\tvis &= ~( me - 1 );\n\n\treturn vis;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\n\tfor (int i = 1; i < n; ++i){\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tint ans = dfs(1, 1);\n\tcout << __lg(ans) << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* Bismillahir Rahmanir Rahim */\n\n#include <bits/stdc++.h>\n\n#define rep(i, n)\tfor(int i=0;i<n;i++)\n#define repn(i, n)\tfor(int i=1;i<=n;i++)\n#define set(i, n)\tmemset(i, n, sizeof(i))\n\n#define pb\tpush_back\n#define f\tfirst\n#define s\tsecond\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 100007;\n\nint n, fx;\nvector<int>edge[N];\n\nint dfs(int at, int past){\n\tint mask = 0, cnt[25];\n\tset(cnt, 0);\n\trep(i, edge[at].size()){\n\t\tint u = edge[at][i];\n\t\tif(u == past) continue;\n\t\tint fask = dfs(u, at);\n\t\trep(j, 20){\n\t\t\tif(fask & (1 << j)) cnt[j]++;\n\t\t}\n\t\tmask |= fask;\n\t}\n\tint s = 0;\n\tfor(int i=20;i>=0;i--){\n\t\t if(cnt[i] < 2) continue;\n\t\t s = i + 1;\n\t\t break;\n\t} \n\tfor(int i=s;i<=20;i++){\n\t\tif(cnt[i] == 0){\n\t\t\tfor(int j=0;j<i;j++) if(mask & (1 << j)) mask ^= (1 << j);\n\t\t\tmask |= (1 << i);\n\t\t\treturn mask;\n\t\t}\n\t}\n}\n\nint main(){\n\tint x, y;\n\tscanf(\"%d\", &n);\n\trepn(i, n-1){\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tint ret = dfs(1, 1);\n\tfor(int i=20;i>=0;i--){\n\t\tif(ret & (1 << i)){\n\t\t\tprintf(\"%d\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5, LG = 20;\nint ans = 0;\n\nvector <int> adj[N];\nint dp[N];\nint cnt[N][LG];\nbool mark[N];\n\nint get(int x, int y) {\n\treturn (x >> y) & 1;\n}\n\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto u : adj[v]) {\n\t\tif (!mark[u]) {\n\t\t\tdfs(u);\n\t\t\tdp[v] |= dp[u];\n\t\t\tfor (int i = 0; i < LG; i++) {\n\t\t\t\tif (get(dp[u], i)) {\n\t\t\t\t\tcnt[v][i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint x = -1;\n\tfor (int i = 0; i < LG; i++) {\n\t\tif (cnt[v][i] > 1) {\n\t\t\tx = i;\n\t\t}\n\t}\n\tx++;\n\twhile (cnt[v][x]) {\n\t\tx++;\n\t}\n\tans = max(ans, x);\n\tfor (int i = 0; i < x; i++) {\n\t\tdp[v] &= (1 << LG) - 1 - (1 << i);\n\t}\n\tdp[v] |= (1 << x);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tdfs(1);\n\tcout << ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (!isdigit(ch)&&ch!='-')\n\t\tch=getchar();\n\tif (ch=='-')\n\t\tf=-1,ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x*f;\n}\nint n;\nvector <int> e[N];\nint Log[N],ans=0,f[N];\nvoid solve(int x,int pre){\n\tint t=0;\n\tfor (auto y : e[x])\n\t\tif (y!=pre){\n\t\t\tsolve(y,x);\n\t\t\tt|=f[x]&f[y];\n\t\t\tf[x]|=f[y];\n\t\t}\n\tf[x]^=t;\n\tint k=t?Log[t]+1:0;\n\twhile (k<30&&(f[x]>>k&1))\n\t\tk++;\n\tans=max(ans,k);\n\tf[x]|=1<<k;\n\tf[x]&=~((1<<k)-1);\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t\te[i].clear();\n\tfor (int i=1;i<n;i++){\n\t\tint a=read(),b=read();\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tLog[1]=0;\n\tfor (int i=2;i<=n;i++)\n\t\tLog[i]=Log[i>>1]+1;\n\tsolve(1,0);\n\tcout << ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\n//#define DEBUG\n\nint N;\nvector <int> adjList[100005];\n\nint k;\nint getMaxK(int u, int prevP)\n{\n    if (u != 1 && adjList[u].size() == 1) return 1;\n    vector <int> labels;\n    for (int v : adjList[u])\n    {\n        if (prevP == v) continue;\n        labels.push_back(getMaxK(v, u));\n    }\n\n    #ifdef DEBUG\n    printf(\"%d:\", u);\n    for (int label : labels)\n    {\n        printf(\" %s\", bitset<3>(label).to_string().c_str());\n    }\n    printf(\"\\n\");\n    #endif // DEBUG\n\n    bool found = false;\n    int closestZero;\n    for (int k = 20; k >= 0 && !found; k--)\n    {\n        bool allZero = true;\n        bool hasOne = false;\n        for (int label : labels)\n        {\n            if (label & (1 << k))\n            {\n                allZero = false;\n                if (hasOne)\n                {\n                    found = true;\n                    break;\n                }\n                else\n                {\n                    hasOne = true;\n                }\n            }\n        }\n        if (allZero) closestZero = k;\n    }\n    k = max(k, closestZero);\n    int resLabel = 0;\n    for (int label : labels) resLabel |= label;\n    resLabel &= ~((1 << closestZero) - 1);\n    resLabel |= (1 << closestZero);\n    return resLabel;\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    for (int i = 1; i < N; i++)\n    {\n        int a, b; scanf(\"%d%d\", &a, &b);\n        adjList[a].push_back(b), adjList[b].push_back(a);\n    }\n    int label = getMaxK(1, -1);\n    k = max(k, (int) log2(label & -label));\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<vector<int> > adj, chd;\n\nvoid dfs(int u, int p) {\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        chd[u].push_back(v);\n        dfs(v, u);\n    }\n}\n\nint cc[100010];\nint dp(int u) {\n    int &ret = cc[u];\n    if(ret != -1) return ret;\n\n    vector<int> cnt(20, 0);\n    int mask = 0;\n    for(int i = 0; i < chd[u].size(); i++) {\n        int v = chd[u][i];\n\n        int nmask = dp(v);\n        for(int j = 0; j < 20; j++) {\n            if(nmask & (1 << j)) cnt[j]++;\n        }\n        mask |= nmask;\n    }\n\n    for(int i = 20; i--;) {\n        if(cnt[i] > 1) {\n            for(int j = i + 1; j < 20; j++) {\n                if(mask & (1 << j)) continue;\n                return ret = (mask | (1 << j)) & ((1 << 20) - (1 << j));\n            }\n        }\n    }\n    for(int i = 0; i < 20; i++) {\n        if(mask & (1 << i)) continue;\n        return ret = (mask | (1 << i)) & ((1 << 20) - (1 << i));\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    chd.resize(N);\n    dfs(0, -1);\n\n    memset(cc, -1, sizeof(cc));\n    int mask = dp(0);\n    for(int i = 20; i >= 0; i--) {\n        if(mask & (1 << i)) {\n            printf(\"%d\", i);\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 50000000;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q--) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t\t\n\t\tif (clock() > 1960)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ANS + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\t\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nstruct edge\n{\n\tint to;\n\tint next;\n}e[666666];\nint pe=222222;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n}\nint f[222222],g[222222];\nint top[555555];\nvoid dfs(int o,int fa)\n{\n\tint s=0;\n\tint min=-1;\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)\n\t\t{\n\t\t\tdfs(e[p].to,o);\n\t\t\tcmax(min,top[s&g[e[p].to]]);\n\t\t\ts|=g[e[p].to];\n\t\t}\n\tfor(register int i=min+1;i<=20;++i)\n\t\tif(!(s&1<<i)){f[o]=i;break;}\n\tg[o]=1<<f[o];\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)g[o]|=g[e[p].to]&~((1<<f[o])-1);\n}\nint main()\n{\n\tfreopen(\"tdc.in\",\"r\",stdin);\n\tfreopen(\"tdc.out\",\"w\",stdout);\n\ttop[0]=-1;\n\tfor(register int i=2;i<=524287;++i)\n\t\ttop[i]=top[i>>1]+1;\n\tif(1)\n\t{\n\t\tint n=io::F();\n\t\tif(n==0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(register int i=1;i<n;++i)\n\t\t{\n\t\t\tint x=io::F(),y=io::F();\n\t\t\tinsert(x,y);\n\t\t\tinsert(y,x);\n\t\t}\n\t\tdfs(1,0);\n\t\tint max=0;\n\t\tfor(register int i=1;i<=n;++i)cmax(max,f[i]);\n\t\tprintf(\"%d\\n\",max);\n\t\tpe=222222;\n\t\tfor(register int i=1;i<=n;++i)e[i].next=0;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntemplate<typename T> inline void chkmin(T &a, const T &b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T &a, const T &b) { a = a > b ? a : b; }\n\nconst int MAXN = 100005, B = 20;\nvector<int> gra[MAXN];\nint f[MAXN][B], n, ans;\n\nvoid dfs(int u, int fa) {\n\tfor (int v : gra[u]) if (v != fa) {\n\t\tdfs(v, u);\n\t\tfor (int i = 0; i < B; i++)\n\t\t\tf[u][i] += f[v][i];\n\t}\n\tint p = 0;\n\tfor (int i = B - 1; ~i; i--)\n\t\tif (f[u][i] > 1) { p = i; break; }\n\twhile (f[u][p]) ++p;\n\tf[u][p] = 1;\n\tfor (int i = 0; i < p; i++) f[u][i] = 0;\n\tchkmax(ans, p);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tgra[u].push_back(v), gra[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_LG = 20;\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N];\nint mask [MAX_N];\n\nvoid dfs (int u, int p) {\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      dfs(nxt, u);\n      mask[u] |= mask[nxt];\n    }\n  }\n  mask[u]++;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  dfs(1, 0);\n\n  cout << 31 - __builtin_clz(mask[1]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n#define INT long long\n#define MOD 1000000007\nusing namespace std;\nINT n, d, unido[100010] = {0, 1, 1};\nvector<INT> g[100010];\nint solve(int x)\n{\n    int chk[100010] = {0};\n    int ret = x;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        ret = v;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return ret;\n}\nint f(int x, int y)\n{\n    int chk[100010] = {0};\n    int ret = 0;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        if( v == y ) return chk[v]-1;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n;\n    for(int i = 1 ; i < n ; i++ )\n    {\n        INT a, b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int v = solve(1);\n    int w = solve(v);\n    int d = f(v, w);\n    for(int i = 3 ; i <= d ; i++ )\n        unido[i] = unido[(i-1)/2] + 1;\n    cout<<unido[d]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint n;\nvector<int> g[100005];\nint lsb(int a){\n  return __builtin_ctz(a);\n}\nint dfs(int v,int p){\n  int mask=0,incr=-1;\n  for(auto to:g[v]){\n    if(to==p) continue;\n    int tmp=dfs(to,v);\n    if(tmp&mask) chmax(incr,lsb(tmp&mask));\n    mask|=tmp;\n  }\n  for(int i=max(0,incr);;++i) if(!(mask>>i&1)){\n    mask|=(1<<i);\n    if(~incr) mask&=~((1<<i)-1);\n    break;\n  }\n  return mask;\n}\n\n\nint main(){\n  cin>>n;\n  REP(i,n-1){\n    int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n  int res=dfs(0,-1);\n  int ans=0;\n  REP(i,20) if(res>>i&1) ans=i;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nvector<int> v[100005];\npii dfs(int x,int f){\n    pii p=mp(0,x);\n    for(auto it:v[x]){\n        if(it!=f){\n            p=max(p,dfs(it,x));\n        }\n    }\n    p.x++;\n    return p;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 1;i<n;i++){\n        int x,y;\n        scanf(\"%d %d\",&x,&y);\n        v[x].pb(y);\n        v[y].pb(x);\n    }\n    int dp[105];\n    pii p=dfs(dfs(1,0).y,0);\n    dp[0]=1;\n    for(int i = 1;;i++){\n        dp[i]=dp[i-1]*2+1;\n        if(dp[i]>=p.x){\n            printf(\"%d\\n\",i);\n            break;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#define PR pair\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n#define REP(i, x, y)   for(int i = (int)(x); i <= (int)(y); i++)\n#define FOR(i, x, y)   for(int i = (int)(x); i <  (int)(y); i++)\n#define PER(i ,x, y)   for(int i = (int)(x); i >= (int)(y); i--)\n#define CH\t         ch = getchar()\n#define Exit(...)    printf(__VA_ARGS__), exit(0)\n#define dln()        fprintf(stderr,\"\\n\")\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef double\t  db;\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<VI > VII;\ntypedef PR<int,int> PII;\ntypedef vector<PII> VPI;\nconst\tint inf=2e9;\nconst\tLL Inf=1e10;\nconst\tint P=1e9+7;\nconst\tint N=100005;\n\ninline LL IN(){\n\tLL x = 0;\n\tint ch = 0, f = 0;\n\tfor (CH; ch != -1 && (ch < 48 || ch > 57); CH) f = (ch == '-');\n\tfor (; ch >= 48 && ch <= 57; CH) x = (x << 1) + (x << 3) + ch - '0';\n\treturn f ? (-x) : x;\n}\ntemplate<typename T> inline int chkmin(T &a, const T &b){if(b < a) return a = b, 1; return 0;}\ntemplate<typename T> inline int chkmax(T &a, const T &b){if(b > a) return a = b, 1; return 0;}\n\nvoid renew(int &x, const int &y){\n\tx += y;\n\tif(x >= P) x -= P;\n\tif(x <  0) x += P;\n}\n\nint Pow(int x, int y, int p){\n\tint a = 1;\n\tfor (; y; y >>= 1, x = (LL)x * x %p) if(y & 1) a=(LL)a * x%p;\n\treturn a;\n}\n\nint Msk[31];\nint Max[N << 2], Mex[N << 2];\nint n, a[N];\nstruct edge{\n\tint v, pre;\n}e[N << 1]; int dex, adj[N], fa[N], dp[N];\nint maxlab = 0, U;\n\nint ans;\nvoid dfs(int x){\n\tint s = 0, t = 0;\n\tfor(int i = adj[x]; i; i = e[i].pre){\n\t\tint v = e[i].v;\n\t\tif(v == fa[x]) continue;\n\t\tfa[v] = x;\n\t\tdfs(v);\n\t\tt |= (dp[v] & s);\n\t\ts |= dp[v];\n\t}\n\tint lab = Mex[s | Max[t]];\n\tdp[x] = s & Msk[lab];\n\tdp[x] |= 1 << lab;\n\tans = max(ans, lab);\n}\n\nvoid prebitcalc(){\n\tfor(int m = n; m; ){\n\t\tm >>= 1;\n\t\tmaxlab ++;\n\t}\n\tU = 1 << maxlab;\n\tU --;\n\tmemset(Max, -1, sizeof Max);\n\tREP(i, 0, maxlab) Max[(1 << i) - 1] = (1 << i) - 1;\n\tPER(i, U, 0) if(Max[i] < 0) Max[i] = Max[i + 1];\n\tREP(i, 0, maxlab) Msk[i] = (U >> i) << i;\n\tMex[0] = 0;\n\tMex[1] = 1;\n\tREP(i, 1, U) if(!(i & 1)) Mex[i] = 0; else Mex[i] = Mex[i >> 1] + 1;\n\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tprebitcalc();\n\tREP(i, 1, n - 1){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\te[++dex] = (edge){y, adj[x]}; adj[x] = dex;\n\t\te[++dex] = (edge){x, adj[y]}; adj[y] = dex;\n\t}\n\tdfs(1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint val[100005];\nvector<int> adj[100005];\nvoid DFS(int v, int p){\n\tval[v] = 0;\n\tfor (int j: adj[v]){\n\t\tif (j != p){\n\t\t\tDFS(j, v);\n\t\t\tint k = val[j];\n\t\t\tfor (int i = 0; i < 20; i++){\n\t\t\t\tif (val[v] & (1<<i)){\n\t\t\t\t\tif (k&(1<<i)){\n\t\t\t\t\t\tval[v] |= ((1<<(i+1)) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tval[v] |= (k&(1<<i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tval[v]++;\n}\n\nint main(){\n\tint N; cin >> N;\n\tfor (int i = 0; i < N - 1; i++){\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tDFS(1, 0);\n\tint lg = 0;\n\twhile (val[1]/2){\n\t\tval[1] /= 2;\n\t\tlg++;\n\t}\n\tcout << lg << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n = num_in<int>();\n    vector<vector<int>> adj(n);\n    for (int _ : in(n - 1)) {\n        int a = num_in<int>() - 1, b = num_in<int>() - 1;\n        adj[a].emplace_back(b);\n        adj[b].emplace_back(a);\n    }\n    const int LOGN = 18;\n    function<int(int, int)> dfs = [&](int cur, int par)-> int {\n        vector<int> count(LOGN);\n        for (int nxt : adj[cur]) {\n            if (nxt == par) continue;\n            int ret = dfs(nxt, cur);\n            for (int i : in(LOGN))\n                if ((ret & (1 << i)) != 0)\n                    count[i] += 1;\n        }\n        int lower = [&]()-> int {\n            for (int i : in(LOGN).rev()) {\n                if (count[i] >= 2) {\n                    for (int j : in(i, LOGN)) \n                        if (count[j] == 0)\n                            return j;\n                }\n            }\n            return 0;\n        }();\n        int res = 1 << lower;\n        for (int i : in(lower + 1, LOGN))\n            if (count[i] == 1)\n                res |= 1 << i;\n        return res;\n    };\n    int val = dfs(0, -1);\n    int ans = [&]()->int {\n        for (int i : in(LOGN).rev()) \n            if ((val & (1 << i)) != 0)\n                return i + 1;\n        assert(0);\n    }();\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nconst int m = 4000;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint n; cin >> n;\n\tvvel way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(b);\n\t\tway[b].push_back(a);\n\t}\n\tint u = most_far(0, n, way).second;\n\tint cho = most_far(u, n, way).first;\n\tint ans = 0;\n\twhile (cho > 0) {\n\t\tans++;\n\t\tif (cho % 2 == 0) { cho = cho / 2; cho--; }\n\t\telse { cho = cho / 2; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=11e4,M=N<<1;\n\nint f[N],fa[N];\nint ne[M],lb[M],la[N];\nint n,oo;\n\ninline void llb(int a,int b)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b;}\n \ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+ch-48;\n\treturn o;\n} \n\nvoid dfs(int o)\n{\n\tint u=0;\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o,dfs(lb[y]);\n\t\tu|=(f[o]&f[lb[y]]);\n\t\tf[o]|=f[lb[y]];\n\t}\n\tint k=1;\n\twhile(k<=u||(f[o]&k)>0)f[o]^=(k&f[o]),k<<=1;\n\tf[o]^=k;\n}\n\nint main()\n{\n\tcin>>n; int a,b;\n\tfo(i,1,n-1)a=read(),b=read(),llb(a,b),llb(b,a);\n\tfa[1]=-1; dfs(1);\n\tint k=1,p=0;\n\twhile(k<=f[1])k<<=1,++p;\n\tcout<<p-1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\nint las[N],vis[N],fa[N];\nint n,cnt,mx,w,ans;\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid dfs(int x,int d){\n\tif (d>mx) mx=d,w=x;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]&&y!=fa[x]){\n\t\t\tfa[y]=x;\n\t\t\tdfs(y,d+1);\n\t\t}\n}\nint cal(int x){\n\tint ans=0;\n\tvis[x]=1;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]){\n\t\t\tmx=-1;fa[y]=0;\n\t\t\tdfs(y,0);\n\t\t\tmx=-1;fa[w]=0;\n\t\t\tdfs(w,0);\n\t\t\tans=max(ans,mx);\n\t\t}\n\tvis[x]=0;\n\treturn ans;\n}\nvoid solve(int x,int dep){\n\tans=max(ans,dep);\n\tmx=-1;fa[x]=0;\n\tdfs(x,0);\n\tmx=-1;fa[w]=0;\n\tdfs(w,0);\n\tx=w;\n\tFor(i,0,mx/2) x=fa[x];\n\tint u=fa[x];\n\tif (mx%2==1&&cal(u)<cal(x)) x=u;\n\tvis[x]=1;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]){\n\t\t\tsolve(y,dep+1);\n\t\t}\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n) Link(IN(),IN());\n\tsolve(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\n\ninline int read()\n{\n\tint sc = 0; char ch = getchar();\n\twhile( ch < '0' || ch > '9' ) ch = getchar();\n\twhile( ch >= '0' && ch <= '9' ) sc = sc * 10 + ch - '0', ch = getchar();\n\treturn sc;\n}\n\nconst int MAXN = 100010;\n\nvector < int > G[MAXN];\nint f[MAXN], n;\n\ninline void dfs(int x, int fa)\n{\n\tfor( auto y : G[ x ] ) if( y ^ fa ) dfs( y, x );\n\tint d = 20;\n\tfor( ; ~d ; d-- )\n\t{\n\t\tint c = 0;\n\t\tfor( auto y : G[ x ] ) if( y ^ fa ) if( f[ y ] >> d & 1 ) c++;\n\t\tif( c >= 2 ) { f[ x ] += 1 << d + 1; break; }\n\t\telse if( c == 1 ) f[ x ] |= 1 << d;\n\t}\n\tif( d == -1 ) f[ x ]++;\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tscanf( \"%d\", &n );\n\tfor( int i = 1, x, y ; i < n ; i++ ) scanf( \"%d%d\", &x, &y ), G[ x ].pb( y ), G[ y ].pb( x );\n\tdfs( 1, 0 );\n\tint ret = 0;\n\twhile( ( 1 << ret + 1 ) <= f[ 1 ] ) ret++;\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nvector<int> adj[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\nconst int MAX_LOG = 20;\n\nint f[MAX_LOG + 1][MAXN + 5];\n\nint ans = 0;\n\ninline void dfs(int u, int fa)\n{\n\tfor(auto v : adj[u]) if(v != fa)\n\t{\n\t\tdfs(v, u);\n\t\tfor(int i = 0; i <= MAX_LOG; ++i) f[u][i] += f[v][i];\n\t}\n\n\tint k = 0;\n\tfor(int i = MAX_LOG; i >= 0; --i) if(f[u][i] >= 2) { k = i + 1; break; }\n\twhile(f[u][k] == 1) ++k;\n\n\tchkmax(ans, k), ++f[u][k];\n\tfor(int i = 0; i < k; ++i) f[u][i] = 0;\n}\n\ninline void solve()\n{\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 100005;\nconst int KMAX = 30;\n\nvector<int> G[NMAX];\n\narray<int, KMAX> dfs(int node, int prev) {\n    array<int, KMAX> ret;\n    fill(ret.begin(), ret.end(), 0);\n    ret[0] = 1;\n    for (int to: G[node]) {\n        if (to != prev) {\n            array<int, KMAX> son = dfs(to, node);\n            for (int i = 0; i < KMAX; ++i) {\n                ret[i] += son[i];\n            }\n        }\n    }\n    for (int i = 0; i < KMAX; ++i) {\n        if (ret[i] > 1) {\n            ret[i] = 0;\n            ret[i + 1]++;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    array<int, KMAX> ans = dfs(1, -1);\n    int fans = 0;\n    for (int i = 0; i < KMAX; ++i) {\n        if (ans[i] > 0) {\n            fans = i;\n        }\n    }\n    cout << fans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    {\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++) assert(used[i]);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      //if(!used[i]&&belong[i]<0) exit(0);\n      if(!used[i]&&cnt[i]<1) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 100010;\n\nstd::vector <int> e[N];\nint ans[N], sz[N], sum, min, minsit;\nbool vis[N];\n\nvoid precalc(int u, int fa){\n\tsz[u] = 1;\n\tfor (auto v : e[u]){\n\t\tif (vis[v] || v == fa) continue;\n\t\tprecalc(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nvoid dfs1(int u, int fa, int sum){\n\tint max = 0, ssum = sum;\n\tfor (auto v : e[u]){\n\t\tif (vis[v] || v == fa) continue;\n\t\tdfs1(v, u, sum);\n\t\tssum -= sz[v];\n\t\tmax = std::max(max, sz[v]);\n\t}\n\tmax = std::max(max, ssum - 1);\n\tif (max < min){\n\t\tmin = max;\n\t\tminsit = u;\n\t}\n}\n\nvoid dfs(int u){\n\tprecalc(u, 0);\n\tif (sz[u] == 1) return;\n\tmin = INT_MAX;\n\tdfs1(u, 0, sz[u]);\n\tvis[minsit] = true;\n\tfor (auto v : e[minsit]){\n\t\tif (vis[v]) continue;\n\t\tdfs(v);\n\t\tans[minsit] = std::max(ans[minsit], ans[v]);\n\t}\n\t++ ans[minsit];\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0, u, v; i < n - 1; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1);\n\tint max = 0;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tmax = std::max(max, ans[i]);\n\t}\n\tprintf(\"%d\\n\", max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, f[505000], g[22];\nvector<int>G[505000];\n\nint mg(int x,int y){\n  for (int t;t=(x&y);){\n    x+=t&-t;\n  }\n  return min(10001000,x|y);\n}\n\nvoid dfs(int x,int fff){\n  for (auto y:G[x])\n    if (y!=fff)\n      dfs(y,x);\n  memset(g,0,sizeof g);\n  for (auto y:G[x])\n    if (y!=fff){\n      for (int i=0;i<=20;++i){\n\tint tmp=f[y]>>i<<i;\n\tif (tmp>>i&1) tmp+=1<<i;\n\tg[i]=mg(g[i],tmp);\n      }\n    }\n  f[x]=998244353;\n  for (int i=0;i<=20;++i)\n    f[x]=min(f[x],g[i]|1<<i);\n}\n\nint main(){\n  cin>>n; int x, y;\n  for (int tim=n-1;tim--;){\n    cin>>x>>y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  dfs(1,0);\n  int ans=0;\n  for (int t=f[1];t;t>>=1) ++ans;\n  cout<<ans-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nset<int> S[MAX_N];\nvector<int> G[MAX_N];\nint cnt[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\tcnt[a]++;\n\t\tcnt[b]++;\n\t}\n\tqueue<int> que;\n\trep(i, 0, N) {\n\t\tif(cnt[i] == 1) que.push(i);\n\t}\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tint at = 0;\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] != 0) continue;\n\t\t\tif(sz(S[n]) > sz(S[v])) swap(S[n], S[v]);\n\t\t\tfor(auto d : S[n]) {\n\t\t\t\tif(S[v].count(d)) {\n\t\t\t\t\twhile((*(S[v].begin())) != d) S[v].erase(S[v].begin());\n\t\t\t\t\tat = d;\n\t\t\t\t}\n\t\t\t\telse S[v].insert(d);\n\t\t\t}\n\t\t}\n\t\twhile(!S[v].empty() && (*(S[v].begin())) == at) {\n\t\t\tS[v].erase(S[v].begin());\n\t\t\tat++;\n\t\t}\n\t\tS[v].insert(at);\n\t\tMAX(ans, at);\n\n\t\t// debug(v, vi(all(S[v])));\n\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] == 0) continue;\n\t\t\tcnt[n]--;\n\t\t\tcnt[v]--;\n\t\t\tif(cnt[n] == 1) que.push(n);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define SZ 666666\n#define S 20\nint fst[SZ],M=0,nxt[SZ],vb[SZ];\nvoid ad_de(int a,int b)\n{\n\t++M; nxt[M]=fst[a]; fst[a]=M; vb[M]=b;\n}\nvoid adde(int a,int b)\n{ad_de(a,b);ad_de(b,a);}\nbool f[100555][S];\nint n,tmp[S];\nvoid dfs(int x,int fa=0)\n{\n\tfor(int e=fst[x];e;e=nxt[e])\n\t{\n\t\tint b=vb[e]; if(b==fa) continue;\n\t\tdfs(b,x);\n\t}\n\tfor(int i=0;i<S;++i) tmp[i]=0;\n\tfor(int e=fst[x];e;e=nxt[e])\n\t{\n\t\tint b=vb[e]; if(b==fa) continue;\n\t\tfor(int j=0;j<S;++j) tmp[j]+=f[b][j];\n\t}\n\t++tmp[0];\n\tfor(int j=0;j<S;++j)\n\t\tif(tmp[j]>=2)\n\t\t\ttmp[j]=0, ++tmp[j+1];\n\tfor(int j=0;j<S;++j)\n\t\tf[x][j]=tmp[j];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(a,b);\n\t}\n\tdfs(1);\n\tfor(int i=S-1;i>=0;--i)\n\t{\n\t\tif(f[1][i])\n\t\t{\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\nint c[MX];\n\nP cfs(int v, int d=0, int p=-1) {\n  P res(d,v);\n  for (int u : to[v]) {\n    if (c[u] || u == p) continue;\n    maxs(res, cfs(u,d+1,v));\n  }\n  return res;\n}\nvi vs;\nbool vfs(int v, int t, int p=-1) {\n  if (v == t) {\n    vs.pb(v);\n    return true;\n  }\n  for (int u : to[v]) {\n    if (c[u] || p == u) continue;\n    if (vfs(u,t,v)) {\n      vs.pb(v);\n      return true;\n    }\n  }\n  return false;\n}\nint dfs(int v) {\n  v = cfs(v).se;\n  P p = cfs(v);\n  vs = vi();\n  vfs(v,p.se);\n  v = vs[(p.fi+rand()%2)/2];\n  c[v] = 1;\n  int res = 0;\n  for (int u : to[v]) {\n    if (c[u]) continue;\n    maxs(res,dfs(u)+1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 101000;\n\nint n, f[N];\n\nstruct Edge\n{\n    int nxt, to;\n} eg[N << 1];\nint head[N], en;\n\nvoid setEdge(int u, int v)\n{\n    eg[++en] = (Edge) {head[u], v};\n    head[u] = en;\n}\n\nvoid dfs(int u, int fa)\n{\n    f[u] = 1;\n    for (int e = head[u]; e; e = eg[e].nxt)\n    {\n        int v = eg[e].to;\n        if (v == fa) continue;\n        dfs(v, u);\n        f[u] += f[v];\n    }\n}\n\nint main()\n{\n    n = read();\n    for (int i = 1; i < n; i++)\n    {\n        int u = read(), v = read();\n        setEdge(u, v);\n        setEdge(v, u);\n    }\n    dfs(1, 0);\n    for (int i = 30; i >= 0; i--)\n        if (f[1] >> i & 1)\n        {\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 100000;\nint N, n;\nvector<int> graph[MAX];\nint label[MAX];\n\nint dfs(int node){\n\tlabel[node] = -1;\n\tint used = 0, more = 0;\n\tfor (int i = 0; i < graph[node].size(); ++i){\n\t\tint next = graph[node][i];\n\t\tif (!label[next]){\n\t\t\tint next_used = dfs(next);\n\t\t\tmore |= used & next_used;\n\t\t\tused |= next_used;\n\t\t}\n\t}\n\n\tmore |= more >> 1;\n\tmore |= more >> 2;\n\tmore |= more >> 4;\n\tmore |= more >> 8;\n\tmore |= more >> 16;\n\t++more;\n\n\tint possible = (~used) & (-more);\n\tlabel[node] = possible & (-possible);\n\n\tused |= label[node];\n\tused &= -label[node];\n\treturn used;\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; ++i){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--,y--;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\tdfs(0);\n\tint maximum = *max_element(label, label+N), result = 0;\n\twhile (maximum){\n\t\t++result;\n\t\tmaximum >>= 1;\n\t}\n\tprintf(\"%d\\n\", result-1);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n \tmemset(down, 0, sizeof down);\n\tmemset(up, 0, sizeof up);\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = inF, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstatic vector<int> e[2][100000];\n \nint recon(int i,int p,bool b,int &N)\n{\n  //printf(\"%d %d %d\\n\",i,p,N);\n  int t=N;\n  e[!b][t]=vector<int>(0);\n  N++;\n  int S=0;\n  for(int x=0;x<e[b][i].size();x++){\n    if(e[b][e[b][i][x]].size()==1){\n      S++;\n    }\n  }\n  for(int x=0;x<e[b][i].size();x++){\n    int j=e[b][i][x];\n    if(j==p)continue;\n    if(e[b][j].size()==2&&S>=e[b][i].size()-1){\n      int k=(e[b][j][0]==i?e[b][j][1]:e[b][j][0]);\n      int c=recon(k,j,b,N);\n      e[!b][t].push_back(c);\n      e[!b][c].push_back(t);\n    }\n    else if(e[b][j].size()>=2){\n      int c=recon(j,i,b,N);\n      e[!b][t].push_back(c);\n      e[!b][c].push_back(t);\n    }\n  }\n  return t;\n}\n \nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  bool b=0;\n  for(int i=0;i<n-1;i++){\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    u--,v--;\n    e[b][u].push_back(v);\n    e[b][v].push_back(u);\n  }\n  int N=n,t=0;\n  while(N>1){\n    //printf(\"%d\\n\",N);\n    t++;\n    int r;\n    for(int i=0;i<N;i++){\n      if(e[b][i].size()==1){\n\tr=e[b][i][0];\n\tbreak;\n      }\n    }\n    N=0;\n    recon(r,-1,b,N);\n    b=!b;\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Parent[500000], Dist[500000];\nset<int> G[500000];\n\nint DFS(int node, int par, int dist) {\n\tParent[node] = par;\n\tDist[node] = dist;\n\n\tint ret = node;\n\tfor(auto vec : G[node])\n\t\tif(vec != par) \n\t\t\tret = max(ret, DFS(vec, node, dist + 1), [&](int a, int b) {\n\t\t\t\treturn Dist[a] < Dist[b]; \n\t\t\t});\n\t\t\n\treturn ret;\n}\n\nint GetCenter(int node) {\n\tint last = DFS(node, 0, 0);\n\tlast = DFS(last, 0, 0);\n\n\tint d = Dist[last];\n\tfor(int i = 0; i < d / 2; ++i)\n\t\tlast = Parent[last];\n\t\n\tlast = DFS(last, 0, 0);\n\tassert(Dist[last] == (d + 1) / 2);\n\n\treturn last;\n}\n\nint Decomp(int node) {\n\tint cen = GetCenter(node);\n\tfor(auto vec : G[cen]) {\n\t\tG[vec].erase(cen);\n\t}\n\n\tint ans = 0;\n\tfor(auto vec : G[cen])\n\t\tans = max(ans, Decomp(vec) + 1);\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 1; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tG[a].insert(b);\n\t\tG[b].insert(a);\n\t}\n\n\tcout << Decomp(1) << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5+5;\ntypedef long long ll;\nstruct node{\n    int u,v,nxt;\n}edge[N*2];\nint head[N],mcnt;\nvoid add_edge(int u,int v){\n    mcnt++;\n    edge[mcnt].u=u;\n    edge[mcnt].v=v;\n    edge[mcnt].nxt=head[u];\n    head[u]=mcnt;\n}\nint n;\nint ans=0;\nint bit[N];\nint lb[N];\nvoid dfs(int u,int fa){\n    bit[u]=lb[u]=0;\n    int z=0;\n    bool leaf=true;\n    for(int i=head[u];i;i=edge[i].nxt){\n        int v=edge[i].v;\n        if(v==fa)\n            continue;\n        leaf=false;\n        dfs(v,u);\n        z|=(bit[u]&bit[v]);\n        bit[u]|=bit[v];\n    }\n    if(leaf){\n        lb[u]=0;\n        bit[u]=1;\n    }\n    else{\n        while((1<<lb[u])<z||(1<<lb[u])&bit[u])\n            lb[u]++;\n        bit[u]>>=lb[u];\n        bit[u]<<=lb[u];\n        bit[u]|=1<<lb[u];\n    }\n    ans=max(ans,lb[u]);\n}\nint main()\n{\n    //freopen(\"uninity.in\",\"r\",stdin);\n    //freopen(\"uninity.out\",\"w\",stdout);\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add_edge(u,v);\n        add_edge(v,u);\n    }\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n;\nvector<vector<ll>> v(111111);\nll mp[111111];\n\nll dfs(ll s,ll pre){\n\tll ret = 0;\n\tvector<ll> tmp;\n\tREP(i,v[s].size()){\n\t\tif(v[s][i] != pre){\n\t\t\ttmp.PB(dfs(v[s][i],s));\n\t\t\tret |= tmp[tmp.size()-1];\n\t\t}\n\t}\n\t\n\tif(tmp.size() == 0){\n\t\treturn mp[s] = 1;\n\t}\n\tll cou = 60;\n\tfor(;cou > 0;cou--){\n\t\tbool flag = true;\n\t\tREP(i,tmp.size()){\n\t\t\tif(!(tmp[i] & (1LL << cou)))flag = false;\n\t\t}\n\t\tif(flag && tmp.size() > 1)break;\n\t}\n\t\n\tfor(;;cou++){\n\t\tif(!(ret & (1LL <<cou))){\n\t\t\tret |= (1LL << cou);\n\t\t\tret &= ((1LL << 60)-1) - ((1LL << cou) - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn mp[s] = ret;\n}\n\nint main(){\n\t\n\tcin >> n;\n\tREP(i,n-1){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv[a].PB(b);\n\t\tv[b].PB(a);\n\t}\n\t\t\n\tll ans = dfs(0,-1);\n\tfor(ll i = 60;i >= 0;i--){\n\t\tif(ans & (1LL << i)){\n\t\t\tcout << i << endl;\n\t\t\t//return 0;\n\t\t\tbreak;\n\t\t}\n\t}\t\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int len = 1e5+5;\nint block[len], dep[len], sz[len];\nvector<int> adj[len];\n\nvoid fix(int u, int p){\n    sz[u] = 1;\n    for (int j = 0; j < adj[u].size(); j++){\n        int v = adj[u][j];\n        if (!block[v] && v != p)\n            fix(v, u), sz[u] += sz[v];\n    }\n}\n\nii cent(int u, int p, int all){\n    ii ans = mp(all, u);\n    int mx = all-sz[u];\n    for (int j = 0; j < adj[u].size(); j++){\n        int v = adj[u][j];\n        if (v != p && !block[v])\n            ans = min(ans, cent(v, u, all)), mx = max(mx, sz[v]);\n    }\n\n    return min(ans, mp(mx, u));\n}\n\nvoid solve(int u, int d){\n    fix(u, u);\n    u = cent(u, u, sz[u]).se;\n\n    //printf(\"u = %d, d = %d\\n\", u, d);\n\n    dep[u] = d;\n    block[u] = 1;\n    for (int j = 0; j < adj[u].size(); j++){\n        int v = adj[u][j];\n        if (!block[v])\n            solve(v, d+1);\n    }\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n-1; i++){\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n\n    solve(1, 0);\n\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n        ans = max(ans, dep[i]);\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 1e5 + 100, OO = 1e9 + 7, T = 1e5 + 10, M2 = 1e9 + 7, M = 1e9 + 7,  P = 6151, SQ = 800, lg = 70;\ntypedef pair <int, int> pii;\nvector <int> v[N];\n\npii dfs(int x, int y) {\n\tint mx = 0, id = x;\n\tfor(auto u : v[x]) {\n\t\tif(u != y) {\n\t\t\tpii p = dfs(u, x);\n\t\t\tif(p.ss > mx)\n\t\t\t\tmx = p.ss, id = p.ff;\n\t\t}\n\t}\n\tmx++;\n\treturn {id, mx};\n}\n\nint32_t main () {\n\tuse_fast;\t\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tint k = dfs(dfs(1, 0).ff, 0).ss;\n\tint sum = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tsum = 2 * sum + 1;\n\t\tif(sum >= k)\n\t\t\treturn cout << i, 0;\n\t}\n\treturn 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nint A[MAX_N];\n\nvector<int> adj[MAX_N];\n\nint max_lvl = -1,V = -1;\nint f(int v,int p,int d){\n  if(d > max_lvl){ max_lvl = d; V = v; }\n  \n  int ans = 0;\n  for(auto u : adj[v])\n    if(u != p)\n      ans = max(ans,1+f(u,v,d+1));\n  return ans;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n; cin >> n;\n  \n  for(int i=0;i<n-1;i++){\n    int u,v; cin >> u >> v; u--; v--;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  \n  f(0,-1,0);\n  int l = f(V,-1,0);\n  \n  if(l <= 2) cout << 1 << endl;\n  else {\n    cout << (l % 3 == 1 ? 3 : 2) << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 200055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,fa[N],ans;\nbitset <32> a[N],b[N];\nint nedge,Next[N*2],head[N],to[N*2];\n#define V to[i]\nvoid add(int a,int b){\n\tNext[++nedge]=head[a];head[a]=nedge;to[nedge]=b;\n}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tgo(i,x){\n\t\tif (fa[x]==V) continue;\n\t\tfa[V]=x;dfs(V);b[x]|=a[x]&a[V];a[x]|=a[V];\n\t}\n\tint num=0;\n\tF(i,0,30) if (b[x][num]) num=i+1;\n\tF(i,num,30) if (a[x][i]==0) {num=i;break;}\n\ta[x][num]=1;\n\tans=max(ans,num);\n\tF(i,0,num-1) a[x][i]=0;\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n-1) add_ne(read(),read());\n\tdfs(1);\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<62;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n \nvector<int> adj[100009];\n \nint dfs(int x,int p){//returns bitmask of visible positions\n\tbool hasc=0;\n\tint visible=0;\n\tint doubleup=0;\n\tfor(int i:adj[x]){\n\t\tif(i==p)continue;\n\t\thasc=1;\n\t\tint dfsv=dfs(i,x);\n\t\tdoubleup|=(visible&dfsv);\n\t\tvisible|=dfsv;\n\t}\n\tif(!hasc)return 1;\n\tint m2=0;\n\tfor(int i=19;i>=0;i--){\n\t\tif(doubleup&(1<<i)){m2=i+1;break;}\n\t}\n\tint v=0;\n\tREPP(i,m2,20){\n\t\tif(!(visible&(1<<i))){v=i;break;}\n\t}\n\tvisible|=(1<<v);\n\tREP(i,v){\n\t\tif(visible&(1<<i))\n\t\tvisible^=(1<<i);\n\t}\n\treturn visible;\n}\n \nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tadj[a].PB(b);adj[b].PB(a);\n\t}\n\tint vv=dfs(0,-1);\n\t//printf(\"%d \",vv);\n\tfor(int i=20;i>=0;i--){\n\t\tif(vv&(1<<i)){printf(\"%d\",i);return 0;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 100100;\nint n;\nvector<int> g[N];\nint dp[N];\n\nvoid dfs(int v, int par) {\n\tint p = 0, x = 0;\n\tfor (int u : g[v]) {\n\t\tif (u == par) continue;\n\t\tdfs(u, v);\n\t\twhile(x & dp[u]) {\n\t\t\tp++;\n\t\t\tx ^= x & ((1 << p) - 1);\n\t\t}\n\t\tx |= dp[u];\n\t\tx ^= x & ((1 << p) - 1);\n\t}\n\tdp[v] = x + (1 << p);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0, -1);\n\tint ans = 0;\n\twhile((1 << ans) <= dp[0]) ans++;\n\tprintf(\"%d\\n\", ans - 1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <map>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <set>\nusing namespace std;\n\npair<int, int> finder(vector<vector<int> > G, int from) {\n  int n = G.size();\n  vector<int> dist(n, -1);\n  dist[from] = 0;\n  queue<int> Q;\n  Q.push(from);\n  pair<int, int> ret;\n  while (!Q.empty()) {\n    int now = Q.front();\n    ret = pair<int, int>(now, dist[now]);\n    Q.pop();\n    for (int i=0; i<G[now].size(); i++)\n      if (dist[G[now][i]] == -1) {\n        dist[G[now][i]] = dist[now] + 1;\n        Q.push(G[now][i]);\n      }\n  }\n  return ret;\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<vector<int> > G(N);\n  for (int i=0; i<N-1; i++) {\n    int a, b;\n    cin >> a >> b;\n    G[a-1].push_back(b-1);\n    G[b-1].push_back(a-1);\n  }\n\n  pair<int, int> farthest = finder(G, 0);\n  pair<int, int> diameter = finder(G, farthest.first);\n\n  int now = 0;\n  for (int res = 0; ; res ++) {\n    if (now >= diameter.second) {\n      printf(\"%d\\n\", res);\n      break;\n    }\n    now = now * 2 + 2;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 20.11.2019 16:54:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> mask(n);\n  int ans = 0;\n  function<void(int, int)> Dfs = [&](int v, int pr) {\n    int lowest = 0;\n    for (int u : g[v]) {\n      if (u == pr) {\n        continue;\n      }\n      Dfs(u, v);\n      lowest |= (mask[u] & mask[v]);\n      mask[v] |= mask[u];\n    }\n    int bit = 1 << (lowest == 0 ? 0 : 32 - __builtin_clz(lowest));\n    while (mask[v] & bit) {\n      bit <<= 1;\n    }\n    mask[v] &= ~((1 << bit) - 1);\n    mask[v] |= bit;\n    ans = max(ans, 31 - __builtin_clz(mask[v]));\n  };\n  Dfs(0, -1);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n;\nvector<int> G[100010];\nint dp[100010];\nint s[100010];\nvoid dfs(int v,int p){\n\ts[v] = 0;\n\tdp[v] = 0;\n\tfor(int u: G[v]){\n\t\tif(p == u)continue;\n\t\tdfs(u,v);\n\t\tint t = s[v]&s[u];\n\t\trep(i,20){\n\t\t\tif((t>>i)&1){\n\t\t\t\tdp[v] = max( dp[v] , i+1 );\n\t\t\t}\n\t\t\telse if((t>>i)>0){\n\t\t\t\tt += 1<<i;\n\t\t\t}\n\t\t}\n\t\ts[v] = s[v]+s[u]-(t<<1);\n\t}\n\twhile((s[v]>>dp[v])&1){\n\t\ts[v] -= 1<<dp[v];\n\t\tdp[v] ++;\n\t}\n\ts[v] += 1<<dp[v];\n\t//cout << v << \" \" << dp[v] << \" \" << s[v] << endl;\n}\n\nint main(){\n\tint n;\n\tint a[100010],b[100010];\n\tscanf(\"%d\",&n);\n\trep1(i,n-1){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG[a[i]].pb(b[i]);\n\t\tG[b[i]].pb(a[i]);\n\t}\n\tdfs(1,0);\n\t\n\tint ret = 0;\n\trep1(i,n)ret = max( ret , dp[i] );\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      //if(cnt[v]==0) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      //assert(cnt[v]==1);\n      //assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n      if(~c) continue;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n\n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      assert(cnt[v]==1);\n      assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n\n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n\n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint n, d1, d2, dis[N], mark[N];\nvector <int> adj[N];\n\nvoid _dfs(int v, int c) {\n\tdis[v] = c;\n\tmark[v] = 1;\n\tfor (int i : adj[v])\n\t\tif (!mark[i])\n\t\t\t_dfs(i, c + 1);\n}\n\nvoid dfs(int s) {\n\tmemset(mark, 0, sizeof mark);\n\t_dfs(s, 0);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t}\n\t\n\tdfs(0);\n\tfor (int i = 0, mx = 0; i < n; i++)\n\t\tif (dis[i] > mx) {\n\t\t\tmx = dis[i];\n\t\t\td1 = i;\n\t\t}\n\tdfs(d1);\n\tfor (int i = 0, mx = 0; i < n; i++)\n\t\tif (dis[i] > mx) {\n\t\t\tmx = dis[i];\n\t\t\td2 = i;\n\t\t}\n\tcout << (dis[d2] + 1) / 2 - 1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, A[1 << 17], B[1 << 17], dp[1 << 17], ret; vector<int>X[1 << 17], G[1 << 17];\nbool used[1 << 17];\n\nvoid dfs(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tG[pos].push_back(X[pos][i]);\n\t\tdfs(X[pos][i]);\n\t}\n}\n\nint solve(int pos) {\n\tint r = 0, s = 0;\n\tfor (int i = 0; i < G[pos].size(); i++) {\n\t\tint A = solve(G[pos][i]);\n\t\tif (A == 1) r++;\n\t\tif (A == 2) s++;\n\t}\n\n\tif (dp[pos] != -1) {\n\t\tif (r == 0) return 0;\n\t\tif (r == 2) return 2;\n\t\treturn 1;\n\t}\n\tif (r == 0 && s <= 1) { dp[pos] = ret; return 1; }\n\treturn 2;\n}\n\nint main() {\n\t//FILE *in = freopen(\"in1.txt\", \"r\", stdin);\n\tcin >> N;\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tX[A[i]].push_back(B[i]);\n\t\tX[B[i]].push_back(A[i]);\n\t}\n\tdfs(1);\n\n\tfor (int i = 1; i <= N; i++) dp[i] = -1;\n\n\twhile (true) {\n\t\tint cnt = 0; for (int i = 1; i <= N; i++) { if (dp[i] == -1) cnt++; }\n\t\tif (cnt == 0) {\n\t\t\tcout << ret - 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\tsolve(1);\n\t\tret++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/** MIT License Copyright (c) 2018 Vasilyev Daniil **/\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\ntemplate<typename T> using v = vector<T>;\n//template<typename T, typename U>  using hmap = __gnu_pbds::gp_hash_table<T, U>;\n#define int long long\ntypedef long double ld;\ntypedef string str;\ntypedef vector<int> vint;\n#define rep(a, l, r) for(int a = (l); a < (r); a++)\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sc second\n#define sz(a) ((int) a.size())\nconst long long inf = 4611686018427387903; //2^62 - 1\n#if 0  //FileIO\nconst string fileName = \"\";\nifstream fin ((fileName == \"\" ? \"input.txt\"  : fileName + \".in\" ));\nofstream fout((fileName == \"\" ? \"output.txt\" : fileName + \".out\"));\n#define get fin>>\n#define put fout<<\n#else\n#define get cin>>\n#define put cout<<\n#endif\n#define eol put endl\n#define check(a) put #a << \": \" << a << endl;\nvoid read() {} template<typename Arg,typename... Args> void read (Arg& arg,Args&... args){get (arg)     ;read(args...) ;}\nvoid print(){} template<typename Arg,typename... Args> void print(Arg  arg,Args...  args){put (arg)<<\" \";print(args...);}\nint getInt(){int a; get a; return a;}\n//code goes here\nconst int N = 1e5 + 1;\nvint t[N];\nbitset<N> added;\nint siz[N];\nint ans = 0;\nint calcSize(int cur, int p = -1) {\n    siz[cur] = 1;\n    for (int i : t[cur])\n        if (!added.test(i) && i != p)\n            siz[cur] += calcSize(i, cur);\n    return siz[cur];\n}\nvoid make_centroid(int cur, int h = 0) {\n    ans = max(ans, h);\n    int lim = calcSize(cur) / 2;\n    bool again = 1;\n    int pr = -1;\n    while (again) {\n        again = 0;\n        for (int i : t[cur])\n            if (i != pr && !added.test(i) && siz[i] > lim) {\n                pr = cur;\n                cur = i;\n                again = 1;\n                break;\n            }\n    }\n    added.set(cur);\n    for (int i : t[cur])\n        if (!added.test(i))\n            make_centroid(i, h + 1);\n}\n\nvoid run() {\n    int n;\n    get n;\n    rep(i, 1, n) {\n        int v, u;\n        read(v, u);\n        t[v].pb(u);\n        t[u].pb(v);\n    }\n    make_centroid(1);\n    put ans;\n}\nsigned main() {srand(time(0)); ios::sync_with_stdio(0); cin.tie(0); put fixed << setprecision(15); run(); return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef unordered_set<ll> set;\n#define N 100010\n#define D 20\nll n;\nvector<ll> g[N];\nset solve(ll x,ll from){\n  vector<set> v;\n  for(auto y:g[x])if(y!=from)v.push_back(solve(y,x));\n  ll clash=-1;\n  for(ll i=0;i<D;i++){\n    int cnt=0;\n    for(auto x:v)if(x.find(i)!=x.end())cnt++;\n    if(cnt>=2){clash=i; break;}\n  }\n  ll gen;\n  for(ll i=clash+1;;i++){\n    int cnt=0;\n    for(auto x:v)if(x.find(i)!=x.end())cnt++;\n    if(cnt==0){gen=i; break;}\n  }\n  set res; res.insert(gen);\n  for(ll i=gen+1;i<D;i++){\n    int cnt=0;\n    for(auto x:v)if(x.find(i)!=x.end())cnt++;\n    if(cnt>0)res.insert(i);\n  }\n  return res;\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    ll a,b;cin>>a>>b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  set res=solve(1,0);\n  ll ans=0;\n  for(auto x:res)ans=max(ans,x);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstruct edge{int s,t,n;}e[200010];\nint n,h[200010],f[200010];\n \nvoid dfs(int x,int fa)\n{\n\tint s=0,sum=0,k=1,p=0;\n\tfor (int i=h[x],y; y=e[i].t,i; i=e[i].n)\n\t\tif (y!=fa)  dfs(y,x),s|=sum&f[y],sum|=f[y];\n\twhile ((k<s)||(sum&k))  {k<<=1;p++;}\n\t//f[x]=(sum^(sum&(k-1)))|k;\nf[x]=(sum>>(p-1)<<(p-1))|k;\n}\n \nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1,u,v,tot=0; i<n; i++)\n\t\t{\n\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\te[++tot]=(edge){u,v,h[u]},h[u]=tot;\n\t\t\te[++tot]=(edge){v,u,h[v]},h[v]=tot;\n\t\t}\n\tdfs(1,0);\n\tprintf(\"%d\",int(log2(f[1])));\n}\n \nint main()\n{\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 1e5 + 5;\nconst int LOGN = 19;\n\nint N;\nvector<int> G[MAXN];\n\nvoid input()\n{\n    read(N);\n    for (int i = 1; i < N; ++i) {\n        int u, v;\n        read(u); read(v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n}\n\nint calc(int u, int f)\n{\n    int st = 0, mask = 0;\n    for (int i = 0; i < SZ(G[u]); ++i) {\n        int v = G[u][i];\n        if (v == f)\n            continue;\n        int t = calc(v, u);\n        if (mask & t)\n            chkmax(st, 31 - __builtin_clz(mask & t));\n        mask |= t;\n    }\n    while (mask >> st & 1) {\n        ++st;\n    }\n    return (mask & (~0 ^ ((1 << st) - 1))) | (1 << st);\n}\n\nvoid solve()\n{\n    int ans = 31 - __builtin_clz(calc(1, 0));\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"D.in\", \"r\", stdin);\n    freopen(\"D.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 汉兵已略地，四方楚歌声。\n//     -- 虞姬《和项王歌》\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=100007;\n\nstd::vector<int>p[N];\nint n,sz[N],rsz,nro,nsz;\nbool vis[N];\n\ninline void dfs1(int x,int fa)\n{\n\tsz[x]=1;\n\tfoe(i,p[x])if(*i!=fa&&!vis[*i])\n\t\tdfs1(*i,x),sz[x]+=sz[*i];\n}\n\ninline void dfs2(int x,int fa)\n{\n\tint t=rsz-sz[x];\n\tfoe(i,p[x])if(*i!=fa&&!vis[*i])\n\t\tdfs2(*i,x),repr(t,sz[*i]);\n\tif(t<nsz)nsz=t,nro=x;\n}\n\ninline int work(int x)\n{\n\tdfs1(x,0);\n\trsz=nsz=sz[nro=x];\n\tdfs2(x,0);\n\tvis[x=nro]=1;\n\tint t=0;\n\tfoe(i,p[x])if(!vis[*i])repr(t,work(*i));\n\treturn t+1;\n}\n\nint main()\n{\n\tin,n;\n\tfo1(i,n-1)\n\t{\n\t\tint x,y;\n\t\tin,x,y;\n\t\tp[x].pb(y);\n\t\tp[y].pb(x);\n\t}\n\tout,work(1)-1,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\n\nint dp[MAXn], dp2[MAXn], ans = MAXn;\nvector<int> g[MAXn];\n//dp1 halati ke v ro joz raas speciala bezarim\n//dp2 halati ke v joz raas special ha nabashe va lozomn be yekishon motasel bashem\n//dp3 maximum dp2 haye motasel be v\nvoid dfs(int v, int par) {\n\tint mx = 0;\n\tvector<int> vec;\n\tif (g[v].size() == 1 && par)\n\t\treturn;\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tdfs(g[v][i], v);\n\t\t\tdp2[v] = max(dp2[v], dp[g[v][i]]);\n\t\t\tvec.push_back(dp[g[v][i]]);\n\t\t}\n\t\n\tdp[v] = dp2[v] + 1;\n\tif ((g[v].size() == 1 && !par) || (par && g[v].size() == 2)) {\n\t\tfor (int i = 0; i < g[v].size(); i++)\n\t\t\tif (g[v][i] != par) {\n\t\t\t\tdp[v] = min(dp[v], dp2[g[v][i]] + 1);\n\t\t\t}\n\t}\n\n}\n\nvoid dfs2(int v, int par, int ans1) {\n\tmultiset<int> st;\n\tst.insert(ans1);\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par)\n\t\t\tst.insert(dp[g[v][i]]);\n\t//cout << v << ' ' << ans1 << endl;\n\tans = min(ans, (*st.rbegin()) + 1);\n\tfor (int i = 0; i < g[v].size(); i++)\n\t\tif (g[v][i] != par) {\n\t\t\tst.erase(st.find(dp[g[v][i]]));\n\t\t\tif (st.size() > 1)\n\t\t\tdfs2(g[v][i], v, (*st.rbegin()) + 1);\n\t\t\telse if (st.size() == 1)\n\t\t\tdfs2(g[v][i], v, (*st.rbegin()));\n\t\t\tst.insert(dp[g[v][i]]);\n\t\t}\n\t\n\t\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tdfs2(1,0, 0);\n\tcout << min(ans, dp[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iosfwd>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n#include <deque>\n#include <string>\n#include <list>\n#include <iterator>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <algorithm>\n#include <assert.h>\n#include <unordered_map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector < long long > vll;\ntypedef pair <long long, long long> pll;\ntypedef pair <int, int> pii;\ntypedef vector < int > vii;\ntypedef complex < double > Point;\n\n#define csl ios_base::sync_with_stdio(false); cin.tie(NULL)\n#define mp make_pair\n#define fst first\n#define snd second\n\nll t, n, m, u, v, q, r, ql, qr, k, l, w, x, y, d, c, a, s;\nconst int N = 1e5 + 500;\nconst long long mod = 1e9 + 7;\nconst long long INF = 1LL << 61LL;\n\nvector <int> adj[N];\n// visible means there's no bigger label b/w path from node in subtree of v to v\nint solve(int v, int p) { // returns mask of visible node labels\n  int vis[30] = {0};\n  int assign = 0; // minimum possible label for v\n  for (int u : adj[v]) {\n    if (u == p) continue;\n    int mask = solve(u, v);\n    for (int j = 0; j < 30; ++j) {\n      if (mask & (1 << j)) {\n        vis[j]++;\n        if (vis[j] == 2) assign = max(assign, j + 1);\n      }\n    }\n  }\n  while (vis[assign] > 0) assign++;\n  int ret = (1 << assign); // will be visible to parent\n  for (int j = assign + 1; j < 30; ++j) {\n    if (vis[j]) ret |= (1 << j); // will still be visible to parent\n  }\n  return ret;\n}// when the answer for root is returned the tree is splitted into regions which are connected by single edges\n// merge trees with smaller node labels to ones with larger\n// in the end we will have a single tree with node label = largest node lable visible to root\nint main() {\n  csl;\n  cin >> n;\n  for (int i = 0; i < n - 1; ++i) {\n    cin >> u >> v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  \n  int get = solve(1, 0);\n  int cnt = -1;\n  while (get) {\n    cnt++;\n    get /= 2;\n  }// highest visible node label\n  cout << cnt << '\\n';\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned int uint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=100010;\ninline uint lowbit(uint x){\n\treturn x&-x;\n}\ninline uint highbit(uint x){\n\tfor(;x!=(x&-x);x^=x&-x);\n\treturn x;\n}\nnamespace T{\n\tconst int E=N<<1;\n\tint to[E],bro[E],head[N],e=0;\n\tinline void init(){\n\t\tmemset(head,-1,sizeof(head));\n\t}\n\tinline void ae(int u,int v){\n\t\tto[e]=v,bro[e]=head[u],head[u]=e++;\n\t}\n\tinline void add(int u,int v){\n\t\tae(u,v),ae(v,u);\n\t}\n\tuint dfs(int x,int fa){\n\t\tuint ans=0,hb=0;\n\t\tfor(int i=head[x],v;~i;i=bro[i]){\n\t\t\tif((v=to[i])!=fa){\n\t\t\t\tuint cur=dfs(v,x);\n\t\t\t\tapmax(hb,highbit(cur&ans)<<1);\n\t\t\t\tans|=cur;\n\t\t\t}\n\t\t}\n\t\tapmax(hb,lowbit(~ans));\n\t\treturn hb|(ans&~(hb-1));\n\t}\n}\nint main(){\n\tint n=ni;\n\tT::init();\n\tfor(int i=1;i<n;T::add(ni,ni),i++);\n\tuint tmp=T::dfs(1,0);\n\tint ans=0;\n\tfor(;tmp>1;tmp>>=1,ans++);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ***************************************\nAuthor        :Scau.ion\nCreated Time  :2017/01/22 21:30:57 UTC+8\nFile Name     :ion.cpp\n*************************************** */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define ULL unsigned long long\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<PII>\n#define X first\n#define Y second\n#define IOS ios::sync_with_stdio(0);cin.tie(0);\n#define IN freopen(\"in\", \"r\", stdin);\n#define OUT freopen(\"out\", \"w\", stdout);\n\nconst int maxn=100010;\n\nVI son[maxn];\nint ma,id;\n\nvoid dfs(int st,int fa,int dep)\n{\n    if (dep>ma)\n    {\n        ma=dep;\n        id=st;\n    }\n    for (int j=0;j<son[st].size();++j)\n    {\n        if (son[st][j]==fa) continue;\n        dfs(son[st][j],st,dep+1);\n    }\n    return;\n}\n\nint main()\n{\n    IOS;\n    int n;\n    cin>>n;\n    for (int j=1;j<=n;++j)\n    {\n        int a,b;\n        cin>>a>>b;\n        son[a].PB(b);\n        son[b].PB(a);\n    }\n    dfs(1,0,1);\n    dfs(id,0,1);\n    int ans=0;\n    int mx=1;\n    while (ma>mx)\n    {\n        ++ans;\n        mx=mx*2+1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\n#define X first\n#define Y second\n#define PB push_back\n\nusing namespace std;\n\nconst int N = 1e5 + 500;\nconst int K = 30;\n\nvector < int > v[N];\n\nint obr[N], doc[N][K], par[N], ja[N], sol, n, deg[N];\nqueue < int > Q;\n\nvoid ide(int x){\n\tfor(int y : v[x]){\n\t\tif(!obr[y]){\n\t\t\tpar[x] = y;\n\t\t\tv[x].erase(find(v[x].begin(), v[x].end(), y));\n\t\t}\n\t}\n\tfor(int y : v[x]){\n\t\tfor(int k = 0;k < K;k++)\n\t\t\tdoc[x][k] |= doc[y][k];\n\t}\n\tfor(;doc[x][ja[x]];ja[x]++){\n\t\tdoc[x][ja[x]] = 0;\n\t}\n\t//printf(\"x = %d ja = %d par = %d\\n\", x, ja[x], par[x]);\n\tdoc[x][ja[x]] = 1; obr[x] = 1;\n\tsol = max(sol, ja[x]);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1;i < n;i++){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tv[x].PB(y); v[y].PB(x);\n\t\tdeg[x]++, deg[y]++;\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tif(deg[i] == 1)\n\t\t\tQ.push(i);\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tint gas = Q.front(); Q.pop();\n\t\tide(gas); deg[par[gas]]--;\n\t\tif(deg[par[gas]] <= 1)\n\t\t\tQ.push(par[gas]);\n\t}\n\tprintf(\"%d\\n\", sol);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define  NDEBUG\n\n//#pragma optimize(\"tree-vectorize\")\n//#pragma optimize (\"fast-math\")\n//#pragma optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v)                  v.begin(), v.end()\n#define db(x)                   cout << #x << \" = \" << (x) << \"\\n\"\n#define fend(x)                 ((x) & ((x)+1)) - 1\n#define fenu(x)                 (x) | ((x)+1)\n#define forn(i, n)              for (int i = 0; i < (int)n; ++i)\n#define forr(i, b, e)           for (int i = b; i < (int)e; ++i)\n#define ft                      first\n#define len(s)                  s.length()\n#define mp                      std::make_pair\n#define pob                     pop_back\n#define pof                     pop_front\n#define pub                     push_back\n#define puf                     push_front\n#define sc                      second\n\ntypedef double dbl;\ntypedef long double ldbl;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst long long MILLER_RABIN = 3215031751;\nconst long double PI = acos(-1);\n\n#if __cplusplus >= 201103L\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nstruct config_io {\n    config_io() {\n        cin.tie(nullptr);\n        cout.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n    }\n} cnf_io;\n\nstruct config_rand {\n    config_rand() {\n        srand(chrono::duration_cast<chrono::nanoseconds>(\n                chrono::high_resolution_clock::now().time_since_epoch()).count());\n    }\n} cnf_rand;\n\nnamespace std {\n    template<>\n    struct hash<pair<int, int> > {\n        size_t operator()(const pair<int, int> &x) const {\n            return (x.first * 71ll + x.second) % ((int) 1e9 + 7);\n        }\n    };\n\n    template<>\n    struct hash<vector<int>> {\n        size_t operator()(const vector<int> &v) const {\n            size_t hsh = 0;\n            for (int i = 0; i < v.size(); ++i) {\n                hsh = (hsh * 71ll + v[i]) % (int) (1e9 + 7);\n            }\n            return hsh;\n        }\n    };\n}\n\ntemplate<class T>\nusing ordered_set = __gnu_pbds::tree<T, __gnu_pbds::null_type, less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n//ordered_set<int>  s;\n//s.insert(3);\n//cout << s.order_of_key(2) << endl; // the number of elements in the s less than 2\n//cout << *s.find_by_order(0) << endl; // print the 0-th smallest number in s(0-based)\n\n// __builtin_popcount(x) - Returns the number of 1-bits in x.\n// __builtin_parity(x) - Returns the parity of x, i.e. the number of 1-bits in x modulo 2.\n// __builtin_ffs(x) - Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero.\n// __builtin_clz(x) - Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.\n// __builtin_ctz(x) - Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.\n\n//inline string tobin(long long x) { bitset<63>(x).to_string(); }\n\ntemplate<class T>\nvoid trace(T collection) {\n    for (auto elem : collection) { cout << elem << \" \"; }\n    cout << endl;\n}\n\n#endif\n\nconst int ML = 1e5 + 10;\nvector<int> g[ML];\nint f[ML];\n\nint most_sign_bit(int x) {\n    return 31 - __builtin_clz(x);\n}\n\nint first_zero_bit(int x) {\n    int i = 0;\n    while (x & (1 << i)) ++i;\n    return i;\n}\n\nvoid dfs(int v, int par = -1) {\n    f[v] = 0;\n    forn(i, g[v].size()) {\n        int to = g[v][i];\n        if (to == par) continue;\n        dfs(to, v);\n    }\n    int d = 1 << 20;\n    while (d) {\n        int cnt = 0;\n        forn(i, g[v].size()) {\n            int to = g[v][i];\n            if (to == par) continue;\n            if (f[to] & d) cnt++;\n        }\n        if (cnt > 1) {\n            f[v] += d << 1;\n            break;\n        }\n        if (cnt == 1) f[v] |= d;\n        d >>= 1;\n    }\n    f[v] += 1;\n}\n\nvoid solve(int test) {\n    int n;\n    cin >> n;\n    forn(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0);\n    //cout << bitset<32>(f[0]) << endl;\n    cout << most_sign_bit(f[0]) << endl;\n}\n\nint main() {\n#ifdef HOME\n    freopen(\"home.in\", \"r\", stdin);\n    freopen(\"home.out\", \"w\", stdout);\n#endif\n\n    int tests = 1;\n    //cin >> tests;\n    for (int test = 1; test <= tests; ++test) {\n        solve(test);\n    }\n\n#ifdef HOME\n    cout << \"\\n\\nTime: \" << clock() / (double) CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define fi first\n#define se second\n#define ll long long\n#define dbg(v) cerr<<#v<<\" = \"<<v<<'\\n'\n#define vi vector<int>\n#define vl vector <ll>\n#define pii pair<int,int>\n#define mp make_pair\n#define db long double\n#define pb push_back\n#define all(s) s.begin(),s.end()\ntemplate < class T > T smin(T &a,T b) {if (a > b) a = b;return a;}\ntemplate < class T > T smax(T &a,T b) {if (a < b) a = b;return a;}\nconst int N = (int)(1e6) + 5;\nvi g[N];\nint ans = 0;\nint dfs(int node,int prev)\n{\n    int was[22];\n    memset(was,0,sizeof(was));\n    for (auto it : g[node])\n        if (it != prev)\n        {\n            int msk = dfs(it,node);\n            for (int i = 0;i < 20;++i)\n                if ((msk >> i) & 1)\n                    ++was[i];\n        }\n    int lst = -1;\n    for (int i = 0;i < 20;++i)\n        if (was[i] >= 2)\n            lst = i;\n    int mask = 0;\n    for (int i = lst + 1;i < 20;++i)\n        if (!was[i])\n        {\n            smax(ans,i);\n            mask |= (1 << i);\n            for (int j = i + 1;j < 20;++j)\n                if (was[j])\n                    mask |= 1 << j;\n            return mask;\n        }\n}\nint main(void)\n{\n    int n;\n    cin>>n;\n    for (int i = 1;i < n;++i)\n    {\n        int a,b;\n        cin>>a>>b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(1,0);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI X[100011];\n\nint par[100011];\nVI ord;\nint U[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i_, N) {\n\tint v = ord[i_];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    VI buf; buf.reserve(N);\n    \n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tint cnt = 0, ma = -1;\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    if (ma < X[*e].back()) {\n\t\tma = X[*e].back();\n\t\tcnt = 0;\n\t    }\n\t    if (ma == X[*e].back()) {\n\t\tcnt++;\n\t    }\n\t}\n\n\tif (cnt == 0) {\n\t    U[v] = 0;\n\t    X[v].push_back(0);\n\t} else if (cnt >= 2) {\n\t    U[v] = ma+1;\n\t    X[v].push_back(ma+1);\n\t} else {\n\t    buf.resize(ma+2);\n\t    fill(buf.begin(), buf.end(), 0);\n\t    EACH (e, G[v]) if (*e != par[v]) {\n\t\tEACH (f, X[*e]) buf[*f] = 1;\n\t    }\n\t    REP (i, ma+2) {\n\t\tif (buf[i] == 0) {\n\t\t    U[v] = i;\n\t\t    buf[i] = 1;\n\t\t    break;\n\t\t} else {\n\t\t    buf[i] = 0;\n\t\t}\n\t    }\n\t    REP (i, ma+2) {\n\t\tif (buf[i]) X[v].push_back(i);\n\t    }\n\t}\n\n    }\n\n    int ma = *max_element(U, U+N);\n    // rprintf(\"%d\", U, U+N);\n    printf(\"%d\\n\", ma);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,f[110001][21],ans,s[110001];\nvector<int> w[110001];\nvoid dfs(int u,int p)\n{\n\tfor(int v:w[u])\n\t\tif(v!=p)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tfor(int j=0;j<18;j++)f[u][j]+=f[v][j];\n\t\t}\n\tint j=0;\n\tfor(int i=17;i>=0;i--)\n\t\tif(f[u][i]>1){j=i+1;break;}\n\twhile(f[u][j])j++;\n\tans=max(ans,j);\n\tf[u][j]++;\n\twhile(j--)f[u][j]=0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tw[x].push_back(y);\n\t\tw[y].push_back(x);\n\t}\n\tdfs(1,-1);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      if(cnt[v]==0) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      assert(cnt[v]==1);\n      assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n\n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n\n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Author       : Sun YaoFeng\n//============================================================================\n\n//#pragma \tcomment(linker, \"/STACK:100240000,100240000\")\n//#include\t<cstdio>\n//#include\t<cstdlib>\n//#include\t<cstring>\n//#include\t<algorithm>\n\n#include\t<bits/stdc++.h>\n\nusing\tnamespace\tstd;\n\n#define DB\t\tdouble\n#define\tlf\t\telse if\n#define I64\t\tlong long\n#define\tRd()\t(rand()<<15|rand())\n#define For(i,a,b)\tfor(int i=a,lim=b;i<=lim;i++)\n#define Rep(i,a,b)\tfor(int i=a,lim=b;i>=lim;i--)\n\n#define\tfi\tfirst\n#define se\tsecond\n#define MK\tmake_pair\n#define PA\tpair<int, int>\n\n//#define\tmin(a,b)\t((a)<(b)?(a):(b))\n//#define\tmax(a,b)\t((a)<(b)?(b):(a))\n\n#define\tCH\t(ch=getchar())\nint\t\tIN()\t{\n\t\tint x= 0, f= 0, ch;\n\t\tfor\t(; CH < '0' || ch > '9';)\tf= (ch == '-');\n\t\tfor\t(; ch >= '0' && ch <= '9'; CH)\tx= x*10 + ch -'0';\n\t\treturn\tf? -x : x;\n}\n\n#define n\t100005\n\nint\t\tN, D, Rt, Ans, st[n], Dep[n];\n\nstruct\tLin{\n\t\tint v, next;\n}E[n << 1];\n\nvoid\tLink(int u, int v)\t{\n\t\tE[++ D]= (Lin){v, st[u]};\tst[u]= D;\n\t\tE[++ D]= (Lin){u, st[v]};\tst[v]= D;\n}\n\nvoid\tDFS(int u, int f)\t{\n\t\tDep[u]= Dep[f] + 1;\n\t\t\n\t\tfor (int i= st[u], v; i; i= E[i].next)\n\t\t\tif\t((v= E[i].v) != f)\tDFS(v, u);\n}\n\nint\t\tmain(int argc, char* argv[]){\n\t\tN= IN();\n\t\tFor(i, 2, N)\tLink(IN(), IN());\n\t\t\n\t\tDFS(1, 0);\n\t\t\n\t\tRt= 1;\n\t\tFor(i, 2, N)\tif\t(Dep[i] > Dep[Rt])\tRt= i;\n\t\t\n\t\tDFS(Rt, 0);\n\t\t\n\t\tint\tD= 0;\n\t\tFor(i, 1, N)\tD= max(D, Dep[i]);\n\t\t\n\t\tfor (; D > 1; D>>= 1)\tAns++;\n\t\tcout << Ans << endl;\n\t\t\n\t\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <cstdlib>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n \ntypedef long long ll;\ntypedef long double ld;\n \nconst ll MOD = 1e9 + 7, INF = 1e18 + 1;\n \nusing namespace std;\n\nint n;\n\nvector <int> g[1000000];\n\nint label[1000000], f[300000][20], ans;\n\nint dfs (int x, int p)\n{\n\tint mx = 0;\n\tfor (int to : g[x])\n\t\tif (to != p)\n\t\t{\n\t\t\tdfs (to, x);\n\n\t\t\tfor (int i = 0; i < 20; i++)\n\t\t\t{\n\t\t\t\tif (f[x][i] && f[to][i]) mx = max (mx, i);\n\t\t\t\tf[x][i] |= f[to][i];\n\t\t\t}\n\t\t}\n\n\twhile (f[x][mx]) mx++;\n\n\tlabel[x] = mx;\n\n\tans = max (label[x], ans);\n\n\tf[x][mx] = 1;\n\n\tfor (int i = 0; i < mx; i++)\n\t\tf[x][i] = 0;\n\n\treturn label[x];\n}\n\nint main ()\n{\n\tcin >> n;\n\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint a, b;\n\n\t\tscanf (\"%d%d\", &a, &b);\n\n\t\tg[a-1].push_back (b - 1);\n\t\tg[b-1].push_back (a - 1);\n\t}\n\n\tdfs (0, -1);\n\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rint register int\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0;char c = getchar();bool f = 0;\n  for (; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\nconst int lgN = 19;\nconst int N = 3e5 + 233;\nint n, ban[lgN + 2], col[N], ans = 0;\nvector<int> g[N];\ninline int dfs(int u, int fat) {\n  vector<int> vec;\n  int has = 0;\n  for (int v : g[u]) if (v != fat) {\n      int p = dfs(v, u);\n      vec.push_back(p);\n      has |= p;\n    }\n  int mx = 0;\n  memset(ban, 0, sizeof ban);\n  for (int k = 0; k < lgN; k ++) {\n    int cnt = 0;\n    for (int i : vec)\n      cnt += i >> k & 1;\n    if (cnt >= 1) ban[k] = true;\n    if (cnt >= 2) mx = max(mx, k + 1);\n  }\n  while (ban[mx]) ++ mx;\n  col[u] = mx;\n  ans = max(ans, mx);\n  for (int k = 0; k < col[u]; k ++)\n    has &= 1 << k;\n  has |= 1 << col[u];\n  return has;\n}\n\nmain(void) {\n  read(n);\n  for (int i = 2; i <= n; i ++) {\n    int x, y; read(x); read(y);\n    g[x].push_back(y); g[y].push_back(x);\n  }\n  dfs(1, 0);\n  cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof a)\n#define mcpy(a,b) memcpy(a,b,sizeof b)\n#define max(a,b) ((a)<(b)?(b):(a))\n#define swap(a,b) a^=b^=a^=b\n#define lb(x) ((x)&(-(x)))\n#define inf 0x3f3f3f3f\n#define N 100010\nusing namespace std;\ntypedef long long ll;\nint n,d[N],mx,pos;\nvector<int> g[N];\ninline void dfs(int x,int p){\n\tfor(int i=0;i<g[x].size();i++){\n\t\tint th=g[x][i];\n\t\tif(th^p)d[th]=d[x]+1,dfs(th,x);\n\t}\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1,a,b;i<n;i++)scanf(\"%d%d\",&a,&b),g[a].push_back(b),g[b].push_back(a);\n\tdfs(1,0);\n\tfor(int i=1;i<=n;i++)if(mx<d[i])mx=d[pos=i];\n\td[pos]=0,dfs(pos,0);\n\tmx=0;\n\tfor(int i=1;i<=n;i++)mx=max(mx,d[i]);\n\tprintf(\"%d\",((mx+1)>>1)-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author jcg\n */\n\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n\n\n// Complexity: O(n + k)\ntemplate<typename ForwardIt, typename Func>\nstd::vector<typename std::iterator_traits<ForwardIt>::value_type> counting_sort(ForwardIt first, ForwardIt last, const Func &func)\n{\n    int maxk = 0, n = 0;\n    for (auto it = first; it != last; ++it, ++n)\n        maxk = std::max(maxk, func(*it));\n    std::vector<int> cnt(maxk + 1);\n    for (auto it = first; it != last; ++it)\n        ++cnt[func(*it)];\n    for (int i = 0, sum = 0; i <= maxk; ++i)\n    {\n        sum += cnt[i];\n        cnt[i] = sum - cnt[i];\n    }\n    std::vector<typename std::iterator_traits<ForwardIt>::value_type> result(n);\n    for (auto it = first; it != last; ++it)\n        result[cnt[func(*it)]++] = *it;\n    return result;\n}\n\n\n\nstruct parent_representation\n{\n    std::vector<int> parent;\n    std::vector<int> ord; // preorder\n};\n\nparent_representation get_parent_representation(int root, const std::vector<int> &u, const std::vector<int> &v)\n{\n    const int n = u.size() + 1;\n    std::vector<int> degree(n), edges(2 * u.size());\n    for (int i = 0; i < n - 1; ++i)\n    {\n        ++degree[u[i]]; ++degree[v[i]];\n        edges[i] = edges[i + u.size()] = i;\n    }\n    auto same = [&](int e) { return e < u.size() ? u[e] : v[e - u.size()]; };\n    auto other = [&](int e) { return e < u.size() ? v[e] : u[e - u.size()]; };\n    edges = counting_sort(edges.begin(), edges.end(), same);\n    std::vector<int> first(n, -1), last(n);\n    for (int i = 0; i < (int) edges.size(); ++i)\n    {\n        int e = edges[i];\n        if (first[same(e)] == -1)\n            first[same(e)] = i;\n        last[same(e)] = i;\n    }\n    std::vector<int> parent(n, -1), ord, stk;\n    for (stk.emplace_back(root); !stk.empty();)\n    {\n        int x = stk.back();\n        ord.emplace_back(x);\n        stk.pop_back();\n        for (int k = first[x]; k <= last[x]; ++k)\n        {\n            int y = other(edges[k]);\n            if (parent[y] == -1 && y != root)\n                parent[y] = x, stk.push_back(y);\n        }\n    }\n//    for (int i = 0; i < n; ++i)\n//        std::cout << i+1 << \" \" << parent[i]+1 << std::endl;\n//    for (int x : ord) std::cout << x+1 << \" \";\n//    std::cout << std::endl;\n    return parent_representation{parent, ord};\n}\n\nstd::vector<int> strategy_function(const std::vector<int> &u, const std::vector<int> &v)\n{\n    parent_representation rep = get_parent_representation(0, u, v);\n    const auto &parent = rep.parent;\n    const auto &ord = rep.ord;\n    const int n = ord.size();\n    std::vector<int> label(n), used(n), more(n);\n    for (int i = n - 1; i >= 0; --i)\n    {\n        int u = ord[i];\n        for (int k : {1, 2, 4, 8, 16})\n            more[u] |= more[u] >> k;\n        ++more[u];\n        int possible = ~used[u] & -more[u];\n        label[u] = possible & -possible;\n        used[u] |= label[u];\n        used[u] &= -label[u];\n        if (parent[u] != -1)\n        {\n            int p = parent[u];\n            more[p] |= used[u] & used[p];\n            used[p] |= used[u];\n        }\n    }\n    return label;\n}\n\nclass DUninity\n{\npublic:\n    void solve(std::istream& in, std::ostream& out)\n    {\n        using std::vector;\n\n        int n;\n        in >> n;\n\n        vector<int> u(n - 1), v(n - 1);\n        for (int i = 0; i < n - 1; ++i)\n        {\n            in >> u[i] >> v[i];\n            --u[i], --v[i];\n        }\n\n        auto label = strategy_function(u, v);\n        out << std::__lg(*std::max_element(label.begin(), label.end())) << '\\n';\n    }\n};\n\n\nint main()\n{\n    std::ios_base::sync_with_stdio(0);\n    std::istream& in(std::cin);\n    std::ostream& out(std::cout);\n    in.tie(0);\n    DUninity solver;\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nint i,j,k,n,m,x,y,t,b[20];\nint fi[N*2],ne[N*2],la[N*2],a[N*2],w[N];\nint f[N][20];\nvoid add(int x,int y){\n\tk++;a[k]=y;\n\tif (fi[x]==0)fi[x]=k;else ne[la[x]]=k;\n\tla[x]=k;\n}\nvoid dfs(int x,int fa){\n\tfor (int i=fi[x];i;i=ne[i])\n\t\tif (a[i]!=fa){\n\t\t\tdfs(a[i],x);\n\t\t\tfor (int j=1;j<20;j++)f[x][j]|=f[a[i]][j];\n\t\t}\n\tmemset(b,0,sizeof b);\n\tfor (int i=fi[x];i;i=ne[i])\n\t\tif (a[i]!=fa){\n\t\t\tb[w[a[i]]]=1;\n\t\t}\n\tint bt=0;\n\tfor (int i=19;i>=1;i--)\n\t\tif (f[x][i]){\n\t\t\tbt=i;break;\n\t\t}\n\tfor (int i=1;i<=19;i++)\n\t\tif (!b[i]){\n\t\t\tif (f[x][i]&&i<bt){\n\t\t\t\tw[x]=i;break;\n\t\t\t}\n\t\t\telse if (i>bt){\n\t\t\t\tw[x]=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa)f[x][w[a[i]]]=1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,-1);\n\tint ans=0;\n\tfor (i=1;i<=n;i++)ans=max(ans,w[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\n\nint deg[100005];\nvector <int> v[100005];\n\nint bio[100005];\n\nint main() {\n\tmemset(bio, -1, sizeof bio);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i=0 ; i<n-1 ; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tqueue<int> q;\n\tfor (int i=1 ; i<=n ; i++) {\n\t\tif (deg[i] == 1) {\n\t\t\tbio[i] = 0;\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tfor (int i=0 ; i<v[x].size() ; i++) {\n\t\t\tint nx = v[x][i];\n\t\t\tif (bio[nx] == -1) {\n\t\t\t\tbio[nx] = bio[x]+1;\n\t\t\t\tq.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\tint sol = 0;\n\tfor (int i=1 ; i<=n ; i++) {\n\t\t//cout <<\"i = \"<<i<<\"   bio[\"<<i<<\"] = \"<<bio[i]<<endl;\n\t\tsol = max(sol, bio[i]);\n\t}\n\tprintf(\"%d\\n\", sol);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,fst[N],to[N*2],nxt[N*2],l,fa[N],b[N],Ans;\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n}\nvoid dfs(int x)\n{\n\tint tmp=0;\n\tfor (int i=fst[x];i;i=nxt[i])\n\tif (to[i]!=fa[x])\n\t{\n\t\tfa[to[i]]=x;\n\t\tdfs(to[i]);\n\t\ttmp|=b[to[i]];\n\t}\n\tint t=(~tmp)&(-(~tmp));\n\tcout<<t<<endl;\n\tb[x]=tmp^t^(tmp&(t-1));\n\tAns=max(Ans,t);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tdfs(1);\n\tint ans=0;\n\twhile(Ans>1)Ans>>=1,ans++;\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2e5+10;\nint ans,next[N],head[N],t[N],f[N],bz[N],tot; \nvoid ad(int x,int y)\n{\n\ttot++;\n\tnext[tot]=head[x];\n\thead[x]=tot;\n\tt[tot]=y;\n}\nint max(int x,int y)\n{\n\tif (x>y) return x;\n\treturn y;\n}\nint min(int x,int y)\n{\n\tif (x<y) return x;\n\treturn y;\n}\nvoid dfs(int x,int fa)\n{\n\tint i=head[x],l=0;\n\twhile (i)\n\t{\n\t\tif (t[i]==fa) \n\t\t{\n\t\t\ti=next[i];\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(t[i],x);\n\t\tl=l|(bz[x]&bz[t[i]]);\n\t\tbz[x]=bz[x]|bz[t[i]];\n\t\ti=next[i];\n\t} \n\tif (!bz[x]) bz[x]=1;\n\telse \n\t{\n\t\twhile ((1<<f[x])<l||(1<<f[x])&bz[x]) f[x]++;\n\t\tbz[x]=(bz[x]>>f[x]<<f[x])|(1<<f[x]);\n\t}\n\tans=max(ans,f[x]);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tad(x,y);\n\t\tad(y,x);\t\n\t}\n\tdfs(1,0); \n\tprintf(\"%d\\n\",ans); \n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 100010;\n\nstruct Edge{ int to, next;} edge[N * 2];\nint head[N], num;\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\n\nint s[N], ans;\n\nvoid dfs(int x, int f)\n{\n\tint tmp = 0;\n\tRepG(i, x) if (v != f){\n\t\tdfs(v, x);\n\t\tint ts = (s[v] & s[x]), t0 = 20;\n\t\tif (ts) {\n\t\t\twhile (!(ts & (1 << t0))) t0 --; \n\t\t\ttmp = max(tmp, t0 + 1);\n\t\t}\n\t\ts[x] |= s[v];\n\t}\n\t//if (tmp) Rep0(i, tmp - 1) s[x] ^= (1 << i);\n\tfor (int i = tmp; i <= 20; i ++){\n\t\tif (!(s[x] & (1 << i))){\n\t\t\ts[x] = ((s[x] >> i) << i);\n\t\t\ts[x] |= (1 << i), ans = max(ans, i);\n\t\t\tbreak;\n\t\t}\n\t\t//else s[x] ^= (1 << i);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd_edge(a, b); add_edge(b, a);\n\t}\n\t\n\tdfs(1, 0);\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef complex<double> cd;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\nstring Yes[2] = {\"No\\n\", \"Yes\\n\"};\nstring YES[2] = {\"NO\\n\", \"YES\\n\"};\nstring Possible[2] = {\"Impossible\\n\", \"Possible\\n\"};\nstring POSSIBLE[2] = {\"IMPOSSIBLE\\n\", \"POSSIBLE\\n\"};\n\nint ok(int x, int n)\n{\n    return 0 <= x && x < n;\n}\n\nll log10(ll x)\n{\n    if (x < 10) re 1;\n    re 1 + log10(x / 10);\n}\n\nll ds(ll x)\n{\n    if (x < 10) return x;\n    re x % 10 + ds(x / 10);\n}\n\ndouble sqr(double x)\n{\n    return x * x;\n}\n\nbool in(int bit, int mask)\n{\n    return (mask & (1 << bit)) > 0;\n}\n\nvoid Del(vector<int> &v, int pos)\n{\n    swap(v[pos], v[v.size() - 1]);\n    v.pop_back();\n}\n\nlong long g(vector<long long> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nint g(vector<int> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nint __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\ninline void __precompute_combinatorics(int __n)\n{\n    if (__precomputed_combinatorics >= __n)\n        return;\n    __fact.resize(__n);\n    __ufact.resize(__n);\n    __rev.resize(__n);\n    __rev[1] = 1;\n    for (int i = max(2, __precomputed_combinatorics); i < __n; i++)\n        __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = max(1, __precomputed_combinatorics); i < __n; i++)\n        __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n    __precomputed_combinatorics = __n;\n}\n\nll fact(int x)\n{\n    if (__precomputed_combinatorics <= x)\n        __precompute_combinatorics(x + 1);\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n)\n        return 0;\n    if (__precomputed_combinatorics <= n)\n        __precompute_combinatorics(n + 1);\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nstruct dsu\n{\n    vector<int> root;\n    vector<int> sz;\n\n    dsu(int _n)\n    {\n        root.resize(_n);\n        iota(all(root), 0);\n        sz.resize(_n, 1);\n    }\n\n    dsu()\n    {\n        dsu(0);\n    }\n\n    void Reset(int _n)\n    {\n        root.resize(_n);\n        sz.resize(_n);\n        for (int i = 0; i < root.size(); i++)\n        {\n            root[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    void Reset()\n    {\n        Reset(root.size());\n    }\n\n    int Root(int x)\n    {\n        if (x == root[x]) return x;\n        return root[x] = Root(root[x]);\n    }\n\n    void Merge(int v, int u)\n    {\n        v = Root(v), u = Root(u);\n        if (v == u) return;\n        if (sz[v] < sz[u])\n        {\n            sz[u] += sz[v];\n            root[v] = u;\n        }\n        else\n        {\n            sz[v] += sz[u];\n            root[u] = v;\n        }\n    }\n};\n\nstruct dsu_cut\n{\n    vector<int> root;\n    vector<int> sz;\n    stack<int> cuts;\n\n    dsu_cut(int _n)\n    {\n        root.resize(_n);\n        iota(all(root), 0);\n        sz.resize(_n, 1);\n    }\n\n    dsu_cut()\n    {\n        dsu_cut(0);\n    }\n\n    void Cut()\n    {\n        if (!cuts.size()) return;\n        int v = cuts.top();\n        sz[root[v]] -= sz[v];\n        root[v] = v;\n        cuts.pop();\n    }\n\n    void Reset(int _n)\n    {\n        root.resize(_n);\n        sz.resize(_n);\n        for (int i = 0; i < root.size(); i++)\n        {\n            root[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    void Reset()\n    {\n        if (cuts.size() < root.size())\n        {\n            while (cuts.size())\n            {\n                Cut();\n            }\n        }\n        else\n        {\n            Reset(root.size());\n        }\n    }\n\n    int Root(int x)\n    {\n        if (x == root[x]) return x;\n        return Root(root[x]);\n    }\n\n    void Merge(int v, int u)\n    {\n        v = Root(v), u = Root(u);\n        if (v == u) return;\n        if (sz[v] < sz[u])\n        {\n            sz[u] += sz[v];\n            root[v] = u;\n            cuts.push(v);\n        }\n        else\n        {\n            sz[v] += sz[u];\n            root[u] = v;\n            cuts.push(u);\n        }\n    }\n};\n\nvoid bfs(int v, vi &dist, vector<vi> &graph)\n{\n    fill(all(dist), -1);\n    dist[v] = 0;\n    vi q = {v};\n    for (int i = 0; i < q.size(); i++)\n    {\n        for (auto u : graph[q[i]])\n        {\n            if (dist[u] == -1)\n            {\n                dist[u] = dist[q[i]] + 1;\n                q.push_back(u);\n            }\n        }\n    }\n}\n\nvector<int> z_func(string &s)\n{\n    // Calculates z-function of string s\n    // z[0] = s.size(), s should not be empty\n    //\n    // Tested on the following problem:\n    // https://codeforces.com/edu/course/2/lesson/3/3/practice/contest/272263/problem/A\n    //\n    vector<int> z(s.size());\n    z[0] = s.size();\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    return z;\n}\n\nvector<int> p_func(string &s)\n{\n    // Calculates prefix function of string s\n    //\n    //\n    vector<int> p(s.size());\n    for (int i = 1; i < s.size(); i++)\n    {\n        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = p[j - 1];\n        if (s[i] == s[j])\n            j++;\n        p[i] = j;\n    }\n    return p;\n}\n\nvector<int> d1_func(string &s)\n{\n    // Calculates max length of palindrome centered in positions and i for each i\n    //\n    //\n    vector<int> d1(s.size());\n    int L = 0, R = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d1[R - i + L]);\n        while (i + k < s.size() && i - k >= 0 && s[i - k] == s[i + k])\n            k++;\n        d1[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k;\n            R = i + k;\n        }\n    }\n    return d1;\n}\n\nvector<int> d2_func(string &s)\n{\n    // Calculates max length of palindrome centered in positions i - 1 and i for each i\n    //\n    //\n    vector<int> d2(s.size());\n    int L = 0, R = -1;\n    for (int i = 1; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d2[R - i + L + 1]);\n        while (i + k < s.size() && i - k - 1 >= 0 && s[i - k - 1] == s[i + k])\n            k++;\n        d2[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k - 1;\n            R = i + k;\n        }\n    }\n    return d2;\n}\n\nvoid add(int pos, ll x, vector<ll> &fenw)\n{\n    // Performs add query on Fenwick tree\n    //\n    // Tested on the following problem:\n    // https://atcoder.jp/contests/practice2/tasks/practice2_b\n    //\n    while (pos < fenw.size())\n    {\n        fenw[pos] += x;\n        pos |= (pos + 1);\n    }\n}\n\nll get(int pos, vector<ll> &fenw)\n{\n    // Performs get query on Fenwick tree\n    //\n    // Tested on the following problem:\n    // https://atcoder.jp/contests/practice2/tasks/practice2_b\n    //\n    ll res = 0;\n    while (pos >= 0)\n    {\n        res += fenw[pos];\n        pos = (pos & (pos + 1)) - 1;\n    }\n    return res;\n}\n\nstruct dcp_offine{\n    // Given n, m and arrays v, u, t of length m\n    // -1 <= t[i] <= 1 and 0 <= v[i], u[i] < n satisfied for t[i] != -1\n    // t[i] = 0 asks to change state of edge (v[i], u[i])\n    // t[i] = -1 asks to calculate number of connected components\n    // t[i] = 1 asks to check if v[i] and u[i] are in the same connected component\n    // After creating following holds:\n    // ans[i] contains -1 for t[i] = 0 and answer for the i-th query otherwise\n    //\n    // Correctness t[i] <= 0 tested on the following problem:\n    // https://codeforces.com/edu/course/2/lesson/7/3/practice/contest/289392/problem/C\n    // Correctness tested on random tests with m = 40000\n    // Speed tested on random tests with m = 2e6, average = 0.955ms/test (local)\n    //\n    int n, m;\n    dsu_cut dcp;\n    vector<int> ans;\n    void solve(int l, int r, vi &v, vi &u, vi &t, vi &L, vi &R)\n    {\n        if (l >= r) return;\n        if (l + 1 == r)\n        {\n            if (t[l] == -1)\n            {\n                ans[l] = n - dcp.cuts.size();\n            }\n            if (t[l] == 1)\n            {\n                ans[l] = dcp.Root(v[l]) == dcp.Root(u[l]);\n            }\n            return;\n        }\n        int m = (l + r) / 2;\n        int ss = dcp.cuts.size();\n        for (int i = l; i < m; i++)\n        {\n            if (R[i] >= r) dcp.Merge(v[i], u[i]);\n        }\n        solve(m, r, v, u, t, L, R);\n        while (dcp.cuts.size() > ss) dcp.Cut();\n        for (int i = r - 1; i >= m; i--)\n        {\n            if (L[i] < l) dcp.Merge(v[i], u[i]);\n        }\n        solve(l, m, v, u, t, L, R);\n        while (dcp.cuts.size() > ss) dcp.Cut();\n    }\n    dcp_offine(int _n, int _m, vi v, vi u, vi t)\n    {\n        n = _n, m = _m;\n        dcp.Reset(n);\n        ans.resize(m, -1);\n        map<pair<int, int>, int> mm;\n        vi L(m, INF), R(m, -INF);\n        for (int i = 0; i < m; i++)\n        {\n            if (t[i] != 0) continue;\n            if (v[i] > u[i]) swap(v[i], u[i]);\n            if (mm.find({v[i], u[i]}) == mm.end())\n            {\n                mm[{v[i], u[i]}] = i;\n            }\n            else\n            {\n                int t = mm[{v[i], u[i]}];\n                R[t] = i;\n                L[i] = t;\n                mm.erase({v[i], u[i]});\n            }\n        }\n        while (mm.size())\n        {\n            t.push_back(0);\n            ans.push_back(-1);\n            L.push_back(INF);\n            R.push_back(-INF);\n            auto it = mm.begin();\n            pair<int, int> s = (*it).first;\n            int t = (*it).second;\n            R[t] = m;\n            L[m] = t;\n            v.push_back(s.first);\n            u.push_back(s.second);\n            mm.erase(mm.begin());\n            m++;\n        }\n        solve(0, m, v, u, t, L, R);\n    }\n};\n\ntemplate<class T> struct sparse_min{\n    // Returns min on segment [l, r] of predefined array a\n    //\n    // Correctness tested on the following problem:\n    // https://codeforces.com/contest/1304/problem/E\n    // Speed tested on random tests with n = 4e6, q = 4e6, T = int, average = 0.508ms/test (local)\n    // Speed tested on random tests with n = 4e6, q = 4e7, T = int, average = 1.778ms/test (local)\n    //\n    vector<vector<T> > sp;\n    vector<int> H;\n    T get(int l, int r)\n    {\n        int h = H[r - l + 1];\n        return min(sp[h][l], sp[h][r - (1 << h) + 1]);\n    }\n    sparse_min(vector<T> a)\n    {\n        int n = a.size();\n        H = vector<int>(n + 1);\n        for (int i = 3; i < n + 1; i++)\n        {\n            H[i] = H[i - 1] + (((i - 1) & (i - 2)) == 0);\n        }\n        int s = 0;\n        while ((1 << s) < n) s++;\n        sp = vector<vector<T>>(s, vector<T>(n));\n        for (int i = 0; i < n; i++)\n        {\n            sp[0][i] = a[i];\n        }\n        for (int j = 1; j < s; j++)\n        {\n            for (int i = 0; i + (1 << j) - 1 < n; i++)\n            {\n                sp[j][i] = get(i, i + (1 << j) - 1);\n            }\n        }\n    }\n};\n\ntemplate<class T> struct sparse_max{\n    // Returns min on segment [l, r] of predefined array a\n    //\n    // Correctness tested on the following problem:\n    // https://codeforces.com/contest/1304/problem/E\n    // Speed tested on random tests with n = 4e6, q = 4e6, T = int, average = 0.508ms/test (local)\n    // Speed tested on random tests with n = 4e6, q = 4e7, T = int, average = 1.778ms/test (local)\n    //\n    vector<vector<T> > sp;\n    vector<int> H;\n    T get(int l, int r)\n    {\n        int h = H[r - l + 1];\n        return max(sp[h][l], sp[h][r - (1 << h) + 1]);\n    }\n    sparse_max(vector<T> a)\n    {\n        int n = a.size();\n        H = vector<int>(n + 1);\n        for (int i = 3; i < n + 1; i++)\n        {\n            H[i] = H[i - 1] + (((i - 1) & (i - 2)) == 0);\n        }\n        int s = 0;\n        while ((1 << s) < n) s++;\n        sp = vector<vector<T>>(s, vector<T>(n));\n        for (int i = 0; i < n; i++)\n        {\n            sp[0][i] = a[i];\n        }\n        for (int j = 1; j < s; j++)\n        {\n            for (int i = 0; i + (1 << j) - 1 < n; i++)\n            {\n                sp[j][i] = get(i, i + (1 << j) - 1);\n            }\n        }\n    }\n};\n\nstruct scc_graph{\n    // Find Strongly Connected Components of given graph\n    //\n    // Correctness tested on the following problem:\n    // https://atcoder.jp/contests/arc069/tasks/arc069_d\n    //\n    int n;\n    vector<vector<int> > graph;\n    vector<vector<int> > inv_graph;\n    vector<int> fr, to;\n    vector<int> fn;\n    vector<int> vis;\n    vector<int> component;\n    int col;\n    void inv_dfs(int v)\n    {\n        vis[v] = 1;\n        for (auto id : inv_graph[v])\n        {\n            int u = fr[id];\n            if (!vis[u])\n            {\n                inv_dfs(u);\n            }\n        }\n        fn.push_back(v);\n    }\n    void dfs(int v)\n    {\n        component[v] = col;\n        for (auto id : graph[v])\n        {\n            int u = to[id];\n            if (component[u] == -1)\n            {\n                dfs(u);\n            }\n        }\n    }\n    scc_graph(int _n)\n    {\n        n = _n;\n        graph = vector<vector<int> >(n);\n        inv_graph = vector<vector<int> >(n);\n    }\n    void add_edge(int v, int u)\n    {\n        graph[v].push_back(fr.size());\n        inv_graph[u].push_back(fr.size());\n        fr.push_back(v);\n        to.push_back(u);\n    }\n    vector<vector<int> > scc()\n    {\n        vis = vector<int>(n);\n        component = vector<int>(n, -1);\n        fn = {};\n        col = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (!vis[i])\n            {\n                inv_dfs(i);\n            }\n        }\n        reverse(fn.begin(), fn.end());\n        for (auto i : fn)\n        {\n            if (component[i] == -1)\n            {\n                dfs(i);\n                col++;\n            }\n        }\n        vector<vector<int> > res(col);\n        for (int i = 0; i < n; i++)\n        {\n            res[component[i]].push_back(i);\n        }\n        return res;\n    }\n};\n\nint ans;\n\nvector<int> solve(int v, int p, vvi &graph)\n{\n    vector<int> cnt(20);\n    for (auto u : graph[v]) if (u != p)\n    {\n        vector<int> z = solve(u, v, graph);\n        for (int j = 0; j < 20; j++) cnt[j] += z[j];\n    }\n    int sel = -1;\n    for (int j = 0; j < 20; j++)\n    {\n        if (cnt[j] >= 2)\n        {\n            sel = j + 1;\n        }\n    }\n    if (sel != -1)\n    {\n        for (int j = 0; j < sel; j++)\n        {\n            cnt[j] = 0;\n        }\n        ans = max(ans, sel);\n        return cnt;\n    }\n    for (int j = 0; j < 20; j++)\n    {\n        if (cnt[j] == 0)\n        {\n            sel = j;\n            break;\n        }\n    }\n    cnt[sel]++;\n    for (int j = 0; j < sel; j++)\n    {\n        cnt[j] = 0;\n    }\n    ans = max(ans, sel);\n    return cnt;\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    vvi graph(n);\n    forn(i, n - 1)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    solve(0, 0, graph);\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code (MOD, INF, INFLL)\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n \nvi adj[100001];\n/*\nint h[100001];\nll dp[100001];\n \nvoid dfs(int u, int p)\n{\n\tif(p==-1) h[u]=0;\n\telse h[u]=h[p]+1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tif(adj[u][i]==p) continue;\n\t\tdfs(adj[u][i],u);\n\t}\n}\n*/\nconst int N = 1e5 + 3;\n \nint subsize[N];\nbool visited[N];\nint treesize;\nvoid dfs(int u, int par)\n{\n\tsubsize[u] = 1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tdfs(v, u);\n\t\tsubsize[u] += subsize[v];\n\t}\n\ttreesize=subsize[u];\n}\n \nint centroid(int u, int par)\n{\n\tint best = 0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tbest=max(best,subsize[v]);\n\t}\nint bestidx = u;\n\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tint maxsize = treesize-subsize[v];\n\t\tfor(int j = 0; j < adj[v].size(); j++)\n\t\t{\n\t\t\tint w = adj[v][j];\n\t\t\tif(w==u) continue;\n\t\t\tif(visited[w]) continue;\n\t\t\tmaxsize=max(maxsize,subsize[w]);\n\t\t}\n\t\t//if(subsize[v]>treesize-subsize[v]) return centroid(v, u);\n\t\tif(maxsize<best)\n{\nbest=maxsize;\nbestidx=v;\n}\n\n\t}\nif(bestidx==u) return u;\nelse return centroid(bestidx,u);\n\treturn u;\n}\n \nint compsolve(int u)\n{\n\tdfs(u, -1);\n\tint cent = centroid(u, -1);\n\t//cerr<<u<<' '<<cent<<'\\n';\n\tvisited[cent]=1;\n\tint ans = -1;\n\tfor(int i = 0; i < adj[cent].size(); i++)\n\t{\n\t\tint v = adj[cent][i];\n\t\tif(visited[v]) continue;\n\t\tans=max(ans,compsolve(v));\n\t}\n\treturn ans+1;\n}\n \nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tcout<<compsolve(0)<<'\\n';\n\t/*\n\tdp[1] = 2;\n\tfor(int i = 2; i <= 60; i++)\n\t{\n\t\tdp[i] = (dp[i-1]*2+2);\n\t}\n\tdfs(0,-1);\n\tint best = 0; int idx = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t\tidx=i;\n\t\t}\n\t}\n\tdfs(idx,-1);\n\tbest=0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t}\n\t}\n\t//cerr<<best<<'\\n';\n\tfor(int i = 1; i <= 60; i++)\n\t{\n\t\tif(best<=dp[i])\n\t\t{\n\t\t\tcout<<i<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*/\n\t\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nconstexpr int MAX = 20;\n\nclass DUninity {\npublic:\n    int N;\n    vector<vector<int>> E;\n\n    int dfs(int u, int p) {\n        vector<int> CNT(MAX, 0);\n        for (int v: E[u]) if (v != p) {\n            int s = dfs(v, u);\n            for (int i = 0; i < MAX; ++i) {\n                if (s&1<<i) CNT[i]++;\n            }\n        }\n        int ans = MAX;\n        for (int i = MAX-1; i >= 0; --i) {\n            if (CNT[i] >= 2) break;\n            if (CNT[i] == 0) ans = i;\n        }\n        int cur = 1<<ans;\n        for (int i = ans+1; i < MAX; ++i) if (CNT[i] == 1) cur |= 1<<i;\n        return cur;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        E.resize(N);\n        for (int i = 0; i < N - 1; ++i) {\n            int a, b; cin >> a >> b;\n            --a; --b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        cout << logceil(dfs(0, -1)) - 1 << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDUninity solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\nint Adj[MAXN],V[MAXN*2],nxt[MAXN*2],c;\nvoid AddEdge(int u,int v)\n{\n\tc++;V[c]=v,nxt[c]=Adj[u];Adj[u]=c;\n}\nint dp[MAXN][21],n,ans;\nvoid dfs(int u,int p)\n{\n\tfor(int i=Adj[u];i;i=nxt[i])\n\t\tif(V[i]!=p)\n\t\t{\n\t\t\tint v=V[i];\n\t\t\tdfs(v,u);\n\t\t\tfor(int j=0;j<=20;j++)\n\t\t\t\tdp[u][j]+=dp[v][j];\n\t\t}\n\tint k=0;\n\tfor(int i=20;i>=0;i--)\n\t\tif(dp[u][i]>1)\n\t\t{\n\t\t\tk=i+1;\n\t\t\tbreak;\n\t\t}\n\twhile(dp[u][k]) k++;\n\tdp[u][k]++;\n\tfor(int i=0;i<k;i++)\n\t\tdp[u][i]=0;\n\tans=max(ans,k);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tint u,v;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tAddEdge(u,v);\n\t\tAddEdge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 100 * 1000 + 10;\n\nvector<int> g[N];\nbool del[N];\nint size[N];\nint max_s[N];\nvector<int> cur;\nint ans = 0;\n\nvoid dfs(int v, int par) {\n    size[v] = 1;\n    max_s[v] = 0;\n    cur.push_back(v);\n    for (int to : g[v])\n        if (!del[to] && to != par) {\n            dfs(to, v);\n            size[v] += size[to];\n            max_s[v] = max(max_s[v], size[to]);\n        }\n}\n\nvoid build(int st, int curh) {\n    ans = max(ans, curh);\n    cur.clear();\n    dfs(st, st);\n    if (cur.size() == 1)\n        return;\n    int tot = cur.size();\n    vector<int> vs;\n    for (int x : cur)\n        if (max_s[x] * 2 <= tot && (tot - size[x]) * 2 <= tot)\n            vs.push_back(x);\n    random_shuffle(vs.begin(), vs.end());\n    int v = vs[0];\n    del[v] = true;\n    for (int to : g[v])\n        if (!del[to])\n            build(to, curh + 1); \n}\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);    \n    }\n    int res = n - 1;\n    for (int rep = 0; rep < 15; rep++) {\n        fill(del, del + n, false);\n        ans = 0;\n        build(0, 0);\n        res = min(res, ans);        \n    }\n    cout << res << endl;\n}   "
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\ntemplate< typename T >\nstruct edge{\n    int from, to;\n    T cost;\n    edge(int to,T cost) : from(-1), to(to), cost(cost){}\n    edge(int from,int to,T cost) : from(from), to(to), cost(cost){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const{ return to;}\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedTree = vector< Edges<T>>;\nusing tree = vector< vector<int> >;\n\ntree make(int n,int offset = 1){\n    tree res(n);\n    for(int i = 0;i < n-1; i++){\n        int a,b; cin >> a >> b;\n        a -= offset,b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate< typename T >\nWeightedTree<T> make2(int n, int offset = 1){\n    WeightedTree<T> res(n);\n    for(int i = 0;i < n-1 ; i++){\n        int a,b ; cin >> a >> b;\n        a -= offset, b -= offset;\n        T c; cin >> c;\n        res[a].emplace_back(b,c);\n        res[b].emplace_back(a,c);\n    }\n    return res;\n}\n\nvector<int> Centers(vector<set<int>> &g,int idx = 0){\n    vector<int> res;\n    int max_depth = -1, leaf;\n    auto dfs = [&](auto &&self,int x,int p,int d)->bool{\n        bool flag = false;\n        if(max_depth < d){\n            max_depth = d, leaf = x, flag = true;\n            res.clear();\n        }\n        for(auto e:g[x]){\n            if(e != p)\n            flag |= self(self,e,x,d+1);\n        }\n        if(flag and (d == (max_depth>>1) or d == ((max_depth+1)>>1))) {\n            res.emplace_back(x);\n        }\n        return flag;\n    };\n    dfs(dfs,idx,-1,0);\n    max_depth = -1;\n    dfs(dfs,leaf,-1,0);\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    INT(n);\n    vector<set<int>> g(n);\n    rep(i,n-1){\n        int a=in()-1,b=in()-1;\n        g[a].emplace(b);g[b].emplace(a);\n    }\n    auto solve = [&](auto &&self,int x) -> int{\n        if(g[x].size() == 0) return 0;\n        auto centers = Centers(g,x);\n        int res = 0;\n        if(centers.size() == 1){\n            int center = centers.back();\n            for(auto e:g[center]){\n                g[e].erase(center);\n                chmax(res,self(self,e));\n                g[e].emplace(center);\n            }\n            return res + 1;\n        }\n        else{\n            int a = centers[0],b = centers[1];\n            g[a].erase(b);\n            g[b].erase(a);\n            int A = self(self,a);\n            int B = self(self,b);\n            for(auto e:g[a]){\n                g[e].erase(a);\n                chmax(B,self(self,e));\n                g[e].emplace(a);\n            }\n            for(auto e:g[b]){\n                g[e].erase(b);\n                chmax(A,self(self,e));\n                g[e].emplace(b);\n            }\n            g[a].emplace(b);\n            g[b].emplace(a);\n            return min(A,B) + 1;\n        }\n    };\n    cout << solve(solve,0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nint N;\nvector <int> E[100010];\nint ans, d[100010];\n\nvoid dfs(int x, int fa){\n\tint X = 0;\n\tvector <int> v;\n\tfor(int e : E[x])if(e != fa){\n\t\tdfs(e, x);\n\t\tv.pb(d[e]);\n\t\tX |= d[e];\n\t}\n\tsort(all(v)); reverse(all(v));\n\tif(sz(v) == 0){\n\t\td[x] = 1;\n\t\treturn;\n\t}\n\tint s = 0;\n\tfor(int i=19;i>=0;i--)if(1<<i & X){s = i; break;}\n\tint cnt = 0;\n\tfor(int e : v)if(1<<s & e)cnt++;\n\tif(cnt > 1){\n\t\td[x] = 1<<(s+1);\n\t\treturn;\n\t}\n\tfor(int i=0;i<s;i++)if(!(v[0] & 1<<i)){\n\t\tint cnt = 0;\n\t\tfor(int e : v)if((1<<i) > e)cnt++;\n\t\tif(cnt == sz(v) - 1){\n\t\t\tfor(int j=s;j>i;j--)if(v[0] & 1<<j)d[x] |= 1<<j;\n\t\t\td[x] |= 1<<i;\n\t\t\treturn;\n\t\t}\n\t}\n\td[x] = 1<<(s+1);\n}\n\nvoid solve(){\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<N;i++){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tE[x].pb(y);\n\t\tE[y].pb(x);\n\t}\n\tdfs(1, -1);\n\tfor(int i=19;i>=0;i--)if(1<<i & d[1]){\n\t\tprintf(\"%d\\n\", i);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tint Tc = 1; // scanf(\"%d\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint head[100001], next[199999], to[199999], f[100001], q[100001], fa[100001], N, E;\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, u, v; i < N; i++)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tnext[++E] = head[u], to[E] = v, head[u] = E;\n\t\tnext[++E] = head[v], to[E] = u, head[v] = E;\n\t}\n\tint H = 0, T = 1, u;\n\tq[1] = 1;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\tfor (int i = N; i; i--)\n\t{\n\t\tint u = q[i];\n\t\tfor (int e = head[u]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t\tf[u] = std::max(f[u], f[to[e]]);\n\t\tf[u]++;\n\t}\n\tint O = 0;\n\twhile (2 << O <= f[1])\n\t\tO++;\n\tprintf(\"%d\\n\", O);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n \nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n \nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n \n \nint n;\nvector<int> adj[100005];\n \n \nint dp(int v, int par){\n\n\tint cnt[30] = {0};\n\tfor(auto vv : adj[v])\n\t\tif(vv != par){\n\t\t\tint mask = dp(vv, v);\n\t\t\tfor(int i=0;i<30;i++)\n\t\t\t\tif((mask >> i) & 1)\n\t\t\t\t\tcnt[i]++;\n\t\t}\n\n\t//read editorial\n\t//mask denotes all labels visible from v\n\t//if atleast 2 children have v contribute to label x being visible \n\t//from v, then label(v) should be atleast x+1\n\n\tint atleast = 0;\n\tfor(int i=0;i<30;i++)\n\t\tif(cnt[i] >= 2)\n\t\t\tatleast = i;\n\twhile(atleast < 30 && cnt[atleast] > 0)\n\t\tatleast++;\n\tcnt[atleast]++;\n\n\tint ans = 0;\n\twhile(atleast < 30){\n\t\tif(cnt[atleast] > 0)\n\t\t\tans |= (1<<atleast);\n\t\tatleast++;\n\t}\n\n\treturn ans;\n}\n \n\n\n \nint main(){\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n \n    cin>>n;\n    int e = n-1;\n    while(e--){\n    \tint a, b;\n    \tcin>>a>>b;\n    \tadj[a].pb(b);\n    \tadj[b].pb(a);\n    }\n \n    int ans = dp(1, -1);\n    for(int i=30;i>=0;i--)\n    \tif((ans >> i) & 1){\n    \t\tcout<<i;\n    \t\treturn 0;\n    \t}\n \n    return 0;\n}\n \n \n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint cnt,head[N],n,u,v,Cnt[N][20],ans;\nstruct node{int to,next;}num[N<<1];\nvoid add(int x,int y)\n{\n\tnum[++cnt].to=y;num[cnt].next=head[x];head[x]=cnt;\n}\nvoid dfs(int x,int fa)\n{\n\tfor (int i=head[x];i;i=num[i].next)\n\t  if (num[i].to!=fa) {\n\t     dfs(num[i].to,x);\n\t     for (int j=0;j<20;j++)\n\t       Cnt[x][j]+=Cnt[num[i].to][j];   \n\t  }\n\tint Min=0;\n\tfor (int j=19;j>=0;j--) if (Cnt[x][j]>=2) {Min=j+1;break;}\n\twhile (Cnt[x][Min]) Min++;\n\tCnt[x][Min]=1;\n\tans=max(ans,Min);\n\tfor (int j=0;j<Min;j++) Cnt[x][j]=0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++) scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tdfs(1,-1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 10000;\n\nint n;\nvector<int> edg[MAXN];\nint f[MAXN], v[MAXN];\n\nvoid dfs(int x, int fa)\n{\n\tf[x] = 0, v[x] = 0;\n\tint cover = 0;\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(edg[x][i] != fa)\n\t\t{\n\t\t\tint y = edg[x][i];\n\t\t\tdfs(y, x);\n\t\t\tcover |= f[y] & f[x];\n\t\t\tf[x] |= f[y];\n\t\t}\n\twhile((1 << v[x]) < cover || (f[x] & (1 << v[x])))\n\t\tv[x]++;\n\tf[x] &= ~((1 << v[x]) - 1);\n\tf[x] |= 1 << v[x];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tedg[x].push_back(y), edg[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tans = max(ans, v[i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 100010;\n\nstruct Edge{ int to, next;} edge[N * 2];\nint head[N], num;\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\n\nint s[N], ans;\n\nvoid dfs(int x, int f)\n{\n\tint tmp = 0;\n\tRepG(i, x) if (v != f){\n\t\tdfs(v, x);\n\t\tint ts = (s[v] & s[x]), t0 = 20;\n\t\tif (ts) {\n\t\t\twhile (!(ts & (1 << t0))) t0 --; \n\t\t\ttmp = max(tmp, t0 + 1);\n\t\t}\n\t\ts[x] |= s[v];\n\t}\n\tif (tmp) Rep0(i, tmp - 1) s[x] ^= (1 << i);\n\tfor (int i = tmp; i <= 20; i ++){\n\t\tif (!(s[x] & (1 << i))){\n\t\t\ts[x] |= (1 << i), ans = max(ans, i);\n\t\t\tbreak;\n\t\t}\n\t\telse s[x] ^= (1 << i);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd_edge(a, b); add_edge(b, a);\n\t}\n\t\n\tdfs(1, 0);\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 100;\n\nvector<int> adj[N];\nint d[N];\nint n, mx;\n\nvoid dfs(int v, int p) {\n\tfor (auto u : adj[v]) {\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\td[u] = d[v] + 1;\n\t\tdfs(u, v);\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tadj[--v].push_back(--u);\n\t\tadj[u].push_back(v);\n\t}\n\tdfs(0, 0);\n\tfor (int i = 0; i < n; i++)\n\t\tif (d[i] > d[mx])\n\t\t\tmx = i;\n\tmemset(d, 0, sizeof d);\n\tdfs(mx, mx);\n\tmx = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tmx = max(mx, d[i]);\n\tmx++;\n\treturn cout << (mx / 3) + ((mx % 3) > 0), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tUL N; cin >> N;\n\t\tvector<vector<UL>> E(N);\n\t\trep(i, N - 1) {\n\t\t\tUL a, b; cin >> a >> b; a--; b--;\n\t\t\tE[a].push_back(b); E[b].push_back(a);\n\t\t}\n\t\tvector<UL> q;\n\t\tvector<bool> flag(N);\n\t\tstack<UL> q2;\n\t\tvector<UL> P(N);\n\t\tq2.push(0);\n\t\twhile (q2.size()) {\n\t\t\tUL p = q2.top(); q2.pop();\n\t\t\tq.push_back(p); flag[p] = true;\n\t\t\tfor (UL e : E[p]) {\n\t\t\t\tif (flag[e]) P[p] = e;\n\t\t\t\telse q2.push(e);\n\t\t\t}\n\t\t}\n\t\tvector<UL> dp(N);\n\t\tUL ans = 0;\n\t\treverse(q.begin(), q.end());\n\t\tq.pop_back();\n\t\trep(i, q.size()) {\n\t\t\tUL p = q[i];\n\t\t\tUL d = dp[p] + 1;\n\t\t\tans = max(ans, dp[P[p]] + d);\n\t\t\tdp[P[p]] = max(dp[P[p]], d);\n\t\t}\n\t\tUL M = 0;\n\t\tUL uninity = 0;\n\t\twhile (M < ans) { M = M * 2 + 2; uninity++; }\n\t\tcout << uninity << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 100011\n#define inf (17 * maxN)\n\n\nconst int mask = (1 << 30) - 1;\n\nint n, i, x, y;\nvector<int> list[maxN];\nint conf[maxN];\n\nvoid solve(int node, int root) {\n    int mand, mor, pos;\n\n    mand = 0;\n    mor = 0;\n\n    for (auto to : list[node]) {\n        if (to == root) continue;\n        solve(to, node);\n\n        mand |= (mor & conf[to]);\n        mor |= conf[to];\n    }\n\n\n    for (pos = 0; (1 << pos) <= mand; pos++);\n    for (; (1 << pos) & mor; pos++);\n\n    mor |= 1 << pos;\n    for (pos--; pos >= 0; pos--) mor &= mask ^ (1 << pos);\n    conf[node] = mor;\n}\n\nint main()\n{\n    //freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\", &n);\n    for (i = 1; i < n; i++) {\n        scanf(\"%d%d\", &x, &y);\n        list[x].pb(y);\n        list[y].pb(x);\n    }\n\n    solve(1, 0);\n\n    int ans = 0;\n    for (; (1 << ans) <= conf[1]; ans++);\n\n    printf(\"%d\", ans - 1);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nvector<int> g[101010];\nint d[101010];\nint del[101010];\n\nint md=0;\n\nvoid dfs1(int x, int p){\n\td[x]=0;\n\tfor (int nx:g[x]){\n\t\tif (del[nx]) continue;\n\t\tif (nx!=p){\n\t\t\tdfs1(nx, x);\n\t\t\tmd=max(md, d[x]+d[nx]+1);\n\t\t\td[x]=max(d[x], d[nx]+1);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x, int p, int pd, vector<int>& cdv){\n\tint d1=pd;\n\tint d2=0;\n\tint d1v=0;\n\tfor (int nx:g[x]){\n\t\tif (del[nx]) continue;\n\t\tif (nx!=p){\n\t\t\tif (d[nx]+1>d1){\n\t\t\t\td2=d1;\n\t\t\t\td1=d[nx]+1;\n\t\t\t\td1v=nx;\n\t\t\t}\n\t\t\telse if(d[nx]+1>d2){\n\t\t\t\td2=d[nx]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif (d1+d2==md&&min(d1, d2)>=md/2){\n\t\tcdv.push_back(x);\n\t}\n\tfor (int nx:g[x]){\n\t\tif (del[nx]) continue;\n\t\tif (nx!=p){\n\t\t\tif (d1v==nx){\n\t\t\t\tdfs2(nx, x, d2+1, cdv);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdfs2(nx, x, d1+1, cdv);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(int x){\n\tmd=0;\n\tdfs1(x, 0);\n\tvector<int> cdv;\n\tif (md==0) return 0;\n\tif (md<=2) return 1;\n\tdfs2(x, 0, 0, cdv);\n\tassert((int)cdv.size()<=2);\n\tassert((int)cdv.size()>=1);\n\tif (cdv.size()==1){\n\t\tdel[cdv[0]]=1;\n\t\tint v=0;\n\t\tfor (int nx:g[cdv[0]]){\n\t\t\tif (!del[nx]){\n\t\t\t\tv=max(v, solve(nx)+1);\n\t\t\t}\n\t\t}\n\t\tdel[cdv[0]]=0;\n\t\treturn v;\n\t}\n\telse{\n\t\tdel[cdv[0]]=1;\n\t\tint v1=0;\n\t\tfor (int nx:g[cdv[0]]){\n\t\t\tif (!del[nx]){\n\t\t\t\tv1=max(v1, solve(nx)+1);\n\t\t\t}\n\t\t}\n\t\tdel[cdv[0]]=0;\n\t\tdel[cdv[1]]=1;\n\t\tint v2=0;\n\t\tfor (int nx:g[cdv[1]]){\n\t\t\tif (!del[nx]){\n\t\t\t\tv2=max(v2, solve(nx)+1);\n\t\t\t}\n\t\t}\n\t\tdel[cdv[1]]=0;\n\t\treturn min(v1, v2);\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor (int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint v=solve(1);\n\tcout<<v<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/hash_map>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define REP(i,n) for( (i)=0 ; (i)<(n) ; (i)++ )\n#define rep(i,x,n) for( (i)=(x) ; (i)<(n) ; (i)++ )\n#define REV(i,n) for( (i)=(n) ; (i)>=0 ; (i)-- )\n#define FORIT(it,x) for( (it)=(x).begin() ; (it)!=(x).end() ; (it)++ )\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define rforeach(it,c) for(__typeof((c).rbegin()) it=(c).rbegin();it!=(c).rend();++it)\n#define foreach2d(i, j, v) foreach(i,v) foreach(j,*i)\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define SZ(x) ((int)(x).size())\n#define MMS(x,n) memset(x,n,sizeof(x))\n#define mms(x,n,s) memset(x,n,sizeof(x)*s)\n#define pb push_back\n#define mp make_pair\n#define NX next_permutation\n#define UN(x) sort(all(x)),x.erase(unique(all(x)),x.end())\n#define CV(x,n) count(all(x),(n))\n#define FIND(x,n) find(all(x),(n))-(x).begin()\n#define ACC(x) accumulate(all(x),0)\n#define PPC(x) __builtin_popcountll(x)\n#define LZ(x) __builtin_clz(x)\n#define TZ(x) __builtin_ctz(x)\n#define mxe(x) *max_element(all(x))\n#define mne(x) *min_element(all(x))\n#define low(x,i) lower_bound(all(x),i)\n#define upp(x,i) upper_bound(all(x),i)\n#define NXPOW2(x) (1ll << ((int)log2(x)+1))\n#define PR(x) cout << #x << \" = \" << (x) << endl ;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\n\nconst int OO = (int) 2e9;\nconst double eps = 1e-9;\n\nconst int N = 300005;\n\nint n;\nvi adj[N];\nint root, tot, ans;\nint h[N];\nbool vis[N];\n\nvoid dfs(int cur, int par = -1, int len = 0) {\n\th[cur] = len;\n\tfor (auto to : adj[cur]) {\n\t\tif (vis[to] || to == par)\n\t\t\tcontinue;\n\t\tdfs(to, cur, len + 1);\n\t}\n}\n\nint getMaxNode(int cur, int par = -1) {\n\tint res = cur;\n\tfor (auto to : adj[cur]) {\n\t\tif (vis[to] || to == par)\n\t\t\tcontinue;\n\t\tint nxt = getMaxNode(to, cur);\n\t\tif (h[res] < h[nxt])\n\t\t\tres = nxt;\n\t}\n\treturn res;\n}\n\nint center(int cur, int par = -1) {\n\tif (h[cur] == tot / 2)\n\t\treturn cur;\n\tint res = -1;\n\tfor (auto to : adj[cur]) {\n\t\tif (vis[to] || to == par)\n\t\t\tcontinue;\n\t\tres = max(res, center(to, cur));\n\t\tif (res != -1)\n\t\t\treturn res;\n\t}\n\treturn res;\n}\n\nvoid solve(int cur, int curK = 1) {\n\tans = max(ans, curK);\n\tdfs(cur);\n\tint n1 = getMaxNode(cur);\n\tdfs(n1);\n\tn1 = getMaxNode(n1);\n\ttot = h[n1];\n\troot = center(n1);\n\tvis[root] = 1;\n\tfor (auto to : adj[root]) {\n\t\tif (vis[to])\n\t\t\tcontinue;\n\t\tsolve(to, curK + 1);\n\t}\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"rt\", stdin);\n//\tfreopen(\"out.txt\", \"wt\", stdout);\n#endif\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint f, t;\n\t\tcin >> f >> t;\n\t\tf--, t--;\n\t\tadj[f].pb(t);\n\t\tadj[t].pb(f);\n\t}\n\tsolve(0);\n\tcout << ans - 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<map>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define NMAX 100005\n#define MOD 1000000007\n\nvector<int> tree[NMAX];\nint n, viz[NMAX], viz2[NMAX], marked[NMAX], dp[NMAX];\n\nint getCentroid(int node, int sizeTree){\n    viz[node] = sizeTree;\n    dp[node] = 1;\n    int lim = tree[node].size(), ok = 1, ans = 0;\n    for(int i = 0; i < lim; i++){\n        int vec = tree[node][i];\n        if(marked[vec]){\n            tree[node][i] = tree[node][lim - 1];\n            tree[node].pop_back();\n            i--;\n            lim--;\n            continue;\n        }\n        if(viz[vec] != sizeTree){\n            int poss = getCentroid(vec, sizeTree);\n            if(poss)\n                ans = poss;\n            if(dp[vec] > sizeTree / 2)\n                ok = 0;\n            dp[node] += dp[vec];\n        }\n    }\n    if(ok && sizeTree - dp[node] <= sizeTree / 2)\n        return node;\n    return ans;\n}\n\nvoid dfsUpd(int node, int sizeTree){\n    viz2[node] = sizeTree;\n    dp[node] = 1;\n    int lim = tree[node].size();\n    for(int i = 0; i < lim; i++){\n        int vec = tree[node][i];\n        if(viz2[vec] != sizeTree){\n            dfsUpd(vec, sizeTree);\n            dp[node] += dp[vec];\n        }\n    }\n  // printf(\"am curatat %d %d\\n\", node, dp[node]);\n}\n\nint uninity(int root, int sizeTree){\n    //printf(\"Arbore %d %d\\n\", root, sizeTree);\n    int center = getCentroid(root, sizeTree);\n    //printf(\"Centru in %d\\n\", center);\n    dfsUpd(center, sizeTree);\n    int lim = tree[center].size();\n    int answer = 0;\n    marked[center] = 1;\n    for(int i = 0; i < lim; i++){\n        answer = max(answer, uninity(tree[center][i], dp[tree[center][i]]));\n    }\n    //printf(\"uninity de %d %d este %d\\n\", root, sizeTree, answer + 1);\n    return answer + 1;\n}\n\nint main (){\n    int a, b;\n    \n    scanf(\"%d\",&n);\n    for(int i = 1; i < n; i++){\n        scanf(\"%d%d\",&a,&b);\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n    printf(\"%d\\n\", uninity(1, n) - 1);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int NV=202020;\nint N;\nvector<int> E[NV];\nint ret;\n\nint dfs(int cur,int pre) {\n\tint cnt[32]={};\n\tint mi=-1;\n\tint mask=0,i;\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tint tr = dfs(r,cur);\n\t\tmask |= tr;\n\t\tFOR(i,30) if(tr&(1<<i)) {\n\t\t\tcnt[i]++;\n\t\t\tif(cnt[i]>=2) mi=max(mi,i);\n\t\t}\n\t}\n\tmi++;\n\twhile(cnt[mi]) mi++;\n\tmask |= 1<<mi;\n\t\n\tret=max(ret,mi);\n\t\n\tmask &= ~((1<<mi)-1);\n\treturn mask;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tdfs(0,-1);\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,oo=1e18,N=1e5+100;\n\nvi g[N], f[N];\n\nnamespace centroid{\n    int sz[N];\n    bool used[N];\n\n    void dfs(int v, int pr){\n        sz[v]=1;\n        for(auto to:g[v]){\n            if(to==pr||used[to])\n                continue;\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n\n    int find_centroid(int v, int pr, int k){\n        for(auto to:g[v]){\n            if(to==pr||used[to])\n                continue;\n            if(sz[to]>=k/2)\n                return find_centroid(to,v,k);\n        }\n        return v;\n    }\n\n\n    void build_centroid(int v, int parent){\n        dfs(v,v);\n        int centroid=find_centroid(v,v,sz[v]);\n        used[centroid]=true;\n        f[parent].push_back(centroid);\n        for(auto to:g[centroid]){\n            if(!used[to])\n                build_centroid(to,centroid);\n        }\n    }\n}\n\nint lol[N];\n\nint ans=0;\nvoid kek_dfs(int v, int u){\n    inmax(ans,u);\n    for(auto to:f[v]){\n        kek_dfs(to,u+1);\n    }\n}\n\nvoid smain() {\n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++){\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    centroid::build_centroid(1,0);\n    int y=f[0][0];\n    kek_dfs(y,0);\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int N=100005;\n\nstruct E{\n\tint to,next;\n}mem[N<<1];\nint num,n,x,y,ans;\nint head[N],f[N][22];\n\nvoid add(int x,int y){\n\tnum++;\n\tmem[num].to=y; mem[num].next=head[x];\n\thead[x]=num;\n}\n\nvoid dfs(int k,int pre){\n\tint j,u,i,lim; lim=0;\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre) continue;\n\t\tdfs(u,k);\n\t\tfor (i=0;i<=20;i++) f[k][i]+=f[u][i];\n\t}\n\tfor (i=0;i<=20;i++)\n\t\tif (f[k][i]>1) lim=i+1;\n\twhile (f[k][lim]) lim++;\n\tfor (i=0;i<lim;i++) f[k][i]=0;\n\tf[k][lim]++;\n\tans=max(ans,lim);\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,oo=1e18,N=1e5+100;\n\nvi g[N], f[N];\n\nnamespace centroid{\n    int sz[N];\n    bool used[N];\n\n    void dfs(int v, int pr){\n        sz[v]=1;\n        for(auto to:g[v]){\n            if(to==pr||used[to])\n                continue;\n            dfs(to,v);\n            sz[v]+=sz[to];\n        }\n    }\n\n    int find_centroid(int v, int pr, int k){\n        for(auto to:g[v]){\n            if(to==pr||used[to])\n                continue;\n            if(sz[to]>k/2)\n                return find_centroid(to,v,k);\n        }\n        return v;\n    }\n\n\n    void build_centroid(int v, int parent){\n        dfs(v,v);\n        int centroid=find_centroid(v,v,sz[v]);\n        used[centroid]=true;\n        f[parent].push_back(centroid);\n        for(auto to:g[centroid]){\n            if(!used[to])\n                build_centroid(to,centroid);\n        }\n    }\n}\n\nint lol[N];\n\nint ans=0;\nvoid kek_dfs(int v, int u){\n    inmax(ans,u);\n    for(auto to:f[v]){\n        kek_dfs(to,u+1);\n    }\n}\n\nvoid smain() {\n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++){\n        int a,b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n\n    centroid::build_centroid(1,0);\n    int y=f[0][0];\n    kek_dfs(y,0);\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "/*\ncontest <- \"AtCoder Grand Contest 009\",\ntask <- \"D - Uninity\".\n*/\n#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 100005;\nconst int KMAX = 30;\nvector<int> G[NMAX];\ntemplate<typename Type>\nvoid showContent(Type input)\n{\n\tfor(auto iterator=input.begin(); iterator!=input.end(); ++iterator)\n\t{\n\t\tcout<<(*iterator)<<\", \";\n\t}\n\treturn;\n}\narray<int, KMAX> dfs(int node, int prev) {\n    array<int, KMAX> ret;\n    fill(ret.begin(), ret.end(), 0);\n    ret[0] = 1;\n    for (int to: G[node]) {\n        if (to != prev) {\n            array<int, KMAX> son = dfs(to, node);\n            //->\n            //cout<<\"Next Is Not Equal To Previous <- <- Next Is Not Equal To Previous\"<<endl;\n            /*\n          \tcout<<\"Current point node <- \"<<node<<\", prev <- \"<<prev<<\", to <- \"<<to<<endl;\n            cout<<\"son <- \";\n            showContent(son);\n            cout<<endl;\n            */\n    \t\t//cout<<\"Next Is Not Equal To Previous <- <- Next Is Not Equal To Previous\"<<endl<<endl<<endl;\n            //<-\n            for (int i = 0; i < KMAX; ++i) {\n                ret[i] += son[i];\n            }\n            //->\n            /*\n          \tcout<<\"ret <- \";\n            showContent(ret);\n            cout<<endl;\n            cout<<\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n\t\t\t*/\n\t\t\t//<-\n        }\n    }\n    for (int i = KMAX - 1; i >= 0; --i) {\n    //for(int i=0; i<KMAX; ++i)\n    //{\n        if (ret[i] > 1) {\n            fill(ret.begin(), ret.begin() + i + 1, 0);\n            for (int j = i + 1; j < KMAX; ++j) {\n                //->\n                //cout<<\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n                /*\n              \tcout<<\"node <- \"<<node<<\", prev <- \"<<prev<<endl;\n                cout<<\"i <- \"<<i<<\", j <- \"<<j<<endl;\n                */\n                //cout<<\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n                //<-\n                if (ret[j] > 0) {\n                    ret[j] = 0;\n                } else {\n                    ret[j] = 1;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    //->\n  \t/*\n  \tcout<<\"node <- \"<<node<<\", prev <- \"<<prev<<endl;\n    cout<<\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\"<<endl;\n    */\n    //<-\n  \treturn ret;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    array<int, KMAX> ans = dfs(1, -1);\n    int fans = 0;\n    for (int i = 0; i < KMAX; ++i) {\n        if (ans[i] > 0) {\n            fans = i;\n        }\n    }\n    cout<<fans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\nnamespace IO {\n    template <typename _T>\n    inline bool read (_T& x) {\n        x = 0;\n        _T y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return false;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return true;\n    }\n\n    template <typename _T>\n    inline _T input () {\n        _T x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        x *= y;\n        return x;\n    }\n};\nusing namespace IO;\n\nnamespace modular {\n    const int MOD = 1000000007;\n\n    inline int add (int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n\n    inline void inc (int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n\n    inline int mul (int x, int y) { return 1LL * x * y % MOD; }\n\n    inline int qpow (int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x)) if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};\n\n#define reg register\n#define MAX_N 200007\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\n#define lep(i, l, r) for(int i = l; i < r; ++i)\n#define irep(i, r, l) for(int i = r; i >= l; --i)\n#define ilep(i, r, l) for(int i = r; i > l; --i)\ntypedef long long ll;\n\nint N, res;\nint head[MAX_N], to[MAX_N << 1], nxt[MAX_N << 1], cap;\nint ban[MAX_N];\n\ninline void addE (int u, int v) {\n    nxt[++cap] = head[u];\n    head[u] = cap;\n    to[cap] = v;\n}\n\nvoid dfs (int x, int las) {\n    int t = 0, y = 0, z = 0;\n    for (int i = head[x]; i; i = nxt[i]) if (to[i] != las) {\n        dfs(to[i], x);\n        z |= (t & ban[to[i]]);\n        t |= ban[to[i]];\n        ban[x] |= ban[to[i]];\n    }\n    int lb = 0, pos = 0;\n    rep (i, 0, 30) if (z >> i & 1) pos = i + 1;\n    rep (i, pos, 30) if (!(ban[x] >> i & 1)) { lb = i; break; }\n    rep (i, 0, lb - 1) if (ban[x] >> i & 1) ban[x] ^= (1 << i);\n    ban[x] |= (1 << lb);\n    // printf(\"%d %d %d %d\\n\", x, lb, ban[x], pos);\n    res = std::max(res, lb);\n}\n\nint main () {\n#ifdef LOCAL\n    FIN(\"in\");\n#endif\n    read(N);\n    int u, v;\n    rep (i, 2, N) {\n        read(u), read(v);\n        addE(u, v);\n        addE(v, u);\n    }\n    dfs(1, 0);\n    printf(\"%d\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\nconst int N=100500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint B[2*N][2],A[N],B0;\nint dp[N];\nbool z[N];\nvoid link(int q,int w)\n{\n\tB[++B0][0]=A[q],A[q]=B0,B[B0][1]=w;\n\tB[++B0][0]=A[w],A[w]=B0,B[B0][1]=q;\n}\nvoid dfsf(int q,int c,int fa)\n{\n\tdp[q]=1;\n\tefo(i,q)if(B[i][1]!=fa&&!z[B[i][1]])dfsf(B[i][1],c+1,q),dp[q]=max(dp[q],dp[B[i][1]]+1);\n}\nint zx,zx1;\nvoid dfs(int q,int mx,int fa)\n{\n\t++mx;\n\tint mx1=0,mxz=0;\n\tefo(i,q)if(B[i][1]!=fa&&!z[B[i][1]])\n\t{\t\n\t\tif(dp[B[i][1]]>mx)mx1=mx,mx=dp[B[i][1]],mxz=B[i][1];\n\t\telse if(dp[B[i][1]]>mx1)mx1=dp[B[i][1]];\n\t}\n\tif(zx1>mx)zx1=mx,zx=q;\n\tefo(i,q)if(B[i][1]!=fa&&!z[B[i][1]])dfs(B[i][1],(mxz==B[i][1]?mx1:mx),q);\n}\nvoid divide(int q,int ansc)\n{\n\tans=max(ans,ansc);\n\tdfsf(q,1,0);zx1=1e9;\n\tdfs(q,-1,0);q=zx;\n\tz[q]=1;\n\t// printf(\"%d  %d\\n\",q,ansc);\n\tefo(i,q)if(!z[B[i][1]])divide(B[i][1],ansc+1);\n}\nint main()\n{\n\tint q,w;\n\tread(n);\n\tfo(i,1,n-1)read(q),read(w),link(q,w);\n\tdivide(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n \nint n,flag[100100][20],ans;\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[200100],*tp=pool,*fst[100100];\n \nvoid dfs(int x,int fa)\n{\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->v!=fa)\n            dfs(i->v,x);\n    int w=0;\n    repu(i,0,ans)\n        if (flag[x][i]>1)\n            w=i+1;\n    for (; flag[x][w]; ++w);\n    ans=max(ans,w),++flag[fa][w];\n    repu(i,w+1,ans)\n        if (flag[x][i])\n            ++flag[fa][i];\n}\n \nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n-1)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        *tp=(edge){v,fst[u]},fst[u]=tp++;\n        *tp=(edge){u,fst[v]},fst[v]=tp++;\n    }\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e5+5,LG=19,SM=600+5,inf=1e18+1;\nll mod=1e9+7;\n\nll n;\nvll g[M];\n\nll pn;\nll sz[M],par[M];\nbool mark[M];\n\nvoid dfs(ll x)\n{\n    sz[x]=1;\n    for (ll y:g[x])\n    {\n        if (mark[y] || y==par[x]) continue;\n        par[y]=x;\n        dfs(y);\n        sz[x]+=sz[y];\n    }\n}\n\nll cent(ll x)\n{\n    pll mx={0,-1};\n    for (ll y:g[x])\n    {\n        if (mark[y] || y==par[x]) continue; \n        smax(mx,make_pair(sz[y],y));        \n    }\n    if (mx.X<pn) return x;\n    return cent(mx.Y);\n}\n\nll bcent(ll x)\n{\n    if (mark[x]) return 0;\n    par[x]=x;\n    dfs(x);\n    if (sz[x]==1) return 0;\n    pn=sz[x]/2+sz[x]%2;\n    x=cent(x);\n    //ER(x);\n    mark[x]=1;\n    ll mx=0;\n    for (ll y:g[x])\n    {\n        smax(mx,bcent(y));\n    }\n    //ER(x);\n    return mx+1;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n;\n    For(i,1,n)\n    {\n        ll a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].PB(b);g[b].PB(a);\n    }\n    cout << bcent(0);\n}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--)\nusing namespace std;\nconst int N = 100010;\n\nstruct edge{ int to, pre; }e[N << 1]; int u[N], l = 0;\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\n\nint w[N], ans = 0;\nvoid dfs(int x, int f) {\n\tw[x] = 0; int cnt[19]; rep(i,0,18) cnt[i] = 0;\n\treg(i,x) if (v != f) { dfs(v, x); rep(j,0,18) if (w[v] >> j & 1) cnt[j]++; }\n\tint t = 0; dep(i,18,0) if (!cnt[i]) t = i; else if (cnt[i] >= 2) break;\n\tans = max(ans, t);\n\tw[x] = 1 << t; rep(i,t + 1,18) if (cnt[i]) w[x] |= 1 << i;\n}\n\nint main() {\n\tint n; scanf(\"%d\",&n);\n\trep(i,1,n - 1) { int a, b; scanf(\"%d%d\",&a,&b), ins(a, b), ins(b, a); }\n\tdfs(1,0); printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define ull unsigned ll\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 100100\n\nint du[MAXN];\nint n;\n\nint main(){\n\tms(du);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i < n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tdu[a]++; du[b]++;\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1;i <= n;i++)\n\t\tif(du[i] > 2)\n\t\t\tans++;\n\tcout << ans+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,f[110001][21],ans,s[110001];\nvector<int> w[110001];\nvoid dfs(int u,int p)\n{\n\tfor(int v:w[u])\n\t\tif(v!=p)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tfor(int j=0;j<18;j++)f[u][j]+=f[v][j];\n\t\t}\n\tint j=0;\n\tfor(int i=17;i>=0;i--)\n\t\tif(f[u][i]>1){j=i+1;break;}\n\twhile(f[u][j])j++;\n\tans=max(ans,j);\n\tf[u][j]++;\n\twhile(j--)f[u][j]=0;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tw[x].push_back(y);\n\t\tw[y].push_back(x);\n\t}\n\tdfs(1,-1);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0;char ch=' ';\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q;\n}\nconst int N=100005;\nint n,tot,ans;\nint h[N],ne[N<<1],to[N<<1],f[N][22];\nvoid add(int x,int y) {to[++tot]=y,ne[tot]=h[x],h[x]=tot;}\nvoid dfs(int x,int las) {\n\tfor(RI i=h[x];i;i=ne[i]) {\n\t\tif(to[i]==las) continue;\n\t\tdfs(to[i],x);\n\t\tfor(RI j=0;j<=20;++j) f[x][j]+=f[to[i]][j];\n\t}\n\tint p=0;\n\tfor(RI i=20;i>=0;--i) if(f[x][i]>=2) {p=i+1;break;}\n\twhile(f[x][p]) ++p;\n\t++f[x][p];for(RI i=0;i<p;++i) f[x][i]=0;\n\tans=max(ans,p);\n}\nint main()\n{\n\tint x,y;\n\tn=read();\n\tfor(RI i=1;i<n;++i) x=read(),y=read(),add(x,y),add(y,x);\n\tdfs(1,0),printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\ntemplate<class T>\nvoid dump(vector<T> &vec){\n\tfor(int i=0;i<vec.size();i++){\n\t\tcout << vec[i];\n\t\tif(i+1<vec.size())cout << ' ';\n\t\telse cout << endl;\n\t}\n\treturn;\n}\nstruct edge{\n\tint from,to;\n\tedge(){}\n\tedge(int f,int t):from(f),to(t){}\n};\nstruct Tree{\n\tint V;\n\tint root;\n\tvector<int> depth;\n\tvector<int> par;\n\tvector<int> subtree_size;\n\tvector<vector<edge> > G;\n\tvector<bool> dead; // for centroid decomposition\n\tvector<int> sz;    // for centroid decomposition\n\tTree(){}\n\tTree(int v,int r=0){\n\t\tV = v;\n\t\troot = r;\n\t\tG.resize(V);\n\t\tdepth.resize(V);\n\t\tpar.resize(V);\n\t\tsubtree_size.resize(V);\n\t\tsz.resize(V,0);\n\t\tdead.resize(V,false);\n\t}\n\tvoid add_edge(int u,int v){\n\t\tG[u].pb(edge(u,v));\n\t\tG[v].pb(edge(v,u));\n\t}\n\tint dfs(int v,int p,int d){\n\t\tdepth[v]=d;\n\t\tpar[v]=p;\n\t\tsubtree_size[v]=1;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(u==p)continue;\n\t\t\tsubtree_size[v]+=dfs(u,v,d+1);\n\t\t}\n\t\treturn subtree_size[v];\n\t}\n\tvoid init(){\n\t\tdfs(root,-1,0);\n\t}\n\n\t// following functions are for centroid decomposition\n\tint subtree_size_dead(int v,int p){\n\t\tsz[v] = 1;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(u!=p&&!dead[u]){\n\t\t\t\tsz[v] += subtree_size_dead(u,v);\n\t\t\t}\n\t\t}\n\t\treturn sz[v];\n\t}\n\tint centroid_dead(int v,int p,int n){\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(u!=p&&!dead[u]){\n\t\t\t\tif(sz[u]>n/2)return centroid_dead(u,v,n);\n\t\t\t}\n\t\t}\n\t\treturn v;\n\t}\n\tint centroid_decomposition(int v){\n\t\tsubtree_size_dead(v,-1);\n\t\tint c = centroid_dead(v,-1,sz[v]);\n\t\tdead[c] = true;\n\t\tint res = 0;\n\t\tfor(int i=0;i<G[c].size();i++){\n\t\t\tint u = G[c][i].to;\n\t\t\tif(!dead[u]){\n\t\t\t\t// count something within each subtree alone (without the centroid)\n\t\t\t\tres = max(res,1+centroid_decomposition(u));\n\t\t\t}\n\t\t}\n\t\t// count something between subtrees (through centroid)\n\t\tdead[c] = false;\n\t\treturn res;\n\t}\n};\nint N;\nint main(){\n\tcin >> N;\n\tTree G(N);\n\tfor(int i=0;i<N-1;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tx--;y--;\n\t\tG.add_edge(x,y);\n\t}\n\tcout << G.centroid_decomposition(0) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n \nusing namespace std;\n \ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n \nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n \ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n \ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n \ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n \ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n \ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n \ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n \ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n \n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n \n//---------------------------------------------------------head----------------------------------------------------\n \nconst int maxn = 1e5 + 10;\n \nint n;\nvi g[maxn];\nunsigned int dp[maxn];\n \nvoid dfs(int u = 1, int par = 0) {\n\tunsigned int s1 = 0, s2 = 0, &s = dp[u];\n\tfor (int v: g[u]) {\n\t\tif(v != par) {\n\t\t\tdfs(v, u);\n\t\t\ts2 |= (dp[v] & s1);\n\t\t\ts1 |= dp[v];\n\t\t}\n\t}\n\ts = 1;\n\twhile(s <= s2) {\n\t\ts <<= 1;\n\t}\n\twhile(s & s1) {\n\t\ts <<= 1;\n\t}\n\ts = ((s > 1) ? (s1 & ~(s - 1)) : s1) | s;\n\treturn;\n}\n \nint main() {\n\tscf(n);\n\trep (i, n - 1) {\n\t\tint u, v;\n\t\tscf(u, v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs();\n\tunsigned int s = 1;\n\tint ans = -1;\n\twhile(s <= dp[1]) {\n\t\ts <<= 1;\n\t\t++ans;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvector<int> edge[216000];\nInt cnt[216000][20];\nInt val[216000];\nInt n, u, v;\nvoid solve(Int x, Int last = -1){\n  for(Int to:edge[x]){\n    if(to == last)continue;\n    solve(to, x);\n    for(Int i = 0;i < 20;i++){\n      cnt[x][i] += cnt[to][i];\n    }\n  }\n  val[x] = 19;\n  while(val[x] > 0 && cnt[x][val[x]] <= 1)val[x]--;\n  while(cnt[x][val[x]] > 0)val[x]++;\n  for(int i = 0;i < 20;i++){\n    cnt[x][i] = !!cnt[x][i];\n    if(i < val[x])cnt[x][i] = 0;\n  }\n  cnt[x][val[x]] = 1;\n  cout << x << \" \" << val[x] << endl;\n}\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n-1;i++){\n    cin >> u >> v;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\t\t   \n  }\n  solve(1);\n  cout << *max_element(val, val + n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::max;\nusing std::min;\nconst int N=1e5+10;\n\nstruct Edge{ int to,next; }way[N<<1];\nint n,dep[N],num[N],tot,mans;\n\nvoid Build(int a,int b) { way[++tot]=(Edge){b,num[a]}; num[a]=tot; }\n\nvoid Init() {\n\tscanf(\"%d\",&n);\n\tint a,b;\n\tfor (int i=2;i<=n;++i) {\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tBuild(a,b);\n\t\tBuild(b,a);\n\t}\n}\n\nvoid Dfs_1(int x,int fa) {\n\tdep[x]=1;\n\tfor (int i=num[x];i;i=way[i].next) {\n\t\tint v=way[i].to;\n\t\tif (v==fa) continue;\n\t\tDfs_1(v,x);\n\t\tdep[x]=max(dep[x],dep[v]+1);\n\t}\n}\n\nvoid Dfs_2(int x,int fa,int uplen) {\n\tmans=min(mans,max(uplen,dep[x]));\n\tint m1=0,m2=0;\n\tfor (int i=num[x];i;i=way[i].next) {\n\t\tint v=way[i].to;\n\t\tif (v==fa) continue;\n\t\tif (dep[v]>m1) m2=m1,m1=dep[v];\n\t\telse if (dep[v]>m2) m2=dep[v];\n\t}\n\tm1++; m2++;\n\tfor (int i=num[x];i;i=way[i].next) {\n\t\tint v=way[i].to;\n\t\tif (v==fa) continue;\n\t\tif (dep[v]+1==m1) Dfs_2(v,x,max(m2,uplen)+1);\n\t\telse Dfs_2(v,x,max(m1,uplen)+1);\n\t}\n}\n\nvoid Solve() {\n\tDfs_1(1,0);\n\tmans=n;\n\tDfs_2(1,0,1);\n\tint cnt=0;mans--;\n\twhile (mans) \n\t\tmans>>=1,cnt++;\n\tprintf(\"%d\\n\",cnt);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 2e5 + 7;\nconst int LOG = 25;\n\nint n;\nvector<int> adj[N];\nint ans;\n\nint dfs(int u, int from) {\n\tint all = 0, least = 0;\n\tfor (int v : adj[u]) {\n\t\tif (v == from) continue;\n\t\tint mask = dfs(v, u);\n\t\tfor (int j = 0; j < LOG; j++) {\n\t\t\tif ((all >> j & 1) && (mask >> j & 1)) {\n\t\t\t\tleast = max(least, j + 1);\n\t\t\t}\n\t\t}\n\t\tall |= mask;\n\t}\n\tassert(least + 1 < LOG);\n\tfor (int i = least; ; i++) {\n\t\tif (~all >> i & 1) {\n\t\t\tans = max(ans, i);\n\t\t\tall ^= (1 << i);\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (all >> j & 1) {\n\t\t\t\t\tall ^= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn all;\n\t\t}\n\t}\n}\n\nint solve() {\n\tans = 0;\n\tdfs(rand() % n + 1, 0);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\t//n = 1e5;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tint ret = n;\n\tfor (int r = 1; r <= 5; r++) {\n\t\tret = min(ret, solve());\n\t}\n\tprintf(\"%d\\n\", ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\n\nconst int N=1e5+9;\n\nunsigned int bit[N];\nint n,f[N],ans;\nint to[N<<1],nxt[N<<1],beg[N],tot;\n\ninline void add(int u,int v)\n{\n\tto[++tot]=v;\n\tnxt[tot]=beg[u];\n\tbeg[u]=tot;\n}\n\ninline void dfs(int u,int fa)\n{\n\tbit[u]=f[u]=0;\n\tfor(int i=beg[u],v;i;i=nxt[i])\n\t\tif((v=to[i])!=fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tbit[u]|=bit[v];\n\t\t}\n\tif(bit[u]==0)\n\t\tbit[u]=1;\n\telse\n\t{\n\t\twhile(bit[u]&(1<<f[u]))f[u]++;\n\t\tbit[u]=bit[u]&((1<<17)-(1<<f[u]));\n\t\tbit[u]|=(1<<f[u]);\n\t}\n\tif(ans<f[u])ans=f[u];\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tu=read();v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\n#define pa pair<int,int>\n#define fir first\n#define sec second\nusing namespace std;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return  w*s;}\nstruct node{int to,next;} e[290010];\nint n,h[101010],tot,exist[101010][21],Ans;\ninline void add(int from,int to){e[++tot].next=h[from];h[from]=tot;e[tot].to=to;}\ninline void DFS(int now,int ffa){\n\t//debug(now);\n\tfor(rint i=h[now];i;i=e[i].next){\n\t\tint to=e[i].to;if(to==ffa) continue;\n\t\tDFS(to,now);\n\t\tfor(rint j=1;j<=20;++j) exist[now][j]+=exist[to][j];\n\t}\n\tint Min=0;\n\tfor(rint i=1;i<=20;++i) if(exist[now][i]==2) Min=i;\n\t//debug(Min);\n\tMin++;\n\twhile(exist[now][Min]) Min++;\n\tAns=max(Ans,Min);\n\texist[now][Min]=1;\n\tfor(rint i=1;i<=Min-1;++i) exist[now][i]=0;\n}\nint main()\n{\n\tn=read();\n\tfor(rint i=1;i<n;++i){\n\t\tint u=read(),v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\tDFS(1,0);\n\tcout<<Ans-1<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\n\nint head[N], tot, ans = 0, n;\nstruct edge { int to, nxt; } e[N << 1];\n\nvoid link(int x, int y) {\n\te[++tot] = (edge) { y, head[x] }, head[x] = tot;\n\te[++tot] = (edge) { x, head[y] }, head[y] = tot;\n}\nint dfs(int x, int f = 0) {\n\tint ret = 0, max = 0;\n\tfor (int i = head[x]; i; i = e[i].nxt) if (e[i].to != f) {\n\t\tint v = dfs(e[i].to, x);\n\t\tmax = std::max(max, std::__lg(ret & v)), ret |= v;\n\t}\n\tint b = __builtin_ctz(~ret & (-1 << max));\n\tans = std::max(ans, b);\n\treturn (ret &= (-1 << b)) |= 1 << b;\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1, x, y; i < n; ++i)\n\t\tstd::cin >> x >> y, link(x, y);\n\tdfs(1), std::cout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n\nusing namespace std;\n#define N 100010\nvector<ll> t[N];\n//bool dead[N];\nclass DivideTree{\n  public:\n  bool dead[N];\n  class FindCentroid{\n      public:\n      ll res,n;\n      ll alt(ll x,ll from){\n\t  if(dead[x])return 0;\n\t  ll sum=1;\n\t  for(auto y:t[x]){\n\t      if(y!=from)sum+=alt(y,x);\n\t  }\n\t  return sum;\n      }\n      ll dfs(ll x,ll from){\n\t  if(dead[x])return 0;\n\t  ll sum=1,maxi=-1;\n\t  for(auto y:t[x]){\n\t      if(y==from)continue;\n\t      ll val=dfs(y,x);\n\t      sum+=val,maxi=max(maxi,val);\n\t  }\n\t  ll rem=n-sum;\n\t  maxi=max(maxi,rem);\n\t  if(maxi<=n/2)res=x;\n\t  return sum;\n      }\n      ll main(ll s){\n\t  n=alt(s,-1);\n\t  dfs(s,-1);\n\t  return res;\n      }\n  };FindCentroid fc;\n  \n  ll solve(ll s){\n      //cout<<s<<\":\";\n      s=fc.main(s);\n      //cout<<s<<endl;\n      dead[s]=1;\n      ll res=-1;\n      for(auto y:t[s]){\n\t  if(dead[y])continue;\n\t  res=max(res,solve(y));\n      }\n      dead[s]=0;\n      return res+1;\n  }\n  ll main(){\n      for(int i=0;i<N;i++)dead[i]=0;\n      return solve(1);\n  }\n};DivideTree dt;\n\nint main(){\n    ll n,a,b;cin>>n;\n    for(int i=0;i<n-1;i++){\n\tcin>>a>>b;\n\tt[a].push_back(b);\n\tt[b].push_back(a);\n    }\n    cout<<dt.main()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nvector<int> adj[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\nint dep[MAXN + 5], st[MAXN + 5], ed[MAXN + 5], dfn_cur = 0, seq[MAXN + 5];\n\ninline void dfs_init(int u, int fa)\n{\n\tdep[u] = dep[fa] + 1;\n\n\tseq[st[u] = ++dfn_cur] = dep[u];\n\tfor(auto v : adj[u]) if(v != fa)\n\t\tdfs_init(v, u);\n\ted[u] = dfn_cur;\n}\n\nnamespace SEGT\n{\n\tconst int MAX_NODE = MAXN * 4;\n\n\tint mx[MAX_NODE + 5], add[MAX_NODE + 5];\n\n\tinline void push_up(int u) { mx[u] = max(mx[u << 1], mx[u << 1 | 1]); }\n\tinline void push_down(int u)\n\t{\n\t\tif(add[u])\n\t\t{\n\t\t\tmx[u << 1] += add[u], mx[u << 1 | 1] += add[u];\n\t\t\tadd[u << 1] += add[u], add[u << 1 | 1] += add[u];\n\t\t\tadd[u] = 0;\n\t\t}\n\t}\n\n\tinline void build(int u, int l, int r)\n\t{\n\t\tif(l == r)\n\t\t{\n\t\t\tmx[u] = seq[l];\n\t\t\treturn;\n\t\t}\n\n\t\tint mid = (l + r) / 2;\n\t\tbuild(u << 1, l, mid);\n\t\tbuild(u << 1 | 1, mid + 1, r);\n\t\tpush_up(u);\n\t}\n\n\tinline void update(int u, int l, int r, int ql, int qr, int val)\n\t{\n\t\tif(ql <= l && r <= qr)\n\t\t{\n\t\t\tmx[u] += val;\n\t\t\tadd[u] += val;\n\t\t\treturn;\n\t\t}\n\t\tpush_down(u);\n\n\t\tint mid = (l + r) / 2;\n\t\tif(ql <= mid) update(u << 1, l, mid, ql, qr, val);\n\t\tif(mid < qr) update(u << 1 | 1, mid + 1, r, ql, qr, val);\n\t\tpush_up(u);\n\t}\n}\n\nint ans;\n\ninline void dfs_ans(int u, int fa)\n{\n\tchkmin(ans, SEGT::mx[1]);\n\n\tfor(auto v : adj[u]) if(v != fa)\n\t{\n\t\t++SEGT::mx[1], ++SEGT::add[1];\n\t\tSEGT::update(1, 1, n, st[v], ed[v], -2);\n\n\t\tdfs_ans(v, u);\n\n\t\t--SEGT::mx[1], --SEGT::add[1];\n\t\tSEGT::update(1, 1, n, st[v], ed[v], +2);\n\t}\n}\n\ninline void solve()\n{\n\tdfs_init(1, 0);\n\tSEGT::build(1, 1, n);\n\tans = n + 1, dfs_ans(1, 0);\n\tprintf(\"%d\\n\", (int) ceil(log2(ans)));\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n\nusing namespace std;\n#define N 100010\nvector<ll> t[N];\nbool dead[N];\nclass DivideTree{\n  public:\n  \n  class FindCentroid{\n      public:\n      ll res,n;\n      ll alt(ll x,ll from){\n\t  if(dead[x])return 0;\n\t  ll sum=1;\n\t  for(auto y:t[x]){\n\t      if(y!=from)sum+=alt(y,x);\n\t  }\n\t  return sum;\n      }\n      ll dfs(ll x,ll from){\n\t  if(dead[x])return 0;\n\t  ll sum=1,maxi=-1;\n\t  for(auto y:t[x]){\n\t      if(y==from)continue;\n\t      ll val=dfs(y,x);\n\t      sum+=val,maxi=max(maxi,val);\n\t  }\n\t  ll rem=n-sum;\n\t  maxi=max(maxi,rem);\n\t  if(maxi<=n/2)res=x;\n\t  return sum;\n      }\n      ll main(ll s){\n\t  n=alt(s,-1);\n\t  dfs(s,-1);\n\t  return res;\n      }\n  };FindCentroid fc;\n  \n  ll solve(ll s){\n      //cout<<s<<\":\";\n      s=fc.main(s);\n      //cout<<s<<endl;\n      dead[s]=1;\n      ll res=-1;\n      for(auto y:t[s]){\n\t  if(dead[y])continue;\n\t  res=max(res,solve(y));\n      }\n      dead[s]=0;\n      return res+1;\n  }\n  ll main(){\n      for(int i=0;i<N;i++)dead[i]=0;\n      return solve(1);\n  }\n};DivideTree dt;\n\nint main(){\n    ll n,a,b;cin>>n;\n    for(int i=0;i<n-1;i++){\n\tcin>>a>>b;\n\tt[a].push_back(b);\n\tt[b].push_back(a);\n    }\n    cout<<dt.main()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Èå äÇã Çæ */\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int MAX_N = 100 * 1000 + 5;\nint n, max_path;\nset<int> adj[MAX_N];\n\nvoid read_input() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tadj[u].insert(v);\n\t\tadj[v].insert(u);\n\t}\t\n}\n\nint dfs(int v, int pr = -1) {\n\tint x = 0, y = 0;\n\tfor (int u: adj[v])\n\t\tif (u != pr) {\n\t\t\ty = max(y, dfs(u, v) + 1);\n\t\t\tif (x < y)\n\t\t\t\tswap(x, y);\n\t\t}\n\tmax_path = max(max_path, x + y);\n\treturn x;\n}\n\nvoid solve() {\n\tdfs(0);\n}\n\nvoid print_output() {\n\tcout << 31 - __builtin_clz(max_path + 1);\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tread_input();\n\tsolve();\n\tprint_output();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rint register int\nusing namespace std;\n// by piano\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0;char c = getchar();bool f = 0;\n  for (; c < '0' || c > '9'; f |= (c == '-'), c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\nconst int lgN = 21;\nconst int N = 3e5 + 233;\nint n, ban[lgN + 2], col[N], ans = 0;\nvector<int> g[N];\ninline int dfs(int u, int fat) {\n  vector<int> vec;\n  int has = 0;\n  for (int v : g[u]) if (v != fat) {\n      int p = dfs(v, u);\n      vec.push_back(p);\n      has |= p;\n    }\n  int mx = 0;\n  memset(ban, 0, sizeof ban);\n  for (int k = 0; k < lgN; k ++) {\n    int cnt = 0;\n    for (int i : vec)\n      cnt += i >> k & 1;\n    if (cnt >= 1) ban[k] = true;\n    if (cnt >= 2) mx = max(mx, k + 1);\n  }\n  while (ban[mx]) ++ mx;\n  col[u] = mx;\n  ans = max(ans, mx);\n  for (int k = 0; k < col[u]; k ++)\n    if (has >> k & 1)\n      has ^= 1 << k;\n  has |= 1 << col[u];\n  return has;\n}\n\nmain(void) {\n  read(n);\n  for (int i = 2; i <= n; i ++) {\n    int x, y; read(x); read(y);\n    g[x].push_back(y); g[y].push_back(x);\n  }\n  dfs(1, 0);\n  // for (int i = 1; i <= n; i ++)\n  //   cout << col[i] << \" \"; puts(\"\");\n  cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n \n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n \nusing namespace std;\n//using namespace __gnu_pbds;\n \n//typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n \nconst int N = 1000000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 31;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\n//const int MAX_INT = (1 << 31) - 1;\n \n/*void print(vector<auto> &a)\n{\n    for (auto i : a)\n        cout << i.fi << endl;\n    cout << endl;\n}*/\n \nvector<int> g[N];\nbool used[N];\nint par[N];\nint sz[N];\n \nbool dfs(int u, int p, int n, int c)\n{\n    sz[u] = 1;\n    bool ok = true;\n    for (int v : g[u])\n        if (v != p && !used[v])\n        {\n            if (dfs(v, u, n, c))\n                return true;\n            sz[u] += sz[v];\n            if (sz[v] * 2 > n)\n                ok = false;\n        }\n    if (sz[u] * 2 < n)\n        ok = false;\n    if (ok)\n    {\n        par[u] = c;\n        used[u] = true;\n        for (int v : g[u])\n            if (v != p && !used[v])\n                dfs(v, -1, sz[v], u);\n        if (p != -1 && !used[p])\n            dfs(p, -1, n - sz[u], u);\n    }\n    return ok;\n}\n \nvector<int> g1[N];\n \nint dfs1(int u)\n{\n    int res = 0;\n    for (int v : g1[u])\n        res = max(res, dfs1(v) + 1);\n    return res;\n}\n \nint main()\n{\n    //freopen(\"decomposition.in\", \"r\", stdin);\n    //freopen(\"decomposition.out\", \"w\", stdout);\n    //ios_base::sync_with_stdio(0);\n    //cin.tie(0);\n    //cout.precision(20);\n    int n;\n    scanf(\"%d\", &n);\n    rep(i, 0, n - 1)\n    {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs(0, -1, n, -1);\n    int root = -1;\n    rep(i, 0, n)\n    {\n        if (par[i] == -1)\n            root = i;\n        else\n            g1[par[i]].push_back(i);\n    }\n    printf(\"%d\\n\", dfs1(root));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\nint c[MX];\n\nP cfs(int v, int d=0, int p=-1) {\n  P res(d,v);\n  for (int u : to[v]) {\n    if (c[u] || u == p) continue;\n    maxs(res, cfs(u,d+1,v));\n  }\n  return res;\n}\nvi vs;\nbool vfs(int v, int t, int p=-1) {\n  if (v == t) {\n    vs.pb(v);\n    return true;\n  }\n  for (int u : to[v]) {\n    if (c[u] || p == u) continue;\n    if (vfs(u,t,v)) {\n      vs.pb(v);\n      return true;\n    }\n  }\n  return false;\n}\nint dfs(int v) {\n  v = cfs(v).se;\n  v = cfs(v).se;\n  P p = cfs(v);\n  vs = vi();\n  vfs(v,p.se);\n  v = vs[(p.fi)/2];\n  c[v] = 1;\n  int res = 0;\n  for (int u : to[v]) {\n    if (c[u]) continue;\n    maxs(res,dfs(u)+1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N;\nint a[110000], b[110000];\nvint G[110000];\n\nint dfs(int v, int p) {\n    int a = 0;\n    vint vec;\n    for (int i = 0; i < G[v].size(); i++) {\n        if (G[v][i] == p)continue;\n        vec.push_back(dfs(G[v][i], v));\n        a |= vec[vec.size() - 1];\n    }\n    int idx;\n    for (int i = 20; i >= 0; i--) {\n        if ((a & (1 << i)) == 0)idx = i;\n        int cnt = 0;\n        for (int j = 0; j < vec.size(); j++)cnt += (vec[j] & (1 << i)) ? 1 : 0;\n        if (cnt >= 2)break;\n    }\n    a |= 1 << idx;\n    a -= a % (1 << idx);\n    return a;\n}\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++)cin >> a[i] >> b[i], G[a[i]].push_back(b[i]), G[b[i]].push_back(a[i]);\n    int x = dfs(1, 0);\n    for (int i = 20; i >= 0; i--) {\n        if (x & (1 << i)) {cout << i << endl; break;}\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint N;\nvector< int > g[100000];\nbool v[100000][30];\n\nint dfs(int idx, int par) {\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to != par) ret = max(ret, dfs(to, idx));\n  }\n  for(int i = 0; i < 30; i++) {\n    bool correct = true;\n    for(auto &to : g[idx]) {\n      if(to != par) {\n        if(v[to][i]) correct = false;\n      }\n    }\n    if(correct) {\n      ret = max(ret, i);\n      v[idx][i] = true;\n      for(auto &to : g[idx]) {\n        for(int j = i + 1; j < 30; j++) {\n          v[idx][j] |= v[to][j];\n        }\n      }\n      break;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  cout << dfs(0, -1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define X first\n#define Y second\n#define REP(i,a) for(int i=0;i<a;++i)\n#define REPP(i,a,b) for(int i=a;i<b;++i)\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define foreach( gg,itit )  for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define mp make_pair\n#define pb push_back\n#define all(s) s.begin(),s.end()\n#define present(c,x) ((c).find(x) != (c).end())\nconst double EPS = 1e-8;\nconst int mod = 1e9+7;\nconst int N = 1e6+10;\nconst ll INF = 1e18;\n\n//#define DEBUG\nll power(ll x,ll y){\n  ll t=1;\n  while(y>0){\n    if(y%2) y-=1,t=t*x%mod;\n    else y/=2,x=x*x%mod;\n  }\n  return t;\n}\n#ifdef DEBUG\n#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)\n#else\n#define dprintf(fmt,...)\n#endif\n\nvector<int> G[N];\n\nint dfs(int v,int p){\n  int cur=0;\n  int ct[24]; FILL(ct,0);\n  REP(i,G[v].size()) if(G[v][i]!=p) {\n    int x=dfs(G[v][i],v);\n    REP(j,20) if((x>>j)&1){\n      if(ct[j]==1) cur=max(j+1,cur);\n      ct[j]++;\n    }\n  }\n  while(ct[cur]) cur++;\n  int occ=0;\n  ct[cur]++;\n  REPP(i,cur,20) if(ct[i]) occ|=1<<i;\n  return occ;\n}\nint main(){\n  int n; scanf(\"%d\",&n);\n  REP(i,n-1) {\n    int x,y; scanf(\"%d%d\",&x,&y);\n    x--;y--;\n    G[x].pb(y); G[y].pb(x);\n  }\n  int a=dfs(0,-1);\n  int x=20;\n // printf(\"%d\\n\",a);\n  while(((a>>x)&1)==0&&x>=0) x--;\n  printf(\"%d\\n\",x); \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,fst[N],to[N*2],nxt[N*2],l,fa[N],b[N],Ans;\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n}\nvoid dfs(int x)\n{\n\tint tmp=0;\n\tfor (int i=fst[x];i;i=nxt[i])\n\tif (to[i]!=fa[x])\n\t{\n\t\tfa[to[i]]=x;\n\t\tdfs(to[i]);\n\t\ttmp|=b[to[i]];\n\t}\n\tint t=0;\n\twhile((1<<t)&tmp)t++;\n\t//cout<<t<<endl;\n\tb[x]=tmp^(1<<t)^(tmp&((1<<t)-1));\n\tAns=max(Ans,t);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tdfs(1);\n\t/*int ans=0;\n\twhile(Ans>1)Ans>>=1,ans++;*/\n\tprintf(\"%d\\n\",Ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N;\nint a[110000], b[110000];\nvint G[110000];\nbool centroid[110000];\nint sos[110000];\nbool used[110][110000];\n\nvoid dfs(int v, int p,int dep) {\n    used[dep][v] = false;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || cur == p)continue;\n        dfs(cur, v, dep);\n    }\n}\n\nint size_of_subtree(int v, int p,int dep) {\n    int ret = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || used[dep][cur] || cur == p)continue;\n        ret += size_of_subtree(cur, v, dep);\n    }\n    return sos[v] = ret;\n}\n\nint search_centroid(int v, int t,int dep) {\n    if (used[dep][v])return -1;\n    int p = -1;\n    while (true) {\n        int ch, s = 0;\n        for (int i = 0; i < G[v].size(); i++) {\n            int cur = G[v][i];\n            if (centroid[cur] || used[dep][cur] || cur == p)continue;\n            if (s <= sos[cur])s = sos[cur], ch = cur;\n        }\n        if (s <= t / 2)break;\n        p = v;\n        v = ch;\n    }\n    return v;\n}\n\nint u(int v, int dep) {\n    dfs(v, -1, dep);\n    int ret = LLONG_MAX;\n    while (true) {\n        size_of_subtree(v, -1, dep);\n        int cidx = search_centroid(v, sos[v], dep);\n        if (cidx == -1)return ret;\n        centroid[cidx] = true;\n        used[dep][cidx] = true;\n        int mu = -1, m2 = -1;\n        for (int i = 0; i < G[cidx].size(); i++) {\n            if (centroid[G[cidx][i]])continue;\n            int cu = u(G[cidx][i], dep + 1);\n\n            if (mu <= cu)m2 = mu, mu = cu, v = G[cidx][i];\n        }\n        ret = min(ret, mu + 1);\n        centroid[cidx] = false;\n        if (mu == m2) return ret;\n    }\n}\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++)cin >> a[i] >> b[i], a[i]--, b[i]--, G[a[i]].push_back(b[i]), G[b[i]].push_back(a[i]);\n    cout << u(0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=100010;\nint tt,ans;\nint f[N],head[N],to[N*2],nxt[N*2];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline void dfs(int x,int fa) {\n    int s=0,t=0;\n    for(int i=head[x];i;i=nxt[i]) {\n\tint y=to[i];\n\tif(y!=fa) {\n\t    dfs(y,x);\n\t    s|=f[x]&f[y],f[x]|=f[y];\n\t}\n    }\n    while((1<<t)<=s||f[x]>>t&1) ++t;\n    ans=max(ans,t),f[x]=((f[x]>>t)|1)<<t;\n}\nint main() {\n    int n;\n    cin>>n;\n    for(int i=1;i<n;i++) {\n\tint x=gi(),y=gi();\n\tto[++tt]=y,nxt[tt]=head[x],head[x]=tt;\n\tto[++tt]=x,nxt[tt]=head[y],head[y]=tt;\n    }\n    dfs(1,0);\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) ((x) & -(x))\nusing namespace std;\n\nvector <int> adia[100010];\nint see[100010];\nint lgr[1000010];\nint maxim = 0, total;\n\nint dfs(int nod, int tata)\n{\n    for (auto i : adia[nod])\n        if (i != tata)\n            see[nod] |= dfs(i, nod);\n    /// pun lsb(~see[nod])\n    int pun = lgr[lsb(total - see[nod])];\n    assert(((1 << pun) & see[nod]) == 0);\n    maxim = max(maxim, pun);\n    see[nod] &= total - ((1 << pun) - 1);\n    see[nod] += (1 << pun);\n    return see[nod];\n}\n\nint main()\n{\n    total = (1 << 30) - 1;\n    for (int i = 2; i <= 1000000; i++)\n        lgr[i] = 1 + lgr[i / 2];\n\n    int n, a, b;\n    cin >> n;\n\n    while (--n) {\n        cin >> a >> b;\n        adia[a].push_back(b);\n        adia[b].push_back(a);\n    }\n\n    dfs(1, 0);\n\n    cout << maxim << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define REP(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) REP((i),0,(n))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing tp3 = tuple<int, int, int>;\nusing Mat = vector<vector<ll>>;\nconstexpr int INF = 1 << 28;\nconstexpr ll INFL = 1ll << 60;\nconstexpr int dh[4] = { 0,1,0,-1 };\nconstexpr int dw[4] = { -1,0,1,0 };\nbool isin(const int H, const int W, const int h, const int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\ntemplate<typename T>\nT chmin(T& l, T r) {\n    return l = min(l, r);\n}\ntemplate<typename T>\nT chmax(T& l, T r) {\n    return l = max(l, r);\n}\n// ============ template finished ============\nusing Graph = vector<vector<int>>;\nusing Level = int;\nusing Upper = bool;\nusing Status = pair<Level, Upper>;\nusing Index = int;\n\nStatus get_status(vector<Status> statuses) {\n    Status res;\n    for (Status status : statuses)res = max(res, status);\n    return res;\n}\n\nIndex get_parent(const Graph& graph, set<Index> liftupped, const Index now) {\n    for (Index next : graph[now])\n        if (liftupped.find(next) == liftupped.end())\n            return next;\n    return -1;\n}\n\nStatus next_status(Status status) {\n    if (status.second) {\n        return { status.first + 1,false };\n    }\n    else {\n        return { status.first,true };\n    }\n}\n\nint max_level(map<Level, int>& cnt) {\n    int base = -1;\n    for (auto itr : cnt)base = max(base, itr.first);\n    return base;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    Graph graph(N);\n\n    rep(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    vector<vector<Status>> raw_statuses(N);\n    queue<Index> liftups;\n    set<Index> liftupped;\n    rep(i, N)if (graph[i].size() == 1) {\n        raw_statuses[i].push_back({ 0,true });\n        liftups.push(i);\n        liftupped.insert(i);\n    }\n    while (!liftups.empty()) {\n        Index now = liftups.front(); liftups.pop();\n        Index parent = get_parent(graph, liftupped, now);\n        if (parent == -1)break;\n        Status status = get_status(raw_statuses[now]);\n        Status parent_status = next_status(status);\n        raw_statuses[parent].push_back(parent_status);\n\n        if (raw_statuses[parent].size() + 1 == graph[parent].size()) {\n            assert(liftupped.find(parent) == liftupped.end());\n            liftups.push(parent);\n            liftupped.insert(parent);\n        }\n    }\n    map<Level, int> cnt;\n    for (auto& raw_status : raw_statuses) {\n        auto status = get_status(raw_status);\n        cnt[status.first]++;\n    }\n    int level = max_level(cnt);\n    if (cnt[level] > 1)level++;\n    cout << level << endl;\n\n    rep(i, N) {\n        Status status = get_status(raw_statuses[i]);\n        // cout << \"Index: \" << i << \" -> (\" << status.first << \",\" << status.second << \")\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n/*\ntane adami sharifast be jane adamiat\nna hamin lebase zibast neshane adamiat\nagar adami be cheshmasto dahano goosho bini\nche miane naghshe divaro miane adamiat\nkhoro khabo khashmo shahvat shaghab asto jahlo zolmat\nhayavan khabar nadarad ze jahane adamiat\nbe haghighat adami bash vagarna morgh bashad\nke hami sokhan begooyad be zabane adamiat\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); }\n#define MKP make_pair\n#define RETD(x) { cout << fixed << setprecision(15) << x; } //exit(0); }\n#define GEI(x) scanf(\"%d\",&x)\n#define GEL(x) scanf(\"%lld\",&x)\n#define ALL(x) x.begin(),x.end()\nconst ll M=2e5+5,LG=32,SM=2e4+5,inf=1e9+5;\nll mod=1e9+7;\n#define MOK(x) if(x>mod) x-=mod;\nll pw(ll x,ll n) { return (n==0?1:pw(x*x%mod,n/2)*(n&1?x:1)%mod); }\n\nll n;\nvll g[M];\nll cm[M],cn[M];\nll res;\n\nll lasb(ll x) { return (x<2?x:lasb(x>>1)+1); }\nll firb(ll x) { return (x&1?0:firb(x>>1)+1); }\n\nvoid dfs(ll x,ll p)\n{\n    ll ba=0;\n    for (ll y:g[x])\n    {\n        if (y==p) continue;\n        dfs(y,x);\n        ba|=cm[x]&cm[y];\n        cm[x]|=cm[y];\n    }\n    ll nd=lasb(ba);\n    cm[x]&=-(1<<nd);\n    cm[x]+=(1<<nd);\n    cn[x]=firb(cm[x]);\n    smax(res,cn[x]);\n}\n \nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n;\n    For(i,1,n)\n    {\n        ll a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].PB(b);g[b].PB(a);\n    }\n    dfs(0,0);\n    RET(res);\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=1e5+3;\nint n,lg2,f[mn],gra,beg[mn],to[mn*2],nex[mn*2];\nvoid ins(int u,int v){\n\tto[++gra]=v;\n\tnex[gra]=beg[u];\n\tbeg[u]=gra;\n}\nvoid dfs(int p,int q){\n\tfr(i,p)if(to[i]!=q){\n\t\tdfs(to[i],p);\n\t\tf[p]|=f[to[i]];\n\t}\n\tfo(i,0,lg2)if(!(f[p]&(1<<i)))\n\t\t{f[p]=((f[p]>>i)+1)<<i;return;}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tins(u,v);\n\t\tins(v,u);\n\t}\n\tlg2=log(n)/log(2)+1;\n\tdfs(1,0);\n\tfd(i,lg2,0)if(f[1]&(1<<i)){printf(\"%d\",i);return 0;}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 100000;\n\nint n;\nvector<int> adj[MaxN + 1];\n\nint sta[MaxN + 1];\nint lab[MaxN + 1];\n\nint dfs(int u, int prev)\n{\n\tsta[u] = 0;\n\n\tint mask = 0;\n\tfor (int v : adj[u])\n\t\tif (v != prev)\n\t\t{\n\t\t\tint sv = dfs(v, u);\n\t\t\tmask |= sv & sta[u];\n\t\t\tsta[u] |= sv;\n\t\t}\n\n\tif (sta[u] == 0)\n\t\tsta[u] = 1, lab[u] = 0;\n\telse\n\t{\n\t\tint l = 0;\n\t\twhile (1 << l <= mask)\n\t\t\t++l;\n\t\twhile (sta[u] >> l & 1)\n\t\t\t++l;\n\n\t\tlab[u] = l;\n\t\tsta[u] >>= l, sta[u] <<= 1;\n\t\tsta[u] |= 1 << l;\n\t}\n\n\treturn sta[u];\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tint u = getint(), v = getint();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tdfs(1, 0);\n\n\tcout << *max_element(lab + 1, lab + n + 1);\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, x, y;\nvector<int> a[100020];\nint dfs(int x, int y) {\n\tint c = 0, d = 0, p = 0;\n\tfor (int i: a[x]) {\n\t\tif (i != y) {\n\t\t\tint u = dfs(i, x);\n\t\t\td |= c & u;\n\t\t\tc |= u;\n\t\t}\n\t}\n\twhile (1 << p < d || c >> p & 1) {\n\t\tp++;\n\t}\n\treturn (c >> p | 1) << p;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tprintf(\"%d\\n\", 31 - __builtin_clz(dfs(1, 0)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[N<<1];\nint n,home[N],cnt=-1,lg2[N<<1];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nint f[N],sum[25];\nvoid dfs(int k,int F){\n\tfor(int i=home[k];~i;i=e[i].next)if(e[i].k!=F){\n\t\tdfs(e[i].k,k);\n\t}\n\tmemset(sum,0,sizeof(sum));\n\tfor(int i=home[k];~i;i=e[i].next)if(e[i].k!=F){\n\t\tint g=f[e[i].k],t;\n\t\twhile(g) t=g&-g,sum[lg2[t]]++,g-=t;\n\t}\n\tbool t=0;int o=0;\n\tfor(int i=20;~i;i--){\n\t\tif(sum[i]){\n\t\t\tif(!o) o=(1<<i);\n\t\t\tif(sum[i]>1){\n\t\t\t\tt=1;i++;\n\t\t\t\twhile(sum[i]){\n\t\t\t\t\tf[k]^=(1<<i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tf[k]|=(1<<i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf[k]|=(1<<i);\n\t\t}else if(o){\n\t\t\tt=1;int K=0,g,h=0;\n\t\t\twhile(i>=0){\n\t\t\t\tif(!sum[i]) g=(1<<i),h|=K;\n\t\t\t\telse K|=(1<<i);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tf[k]|=(g|h);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!t) f[k]=o+o;\n\tif(!f[k]) f[k]=1;\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tfor(int i=2;i<=200000;i++) lg2[i]=lg2[i>>1]+1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tint ans=-1;\n\twhile(f[1]) f[1]>>=1,ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nvector<int> G[100020],G2[100020];\n\nvoid dfs_1(int r,int p){\n\tfor(auto v:G[r])if(v!=p){\n\t\tG2[r].pb(v);\n\t\tdfs_1(v,r);\n\t}\n}\n\n\nint bit[100020];\nint ans[100020];\n\nvoid dfs(int r){\n\t\n\tif(G2[r].size()==0){\n\t\tans[r]=0;\n\t\tbit[r]=0;\n\t\treturn;\n\t}\n\t\n\tfor(auto v:G2[r]){\n\t\tdfs(v);\n\t}\n\t\n\tvector<int> ve;\n\tfor(auto v:G2[r]){\n\t\t\n\t\tint f=bit[v];\n\t\t\n\t\tfor(int i=0;i<=ans[v];i++)if(f&(1ll<<i)){\n\t\t\tf^=(1ll<<i);\n\t\t}\n\t\tf^=(1ll<<ans[v]);\n\t\tve.pb(f);\n\t\t\n\t}\n\tint it=-1;\n\tfor(int i=0;i<60;i++){\n\t\tint cnt=0;\n\t\tfor(auto v:ve){\n\t\t\tif(v&(1ll<<i))cnt++;\n\t\t}\n\t\tif(cnt>=2)it=max(it,i);\n\t}\n\tfor(int i=it+1;;i++){\n\t\tint cnt=0;\n\t\tfor(auto v:ve){\n\t\t\tif(v&(1ll<<i))cnt++;\n\t\t}\n\t\tif(cnt==0){\n\t\t\tans[r]=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint b=0;\n\tfor(auto v:ve)b|=v;\n\tfor(int i=0;i<ans[r];i++)if(b&(1ll<<i)){\n\t\tb^=(1ll<<i);\n\t}\n\tb^=(1ll<<ans[r]);\n\t\n\tbit[r]=b;\n\treturn;\n}\n\n\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tcin>>n;\n \tfor(int i=0;i<n-1;i++){\n \t\tint y,yy;\n \t\tcin>>y>>yy;\n \t\tG[y].pb(yy);\n \t\tG[yy].pb(y);\n \t}\n \tdfs_1(1,1);\n \t\n \t\n \tdfs(1);\n \t\n \t\n \tint g=-1;\n \tfor(int i=1;i<=n;i++)g=max(g,ans[i]);\n \tcout<<g<<endl;\n \treturn 0;\n  }\n  "
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author RiaD\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <iostream>\n\n\n#include <iterator>\n\n\n#include <string>\n#include <stdexcept>\n\n#ifndef SPCPPL_ASSERT\n\t#ifdef SPCPPL_DEBUG\n\t\t#define SPCPPL_ASSERT(condition) \\\n\t\tif(!(condition)) { \\\n\t\t\tthrow std::runtime_error(std::string() + #condition + \" in line \" + std::to_string(__LINE__) + \" in \" + __PRETTY_FUNCTION__); \\\n\t\t}\n\t#else\n\t\t#define SPCPPL_ASSERT(condition)\n\t#endif\n#endif\n\n\n/**\n* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because\n* it's reference type is not a reference.\n*\n* It doesn't return reference because\n* 1. Anyway it'll not satisfy requirement [forward.iterators]/6\n*   If a and b are both dereferenceable, then a == b if and only if *a and\n*   b are bound to the same object.\n* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator\n*\n* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,\n* but it's seems to work at least on my implementation.\n*\n* It's not really useful anywhere except iterating anyway.\n*/\ntemplate <typename T>\nclass IntegerIterator: public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {\npublic:\n\texplicit IntegerIterator(T value): value(value) {\n\n\t}\n\n\tIntegerIterator& operator++() {\n\t\t++value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator++(int) {\n\t\tIntegerIterator copy = *this;\n\t\t++value;\n\t\treturn copy;\n\t}\n\n\tIntegerIterator& operator--() {\n\t\t--value;\n\t\treturn *this;\n\t}\n\n\tIntegerIterator operator--(int) {\n\t\tIntegerIterator copy = *this;\n\t\t--value;\n\t\treturn copy;\n\t}\n\n\tT operator*() const {\n\t\treturn value;\n\t}\n\n\tbool operator==(IntegerIterator rhs) const {\n\t\treturn value == rhs.value;\n\t}\n\n\tbool operator!=(IntegerIterator rhs) const {\n\t\treturn !(*this == rhs);\n\t}\n\nprivate:\n\tT value;\n};\n\ntemplate <typename T>\nclass IntegerRange {\npublic:\n\tIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin <= end);\n\t}\n\n\tIntegerIterator<T> begin() const {\n\t\treturn IntegerIterator<T>(begin_);\n\t}\n\n\tIntegerIterator<T> end() const {\n\t\treturn IntegerIterator<T>(end_);\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nclass ReversedIntegerRange {\n\ttypedef std::reverse_iterator<IntegerIterator<T>> IteratorType;\npublic:\n\tReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {\n\t\tSPCPPL_ASSERT(begin >= end);\n\t}\n\n\tIteratorType begin() const {\n\t\treturn IteratorType(IntegerIterator<T>(begin_));\n\t}\n\n\tIteratorType end() const {\n\t\treturn IteratorType(IntegerIterator<T>(end_));\n\t}\n\nprivate:\n\tT begin_;\n\tT end_;\n};\n\ntemplate <typename T>\nIntegerRange<T> range(T to) {\n\treturn IntegerRange<T>(0, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> range(T from, T to) {\n\treturn IntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T to) {\n\treturn IntegerRange<T>(0, to + 1);\n}\n\ntemplate <typename T>\nIntegerRange<T> inclusiveRange(T from, T to) {\n\treturn IntegerRange<T>(from, to + 1);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from) {\n\treturn ReversedIntegerRange<T>(from, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> downrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from, to);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from) {\n\treturn ReversedIntegerRange<T>(from + 1, 0);\n}\n\ntemplate <typename T>\nReversedIntegerRange<T> inclusiveDownrange(T from, T to) {\n\treturn ReversedIntegerRange<T>(from + 1, to);\n}\n\n#include <vector>\n#include <map>\n#include <algorithm>\n\ntemplate <typename T>\nvoid updateMin(T& oldValue, const T& newValue) {\n\tif (newValue < oldValue) {\n\t\toldValue = newValue;\n\t}\n}\n\ntemplate <typename T>\nvoid updateMax(T& oldValue, const T& newValue) {\n\tif (oldValue < newValue) {\n\t\toldValue = newValue;\n\t}\n}\n\n#include <cassert>\n\nusing namespace std;\n\nclass TaskD {\n\tvector<vector<int>> g;\n\n\tvector<int> solve(int v, int p) {\n\t\tmap<int, int> cnt;\n\n\t\tint mxDouble = -1;\n\t\tfor (int to: g[v]) {\n\t\t\tif (to == p) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int x: solve(to, v)) {\n\t\t\t\tif (++cnt[x] == 2) {\n\t\t\t\t\tupdateMax(mxDouble, x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = mxDouble + 1;; ++i) {\n\t\t\tif (cnt[i] == 0) {\n\t\t\t\tvector<int> vv;\n\t\t\t\tvv.push_back(i);\n\t\t\t\tfor (auto pp: cnt) {\n\t\t\t\t\tif (pp.first <= i) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tassert(pp.second == 1);\n\t\t\t\t\tvv.push_back(pp.first);\n\t\t\t\t}\n\t\t\t\treturn vv;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvoid solve(std::istream& in, std::ostream& out) {\n\t\t//out << \"Case #\" << ++testNumber << \": \";\n\t\t//cerr << \"Running test: \" << testNumber << endl;\n\n\t\tint n;\n\t\tin >> n;\n\n\t\tg.resize(n);\n\n\t\tfor (int i: range(n - 1)) {\n\t\t\tint a, b;\n\t\t\tin >> a >> b;\n\t\t\t--a, --b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\n\t\tout << solve(0, -1).back() << \"\\n\";\n\t}\n};\n\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tTaskD solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tin.tie(nullptr);\n\tout << std::fixed;\n\tout.precision(20);\n\tsolver.solve(in, out);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\ntemplate< typename T >\nstruct edge{\n    int from, to;\n    T cost;\n    edge(int to,T cost) : from(-1), to(to), cost(cost){}\n    edge(int from,int to,T cost) : from(from), to(to), cost(cost){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const{ return to;}\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedTree = vector< Edges<T>>;\nusing tree = vector< vector<int> >;\n\ntree make(int n,int offset = 1){\n    tree res(n);\n    for(int i = 0;i < n-1; i++){\n        int a,b; cin >> a >> b;\n        a -= offset,b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate< typename T >\nWeightedTree<T> make2(int n, int offset = 1){\n    WeightedTree<T> res(n);\n    for(int i = 0;i < n-1 ; i++){\n        int a,b ; cin >> a >> b;\n        a -= offset, b -= offset;\n        T c; cin >> c;\n        res[a].emplace_back(b,c);\n        res[b].emplace_back(a,c);\n    }\n    return res;\n}\n\nvector<int> Centers(tree &g,int idx = 0){\n    vector<int> res;\n    int max_depth = -1, leaf;\n    auto dfs = [&](auto &&self,int x,int p,int d)->bool{\n        bool flag = false;\n        if(max_depth < d){\n            max_depth = d, leaf = x, flag = true;\n            res.clear();\n        }\n        for(auto e:g[x]){\n            if(e != p)\n            flag |= self(self,e,x,d+1);\n        }\n        if(flag and (d == (max_depth>>1) or d == ((max_depth+1)>>1))) {\n            res.emplace_back(x);\n        }\n        return flag;\n    };\n    dfs(dfs,idx,-1,0);\n    max_depth = -1;\n    dfs(dfs,leaf,-1,0);\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    INT(n);\n    auto g = make(n);\n    rep(i,n)sort(all(g[i]));\n    auto solve = [&](auto &&self,int x) -> int{\n        if(g[x].size() == 0) return 0;\n        auto centers = Centers(g,x);\n        int res = 0;\n        if(centers.size() == 1){\n            int center = centers.back();\n            for(auto e:g[center]){\n                auto it = lower_bound(all(g[e]),center);\n                g[e].erase(it);\n                chmax(res,self(self,e));\n                g[e].eb(center);\n            }\n            return res + 1;\n        }\n        else{\n            int a = centers[0],b = centers[1];\n            auto it = lower_bound(all(g[a]),b);\n            g[a].erase(it);\n            it = lower_bound(all(g[b]),a);\n            g[b].erase(it);\n            int A = self(self,a);\n            int B = self(self,b);\n            for(auto e:g[a]){\n                auto it = lower_bound(all(g[e]),a);\n                g[e].erase(it);\n                chmax(B,self(self,e));\n            }\n            for(auto e:g[b]){\n                auto it = lower_bound(all(g[e]),b);\n                g[e].erase(it);\n                chmax(A,self(self,e));\n            }\n            g[a].eb(b);\n            g[b].eb(a);\n            return min(A,B) + 1;\n        }\n    };\n    cout << solve(solve,0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100100;\nint n,ans;\nvector<int>g[N];\n\nint dfs(int x,int fa=-1){\n\tint ret=0,res=0;\n\tfor(int i:g[x])if(i!=fa){\n\t\tint u=dfs(i,x);\n\t\tres|=ret&u;ret|=u;\n\t}\n\tint now=(res?32-__builtin_clz(res):0);\n\tnow+=__builtin_ctz((ret>>now)+1);\n\tans=max(ans,now);ret&=~((1<<now)-1);\n\tret|=1<<now;return ret;\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<n;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tg[x].push_back(y);g[y].push_back(x);\n\t}\n\tdfs(1);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nint N;\nvector <int> adjList[100005];\nint dp[35];\n\nii getFurthest(int u, int prevP, int prevDist)\n{\n    ii furthest = ii(prevDist, u);\n    for (int v : adjList[u])\n    {\n        if (v == prevP) continue;\n        ii cur = getFurthest(v, u, prevDist + 1);\n        if (furthest.first <= cur.first) furthest = cur;\n    }\n    return furthest;\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    for (int i = 1; i < N; i++)\n    {\n        int a, b; scanf(\"%d%d\", &a, &b);\n        adjList[a].push_back(b), adjList[b].push_back(a);\n    }\n    int diameter = getFurthest(getFurthest(1, -1, 0).second, -1, 0).first + 1;\n    dp[0] = 1;\n    for (int i = 1; i <= 30; i++) dp[i] = dp[i - 1] * 2 + 1;\n    int k = lower_bound(dp, dp + 31, diameter) - dp;\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nvector<int> G[N];\nint n,a[N];\nvoid dfs(int t,int fa)\n{\n\tint i,j,u=0,v=0;\n\tfor(i=0;i<G[t].size();i++)\n\t\tif(G[t][i]!=fa){\n\t\t\tdfs(G[t][i],t);\n\t\t\tv|=u&a[G[t][i]];\n\t\t\tu|=a[G[t][i]];\n\t\t  }\n\tv=(v<<1)|1;\n\tfor(i=0;i<30;i++)\n\t\tif((v>>i)&1)\n\t\t\tfor(j=i;j<30;j++)\n\t\t\t\tif((~u>>j)&1){\n\t\t\t\t\ta[t]=(u^(u&((1<<j)-1)))|(1<<j);\n\t\t\t\t\treturn ;\n\t\t\t\t  }\n}\nint main()\n{\n\tint i,x,y;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t  }\n\tdfs(1,0);\n\tfor(i=29;i>=0;i--)\n\t\tif((a[1]>>i)&1){\n\t\t\tprintf(\"%d\",i);\n\t\t\treturn 0;\n\t\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n;\n\nvector<int> G[maxn];\n\nint Ans[maxn],vis[maxn];\n\nvoid dfs(int u,int f){\n\tint t=0;\n\tfor(auto v:G[u])if(v!=f){\n\t\tdfs(v,u);\n\t\tt|=vis[u]&vis[v];\n\t\tvis[u]|=vis[v];\n\t}\n\twhile((1<<Ans[u])<=t||((vis[u]>>Ans[u])&1))Ans[u]++;\n\tvis[u]&=~((1<<Ans[u])-1);\n\tvis[u]|=1<<Ans[u];\n}\n\nvoid Work(){\n\tdfs(1,0);\n\tint ans=0;\n\tREP(i,1,n)ans=max(ans,Ans[i]);\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG[u].PB(v);G[v].PB(u);\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define x first    \n# define y second\n# define mp make_pair\n// everything go according to my plan      \n# define pb push_back\n# define sz(a) (int)(a.size())\n# define vec vector         \n// shimkenttin kyzdary, dzyn, dzyn, dzyn...\n# define y1    Y_U_NO_y1\n# define left  Y_U_NO_left\n# define right Y_U_NO_right  \n\nusing namespace std;\n\ntypedef pair <int, int> pii; \ntypedef long long ll;\ntypedef long double ld;\n\nconst int Mod = (int)1e9 + 7;\nconst int MX = 1073741822;\nconst ll MXLL = 4e18;\nconst int Sz = 1110111;\n// a pinch of soul\ninline void Read_rap () {\n  ios_base :: sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n}\ninline void randomizer3000 () {\n  unsigned int seed;\n  asm (\"rdtsc\" : \"=A\"(seed));\n  srand (seed);\n}\nvoid files (string problem) {   \n  if (fopen ((problem + \".in\").c_str(),\"r\")) {\n    freopen ((problem + \".in\").c_str(),\"r\",stdin);\n    freopen ((problem + \".out\").c_str(),\"w\",stdout);\n  }\n}\nvoid localInput(const char in[] = \"s\") { \n  if (fopen (in, \"r\")) {\n    freopen (in, \"r\", stdin);\n  }\n  else\n    cerr << \"Warning: Input file not found\" << endl;\n}\nint n;\n\nvec<int> g[Sz];\n\nint mx[Sz], mx2[Sz];\nint D;\n\nvoid dfs (int v, int pr) {\n  for (int to : g[v]) {\n    if (to != pr) {\n      dfs (to, v);\n      if (mx[v] < mx[to] + 1)\n        mx2[v] = mx[v], mx[v] = mx[to] + 1;\n      else\n        mx2[v] = max (mx2[v], mx[to] + 1);\n    }\n  }\n  D = max (mx[v] + mx2[v], D);\n}\nint main()\n{\n  # ifdef Local\n    //localInput();\n  # endif\n  Read_rap();\n  cin >> n;\n  for (int i = 1; i < n; i++) {\n    int a, b; cin >> a >> b;\n    g[a].pb (b);\n    g[b].pb (a);\n  }     \n  dfs (1, 1);\n\n  cout << (int)log2(D + 1);        \n\n  return 0;\n}\n\n\n\n\n\n\n// Coded by Z..\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[100001];\n/*\nint h[100001];\nll dp[100001];\n\nvoid dfs(int u, int p)\n{\n\tif(p==-1) h[u]=0;\n\telse h[u]=h[p]+1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tif(adj[u][i]==p) continue;\n\t\tdfs(adj[u][i],u);\n\t}\n}\n*/\nconst int N = 1e5 + 3;\n\nint subsize[N];\nbool visited[N];\nint treesize;\nvoid dfs(int u, int par)\n{\n\tsubsize[u] = 1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tdfs(v, u);\n\t\tsubsize[u] += subsize[v];\n\t}\n\ttreesize=subsize[u];\n}\n\nint centroid(int u, int par)\n{\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tif(subsize[v]*2 > treesize) return centroid(v, u);\n\t}\n\treturn u;\n}\n\nint compsolve(int u)\n{\n\tdfs(u, -1);\n\tint cent = centroid(u, -1);\n\tvisited[cent]=1;\n\tint ans = -1;\n\tfor(int i = 0; i < adj[cent].size(); i++)\n\t{\n\t\tint v = adj[cent][i];\n\t\tif(visited[v]) continue;\n\t\tans=max(ans,compsolve(v));\n\t}\n\treturn ans+1;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tcout<<compsolve(0)<<'\\n';\n\t/*\n\tdp[1] = 2;\n\tfor(int i = 2; i <= 60; i++)\n\t{\n\t\tdp[i] = (dp[i-1]*2+2);\n\t}\n\tdfs(0,-1);\n\tint best = 0; int idx = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t\tidx=i;\n\t\t}\n\t}\n\tdfs(idx,-1);\n\tbest=0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t}\n\t}\n\t//cerr<<best<<'\\n';\n\tfor(int i = 1; i <= 60; i++)\n\t{\n\t\tif(best<=dp[i])\n\t\t{\n\t\t\tcout<<i<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\n\nint n;\nvector <int> neigh[Maxn];\nint par[Maxn];\nbool er[Maxn];\n\nii Get(int v, int p)\n{\n    par[v] = p;\n    ii res = ii(1, v);\n    for (int i = 0; i < neigh[v].size(); i++) {\n        int u = neigh[v][i];\n        if (u == p || er[u]) continue;\n        ii g = Get(u, v);\n        res = max(res, ii(g.first + 1, g.second));\n    }\n    return res;\n}\n\nint Solve(int v)\n{\n    ii g = Get(v, 0);\n    g = Get(g.second, 0);\n    int tk = g.first / 2;\n    int u = g.second;\n    while (tk--) u = par[u];\n    er[u] = true;\n    int mx = 0;\n    for (int i = 0; i < neigh[u].size(); i++) {\n        int nxt = neigh[u][i];\n        if (!er[nxt]) mx = max(mx, Solve(nxt) + 1);\n    }\n    return mx;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        neigh[a].push_back(b);\n        neigh[b].push_back(a);\n    }\n    printf(\"%d\\n\", Solve(1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n// manually set n = number of vertices \n// vertex index from 1 to n\n// first call tree_init();\n// ae(u,v) only one direction\n\nconst int TREE_MAXV=300000+5;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pre[TREE_MAXV];\nint n;\nint f[333333];\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpre[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t}\n\t}\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\nvoid readedge(){\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;gn(x);gn(y);\n\t\tae(x,y);ae(y,x);\n\t}\n}\n\n\nvoid work(int u){\n\tint gg=0,tmp=0;\n\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\tgg|=f[e[i].v]&tmp;\n\t\ttmp|=f[e[i].v];\n\t}\n\tif(gg>0){\n\t\twhile(gg&(gg-1))gg&=gg-1;\n\t\ttmp|=gg&(gg-1);\n\t}\n\tf[u]=tmp+1;\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);\n\ttree_init();\n\treadedge();\n\n\tbfs(1);\n\tfor(int i=n-1;i>=0;i--)work(qu[i]);\n\tint ret=1;\n\twhile(pw(ret)<=f[1])ret++;\n\tprintf(\"%d\\n\",ret-1);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma optimize O3\nusing namespace __gnu_pbds;\nusing namespace std;\ntemplate <typename T> using ordered_set =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset =  tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \n#define RETD(x) { cout << fixed << setprecision(15) << x; exit(0); }\nconst ll M=2e5+5,LG=32,SM=600+5,inf=1e18+5;\nll mod=1e9+7;\n\nll n;\nvll g[M];\nll mark[M][LG];\n \nvoid dfs(ll x,ll p)\n{\n    for (ll y:g[x])\n    {\n        if (y!=p)\n        {    \n            dfs(y,x);\n            For(i,0,LG)\n            {\n                mark[x][i]+=mark[y][i];\n            }\n        }\n    }\n    ll nd=-1;\n    For(i,0,LG)\n    {\n        if (mark[x][i]>1)\n            nd=i;    \n    }\n    nd++;\n    For(i,0,nd)\n        mark[x][i]=0;\n    while (mark[x][nd]!=0)\n    {\n        mark[x][nd]=0;\n        nd++;\n    }\n    mark[x][nd]=1;\n    return;\n}\n \nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n;\n    For(i,1,n)\n    {\n        ll a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].PB(b);g[b].PB(a);\n    }\n    dfs(0,0);\n    ll cnt=0;\n    For(i,0,LG)\n    {\n        if (mark[0][i])\n            cnt=i;\n    }\n    RET(cnt);\n}    \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------------------------head--------------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,dp[N];\nvi g[N];\nbool vis[N];\n\nvoid dfs(int x){\n\tint cnt[20];clr(cnt,0);\n\tvis[x]=1;\n\tfor(int y:g[x]){\n\t\tif(vis[y]) continue;\n\t\tdfs(y);\n\t\tfor(int i=0;i<m;i++)\n\t\t\tif(dp[y]&1) cnt[i]++;\n\t}\n\tint mx=-1;\n\tfor(int i=0;i<m;i++)\n\t\tif(cnt[i]>=2) mx=i;\n\tfor(int i=0;i<m;i++)\n\t\tif(!cnt[i]&&i>mx){\n\t\t\tfor(int j=0;j<i;j++) cnt[j]=0;\n\t\t\tcnt[i]=1;\n\t\t}\n\tfor(int i=0;i<m;i++) dp[x]|=(cnt[i]>0)<<i;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\twhile((1<<m)<=n) m++;\n\tdfs(1);\n\tfor(int i=m;~i;i--)\n\t\tif(dp[1]&(1<<i)){print(i);break;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint solve(int pos, int pre, vector<vector<int> > &g) {\n\tint req = 0, mx = 0;\n\tvector<int> lens;\n\tfor (int i : g[pos]) {\n\t\tif (i == pre) continue;\n\t\tint res = solve(i, pos, g);\n\t\tint res_req = 0;\n\t\tint res_len = 0;\n\t\twhile (2 << res_len < res) ++res_len;\n\t\twhile ((res >> res_req) & 1) ++res_req;\n\t\treq = max(req, res_req);\n\t\tmx = max(mx, res);\n\t\tlens.push_back(res_len);\n\t}\n\tsort(lens.begin(), lens.end(), greater<int>());\n\tif (lens.size() >= 2) req = max(req, lens[1] + 1);\n\t++mx;\n\treturn ((mx + (1 << req) - 1) >> req) << req;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint n, a, b;\n\tcin >> n;\n\tvector<vector<int> > g(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcin >> a >> b; --a, --b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint ret = solve(0, -1, g);\n\tint ans = 0;\n\twhile (2 << ans <= ret) ++ans;\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef complex<double> cd;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\nstring Yes[2] = {\"No\\n\", \"Yes\\n\"};\nstring YES[2] = {\"NO\\n\", \"YES\\n\"};\nstring Possible[2] = {\"Impossible\\n\", \"Possible\\n\"};\nstring POSSIBLE[2] = {\"IMPOSSIBLE\\n\", \"POSSIBLE\\n\"};\n\nint ok(int x, int n)\n{\n    return 0 <= x && x < n;\n}\n\nll log10(ll x)\n{\n    if (x < 10) re 1;\n    re 1 + log10(x / 10);\n}\n\nll ds(ll x)\n{\n    if (x < 10) return x;\n    re x % 10 + ds(x / 10);\n}\n\ndouble sqr(double x)\n{\n    return x * x;\n}\n\nbool in(int bit, int mask)\n{\n    return (mask & (1 << bit)) > 0;\n}\n\nvoid Del(vector<int> &v, int pos)\n{\n    swap(v[pos], v[v.size() - 1]);\n    v.pop_back();\n}\n\nlong long g(vector<long long> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nint g(vector<int> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nint __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\ninline void __precompute_combinatorics(int __n)\n{\n    if (__precomputed_combinatorics >= __n)\n        return;\n    __fact.resize(__n);\n    __ufact.resize(__n);\n    __rev.resize(__n);\n    __rev[1] = 1;\n    for (int i = max(2, __precomputed_combinatorics); i < __n; i++)\n        __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = max(1, __precomputed_combinatorics); i < __n; i++)\n        __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n    __precomputed_combinatorics = __n;\n}\n\nll fact(int x)\n{\n    if (__precomputed_combinatorics <= x)\n        __precompute_combinatorics(x + 1);\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n)\n        return 0;\n    if (__precomputed_combinatorics <= n)\n        __precompute_combinatorics(n + 1);\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nstruct dsu\n{\n    vector<int> root;\n    vector<int> sz;\n\n    dsu(int _n)\n    {\n        root.resize(_n);\n        iota(all(root), 0);\n        sz.resize(_n, 1);\n    }\n\n    dsu()\n    {\n        dsu(0);\n    }\n\n    void Reset(int _n)\n    {\n        root.resize(_n);\n        sz.resize(_n);\n        for (int i = 0; i < root.size(); i++)\n        {\n            root[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    void Reset()\n    {\n        Reset(root.size());\n    }\n\n    int Root(int x)\n    {\n        if (x == root[x]) return x;\n        return root[x] = Root(root[x]);\n    }\n\n    void Merge(int v, int u)\n    {\n        v = Root(v), u = Root(u);\n        if (v == u) return;\n        if (sz[v] < sz[u])\n        {\n            sz[u] += sz[v];\n            root[v] = u;\n        }\n        else\n        {\n            sz[v] += sz[u];\n            root[u] = v;\n        }\n    }\n};\n\nstruct dsu_cut\n{\n    vector<int> root;\n    vector<int> sz;\n    stack<int> cuts;\n\n    dsu_cut(int _n)\n    {\n        root.resize(_n);\n        iota(all(root), 0);\n        sz.resize(_n, 1);\n    }\n\n    dsu_cut()\n    {\n        dsu_cut(0);\n    }\n\n    void Cut()\n    {\n        if (!cuts.size()) return;\n        int v = cuts.top();\n        sz[root[v]] -= sz[v];\n        root[v] = v;\n        cuts.pop();\n    }\n\n    void Reset(int _n)\n    {\n        root.resize(_n);\n        sz.resize(_n);\n        for (int i = 0; i < root.size(); i++)\n        {\n            root[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    void Reset()\n    {\n        if (cuts.size() < root.size())\n        {\n            while (cuts.size())\n            {\n                Cut();\n            }\n        }\n        else\n        {\n            Reset(root.size());\n        }\n    }\n\n    int Root(int x)\n    {\n        if (x == root[x]) return x;\n        return Root(root[x]);\n    }\n\n    void Merge(int v, int u)\n    {\n        v = Root(v), u = Root(u);\n        if (v == u) return;\n        if (sz[v] < sz[u])\n        {\n            sz[u] += sz[v];\n            root[v] = u;\n            cuts.push(v);\n        }\n        else\n        {\n            sz[v] += sz[u];\n            root[u] = v;\n            cuts.push(u);\n        }\n    }\n};\n\nvoid bfs(int v, vi &dist, vector<vi> &graph)\n{\n    fill(all(dist), -1);\n    dist[v] = 0;\n    vi q = {v};\n    for (int i = 0; i < q.size(); i++)\n    {\n        for (auto u : graph[q[i]])\n        {\n            if (dist[u] == -1)\n            {\n                dist[u] = dist[q[i]] + 1;\n                q.push_back(u);\n            }\n        }\n    }\n}\n\nvector<int> z_func(string &s)\n{\n    // Calculates z-function of string s\n    // z[0] = s.size(), s should not be empty\n    //\n    // Tested on the following problem:\n    // https://codeforces.com/edu/course/2/lesson/3/3/practice/contest/272263/problem/A\n    //\n    vector<int> z(s.size());\n    z[0] = s.size();\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    return z;\n}\n\nvector<int> p_func(string &s)\n{\n    // Calculates prefix function of string s\n    //\n    //\n    vector<int> p(s.size());\n    for (int i = 1; i < s.size(); i++)\n    {\n        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = p[j - 1];\n        if (s[i] == s[j])\n            j++;\n        p[i] = j;\n    }\n    return p;\n}\n\nvector<int> d1_func(string &s)\n{\n    // Calculates max length of palindrome centered in positions and i for each i\n    //\n    //\n    vector<int> d1(s.size());\n    int L = 0, R = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d1[R - i + L]);\n        while (i + k < s.size() && i - k >= 0 && s[i - k] == s[i + k])\n            k++;\n        d1[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k;\n            R = i + k;\n        }\n    }\n    return d1;\n}\n\nvector<int> d2_func(string &s)\n{\n    // Calculates max length of palindrome centered in positions i - 1 and i for each i\n    //\n    //\n    vector<int> d2(s.size());\n    int L = 0, R = -1;\n    for (int i = 1; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d2[R - i + L + 1]);\n        while (i + k < s.size() && i - k - 1 >= 0 && s[i - k - 1] == s[i + k])\n            k++;\n        d2[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k - 1;\n            R = i + k;\n        }\n    }\n    return d2;\n}\n\nvoid add(int pos, ll x, vector<ll> &fenw)\n{\n    // Performs add query on Fenwick tree\n    //\n    // Tested on the following problem:\n    // https://atcoder.jp/contests/practice2/tasks/practice2_b\n    //\n    while (pos < fenw.size())\n    {\n        fenw[pos] += x;\n        pos |= (pos + 1);\n    }\n}\n\nll get(int pos, vector<ll> &fenw)\n{\n    // Performs get query on Fenwick tree\n    //\n    // Tested on the following problem:\n    // https://atcoder.jp/contests/practice2/tasks/practice2_b\n    //\n    ll res = 0;\n    while (pos >= 0)\n    {\n        res += fenw[pos];\n        pos = (pos & (pos + 1)) - 1;\n    }\n    return res;\n}\n\nstruct dcp_offine{\n    // Given n, m and arrays v, u, t of length m\n    // -1 <= t[i] <= 1 and 0 <= v[i], u[i] < n satisfied for t[i] != -1\n    // t[i] = 0 asks to change state of edge (v[i], u[i])\n    // t[i] = -1 asks to calculate number of connected components\n    // t[i] = 1 asks to check if v[i] and u[i] are in the same connected component\n    // After creating following holds:\n    // ans[i] contains -1 for t[i] = 0 and answer for the i-th query otherwise\n    //\n    // Correctness t[i] <= 0 tested on the following problem:\n    // https://codeforces.com/edu/course/2/lesson/7/3/practice/contest/289392/problem/C\n    // Correctness tested on random tests with m = 40000\n    // Speed tested on random tests with m = 2e6, average = 0.955ms/test (local)\n    //\n    int n, m;\n    dsu_cut dcp;\n    vector<int> ans;\n    void solve(int l, int r, vi &v, vi &u, vi &t, vi &L, vi &R)\n    {\n        if (l >= r) return;\n        if (l + 1 == r)\n        {\n            if (t[l] == -1)\n            {\n                ans[l] = n - dcp.cuts.size();\n            }\n            if (t[l] == 1)\n            {\n                ans[l] = dcp.Root(v[l]) == dcp.Root(u[l]);\n            }\n            return;\n        }\n        int m = (l + r) / 2;\n        int ss = dcp.cuts.size();\n        for (int i = l; i < m; i++)\n        {\n            if (R[i] >= r) dcp.Merge(v[i], u[i]);\n        }\n        solve(m, r, v, u, t, L, R);\n        while (dcp.cuts.size() > ss) dcp.Cut();\n        for (int i = r - 1; i >= m; i--)\n        {\n            if (L[i] < l) dcp.Merge(v[i], u[i]);\n        }\n        solve(l, m, v, u, t, L, R);\n        while (dcp.cuts.size() > ss) dcp.Cut();\n    }\n    dcp_offine(int _n, int _m, vi v, vi u, vi t)\n    {\n        n = _n, m = _m;\n        dcp.Reset(n);\n        ans.resize(m, -1);\n        map<pair<int, int>, int> mm;\n        vi L(m, INF), R(m, -INF);\n        for (int i = 0; i < m; i++)\n        {\n            if (t[i] != 0) continue;\n            if (v[i] > u[i]) swap(v[i], u[i]);\n            if (mm.find({v[i], u[i]}) == mm.end())\n            {\n                mm[{v[i], u[i]}] = i;\n            }\n            else\n            {\n                int t = mm[{v[i], u[i]}];\n                R[t] = i;\n                L[i] = t;\n                mm.erase({v[i], u[i]});\n            }\n        }\n        while (mm.size())\n        {\n            t.push_back(0);\n            ans.push_back(-1);\n            L.push_back(INF);\n            R.push_back(-INF);\n            auto it = mm.begin();\n            pair<int, int> s = (*it).first;\n            int t = (*it).second;\n            R[t] = m;\n            L[m] = t;\n            v.push_back(s.first);\n            u.push_back(s.second);\n            mm.erase(mm.begin());\n            m++;\n        }\n        solve(0, m, v, u, t, L, R);\n    }\n};\n\ntemplate<class T> struct sparse_min{\n    // Returns min on segment [l, r] of predefined array a\n    //\n    // Correctness tested on the following problem:\n    // https://codeforces.com/contest/1304/problem/E\n    // Speed tested on random tests with n = 4e6, q = 4e6, T = int, average = 0.508ms/test (local)\n    // Speed tested on random tests with n = 4e6, q = 4e7, T = int, average = 1.778ms/test (local)\n    //\n    vector<vector<T> > sp;\n    vector<int> H;\n    T get(int l, int r)\n    {\n        int h = H[r - l + 1];\n        return min(sp[h][l], sp[h][r - (1 << h) + 1]);\n    }\n    sparse_min(vector<T> a)\n    {\n        int n = a.size();\n        H = vector<int>(n + 1);\n        for (int i = 3; i < n + 1; i++)\n        {\n            H[i] = H[i - 1] + (((i - 1) & (i - 2)) == 0);\n        }\n        int s = 0;\n        while ((1 << s) < n) s++;\n        sp = vector<vector<T>>(s, vector<T>(n));\n        for (int i = 0; i < n; i++)\n        {\n            sp[0][i] = a[i];\n        }\n        for (int j = 1; j < s; j++)\n        {\n            for (int i = 0; i + (1 << j) - 1 < n; i++)\n            {\n                sp[j][i] = get(i, i + (1 << j) - 1);\n            }\n        }\n    }\n};\n\ntemplate<class T> struct sparse_max{\n    // Returns min on segment [l, r] of predefined array a\n    //\n    // Correctness tested on the following problem:\n    // https://codeforces.com/contest/1304/problem/E\n    // Speed tested on random tests with n = 4e6, q = 4e6, T = int, average = 0.508ms/test (local)\n    // Speed tested on random tests with n = 4e6, q = 4e7, T = int, average = 1.778ms/test (local)\n    //\n    vector<vector<T> > sp;\n    vector<int> H;\n    T get(int l, int r)\n    {\n        int h = H[r - l + 1];\n        return max(sp[h][l], sp[h][r - (1 << h) + 1]);\n    }\n    sparse_max(vector<T> a)\n    {\n        int n = a.size();\n        H = vector<int>(n + 1);\n        for (int i = 3; i < n + 1; i++)\n        {\n            H[i] = H[i - 1] + (((i - 1) & (i - 2)) == 0);\n        }\n        int s = 0;\n        while ((1 << s) < n) s++;\n        sp = vector<vector<T>>(s, vector<T>(n));\n        for (int i = 0; i < n; i++)\n        {\n            sp[0][i] = a[i];\n        }\n        for (int j = 1; j < s; j++)\n        {\n            for (int i = 0; i + (1 << j) - 1 < n; i++)\n            {\n                sp[j][i] = get(i, i + (1 << j) - 1);\n            }\n        }\n    }\n};\n\nstruct scc_graph{\n    // Find Strongly Connected Components of given graph\n    //\n    // Correctness tested on the following problem:\n    // https://atcoder.jp/contests/arc069/tasks/arc069_d\n    //\n    int n;\n    vector<vector<int> > graph;\n    vector<vector<int> > inv_graph;\n    vector<int> fr, to;\n    vector<int> fn;\n    vector<int> vis;\n    vector<int> component;\n    int col;\n    void inv_dfs(int v)\n    {\n        vis[v] = 1;\n        for (auto id : inv_graph[v])\n        {\n            int u = fr[id];\n            if (!vis[u])\n            {\n                inv_dfs(u);\n            }\n        }\n        fn.push_back(v);\n    }\n    void dfs(int v)\n    {\n        component[v] = col;\n        for (auto id : graph[v])\n        {\n            int u = to[id];\n            if (component[u] == -1)\n            {\n                dfs(u);\n            }\n        }\n    }\n    scc_graph(int _n)\n    {\n        n = _n;\n        graph = vector<vector<int> >(n);\n        inv_graph = vector<vector<int> >(n);\n    }\n    void add_edge(int v, int u)\n    {\n        graph[v].push_back(fr.size());\n        inv_graph[u].push_back(fr.size());\n        fr.push_back(v);\n        to.push_back(u);\n    }\n    vector<vector<int> > scc()\n    {\n        vis = vector<int>(n);\n        component = vector<int>(n, -1);\n        fn = {};\n        col = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (!vis[i])\n            {\n                inv_dfs(i);\n            }\n        }\n        reverse(fn.begin(), fn.end());\n        for (auto i : fn)\n        {\n            if (component[i] == -1)\n            {\n                dfs(i);\n                col++;\n            }\n        }\n        vector<vector<int> > res(col);\n        for (int i = 0; i < n; i++)\n        {\n            res[component[i]].push_back(i);\n        }\n        return res;\n    }\n};\n\nint ans;\n\nvector<int> solve(int v, int p, vvi &graph)\n{\n    vector<int> cnt(20);\n    for (auto u : graph[v]) if (u != p)\n    {\n        vector<int> z = solve(u, v, graph);\n        for (int j = 0; j < 20; j++) cnt[j] += z[j];\n    }\n    int sel = -1;\n    for (int j = 0; j < 20; j++)\n    {\n        if (cnt[j] >= 2)\n        {\n            sel = j + 1;\n        }\n    }\n    for (int j = sel + 1; j < 20; j++)\n    {\n        if (cnt[j] == 0)\n        {\n            sel = j;\n            break;\n        }\n    }\n    cnt[sel]++;\n    for (int j = 0; j < sel; j++)\n    {\n        cnt[j] = 0;\n    }\n    ans = max(ans, sel);\n    return cnt;\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    vvi graph(n);\n    forn(i, n - 1)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    solve(0, 0, graph);\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code (MOD, INF, INFLL)\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=1e5+3;\nint n,lg2,f[mn],gra,beg[mn],to[mn*2],nex[mn*2];\nvoid ins(int u,int v){\n\tto[++gra]=v;\n\tnex[gra]=beg[u];\n\tbeg[u]=gra;\n}\nvoid dfs(int p,int q){\n\tint tmp=0;\n\tfr(i,p)if(to[i]!=q){\n\t\tdfs(to[i],p);\n\t\ttmp|=f[p]&f[to[i]];\n\t\tf[p]|=f[to[i]];\n\t}\n\tint lim=0;\n\tfd(i,lg2,0)if(tmp&(1<<i)){lim=i+1;break;}\n\tfo(i,lim,lg2)if(!(f[p]&(1<<i)))\n\t\t{f[p]=((f[p]>>i)+1)<<i;return;}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tins(u,v);\n\t\tins(v,u);\n\t}\n\tlg2=log(n)/log(2)+1;\n\tdfs(1,0);\n\tfd(i,lg2,0)if(f[1]&(1<<i)){printf(\"%d\",i);return 0;}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n\n          A FAN OF FIZZYDAVID\n\n*/\n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n#define FILL(a,b) memset((a),(b),sizeof((a)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<LL> vl;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\n\nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n\ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1,typename T2,typename T3,typename T4>\nvoid scf(T1 &x,T2 &y,T3 &z,T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n\n//---------------------------head----------------------------\n\nconst int N = 1e5 + 100;\nconst int M = 2147483647;\n\nint dp[N];\nvi g[N];\n\nint lowbit(int x){ return x & (-x); }\n\nvoid dfs(int u = 1, int fa = 0)\n{\n    int on = 0, tw = 0;\n    for(int v: g[u]) if(v != fa)\n    {\n        dfs(v, u);\n        tw |= on & dp[v];\n        on |= dp[v];\n    }\n    while(lowbit(tw) != tw) tw ^= lowbit(tw);\n    if(!tw) tw = 1; else tw <<= 1;\n    while(on & tw) tw <<= 1;\n    #ifdef DEBUG\n    cout<<u<<endl;\n    for(int v:g[u]) if(v != fa) cout<<v<<' '<<dp[v]<<endl;\n    cout<<tw<<endl;\n    puts(\"----------------------------------\");\n    #endif // DEBUG\n    dp[u] = (on & (M ^ (tw - 1))) | tw;\n    return;\n}\n\norz yjz()\n{\n    int n; scf(n);\n    rep(i, n - 1)\n    {\n        int u, v; scf(u, v);\n        g[u].pb(v); g[v].pb(u);\n    }\n    dfs();\n    nrof(i, 30, 0) if(dp[1] & (1 << i)){ printf(\"%d\\n\",i); fizzydavid ak la }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n;\nvector<int> g[maxn];\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    v--;\n    u--;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  return true;\n}\n\nint del[maxn];\nint d[maxn];\n\nint dfs(int v, int p) {\n  int res = v;\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (del[u] || u == p) {\n      continue;\n    }\n    d[u] = d[v] + 1;\n    int cur = dfs(u, v);\n    if (d[cur] > d[res]) {\n      res = cur;\n    }\n  }\n  return res;\n}\n\nbool getPath(int v, int t, int p, vector<int> &path) {\n  path.push_back(v);\n  if (v == t) {\n    return true;\n  }\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (del[u] || u == p) {\n      continue;\n    }\n    if (getPath(u, t, v, path)) {\n      return true;\n    }\n  }\n  path.pop_back();\n  return false;\n}\n\nint rec(int v) {\n  d[v] = 0;\n  v = dfs(v, -1);\n  d[v] = 0;\n  int u = dfs(v, -1);\n  vector<int> path;\n  getPath(v, u, -1, path);\n  v = path[sz(path) / 2];\n  del[v] = true;\n  int res = 0;\n  for (int i = 0; i < sz(g[v]); i++) {\n    u = g[v][i];\n    if (!del[u]) {\n      res = max(res, rec(u) + 1);\n    }\n  }\n  return res;\n}\n\nvoid solve() {\n  for (int i = 0; i < n; i++) {\n    del[i] = false;\n  }\n  printf(\"%d\\n\", rec(0));\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      //if(!used[i]&&belong[i]<0) exit(0);\n      if(!used[i]&&cnt[i]>1) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nvector<int> G[100010];\n\nll dp[100010];\n\nll DFS(int v,int p)\n{\n    ll AND = 0,OR = 0;\n    if(G[v].size() == 1 && G[v][0] == p)return dp[v] = 1;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int ne = G[v][i];\n        if(ne == p)continue;\n        ll now = DFS(ne,v);\n        AND |= (now & OR);\n        OR |= now;\n    }\n    int id = 0;\n    while(AND >= (1 << id))id++;\n    while((OR >> id) & 1)id++;\n    return dp[v] = (OR + (1 << id)) & (~((1 << id) - 1));\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    ll res = DFS(1,-1);\n\n    for(int i = 0; res >> i; i++)\n    {\n        if(res >> i + 1 == 0)\n        {\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define maxn 100005\nusing namespace std;\nint n,ans,f[maxn][30];\nstruct node { int v; node *nxt; } edge[maxn*2],*head[maxn],*ncnt;\nvoid addedge(int u,int v)\n{\n\tncnt++;\n\tncnt->v=v,ncnt->nxt=head[u];\n\thead[u]=ncnt;\n}\nvoid dfs(int u,int fa)\n{\n\tfor(node *p=head[u];p;p=p->nxt)\n\t{\n\t\tint v=p->v;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u); \n\t\tfor(int i=0;i<=20;i++) f[u][i]+=f[v][i];\n\t}\n\tint p=0;\n\tfor(int i=20;i>=0;i--)\n\t\tif(f[u][i]>1) { p=i+1; break; }\n\twhile(f[u][p]) p++;\n\tf[u][p]++;\n\tfor(int i=0;i<p;i++) f[u][i]=0;\n\tans=max(ans,p);\n}\nint main()\n{\n\tncnt=&edge[0];\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nconst int N=100005;\n \nstruct E{\n\tint to,next;\n}mem[N<<1];\nint n,num,x,y,inf,ans;\nint head[N],dp[N][2],d[N],f[N][2];\n\nvoid add(int x,int y){\n\tnum++;\n\tmem[num].to=y; mem[num].next=head[x];\n\thead[x]=num;\n}\n\nvoid dfs1(int k,int pre){\n\tint j,u,mx1,mx2; mx1=mx2=0;\n\tif (d[k]==1&&k>1){\n\t\tdp[k][0]=dp[k][1]=0;\n\t\treturn;\n\t}\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre) continue;\n\t\tdfs1(u,k);\n\t\tmx1=max(mx1,min(dp[u][0],dp[u][1]));\n\t\tmx2=max(mx2,dp[u][1]);\n\t}\n\tif ((k==1&&d[k]==1)||(k>1&&d[k]==2)){\n\t\tif (mx2) dp[k][0]=mx2;\n\t\telse dp[k][0]=mx2+1;\n\t}\n\tdp[k][1]=mx1+1;\n\tdp[k][0]=min(dp[k][0],mx1+1);\n}\n\nvoid dfs2(int k,int pre){\n\tint j,u,cnt,w;\n\tvector<int> son,mx[2];\n\tson.clear();\n\tmx[0].clear(); mx[1].clear();\n\tw=min(f[k][0],f[k][1]);\n\tfor (j=head[k];j;j=mem[j].next){\n\t\tu=mem[j].to;\n\t\tif (u==pre) continue;\n\t\tson.push_back(u);\n\t\tmx[0].push_back(min(dp[u][0],dp[u][1]));\n\t\tmx[1].push_back(min(dp[u][0],dp[u][1]));\n\t\tw=max(w,min(dp[u][0],dp[u][1]));\n\t}\n\tans=min(ans,w+1);\n\tcnt=son.size()-1;\n\tif (!cnt){\n\t\tu=son[0];\n\t\tif (k==1) f[u][0]=f[u][1]=0;\n\t\telse{\n\t\t\tif (f[k][1]) f[u][0]=f[k][1];\n\t\t\telse f[u][0]=f[k][1]+1;\n\t\t\tf[u][1]=f[k][0]+1;\n\t\t}\n\t\tdfs2(u,k);\n\t\treturn;\n\t}\n\tfor (j=1;j<=cnt;j++) mx[0][j]=max(mx[0][j],mx[0][j-1]);\n\tfor (j=cnt-1;j>=0;j--) mx[1][j]=max(mx[1][j],mx[1][j+1]);\n\tfor (j=0;j<=cnt;j++){\n\t\tu=son[j];\n\t\tw=min(f[k][0],f[k][1]);\n\t\tif (j>0) w=max(w,mx[0][j-1]);\n\t\tif (j<cnt) w=max(w,mx[1][j+1]);\n\t\tf[u][0]=f[u][1]=w+1;\n\t\tdfs2(u,k);\n\t}\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t\td[x]++; d[y]++;\n\t}\n\tmemset(dp,0x3f,sizeof(dp)); inf=dp[0][0];\n\tmemset(f,0x3f,sizeof(f));\n\tdfs1(1,0);\n\tans=min(dp[1][0],dp[1][1]);\n\tf[1][1]=f[1][0]=0;\n\tdfs2(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin p2(in a){\n  return 1LL<<a;\n}\nVVI egs;\nconst in mx=50;\npair<in,in> dfs(in u, in pr){\n  VI hv(mx,0);\n  pair<in,in> tp;\n  forv(i,egs[u]){\n    if(egs[u][i]==pr)\n      continue;\n    tp=dfs(egs[u][i],u);\n    forn(j,tp.second+1){\n      if(tp.first&p2(j))\n\t++hv[j];\n    }\n  }\n  in tt=mx-1;\n  while(tt>=0 && hv[tt]<=1)\n    --tt;\n  ++tt;\n  while(hv[tt])\n    ++tt;\n  hv[tt]=1;\n  in tmsk=0;\n  while(tt<mx){\n    if(hv[tt])\n      tmsk|=p2(tt);\n    ++tt;\n  }\n  --tt;\n  while(!hv[tt])\n    --tt;\n  return MP(tmsk,tt);\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  egs.resize(n);\n  in ta,tb;\n  forn(z,n-1){\n    cin>>ta>>tb;\n    --ta;\n    --tb;\n    egs[ta].PB(tb);\n    egs[tb].PB(ta);\n  }\n  cout<<dfs(0,0).second<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<vector>\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nconst int M = 1e9 + 7;\nconst ll MLL = 1e18L + 9;\n#pragma unused(M)\n#pragma unused(MLL)\n#ifdef LOCAL\n#include\"basic.hpp\"\n#else\ntemplate <class... T> void printl(T&&...){ }\ntemplate <class... T> void printc(T&&...){ }\ntemplate <class... T> void prints(T&&...){ }\ntemplate <class... T> void printd(T&&...){ }\n#endif\n\nstruct Node{\n    vector<Node*> dests;\n    void add(Node* n){\n        dests.push_back(n);\n    }\n    void add2(Node* n){\n        add(n);\n        n->add(this);\n    }\n    pair<int, Node*> dfs(Node* from = nullptr){\n        pair<int, Node*> ret = {0, this};\n        for(Node* d : dests){\n            if(d == from){ continue; }\n            auto p = d -> dfs(this);\n            p.first++;\n            ret = max(ret, p);\n        }\n        return ret;\n    }\n    pair<int, Node*> dfs_(Node* from = nullptr){\n        pair<int, Node*> ret = {0, this};\n        for(Node* d : dests){\n            if(d == from){ continue; }\n            auto p = d -> dfs(this);\n            p.first++;\n            ret = max(ret, p);\n        }\n        return ret;\n    }\n};\n\npair<int, Node*> dfs2(Node* from){\n    pair<int, Node*> ret = {0, from};\n    vector<pair<Node*, int>> st = {{from, 0}};\n    set<Node*> visited = {from};\n    while(st.size()){\n        auto n = st.back(); st.pop_back();\n        auto node = n.first;\n        pair<int, Node*> depth = {n.second, n.first};\n        ret = max(ret, depth);\n        for(Node* d : node->dests){\n            if(visited.count(d)){ continue; }\n            visited.insert(d);\n            st.emplace_back(d, depth.first + 1);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int n; cin >> n;\n    vector<Node> nodes(n);\n    for(int i=0;i<n;i++){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        nodes[a].add2(&nodes[b]);\n    }\n    auto f1 = dfs2(&nodes[0]);\n    auto f2 = dfs2(f1.second);\n    // auto f1 = nodes[0].dfs();\n    // auto f2 = f1.second->dfs();\n    int d = f2.first;\n    printd(d);\n    int num = 0, ans = 0;\n    for(int i=1;i<M;i++){\n        num = num * 2 + 2;\n        prints(num, d, i);\n        if(num >= d){ ans = i; break; }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nset<int> S[MAX_N];\nvector<int> G[MAX_N];\nint cnt[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\tcnt[a]++;\n\t\tcnt[b]++;\n\t}\n\tqueue<int> que;\n\trep(i, 0, N) {\n\t\tif(cnt[i] == 1) que.push(i);\n\t}\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tint at = 0;\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] != 0) continue;\n\t\t\tif(sz(S[n]) > sz(S[v])) swap(S[n], S[v]);\n\t\t\tfor(auto d : S[n]) {\n\t\t\t\tif(S[v].count(d)) MAX(at, d + 1);\n\t\t\t\telse S[v].insert(d);\n\t\t\t}\n\t\t}\n\t\twhile(!S[v].empty() && (*(S[v].begin())) < at) S[v].erase(S[v].begin());\n\t\twhile(!S[v].empty() && (*(S[v].begin())) == at) {\n\t\t\tS[v].erase(S[v].begin());\n\t\t\tat++;\n\t\t}\n\t\tS[v].insert(at);\n\t\tMAX(ans, at);\n\n\t\t// debug(v, vi(all(S[v])));\n\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] == 0) continue;\n\t\t\tcnt[n]--;\n\t\t\tcnt[v]--;\n\t\t\tif(cnt[n] == 1) que.push(n);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[N<<1];\nint n,home[N],cnt=-1,lg2[N<<1];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nint f[N],sum[25];\nvoid dfs(int k,int F){\n\tfor(int i=home[k];~i;i=e[i].next)if(e[i].k!=F){\n\t\tdfs(e[i].k,k);\n\t}\n\tmemset(sum,0,sizeof(sum));\n\tfor(int i=home[k];~i;i=e[i].next)if(e[i].k!=F){\n\t\tint g=f[e[i].k],t;\n\t\twhile(g) t=g&-g,sum[lg2[t]]++,g-=t;\n\t}\n\tint o=0;\n\tfor(int i=20;~i;i--){\n\t\tif(sum[i]){\n\t\t\tif(!o) o=(1<<i);\n\t\t\tif(sum[i]>1){\n\t\t\t\ti++;\n\t\t\t\twhile(sum[i]){\n\t\t\t\t\tf[k]^=(1<<i);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tf[k]|=(1<<i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tf[k]|=(1<<i);\n\t\t}else if(o){\n\t\t\tint h=0,g;\n\t\t\twhile(i>=0){\n\t\t\t\tif(!sum[i]) g=(1<<i)|h;\n\t\t\t\telse h|=(1<<i);\n\t\t\t\tif(sum[i]>1) break;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tf[k]|=g;\n\t\t\treturn;\n\t\t}\n\t}\n\tf[k]=o+o;\n\tif(!f[k]) f[k]=1;\n}\nint main(){\n\t//freopen(\"test.in\",\"r\",stdin);\n\tmemset(home,-1,sizeof(home));\n\tfor(int i=2;i<=200000;i++) lg2[i]=lg2[i>>1]+1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",lg2[f[1]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nconst int N = 200000;\nvector <int> bi[N];\nint dfs(int t, int f = 0)\n{\n    int c = 0, d = 0;\n    for (int i = 0; i < bi[t].size(); ++ i)\n        if (bi[t][i] != f)\n        {\n            int v = dfs(bi[t][i], t);\n            d |= c & v;\n            c ^= v;\n        }\n    for (int i = 30; ~i; -- i)\n        if (i == 0 || (d & (1 << (i - 1))))\n            for (int j = i; ; ++ j)\n                if (!(c & (1 << j)))\n                    return (c | (1 << j)) ^ (c & ((1 << j) - 1));\n}\nint main()\n{\n    cin >> n;\n    for (int i = 1; i < n; ++ i)\n    {\n        int a, b;\n        cin >> a >> b;\n        bi[a].push_back(b);\n        bi[b].push_back(a);\n    }\n    int v = dfs(1);\n    for (int i = 30; ~i; -- i)\n        if (v & (1 << i))\n        {\n            cout << i << endl;\n            return 0;\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Parent[500000], Dist[500000];\nset<int> G[500000];\n\nint DFS(int node, int par, int dist) {\n\tParent[node] = par;\n\tDist[node] = dist;\n\n\tint ret = node;\n\tfor(auto vec : G[node])\n\t\tif(vec != par) \n\t\t\tret = max(ret, DFS(vec, node, dist + 1), [&](int a, int b) {\n\t\t\t\treturn Dist[a] < Dist[b]; \n\t\t\t});\n\t\t\n\treturn ret;\n}\n\nint GetCenter(int node) {\n\tint last = DFS(node, 0, 0);\n\tlast = DFS(last, 0, 0);\n\n\tint d = Dist[last];\n\tfor(int i = 0; i < d / 2; ++i)\n\t\tlast = Parent[last];\n\tif((d + 1) / 2 != d / 2 && rand() % 2)\n\t\tlast = Parent[last];\n\t\n\tint ret = last;\n\n\tlast = DFS(last, 0, 0);\n\tassert(Dist[last] == (d + 1) / 2);\n\n\treturn ret;\n}\n\nint Decomp(int node) {\n\tint cen = GetCenter(node);\n\tfor(auto vec : G[cen]) {\n\t\tG[vec].erase(cen);\n\t}\n\n\tint ans = 0;\n\tfor(auto vec : G[cen])\n\t\tans = max(ans, Decomp(vec) + 1);\n\treturn ans;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tsrand(time(0));\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 1; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tG[a].insert(b);\n\t\tG[b].insert(a);\n\t}\n\n\tcout << Decomp(1) << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 3000050;\nconst int K = 25;\nvector <int> g[N];\nint a[N];\nvoid dfs(int v, int p = -1){\n    int b = 0;\n    for (auto u: g[v]){\n        if (u == p) continue;\n        dfs(u, v);\n        for (int i = b; i < K; i++){\n            if ((a[v] & a[u]) & (1 << i)){\n                b = i + 1;\n            }\n        }\n        a[v] |= a[u];\n        while (a[v] & (1 << b)) b++;\n    }\n    for (int i = 0; i < b; i++) if (a[v] & (1 << i)) a[v] ^= (1 << i);\n    a[v] |= (1 << b);\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n   // freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1);\n    int ans = 0;\n    for (int i = 0; i < K; i++) if (a[1] & (1 << i)) ans = i;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\n#define pa pair<int,int>\n#define fir first\n#define sec second\nusing namespace std;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return  w*s;}\nstruct node{int to,next;} e[290010];\nint n,h[101010],tot,exist[101010][21],Ans;\ninline void add(int from,int to){e[++tot].next=h[from];h[from]=tot;e[tot].to=to;}\ninline void DFS(int now,int ffa){\n\t//debug(now);\n\tfor(rint i=h[now];i;i=e[i].next){\n\t\tint to=e[i].to;if(to==ffa) continue;\n\t\tDFS(to,now);\n\t\tfor(rint j=1;j<=20;++j) exist[now][j]+=exist[to][j];\n\t}\n\tint Min=0;\n\tfor(rint i=1;i<=20;++i) if(exist[now][i]>=2) Min=i;\n\t//debug(Min);\n\tMin++;\n\twhile(exist[now][Min]) Min++;\n\tAns=max(Ans,Min);\n\texist[now][Min]=1;\n\tfor(rint i=1;i<=Min-1;++i) exist[now][i]=0;\n}\nint main()\n{\n\tn=read();\n\tfor(rint i=1;i<n;++i){\n\t\tint u=read(),v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\tDFS(1,0);\n\tcout<<Ans-1<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 1e5 + 100, OO = 1e9 + 7, T = 1e5 + 10, M2 = 1e9 + 7, M = 1e9 + 7,  P = 6151, SQ = 800, lg = 70;\ntypedef pair <int, int> pii;\nvector <int> v[N];\n\npii dfs(int x, int y) {\n\tint mx = 0, id = x;\n\tfor(auto u : v[x]) {\n\t\tif(u != y) {\n\t\t\tpii p = dfs(u, x);\n\t\t\tif(p.ss > mx)\n\t\t\t\tmx = p.ss, id = p.ff;\n\t\t}\n\t}\n\tmx++;\n\treturn {id, mx};\n}\n\nint32_t main () {\n\tuse_fast;\t\n\tint n;\n\tcin >> n;\n\tfor(int i = 1; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t}\n\tint k = dfs(dfs(1, 0).ff, 0).ss + 1;\n\tint ans = 0;\n\twhile(k) {\n\t\tk /= 3;\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, A[1 << 17], B[1 << 17], dp[1 << 17], ret; vector<int>X[1 << 17], G[1 << 17];\nbool used[1 << 17];\n\nvoid dfs(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tG[pos].push_back(X[pos][i]);\n\t\tdfs(X[pos][i]);\n\t}\n}\n\nvector<int> solve(int pos) {\n\tint used[30]; for (int i = 0; i < 30; i++) used[i] = 0;\n\n\tfor (int i = 0; i < G[pos].size(); i++) {\n\t\tvector<int> E = solve(G[pos][i]);\n\t\tfor (int j = 0; j < E.size(); j++) used[E[j]]++;\n\t}\n\n\tint c = -1, t = 0;\n\tfor (int i = 0; i < 30; i++) { if (used[i] >= 2) t = i; }\n\tfor (int i = t; i < 30; i++) {\n\t\tif (used[i] == false) { c = i; break; }\n\t}\n\tdp[pos] = c;\n\tvector<int>L; L.push_back(c);\n\tfor (int i = c + 1; i < 30; i++) { if (used[i] == true) L.push_back(i); }\n\treturn L;\n}\n\nint main() {\n\t//FILE *in = freopen(\"in1.txt\", \"r\", stdin);\n\tcin >> N;\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tX[A[i]].push_back(B[i]);\n\t\tX[B[i]].push_back(A[i]);\n\t}\n\tdfs(1);\n\tsolve(1);\n\n\tint maxn = 0; for (int i = 1; i <= N; i++) maxn = max(maxn, dp[i]);\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nstruct edge{\n\tint to,next;\n}e[N*2];\nint head[N],tot;\nint f[N],n,ans;\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nvoid dfs(int x,int fa){\n\tint has=0,bad=0;\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (e[i].to!=fa){\n\t\t\tdfs(e[i].to,x);\n\t\t\tbad|=(has&f[e[i].to]);\n\t\t\thas|=f[e[i].to];\n\t\t}\n\tint tmp=16;\n\tfor (;tmp>=0;tmp--)\n\t\tif (bad&(1<<tmp)) break;\n\tfor (tmp++;has&(1<<tmp);tmp++);\n\tf[x]=(has&((1<<17)-(1<<tmp)))|(1<<tmp);\n\tans=max(ans,tmp);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//cwystc <--> 陈威宇是天才  --by cwy\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst double PI=acos(-1);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n#define travel_set(it,a) for (set<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_map(it,a) for (map<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_vec(it,a) for (vector<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define p(x) cout << x << endl;\n#define def cout << \"find\" << endl;\n#define what_is(x) cout << #x << \" is \" << x << endl;\ntemplate <class T>T sqr(T x){return x*x;}\ntemplate <class T>T alex(T x){return (x>0)?x:-x;}\ntemplate <class T>void read(T&x){\n\tx=0;T f=1;char ch=getchar();\n\twhile ((ch<48||ch>57)&&ch!=45)ch=getchar();\n\tif (ch==45)f=-1,ch=getchar();\n\twhile (ch>=48&&ch<=57)x=x*10+ch-48,ch=getchar();\n\tx*=f;\n}\n\n//-------------------------------------------------head-------------------------------------------------\n\n#define maxn 100005\nint n;\nvector<int>E[maxn];\nint sign[maxn];bool vis[maxn];\nbool gbit(int x,int bit){return (x>>bit)&1;}\nvoid dfs(int x){\n\tvis[x]=true;int _sign=0;\n\tRep(i,0,E[x].size())if (!vis[E[x][i]]){\n\t\tdfs(E[x][i]);_sign^=sign[E[x][i]];\n\t}\n\tRep(i,0,20){_sign^=(1<<i);if (gbit(_sign,i)==1)break;}\n\tsign[x]=_sign;\n}\nint main(){\n\t// freopen(\"D.in\",\"r\",stdin);\n\t// freopen(\"D.out\",\"w\",stdout);\n\tread(n);\n\tRep(i,1,n){\n\t\tint x,y;read(x);read(y);\n\t\tE[x].pb(y);E[y].pb(x);\n\t}\n\tdfs(1);int res=0;\n\trep(i,1,n)res=max(res,sign[i]);\n\tres=(int)log2(res);printf(\"%d\\n\",res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef unordered_set<ll> set;\n#define N 100010\n#define D 20\nll n;\nvector<ll> g[N];\nset solve(ll x,ll from){\n  vector<set> v;\n  for(auto y:g[x])if(y!=from)v.push_back(solve(y,x));\n  ll clash=-1;\n  for(ll i=D;i-1;i--){\n    int cnt=0;\n    for(auto x:v)if(x.find(i)!=x.end())cnt++;\n    if(cnt>=2){clash=i; break;}\n  }\n  ll gen;\n  for(ll i=clash+1;;i++){\n    int cnt=0;\n    for(auto x:v)if(x.find(i)!=x.end())cnt++;\n    if(cnt==0){gen=i; break;}\n  }\n  set res; res.insert(gen);\n  for(ll i=gen+1;i<D;i++){\n    int cnt=0;\n    for(auto x:v)if(x.find(i)!=x.end())cnt++;\n    if(cnt>0)res.insert(i);\n  }\n  return res;\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    ll a,b;cin>>a>>b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  set res=solve(1,0);\n  ll ans=0;\n  for(auto x:res)ans=max(ans,x);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define REP(x, l, u) for(ll x = l;x<u;x++)\n#define RREP(x, l, u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(begin(a),end(a)),end(a))\n#define mst(x, a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define rall(a) rbegin(a),rend(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace __gnu_pbds; //required\nusing namespace std;\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst ll mod = 1e9 + 7;\n\n\nstring to_string (string s) { return '\"' + s + '\"'; }\n\nstring to_string (const char *s) { return to_string ((string) s); }\n\nstring to_string (bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<typename A, typename B>\nstring to_string (pair<A, B> p) { return \"(\" + to_string (p.first) + \", \" + to_string (p.second) + \")\"; }\n\ntemplate<typename A>\nstring to_string (A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) { res += \", \"; }\n        first = false;\n        res += to_string (x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out () { cerr<<endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out (Head H, Tail... T) {\n    cerr<<\" \"<<to_string (H);\n    debug_out (T...);\n}\n\n#ifdef LOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T, typename S>\ninline bool upmin (T &a, const S &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T, typename S>\ninline bool upmax (T &a, const S &b) { return a < b ? a = b, 1 : 0; }\n\n\null twop (ll x) { return 1ULL<<x; }\n\nll MOD (ll a, ll m) {\n    a %= m;\n    if (a < 0)a += m;\n    return a;\n}\n\nll inverse (ll a, ll m) {\n    a = MOD (a, m);\n    if (a <= 1)return a;\n    return MOD ((1 - inverse (m, a) * m) / a, m);\n}\n\ntemplate<typename T>\nT sqr (T x) { return x * x; }\n\nll gcd (ll a, ll b) {\n    a = abs (a), b = abs (b);\n    while (b != 0) {\n        a %= b;\n        swap (a, b);\n    }\n    return a;\n}\n\nll fast (ll a, ll b) {\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans *= a;\n        a *= a;\n        b /= 2;\n    }\n    return ans;\n}\n\nll fast (ll a, ll b, ll mod) {\n    if (b < 0)a = inverse (a, mod), b = -b;\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans = ans * a % mod;\n        a = a * a % mod;\n        b /= 2;\n    }\n    return ans % mod;\n}\n\n\nnamespace SOLVE {\n    VLL adj[100100];\n    ll dp[101000];\n    ll n;\n    \n    void dfs (int cur, int fa) {\n        ll forbid = 0;\n        for (auto s:adj[cur]) {\n            if (s != fa) {\n                dfs (s, cur);\n                forbid |= dp[s];\n            }\n        }\n        REP(i, 0, 20) {\n            if (twop (i) & forbid)continue;\n            REP(j, 0, i) {\n                forbid ^= twop (j);\n            }\n            dp[cur] = forbid | twop (i);\n            return;\n        }\n    }\n    \n    void main () {\n        cin>>n;\n        REP(i, 1, n) {\n            int u, v;\n            cin>>u>>v;\n            adj[u].PB (v);\n            adj[v].PB (u);\n        }\n        dfs (1, 0);\n        int ans = 0;\n        REP(i,0,20){\n            if(twop(i) & dp[1])ans = i;\n        }\n        cout<<ans;\n    }\n}\n\n\nsigned main () {\n#ifdef LOCAL\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    int t = 1;\n//    cin >> t;\n    for (int i = 1; i <= t; i++) {\n//        cout<<\"Case #\"<<i<<\": \";\n        SOLVE::main ();\n        \n    }\n\n\n\n\n\n\n\n\n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\nint las[N],vis[N],fa[N];\nint n,cnt,mx,w,ans;\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid dfs(int x,int d){\n\tif (d>mx) mx=d,w=x;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]&&y!=fa[x]){\n\t\t\tfa[y]=x;\n\t\t\tdfs(y,d+1);\n\t\t}\n}\nvoid solve(int x,int dep){\n\tans=max(ans,dep);\n\tmx=-1;\n\tfa[x]=0;\n\tdfs(x,0);\n\tmx=-1;\n\tfa[w]=0;\n\tdfs(w,0);\n\tFor(i,0,mx/2) w=fa[w];\n\tvis[w]=1;\n\tfor (int i=las[w],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]){\n\t\t\tsolve(y,dep+1);\n\t\t}\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n) Link(IN(),IN());\n\tsolve(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    {\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      //if(!used[i]&&belong[i]<0) exit(0);\n      if(!used[i]&&cnt[i]<1) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nvector<vector<int>> E;\n\nint dfs(int u, int prev) {\n    int value = 0;\n    int bit = 0;\n    for(int v : E[u]) {\n        if (v == prev) continue;\n        int t = dfs(v, u);\n        if (bit&t) {\n            value = max(value, 31 - __builtin_clz(bit&t));\n        }\n        bit |= t;\n    }\n    for(int i = value; ; ++i) {\n        if (!(bit >> i & 1)) {\n            bit |= 1 << i;\n            bit &= ~((1<<i) - 1);\n            break;\n        }\n    }\n    return bit;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    E.resize(n);\n    for(int i = 0; i < n; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        E[a].push_back(b);\n        E[b].push_back(a);\n    }\n    int ans = 0;\n    int t = dfs(0, -1);\n    for(int i = 0; i < 32; ++i) {\n        if (t >> i & 1) {\n            ans = i;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n\ntypedef long long int64;\ntypedef pair<int,int> pii;\ntypedef vector<int64> vi;\n\nconst int oo = 0x3f3f3f3f;\nconst double eps = 1e-9;\nconst int maxn = 100000 + 10;\n\nint ans;\nvi adj[maxn];\n\nint dfs(int s, int p){\n\tint cur = 0;\n\n\tfor (int i = 0; i < (int)adj[s].size(); ++i){\n\t\tint u = adj[s][i]; if (u == p) continue;\n\t\tcur |= dfs(u, s);\n\t}\n\n\tcur++;\n\tans = max(ans, __lg(cur & -cur));\n\n\treturn cur;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n; cin >> n;\n\n\tfor (int i = 1; i < n; ++i){\n\t\tint u, v; cin >> u >> v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\n\tans = 0;\n\tdfs(1, 1);\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n#define sz(c) (int)(c).size()\n#define ALL(c) (c).begin(), (c).end()\n\npii bfs (int v, const vvi &g)\n{\n    const int n = sz(g);\n    vi d(n, -1);\n    queue<int> q;\n\n    q.push(v);\n    d[v] = 0;\n    int last = -1;\n\n    while (!q.empty())\n    {\n        int cur = q.front();\n        last = cur;\n        q.pop();\n\n        for (int dest : g[cur]) if (d[dest] == -1)\n        {\n            d[dest] = d[cur] + 1;\n            q.push(dest);\n        }\n    }\n\n    return mp(last, d[last]);\n}\n\nvoid solve (int n)\n{\n    vvi g(n);\n    forn (i, n - 1)\n    {\n        int x, y;\n        cin >> x >> y;\n        --x, --y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n\n    pii to = bfs(0, g);\n    pii res = bfs(to.fst, g);\n    int len = res.snd;\n\n    int diam = 0;\n    int curk = 0;\n\n    while (diam < len)\n    {\n        curk++;\n        diam = 2 * diam + 2;\n    }\n\n    cout << curk << '\\n';\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    while (cin >> n)\n        solve(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX_N = 100030;    // Change as necessary\nconst ll  MODD = 1000000009; //\n\nint A[MAX_N];\n\nvector<int> adj[MAX_N];\n\nint max_lvl = -1,V = -1;\nint f(int v,int p,int d){\n  if(d > max_lvl){ max_lvl = d; V = v; }\n  \n  int ans = 0;\n  for(auto u : adj[v])\n    if(u != p)\n      ans = max(ans,1+f(u,v,d+1));\n  return ans;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  \n  int n; cin >> n;\n  \n  for(int i=0;i<n-1;i++){\n    int u,v; cin >> u >> v; u--; v--;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  \n  f(0,-1,0);\n  int l = f(V,-1,0)+1;\n  \n  int ans = 0;\n  while(l > 1){\n    int k = 2*(l/4);\n    if(l % 4) k++;\n    l = k;\n    ans++;\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nvint G[111111];\n\nint dfs(int v,int p){\n    vint lis;\n    for(auto u:G[v]){\n        if(u==p)continue;\n        lis.pb(dfs(u,v));\n    }\n\n    int k=0;\n    int ret=0;\n    for(auto x:lis)ret|=x;\n    rep(i,20){\n        int cnt=0;\n        for(auto x:lis)if(x>>i&1)cnt++;\n        if(cnt>1)k=i+1;\n    }\n    while(ret>>k&1)k++;\n    rep(i,k)if(ret>>i&1)ret^=1<<i;\n    ret^=1<<k;\n    return ret;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n    int tmp=dfs(0,-1);\n    int k=20;\n    while(~tmp>>k&1)k--;\n    cout<<k<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,f[100010][25];\nvector<int> a[100010];\ninline void dp(int i,int l)\n{\n    int j,k;\n    for(j=0;j<a[i].size();j++)\n      if(a[i][j]!=l)\n        {\n         dp(a[i][j],i);\n         for(k=1;k<=20;k++)\n           f[i][k]+=f[a[i][j]][k];\n        }\n    for(j=20;j>0;j--)\n      if(f[i][j]>1)\n        break;\n    for(j++;f[i][j];j++);\n    f[i][j]=1;\n    for(j--;j>0;j--)\n      f[i][j]=0;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++)\n\t  {\n       scanf(\"%d%d\",&j,&k);\n       a[j].push_back(k);\n       a[k].push_back(j);\n      }\n    dp(1,0);\n    for(i=20;!f[1][i];i--);\n    printf(\"%d\\n\",i-1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, d[N], dp[N];\nvector <int> g[N];\n\nvoid dfs (int, int, int);\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tdfs (0, -1, 0);\n\tint far = 0;\n\tfor (int v = 1; v < n; v++)\n\t\tif (d[v] > d[far])\n\t\t\tfar = v;\n\n\tdfs (far, -1, 0);\n\tint len = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tlen = max(len, d[i]);\n\n\tlen++;\n\tdp[1] = 0;\n\tcerr << \"len: \" << len << endl;\n\tfor (int i = 2; i <= len; i++)\n\t\tdp[i] = dp[i / 2] + 1;\t\n\tcout << dp[len] + 1 << endl;\n}\n\nvoid dfs (int v, int pv, int depth) {\n\t// cerr << \"dfs: \" << v + 1 << ' ' << pv + 1 << ' ' << depth << endl;\n\td[v] = depth;\n\tfor (int u: g[v])\n\t\tif (u != pv)\n\t\t\tdfs (u, v, depth + 1);\n}\n\n// SamMHD :: Feb17-2019 :: Another Simulation..."
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <list>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <assert.h>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\nconst int SZ = 1e5 + 10;\nconst int INF = 1e9;\n\nvector<int> child[SZ];\nint d[SZ], diam;\nbool v[SZ];\n\nvoid dfs(int h) {\n\tv[h] = true;\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tdfs(i);\n\t\t\td[h] = max(d[h], d[i] + 1);\n\t\t}\n}\n\nvoid dfs1(int h, int top) {\n\tv[h] = true;\n\tint mx1 = top, mx2 = 0;\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tif (d[i] + 1 >= mx1) {\n\t\t\t\tmx2 = mx1;\n\t\t\t\tmx1 = d[i] + 1;\n\t\t\t} else if (d[i] + 1 >= mx2)\n\t\t\t\tmx2 = d[i] + 1;\n\t\t}\n\tdiam = max(diam, mx1 + mx2);\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tif (d[i] + 1 == mx1)\n\t\t\t\tdfs1(i, mx2 + 1);\n\t\t\telse\n\t\t\t\tdfs1(i, mx1 + 1);\n\t\t}\n}\n\nint main() {\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tchild[a].push_back(b);\n\t\tchild[b].push_back(a);\n\t}\n\tdfs(0);\n\tfor (int i = 0; i < n; i++)\n\t\tv[i] = false;\n\tdfs1(0, 0);\n\n\tdiam++;\n\tint ans = 0, p = 1;\n\twhile (p < diam) {\n\t\tans++;\n\t\tp = 2 * p;\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100010;\nint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\nvoid addedge(int b, int e) {\n\tnxt[++tot] = head[b]; to[head[b] = tot] = e;\n\tnxt[++tot] = head[e]; to[head[e] = tot] = b;\n}\nint n;\nint dfs(int u, int fa = 0) {\n\tint pre = 0, hav = 0;\n\tfor (int i = head[u]; i; i = nxt[i]) if (to[i] != fa) {\n\t\tint t = dfs(to[i], u);\n\t\thav |= pre & t;\n\t\tpre |= t;\n\t}\n\tint p = hav ? std::__lg(hav) + 1 : 0;\n\tp += __builtin_ctz((pre >> p) + 1);\n\tpre ^= pre & (1 << p) - 1;\n\treturn pre | 1 << p;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, addedge(t1, t2);\n\tstd::cout << std::__lg(dfs(1)) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nvector<int> Mat[MAXN];\nint n, mxv, mxd;\n\nint dfs(int v, int p, int d) {\n\tif (mxd < d)\n\t\tmxd = d, mxv = v;\n\tfor (int i = 0; i < Mat[v].size(); i++)\n\t\tif (Mat[v][i] != p)\n\t\t\tdfs(Mat[v][i], v, d + 1);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tMat[a].push_back(b);\n\t\tMat[b].push_back(a);\n\t}\n\tdfs(1, 1, 0);\n\tdfs(mxv, mxv, 0);\n\tcout << (int) log2(mxd + 1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  Int first=1;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(first){\n      first=0;\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n      exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]&&belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 1e5 + 5;\nint n;\nint a , b;\nvector < int > v[N];\nint dfs(int node , int parent){\n    int mask1 = 0;\n    int mask2 = 0;\n    for(int next : v[node]){\n        if(next != parent){\n            int val = dfs(next , node);\n            mask2 |= val & mask1;\n            mask1 |= val;\n        }\n    }\n    int mn = 0;\n    for(int i = 0 ; i < 20 ; ++i){\n        if((mask2 >> i) & 1){\n            mn = i;\n        }\n    }\n    for(int i = mn ; i < 20 ; ++i){\n        if(!((mask1 >> i) & 1)){\n            mask1 |= 1 << i;\n            mask1 &= ~((1 << i) - 1);\n            break;\n        }\n    }\n    return mask1;\n}\nint main(){\n    scanf(\"%d\" , &n);\n    for(int i = 1 ; i < n ; ++i){\n        scanf(\"%d %d\" , &a , &b);\n        v[a].emplace_back(b);\n        v[b].emplace_back(a);\n    }\n    int ans = dfs(1 , 0);\n    for(int i = 19 ; ; --i){\n        if((ans >> i) & 1){\n            printf(\"%d\\n\" , i);\n            break;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  Int first=1;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(first){\n      first=0;\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lg2 std::__lg\n#define ctz __builtin_ctz\n\nconst int N = 100054, M = N * 2;\n\nint n, E = 0;\nint to[M], first[N], next[M];\nint f[N], ans[N];\n\ninline void addedge(int u, int v) {\n\tto[++E] = v, next[E] = first[u], first[u] = E;\n\tto[++E] = u, next[E] = first[v], first[v] = E;\n}\n\nvoid dfs(int x, int px = 0) {\n\tint i, y, s = 0;\n\tfor (i = first[x]; i; i = next[i])\n\t\tif ((y = to[i]) != px)\n\t\t\tdfs(y, x), s |= f[x] & f[y], f[x] |= f[y];\n\ts = lg2(s << 1 | 1), s += ctz(~(f[x] >> s));\n\tf[x] = (f[x] >> s | 1) << s, ans[x] = s;\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v);\n\tdfs(1), printf(\"%d\\n\", *std::max_element(ans + 1, ans + (n + 1)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 1e5 + 10;\nvector<vector<int> > es;\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  es = vector<vector<int> >(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    --s, --t;\n    es[s].pb(t), es[t].pb(s);\n  }\n  return 1;\n}\n\n\nint dfs(int v, int p = -1) {\n  int res = 0;\n  int mn = 0;\n  for (int u : es[v]) {\n    if (u == p) {\n      continue;\n    }\n    int got = dfs(u, v);\n    {\n      int x = (res & got);\n      if (x) {\n        mn = max(mn, 31 - __builtin_clz(x) + 1);\n      }\n    }\n\n    res |= got;\n    res |= (1 << mn) - 1;\n    ++res;\n    mn = __builtin_ctz(res);\n    res ^= (1 << mn);\n  }\n  return res ^ (1 << mn);\n}\n\nvoid solve() {\n  int mask = dfs(0);\n  printf(\"%d\\n\", 31 - __builtin_clz(mask));\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\ntemplate< typename T >\nstruct edge{\n    int from, to;\n    T cost;\n    edge(int to,T cost) : from(-1), to(to), cost(cost){}\n    edge(int from,int to,T cost) : from(from), to(to), cost(cost){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const{ return to;}\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedTree = vector< Edges<T>>;\nusing tree = vector< vector<int> >;\n\ntree make(int n,int offset = 1){\n    tree res(n);\n    for(int i = 0;i < n-1; i++){\n        int a,b; cin >> a >> b;\n        a -= offset,b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate< typename T >\nWeightedTree<T> make2(int n, int offset = 1){\n    WeightedTree<T> res(n);\n    for(int i = 0;i < n-1 ; i++){\n        int a,b ; cin >> a >> b;\n        a -= offset, b -= offset;\n        T c; cin >> c;\n        res[a].emplace_back(b,c);\n        res[b].emplace_back(a,c);\n    }\n    return res;\n}\n\nvector<int> Centers(tree &g,int idx = 0){\n    vector<int> res;\n    int max_depth = -1, leaf;\n    auto dfs = [&](auto &&self,int x,int p,int d)->bool{\n        bool flag = false;\n        if(max_depth < d){\n            max_depth = d, leaf = x, flag = true;\n            res.clear();\n        }\n        for(auto e:g[x]){\n            if(e != p)\n            flag |= self(self,e,x,d+1);\n        }\n        if(flag and (d == (max_depth>>1) or d == ((max_depth+1)>>1))) {\n            res.emplace_back(x);\n        }\n        return flag;\n    };\n    dfs(dfs,idx,-1,0);\n    max_depth = -1;\n    dfs(dfs,leaf,-1,0);\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    INT(n);\n    auto g = make(n);\n    rep(i,n)sort(all(g[i]));\n    auto solve = [&](auto &&self,int x) -> int{\n        if(g[x].size() == 0) return 0;\n        auto centers = Centers(g,x);\n        int res = 0;\n        if(centers.size() == 1){\n            int center = centers.back();\n            for(auto e:g[center]){\n                auto it = lower_bound(all(g[e]),center);\n                g[e].erase(it);\n                chmax(res,self(self,e));\n                g[e].eb(center);\n            }\n            return res + 1;\n        }\n        else{\n            int a = centers[0],b = centers[1];\n            auto it = lower_bound(all(g[a]),b);\n            g[a].erase(it);\n            it = lower_bound(all(g[b]),a);\n            g[b].erase(it);\n            int A = self(self,a);\n            int B = self(self,b);\n            for(auto e:g[a]){\n                auto it = lower_bound(all(g[e]),a);\n                g[e].erase(it);\n                chmax(B,self(self,e));\n            }\n            for(auto e:g[b]){\n                auto it = lower_bound(all(g[e]),b);\n                g[e].erase(it);\n                chmax(A,self(self,e));\n            }\n            g[a].eb(b);\n            g[b].eb(a);\n            return min(A,B) + 1;\n        }\n    };\n    cout << solve(solve,0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 101000;\n\nint n, f[N][61];\n\nstruct Edge\n{\n    int nxt, to;\n} eg[N << 1];\nint head[N], en;\n\nvoid setEdge(int u, int v)\n{\n    eg[++en] = (Edge) {head[u], v};\n    head[u] = en;\n}\n\nvoid dfs(int u, int fa)\n{\n    for (int e = head[u]; e; e = eg[e].nxt)\n    {\n        int v = eg[e].to;\n        if (v == fa) continue;\n        dfs(v, u);\n        for (int i = 0; i <= 60; i++)\n            f[u][i] += f[v][i];\n    }\n    for (int i = 60; i >= 0; i--)\n        if (f[u][i] > 1)\n        {\n            int p = i + 1;\n            while (f[u][p]) p++;\n            f[u][p] = 1;\n            for (int j = 0; j < p; j++)\n                f[u][j] = 0;\n            return ;\n        }\n    int p = 0;\n    while (f[u][p]) p++;\n    f[u][p] = 1;\n    for (int j = 0; j < p; j++)\n        f[u][j] = 0;\n}\n\nint main()\n{\n    n = read();\n    for (int i = 1; i < n; i++)\n    {\n        int u = read(), v = read();\n        setEdge(u, v);\n        setEdge(v, u);\n    }\n    dfs(1, 0);\n    for (int i = 60; i >= 0; i--)\n        if (f[1][i])\n        {\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=200005;\n\ntypedef long long LL;\n\nint n,f[N],ans,g[N],h[N],e[N],nxt[N],tot;\n\nchar c;\n\nint read()\n{\n    int x=0,sig=1;\n    for (c=getchar();c<'0' || c>'9';c=getchar()) if (c=='-') sig=-1;\n    for (;c>='0' && c<='9';c=getchar()) x=x*10+c-48;\n    return x*sig;\n}\n\nvoid Add(int x,int y)\n{\n\te[++tot]=y; nxt[tot]=h[x]; h[x]=tot;\n}\n\nvoid dfs(int x,int y)\n{\n\tint i,j,k;\n\tfor (i=h[x],j=k=0;i;i=nxt[i]) if (e[i]!=y)\n\t{\n\t\tdfs(e[i],x);\n\t\tif ((j&f[e[i]])>0) k=max(k,g[j&f[e[i]]]+1);\n\t\tj|=f[e[i]];\n\t}\n\tfor (i=0;((1<<i)&j)>0;i++);\n\tk=max(k,i);\n\tans=max(ans,k); f[x]=1<<k;\n\tfor (;g[j]>k;j^=(1<<g[j])) f[x]|=(1<<g[j]);\n}\n\nint main()\n{\n\tn=read();\n\tfor (int i=1,x,y;i<n;i++)\n\t{\n\t\tx=read(); y=read();\n\t\tAdd(x,y); Add(y,x);\n\t}\n\tfor (int i=1,j=0;i<N;i<<=1,j++) g[i]=j;\n\tfor (int i=3;i<N;i++) if (!g[i]) g[i]=g[i-1];\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<cmath>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<ctype.h>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<math.h>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<stdio.h>\n#include<stdlib.h>\n#include<streambuf>\n#include<string.h>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\nusing namespace std;\nvector<int> adj[100010];\nint dist[100010];\nint mxid;\nvoid dfs(int fa,int i){\n\tfor (int j=adj[i].size()-1;~j;j--){\n\t\tif (adj[i][j]!=fa){\n\t\t\tdist[adj[i][j]]=dist[i]+1;\n\t\t\tif (dist[i]+1>dist[mxid]) mxid=adj[i][j];\n\t\t\tdfs(i,adj[i][j]);\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tdfs(-1,1);\n\tmemset(dist,0,sizeof(dist));\n\tdfs(-1,mxid);\n\tint i=1,j=2;\n\twhile(j<dist[mxid]){\n\t\ti++;\n\t\tj++;\n\t\tj<<=1;\n\t}\n\tprintf(\"%d\",i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\n\nconst int N = 100100;\nVI edges[N];\n\nll dp[N];\n\nvoid dfs(int v, int par) {\n  VL ch;\n  ll orl = 0;\n  for (auto w: edges[v]) {\n    if (w == par) { continue; }\n    dfs(w, v);\n    ch.push_back(dp[w]);\n    orl |= dp[w];\n  }\n  vector<int> hb(64);\n  REP(b, 0, 64) {\n    int cnt = 0;\n    for (ll t: ch) {\n      if (t & (1LL << b)) {\n\tcnt += 1;\n      }\n    }\n    hb[b] = cnt;\n  }\n  int c = 0;\n  REP(b, 0, 64) {\n    if (hb[b] >= 2) {\n      c = b + 1;\n    }\n  }\n  int t = -1;\n  REP(b, c, 64) {\n    if (hb[b] == 0) {\n      t = b;\n      break;\n    }\n  }\n  ll mask = 1LL << t;\n  dp[v] = (orl & ~(mask - 1)) | mask;\n}\n\n// This was implemented after the author read the editorial.\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n - 1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    edges[a].push_back(b);\n    edges[b].push_back(a);\n  }\n  dfs(0, -1);\n  int b = 0;\n  REP(i, 0, 64) {\n    if (dp[0] & 1LL << i) {\n      b = i;\n    }\n  }\n  cout << b << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x) & -(x)\nusing namespace std;\n\nvector <int> adia[100010];\nint see[100010];\nint lgr[200010];\nint maxim = 0, total;\n\nint dfs(int nod, int tata)\n{\n    for (auto i : adia[nod])\n        if (i != tata)\n            see[nod] |= dfs(i, nod);\n    /// pun lsb(~see[nod])\n    int pun = lgr[lsb(total - see[nod])];\n    maxim = max(maxim, pun);\n    see[nod] &= ~((1 << pun) - 1);\n    see[nod] += (1 << pun);\n    return see[nod];\n}\n\nint main()\n{\n    total = (1 << 20) - 1;\n    for (int i = 2; i <= 200000; i++)\n        lgr[i] = 1 + lgr[i / 2];\n\n    int n, a, b;\n    cin >> n;\n\n    while (--n) {\n        cin >> a >> b;\n        adia[a].push_back(b);\n        adia[b].push_back(a);\n    }\n\n    dfs(1, 0);\n\n    cout << maxim << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  if(n==2){\n    cout<<1<<endl;\n    return 0;\n  }\n  function<Int(Int, Int)> dfs=[&](Int v,Int p){\n    Int one=0,two=0;\n    for(Int u:G[v]){\n      if(u==p) continue;\n      Int tmp=dfs(u,v);\n      two|=(one&tmp);\n      one|=tmp;\n    }\n    Int res=1;\n    while(res<=two||(one&res)) res<<=1;\n    return one^(res|(res-1));\n  };\n\n  for(Int i=0;i<n;i++){\n    if(G[i].size()==1u) continue;\n    Int res=dfs(i,-1);\n    Int ans=31-__builtin_clz(res);\n    cout<<ans<<endl;\n    break;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n \nconst int N = 1e5 + 7;\n \nvector <int> ad[N];\nint gone[N], n, mrk[N],\tsz[N];\n\nvoid dfs(int v, int p = 0) {\n\tsz[v] = 1;\n\tmrk[v] = 1;\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tdfs(u, v);\n\t\t\tsz[v] += sz[u];\n\t\t}\n\t}\n}\npair <int, int> get(int v, int p, int sall) {\n\tpair <int, int> res;\n\tres.first = v;\n\tres.second = sall - sz[v];\n\tfor (auto u: ad[v])\n\t   \tif (!gone[u] && u != p)\t\n\t\t\tres.second = max(res.second, sz[u]);\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tpair <int, int> t = get(u, v, sall);\n\t\t\tif (t.second < res.second)\n\t\t\t\tres = t;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tad[v].push_back(u);\n\t\tad[u].push_back(v);\n\t}\n\tint res = 0;\n\twhile (1) {\n\t\tbool was = 0;\n\t\tmemset(sz, 0, sizeof sz);\n\t\tmemset(mrk, 0, sizeof mrk);\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tif (!gone[i] && !mrk[i]) {\n\t\t\t\twas = 1;\n\t\t\t\tdfs(i);\n\t\t\t\tint v = get(i, 0, sz[i]).first;\n\t\t\t\tgone[v] = 1;\n\t\t\t}\n\t\tif (!was)\n\t\t\tbreak;\n\t\tres++;\n\t}\n\tcout << res - 1;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\n\nconst int N=1e5+9;\n\nunsigned int bit[N];\nint n,f[N],ans;\nint to[N<<1],nxt[N<<1],beg[N],tot;\n\ninline void add(int u,int v)\n{\n\tto[++tot]=v;\n\tnxt[tot]=beg[u];\n\tbeg[u]=tot;\n}\n\ninline void dfs(int u,int fa)\n{\n\tbit[u]=f[u]=0;\n\tint las=0;\n\tfor(int i=beg[u],v;i;i=nxt[i])\n\t\tif((v=to[i])!=fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tlas|=bit[v]&bit[u];\n\t\t\tbit[u]|=bit[v];\n\t\t}\n\tif(bit[u]==0)\n\t\tbit[u]=1;\n\telse\n\t{\n\t\twhile((1<<f[u])<las || bit[u]&(1<<f[u]))f[u]++;\n\t\tbit[u]=(bit[u]>>f[u]<<f[u])|(1<<f[u]);\n\t}\n\tif(ans<f[u])ans=f[u];\n}\n\nint main()\n{\n\tif(fopen(\"vj.in\",\"r\"))\n\t{\n\t\tfreopen(\"vj.in\",\"r\",stdin);\n\t\tfreopen(\"vj.out\",\"w\",stdout);\n\t}\n\n\tn=read();\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tu=read();v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[100001];\nint h[100001];\nll dp[100001];\n\nvoid dfs(int u, int p)\n{\n\tif(p==-1) h[u]=0;\n\telse h[u]=h[p]+1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tif(adj[u][i]==p) continue;\n\t\tdfs(adj[u][i],u);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tdp[1] = 2;\n\tfor(int i = 2; i <= 60; i++)\n\t{\n\t\tdp[i] = (dp[i-1]*2+2);\n\t}\n\tint n; cin>>n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tdfs(0,-1);\n\tint best = 0; int idx = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t\tidx=i;\n\t\t}\n\t}\n\tdfs(idx,-1);\n\tbest=0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t}\n\t}\n\t//cerr<<best<<'\\n';\n\tfor(int i = 1; i <= 60; i++)\n\t{\n\t\tif(best<=dp[i])\n\t\t{\n\t\t\tcout<<i<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define min(x,y) ((x)<(y)?(x):(y))\n#define max(x,y) ((x)>(y)?(x):(y))\n\nusing namespace std;\n\nconst int maxn=2e5+5;\n\nint fi[maxn],ne[maxn*2],dui[maxn*2],qc[maxn],f[maxn];\nint cc[maxn];\nint i,j,k,l,m,n,x,y,now,ans;\n\nvoid add(int x,int y){\n\tif (fi[x]==0) fi[x]=++now; else ne[qc[x]]=++now;\n\tdui[now]=y; qc[x]=now;\n}\nvoid dfs(int x,int y){\n\tint i,t=0;\n\tfor(i=fi[x];i;i=ne[i]){\n\t\tif (dui[i]==y) continue;\n\t\tdfs(dui[i],x);\n\t\tt=t&f[dui[i]];\n\t\tf[x]=f[x] | f[dui[i]];\n\t}\n\tfo(i,1,20) if (cc[i]>t && ((f[x] & cc[i])==0)){\n\t\tt=i; break;\n\t}\n\tans=max(ans,t);\n\tf[x]=(f[x]&(cc[20]-cc[t]))|cc[t];\n}\nint main(){\n//\tfreopen(\"009d.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tcc[1]=1;\n\tfo(i,2,20) cc[i]=cc[i-1]*2;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#define fo(i,a,b) for(int i=a;i<=b;++i)\n#define fod(i,a,b) for(int i=a;i>=b;--i)\n#define N 100005\nusing namespace std;\nint nt[2*N],fs[N],dt[2*N],n,m,s[N],f[N][20],ans;\nvoid link(int x,int y)\n{\n\tnt[++m]=fs[x];\n\tdt[fs[x]=m]=y;\n}\nvoid dfs(int k,int fa)\n{\n\tfor(int i=fs[k];i;i=nt[i])\n\t{\n\t\tint p=dt[i];\n\t\tif(p!=fa)\n\t\t{\n\t\t\tdfs(p,k);\n\t\t\tfo(j,0,19) f[k][j]+=f[p][j];\n\t\t}\n\t}\n\tint lim=0;\n\tfod(j,19,0) if(f[k][j]>1)\n\t{\n\t\tlim=j+1;\n\t\tbreak;\n\t}\n\twhile(f[k][lim]) lim++;\n\ts[k]=lim;\n\tfo(j,0,lim-1) f[k][j]=0;\n\tf[k][lim]++;\n\tans=max(ans,s[k]);\n}\nint main()\n{\n\tcin>>n;\n\tfo(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t\tlink(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author jcg\n */\n\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n\n\nusing std::vector;\n\nvector<int> strategy_function(const vector<vector<int>> &g)\n{\n\tvector<int> label(g.size());\n\tstd::function<int(int)> dfs = [&](int u)\n\t{\n\t\tlabel[u] = -1;\n\t\tint used = 0, more = 0;\n\t\tfor (int v : g[u])\n\t\t\tif (!label[v])\n\t\t\t{\n\t\t\t\tint mask = dfs(v);\n\t\t\t\tmore |= mask & used;\n\t\t\t\tused |= mask;\n\t\t\t}\n\t\tfor (int k : {1, 2, 4, 8, 16})\n\t\t\tmore |= more >> k;\n\t\t++more;\n\t\tint possible = ~used & -more;\n\t\tlabel[u] = possible & -possible;\n\t\tused |= label[u];\n\t\tused &= -label[u];\n\t\treturn used;\n\t};\n\tdfs(0);\n\treturn label;\n}\n\n\nclass DUninity\n{\npublic:\n    void solve(std::istream& in, std::ostream& out)\n    {\n        using std::vector;\n\n        int n;\n        in >> n;\n\n        vector<vector<int>> g(n);\n        for (int i = 1; i < n; ++i)\n        {\n            int u, v;\n            in >> u >> v;\n            --u, --v;\n            g[u].emplace_back(v);\n            g[v].emplace_back(u);\n        }\n\n        auto label = strategy_function(g);\n        out << std::__lg(*std::max_element(label.begin(), label.end())) << '\\n';\n    }\n};\n\n\nint main()\n{\n    std::ios_base::sync_with_stdio(0);\n    std::istream& in(std::cin);\n    std::ostream& out(std::cout);\n    in.tie(0);\n    DUninity solver;\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n;\nvi g[N];\n\nint dfs(int c,int fa) {\n  vi f;\n  for(auto t : g[c]) if(t != fa)\n    f.pb(dfs(t , c));\n  f.pb(1);\n  int res = 0;\n  for(int i=0,d=0,j=0;i<20;++i) {\n    int s = d;\n    for(auto e : f)\n      s += e >> i & 1;\n    if(s == 1) {\n      res |= 1 << i;\n      if(d == 1) {\n        rep(k,j,i) if(res >> k & 1)\n          res ^= 1 << k;\n        j = i;\n      }\n    }\n    if(s >= 2)\n      d = 1;\n    else\n      d = 0;\n  }\n  return res;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  rep(i,1,n) {\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    g[u].pb(v);\n    g[v].pb(u);\n  }\n  printf(\"%d\\n\",31-__builtin_clz(dfs(1,0)));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=200010;\nint i,j,k,n,m,x,y,t,b[20];\nint fi[N*2],ne[N*2],la[N*2],a[N*2],w[N];\nint f[N][20],g[N][20];\nvoid add(int x,int y){\n\tk++;a[k]=y;\n\tif (fi[x]==0)fi[x]=k;else ne[la[x]]=k;\n\tla[x]=k;\n}\nvoid dfs(int x,int fa){\n\tfor (j=0;j<20;j++)f[x][j]=1;\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa){\n\t\tdfs(a[i],x);\n\t\tfor (j=0;j<20;j++)f[x][j]&=f[a[i]][j],g[x][j]+=g[a[i]][j];\n\t}\n\tmemset(b,0,sizeof b);\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa)b[w[a[i]]]++;\n\tfor (j=19;j>=0;j--)if (b[j]>1){\n\t\tfor (k=j;k<20;k++)if (f[x][k]){w[x]=k;break;}\n\t\tbreak;\n\t}\n\tif (!w[x]){for (j=0;j<20;j++)if (f[x][j]){w[x]=max(w[x],j);break;}}\n\tf[x][w[x]]=0;g[x][w[x]]++;\n\tfor (j=0;j<w[x];j++)f[x][j]=1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,-1);\n\tint ans=0;\n\tfor (i=1;i<=n;i++)ans=max(ans,w[i]);\n\tfor (i=1;i<=n;i++)printf(\"%d \",w[i]);printf(\"\\n\");\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 101234;\nint mx = 0;\nint dp[MN], col[MN];\nvector <int> adj[MN];\n\nint LogDo(int x) {\n\tint ans = -1;\n\tfor (int i = 0; i < 30; i++)\n\t\tif (x >> i & 1)\n\t\t\tans = i;\n\treturn ans;\n}\n\nvoid dfs(int v = 0, int p = 0) {\n\tint ans = 0, pre = 0;\n\tfor (int u: adj[v]) {\n\t\tif (u == p) \n\t\t\tcontinue;\n\t\tdfs(u, v);\n\t\tint msk = (dp[u] >> col[u] | 1 << col[u]);\n\t\tans = max(ans, LogDo(msk & dp[v] & -1) + 1);\n\t\tdp[v] |= msk;\n\t\twhile (dp[v] >> ans & 1)\n\t\t\tans++;\n\t}\n\tcol[v] = ans;\n\tmx = max(mx, ans);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t}\n\tdfs();\n\tcout << mx;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=1<<18;\n\nint n,lg[maxn];\nint tote,TO[maxn],NEXT[maxn],FIR[maxn];\n\nvoid addedge(int u,int v)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n}\n\nint dfs(int u,int f)\n{\n\tint bit=0,over=0,pos;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (v==f) continue;\n\t\tint tmp=dfs(v,u);\n\t\tover|=bit&tmp;\n\t\tbit|=tmp;\n\t}\n\tfor (pos=lg[over]+1;;pos++)\n\t\tif (!((bit>>pos)&1)) break;\n\tbit|=1<<pos;\n\tbit&=maxn-(1<<pos);\n\treturn bit;\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"D.in\",\"r\",stdin);\n\tfreopen(\"D.out\",\"w\",stdout);\n#endif\n\tint i,u,v;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v);\n\t\taddedge(v,u);\n\t}\n\tlg[0]=-1;\n\tfor (i=0;1<<i<maxn;i++) lg[1<<i]=i;\n\tfor (i=1;i<maxn;i++) lg[i]=max(lg[i],lg[i-1]);\n\tprintf(\"%d\\n\",lg[dfs(1,0)]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N, A[1 << 17], B[1 << 17], dp[1 << 17], ret; vector<int>X[1 << 17], G[1 << 17];\nbool used[1 << 17];\n\nvoid dfs(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tG[pos].push_back(X[pos][i]);\n\t\tdfs(X[pos][i]);\n\t}\n}\n\nint solve(int pos) {\n\tint z = 0, r = 0;\n\tfor (int i = 0; i < G[pos].size(); i++) { r += solve(G[pos][i]); }\n\n\tif (dp[pos] != -1) {\n\t\tif (r == 0) return 0;\n\t\treturn 1;\n\t}\n\tif (r == 0) { dp[pos] = ret; return 1; }\n\treturn 0;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N - 1; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tX[A[i]].push_back(B[i]);\n\t\tX[B[i]].push_back(A[i]);\n\t}\n\tdfs(1);\n\n\tfor (int i = 1; i <= N; i++) dp[i] = -1;\n\n\twhile (true) {\n\t\tint cnt = 0; for (int i = 1; i <= N; i++) { if (dp[i] == -1) cnt++; }\n\t\tif (cnt == 0) {\n\t\t\tcout << ret - 1 << endl;\n\t\t\tbreak;\n\t\t}\n\t\tsolve(1);\n\t\tret++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\nusing namespace std; \n\nconst int maxN = 100 * 1000 + 10;\nvector<int> c[maxN]; \n\nint dis[5][maxN]; \n\nvoid dfs( int s , int p , int h , int * dis ) { \n    dis[s] = h; \n    for( auto x : c[s] ) \n        if( x != p ) \n            dfs( x , s , h + 1 , dis ); \n}\n\nint main() { \n    ios::sync_with_stdio(false); \n    int n; cin >> n; \n\n    for( int i = 0 ; i < n - 1 ; i++ ) { \n        int u,v; cin >> u >> v; \n        u--; v--; \n        c[u].push_back( v ); \n        c[v].push_back( u ); \n    }\n\n    dfs( 0 , -1 , 0 , dis[0] ) ; \n    int u = max_element( dis[0] , dis[0] + n ) - dis[0]; \n    dfs( u , -1 , 0 , dis[1] ); \n    int val = ( *max_element( dis[1] , dis[1] + n ) + 1 ) / 2; \n    int z = 0; \n    for( int i = 0 ; ; i++ , z += z + 1 ) \n        if( val <= z ) { \n            cout << i << endl;\n            return 0; \n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint dp[100001][20];\n\nvector<int> e[100001];\n\n\nvoid dfs(int x,int p){\n\tfor(int it:e[x]){\n\t\tif(it!=p){\n\t\t\tdfs(it,x);\n\t\t\tfor(int i=0;i<=19;i++)\n\t\t\t\tdp[x][i]+=dp[it][i];\n\t\t}\n\t}\n\tint who;\n\tfor(who=19;who>=0;who--)\n\t\tif(dp[x][who]>1)\n\t\t\tbreak;\n\twho++;\n\twhile(dp[x][who])\twho++;\n\tdp[x][who]++;\n\tfor(int i=0;i<who;i++)\n\t\tdp[x][i]=0;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=1,u,v;i<n;i++){\n\t\tcin>>u>>v;\n\t\te[u].emplace_back(v);\n\t\te[v].emplace_back(u);\n\t}\n\tdfs(1,0);\n\tfor(int i=19;;i--)\n\t\tif(dp[1][i]){\n\t\t\tcout<<i<<endl;\n\t\t\treturn 0;\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && up[G[v][i].first] <= 1 + down[G[v][i].first]) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\twhile (true) {\n\t\tans++;\n\t\tmemset(Mark, 0, sizeof Mark);\n\t\tmemset(down, 0, sizeof down);\n\t\tmemset(up, 0, sizeof up);\n\t\tbool change = false;\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\tchange = true;\n\t\t\t\t\n\t\t\t\tdfs1(i, i);\n\t\t\t\tdfs2(i, i, 0);\n\t\t\t\tfindS(i, i);\n\t\t\t\tdel[S] = true;\n\t\t\t\t//cout << \"&   \" << S << \"\\n\";\n\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!d[i]) {\n\t\t\t\t//cout << \"^ \" << i << \"\\n\";\n\t\t\t\tdel[i] = true;\n\t\t\t}\n\t\t\t\t\n\t\tif (!change)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ans - 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\nint n;\nvector<int>G[100010];\nint state[100010];\nint ans;\nvoid dfs(int x,int p)\n{\n\tint all[22];\n\tfor(int i=0;i<=20;i++)all[i]=0;\n\tstate[x]=0;\n\tfor(int i=0;i<G[x].size();i++)\n\t{\n\t\tint y=G[x][i];\n\t\tif(y==p)continue;\n\t\tdfs(y,x);\n\t\tstate[x]|=state[y];\n\t    for(int j=0;j<=20;j++)\n\t    {\n\t    \tif(state[y]>>j&1)\n\t    \t{\n\t    \t\tall[j]++;\n\t    \t}\n\t    }\n\t}\n\tint res=0;\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(all[i]>1)\n\t\t{\n\t\t\tres=i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=res;i<=20;i++)\n\t{\n\t\tif(state[x]>>i&1)continue;\n\t\tres=i;\n\t\tbreak;\n\t}\n\tstate[x]|=(1<<res);\n\tfor(int i=0;i<res;i++)if(state[x]>>i&1)state[x]^=(1<<i);\n\tans=max(ans,res);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a); \n\t}\n\tdfs(1,0);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, a, b);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\t--a[i]; --b[i];\n\t\tg[a[i]].emplace_back(b[i]);\n\t\tg[b[i]].emplace_back(a[i]);\n\t}\n\n\tint ans = 0;\n\twhile (true) {\n\t\tstd::vector<int> checked(g.size(), -1);\n\t\tint p = 0;\n\t\tstd::map<int, std::set<int>> map;\n\t\tREP(i, g.size()) {\n\t\t\tif (checked[i] >= 0) continue;\n\t\t\tif (g[i].size() == 1) {\n\t\t\t\tint c = g[i][0];\n\t\t\t\tif (checked[c] >= 0) continue;\n\t\t\t\tfor(const auto& j : g[c]) {\n\t\t\t\t\tchecked[j] = p;\n\t\t\t\t}\n\t\t\t\tchecked[c] = p++;\n\t\t\t}\n\t\t}\n\t\tstd::set<int> cset;\n\t\tREP(i, g.size()) {\n\t\t\tif (checked[i] >= 0) {\n\t\t\t\tif (cset.find(checked[i]) != cset.end()) continue;\n\t\t\t\tif (g[i].size() == 1) {\n\t\t\t\t\tint c = g[i][0];\n\t\t\t\t\tfor (const auto& j : g[c]) {\n\t\t\t\t\t\tif (g[j].size() >= 2) {\n\t\t\t\t\t\t\tcset.insert(checked[c]);\n\t\t\t\t\t\t\tfor (const auto& k : g[j]) {\n\t\t\t\t\t\t\t\tif (k == c) continue;\n\t\t\t\t\t\t\t\tint t = k;\n\t\t\t\t\t\t\t\tif (checked[k] >= 0) t = 200000 + checked[k];\n\t\t\t\t\t\t\t\tmap[200000 + checked[c]].insert(t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (const auto& j : g[i]) {\n\t\t\t\t\tint t = j;\n\t\t\t\t\tif (checked[j] >= 0) t = 200000 + checked[j];\n\t\t\t\t\tmap[i].insert(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::map<int, int> map2;\n\t\tint ppp = 0;\n\t\tfor (const auto& x : map) {\n\t\t\tmap2[x.first] = ppp++;\n\t\t}\n\n\t\tstd::vector<std::vector<int>> gg;\n\t\tfor(const auto& x : map) {\n\t\t\tstd::vector<int> vec(x.second.size());\n\t\t\tint pp = 0;\n\t\t\tfor (const auto& y : x.second) {\n\t\t\t\tvec[pp++] = map2[y];\n\t\t\t}\n\t\t\tgg.emplace_back(vec);\n\t\t}\n\t\tg = gg;\n\t\t++ans;\n\t\tif (g.empty()) {\n\t\t\tOUT(ans)BR;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      //if(!used[i]&&belong[i]<0) exit(0);\n      if(!used[i]&&cnt[i]<1) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n,u,v,ans,dp[110000][33];\nint edgenum,vet[210000],Next[210000],Head[110000];\nvoid addedge(int u,int v){\n\tvet[++edgenum]=v;\n\tNext[edgenum]=Head[u];\n\tHead[u]=edgenum;\n}\nvoid dfs(int u,int fa){\n\tint v;\n\tfor (int e=Head[u];e;e=Next[e]){\n\t\tv=vet[e];\n\t\tif (v!=fa){\n\t\t\tdfs(v,u);\n\t\t\tfor (int i=0;i<=30;i++) dp[u][i]+=dp[v][i];\n\t\t}\n\t}\n\tv=0;\n\tfor (int i=0;i<=30;i++)\n\t\tif (dp[u][i]>1) v=i+1;\n\twhile (dp[u][v]) v++;\n\tans=max(ans,v); dp[u][v]=1;\n\tfor (int i=0;i<v;i++) dp[u][i]=0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint N;\nvector< int > g[100000];\nbool v[100000][30];\n\nint dfs(int idx, int par) {\n  int ret = 0;\n  vector< int > d(30);\n  for(auto &to : g[idx]) {\n    if(to != par) {\n      ret = max(ret, dfs(to, idx));\n      for(int i = 0; i < 30; i++) d[i] += v[to][i];\n    }\n  }\n  int low = 0;\n  for(int i = 29; i >= 0; i--) {\n    if(d[i] >= 2) {\n      low = i + 1;\n      break;\n    }\n  }\n  for(int i = low; i <= 30; i++) {\n    if(i == 30) {\n      throw 0;\n    }\n    bool correct = true;\n    for(auto &to : g[idx]) {\n      if(to != par) {\n        if(v[to][i]) correct = false;\n      }\n    }\n    if(correct) {\n      //cout << idx+1 << \" \" << low << \" \" << i+1 << endl;\n      ret = max(ret, i);\n      v[idx][i] = true;\n      for(auto &to : g[idx]) {\n        if(to != par) {\n          for(int j = i + 1; j < 30; j++) {\n            v[idx][j] |= v[to][j];\n          }\n        }\n      }\n      break;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  cout << dfs(0, -1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<19)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\twhile(f[u]>>mn&1)++mn;\n\tfor(int i=18;;--i)\n\t\tif(i<mn || (mx>>i&1))\n\t\t{\n\t\t\t++i;\n\t\t\t// f[u]&=S-((1<<i)-1);\n\t\t\t// f[u]|=1<<i;\n\t\t\tf[u]=(f[u]>>i<<i)|(1<<i);\n\t\t\tans=max(ans,i);\n\t\t\t// cerr<<u<<\" \"<<i<<endl;\n\t\t\tbreak;\n\t\t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n4 8\n8 9\n9 10\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXM=MAXN-1;\n\nint n;\nint ghead[MAXN],gnxt[2*MAXM],gto[2*MAXM];\n\nll dfs(int at,int par) {\n\tll ret=0;\n\tfor(int x=ghead[at];x!=-1;x=gnxt[x]) {\n\t\tint to=gto[x]; if(to==par) continue;\n\t\tll cur=dfs(to,at);\n\t\tif(cur>ret) ret=cur;\n\t}\n\tint me=0; while(ret&(1LL<<me)) ++me; ret|=1LL<<me; ret&=~((1LL<<me)-1);\n\t//printf(\"%d = %lld\\n\",at,ret);\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n) ghead[i]=-1;\n\tREP(i,n-1) {\n\t\tint a,b; scanf(\"%d%d\",&a,&b); --a,--b;\n\t\tgnxt[2*i+0]=ghead[a]; ghead[a]=2*i+0; gto[2*i+0]=b;\n\t\tgnxt[2*i+1]=ghead[b]; ghead[b]=2*i+1; gto[2*i+1]=a;\n\t}\n\tll res=dfs(0,-1);\n\tint ret=0; while(res>>(ret+1)) ++ret; printf(\"%d\\n\",ret);\n\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=524444;\n\ntypedef long long LL;\n\nint n,f[N],ans,g[N],h[N],e[N],nxt[N],tot;\n\nchar c;\n\nint read()\n{\n    int x=0,sig=1;\n    for (c=getchar();c<'0' || c>'9';c=getchar()) if (c=='-') sig=-1;\n    for (;c>='0' && c<='9';c=getchar()) x=x*10+c-48;\n    return x*sig;\n}\n\nvoid Add(int x,int y)\n{\n\te[++tot]=y; nxt[tot]=h[x]; h[x]=tot;\n}\n\nvoid dfs(int x,int y)\n{\n\tint i,j,k;\n\tfor (i=h[x],j=k=0;i;i=nxt[i]) if (e[i]!=y)\n\t{\n\t\tdfs(e[i],x);\n\t\tif ((j&f[e[i]])>0) k=max(k,g[j&f[e[i]]]+1);\n\t\tj|=f[e[i]];\n\t}\n\t//for (i=0;((1<<i)&j)>0;i++);\n\t//k=max(k,i);\n\tfor (;((1<<k)&j)>0;k++);\n\tans=max(ans,k);\n\tf[x]=1<<k;\n\tfor (;g[j]>k;j^=(1<<g[j])) f[x]|=(1<<g[j]);\n}\n\nint main()\n{\n\tn=read();\n\tfor (int i=1,x,y;i<n;i++)\n\t{\n\t\tx=read(); y=read();\n\t\tAdd(x,y); Add(y,x);\n\t}\n\tfor (int i=1,j=0;i<N;i<<=1,j++) g[i]=j;\n\tfor (int i=3;i<N;i++) if (!g[i]) g[i]=g[i-1];\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair <int, int> pii;\n\nconst int N = 1e5 + 10;\nint n, ans, mark[N];\nvector <int> vec, adj[N];\nqueue <pii> que;\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t}\n\t\n\tmemset(mark, 127, sizeof mark);\n\tfor (int i = 0; i < n; i++)\n\t\tif (adj[i].size() == 1)\n\t\t\tque.push({i, 0}), mark[i] = 0;\n\t\n\twhile (que.size()) {\n\t\tint v = que.front().first, c = que.front().second;\n\t\tque.pop();\n\t\tif (mark[v] < c)\n\t\t\tcontinue;\n\t\tmark[v] = c;\n\t\tans = max(ans, c);\n\t\t\n\t\tfor (int i : adj[v])\n\t\t\tif (c + 1 < mark[i]) {\n\t\t\t\tmark[i] = c + 1;\n\t\t\t\tque.push({i, c + 1});\n\t\t\t}\n\t}\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 100005;\nconst int KMAX = 30;\n\nvector<int> G[NMAX];\n\narray<int, KMAX> dfs(int node, int prev) {\n    array<int, KMAX> ret;\n    fill(ret.begin(), ret.end(), 0);\n    ret[0] = 1;\n    for (int to: G[node]) {\n        if (to != prev) {\n            array<int, KMAX> son = dfs(to, node);\n            for (int i = 0; i < KMAX; ++i) {\n                ret[i] += son[i];\n            }\n        }\n    }\n    for (int i = 0; i < KMAX; ++i) {\n        if (ret[i] > 2) {\n            ret[i] = 0;\n            ret[i + 1]++;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    array<int, KMAX> ans = dfs(1, -1);\n    int fans = 0;\n    for (int i = 0; i < KMAX; ++i) {\n        if (ans[i] > 0) {\n            fans = i;\n        }\n    }\n    cout << fans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI X[100011];\n\nint par[100011];\nVI ord;\nint U[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i_, N) {\n\tint v = ord[i_];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    VI buf; buf.reserve(N+2);\n    \n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tint cnt = 0, ma = -1;\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    if (ma < X[*e].back()) {\n\t\tma = X[*e].back();\n\t\tcnt = 0;\n\t    }\n\t    if (ma == X[*e].back()) {\n\t\tcnt++;\n\t    }\n\t}\n\n\tif (cnt == 0) {\n\t    U[v] = 0;\n\t    X[v].push_back(0);\n\t} else if (cnt >= 2) {\n\t    U[v] = ma+1;\n\t    X[v].push_back(ma+1);\n\t} else {\n\t    buf.resize(ma+2);\n\t    fill(buf.begin(), buf.end(), 0);\n\t    EACH (e, G[v]) if (*e != par[v]) {\n\t\tEACH (f, X[*e]) buf[*f] = 1;\n\t    }\n\t    REP (i, ma+2) {\n\t\tif (buf[i] == 0) {\n\t\t    U[v] = i;\n\t\t    buf[i] = 1;\n\t\t    break;\n\t\t} else {\n\t\t    buf[i] = 0;\n\t\t}\n\t    }\n\t    if (U[v] == ma+1) {\n\t\tX[v].push_back(ma+1);\n\t    } else {\n\t\tREP (i, ma+2) {\n\t\t    if (buf[i]) X[v].push_back(i);\n\t\t}\n\t    }\n\t}\n\n    }\n\n    int ma = *max_element(U, U+N);\n    // rprintf(\"%d\", U, U+N);\n    printf(\"%d\\n\", ma);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n;\nvi g[N];\n\nint dfs(int c,int fa) {\n  vi f;\n  for(auto t : g[c]) if(t != fa)\n    f.pb(dfs(t , c));\n  f.pb(1);\n  bool carry = false;\n  int res = 0;\n  for(int i=0,d=0;i<20;++i) {\n    int s=d;\n    for(auto e : f)\n      s += e >> i & 1;\n    if(s == 1)\n      res |= 1 << i;\n    if(s >= 2)\n      d = 1;\n    else\n      d = 0;\n  }\n  return res;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  rep(i,1,n) {\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    g[u].pb(v);\n    g[v].pb(u);\n  }\n  printf(\"%d\\n\",31-__builtin_clz(dfs(1,0)));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 100000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,head[MN+5],cnt=0,f[MN+5],v[MN+5],ans=0;\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid dfs(int x,int fa)\n{\n\tint has=0,bad=0;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(e[i].to!=fa)\n\t\t{\n\t\t\tdfs(e[i].to,x);\n\t\t\tbad|=(has&f[e[i].to]);\n\t\t\thas|=f[e[i].to];\n\t\t}\n\tfor(v[x]=16;~v[x];--v[x]) if(bad&(1<<v[x])) break;\n\tfor(++v[x];has&(1<<v[x]);++v[x]);\n\tf[x]=(has&((1<<17)-(1<<v[x])))|(1<<v[x]);\n\tans=max(ans,v[x]);\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i) ins(read(),read());\n\tdfs(1,0);cout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nint n,x,y,tot,ne[N],fi[N],zz[N];\nvoid jb(int x,int y){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n}\nint dfs(int x,int y){\n\tint s1=0,s2=0,p=0;\n\tfor (int k=fi[x];k;k=ne[k])\n\t\tif (zz[k]!=y){\n\t\t\tint p=dfs(zz[k],x);\n\t\t\ts2|=s1&p;\n\t\t\ts1|=p;\n\t\t}\n\twhile (((1<<p)<s2)||(s1&(1<<p)))p++;\n\treturn (s1>>p<<p)|(1<<p);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tjb(x,y);jb(y,x);\n\t}\n\tprintf(\"%d\\n\",(int)log2(dfs(1,0)));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n#define pb push_back\n\nusing namespace std;\n\nconst int N = 100010;\n\nvector<int> G[N];\nint n;\n\nint far, mxdis;\n\nvoid DFS(int o, int f, int dep){\n\tif(dep > mxdis) mxdis = dep, far = o;\n\tfor(int v : G[o]){\n\t\tif(v == f) continue;\n\t\tDFS(v, o, dep + 1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFor(i, 2, n){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v), G[v].pb(u);\n\t}\n\tDFS(1, 0, 0);\n\tmxdis = 0;\n\tDFS(far, 0, 0);\n\tprintf(\"%d\\n\", int(log2(mxdis + 1) + 1e-9));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\nCopy\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=200010;\nint i,j,k,n,m,x,y,t,b[20];\nint fi[N*2],ne[N*2],la[N*2],a[N*2],w[N];\nint f[N][20],g[N][20];\nvoid add(int x,int y){\n\tk++;a[k]=y;\n\tif (fi[x]==0)fi[x]=k;else ne[la[x]]=k;\n\tla[x]=k;\n}\nvoid dfs(int x,int fa){\n\tfor (j=0;j<20;j++)f[x][j]=1;\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa){\n\t\tdfs(a[i],x);\n\t\tfor (j=0;j<20;j++)f[x][j]&=f[a[i]][j],g[x][j]+=g[a[i]][j];\n\t}\n\tmemset(b,0,sizeof b);\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa)b[w[a[i]]]++;\n\tfor (j=19;j>=0;j--)if (b[j]>1){\n\t\tfor (k=j;k<20;k++)if (f[x][k]){w[x]=k;break;}\n\t\tbreak;\n\t}\n\tif (!w[x]){for (j=0;j<20;j++)if (f[x][j]){w[x]=max(w[x],j);break;}}\n\tf[x][w[x]]=0;g[x][w[x]]++;\n\tfor (j=0;j<w[x];j++)f[x][j]=1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,-1);\n\tint ans=0;\n\tfor (i=1;i<=n;i++)ans=max(ans,w[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------------------------head--------------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,dp[N];\nvi g[N];\nbool vis[N];\n\nvoid dfs(int x){\n\tint cnt[20];clr(cnt,0);\n\tvis[x]=1;\n\tfor(int y:g[x]){\n\t\tif(vis[y]) continue;\n\t\tdfs(y);\n\t\tfor(int i=0;i<m;i++)\n\t\t\tif(dp[y]&1) cnt[i]++;\n\t}\n\tint mx=-1;\n\tfor(int i=0;i<m;i++)\n\t\tif(cnt[i]>=2) mx=i;\n\tfor(int i=0;i<m;i++)\n\t\tif(!cnt[i]&&i>mx){\n\t\t\tfor(int j=0;j<i;j++) cnt[j]=0;\n\t\t\tcnt[i]=1;\n\t\t\tbreak;\n\t\t}\n\tfor(int i=0;i<m;i++) dp[x]|=(cnt[i]>0)<<i;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\twhile((1<<m)<=n) m++;\n\tdfs(1);\n\tfor(int i=m;~i;i--)\n\t\tif(dp[1]&(1<<i)){print(i);break;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI X[100011];\n\nint par[100011];\nVI ord;\nint U[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i_, N) {\n\tint v = ord[i_];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    VI buf; buf.reserve(N+2);\n    \n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tint cnt = 0, ma = -1;\n\tVI g;\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    g.push_back(X[*e].back());\n\t    if (ma < X[*e].back()) {\n\t\tma = X[*e].back();\n\t\tcnt = 0;\n\t    }\n\t    if (ma == X[*e].back()) {\n\t\tcnt++;\n\t    }\n\t}\n\n\tif (cnt == 0) {\n\t    U[v] = 0;\n\t    X[v].push_back(0);\n\t} else {\n\t    buf.resize(ma+2);\n\t    fill(buf.begin(), buf.end(), 0);\n\t    EACH (e, G[v]) if (*e != par[v]) {\n\t\tEACH (f, X[*e]) buf[*f] = 1;\n\t\tbuf[U[*e]]++;\n\t    }\n\t    REP (i, ma+2) {\n\t\tif (buf[i] == 0) {\n\t\t    buf[i] = 1;\n\t\t    U[v] = i;\n\t\t    break;\n\t\t} else {\n\t\t    buf[i] = 0;\n\t\t}\n\t    }\n\t    REP (i, ma+2) if (buf[i]) X[v].push_back(i);\n\t}\n    }\n\n    int ma = *max_element(U, U+N);\n    //rprintf(\"%d\", U, U+N);\n    printf(\"%d\\n\", ma);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i, a, b) for(int i=(a); i<(b); i++)\n#define per(i, a, b) for(int i=(b)-1; i>=(a); i--)\n#define sz(a) (int)a.size()\n#define de(a) cout << #a << \" = \" << a << endl\n#define dd(a) cout << #a << \" = \" << a << \" \"\n#define all(a) (a).begin(), (a).end()\n#define pw(x) (1ll<<(x))\n#define lb(x) ((x) & -(x))\n#define endl \"\\n\"\n#define FI(x) freopen(#x\".in\",\"r\",stdin)\n#define FO(x) freopen(#x\".out\",\"w\",stdout)\ntypedef double db;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n//typedef uniform_int_distribution<ll> RR;\nconst int P = 1e9 + 7;\n//ll rnd(ll l, ll r) { mt19937 gen(rand()); RR dis(l, r); return dis(gen); }\nint add(int a, int b) {if((a += b) >= P) a -= P; return a < 0 ? a + P : a;}\nint mul(int a, int b) {return 1ll * a * b % P;}\nint kpow(int a, int b) {int r=1;for(;b;b>>=1,a=mul(a,a)) {if(b&1)r=mul(r,a);}return r;}\n//----\n\nconst int N = 1e5 + 7;\n\nint u, v, n, ans, now, f[N];\nvi g[N];\n\nvoid dfs(int u, int fa) {\n\tfor (auto v : g[u]) if (v != fa) {\n\t\tdfs(v, u);\n\t\tans = max(ans, f[u] + f[v] + 1);\n\t\tf[u] = max(f[u], f[v] + 1);\n\t}\n}\n\nint main() {\n\t//FI(a);\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t//cout << setiosflags(ios::fixed);\n\t//cout << setprecision(2);\n\tcin >> n;\n\trep(i, 1, n) {\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tnow = 1;\n\trep(i, 0, 100) {\n\t\tif (now >= ans + 1) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tnow = now * 2 + 1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tsrand(clock());\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\twhile (true) {\n\t\tans++;\n\t\tmemset(Mark, 0, sizeof Mark);\n\t\tmemset(down, 0, sizeof down);\n\t\tmemset(up, 0, sizeof up);\n\t\tbool change = false;\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\tchange = true;\n\t\t\t\t\n\t\t\t\tdfs1(i, i);\n\t\t\t\tdfs2(i, i, 0);\n\t\t\t\tfindS(i, i);\n\t\t\t\tdel[S] = true;\n\t\t\t\t//cout << \"&   \" << S << \"\\n\";\n\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!d[i]) {\n\t\t\t\t//cout << \"^ \" << i << \"\\n\";\n\t\t\t\tdel[i] = true;\n\t\t\t}\n\t\t\t\t\n\t\tif (!change)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ans - 1 << \"\\n\";\n\treturn 0;\n}//"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\ntypedef long long llint;\nconst llint inf = 1000000000000000000LL;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\nconst int MAXN = 100005;\n\nvector<int> T[MAXN];\nint dad[MAXN];\nbool alive[MAXN];\nint L[MAXN];\nint R[MAXN];\n\npair<int,int> far_dfs(int i, int d = 0, int cur_dad = -1) {\n  pair<int,int> ret = {d, i};\n  dad[i] = cur_dad;\n  for (int j : T[i])\n    if (alive[j] && j != cur_dad)\n      ret = max(ret, far_dfs(j, d + 1, i));\n  return ret;\n}\n\nint depth(int i, int dad) {\n  int ret = 0;\n\n  for (int j : T[i]) {\n    if (alive[j] && j == dad) continue;\n    ret = max(ret, 1 + depth(j, i));\n  }\n\n  return ret;\n}\n\nint solve(int i) {\n  auto a = far_dfs(i);\n  auto b = far_dfs(a.second);\n\n  if (b.first <= 1)\n    return b.first;\n\n  vector<int> path;\n\n  for (int i = b.second; i != -1; i = dad[i]) \n    path.push_back(i);\n\n  int cd = 0;\n  for (int i = 0; i < (int)path.size() - 1; ++i) {\n    for (int j : T[path[i]]) {\n      if (!alive[j] || j == path[i + 1] || i && j == path[i - 1]) continue;\n      cd = max(cd, depth(j, path[i]) + 1);\n    }\n    L[i] = cd;\n    ++cd;\n  }\n\n  cd = 0;\n  for (int i = (int)path.size() - 1; i >= 1; --i) {\n    for (int j : T[path[i]]) {\n      if (!alive[j] || j == path[i - 1]\n\t  || i + 1 < (int)path.size() && j == path[i + 1]) continue;\n      cd = max(cd, depth(j, path[i]) + 1);\n    }\n    R[i] = cd;\n    ++cd;\n  }\n\n  int best = 1;\n  int best_len = 1e9;\n  for (int i = 1; i < (int)path.size() - 1; ++i) {\n    if (max(L[i - 1], R[i + 1]) < best_len) {\n      best_len = max(L[i - 1], R[i + 1]);\n      best = i;\n    }\n  }\n\n  alive[path[best]] = 0;\n  int l = path[best - 1];\n  int r = path[best + 1];\n  path.clear();\n\n  return 1 + max(solve(l), solve(r));\n}\n\nint main(void) \n{\n  int N;\n  scanf(\"%d\", &N);\n\n  FOR(i, 1, N + 1) alive[i] = 1;\n\n  FOR(i, 1, N) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    T[a].push_back(b);\n    T[b].push_back(a);\n  }\n\n  printf(\"%d\\n\", solve(1));\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <complex>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 100000 + 5;\n\nint n;\nvector<int> adj[N];\nset<int> s[N];\n\nset<int>& dfs(int u, int f)\n{\n    set<int> &have = s[u];\n    int a = -1;\n\n    for(auto v: adj[u]) {\n        if (v == f) continue;\n        set<int> &f = dfs(v, u);\n        if (have.size() < f.size()) {\n            have.swap(f);\n        }\n        for(auto e: f) {\n            if (have.count(e)) {\n                a = max(a, e);\n            } else {\n                have.insert(e);\n            }\n        }\n    }\n\n    int b = a + 1;\n    for( ; have.count(b); b++);\n    for( ; have.size() && *have.begin() <= b; have.erase(have.begin()));\n    have.insert(b);\n    return s[u];\n}\n\nvoid solve()\n{\n    cin >> n;\n    for(int i = 0; i < n - 1; ++ i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    set<int> ret = dfs(0, -1);\n    int ans = *ret.rbegin();\n    cout << ans << endl;\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 100005;\nconst int KMAX = 30;\n\nvector<int> G[NMAX];\n\narray<int, KMAX> dfs(int node, int prev) {\n    array<int, KMAX> ret;\n    fill(ret.begin(), ret.end(), 0);\n    ret[0] = 1;\n    for (int to: G[node]) {\n        if (to != prev) {\n            array<int, KMAX> son = dfs(to, node);\n            for (int i = 0; i < KMAX; ++i) {\n                ret[i] += son[i];\n            }\n        }\n    }\n    for (int i = KMAX - 1; i >= 0; --i) {\n        if (ret[i] > 1) {\n            fill(ret.begin(), ret.begin() + i + 1, 0);\n            for (int j = i + 1; j < KMAX; ++j) {\n                if (ret[j] > 0) {\n                    ret[j] = 0;\n                } else {\n                    ret[j] = 1;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    array<int, KMAX> ans = dfs(1, -1);\n    int fans = 0;\n    for (int i = 0; i < KMAX; ++i) {\n        if (ans[i] > 0) {\n            fans = i;\n        }\n    }\n    cout << fans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI X[100011];\n\nint par[100011];\nVI ord;\nint U[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i_, N) {\n\tint v = ord[i_];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    VI buf; buf.reserve(N+2);\n    \n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tint ma = -1;\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    amax(ma, X[*e].back());\n\t}\n\n\tif (ma == -1) {\n\t    U[v] = 0;\n\t    X[v].push_back(0);\n\t} else {\n\t    buf.resize(ma+2);\n\t    fill(buf.begin(), buf.end(), 0);\n\t    EACH (e, G[v]) if (*e != par[v]) {\n\t\tEACH (f, X[*e]) buf[*f]++;\n\t    }\n\t    int at_least = 0;\n\t    REP (i, ma+2) if (buf[i] >= 2) at_least = i+1;\n\t    REP (i, ma+2) {\n\t\tif (i < at_least || buf[i]) {\n\t\t    buf[i] = 0;\n\t\t} else {\n\t\t    U[v] = i;\n\t\t    buf[i] = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t    REP (i, ma+2) if (buf[i]) X[v].push_back(i);\n\t}\n    }\n\n    int ma = *max_element(U, U+N);\n    //rprintf(\"%d\", U, U+N);\n    printf(\"%d\\n\", ma);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\n\nusing namespace std;\ntypedef unordered_map<ll,vector<ll> > tree;\nclass FindCentored{\n  public:\n  tree t;\n  ll res;\n  ll dfs(ll x,ll from){\n      ll sum=1,maxi=-1;\n      for(auto y:t[x]){\n\t  if(y==from)continue;\n\t  ll val=dfs(y,x);\n\t  sum+=val,maxi=max(maxi,val);\n      }\n      ll rem=t.size()-sum;\n      maxi=max(maxi,rem);\n      if(maxi<=t.size()/2)res=x;\n      return sum;\n  }\n  ll main(tree tt){t=tt;\n      dfs(t.begin()->first,-1);\n      return res;\n  }\n};FindCentored fc;\n\nclass DivideTree{\n  public:\n  tree t;\n  tree cur;\n  void make_edge(ll a,ll b){\n      cur[a].push_back(b);\n      cur[b].push_back(a);\n  }\n  void dfs(ll x,ll from,bool flag){\n      if(flag)make_edge(x,from);\n      for(auto y:t[x]){\n\t  if(y!=from)dfs(y,x,1);\n      }\n  }\n  vector<tree> res;\n  vector<tree> main(tree tt){t=tt;\n      res.clear();\n      //cout<<\"reach_dt\"<<endl;\n      ll centor=fc.main(t);\n      //cout<<\"centor_end\"<<endl;\n      for(auto x:t[centor]){\n\t  cur.clear();\n\t  dfs(x,centor,0);\n\t  res.push_back(cur);\n      }\n      return res;\n  }  \n};DivideTree dt;\n\nll solve(tree t){\n    //cout<<\"#\"<<t.size()<<endl;\n    if(t.size()==0)return 0;\n    vector<tree> v=dt.main(t);\n    ll res=-1;\n    for(auto x:v){\n\tres=max(res,solve(x));\n    }\n    return res+1;\n}\nint main(){\n    tree t;\n    ll n,a,b;cin>>n;\n    for(int i=0;i<n-1;i++){\n\tcin>>a>>b;\n\tt[a].push_back(b);\n\tt[b].push_back(a);\n    }\n    cout<<solve(t)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint f[100100][20],n,ans;\nvector<int> e[101000];\nvoid dfs(int x,int dad){\n\tint lim[20],now=0;memset(lim,0,sizeof(lim));\n\tfor(int v:e[x]) if(v!=dad){\n\t\tdfs(v,x);\n\t\tfor(int j=0;j<20;j++){\n\t\t\tif(lim[j]&&f[v][j]) now=max(now,j+1);\n\t\t\tlim[j]|=f[v][j];\n\t\t}\n\t}\n\twhile(lim[now]) now++;\n\tans=max(ans,now);\n\tfor(int i=0;i<now;i++) lim[i]=0;\n\tlim[now]=1;\n\tmemcpy(f[x],lim,sizeof(lim));\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x);read(y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N=100005;\n\nint fst[N],v[N],mask[N],tot=0;\n\nstruct Edge{\n\tint to,nxt;\n}e[N*2];\n\nvoid addedge(int x,int y){\n\te[++tot].to=y;e[tot].nxt=fst[x];fst[x]=tot;\n}\n\nvoid dfs(int x,int father){\n\tmask[x]=0;v[x]=0;\n\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\tint y=e[i].to;\n\t\tif (y!=father){\n\t\t\tdfs(y,x);\n\t\t\tint s=mask[x]&mask[y],j=0;\n\t\t\tmask[x]|=mask[y];\n\t\t\tfor (;s;s>>=1) j++;\n\t\t\tif (j>v[x]) v[x]=j;\n\t\t\tfor (;(mask[x]>>v[x])&1;v[x]++);\n\t\t\tfor (j=0;j<v[x];j++) mask[x]^=mask[x]&(1<<j);\n\t\t}\n\t}\n\tmask[x]|=1<<v[x];\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\\n\",&x,&y);\n\t\taddedge(x,y);\n\t\taddedge(y,x);\n\t}\n\tdfs(1,0);\n\tint ans=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (v[i]>ans) ans=v[i];\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define F first\n#define PB push_back\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\nconst int mod = (int)1e9 + 7;\nconst int maxn = 1e5 + 4;\nconst ll inf = 1e18;\n\nvector <int> t[maxn];\nint dis[maxn];\n\nint T (int n) {\n\tif (n <= 1)\n\t\treturn 0;\n\tn --;\n\treturn max (T(n / 2), T((n + 1) / 2)) + 1;\n}\n\nvoid dfs (int v, int par = -1) {\n\tfor (auto u : t[v]){\n\t\tif (u != par){\n\t\t\tdis[u] = dis[v] + 1;\n\t\t\tdfs (u, v);\n\t\t}\n\t}\n}\n\nint main (){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tt[v].PB (u);\n\t\tt[u].PB (v);\n\t}\n\tdfs(1);\n\tint d = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (dis[i] > dis[d]){\n\t\t\td = i;\n\t\t}\n\t}\n\tmemset (dis, 0, sizeof dis);\n\tdfs (d);\n\tint dia = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tdia = max (dia, dis[i]);\n\t}\n\tcout << T (dia + 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int N = 100 * 1000 + 10;\n\nvector<int> g[N];\nbool del[N];\nint size[N];\nint max_s[N];\nvector<int> cur;\nint ans = 0;\n\nvoid dfs(int v, int par) {\n    size[v] = 1;\n    max_s[v] = 0;\n    cur.push_back(v);\n    for (int to : g[v])\n        if (!del[to] && to != par) {\n            dfs(to, v);\n            size[v] += size[to];\n            max_s[v] = max(max_s[v], size[to]);\n        }\n}\n\nvoid build(int st, int curh) {\n    ans = max(ans, curh);\n    cur.clear();\n    dfs(st, st);\n    if (cur.size() == 1)\n        return;\n    int tot = cur.size();\n    int v = -1;\n    for (int x : cur)\n        if (v == -1 || max(max_s[v], tot - size[v]) > max(max_s[x], tot - size[x]))\n            v = x;\n    del[v] = true;\n    for (int to : g[v])\n        if (!del[to])\n            build(to, curh + 1); \n}\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);    \n    }\n    build(0, 0);\n    cout << ans << endl;\n}   "
  },
  {
    "language": "C++",
    "code": "/** MIT License Copyright (c) 2018-2019 Vasilev Daniil **/\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> using v = vector<T>;\n#define int long long\ntypedef double ld;\ntypedef string str;\ntypedef vector<int> vint;\n#define rep(a, l, r) for(int a = (l); a < (r); a++)\n#define pb push_back\n#define fs first\n#define sc second\n#define sz(a) ((int) a.size())\nconst long long inf = 4611686018427387903; //2^62 - 1\nconst long double EPS = 1e-11;\n#if 0  //FileIO\nconst string fileName = \"\";\nifstream fin ((fileName == \"\" ? \"input.txt\"  : fileName + \".in\" ));\nofstream fout((fileName == \"\" ? \"output.txt\" : fileName + \".out\"));\n#define get fin >>\n#define put fout <<\n#else\n#define get cin >>\n#define put cout <<\n#endif\n#define eol put endl\nvoid read() {} template<typename Arg,typename... Args> void read (Arg& arg,Args&... args){get (arg)     ;read(args...) ;}\nvoid print(){} template<typename Arg,typename... Args> void print(Arg  arg,Args...  args){put (arg)<<\" \";print(args...);}\nint getInt(){int a; get a; return a;}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//code starts here\nconst int N = 1e5 + 1;\nvint t[N];\nint h[N];\nint mx[N], submx[N];\n \nvoid calcH(int cur, int p) {\n\th[cur] = 1;\n\tfor (int i : t[cur]) \n\t\tif (i != p) {\n\t\t\tcalcH(i, cur);\n\t\t\th[cur] = max(h[cur], h[i] + 1);\n\t\t}\n\t\n\tmx[cur] = 0; submx[cur] = 0;\n\tfor (int i : t[cur]) \n\t\tif (i != p) {\n\t\t\tif (mx[cur] == -1 || h[mx[cur]] < h[i]) {\n\t\t\t\tsubmx[cur] = mx[cur];\n\t\t\t\tmx[cur] = i;\n\t\t\t} else if (submx[cur] == -1 || h[submx[cur]] < h[i])\n\t\t\t\tsubmx[cur] = i;\n\t\t}\n}\n \nint ans[N];\nvoid calcAns(int cur, int p, int upperHeight) {\n\tans[cur] = max(h[cur] - 1, upperHeight) + 1;\n\tfor (int i : t[cur]) \n\t    if (i != p) {\n    \t\tif (mx[cur] == i)\n    \t\t\tcalcAns(i, cur, max(upperHeight, h[submx[cur]]) + 1);\n    \t\telse\n    \t\t\tcalcAns(i, cur, max(upperHeight, h[mx[cur]]) + 1);\n    \t}\n}\n \nvoid run() {\n\th[0] = -1;\n\tint n;\n\tget n;\n\t\n\trep(i, 1, n) {\n\t\tint v, u;\n\t\tread(v, u);\n\t\tt[v].pb(u);\n\t\tt[u].pb(v);\n\t}\n\t\n\tcalcH(1, -1);\n\tcalcAns(1, -1, 0);\n\tint res = n;\n\trep(i, 1, n + 1)\n\t\tres = min(res, ans[i]);\n\t\n\tint out = 0;\nint cnt = 1;\n\twhile (cnt < res) {\nout++;\ncnt = cnt * 2 + 1;\n}\n\tput out;\n}\nsigned main() {srand(time(0)); ios::sync_with_stdio(0); cin.tie(0); put fixed << setprecision(12); run();}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define OUT(x)  cerr << #x << \" = \" << x << endl;\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n#define pii     pair<int, int>\n#define piii    pair<int, pair<int, int>>\n\nvector<int> g[101010];\nlong long p[101010];\n\nvoid dfs(int v, int prev) {\n        vector<long long> children;\n        long long getor = 0;\n        for (int u : g[v]) if (u != prev) {\n                dfs(u, v);\n                children.push_back(p[u]);\n                getor |= p[u];\n        }\n        vector<int> cntbit(64);\n        for (int i = 0; i < 64; i ++) {\n                int cnt = 0;\n                for (long long ch : children) {\n                        if (ch & (1LL << i)) {\n                                cnt ++;\n                        }\n                }\n                cntbit[i] = cnt;\n        }\n        int s = 0, t = -1;\n        for (int i = 0; i < 64; i ++) {\n                if (cntbit[i] >= 2) {\n                        s = i + 1;\n                }\n        }\n        for (int i = s; i < 64; i ++) {\n                if (cntbit[i] == 0) {\n                        t = i;\n                        break;\n                }\n        }\n        long long mask = 1LL << t;\n        p[v] = (getor & ~(mask - 1)) | mask;\n        //cerr << static_cast<bitset<63>>(p[v]) << endl;\n}\n\nint main() {\n        int i, j;\n        int n;\n        cin >> n;\n        for (i = 0; i < n - 1; i ++) {\n                int a, b;\n                cin >> a >> b;\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        dfs(0, -1);\n        int ans = 0;\n        for (i = 0; i < 64; i ++) {\n                if (p[0] & (1LL << i)) {\n                        ans = i;\n                }\n        }\n        cout << ans << endl;\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint N;\nvector< int > g[100000];\nbool v[100000][30];\n\nint dfs(int idx, int par) {\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to != par) ret = max(ret, dfs(to, idx));\n  }\n  for(int i = 0; i < 30; i++) {\n    bool correct = true;\n    for(auto &to : g[idx]) {\n      if(to != par) {\n        if(v[to][i]) correct = false;\n      }\n    }\n    if(correct) {\n      ret = max(ret, i);\n      v[idx][i] = true;\n      for(auto &to : g[idx]) {\n        if(to != par) {\n          for(int j = i + 1; j < 30; j++) {\n            v[idx][j] |= v[to][j];\n          }\n        }\n      }\n      break;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  cin >> N;\n  for(int i = 1; i < N; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  for(int i = 0; i < N; i++) {\n    if(g[i].size() == 1) {\n      cout << dfs(i, -1) << endl;\n      return 0;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr long long LINF=334ll<<53; constexpr int INF=15<<26; constexpr long long MOD=1E9+7;\n\nstruct Edge{\n    int from,to;\n};\nusing Graph = vector<vector<Edge>>;\n\n//<f,s>\npair<int,int> dfs(int par, int cur, Graph &t){\n    if((int)t[cur].size()==1 and t[cur][0].to==par){\n        return{0,1};\n    }\n    int sum=0,prd=0,f=0;\n    for(auto &e: t[cur]){\n        if(e.to!= par){\n            auto sub = dfs(cur,e.to,t);\n            f=max(f,sub.first);\n            prd |= sum&sub.second;\n            sum |= sub.second;\n        }\n    }\n    int res=(int)log2((int)t.size())+2;\n    while(res>=0 && !(prd&(1<<res)))res--;\n    res++;\n    while(sum&(1<<res))res++;\n    DBG(cur,res,max(f,res),(((sum>>res)|1)<<res))\n    return {max(f,res),(((sum>>res)|1)<<res)};\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    Graph t(n);\n    for(int i=0; i<n-1; ++i){\n        int a,b;\n        cin >> a >>b;\n        --a;--b;\n        t[a].push_back({a,b});\n        t[b].push_back({b,a});\n    }\n    cout << dfs(-1,0,t).first<<\"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\nint c[MX];\n\nP cfs(int v, int d=0, int p=-1) {\n  P res(d,v);\n  for (int u : to[v]) {\n    if (c[u] || u == p) continue;\n    maxs(res, cfs(u,d+1,v));\n  }\n  return res;\n}\nvi vs;\nbool vfs(int v, int t, int p=-1) {\n  if (v == t) {\n    vs.pb(v);\n    return true;\n  }\n  for (int u : to[v]) {\n    if (c[u] || p == u) continue;\n    if (vfs(u,t,v)) {\n      vs.pb(v);\n      return true;\n    }\n  }\n  return false;\n}\nint dfs(int v) {\n  v = cfs(v).se;\n  P p = cfs(v);\n  vs = vi();\n  vfs(v,p.se);\n  v = vs[(p.fi+rand()%2)/2];\n  c[v] = 1;\n  int res = 0;\n  for (int u : to[v]) {\n    if (c[u]) continue;\n    maxs(res,dfs(u)+1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint num[100001];\n\npair<int,int> dfs_center(int cur,int pre) {\n\tint i;\n\tpair<int,int> res=make_pair(1<<30,-1);\n\tint ma=0;\n\tnum[cur]=1;\n\t\n\tFOR(i,E[cur].size()) {\n\t\tint tar=E[cur][i];\n\t\tif(tar==pre) continue;\n\t\tres=min(res,dfs_center(tar,cur));\n\t\t\n\t\tma=max(ma,num[tar]);\n\t\tnum[cur]+=num[tar];\n\t}\n\treturn min(res,make_pair(max(ma,N-num[cur]),cur));\n}\n\nint dfs(int cur,int pre) {\n\tint cnt[32]={};\n\tint mi=-1;\n\tint mask=0,i;\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tint ret = dfs(r,cur);\n\t\tmask |= ret;\n\t\tFOR(i,30) {\n\t\t\tif(mask&(1<<i)) cnt[i]++;\n\t\t\tif(cnt[i]>=2) mi=max(mi,i);\n\t\t}\n\t}\n\t\n\tmask |= 1<<(mi+1);\n\tFOR(i,mi+1) if(mask&(1<<i)) mask ^= 1<<i;\n\treturn mask;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tauto center=dfs_center(0,-1);\n\tx = dfs(center.second,-1);\n\tFOR(i,32) if(x&(1<<i)) {\n\t\tcout<<(i+1)<<endl;\n\t\tbreak;\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 1e5 + 7;\nconst int LOG = 20;\n\nint n;\nvector<int> adj[N];\nint ans = 0;\n\nint dfs(int u, int from) {\n\tint all = 0, least = 0;\n\tvector<int> mask;\n\tfor (int v : adj[u]) {\n\t\tif (v == from) continue;\n\t\tint mask = dfs(v, u);\n\t\tfor (int j = 0; j < LOG; j++) {\n\t\t\tif ((all >> j & 1) && (mask >> j & 1)) {\n\t\t\t\tleast = j + 1;\n\t\t\t}\n\t\t}\n\t\tall |= mask;\n\t}\n\tfor (int i = least; ; i++) {\n\t\tif (~all >> i & 1) {\n\t\t\tans = max(ans, i);\n\t\t\tall ^= (1 << i);\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (all >> j & 1) {\n\t\t\t\t\tall ^= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn all;\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector <int> adia[100010];\nint see[100010];\nint maxim = 0, total;\n\nint lsb(int x, int i)\n{\n    for (; ; i++)\n        if ((1 << i) & x)\n            return i;\n}\n\nint msb(int x)\n{\n    for (int i = 30; ; i--)\n        if ((1 << i) & x)\n            return i;\n}\n\nint dfs(int nod, int tata)\n{\n    int ce_pun = 0;\n    for (auto i : adia[nod]) {\n        if (i != tata) {\n            int m = dfs(i, nod);\n            if (m & see[nod])\n                ce_pun = max(ce_pun, msb(m & see[nod]));\n            see[nod] |= m;\n        }\n    }\n    ce_pun = lsb(~see[nod], ce_pun);\n    maxim = max(maxim, ce_pun);\n\n    see[nod] |= (1 << ce_pun);\n    for (int i = 0; i < ce_pun; i++)\n        see[nod] &= ~(1 << i);\n\n    return see[nod];\n}\n\nint main()\n{\n    int n, a, b;\n    cin >> n;\n\n    while (--n) {\n        cin >> a >> b;\n        adia[a].push_back(b);\n        adia[b].push_back(a);\n    }\n\n    dfs(1, 0);\n\n    cout << maxim << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = inF, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << max(0, solve(0) - 2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\n#define lc (v * 2)\n#define rc (v * 2 + 1)\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n\nconst int N = 1e5 + 7;\n\nvector <int> ad[N];\nint n;\nint cnt[N][30];\nint res = 0;\nvoid solve(int v, int p = 0) {\n\tif (ad[v].size() == 1 && ad[v].back() == p) {\n\t\tcnt[v][0] = 1;\n\t\treturn;\n\t}\n\tfor (auto u: ad[v])\n\t\tif (u != p) {\n\t\t\tsolve(u, v);\n\t\t\tfor (int i = 0; i < 30; i++)\n\t\t\t   cnt[v][i] += cnt[u][i];\t\n\t\t}\n\tint lst = 29;\n\tfor (int i = 28; i >= 0; i--)\n\t\tif (cnt[v][i] > 1)\n\t\t\tbreak;\n\t\telse if (!cnt[v][i])\n\t\t\tlst = i;\n\tfor (int i = 0; i < lst; i++)\n\t\tcnt[v][i] = 0;\n\tcnt[v][lst] = 1;\n\tres = max(res, lst);\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tad[v].push_back(u);\n\t\tad[u].push_back(v);\n\t}\n\tsolve(1);\n\tcout << res;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define next nxt\n\nint n,x[N],y[N],next[N],p[N],f[N],g[N],ans;\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nvoid travel(int x){\n\tint tmp=0,t=0;\n\tfor (int t=p[x];t;t=next[t])\n\t\tif (f[x]!=y[t]){\n\t\t\tf[y[t]]=x;travel(y[t]);\n\t\t\ttmp|=g[x]&g[y[t]];g[x]|=g[y[t]];\n\t\t}\n\twhile ((1<<t)<=tmp||(1<<t)&g[x]) t++;\n\tg[x]=(g[x]>>t<<t)|(1<<t);\n\tans=max(ans,t);\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n-1;i++){\n\t\tx[2*i-1]=y[2*i]=read();\n\t\ty[2*i-1]=x[2*i]=read();\n\t\tnext[2*i-1]=p[x[2*i]];p[x[2*i-1]]=2*i-1;\n\t\tnext[2*i]=p[x[2*i]];p[x[2*i]]=2*i;\n\t}\n\ttravel(1);printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst int maxn = 100010;\n\nV<int> g[maxn];\n\nint dfs(int v, int p) {\n\tV<int> vec;\n\tfor (int to : g[v]) if (to != p) {\n\t\tvec.pb(dfs(to, v));\n\t}\n\n\tV<int> cnt(30);\n\n\tint dup = -1;\n\tfor (int i = 0; i < 30; ++i) {\n\t\tfor (int x : vec) {\n\t\t\tif ((x >> i) & 1) {\n\t\t\t\tcnt[i]++;\n\t\t\t}\n\t\t}\n\t\tif (cnt[i] >= 2) {\n\t\t\tdup = i;\n\t\t}\n\t}\n\n\tfor (int i = dup + 1; i < 30; ++i) {\n\t\tif (cnt[i] == 0) {\n\t\t\tint mask = (1 << i);\n\t\t\tfor (int x : vec) {\n\t\t\t\tmask |= x;\n\t\t\t}\n\t\t\tmask &= ~((1 << i) - 1);\n\t\t\tdump(mp(v, mask));\n\t\t\treturn mask;\n\t\t}\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\trep(i, N-1) {\n\t\tint a, b; cin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b); g[b].pb(a);\n\t}\n\tint res = dfs(0, -1);\n\tfor (int i = 30; i >= 0; --i) {\n\t\tif ((res >> i) & 1) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 50010\nusing namespace std;\nint n,tote,to[N<<1],nxt[N<<1],con[N],w[N],ans;\nvoid ins(int x,int y)\n{\n\tto[++tote]=y;\n\tnxt[tote]=con[x];\n\tcon[x]=tote;\n}\nvoid dfs(int v,int fa)\n{\n\tint dep=-1;\n\tbool flag=0;\n\tfor(int p=con[v];p;p=nxt[p])\n\t\tif(to[p]!=fa)\n\t\t{\n\t\t\tdfs(to[p],v);\n\t\t\tint tmp=w[v]&w[to[p]];\n\t\t\tfor(int i=30;i>=0;i--)\n\t\t\t\tif((tmp>>i)&1) {dep=max(dep,i);break;}\n\t\t\tw[v]=w[v]|w[to[p]];\n\t\t\tflag=1;\n\t\t}\t\n\tif(!flag) {w[v]=1;return ;}\t\n\tfor(int i=dep+1;i<=30;i++)\n\t\tif((w[v]>>i)&1) \n\t\t\tdep=max(dep,i);\n\t\telse break;\n\tans=max(ans,dep+1);\n\tint R=(1<<(dep+1)),T=((1<<30)-1)^(R-1);\n\tw[v]=(w[v]&T)|R;\t\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tins(x,y);ins(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 100010\nvector<int> g[N];\nint n;\nint d[N];\n\nint dfs(int u){\n\tint res = u;\n\tfor(auto v: g[u]){\n\t\tif(d[v]>=0) continue;\n\t\td[v] = d[u]+1;\n\t\tint w = dfs(v);\n\t\tif(d[w]>d[res]) res = w;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tu--; v--;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tmset(d, -1);\n\td[0] = 0;\n\tint u = dfs(0);\n\tmset(d, -1);\n\td[u] = 0;\n\tint r = d[dfs(u)];\n\tint s = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(r<=s){\n\t\t\tcout<<i<<endl;\n\t\t\tbreak;\n\t\t}\n\t\ts = s*2+2;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n  int t,next;\n  Edge() {}\n  Edge(int a,int b):t(a),next(b) {}\n}; \n\nEdge e[200005];\nint head[100005];\n\nint f[100005],g[100005],ans;\n\nvoid dfs(int x,int fa) {\n  int sum=0;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) {\n    \tint u=e[i].t;\n    \tdfs(u,x);\n    \tsum|=g[x]&g[u];\n    \tg[x]|=g[u];\n\t}\n  sum|=g[x];\n  for(int i=0;i<20;i++)\n    if (!(sum&(1<<i))) {\n    \tf[x]=i;\n    \tbreak;\n\t} \n    else g[x]&=((1<<20)-1)^(1<<i);\n  g[x]|=(1<<f[x]);\n  ans=max(ans,f[x]);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[2*i-1]=Edge(y,head[x]);\n  \thead[x]=2*i-1;\n  \te[2*i]=Edge(x,head[y]);\n  \thead[y]=2*i;\n  }\n  dfs(1,0);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define ull unsigned ll\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 100100\n#define MOD 1000000007\n\nll n,a,b;\nll data[MAXN];\n\nint main(){\n\tcin >> n >> a >> b;\n\tfor(int i = 1;i <= n;i++)\n\t\tcin >> data[i];\n\t\n\tfor(int i = 3;i <= n;i++)\n\t\tif(data[i] - data[i-2] < min(a,b)){\n\t\t\tcout << 0 << endl;\n\t\t\treturn 0;\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nconst int M = 17, MX = 1<<M;\nvi to[MX];\nint t[MX];\n\nint dfs(int v, int p=-1) {\n  int a = 0, b = 0;\n  for (int u : to[v]) {\n    if (u == p) continue;\n    int r = dfs(u,v);\n    b |= a&r;\n    a |= r;\n  }\n  a |= t[b]-1; ++a;\n  return a;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  rep(i,M+1) for (int j = 1<<i>>1; j < (1<<i); ++j) t[j] = 1<<i;\n  int x = dfs(0);\n  int ans = 0;\n  while (x > 1) ++ans, x >>= 1;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<19)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\twhile(f[u]>>mn&1)++mn;\n\tfor(int i=18;;--i)\n\t\tif(i<mn || mx>>i&1)\n\t\t{\n\t\t\t++i;\n\t\t\tf[u]&=S-((1<<i)-1);\n\t\t\tf[u]|=1<<i;\n\t\t\tans=max(ans,i);\n\t\t\tbreak;\n\t\t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(4) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N =   1e5 + 10;\n\nvi g[N];\nint from[N];\n\nint dfs(int v, int par) {\n    int ret = 0;\n    from[v] = 0;\n    for (int to : g[v]) {\n        if (to == par)\n            continue;\n        int cur = dfs(to, v) + 1;\n        if (cur > ret) {\n            ret = cur;\n            from[v] = to;\n        }\n    }\n    return ret;\n}\n\nint dp[N];\n\nvoid smain() {\n    int n;\n    cin >> n;\n    fori (i, n) {\n        int u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(1, -1);\n    int v = 1;\n    while (from[v]) {\n        v = from[v];\n    }\n    dfs(v, -1);\n    int d = 1;\n    while (from[v]) {\n        v = from[v];\n        d++;\n    }\n\n\n    dp[1] = 0;\n    dp[2] = 1;\n\n    for (int i = 3; i <= d; ++i) {\n        int h = (i - 1) >> 1;\n        int h2 = i - 1 - h;\n        dp[i] = max(dp[h], dp[h2]) + 1;\n    }\n    cout << dp[d];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 10000;\n\nint n;\nvector<int> edg[MAXN];\nint f[MAXN], v[MAXN];\n\nvoid dfs(int x, int fa)\n{\n\tf[x] = 0, v[x] = 0;\n\tint cov = 0;\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(edg[x][i] != fa)\n\t\t{\n\t\t\tint y = edg[x][i];\n\t\t\tdfs(y, x);\n\t\t\tcov |= f[y] & f[x];\n\t\t\tf[x] |= f[y];\n\t\t}\n\twhile((1 << v[x]) < cov || (f[x] & (1 << v[x])))\n\t\tf[x] ^= 1 << v[x], v[x]++;\n\tf[x] |= 1 << v[x];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tedg[x].push_back(y), edg[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t\tans = max(ans, v[i]);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=100007;\n\nstd::vector<int>p[N];\nint n,f[N],g[N];\n\ninline void dfs(int x,int fa)\n{\n\tint t=0;\n\tfoe(i,p[x])if(*i!=fa)\n\t{\n\t\tdfs(*i,x);\n\t\tt|=f[x]&f[*i];\n\t\tf[x]|=f[*i];\n\t}\n\tfor(;(1<<g[x])<=t||(f[x]>>g[x]&1);g[x]++);\n\tf[x]&=~((1<<g[x])-1);\n\tf[x]|=1<<g[x];\n}\n\nint main()\n{\n\tin,n;\n\tfo1(i,n-1)\n\t{\n\t\tint x,y;\n\t\tin,x,y;\n\t\tp[x].pb(y);\n\t\tp[y].pb(x);\n\t}\n\tdfs(1,0);\n\tint ans=0;\n\tfo1(i,n)repr(ans,g[i]);\n\tout,ans,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct node { int t,next; }a[200010];\n\nint f[100010][21],head[100010],cnt[233],n,tot;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void add(int x,int y) { a[++tot].t=y;a[tot].next=head[x];head[x]=tot; }\n\ninline void dfs(int x,int y)\n{\n\tfor (int i=head[x];i;i=a[i].next) if (a[i].t!=y) dfs(a[i].t,x);\n\tmemset(cnt,0,sizeof(cnt));\n\tfor (int i=head[x];i;i=a[i].next)\n\t{\n\t\tint t=a[i].t;\n\t\tif (t==y) continue;\n\t\tfor (int j=0;j<21;j++) if (f[t][j]) cnt[j]++;\n\t}\n\tint pos=20;\n\twhile (~pos&&cnt[pos]<=1) pos--;\n\twhile (cnt[++pos]);\n\tf[x][pos]=1;\n\tfor (int i=pos+1;i<21;i++) f[x][i]=cnt[i];\n}\n\nint main()\n{\n\tn=rd();tot=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=rd(),y=rd();\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tint ans=0;\n\tfor (int i=0;i<21;i++) ans+=f[1][i],printf(\"%d\\n\",f[1][i]);\n\tprintf(\"%d\\n\",ans);\n\tfor (int i=20;~i;i--) if (f[1][i]) { printf(\"%d\\n\",i);break; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=100005; \nint n,f[N],ans[N];\nint pp,lnk[N],nxt[N*2],to[N*2];\nvoid ae(int k1,int k2){to[++pp]=k2,nxt[pp]=lnk[k1],lnk[k1]=pp;}\nvoid dfs(int k1,int k2){\n\tint s=0;\n\tfor(int i=lnk[k1];i;i=nxt[i])if(to[i]!=k2){\n\t\tdfs(to[i],k1);\n\t\ts|=f[k1]&f[to[i]];\n\t\tf[k1]|=f[to[i]];\n\t}\n\ts=__lg(s*2);\n\ts+=__builtin_ctz(~(f[k1]>>s));\n\tf[k1]=(f[k1]>>s|1)<<s,ans[k1]=s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,2,n){\n\t\tint k1,k2;\n\t\tscanf(\"%d%d\",&k1,&k2);\n\t\tae(k1,k2),ae(k2,k1);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",*max_element(ans+1,ans+1+n));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int MN = 100005;\n\nint N;\nstd::vector<int> G[MN];\n\nint f[MN];\nvoid DFS(int u, int p) {\n\tint x = 0, y = 0;\n\tfor (int v : G[u]) if (v != p) {\n\t\tDFS(v, u);\n\t\tint z = x & f[v];\n\t\tif (z) y = std::max(y, 32 - __builtin_clz(z));\n\t\tx |= f[v];\n\t}\n\tx &= ~((1 << y) - 1);\n\tf[u] = x + (1 << y);\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, x, y; i < N; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tDFS(1, 0);\n\tprintf(\"%d\\n\", 31 - __builtin_clz(f[1]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 111111\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tx=x*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,ans,f[N][33];\nint tot,a[N*2],b[N*2],c[N];\nvoid add(int x,int y){\n\ttot++;a[tot]=y;b[tot]=c[x];c[x]=tot;\n}\nvoid dfs(int u,int fa){\n\tfor (int i=c[u];i;i=b[i]){\n\t\tint to=a[i];\n\t\tif (to==fa){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to,u);\n\t\tfor (int i=0;i<=20;++i){\n\t\t\tf[u][i]+=f[to][i];\n\t\t}\n\t}\n\tint p=0;\n\tfor (int i=20;i>=0;--i){\n\t\tif (f[u][i]>1){\n\t\t\tp=i+1;break;\n\t\t}\n\t}\n\twhile (f[u][p]) p++;\n\tf[u][p]++;\n\tfor (int i=0;i<p;++i){\n\t\tf[u][i]=0;\n\t}\n\tans=max(ans,p);\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\n\tint n=read();\n\tfor (int i=1;i<n;++i){\n\t\tint u=read(),v=read();\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tdfs(1,0);\n\tcout<<ans<<endl;\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/** MIT License Copyright (c) 2018 Vasilyev Daniil **/\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\ntemplate<typename T> using v = vector<T>;\n//template<typename T, typename U>  using hmap = __gnu_pbds::gp_hash_table<T, U>;\n#define int long long\ntypedef long double ld;\ntypedef string str;\ntypedef vector<int> vint;\n#define rep(a, l, r) for(int a = (l); a < (r); a++)\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sc second\n#define sz(a) ((int) a.size())\nconst long long inf = 4611686018427387903; //2^62 - 1\n#if 0  //FileIO\nconst string fileName = \"\";\nifstream fin ((fileName == \"\" ? \"input.txt\"  : fileName + \".in\" ));\nofstream fout((fileName == \"\" ? \"output.txt\" : fileName + \".out\"));\n#define get fin>>\n#define put fout<<\n#else\n#define get cin>>\n#define put cout<<\n#endif\n#define eol put endl\n#define check(a) put #a << \": \" << a << endl;\nvoid read() {} template<typename Arg,typename... Args> void read (Arg& arg,Args&... args){get (arg)     ;read(args...) ;}\nvoid print(){} template<typename Arg,typename... Args> void print(Arg  arg,Args...  args){put (arg)<<\" \";print(args...);}\nint getInt(){int a; get a; return a;}\n//code goes here\nconst int N = 1e5 + 1;\nvint t[N];\nbitset<N> added;\nint siz[N];\nint ans = 0;\nint calcSize(int cur, int p = -1) {\n    siz[cur] = 1;\n    for (int i : t[cur])\n        if (!added.test(i) && i != p)\n            siz[cur] += calcSize(i, cur);\n    return siz[cur];\n}\nvoid make_centroid(int cur, int h = 0) {\n    ans = max(ans, h);\n    int lim = calcSize(cur) / 2;\n    bool again = 1;\n    int pr = -1;\n    while (again) {\n        again = 0;\n        for (int i : t[cur])\n            if (i != pr && !added.test(i) && siz[i] > lim) {\n                pr = cur;\n                cur = i;\n                again = 1;\n                break;\n            }\n    }\n    added.set(cur);\n    for (int i : t[cur])\n        if (!added.test(i))\n            make_centroid(i, h + 1);\n}\n\nvoid run() {\n    int n;\n    get n;\n    rep(i, 1, n) {\n        int v, u;\n        read(v, u);\n        t[v].pb(u);\n        t[u].pb(v);\n    }\n    make_centroid(1);\n    put ans;\n    eol;\n}\nsigned main() {srand(time(0)); ios::sync_with_stdio(0); cin.tie(0); put fixed << setprecision(15); run(); return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nint diameter(vector<vector<int> > const & tree) {\n    pair<int, int> result = { -1, -1 };\n    int dist = 0;\n    function<void (int, int)> dfs = [&](int i, int parent) {\n        setmax(result, make_pair(dist, i));\n        ++ dist;\n        for (int j : tree[i]) if (j != parent) {\n            dfs(j, i);\n        }\n        -- dist;\n    };\n    dfs(0, 0);\n    int k = result.second;\n    result = { -1, -1 };\n    dfs(k, 0);\n    return result.first;\n}\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n - 1) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    int d = diameter(g);\n    int k = 0;\n    for (int acc = 1; acc < d + 1; ) {\n        acc = 2 * acc + 1;\n        ++ k;\n    }\n    // output\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define min(x,y) ((x)<(y)?(x):(y))\n#define max(x,y) ((x)>(y)?(x):(y))\n\nusing namespace std;\n\nconst int maxn=2e5+5;\n\nint fi[maxn],ne[maxn*2],dui[maxn*2],qc[maxn],f[maxn*10];\nint cc[maxn];\nint i,j,k,l,m,n,x,y,now,ans;\n\nvoid add(int x,int y){\n\tif (fi[x]==0) fi[x]=++now; else ne[qc[x]]=++now;\n\tdui[now]=y; qc[x]=now;\n}\nvoid dfs(int x,int y){\n\tint i,t=0;\n\tfor(i=fi[x];i;i=ne[i]){\n\t\tif (dui[i]==y) continue;\n\t\tdfs(dui[i],x);\n\t\tt=max(t,f[x] & f[dui[i]]);\n\t\tf[x]=f[x] | f[dui[i]];\n\t}\n\tfo(i,1,24) if (cc[i]>t && ((f[x] & cc[i])==0)){\n\t\tt=i; break;\n\t}\n\tans=max(ans,t);\n\tf[x]=(f[x]&(cc[24]-cc[t]))|cc[t];\n}\nint main(){\n//\tfreopen(\"009d.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tcc[1]=1;\n\tfo(i,2,24) cc[i]=cc[i-1]*2;\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n//#define int long long\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\n#define X first\n#define Y second\n#define endl '\\n'\n#define IOS ios::sync_with_stdio(0), cin.tie(0)\n#define all(o) o.begin(), o.end()\nconst int maxn = 1e5 + 10;\nbool bad[maxn];\nvi adj[maxn];\nint sz[maxn];\nvi comp;\nbool mark[maxn];\nvoid dfs(int v,int p){\n\tif(bad[v]) return;\n\tif(v == p) comp.clear();\n\tcomp.push_back(v);\n\tsz[v] = 1;\n\tmark[v] = true;\n\tfor(auto u : adj[v]){\n\t\tif(u == p) continue;\n\t\tdfs(u, v);\n\t\tsz[v] += sz[u];\n\t}\n}\nmain(){\n\tIOS;\n\tint n;\n\tcin >> n;\n\tfor(int i=0; i<n-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tint rem = n;\n\tint tim = 0;\n\twhile(rem){\n\t\tmemset(sz, 0, sizeof sz);\n\t\tmemset(mark, 0, sizeof mark);\n\t\ttim++;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(bad[i] || mark[i]) continue;\n\t\t\tdfs(i, i);\n\t\t\tint mn = 1e9, id = -1;\n\t\t\tfor(auto v : comp){\n\t\t\t\tint mx = 0;\n\t\t\t\tfor(auto u : adj[v]){\n\t\t\t\t\tif(bad[u]) continue;\n\t\t\t\t\tint t;\n\t\t\t\t\tif(sz[v] > sz[u]) t = sz[u];\n\t\t\t\t\telse t = sz[i] - 1 - sz[v];\n\t\t\t\t\tmx = max(mx, t);\n\t\t\t\t}\n\t\t\t\tif(mx < mn){\n\t\t\t\t\tmn = mx;\n\t\t\t\t\tid = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbad[id] = true;\n\t\t\trem--;\n\t\t}\n\t}\n\tcout << tim - 2 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\n#define LL long long\n#define Ldouble long double\n#define PI 3.1415926535897932384626\n\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\n#define M 300003\n\nint n, ans;\nvector<int> v[M];\nint lab[M];\n\nvoid dfs(int id, int pv){\n\tint bitcnt[19];\n\tmemset(bitcnt, 0, sizeof(bitcnt));\n\tfor(auto to: v[id]) if(to != pv){\n\t\tdfs(to, id);\n\t\tFI(j, 0, 18) if(lab[to] & (1 << j)) bitcnt[j]++;\n\t}\n\tFD(i, 18, 0) if(bitcnt[i] > 1){\n\t\tFD(j, i, 0) bitcnt[j] = 1;\n\t\tbreak;\n\t}\n\tFI(i, 0, 18) lab[id] += bitcnt[i] * (1 << i);\n\tlab[id]++;\n//\tprintf(\"%d: %d\\n\", id, lab[id]);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFI(i, 2, n){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\twhile(lab[1]){\n\t\tans++;\n\t\tlab[1] >>= 1;\n\t}\n\tprintf(\"%d\\n\", ans - 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "template<bool r>class Range{struct It{int it;explicit constexpr It(int it_):it(it_){}int operator*(){return it;}bool operator!=(It& a){return it!=a.it;}void operator++(){r?--it:++it;}};const It i,n;public:explicit constexpr Range(int i,int n):i(i),n(n){}Range<true> rev(){return Range<true>(n.it-1, i.it-1);};const It&begin(){return i;}const It&end(){return n;}};\ninline Range<false> in(int n) { return Range<false>(0, n);}\ninline Range<false> in(int i, int n) { return Range<false>(i, n);}\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> T num_in() { T x; cin >> x; return x;}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n = num_in<int>();\n    vector<vector<int>> adj(n);\n    for (int _ : in(n - 1)) {\n        int a = num_in<int>() - 1, b = num_in<int>() - 1;\n        adj[a].emplace_back(b);\n        adj[b].emplace_back(a);\n    }\n    const int LOGN = 18;\n    function<int(int, int)> dfs = [&](int cur, int par)-> int {\n        vector<int> count(LOGN);\n        for (int nxt : adj[cur]) {\n            if (nxt == par) continue;\n            int ret = dfs(nxt, cur);\n            for (int i : in(LOGN))\n                if ((ret & (1 << i)) != 0)\n                    count[i] += 1;\n        }\n        int lower = [&]()-> int {\n            for (int i : in(LOGN).rev()) {\n                if (count[i] >= 2) {\n                    for (int j : in(i, LOGN)) \n                        if (count[j] == 0)\n                            return j;\n                }\n            }\n            for (int i : in(LOGN))\n                if (count[i] == 0)\n                    return i;\n            assert(0);\n        }();\n        int res = 1 << lower;\n        for (int i : in(lower + 1, LOGN))\n            if (count[i] == 1)\n                res |= 1 << i;\n        return res;\n    };\n    int val = dfs(0, -1);\n    cout << 32 - __builtin_clz(val) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n#define N 100050\nint head[N],to[N<<1],nxt[N<<1],cnt,n,tmp[22],f[22][N],ans;\ninline void add(int u,int v) {\n\tto[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;\n}\nvoid merge(int *a,int *b) {\n\tint i;\n\tfor(i=0;i<=20;i++) a[i]+=b[i];\n}\nvoid dfs(int x,int y) {\n\tint i;\n\tfor(i=head[x];i;i=nxt[i]) if(to[i]!=y) dfs(to[i],x);\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(i=head[x];i;i=nxt[i]) if(to[i]!=y) merge(tmp,f[to[i]]);\n\tint k=0;\n\tfor(i=20;i>=0;i--) {\n\t\tif(tmp[i]>1) {\n\t\t\tk=i+1; break;\n\t\t}\n\t}\n\tfor(;tmp[k];k++) ;\n\tmemcpy(f[x]+k,tmp+k,sizeof(int)*(20-k));\n\tf[x][k]++;\n\tans=max(ans,k);\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tint i,x,y;\n\tfor(i=1;i<n;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tdfs(1,0); printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nVI G[100011];\nVI X[100011];\n\nint par[100011];\nVI ord;\nint U[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i_, N) {\n\tint v = ord[i_];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    par[*e] = v;\n\t    ord.push_back(*e);\n\t}\n    }\n\n    VI buf; buf.reserve(N+2);\n    \n    REP (i_, N) {\n\tint v = ord[N-1-i_];\n\tint ma = -1;\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    amax(ma, X[*e].back());\n\t}\n\n\tif (ma == -1) {\n\t    U[v] = 0;\n\t    X[v].push_back(0);\n\t} else {\n\t    buf.resize(ma+2);\n\t    fill(buf.begin(), buf.end(), 0);\n\t    EACH (e, G[v]) if (*e != par[v]) {\n\t\tEACH (f, X[*e]) buf[*f] = 1;\n\t    }\n\t    int at_least = 0;\n\t    REP (i, ma+2) if (buf[i] >= 2) at_least = i+1;\n\t    REP (i, ma+2) {\n\t\tif (i < at_least || buf[i]) {\n\t\t    buf[i] = 0;\n\t\t} else {\n\t\t    U[v] = i;\n\t\t    buf[i] = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t    REP (i, ma+2) if (buf[i]) X[v].push_back(i);\n\t}\n    }\n\n    int ma = *max_element(U, U+N);\n    //rprintf(\"%d\", U, U+N);\n    printf(\"%d\\n\", ma);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\n//const ll inf=0x3f3f3f3f3f3f3f3fll;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\n\n// manually set n = number of vertices \n// vertex index from 1 to n\n// first call tree_init();\n// ae(u,v) only one direction\n\nconst int TREE_MAXV=300000+5;\nstruct edge{int v,next;}e[TREE_MAXV*2];int g[TREE_MAXV],etot;\nint qu[TREE_MAXV],pre[TREE_MAXV];\nint n;\nint f[333333];\nvoid ae(int u,int v){\n\te[etot].v=v;\n\te[etot].next=g[u];g[u]=etot++;\n}\nvoid bfs(int rt){\n\tint p=0,q=0;\n\tpre[rt]=0;\n\tqu[q++]=rt;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\t\tpre[e[i].v]=u;\n\t\t\tqu[q++]=e[i].v;\n\t\t}\n\t}\n}\nvoid tree_init(){\n\tstatic bool ini=0;\n\tif(!ini){\n\t\tini=1;\n\t\tmemset(g,-1,sizeof(g));\n\t}else{\n\t\tfor (int i=0;i<=n;i++)g[i]=-1;\n\t}\n\tetot=0;\n}\nvoid readedge(){\n\tfor (int i=1;i<n;i++){\n\t\tint x,y;gn(x);gn(y);\n\t\tae(x,y);ae(y,x);\n\t}\n}\n\n\nvoid work(int u){\n\tint gg=0,tmp=0;\n\tfor (int i=g[u];~i;i=e[i].next)if(e[i].v!=pre[u]){\n\t\tgg|=f[e[i].v]&tmp;\n\t\ttmp|=f[e[i].v];\n\t}\n\tif(gg>0){\n\t\twhile(gg&(gg-1))gg&=gg-1;\n\t\ttmp|=gg|(gg-1);\n\t}\n\tf[u]=tmp+1;\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);\n\ttree_init();\n\treadedge();\n\n\tbfs(1);\n\tfor(int i=n-1;i>=0;i--)work(qu[i]);\n\tint ret=1;\n\twhile(pw(ret)<=f[1])ret++;\n\tprintf(\"%d\\n\",ret-1);\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\n\nconst int N=1e5+9;\n\nunsigned int bit[N];\nint n,f[N],ans;\nint to[N<<1],nxt[N<<1],beg[N],tot;\n\ninline void add(int u,int v)\n{\n\tto[++tot]=v;\n\tnxt[tot]=beg[u];\n\tbeg[u]=tot;\n}\n\ninline void dfs(int u,int fa)\n{\n\tbit[u]=f[u]=0;\n\tint las=0;\n\tfor(int i=beg[u],v;i;i=nxt[i])\n\t\tif((v=to[i])!=fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tlas|=bit[v]&bit[u];\n\t\t\tbit[u]|=bit[v];\n\t\t}\n\tif(bit[u]==0)\n\t\tbit[u]=1;\n\telse\n\t{\n\t\twhile((1<<f[u])<las || bit[u]&(1<<f[u]))f[u]++;\n\t\tbit[u]=(bit[u]>>f[u]<<f[u])|(1<<f[u]);\n\t}\n\tif(ans<f[u])ans=f[u];\n}\n\nint main()\n{\n\tif(fopen(\"vj.in\",\"r\"))\n\t{\n\t\tfreopen(\"vj.in\",\"r\",stdin);\n\t\tfreopen(\"vj.out\",\"w\",stdout);\n\t}\n\n\tn=read();\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tu=read();v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nint N;\nvector <int> edg[100005];\nint h[100005], sz[100005];\nint cntr[100005];\n\nvoid DFS(int nod, int fth)\n{\n    h[nod] = 1 + h[fth];\n    sz[nod] = 1;\n    for(auto nxt: edg[nod])\n        if(nxt != fth && !cntr[nxt])\n        {\n            DFS(nxt, nod);\n            sz[nod] += sz[nxt];\n        }\n}\n\nint getCentroid(int nod, int szmax)\n{\n    for(auto nxt: edg[nod])\n        if(sz[nod] > sz[nxt] && sz[nxt] > szmax)\n            return getCentroid(nxt, szmax);\n    return nod;\n}\n\nint solve(int nod)\n{\n    DFS(nod, 0);\n    if(sz[nod] == 1)    return 0;\n    int root = getCentroid(nod, sz[nod] / 2);\n    cntr[root] = 1;\n\n    int ans = 0;\n    for(auto nxt: edg[root])\n        if(!cntr[nxt])\n        {\n            int hh = solve(nxt);\n            ans = max(ans, hh);\n        }\n    ans++;\n    return ans;\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d\", &N);\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        edg[x].push_back(y);\n        edg[y].push_back(x);\n    }\n\n    int ans = solve(1);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\nconst int maxn=1e5+5;\ninline int read(){\n\tint n=0,f=1;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif (c=='-') c=getchar(),f=-1;\n\tfor(;c>='0'&&c<='9';c=getchar()) n=n*10+c-48;\n\treturn n*f;\n}\nint i,j,n,k[maxn],ne[maxn<<1],g[maxn<<1],num,f[maxn];\nvoid add(int x,int y){\n\tne[++num]=k[x],k[x]=num,g[num]=y; \n}\nvoid dfs(int x,int y){\n\tint i,s=0,now=0;\n\tfor(i=k[x];i;i=ne[i]){\n\t\tint go=g[i];\n\t\tif (go!=y){\n\t\t\tdfs(go,x);\n\t\t\tnow=max(now,(s&f[go]));\n\t\t\ts|=f[go];\n\t\t}\n\t}\n\tif (!now) {\n\t\tfo(i,0,20) if (!(s&(1<<i))) break;\n\t\tf[x]=(1<<i)|((s>>i)<<i); \n\t}else{\n\t\tfo(i,0,20) if (!(s&(1<<i))&&((1<<i)>now)) break;\n\t\tf[x]=(1<<i)|((s>>i)<<i);\n\t} \n}\nint main(){\n\tn=read();\n\tfo(i,1,n-1){\n\t\tint x=read(),y=read();\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1,0);\n\tfd(i,20,0) if (f[1]&(1<<i)) break;\n\tprintf(\"%d\\n\",i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i) \nconst int N = 1e5 + 5, M = N << 1 ;\nusing namespace std ;\n\nint n, e, ter[M], nxt[M], lnk[N], f[N] ;\n\nvoid add(int x, int y) {\n\tter[++ e] = y, nxt[e] = lnk[x], lnk[x] = e ;\n}\n\ninline int count_max(int x) {\n\tint ret = - 1 ;\n\trep(i, 0, 20) if ((x >> i) & 1) ret = i ;\n\treturn ret ;\n}\n\nvoid dfs(int p, int fa) {\n\tint las = 0, must = 0 ;\n\tfor (int i = lnk[p]; i; i = nxt[i]) if (ter[i] != fa) {\n\t\tdfs(ter[i], p) ;\n\t\tmust |= las & f[ter[i]] ;\n\t\tlas |= f[ter[i]] ;\n\t}\n\tint mx = count_max(must) + 1 ;\n\tfor ( ; (1 << mx) & las ; ++ mx) ;\n\tf[p] = (las | (1 << mx)) >> mx << mx ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\tint x, y ;\n\trep(i, 1, n - 1) {\n\t\tscanf(\"%d%d\", &x, &y) ;\n\t\tadd(x, y), add(y, x) ;\n\t}\n\tdfs(1, 0) ;\n\tprintf(\"%d\\n\", count_max(f[1])) ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\n#define LL long long\n#define Ldouble long double\n#define PI 3.1415926535897932384626\n\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\n#define M 300003\n\nint n, ans;\nvector<int> v[M];\nint lab[M];\n\nvoid dfs(int id, int pv){\n\tint bitcnt[19];\n\tmemset(bitcnt, 0, sizeof(bitcnt));\n\tfor(auto to: v[id]) if(to != pv){\n\t\tdfs(to, id);\n\t\tFI(j, 0, 18) if(lab[to] & (1 << j)) bitcnt[j]++;\n\t}\n\tFD(i, 18, 0) if(bitcnt[i] > 1){\n\t\tFD(j, i, 0) bitcnt[j] = 1;\n\t\tbreak;\n\t}\n\tFI(i, 0, 18) lab[id] += bitcnt[i] * (1 << i);\n\tlab[id]++;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFI(i, 2, n){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\twhile(lab[1]){\n\t\tans++;\n\t\tlab[1] >>= 1;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconst int maxSize=4000;\nvector<int> graph[maxSize];\nvector<int> dp(40);\nint amount;\ntemplate<typename Type>\nvoid showContent(Type input)\n{\n\tfor(auto iterator=input.begin(); iterator!=input.end(); ++iterator)\n\t{\n\t\tcout<<(*iterator)<<\", \";\n\t}\n\treturn;\n}\nvoid fillingGraph()\n{\n\tcin>>amount;\n\tint vertex0, vertex1;\n\tfor(int i=1; i<=amount; ++i)\n\t{\n\t\tcin>>vertex0>>vertex1;\n\t\tgraph[vertex0].push_back(vertex1);\n\t\tgraph[vertex1].push_back(vertex0);\n\t}\n\treturn;\n}\nvoid dfs(int first, int parent)\n{\n\t//int value=1;\n\tfor(int second : graph[first])\n\t{\n\t\tif(second==parent)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(second, first);\n\t}\n\tint value=1, numberOfCalls=0;\n\tfor(int last : graph[first])\n\t{\n\t\tif(last!=parent)\n\t\t{\n\t\t\t/*\n\t\t\tcout<<\"first <- \"<<first<<\", value <- \"<<value<<\", last <- \"<<last;\n\t\t\tcout<<\", dp[\"<<last<<\"] <- \"<<dp[last]<<\", dp[\"<<first<<\"] <- \"<<dp[first];\n\t\t\tcout<<\", parent <- \"<<parent<<endl;\n\t\t\t*/\n\t\t\tvalue+=dp[last];\n\t\t\t/*\n\t\t\tcout<<\"final value <- \"<<value<<endl;\n\t\t\t*/\n\t\t\t++numberOfCalls;\n\t\t}\n\t\tif(numberOfCalls>=2)\n\t\t{\n\t\t\t--value;\n\t\t}\n\t}\n\tdp[first]=value;\n\treturn;\n}\nint main()\n{\n\tfillingGraph();\n\tdfs(1, -1);\n\t/*\n\tshowContent(dp);\n\t*/\n\tbitset<40> bitSet(dp[1]);\n\tint maxIndex=0;\n\tfor(int i=0; i<bitSet.size(); ++i)\n\t{\n\t\tif(bitSet[i]>0)\n\t\t{\n\t\t\t//cout<<i<<\", \";\n\t\t\tmaxIndex=i;\n\t\t}\n\t}\n\tcout<<endl<<maxIndex<<endl<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 1e5 + 10;\n\nint N, totv, ans, vis[MAXN],V[MAXN], sz[MAXN], mxsz[MAXN];\nstd::vector<int> G[MAXN];\n\nvoid dfs(int, int);\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, ui, vi; i < N; i++) {\n\t\tscanf(\"%d%d\", &ui, &vi);\n\t\tG[ui].push_back(vi);\n\t\tG[vi].push_back(ui);\n\t}\n\n\tdfs(1, 0);\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\nvoid dfs1(int u, int fa) {\n\tV[totv++] = u, sz[u] = 1, mxsz[u] = 0;\n\tfor (auto v : G[u]) {\n\t\tif (vis[v] || v == fa) continue;\n\t\tdfs1(v, u);\n\t\tsz[u] += sz[v], mxsz[u] = std::max(mxsz[u], sz[v]);\n\t}\n}\n\nint find_cntr(int u) {\n\ttotv = 0;\n\tdfs1(u, -1);\n\tfor (int i = 0; i < totv; i++) {\n\t\tint v = V[i];\n\t\tmxsz[v] = std::max(mxsz[v], sz[u] - sz[v]);\n\t\tif (mxsz[v] * 2 <= sz[u]) return v;\n\t}\n}\n\nvoid dfs(int u, int dep) {\n\tans = std::max(dep, ans);\n\tu = find_cntr(u);\n\tvis[u] = 1;\n\t\n\tfor (auto v : G[u]) {\n\t\tif (vis[v]) continue;\n\t\tdfs(v, dep + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "const long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\nconst long long INFLL = 1e18;\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef complex<double> cd;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define pb push_back\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\nstring Yes[2] = {\"No\\n\", \"Yes\\n\"};\nstring YES[2] = {\"NO\\n\", \"YES\\n\"};\nstring Possible[2] = {\"Impossible\\n\", \"Possible\\n\"};\nstring POSSIBLE[2] = {\"IMPOSSIBLE\\n\", \"POSSIBLE\\n\"};\n\nint ok(int x, int n)\n{\n    return 0 <= x && x < n;\n}\n\nll log10(ll x)\n{\n    if (x < 10) re 1;\n    re 1 + log10(x / 10);\n}\n\nll ds(ll x)\n{\n    if (x < 10) return x;\n    re x % 10 + ds(x / 10);\n}\n\ndouble sqr(double x)\n{\n    return x * x;\n}\n\nbool in(int bit, int mask)\n{\n    return (mask & (1 << bit)) > 0;\n}\n\nvoid Del(vector<int> &v, int pos)\n{\n    swap(v[pos], v[v.size() - 1]);\n    v.pop_back();\n}\n\nlong long g(vector<long long> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nint g(vector<int> &p, int pos)\n{\n    if (ok(pos, p.size())) return p[pos];\n    if (pos < 0 || p.size() == 0) return 0;\n    return p.back();\n}\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nint __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\ninline void __precompute_combinatorics(int __n)\n{\n    if (__precomputed_combinatorics >= __n)\n        return;\n    __fact.resize(__n);\n    __ufact.resize(__n);\n    __rev.resize(__n);\n    __rev[1] = 1;\n    for (int i = max(2, __precomputed_combinatorics); i < __n; i++)\n        __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = max(1, __precomputed_combinatorics); i < __n; i++)\n        __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n    __precomputed_combinatorics = __n;\n}\n\nll fact(int x)\n{\n    if (__precomputed_combinatorics <= x)\n        __precompute_combinatorics(x + 1);\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (k < 0 || k > n)\n        return 0;\n    if (__precomputed_combinatorics <= n)\n        __precompute_combinatorics(n + 1);\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nstruct dsu\n{\n    vector<int> root;\n    vector<int> sz;\n\n    dsu(int _n)\n    {\n        root.resize(_n);\n        iota(all(root), 0);\n        sz.resize(_n, 1);\n    }\n\n    dsu()\n    {\n        dsu(0);\n    }\n\n    void Reset(int _n)\n    {\n        root.resize(_n);\n        sz.resize(_n);\n        for (int i = 0; i < root.size(); i++)\n        {\n            root[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    void Reset()\n    {\n        Reset(root.size());\n    }\n\n    int Root(int x)\n    {\n        if (x == root[x]) return x;\n        return root[x] = Root(root[x]);\n    }\n\n    void Merge(int v, int u)\n    {\n        v = Root(v), u = Root(u);\n        if (v == u) return;\n        if (sz[v] < sz[u])\n        {\n            sz[u] += sz[v];\n            root[v] = u;\n        }\n        else\n        {\n            sz[v] += sz[u];\n            root[u] = v;\n        }\n    }\n};\n\nstruct dsu_cut\n{\n    vector<int> root;\n    vector<int> sz;\n    stack<int> cuts;\n\n    dsu_cut(int _n)\n    {\n        root.resize(_n);\n        iota(all(root), 0);\n        sz.resize(_n, 1);\n    }\n\n    dsu_cut()\n    {\n        dsu_cut(0);\n    }\n\n    void Cut()\n    {\n        if (!cuts.size()) return;\n        int v = cuts.top();\n        sz[root[v]] -= sz[v];\n        root[v] = v;\n        cuts.pop();\n    }\n\n    void Reset(int _n)\n    {\n        root.resize(_n);\n        sz.resize(_n);\n        for (int i = 0; i < root.size(); i++)\n        {\n            root[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    void Reset()\n    {\n        if (cuts.size() < root.size())\n        {\n            while (cuts.size())\n            {\n                Cut();\n            }\n        }\n        else\n        {\n            Reset(root.size());\n        }\n    }\n\n    int Root(int x)\n    {\n        if (x == root[x]) return x;\n        return Root(root[x]);\n    }\n\n    void Merge(int v, int u)\n    {\n        v = Root(v), u = Root(u);\n        if (v == u) return;\n        if (sz[v] < sz[u])\n        {\n            sz[u] += sz[v];\n            root[v] = u;\n            cuts.push(v);\n        }\n        else\n        {\n            sz[v] += sz[u];\n            root[u] = v;\n            cuts.push(u);\n        }\n    }\n};\n\nvoid bfs(int v, vi &dist, vector<vi> &graph)\n{\n    fill(all(dist), -1);\n    dist[v] = 0;\n    vi q = {v};\n    for (int i = 0; i < q.size(); i++)\n    {\n        for (auto u : graph[q[i]])\n        {\n            if (dist[u] == -1)\n            {\n                dist[u] = dist[q[i]] + 1;\n                q.push_back(u);\n            }\n        }\n    }\n}\n\nvector<int> z_func(string &s)\n{\n    // Calculates z-function of string s\n    // z[0] = s.size(), s should not be empty\n    //\n    // Tested on the following problem:\n    // https://codeforces.com/edu/course/2/lesson/3/3/practice/contest/272263/problem/A\n    //\n    vector<int> z(s.size());\n    z[0] = s.size();\n    int L = 0, R = 0;\n    for (int i = 1; i < s.size(); i++)\n    {\n        z[i] = max(0, min(z[i - L], R - i));\n        while (i + z[i] < s.size() && s[i + z[i]] == s[z[i]]) z[i]++;\n        if (i + z[i] > R)\n        {\n            R = i + z[i];\n            L = i;\n        }\n    }\n    return z;\n}\n\nvector<int> p_func(string &s)\n{\n    // Calculates prefix function of string s\n    //\n    //\n    vector<int> p(s.size());\n    for (int i = 1; i < s.size(); i++)\n    {\n        int j = p[i - 1];\n        while (j > 0 && s[i] != s[j])\n            j = p[j - 1];\n        if (s[i] == s[j])\n            j++;\n        p[i] = j;\n    }\n    return p;\n}\n\nvector<int> d1_func(string &s)\n{\n    // Calculates max length of palindrome centered in positions and i for each i\n    //\n    //\n    vector<int> d1(s.size());\n    int L = 0, R = -1;\n    for (int i = 0; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d1[R - i + L]);\n        while (i + k < s.size() && i - k >= 0 && s[i - k] == s[i + k])\n            k++;\n        d1[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k;\n            R = i + k;\n        }\n    }\n    return d1;\n}\n\nvector<int> d2_func(string &s)\n{\n    // Calculates max length of palindrome centered in positions i - 1 and i for each i\n    //\n    //\n    vector<int> d2(s.size());\n    int L = 0, R = -1;\n    for (int i = 1; i < s.size(); i++)\n    {\n        int k = 0;\n        if (i <= R) k = min(R - i + 1, d2[R - i + L + 1]);\n        while (i + k < s.size() && i - k - 1 >= 0 && s[i - k - 1] == s[i + k])\n            k++;\n        d2[i] = k--;\n        if (i + k > R)\n        {\n            L = i - k - 1;\n            R = i + k;\n        }\n    }\n    return d2;\n}\n\nvoid add(int pos, ll x, vector<ll> &fenw)\n{\n    // Performs add query on Fenwick tree\n    //\n    // Tested on the following problem:\n    // https://atcoder.jp/contests/practice2/tasks/practice2_b\n    //\n    while (pos < fenw.size())\n    {\n        fenw[pos] += x;\n        pos |= (pos + 1);\n    }\n}\n\nll get(int pos, vector<ll> &fenw)\n{\n    // Performs get query on Fenwick tree\n    //\n    // Tested on the following problem:\n    // https://atcoder.jp/contests/practice2/tasks/practice2_b\n    //\n    ll res = 0;\n    while (pos >= 0)\n    {\n        res += fenw[pos];\n        pos = (pos & (pos + 1)) - 1;\n    }\n    return res;\n}\n\nstruct dcp_offine{\n    // Given n, m and arrays v, u, t of length m\n    // -1 <= t[i] <= 1 and 0 <= v[i], u[i] < n satisfied for t[i] != -1\n    // t[i] = 0 asks to change state of edge (v[i], u[i])\n    // t[i] = -1 asks to calculate number of connected components\n    // t[i] = 1 asks to check if v[i] and u[i] are in the same connected component\n    // After creating following holds:\n    // ans[i] contains -1 for t[i] = 0 and answer for the i-th query otherwise\n    //\n    // Correctness t[i] <= 0 tested on the following problem:\n    // https://codeforces.com/edu/course/2/lesson/7/3/practice/contest/289392/problem/C\n    // Correctness tested on random tests with m = 40000\n    // Speed tested on random tests with m = 2e6, average = 0.955ms/test (local)\n    //\n    int n, m;\n    dsu_cut dcp;\n    vector<int> ans;\n    void solve(int l, int r, vi &v, vi &u, vi &t, vi &L, vi &R)\n    {\n        if (l >= r) return;\n        if (l + 1 == r)\n        {\n            if (t[l] == -1)\n            {\n                ans[l] = n - dcp.cuts.size();\n            }\n            if (t[l] == 1)\n            {\n                ans[l] = dcp.Root(v[l]) == dcp.Root(u[l]);\n            }\n            return;\n        }\n        int m = (l + r) / 2;\n        int ss = dcp.cuts.size();\n        for (int i = l; i < m; i++)\n        {\n            if (R[i] >= r) dcp.Merge(v[i], u[i]);\n        }\n        solve(m, r, v, u, t, L, R);\n        while (dcp.cuts.size() > ss) dcp.Cut();\n        for (int i = r - 1; i >= m; i--)\n        {\n            if (L[i] < l) dcp.Merge(v[i], u[i]);\n        }\n        solve(l, m, v, u, t, L, R);\n        while (dcp.cuts.size() > ss) dcp.Cut();\n    }\n    dcp_offine(int _n, int _m, vi v, vi u, vi t)\n    {\n        n = _n, m = _m;\n        dcp.Reset(n);\n        ans.resize(m, -1);\n        map<pair<int, int>, int> mm;\n        vi L(m, INF), R(m, -INF);\n        for (int i = 0; i < m; i++)\n        {\n            if (t[i] != 0) continue;\n            if (v[i] > u[i]) swap(v[i], u[i]);\n            if (mm.find({v[i], u[i]}) == mm.end())\n            {\n                mm[{v[i], u[i]}] = i;\n            }\n            else\n            {\n                int t = mm[{v[i], u[i]}];\n                R[t] = i;\n                L[i] = t;\n                mm.erase({v[i], u[i]});\n            }\n        }\n        while (mm.size())\n        {\n            t.push_back(0);\n            ans.push_back(-1);\n            L.push_back(INF);\n            R.push_back(-INF);\n            auto it = mm.begin();\n            pair<int, int> s = (*it).first;\n            int t = (*it).second;\n            R[t] = m;\n            L[m] = t;\n            v.push_back(s.first);\n            u.push_back(s.second);\n            mm.erase(mm.begin());\n            m++;\n        }\n        solve(0, m, v, u, t, L, R);\n    }\n};\n\ntemplate<class T> struct sparse_min{\n    // Returns min on segment [l, r] of predefined array a\n    //\n    // Correctness tested on the following problem:\n    // https://codeforces.com/contest/1304/problem/E\n    // Speed tested on random tests with n = 4e6, q = 4e6, T = int, average = 0.508ms/test (local)\n    // Speed tested on random tests with n = 4e6, q = 4e7, T = int, average = 1.778ms/test (local)\n    //\n    vector<vector<T> > sp;\n    vector<int> H;\n    T get(int l, int r)\n    {\n        int h = H[r - l + 1];\n        return min(sp[h][l], sp[h][r - (1 << h) + 1]);\n    }\n    sparse_min(vector<T> a)\n    {\n        int n = a.size();\n        H = vector<int>(n + 1);\n        for (int i = 3; i < n + 1; i++)\n        {\n            H[i] = H[i - 1] + (((i - 1) & (i - 2)) == 0);\n        }\n        int s = 0;\n        while ((1 << s) < n) s++;\n        sp = vector<vector<T>>(s, vector<T>(n));\n        for (int i = 0; i < n; i++)\n        {\n            sp[0][i] = a[i];\n        }\n        for (int j = 1; j < s; j++)\n        {\n            for (int i = 0; i + (1 << j) - 1 < n; i++)\n            {\n                sp[j][i] = get(i, i + (1 << j) - 1);\n            }\n        }\n    }\n};\n\ntemplate<class T> struct sparse_max{\n    // Returns min on segment [l, r] of predefined array a\n    //\n    // Correctness tested on the following problem:\n    // https://codeforces.com/contest/1304/problem/E\n    // Speed tested on random tests with n = 4e6, q = 4e6, T = int, average = 0.508ms/test (local)\n    // Speed tested on random tests with n = 4e6, q = 4e7, T = int, average = 1.778ms/test (local)\n    //\n    vector<vector<T> > sp;\n    vector<int> H;\n    T get(int l, int r)\n    {\n        int h = H[r - l + 1];\n        return max(sp[h][l], sp[h][r - (1 << h) + 1]);\n    }\n    sparse_max(vector<T> a)\n    {\n        int n = a.size();\n        H = vector<int>(n + 1);\n        for (int i = 3; i < n + 1; i++)\n        {\n            H[i] = H[i - 1] + (((i - 1) & (i - 2)) == 0);\n        }\n        int s = 0;\n        while ((1 << s) < n) s++;\n        sp = vector<vector<T>>(s, vector<T>(n));\n        for (int i = 0; i < n; i++)\n        {\n            sp[0][i] = a[i];\n        }\n        for (int j = 1; j < s; j++)\n        {\n            for (int i = 0; i + (1 << j) - 1 < n; i++)\n            {\n                sp[j][i] = get(i, i + (1 << j) - 1);\n            }\n        }\n    }\n};\n\nstruct scc_graph{\n    // Find Strongly Connected Components of given graph\n    //\n    // Correctness tested on the following problem:\n    // https://atcoder.jp/contests/arc069/tasks/arc069_d\n    //\n    int n;\n    vector<vector<int> > graph;\n    vector<vector<int> > inv_graph;\n    vector<int> fr, to;\n    vector<int> fn;\n    vector<int> vis;\n    vector<int> component;\n    int col;\n    void inv_dfs(int v)\n    {\n        vis[v] = 1;\n        for (auto id : inv_graph[v])\n        {\n            int u = fr[id];\n            if (!vis[u])\n            {\n                inv_dfs(u);\n            }\n        }\n        fn.push_back(v);\n    }\n    void dfs(int v)\n    {\n        component[v] = col;\n        for (auto id : graph[v])\n        {\n            int u = to[id];\n            if (component[u] == -1)\n            {\n                dfs(u);\n            }\n        }\n    }\n    scc_graph(int _n)\n    {\n        n = _n;\n        graph = vector<vector<int> >(n);\n        inv_graph = vector<vector<int> >(n);\n    }\n    void add_edge(int v, int u)\n    {\n        graph[v].push_back(fr.size());\n        inv_graph[u].push_back(fr.size());\n        fr.push_back(v);\n        to.push_back(u);\n    }\n    vector<vector<int> > scc()\n    {\n        vis = vector<int>(n);\n        component = vector<int>(n, -1);\n        fn = {};\n        col = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (!vis[i])\n            {\n                inv_dfs(i);\n            }\n        }\n        reverse(fn.begin(), fn.end());\n        for (auto i : fn)\n        {\n            if (component[i] == -1)\n            {\n                dfs(i);\n                col++;\n            }\n        }\n        vector<vector<int> > res(col);\n        for (int i = 0; i < n; i++)\n        {\n            res[component[i]].push_back(i);\n        }\n        return res;\n    }\n};\n\nint ans;\n\nvector<int> solve(int v, int p, vvi &graph)\n{\n    vector<int> cnt(20);\n    for (auto u : graph[v]) if (u != p)\n    {\n        vector<int> z = solve(u, v, graph);\n        for (int j = 0; j < 20; j++) cnt[j] += z[j];\n    }\n    int sel = -1;\n    for (int j = 0; j < 20; j++)\n    {\n        if (cnt[j] >= 2)\n        {\n            sel = j;\n        }\n    }\n    for (int j = sel + 1; j < 20; j++)\n    {\n        if (cnt[j] == 0)\n        {\n            sel = j;\n            break;\n        }\n    }\n    cnt[sel]++;\n    for (int j = 0; j < sel; j++)\n    {\n        cnt[j] = 0;\n    }\n    ans = max(ans, sel);\n    return cnt;\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    vvi graph(n);\n    forn(i, n - 1)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    solve(0, 0, graph);\n    cout << ans;\n}\n\n/* Note:\nCheck constants at the beginning of the code (MOD, INF, INFLL)\nCheck corner cases.\n    N = 1\nNo def int long long for now.\nAdd something here.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=100005;\n\nint N;\nvector<int> adj[MAXN];\nint val[MAXN],ans;\n\nvoid dfs(int u,int fa=0)\n{\n\tint mk=0;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tdfs(v,u);\n\t\tmk|=(val[u]&val[v]);\n\t\tval[u]|=val[v];\n\t}\n\tif(val[u]==0)\n\t\tval[u]=1;\n\telse\n\t{\n\t\tint id=0;\n\t\twhile((1<<id)<mk||(val[u]&(1<<id)))\n\t\t\tid++;\n\t\tval[u]=((val[u]>>id)<<id)|(1<<id);\n\t\tans=max(ans,id);\n\t}\n\t//printf(\"val[%d]=%d\\n\",u,val[u]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tdfs(1);\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=100000+19;\nconst int oo=(1<<30)-1;\n\nstruct Edge{\n\tint y,nxt;\n} E[N*2];\nint las[N],vis[N],fa[N],pre[N],suf[N],A[N],chk[N],g[N],h[N],f[N];\nint n,cnt,mx,w,ans;\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid dfs(int x,int d){\n\tif (d>mx) mx=d,w=x;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]&&y!=fa[x]){\n\t\t\tfa[y]=x;\n\t\t\tdfs(y,d+1);\n\t\t}\n}\nvoid calc(int x,int fa){\n\tint m1=0,m2=0;\n\tg[x]=h[x]=f[x]=0;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]&&!chk[y]&&y!=fa){\n\t\t\tcalc(y,x);\n\t\t\tg[x]=max(g[x],g[y]);\n\t\t\tif (h[y]>m1) m2=m1,m1=h[y];lf (h[y]>m2) m2=h[y];\n\t\t}\n\th[x]=m1+1;\n\tf[x]=g[x];\n\tg[x]=max(g[x],m1+m2+1);\n}\nvoid solve(int x,int dep){\n\tans=max(ans,dep);\n\tmx=-1;fa[x]=0;\n\tdfs(x,0);\n\tint u=w;\n\tmx=-1;fa[w]=0;\n\tdfs(w,0);\n\t*A=0;\n\tfor (int i=w;i!=u;i=fa[i]) A[++*A]=i;\n\tA[++*A]=u;\n\tFor(i,1,*A+1) chk[A[i]]=1;\n\tFor(i,1,*A+1) calc(A[i],-1);\n\tint tmp=0;\n\tpre[0]=suf[*A+1]=0;\n\tfor (int i=1;i<=*A;i++){\n\t\tpre[i]=max(max(pre[i-1],h[A[i]]+tmp),g[A[i]]);\n\t\ttmp=max(tmp+1,h[A[i]]);\n\t}\n\ttmp=0;\n\tfor (int i=*A;i>=1;i--){\n\t\tsuf[i]=max(max(suf[i+1],h[A[i]]+tmp),g[A[i]]);\n\t\ttmp=max(tmp+1,h[A[i]]);\n\t}\n\tint mn=oo;\n\tFor(i,1,*A+1){\n\t\ttmp=max(max(pre[i-1],suf[i+1]),f[A[i]]);\n\t\tif (tmp<mn) mn=tmp,x=A[i];\n\t\tchk[A[i]]=0;\n\t}\n\tvis[x]=1;\n\tfor (int i=las[x],y;~i;i=E[i].nxt)\n\t\tif (!vis[y=E[i].y]){\n\t\t\tsolve(y,dep+1);\n\t\t}\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n) Link(IN(),IN());\n\tsolve(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=100000+10;\nint h[maxn],go[maxn*2],nxt[maxn*2],bit[maxn],f[maxn];\nint i,j,k,l,t,n,m,tot,top,ans;\nvoid add(int x,int y){\n\tgo[++tot]=y;\n\tnxt[tot]=h[x];\n\th[x]=tot;\n}\nvoid dfs(int x,int y){\n\tbit[x]=f[x]=0;\n\tint t=h[x],l=0;\n\twhile (t){\n\t\tif (go[t]!=y){\n\t\t\tdfs(go[t],x);\n\t\t\tl|=(bit[x]&bit[go[t]]);\n\t\t\tbit[x]|=bit[go[t]];\n\t\t}\n\t\tt=nxt[t];\n\t}\n\tif (!bit[x]) bit[x]=1;\n\telse{\n\t\twhile ((1<<f[x])<l||(1<<f[x])&bit[x]) f[x]++;\n\t\tbit[x]=(bit[x]>>f[x]<<f[x])|(1<<f[x]);\n\t}\n\tans=max(ans,f[x]);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1){\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tadd(j,k);add(k,j);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define N 100010\nusing namespace std;\nint n,tote,to[N<<1],nxt[N<<1],con[N],w[N],ans;\nvoid ins(int x,int y)\n{\n\tto[++tote]=y;\n\tnxt[tote]=con[x];\n\tcon[x]=tote;\n}\nvoid dfs(int v,int fa)\n{\n\tint dep=-1;\n\tbool flag=0;\n\tfor(int p=con[v];p;p=nxt[p])\n\t\tif(to[p]!=fa)\n\t\t{\n\t\t\tdfs(to[p],v);\n\t\t\tint tmp=w[v]&w[to[p]];\n\t\t\tfor(int i=30;i>=0;i--)\n\t\t\t\tif((tmp>>i)&1) {dep=max(dep,i);break;}\n\t\t\tw[v]=w[v]|w[to[p]];\n\t\t\tflag=1;\n\t\t}\t\n\tif(!flag) {w[v]=1;return ;}\t\n\tfor(int i=dep+1;i<=30;i++)\n\t\tif((w[v]>>i)&1) \n\t\t\tdep=max(dep,i);\n\t\telse break;\n\tans=max(ans,dep+1);\n\tint R=(1<<(dep+1)),T=((1<<30)-1)^(R-1);\n\tw[v]=(w[v]&T)|R;\t\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tins(x,y);ins(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define REP(x, l, u) for(ll x = l;x<u;x++)\n#define RREP(x, l, u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(begin(a),end(a)),end(a))\n#define mst(x, a) memset(x,a,sizeof(x))\n#define all(a) begin(a),end(a)\n#define rall(a) rbegin(a),rend(a)\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define lowbit(x) ((x)&(-(x)))\n#define bitcnt(x) (__builtin_popcountll(x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace __gnu_pbds; //required\nusing namespace std;\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst ll mod = 1e9 + 7;\n\n\nstring to_string (string s) { return '\"' + s + '\"'; }\n\nstring to_string (const char *s) { return to_string ((string) s); }\n\nstring to_string (bool b) { return (b ? \"true\" : \"false\"); }\n\ntemplate<typename A, typename B>\nstring to_string (pair<A, B> p) { return \"(\" + to_string (p.first) + \", \" + to_string (p.second) + \")\"; }\n\ntemplate<typename A>\nstring to_string (A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) { res += \", \"; }\n        first = false;\n        res += to_string (x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out () { cerr<<endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out (Head H, Tail... T) {\n    cerr<<\" \"<<to_string (H);\n    debug_out (T...);\n}\n\n#ifdef LOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T, typename S>\ninline bool upmin (T &a, const S &b) { return a > b ? a = b, 1 : 0; }\n\ntemplate<typename T, typename S>\ninline bool upmax (T &a, const S &b) { return a < b ? a = b, 1 : 0; }\n\n\null twop (ll x) { return 1ULL<<x; }\n\nll MOD (ll a, ll m) {\n    a %= m;\n    if (a < 0)a += m;\n    return a;\n}\n\nll inverse (ll a, ll m) {\n    a = MOD (a, m);\n    if (a <= 1)return a;\n    return MOD ((1 - inverse (m, a) * m) / a, m);\n}\n\ntemplate<typename T>\nT sqr (T x) { return x * x; }\n\nll gcd (ll a, ll b) {\n    a = abs (a), b = abs (b);\n    while (b != 0) {\n        a %= b;\n        swap (a, b);\n    }\n    return a;\n}\n\nll fast (ll a, ll b) {\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans *= a;\n        a *= a;\n        b /= 2;\n    }\n    return ans;\n}\n\nll fast (ll a, ll b, ll mod) {\n    if (b < 0)a = inverse (a, mod), b = -b;\n    ll ans = 1;\n    while (b) {\n        if (b & 1)ans = ans * a % mod;\n        a = a * a % mod;\n        b /= 2;\n    }\n    return ans % mod;\n}\n\n\nnamespace SOLVE {\n    VLL adj[100100];\n    ll dp[101000];\n    ll n;\n    \n    void dfs (int cur, int fa) {\n        ll forbid[20] = {0};\n        for (auto s:adj[cur]) {\n            if (s != fa) {\n                dfs (s, cur);\n                REP(j, 0, 20)if (twop (j) & dp[s])\n                        forbid[j]++;\n            }\n        }\n        int mx = -1;\n        \n        REP(i, 0, 20) {\n            if (forbid[i] >= 2)mx = i;\n        }\n        mx++;\n        while (forbid[mx])mx++;\n        forbid[mx] = 1;\n        REP(j, mx, 20) {\n            if (forbid[j])dp[cur] |= twop (j);\n        }\n    }\n    \n    void main () {\n        cin>>n;\n        REP(i, 1, n) {\n            int u, v;\n            cin>>u>>v;\n            adj[u].PB (v);\n            adj[v].PB (u);\n        }\n        dfs (1, 0);\n        int ans = 0;\n        REP(i, 0, 20) {\n            if (twop (i) & dp[1])ans = i;\n        }\n        cout<<ans;\n    }\n}\n\n\nsigned main () {\n#ifdef LOCAL\n    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    int t = 1;\n//    cin >> t;\n    for (int i = 1; i <= t; i++) {\n//        cout<<\"Case #\"<<i<<\": \";\n        SOLVE::main ();\n        \n    }\n\n\n\n\n\n\n\n\n//    clock_t st = clock();\n//    while(clock() - st < 3.0 * CLOCKS_PER_SEC){\n//\n//    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nconst int MAXN = 100 * 1000 + 23, MXLN = 17 + 3;\n\n\n\n\n\n\n\n\n\n\n\nint n, mx, dp[MAXN], cnt[MAXN][MXLN];\nvector<int> g[MAXN];\n\n\nvoid dfs(int v = 0, int p = -1) {\n\tfor (auto u : g[v]) if (u != p) {\n\t\tdfs(u, v);\n\t\tdp[v] |= dp[u];\n\t\tfor (int i = 0; i < MXLN; i++) cnt[v][i] += ((dp[u] >> i) & 1);\n\t}\n//\t/*\n\tint b = 0, f = 1;\n\tfor (int i = 0; i < MXLN; i++) {\n\t\tif (cnt[v][i] > 1) {\n\t\t\tb = i + 1;\n\t\t\tf = 1;\n\t\t} else {\n\t\t\tif (cnt[v][i]) b += f;\n\t\t\telse f = 0;\n\t\t}\n\t}\n//\t*/\n//\tfor (int i = 0; i < MXLN; i++) if (cnt[v][i] > 1) b = i;\n\tdp[v] &= (((1 << MXLN) - 1) ^ ((1 << b) - 1));\n\tdp[v] |= (1 << b);\n\tmx = max(mx, b);\n}\n\n\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[--u].push_back(--v), g[v].push_back(u);\n\t}\n\tdfs();\n\tcout << mx;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n\nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nint n;\nvector<int> adj[100005];\n\n\nint dp(int v, int par){\n\tint mask = 0;\n\tfor(auto vv : adj[v])\n\t\tif(vv != par)\n\t\t\tmask |= dp(vv, v);\n\n\tint assigned = -1;\n\tfor(int i=0;i<30;i++)\n\t\tif((mask & (1<<i)) == 0){\n\t\t\tassigned = i;\n\t\t\tbreak;\n\t\t}\n\n\tfor(int i=0;i<assigned;i++)\n\t\tif((mask >> i) & 1)\n\t\t\tmask ^= (1<<i);\n\tmask |= (1<<assigned);\n// cout<<\"dp \"<<v<<\" \"<<par<<\" returns \"<<mask<<endl;\n\treturn mask;\n}\n\n\nint main(){\n \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin>>n;\n    int e = n-1;\n    while(e--){\n    \tint a, b;\n    \tcin>>a>>b;\n    \tadj[a].pb(b);\n    \tadj[b].pb(a);\n    }\n\n    int ans = dp(1, -1);\n    for(int i=30;i>=0;i--)\n    \tif((ans >> i) & 1){\n    \t\tcout<<i;\n    \t\treturn 0;\n    \t}\n\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//In the name of Allah\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define PB push_back\n#define MP make_pair\n#define int long long \n\nconst int N=1e5+200;\nconst int NN=20+3;\n\nvector<int> a[N];\nvector<int> b[N];\nint h[N],dp[N];\nint maxi=1; \n\nvoid dfs(int v,int par=-1){\n\tfor(int i=0,u;i<a[v].size();i++){\n\t\tu=a[v][i];\n\t\tif(u!=par){\n\t\t\th[u]=h[v]+1;\n\t\t\tdfs(u,v);\n\t\t\tdp[v]=max(dp[v],dp[u]+1);\n\t\t\tb[v].PB(dp[u]);\n\t\t}\n\t}\n\tmaxi=max(maxi,dp[v]);\n\tsort(b[v].begin(),b[v].end(),greater<int> () );\n\tif(b[v].size()>1){\n\t\tmaxi=max(maxi,b[v][0]+b[v][1]+2);\n\t}\n}\nint32_t main(){\n    ios::sync_with_stdio(0);cin.tie(0);\n \tint n; \n\tcin>>n; \n\tfor(int i=0,u,v;i<n-1;i++){\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\ta[u].PB(v);\n\t\ta[v].PB(u);\n\t}\n\tdfs(0);\n\tint tmp=maxi/2;\n\tif(maxi%2==1)tmp++;\n\tint ans=(tmp-1)/2;\n\tif(tmp%2==0)ans++;\n\tans++;\n\tcout<<ans<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\ntemplate< typename T >\nstruct edge{\n    int from, to;\n    T cost;\n    edge(int to,T cost) : from(-1), to(to), cost(cost){}\n    edge(int from,int to,T cost) : from(from), to(to), cost(cost){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const{ return to;}\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedTree = vector< Edges<T>>;\nusing tree = vector< vector<int> >;\n\ntree make(int n,int offset = 1){\n    tree res(n);\n    for(int i = 0;i < n-1; i++){\n        int a,b; cin >> a >> b;\n        a -= offset,b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate< typename T >\nWeightedTree<T> make2(int n, int offset = 1){\n    WeightedTree<T> res(n);\n    for(int i = 0;i < n-1 ; i++){\n        int a,b ; cin >> a >> b;\n        a -= offset, b -= offset;\n        T c; cin >> c;\n        res[a].emplace_back(b,c);\n        res[b].emplace_back(a,c);\n    }\n    return res;\n}\n\nvector<int> Centers(tree &g,int idx = 0){\n    vector<int> res;\n    int max_depth = -1, leaf;\n    auto dfs = [&](auto &&self,int x,int p,int d)->bool{\n        bool flag = false;\n        if(max_depth < d){\n            max_depth = d, leaf = x, flag = true;\n            res.clear();\n        }\n        for(auto e:g[x]){\n            if(e != p)\n            flag |= self(self,e,x,d+1);\n        }\n        if(flag and d == (max_depth>>1) or d == ((max_depth+1)>>1)) res.emplace_back(x);\n        return false;\n    };\n    dfs(dfs,idx,-1,0);\n    max_depth = -1;\n    dfs(dfs,leaf,-1,0);\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    INT(n);\n    auto g = make(n);\n    rep(i,n)sort(all(g[i]));\n    auto solve = [&](auto &&self,int x) -> int{\n        if(g[x].size() == 0) return 0;\n        auto centers = Centers(g,x);\n        int res = 0;\n        if(centers.size() == 1){\n            int center = centers.back();\n            for(auto e:g[center]){\n                auto it = lower_bound(all(g[e]),center);\n                g[e].erase(it);\n                chmax(res,self(self,e));\n            }\n            return res + 1;\n        }\n        else{\n            int a = centers[0],b = centers[1];\n            auto it = lower_bound(all(g[a]),b);\n            g[a].erase(it);\n            it = lower_bound(all(g[b]),a);\n            g[b].erase(it);\n            return max(self(self,a),self(self,b)) + 1;\n        }\n    };\n    cout << solve(solve,0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>  \n#include<cstdio>  \n#include<cstring>  \n#include<cmath>  \nusing namespace std;  \nconst int N=100000+5;  \nstruct Edge{int to,next;}e[N<<1];  \nint head[N],cnt;  \nvoid ins(int u,int v){  \n    e[++cnt]=(Edge){v,head[u]};head[u]=cnt;  \n}  \nint f[N],bin[30],s[N],m,c[30];  \nvoid dp(int u,int fa){  \n     int sv=0,cu=0,son=0;  \n     for(int i=head[u];i;i=e[i].next){  \n        int v=e[i].to;if(v==fa)continue;  \n        dp(v,u);  \n        sv|=s[v];  \n        son++;  \n     }  \n     if(!son){  \n        f[u]=0;  \n        s[u]=1;  \n        return;  \n     }  \n     memset(c,0,sizeof(c));  \n     for(int i=head[u];i;i=e[i].next)  \n     if(e[i].to!=fa)  \n     for(int j=0;j<m;j++)  \n     if(s[e[i].to]&(1<<j))c[j]++;  \n     if(son>1)  \n     for(int i=m-1;i>=0;i--)  \n     if(c[i]>=2){  \n        cu=i+1;  \n        break;  \n     }  \n     for(int i=cu;i<m;i++)  \n     if(!(sv&(1<<i))){  \n        cu=i;  \n        break;  \n     }  \n     s[u]=((sv>>cu)|1)<<cu;  \n     f[u]=cu;  \n     for(int i=head[u];i;i=e[i].next)  \n     if(e[i].to!=fa)  \n     f[u]=max(f[u],f[e[i].to]);  \n}  \nint main(){  \n    //freopen(\"a.in\",\"r\",stdin);  \n    //freopen(\"a.out\",\"w\",stdout);   \n    int n;scanf(\"%d\",&n);m=log2(n)+1;  \n    for(int i=1;i<n;i++){  \n         int u,v;scanf(\"%d%d\",&u,&v);  \n         ins(u,v);ins(v,u);  \n    }  \n    dp(1,0);  \n    printf(\"%d\\n\",f[1]);  \n    return 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,f[100005];\nvector<int> v[100005];\nint get(int x){\n    for(int i=18;i>=0;--i)if(x&(1<<i)) return i;\n    return -1;\n}\nvoid solve(int x,int y){\n    int o=-1;\n    for(int i=0;i<v[x].size();++i){\n        if(v[x][i]==y) continue;\n        solve(v[x][i],x);\n        o=max(o,get(f[x]&f[v[x][i]]));\n        f[x]|=f[v[x][i]];\n    }\n    for(int i=0;i<=18;++i){\n        if(i<=o||(f[x]&(1<<i)))f[x]=(f[x]|(1<<i))^(1<<i);\n        else f[x]|=(1<<i),i=19;\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;++i){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        v[x].pb(y),v[y].pb(x);\n    }\n    solve(1,0);\n    printf(\"%d\\n\",get(f[1]));\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nint get_size(int root, vector<vector<int> > const & tree, vector<bool> const & used) {\n    function<int (int, int)> dfs = [&](int i, int parent) {\n        int size = 1;\n        for (int j : tree[i]) if (j != parent and not used[j]) {\n            size += dfs(j, i);\n        }\n        return size;\n    };\n    return dfs(root, -1);\n}\nint get_centroid(int root, vector<vector<int> > const & tree, vector<bool> const & used) {\n    int n = get_size(root, tree, used);\n    int centroid = -1;\n    int centroid_weight = INT_MAX;\n    function<int (int, int)> dfs = [&](int i, int parent) {\n        int acc_weight = 0;\n        int max_weight = -1;\n        for (int j : tree[i]) if (j != parent and not used[j]) {\n            int weight = dfs(j, i);\n            acc_weight += weight;\n            setmax(max_weight, weight);\n        }\n        setmax(max_weight, n - (1 + acc_weight));\n        if (max_weight < centroid_weight) {\n            centroid_weight = max_weight;\n            centroid = i;\n        }\n        return 1 + acc_weight;\n    };\n    dfs(root, -1);\n    return centroid;\n}\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n - 1) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    vector<bool> used(n);\n    function<int (int)> go = [&](int i) {\n        i = get_centroid(i, g, used);\n        used[i] = true;\n        int k = 0;\n        for (int j : g[i]) if (not used[j]) {\n            setmax(k, go(j) + 1);\n        }\n        return k;\n    };\n    int k = go(0);\n    // output\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 101234;\nint mx = 0;\nint dp[MN], col[MN];\nvector <int> adj[MN];\n\nint LogDo(int x) {\n\tint ans = -1;\n\tfor (int i = 0; i < 30; i++)\n\t\tif (x >> i & 1)\n\t\t\tans = i;\n\treturn ans;\n}\n\nvoid dfs(int v = 0, int p = 0) {\n\tint ans = 0, pre = 0;\n\tfor (int u: adj[v]) {\n\t\tif (u == p) \n\t\t\tcontinue;\n\t\tdfs(u, v);\n\t\tint msk = (dp[u] >> col[u] | 1) << col[u];\n\t\tans = max(ans, LogDo(msk & dp[v] & -1) + 1);\n\t\tdp[v] |= msk;\n\t\twhile (dp[v] >> ans & 1)\n\t\t\tans++;\n\t}\n\tcol[v] = ans;\n\tmx = max(mx, ans);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tadj[v].push_back(u);\n\t\tadj[u].push_back(v);\n\t}\n\tdfs();\n//\tfor (int i = 0; i < n; i++)\n//\t\tcerr << dp[i] << '&' << col[i] << endl;\n\tcout << mx;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  Int first=1;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      first=0;\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#define pb push_back\n#define mp make_pair\n#define INF 9999999\n#define LINF 9999999999999999\n#define SINF \"%\"\n#define uint unsigned int\n#define msn(a,v) memset(a,v,sizeof(a))\n#define ms(a) msn(a,0)\n#define NONE -1\n#define ll long long\n#define ull unsigned ll\n#define uchar unsigned char\n#define sint short int\n#define usint unsigned sint\n#define xsize(a) sizeof(a)/1024/1024\n#define fr(aaaaa,bbbbb) for(aaaaa = 1;aaaaa <= bbbbb;aaaaa++)\n#define frr(aaaaa,bbbbb,ccccc) for(aaaaa = ccccc;aaaaa <= bbbbb;aaaaa++)\nusing namespace std;\n#define MAXN 100100\n\nint du[MAXN];\nint n;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tdu[a]++; du[b]++;\n\t}\n\t\n\tint ans = 0;\n\tfor(int i=  1;i <= n;i++)\n\t\tif(du[i] > 1)\n\t\t\tans++;\n\tcout << ans+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){c=Getchar();rev|=c=='-';if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------------------------head--------------------------------------------------\n\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,m,dp[N];\nvi g[N];\nbool vis[N];\n\nvoid dfs(int x){\n\tint cnt[20];clr(cnt,0);\n\tvis[x]=1;\n\tfor(int y:g[x]){\n\t\tif(vis[y]) continue;\n\t\tdfs(y);\n\t\tfor(int i=0;i<m;i++)\n\t\t\tif(dp[y]&(1<<i)) cnt[i]++;\n\t}\n\tint mx=-1;\n\tfor(int i=0;i<m;i++)\n\t\tif(cnt[i]>=2) mx=i;\n\tfor(int i=0;i<m;i++)\n\t\tif(!cnt[i]&&i>mx){\n\t\t\tfor(int j=0;j<i;j++) cnt[j]=0;\n\t\t\tcnt[i]=1;\n\t\t\tbreak;\n\t\t}\n\tfor(int i=0;i<m;i++) dp[x]|=(cnt[i]>0)<<i;\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tread(n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;read(x,y);\n\t\tg[x].pb(y);g[y].pb(x);\n\t}\n\twhile((1<<m)<=n) m++;\n\tdfs(1);\n\tfor(int i=m;~i;i--)\n\t\tif(dp[1]&(1<<i)){print(i);break;}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nset<int> S[MAX_N];\nvector<int> G[MAX_N];\nint cnt[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\tcnt[a]++;\n\t\tcnt[b]++;\n\t}\n\tqueue<int> que;\n\trep(i, 0, N) {\n\t\tif(cnt[i] == 1) que.push(i);\n\t}\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tint at = 0;\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] != 0) continue;\n\t\t\tif(sz(S[n]) > sz(S[v])) swap(S[n], S[v]);\n\t\t\tfor(auto d : S[n]) {\n\t\t\t\tif(S[v].count(d)) {\n\t\t\t\t\twhile(!S[v].empty() && (*(S[v].begin())) <= d) S[v].erase(S[v].begin());\n\t\t\t\t\tat = d + 1;\n\t\t\t\t}\n\t\t\t\telse if(d >= at) S[v].insert(d);\n\t\t\t}\n\t\t}\n\t\twhile(!S[v].empty() && (*(S[v].begin())) == at) {\n\t\t\tS[v].erase(S[v].begin());\n\t\t\tat++;\n\t\t}\n\t\tS[v].insert(at);\n\t\tMAX(ans, at);\n\n\t\t// debug(v, vi(all(S[v])));\n\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] == 0) continue;\n\t\t\tcnt[n]--;\n\t\t\tcnt[v]--;\n\t\t\tif(cnt[n] == 1) que.push(n);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 4005;\nconst int mo = 1e9+7;\n\nint n,m,k;\nint f0[N][N],f1[N][N];\n\nint add(int x,int y){return x+y>=mo?x+y-mo:x+y;}\n\nint main(){\n\tn=get();m=get();k=get();\n\tf0[1][0]=1;\n\tfo(i,1,k-1)f1[1][i]=1;\n\tint ans=0;\n\tfo(i,2,(n+m-1)/(k-1)){\n\t\tfo(j,0,m)f0[i][j]=add(f0[i-1][j],f1[i-1][j]);\n\t\tint pre=f0[i][0];\n\t\tfo(j,1,m){\n\t\t\tif (j>=k&&f0[i][j-k])pre=add(pre,mo-f0[i][j-k]);\n\t\t\tf1[i][j]=pre;\n\t\t\tpre=add(pre,f0[i][j]);\n\t\t}\n\t}\n\tfo(i,1,(n+m-1)/(k-1))\n\t\tfo(j,0,m)\n\t\tif ((k-1)*i-j<n&&j%(k-1)==m%(k-1)&&((k-1)*i-j)%(k-1)==(n-1)%(k-1))ans=add(ans,f1[i][j]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1000000010\n#define INFLL ((1LL<<62)-5)\n#define FO(i,a,b) for (int (i) = (a); (i) < (b); ++(i))\n#define OF(i,a,b) for (int (i) = (a)-1; (i) >= (b); --(i))\n#define SZ(v) int(v.size())\n#define pb push_back\n\nusing namespace std;\n//PAIRS:\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n/*~~~~TEMPLATE END~~~~*/\n\nconst int MAXN = 100005;\nint N;\nvector<int> allE[MAXN];\nint par[MAXN];\n\nvector<int> dfs (int c) {\n    int cnt[20];\n    fill(cnt, cnt+20, 0);\n    for (int nxt : allE[c]) {\n        if (nxt == par[c]) continue;\n        par[nxt] = c;\n        auto chV = dfs(nxt);\n        for (int v : chV) {\n            cnt[v]++;\n        }\n    }\n    int endSpot = 0;\n    for (int c = 19; c >= 0; c--) {\n        if (c == 0 || cnt[c] > 1) {\n            while (cnt[endSpot]) endSpot++;\n        }\n    }\n    cnt[endSpot] = 1;\n    vector<int> ret;\n    for (int c = 19; c >= endSpot; c--) {\n        if (cnt[c]) ret.push_back(c);\n    }\n    return ret;\n}\n\n\nint main() {\n    scanf (\"%d\", &N);\n    FO (i,0,N-1) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        allE[a].pb(b);\n        allE[b].pb(a);\n    }\n    auto v = dfs(1);\n    printf (\"%d\\n\", v[0]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 100005;\n\nmultiset<int> G[NMAX];\nint chain[NMAX], diam[NMAX];\n\nvoid dfs1(int node, int prev) {\n    int vmax1 = 0, vmax2 = 0;\n    for (int to: G[node]) {\n        if (to == prev) {\n            continue;\n        }\n        dfs1(to, node);\n        if (vmax1 < chain[to]) {\n            vmax2 = vmax1;\n            vmax1 = chain[to];\n        } else if (vmax2 < chain[to]) {\n            vmax2 = chain[to];\n        }\n        diam[node] = max(diam[node], diam[to]);\n    }\n    diam[node] = vmax1 + vmax2 + 1;\n    chain[node] = vmax1 + 1;\n}\n\nint maxDiam[NMAX];\nint allMin;\n\nint nextRoot = -1;\n\nvoid dfs2(int node, int prev, int chainUp = 0, int diamUp = 0) {\n    int vmax1 = chainUp, vmax2 = 0, vmax3 = 0;\n    int dmax1 = diamUp, dmax2 = 0;\n    maxDiam[node] = diamUp;\n    for (int to: G[node]) {\n        if (to == prev) {\n            continue;\n        }\n        maxDiam[node] = max(maxDiam[node], diam[to]);\n        if (chain[to] > vmax1) {\n            vmax3 = vmax2;\n            vmax2 = vmax1;\n            vmax1 = chain[to];\n        } else if (chain[to] > vmax2) {\n            vmax3 = vmax2;\n            vmax1 = chain[to];\n        } else if (chain[to] > vmax3) {\n            vmax3 = chain[to];\n        }\n        if (diam[to] > dmax1) {\n            dmax2 = dmax1;\n            dmax1 = diam[to];\n        } else if (diam[to] > dmax2) {\n            dmax2 = diam[to];\n        }\n    }\n    if (maxDiam[node] < allMin) {\n        nextRoot = node;\n        allMin = maxDiam[node];\n    }\n    for (int to: G[node]) {\n        if (to == prev) {\n            continue;\n        }\n        int chainDown = (chain[to] == vmax1 ? vmax2: vmax1) + 1;\n        int diamDown1;\n        if (diam[to] == dmax1) {\n            diamDown1 = dmax2;\n        } else {\n            diamDown1 = dmax1;\n        }\n        int diamDown2;\n        if (chain[to] == vmax1) {\n            diamDown2 = vmax2 + vmax3 + 1;\n        } else {\n            diamDown2 = vmax1 + vmax2 + 1;\n        }\n        int diamDown = max(diamDown1, diamDown2);\n        dfs2(to, node, chainDown, diamDown);\n    }\n}\n\nint solve(int root) {\n    dfs1(root, -1);\n    allMin = 0x3f3f3f3f;\n    nextRoot = -1;\n    dfs2(root, -1);\n    root = nextRoot;\n    int ans = 0;\n    for (int to: G[root]) {\n        G[to].erase(root);\n        ans = max(ans, solve(to) + 1);\n    }\n    return ans;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].insert(y);\n        G[y].insert(x);\n    }\n\n    cout << solve(1) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\n#define pii pair<int, int>\n#define mp(x, y) make_pair(x, y)\nusing namespace std;\ntypedef long long ll;\nconst int Maxn = 1e5 + 5;\ntypedef int arr[Maxn];\n//ll Add(ll x, ll y) { return (x += y) >= Mod ? x - Mod : (x < 0 ? x + Mod : x); }\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n, cnt, ans;\narr fir, deg;\nint mk[Maxn][18];\nstruct\n{\n\tint to, last;\n} e[Maxn << 1];\nvoid con(int u, int v)\n{\n\te[++cnt].to = v;\n\te[cnt].last = fir[u];\n\tfir[u] = cnt;\n\tdeg[u]++;\n\tdeg[v]++;\n}\nint Solve(int x, int from)\n{\n\trg int Max = 0;\n\tfor (int next = fir[x], nx; next; next = e[next].last)\n\t{\n\t\tnx = e[next].to;\n\t\tif (nx == from)\n\t\t\tcontinue;\n\t\tMax = max(Max, Solve(nx, x));\n\t\tfor (rg int j = 0; j <= Max; j++)\n\t\t\tmk[x][j] += mk[nx][j];\n\t}\n\trg int res = Max + 1;\n\tfor (int i = Max; i >= 0; i--)\n\t\tif (!mk[x][i])\n\t\t\tres = i;\n\t\telse if (mk[x][i] > 1)\n\t\t\tbreak;\n\tmk[x][res] = 1;\n\tans = max(ans, res);\n\tfor (rg int j = res - 1; j >= 0; j--)\n\t\tmk[x][j] = 0;\n\treturn Max + (res > Max);\n}\nint main()\n{\n\trg int a, b;\n\tcin >> n;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\ta = read();\n\t\tb = read();\n\t\tcon(a, b);\n\t\tcon(b, a);\n\t}\n\tSolve(1, 0);\n\tcout << ans << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\nvi g[MAXN];\n\nint used[MAXN];\n\nint dis[MAXN];\n\nvoid dfs(int s){\n\tused[s] = 1;\n\tREP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (!used[to]){\n\t\t\tdis[to] = dis[s] + 1;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint n, a, b;\n\tscanf(\"%d\", &n);\n\tREP(i, 1, n){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tdfs(1);\n\tint maxi = 1;\n\tREPN(i, 1, n){\n\t\tused[i] = 0;\n\t\tif (dis[i] > dis[maxi]){\n\t\t\tmaxi = i;\n\t\t}\n\t\tdis[i] = 0;\n\t}\n\tdfs(maxi);\n\tmaxi = 1;\n\tREPN(i, 1, n){\n\t\tif (dis[i] > dis[maxi]){\n\t\t\tmaxi = i;\n\t\t}\n\t}\n\tint mx = dis[maxi];\n\tint ans = 0;\n\tfor(int i = 0; i < mx; i = i * 2 + 2, ans++);\n\tprintf(\"%d\\n\", ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint N;\nvector <int> E[MAXN];\nint best, mx;\n\nvoid load() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n}\n\nvoid dfs(int x, int p, int d) {\n\tif (d > mx) {\n\t\tmx = d;\n\t\tbest = x;\n\t}\n\tfor (auto it : E[x])\n\t\tif (it != p)\n\t\t\tdfs(it, x, d + 1);\n}\n\nint solve() {\n\tdfs(1, 0, 0);\t\n\tmx = 0;\n\tdfs(best, 0, 0);\n\tint sol = 0;\n\tfor (mx++; mx > 1; mx >>= 1)\n\t\tsol++;\n\treturn sol;\n}\n\nint main() {\n\tload();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<int> label;\n\nint dfs_init(int node, int par) {\n    int mask = 0, beat = 0;\n    for (auto vec : graph[node]) {\n        if (vec == par) continue;\n        int now = dfs_init(vec, node);\n        beat |= (mask & now);\n        mask |= now;\n    }\n    int need = 31 - __builtin_clz(beat);\n    mask |= (1 << need) - 1;\n    label[node] = __builtin_ctz(~mask);\n    mask ^= (2 << label[node]) - 1;\n    return mask;\n}\n\nint main() {\n    int n; cin >> n;\n    label.resize(n);\n    graph.resize(n);\n    for (int i = 1; i < n; ++i) {\n        int a, b; cin >> a >> b;\n        graph[a - 1].push_back(b - 1);\n        graph[b - 1].push_back(a - 1);\n    }\n    dfs_init(0, -1);\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        res = max(res, label[i]);\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 100000\nstruct edge{int nx,t;}e[MN*2+5];\nint h[MN+5],en,f[MN+5];\ninline void ins(int x,int y)\n{\n\te[++en]=(edge){h[x],y};h[x]=en;\n\te[++en]=(edge){h[y],x};h[y]=en;\n}\nint cal(int x){for(int i=17;i;--i)if(x&(1<<i))return i;return -1;}\nvoid dfs(int x,int fa)\n{\n\tint mx=0;\n\tfor(int i=h[x];i;i=e[i].nx)if(e[i].t!=fa)\n\t{\n\t\tdfs(e[i].t,x);\n\t\tmx=max(mx,cal(f[x]&f[e[i].t])+1);\n\t\tf[x]|=f[e[i].t];\n\t}\n\tfor(int i=0;;++i)if(i>=mx&&!(f[x]&(1<<i)))\n\t\t{f[x]=(f[x]|(1<<i))&((-1)<<i);return;}\n}\nint main()\n{\n\tint n=read(),i;\n\tfor(i=1;i<n;++i)ins(read(),read());\n\tdfs(1,0);\n\tprintf(\"%d\",cal(f[1]));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nvector<int> g[101010];\n\nint md=0;\n\nint dfs(int x, int p){\n\tint d=0;\n\tfor (int nx:g[x]){\n\t\tif (nx!=p){\n\t\t\tint asd=dfs(nx, x)+1;\n\t\t\tmd=max(md, asd+d);\n\t\t\td=max(d, asd);\n\t\t}\n\t}\n\treturn d;\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor (int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tint lol=0;\n\tfor (int k=0;;k++){\n\t\tif (lol>=md){\n\t\t\tcout<<k<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tlol=2*lol+2;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define REP(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) REP((i),0,(n))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing tp3 = tuple<int, int, int>;\nusing Mat = vector<vector<ll>>;\nconstexpr int INF = 1 << 28;\nconstexpr ll INFL = 1ll << 60;\nconstexpr int dh[4] = { 0,1,0,-1 };\nconstexpr int dw[4] = { -1,0,1,0 };\nbool isin(const int H, const int W, const int h, const int w) {\n    return 0 <= h && h < H && 0 <= w && w < W;\n}\ntemplate<typename T>\nT chmin(T& l, T r) {\n    return l = min(l, r);\n}\ntemplate<typename T>\nT chmax(T& l, T r) {\n    return l = max(l, r);\n}\n// ============ template finished ============\nusing Graph = vector<vector<int>>;\nusing Level = int;\nusing Upper = bool;\nusing Status = pair<Level, Upper>;\nusing Index = int;\n\nint debugcnt = 0;\nStatus get_status(const vector<Status>& statuses) {\n    debugcnt += statuses.size();\n    assert(debugcnt < 1e7);\n    Status res;\n    for (Status status : statuses)res = max(res, status);\n    return res;\n}\n\nset<int> duplicate;\nIndex get_parent(const Graph& graph, const set<Index>& liftupped, const Index now) {\n    assert(duplicate.find(now) == duplicate.end());\n    duplicate.insert(now);\n    for (Index next : graph[now])\n        if (liftupped.find(next) == liftupped.end())\n            return next;\n    return -1;\n}\n\nStatus next_status(const Status& status) {\n    if (status.second) {\n        return { status.first + 1,false };\n    }\n    else {\n        return { status.first,true };\n    }\n}\n\nint max_level(const map<Level, int>& cnt) {\n    int base = -1;\n    for (const auto& itr : cnt)base = max(base, itr.first);\n    return base;\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    Graph graph(N);\n\n    rep(i, N - 1) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    vector<vector<Status>> raw_statuses(N);\n    queue<Index> liftups;\n    set<Index> liftupped;\n    rep(i, N)if (graph[i].size() == 1) {\n        raw_statuses[i].push_back({ 0,true });\n        liftups.push(i);\n        liftupped.insert(i);\n    }\n    while (!liftups.empty()) {\n        Index now = liftups.front(); liftups.pop();\n        Index parent = get_parent(graph, liftupped, now);\n        if (parent == -1)break;\n        Status status = get_status(raw_statuses[now]);\n        Status parent_status = next_status(status);\n        raw_statuses[parent].push_back(parent_status);\n\n        if (raw_statuses[parent].size() + 1 == graph[parent].size()) {\n            assert(liftupped.find(parent) == liftupped.end());\n            liftups.push(parent);\n            liftupped.insert(parent);\n        }\n    }\n    map<Level, int> cnt;\n    for (auto& raw_status : raw_statuses) {\n        auto status = get_status(raw_status);\n        cnt[status.first]++;\n    }\n    int level = max_level(cnt);\n    if (cnt[level] > 1)level++;\n    cout << level << endl;\n\n    rep(i, N) {\n        Status status = get_status(raw_statuses[i]);\n        // cout << \"Index: \" << i << \" -> (\" << status.first << \",\" << status.second << \")\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 100100;\n\nvector<int> g[MAX];\n\nint ST[MAX];\nint D[MAX];\n\nvoid go(int x, int p, int val, int diff, int mx)\n{\n\t//cout<<x<<' '<<val<<' '<<mx<<endl;\n\tif (val == -1)\n\t{\n\t\tmx++;\n\t\tD[x] = mx;\n\t\tdiff = 1;\n\t}\n\telse\n\t{\n\t\tif (val == mx - 1) diff = -1;\n\t\tD[x] = val;\n\t}\n\n\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (to == p) continue;\n\n\t\tgo(to, x, val + diff, diff, mx);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n-1)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\n\t\tST[x]++;\n\t\tST[y]++;\n\t}\n\n\tFOR (i, 0, n)\n\t{\n\t\tif (SZ(g[i]) != 1) continue;\n\t\tgo(i, -1, 0, -1, 0);\n\t\tbreak;\n\t}\n\tint res = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tres = max(res, D[i]);\n\t//\tcout<<i+1<<' '<<D[i]<<endl;\n\t}\n\n\tcout<<res<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_map>\n#define INT long long\n#define MOD 1000000007\nusing namespace std;\nINT n, d, unido[100010] = {0, 1, 1};\nvector<INT> g[100010];\nint solve(int x)\n{\n    int chk[100010] = {0};\n    int ret = x;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        ret = v;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return ret;\n}\nint f(int x, int y)\n{\n    int chk[100010] = {0};\n    int ret = 0;\n    queue<INT> q;\n    q.push(x), chk[x] = 1;\n    while( !q.empty() )\n    {\n        int v = q.front(); q.pop();\n        if( v == y ) return chk[v]-1;\n        for( auto w : g[v] )\n            if( !chk[w] )\n                q.push(w), chk[w] = chk[v]+1;\n    }\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n;\n    for(int i = 1 ; i < n ; i++ )\n    {\n        INT a, b;\n        cin>>a>>b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int v = solve(1);\n    int w = solve(v);\n    int d = f(v, w);\n    for(int i = 3 ; i <= d ; i++ )\n        unido[i] = unido[(i-1)/2] + 1;\n    cout<<(d&1?unido[d-1]:unido[d])<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 50000000;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q--) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t\t\n\t\tif (clock() > 1960)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ANS + 3 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc009/tasks/agc009_d\n/*<head>*/\n// #include \"lib/Template.hpp\"\n// #include \"lib/Graph.hpp\"\n/*</head>*/\n\n/*<body>*/\n/* #region header */\n/**\n* @file Template.hpp\n* @brief 競技プログラミング用テンプレート\n* @author btk15049\n* @date 2019/05/02\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* #region macro */\n#ifdef BTK\n#    define DEBUG if (1)\n#    define CIN_ONLY if (0)\n#else\n#    define DEBUG if (0)\n#    define CIN_ONLY if (1)\n#endif\n/** @def\n* ALLマクロ\n*/\n#define ALL(v) (v).begin(), (v).end()\n\n/** @def\n* 再帰ラムダをするためのマクロ\n*/\n#define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n/* #endregion */\n\nnamespace _Template_ {\n/**\n* @brief cin高速化処理を行うための構造体\n* @details CIN_ONLYマクロで動作が変わる\n*/\nstruct cww {\ncww() {\nCIN_ONLY {\nios::sync_with_stdio(false);\ncin.tie(0);\n}\n}\n} star;\n/**\n* @brief change min\n* @tparam T 型\n* @param l 参照\n* @param r 非参照\n* @return 更新があればtrue\n*/\ntemplate <typename T>\ninline bool chmin(T& l, T r) {\nbool a = l > r;\nif (a) l = r;\nreturn a;\n}\n/**\n* @brief chminのmax版\n* @see chmin\n*/\ntemplate <typename T>\ninline bool chmax(T& l, T r) {\nbool a = l < r;\nif (a) l = r;\nreturn a;\n}\n/**\n* @brief\n* vectorに直接cin流すためのやつ\n* @tparam T\n* @param is\n* @param v\n* @return istream&\n*/\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v) {\nfor (auto& it : v) is >> it;\nreturn is;\n}\n/**\n* @brief\n* rangeを逆向きに操作したいとき用\n* @details\n* ループの範囲は[bg,ed)なので注意\n* @see range\n*/\nclass reverse_range {\nprivate:\nstruct I {\nint x;\nint operator*() { return x - 1; }\nbool operator!=(I& lhs) { return x > lhs.x; }\nvoid operator++() { --x; }\n};\nI i, n;\n\npublic:\nreverse_range(int n) : i({0}), n({n}) {}\nreverse_range(int i, int n) : i({i}), n({n}) {}\nI& begin() { return n; }\nI& end() { return i; }\n};\n/**\n* @brief\n* python みたいな range-based for を実現\n* @details\n* ループの範囲は[bg,ed)なので注意\n* !つけると逆向きにループが回る (reverse_range)\n* 空間計算量はO(1)\n* 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n*/\nclass range {\nprivate:\nstruct I {\nint x;\nint operator*() { return x; }\nbool operator!=(I& lhs) { return x < lhs.x; }\nvoid operator++() { ++x; }\n};\nI i, n;\n\npublic:\nrange(int n) : i({0}), n({n}) {}\nrange(int i, int n) : i({i}), n({n}) {}\nI& begin() { return i; }\nI& end() { return n; }\nreverse_range operator!() { return reverse_range(*i, *n); }\n};\n/**\n* @brief\n* rangeで生まれる使わない変数を消す用（警告消し）\n*/\ntemplate <typename T>\ninline T& unused_var(T& v) {\nreturn v;\n}\nusing LL = long long;\n} // namespace _Template_\nusing namespace _Template_;\n\n\n/**\n* @file Graph.hpp\n* @brief グラフクラス\n* @author btk15049\n* @date 2019/03/11\n* @datails\n*  verify: WUPC C\n*/\nnamespace _Graph_ {\n/**\n* @brief 辺を扱う構造体の例\n* @details\n辺に重みなどを加えたい場合は変数とかを増やして作る．\nGraphに使うために必要な要件:\n- id,a,bは必須，他のパラメータ増やすときはコンストラクタを忘れずに\n- versusは必須，基本的にコピペでOK\n*/\nstruct Edge {\nint id, a, b;\n/**\n* @brief Construct a new Edge object\n* @param id 辺番号\n* @param a 辺に接続する頂点番号\n* @param b 辺に接続する頂点番号\n*/\nEdge(int id = 0, int a = 0, int b = 0) : id(id), a(a), b(b) {}\n/**\n* @brief 辺における，vの対になってる頂点番号を取得する\n* @param v 頂点番号\n* @return int vじゃない方の頂点番号\n*/\ninline int versus(const int v) const { return a ^ b ^ v; }\n};\n/**\n* @brief グラフクラス\n* @tparam E=Edge 新たなグラフクラス作るときは書き換える\n* @details 0-indexedで使うことしか考えてないので注意．\n*/\ntemplate <typename E = Edge>\nclass Graph {\nprivate:\n//! 辺集合\nvector<E> edges;\n//! 隣接リスト\nvector<vector<int>> g;\n\npublic:\n/**\n* @brief Construct a new Graph object\n* @param reserved_vertex_size 頂点数の最大値，vectorのサイズ確保用\n* @param reserved_edge_size 辺数の最大値，vectorのサイズ確保用\n*/\nGraph(int reserved_vertex_size = 1, int reserved_edge_size = -1) {\ng.reserve(reserved_vertex_size);\nedges.reserve(max(reserved_vertex_size, reserved_edge_size));\n}\n\n/**\n* @brief グラフの頂点数を返す\n* @return int 頂点数\n*/\ninline int size() { return g.size(); }\n\n/**\n* @brief vの次数を返す\n* @param v 頂点番号\n* @return int 次数\n*/\ninline int degree(const int v) { return g[v].size(); }\n\n/**\n* @brief グラフ全体の辺の数を返す\n* @return int グラフ全体の辺の数\n*/\ninline int degree() { return edges.size(); }\n\n/**\n* @brief \"無向\"辺(a,b)を追加する．\n* @param a 頂点番号\n* @param b 頂点番号\n* @param params 重みとか，容量とか\n* @details paramsはemplace_backと同じノリで続けて足してけばOK\n*/\ntemplate <typename... Ts>\ninline void add_edge(int a, int b, Ts&&... params) {\nconst int id = edges.size();\nif ((int)g.size() <= max(a, b)) {\ng.resize(max(a, b) + 1);\n}\ng[a].emplace_back(id);\ng[b].emplace_back(id);\nedges.emplace_back(id, a, b, forward<Ts>(params)...);\n}\n\n/**\n* @brief \"有向\"辺(a,b)を追加する．\n* @param a 頂点番号\n* @param b 頂点番号\n* @param params 重みとか，容量とか\n* @details paramsはemplace_backと同じノリで続けて足してけばOK\n*/\ntemplate <typename... Ts>\ninline void add_arc(int a, int b, Ts&&... params) {\nconst int id = edges.size();\nif ((int)g.size() <= max(a, b)) {\ng.resize(max(a, b) + 1);\n}\ng[a].emplace_back(id);\nedges.emplace_back(id, a, b, forward<Ts>(params)...);\n}\n\n/**\n* @brief vの隣接頂点を返す\n* @param v int\n* @return vector<int>\n*/\ninline vector<int> Ns(const int v) {\nvector<int> ns(g[v].size());\nfor (int i = 0; i < degree(v); i++) {\nns[i] = edges[g[v][i]].versus(v);\n}\nreturn ns;\n}\n\n/**\n* @brief vに隣接する辺番号の集合を返す\n* @param v int\n* @return vector<int>\n*/\ninline const vector<int>& operator[](const int v) { return g[v]; }\n\n/**\n* @brief 辺番号から辺の参照を取得する\n* @param edge_id\n* @return E&\n*/\ninline E& i2e(const int edge_id) { return edges[edge_id]; }\n};\n} // namespace _Graph_\nusing namespace _Graph_;\n\n/* #endregion */\n/*</body>*/\n\ntemplate <typename E=Edge>\nclass Tree : public Graph<E> {\n    private:\n    using Graph<E>::add_edge;\n    void build(Graph<E>& g, int v,int p) {\n        for(int edge_id:g[v]){\n            auto e = g.i2e(edge_id);\n            const int u = e.versus(v);\n            if(p==u)continue;\n            //add_arc(e);\n            this->add_arc(v,u);\n            build(g,u,v);\n        }\n    }\n    public:\n    const int root;\n    Tree(int reserved_vertex_size = 1, int reserved_edge_size = -1, const int root = 0)\n    : Graph<E>(reserved_vertex_size, reserved_edge_size) , root(root) {}\n    Tree(Graph<E>& g, const int root = 0)\n    : Graph<E>(g.size(), g.size()-1), root(root){\n        build(g,root,root);\n    }\n};\n\nusing X = array<int,32>;\nX dfs(Tree<>& tree, int v){\n    X ret;\n    for(int i:range(32))ret[i]=0;\n    for(int u:tree.Ns(v)){\n        X cld = dfs(tree,u);\n        for(int i:range(32))ret[i]+=cld[i];\n    }\n    int low = -1;\n    for(int i:range(32)){\n        if(ret[i]>=2)low = i;\n    }\n    int up = low+1;\n    while(ret[up]>0){\n        up++;\n    }\n    for(int i:range(up)){\n        ret[i]=0;\n    }\n    ret[up]++;\n    //cerr << v << \" \" << up << \" \";\n    //for(int i:range(32))cerr<<ret[i];\n    //cerr << endl;\n    return ret;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    Graph<> g(N,N-1);\n    for(int i:range(N-1)){\n        unused_var(i);\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        g.add_edge(a,b);\n    }\n    Tree<> tree(g);\n    auto st = dfs(tree,tree.root);\n    for(int i:!range(32)){\n        if(st[i]){\n            cout << i << endl;\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nint n,w[N],head[N],next[N];\nvoid add(int f,int t){\n\tstatic int cnt=0;\n\tw[++cnt]=t;\n\tnext[cnt]=head[f];\n\thead[f]=cnt;\n}\nint dep[N];\nvoid dfs(int x,int fa){\n\tfor (int i=head[x];i;i=next[i])\n\tif (w[i]!=fa) dep[w[i]]=dep[x]+1,dfs(w[i],x);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);add(v,u);\n\t}\n\tdep[1]=1;dfs(1,0);\n\tint v=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (dep[i]>dep[v]) v=i;\n\tdep[v]=1;dfs(v,0);\n\tint len=0;\n\tfor (int i=1;i<=n;i++) len=max(len,dep[i]);\n\t//printf(\"%d\\n\",len);\n\tint k=1,ans=0;\n\twhile (k<len) k=k*2+1,ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 262144\n#define rint register int\ninline int read(){int r;int s=0,c;for(;!isdigit(c=getchar());s=c);for(r=c^48;isdigit(c=getchar());(r*=10)+=c^48);return s^45?r:-r;}\nint c[MAXN+5], h[MAXN+5], n, _; vector<int> e[MAXN+5];\nint DP(int p, int fa){int U = 0, S = 0; for(auto v:e[p]) if(v^fa) _ = DP(v,p), S |= _&U, U |= _; for(_ = h[S]; U&1<<_; ++_); return U>>_<<_|1<<_;}\nint main()\n{\n\tn = read(); for(rint i = 2, a, b; i <= n; a = read(), b = read(), e[a].push_back(b), e[b].push_back(a), i++);\n\tc[1] = 1; for(rint i = 2; i <= MAXN; c[i] = -~c[i-(i&-i)], h[i] = -~h[i>>1], i++); return !printf(\"%d\\n\",h[DP(1,0)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nvector<int> graph[101010];\nint ids[101010];\n\nvoid remove_leaves()\n{\n\tvector<pair<int, int> > rem;\n\tfor (int i = 0; i < N; ++i) {\n\t\tids[i] = -1;\n\t\tfor (int j : graph[i]) {\n\t\t\tif (i < j && graph[i].size() > 1 && graph[j].size() > 1) {\n\t\t\t\trem.push_back({ i, j });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) graph[i].clear();\n\n\tint idx = 0;\n\tfor (auto e : rem) {\n\t\tint u = e.first, v = e.second;\n\t\tif (ids[u] == -1) {\n\t\t\tids[u] = idx++;\n\t\t}\n\t\tif (ids[v] == -1) {\n\t\t\tids[v] = idx++;\n\t\t}\n\t\tgraph[ids[u]].push_back(ids[v]);\n\t\tgraph[ids[v]].push_back(ids[u]);\n\t}\n\tN = idx;\n}\nvoid visit(int p, int rt, int vrt, int el, int &idx, vector<pair<int, int> > &edges)\n{\n\tif (graph[p].size() == 2) {\n\t\tvisit(graph[p][0] + graph[p][1] - rt, p, vrt, el + 1, idx, edges);\n\t\treturn;\n\t}\n\tint my = idx++;\n\tif (rt != -1) {\n\t\tvector<int> bridge;\n\t\tbridge.push_back(my);\n\t\tfor (int i = 0; i < (el - 1) / 2; ++i) {\n\t\t\tbridge.push_back(idx++);\n\t\t}\n\t\tbridge.push_back(vrt);\n\t\tfor (int i = 0; i < bridge.size() - 1; ++i) {\n\t\t\tedges.push_back({ bridge[i], bridge[i + 1] });\n\t\t}\n\t}\n\tfor (int q : graph[p]) if (q != rt) {\n\t\tvisit(q, p, my, 1, idx, edges);\n\t}\n}\nvoid contract()\n{\n\tint idx = 0;\n\tvector<pair<int, int> > edges;\n\tfor (int i = 0; i < N; ++i) if (graph[i].size() != 2) {\n\t\tvisit(i, -1, -1, 0, idx, edges);\n\t\tbreak;\n\t}\n\tfor (int i = 0; i < N; ++i) graph[i].clear();\n\tfor (auto e : edges) {\n\t\tint u = e.first, v = e.second;\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\tN = idx;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tint ans = 0;\n\twhile (N > 1) {\n\t\tans += 1;\n\t\tremove_leaves();\n\t\tcontract();\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nconst int MAX_N = 1e5 + 5;\nint n, ans, p = 1, l;\nint dis[MAX_N];\nint Arr[MAX_N];\nint L, R;\nvector <int> G[MAX_N];\n\nvoid bfs (int v) {\n\tmemset(dis, 127, sizeof dis);\n\tdis[v] = 0;\n\tL = R = 0;\n\tArr[R++] = v;\n\t\n\twhile (L < R) {\n\t\tint u = Arr[L++];\n\t\tfor (int i = 0; i < G[u].size(); i++)\n\t\t\tif (1 + dis[u] < dis[G[u][i]]) {\n\t\t\t\tdis[G[u][i]] = 1 + dis[u];\n\t\t\t\tArr[R++] = G[u][i];\n\t\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\t\n\tbfs(0);\n\tint k = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dis[k] < dis[i])\n\t\t\tk = i;\n\t\t\t\n\tbfs(k);\n\tfor (int i = 0; i < n; i++)\n\t\tif (ans < dis[i])\n\t\t\tans = dis[i];\n\t\t\t\n\tans++;\n\t\n\twhile (p <= ans) {\n\t\tl++;\n\t\tp <<= 1;\n\t}\n\t\n\tcout << l - 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\n#define LL long long\n#define Ldouble long double\n#define PI 3.1415926535897932384626\n\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\n#define M 300003\n\nint n, ans;\nvector<int> v[M];\nint lab[M];\n\nvoid dfs(int id, int pv){\n\tfor(auto to: v[id]) if(to != pv){\n\t\tdfs(to, id);\n\t\tlab[id] |= lab[to];\n\t}\n\tlab[id]++;\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFI(i, 2, n){\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\twhile(lab[1]){\n\t\tans++;\n\t\tlab[1] >>= 1;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = N, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n\ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nvector<int> graph[limit];\nll dp[limit];\n\nconst ll inf = 1LL << 60;\n\nll opr(ll val){\n\tif(val == 0) return 1LL;\n\n\tll ret = val;\n\tint start = -1;\n\t\n\trep(i, 60){\n\t\tif((ret >> i & 1) == 0) {\n\t\t\tstart = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret ^= (1LL << start);\n\n\trrep(i, start){\n\t\tif((ret >> i & 1) == 1) {\n\t\t\tret ^= (1LL << i);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nll dfs(int v, int p){\n\tll ret = 0LL;\n\tfor(auto &v2: graph[v]){\n\t\tif(v2 == p) continue;\n\t\tret |= dfs(v2, v);\n\t}\n\n\tret = opr(ret);\n\treturn ret;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i, n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\n\tconst ll val = dfs(0, -1);\n\n\trrep(ans, 60){\n\t\tif(val >> ans & 1) {\n\t\t\tcout << ans << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lg2 std::__lg\n#define ctz __builtin_ctz\n\nconst int N = 100054, M = N * 2;\n\nint n, E = 0;\nint to[M], first[N], next[M];\nint f[N], ans[N];\n\ninline void addedge(int u, int v) {\n\tto[++E] = v, next[E] = first[u], first[u] = E;\n\tto[++E] = u, next[E] = first[v], first[v] = E;\n}\n\nvoid dfs(int x, int px = 0) {\n\tint i, y, s = 0;\n\tfor (i = first[x]; i; i = next[i])\n\t\tif ((y = to[i]) != px)\n\t\t\tdfs(y, x), s |= f[x] & f[y], f[x] |= f[y];\n\ts = lg2(s << 1 | 1), s = ctz(~(f[x] >> s));\n\tf[x] = (f[x] >> s | 1) << s, ans[x] = s;\n}\n\nint main() {\n\tint i, u, v;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v);\n\tdfs(1), printf(\"%d\\n\", *std::max_element(ans + 1, ans + (n + 1)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nvector<int> adj[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\nconst int MAX_LOG = 20;\n\nint f[MAXN + 5][MAX_LOG + 1];\n\nint ans = 0;\n\ninline void dfs(int u, int fa)\n{\n\tfor(auto v : adj[u]) if(v != fa)\n\t{\n\t\tdfs(v, u);\n\t\tfor(int i = 0; i <= MAX_LOG; ++i) f[u][i] += f[v][i];\n\t}\n\n\tint k = 0;\n\tfor(int i = MAX_LOG; i >= 0; --i) if(f[u][i] >= 2) { k = i + 1; break; }\n\twhile(f[u][k] == 1) ++k;\n\n\tchkmax(ans, k), ++f[u][k];\n\tfor(int i = 0; i < k; ++i) f[u][i] = 0;\n}\n\ninline void solve()\n{\n\tdfs(1, 0);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"D.in\", \"r\", stdin);\n\tfreopen(\"D.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define FILE_IO\n\nint N, ans;\nvector <int> edg[100005];\nint bts[100005];\n\nvoid DFS(int nod, int fth)\n{\n    int msk = 0;\n    int val = 0;\n    for(auto nxt: edg[nod])\n    {\n        if(nxt == fth)  continue;\n        DFS(nxt, nod);\n        for(int b = val + 1; b < 20; b++)\n            if( ((1 << b) & msk) && ((1 << b) & bts[nxt]) )\n                val = b + 1;\n        msk |= bts[nxt];\n    }\n\n    while( (1 << val) & msk )   val++;\n    bts[nod] = 1 << val;\n    for(int b = val + 1; b < 20; b++)\n        if( (1 << b) & msk )\n            bts[nod] |= (1 << b);\n    ans = max(ans, val);\n}\n\nint main()\n{\n    #ifdef FILE_IO\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n    #endif\n\n    scanf(\"%d\", &N);\n    for(int i = 1; i < N; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        edg[x].push_back(y);\n        edg[y].push_back(x);\n    }\n\n    DFS(1, 0);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint mask[N],ans,n;\nvector<int> g[N];\nvoid DFS(int u,int fr){\n    int two=0,tot=0;\n    for(int i:g[u])\n        if(i!=fr){\n            DFS(i,u);\n            two|=tot&mask[i];\n            tot|=mask[i];\n        }\n    int v=31-__builtin_clz(two);\n    v= __builtin_ffs(~(tot>>v))-1+v;\n    ans=max(ans,v);mask[u]=((tot>>v)<<v)|(1<<v);\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=2,f,t;i<=n;i++) \n        scanf(\"%d%d\",&f,&t),g[f].push_back(t),g[t].push_back(f);\n    DFS(1,0);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge\n{\n    int to, nxt;\n};\nEdge e[200010];\nint head[200010], cnt;\nconst int LG = 65;\nint dp[200010][LG + 2];\n\nvoid add_edge(int a, int b)\n{\n    e[++cnt].to = b;\n    e[cnt].nxt = head[a];\n    head[a] = cnt;\n}\n\nvoid dfs(int nod, int tata)\n{\n    for (int i = head[nod]; i; i = e[i].nxt) {\n        int v = e[i].to;\n        if (v == tata)\n            continue;\n        dfs(v, nod);\n        for (int j(1); j <= LG; j++)\n            dp[nod][j] += dp[v][j];\n    }\n    int bigg0(1);\n    for (int i(1); i <= LG; i++) {\n        if (dp[nod][i] <= 1)\n            continue;\n        int p(i);\n        while (dp[nod][p])\n            p++;\n        dp[nod][p] = 1;\n        for (int j(bigg0); j < p; j++)\n            dp[nod][j] = 0;\n        bigg0 = p;\n    }\n\n    int p(1);\n    while (dp[nod][p])\n        p++;\n    dp[nod][p] = 1;\n    for (int i(1); i < p; i++)\n        dp[nod][i] = 0;\n}\n\nint main()\n{\n    int n, a, b;\n    scanf(\"%d\", &n);\n\n    while (--n) {\n        scanf(\"%d%d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n\n    dfs(1, 0);\n\n    for (int i(LG); i >= 0; i--) {\n        if (dp[1][i]) {\n            printf(\"%d\\n\", i - 1);\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic vector<int> e[2][100000];\n\nint recon(int i,int p,bool b,int &N)\n{\n  //printf(\"%d %d %d\\n\",i,p,N);\n  int t=N;\n  e[!b][t]=vector<int>(0);\n  N++;\n  for(int x=0;x<e[b][i].size();x++){\n    int j=e[b][i][x];\n    if(j==p)continue;\n    if(e[b][j].size()==2){\n      int k=(e[b][j][0]==i?e[b][j][1]:e[b][j][0]);\n      int c=recon(k,j,b,N);\n      e[!b][t].push_back(c);\n      e[!b][c].push_back(t);\n    }\n    else if(e[b][j].size()>2){\n      int c=recon(j,i,b,N);\n      e[!b][t].push_back(c);\n      e[!b][c].push_back(t);\n    }\n  }\n  return t;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  bool b=0;\n  for(int i=0;i<n-1;i++){\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    u--,v--;\n    e[b][u].push_back(v);\n    e[b][v].push_back(u);\n  }\n  int N=n,t=0;\n  while(N>1){\n    //printf(\"%d\\n\",N);\n    t++;\n    int r=0;\n    if(e[b][r].size()==1){\n      r=e[b][r][0];\n    }\n    N=0;\n    recon(r,-1,b,N);\n    b=!b;\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 100010;\n\nstd::vector <int> e[N];\nint ans[N], sz[N], sum, min, minsit;\nbool vis[N];\n\nvoid precalc(int u, int fa){\n\tsz[u] = 1;\n\tfor (auto v : e[u]){\n\t\tif (vis[v] || v == fa) continue;\n\t\tprecalc(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nvoid dfs1(int u, int fa, int sum){\n\tint max = 0, ssum = sum;\n\tfor (auto v : e[u]){\n\t\tif (vis[v] || v == fa) continue;\n\t\tdfs1(v, u, sum);\n\t\tssum -= sz[v];\n\t\tmax = std::max(max, sz[v]);\n\t}\n\tmax = std::max(max, ssum - 1);\n\tif (max < min){\n\t\tmin = max;\n\t\tminsit = u;\n\t}\n}\n\nvoid dfs2(int u, int fa){\n\t++ ans[u];\n\tfor (auto v : e[u]){\n\t\tif (v == fa || vis[v]) continue;\n\t\tdfs2(v, u);\n\t}\n}\n\nvoid dfs(int u){\n\tprecalc(u, 0);\n\tif (sz[u] == 1) return;\n\tmin = INT_MAX;\n\tdfs1(u, 0, sz[u]);\n\tdfs2(u, 0);\n\t-- ans[minsit]; \n\tvis[minsit] = true;\n\tfor (auto v : e[minsit]){\n\t\tif (vis[v]) continue;\n\t\tdfs(v);\n\t}\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0, u, v; i < n - 1; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1);\n\tint max = 0;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tmax = std::max(max, ans[i]);\n\t}\n\tprintf(\"%d\\n\", max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 1000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct edge{\n\tint from,to;\n\tedge(){}\n\tedge(int f,int t):from(f),to(t){}\n};\nstruct Tree{\n\tint V;\n\tint root;\n\tvector<int> depth;\n\tvector<int> par;\n\tvector<int> subtree_size;\n\tvector<int> centroid;\n\tvector<vector<edge> > G;\n\tTree(){}\n\tTree(int v,int r=0){\n\t\tV = v;\n\t\troot = r;\n\t\tG.resize(V);\n\t\tdepth.resize(V);\n\t\tpar.resize(V);\n\t\tsubtree_size.resize(V);\n\t}\n\tvoid add_edge(int u,int v){\n\t\tG[u].pb(edge(u,v));\n\t\tG[v].pb(edge(v,u));\n\t}\n\tint dfs(int v,int p,int d){\n\t\tdepth[v]=d;\n\t\tpar[v]=p;\n\t\tsubtree_size[v]=1;\n\t\tbool is_centroid = true;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(u==p)continue;\n\t\t\tsubtree_size[v]+=dfs(u,v,d+1);\n\t\t\tif(subtree_size[u]>V/2)is_centroid=false;\n\t\t}\n\t\tif(V-subtree_size[v]>V/2)is_centroid=false;\n\t\tif(is_centroid)centroid.pb(v);\n\t\treturn subtree_size[v];\n\t}\n\tvoid dfs(){\n\t\tdfs(root,-1,0);\n\t}\n\tint rec(int v,int p){\n\t\tvector<int> vec;\n\t\tint ret = 0;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(u==p)continue;\n\t\t\tint res = rec(u,v);\n\t\t\tret |= res;\n\t\t\tvec.pb(res);\n\t\t}\n\t\tvector<int> cnt(20,0);\n\t\tint m = 0;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tfor(int j=0;j<vec.size();j++){\n\t\t\t\tif(vec[j]&(1<<i))cnt[i]++;\n\t\t\t}\n\t\t\tif(cnt[i]>=2)m = max(m,i+1);\n\t\t}\n\t\twhile(cnt[m]>0)m++;\n\t\tret = ((ret>>m)<<m);\n\t\tret |= (1<<m);\n\t\treturn ret;\n\t}\t\n};\nint N;\nint main(){\n\tcin >> N;\n\tTree G(N);\n\tfor(int i=0;i<N-1;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tx--;y--;\n\t\tG.add_edge(x,y);\n\t}\n\tG.dfs();\n\tint ans = G.rec(0,-1);\n\tint a = 0;\n\tfor(int i=0;i<20;i++){\n\t\tif(ans&(1<<i))a = max(a,i);\n\t}\n\tcout << a << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint N;\nvector <int> E[MAXN];\nbool bio[MAXN];\nvector <int> V;\nint sz[MAXN], maks[MAXN];\nint sol;\n\nvoid load() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i < N; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n}\n\nvoid dfs(int x, int p) {\n  V.push_back(x);\n  maks[x] = 0;\n  sz[x] = 1;\n  for (int i = 0; i < E[x].size(); i++) {\n    int nxt = E[x][i];\n    if (bio[nxt] || nxt == p) \n      continue;\n    dfs(nxt, x);\n    sz[x] += sz[nxt];\n    maks[x] = max(maks[x], sz[nxt]);\n  }\n}\n\nvoid centroid(int x, int p, int d) {\n  V.clear();\n  dfs(x, p);\n  int best = -1;\n  for (int i = 0; i < V.size(); i++) {\n    maks[V[i]] = max(maks[V[i]], sz[x] - sz[V[i]]);\n    if (best == -1 || maks[V[i]] < maks[best]) \n      best = V[i];\n  }\n  x = best;\n  sol = max(sol, d);\n  bio[x] = true;\n  for (int i = 0; i < E[x].size(); i++) {\n    int nxt = E[x][i];\n    if (bio[nxt]) \n      continue;\n    centroid(nxt, x, d + 1);\n  }\n}\n\nint main() {\n  load();\n  centroid(1, 0, 0);\n  printf(\"%d\\n\", sol);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 100010\nvector<int> g[N];\nint n;\nint d[N], d2[N], dd[N];\n\nint dfs(int u, int *d){\n\tint res = u;\n\tfor(auto v: g[u]){\n\t\tif(d[v]!=-1) continue;\n\t\td[v] = d[u]+1;\n\t\tint w = dfs(v, d);\n\t\tif(d[w]>d[res]) res = w;\n\t}\n\treturn res;\n}\n\nvector<int> cs(int u, int *d, int *d2, int len){\n\tvector<int> res;\n\tif(d[u]+d2[u]>len) return res;\n\tif(abs(d[u]-d2[u])<=1) res.pb(u);\n\tfor(auto v: g[u]){\n\t\tif(d2[v]<d2[u]) continue;\n\t\tauto r = cs(v, d, d2, len);\n\t\tif(r.size()>res.size()) res.swap(r);\n\t\tres.insert(res.end(), r.begin(), r.end());\n\t}\n\treturn res;\n}\n\nint rec(int u){\n\tcerr<<u<<endl;\n\tmemcpy(d, dd, sizeof(d));\n\tmemcpy(d2, dd, sizeof(d));\n\td[u] = 0;\n\tint v = dfs(u, d);\n\td2[v] = 0;\n\tint w = dfs(v, d2);\n\t//cerr<<w<<\" \"<<d2[w]<<endl;\n\tif(d2[w]==0) return 0;\n\tauto nodes = cs(v, d, d2, d2[w]);\n\t//cerr<<\"nodes\"<<nodes<<endl;\n\tint res = INF;\n\tfor(auto x: nodes){\n\t\tdd[x] = -INF;\n\t\tint res2 = 0;\n\t\tfor(auto y: g[x]){\n\t\t\tif(dd[y]==-INF) continue;\n\t\t\t//cerr<<x<<\" \"<<y<<endl;\n\t\t\tchmax(res2, rec(y)+1);\n\t\t}\n\t\tchmin(res, res2);\n\t\tdd[x] = -1;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n-1){\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tu--; v--;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tmset(dd, -1);\n\tint res = rec(0);\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Tree {\n  public:\n    Tree(int size):\n            m_edges(size),\n            m_size(size) {}\n\n    int size() const {\n        return m_edges.size();\n    }\n\n    void addEdge(int x, int y) {\n        m_edges[x].emplace_back(y);\n        m_edges[y].emplace_back(x);\n    }\n\n    int uninity() {\n        return dfsUninity(0);\n    }\n\n  private:\n    int dfsUninity(int node) {\n        if (m_edges[node].size() == 0)\n            return 0;\n\n        dfsSize(node);\n        int center = node;\n        while (true) {\n            bool found_next = false;\n            for (auto &x : m_edges[center])\n                if (m_size[x] < m_size[center] && m_size[x] > m_size[node] / 2) {\n                    center = x;\n                    found_next = true;\n                    break;\n                }\n            if (!found_next)\n                break;\n        }\n\n        int answer = 0;\n        for (auto &x : m_edges[center]) {\n            m_edges[x].erase(find(m_edges[x].begin(), m_edges[x].end(), center));\n            answer = max(answer, dfsUninity(x));\n        }\n        return answer + 1;\n    }\n\n    void dfsSize(int node, int father = -1) {\n        m_size[node] = 1;\n        for (auto &x : m_edges[node])\n            if (x != father) {\n                dfsSize(x, node);\n                m_size[node] += m_size[x];\n            }\n    }\n\n    vector< vector<int> > m_edges;\n    vector<int> m_size;\n};\n\nint main() {\n    int N; cin >> N;\n\n    Tree T(N);\n    for (int i = 1; i < N; ++i) {\n        int x, y; cin >> x >> y;\n        T.addEdge(x - 1, y - 1);\n    }\n\n    cout << T.uninity() << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nint mx[100005], smx[100005];\nstruct node {\n\tint vs[100005];\n\tint hd[100005], vr[200005], nt[200005], tt, rt;\n\tvoid push(int x, int y) {\n\t\tvr[++tt] = y; nt[tt] = hd[x]; hd[x] = tt;\n\t}\n\tvoid dfs0_0(int nw, int en) {\n\t\tsmx[nw] = mx[nw] = 0;\n\t\tfor(int i = hd[nw]; i; i = nt[i]) {\n\t\t\tif(vr[i] == en || vs[vr[i]]) continue;\n\t\t\tdfs0_0(vr[i], nw);\n\t\t\tif(mx[nw] < mx[vr[i]] + 1) {\n\t\t\t\tsmx[nw] = mx[nw];\n\t\t\t\tmx[nw] = mx[vr[i]] + 1;\n\t\t\t} else smx[nw] = max(smx[nw], mx[vr[i]] + 1);\n\t\t}\n\t}\n\tvoid dfs0_1(int nw, int en) {\n\t\tif(en != 0) {\n\t\t\tint k = 0;\n\t\t\tif(mx[nw] + 1 == mx[en]) k = smx[en];\n\t\t\telse k = mx[en];\n\t\t\tif(mx[nw] < k + 1) {\n\t\t\t\tsmx[nw] = mx[nw];\n\t\t\t\tmx[nw] = k + 1;\n\t\t\t} else smx[nw] = max(smx[nw], k + 1);\n\t\t}\n\t\tif(mx[rt] > mx[nw]) rt = nw;\n\t\tfor(int i = hd[nw]; i; i = nt[i]) {\n\t\t\tif(vr[i] == en || vs[vr[i]]) continue;\n\t\t\tdfs0_1(vr[i], nw);\n\t\t}\n\t}\n\tint dfs(int nw) {\n\t\trt = 0;\n\t\tdfs0_0(nw, 0);\n\t\tdfs0_1(nw, 0);\n\t\tvs[rt] = 1;\n\t\tif(mx[rt] == 0) return 0;\n\t\tint MX = 0;\n\t\tfor(int i = hd[rt]; i; i = nt[i]) {\n\t\t\tif(vs[vr[i]]) continue;\n\t\t\tint k = dfs(vr[i]);\n\t\t\tif(k > MX) MX = k;\n\t\t}\n\t\treturn MX + 1;\n\t}\n}T;\nint n, x, y;\nint main() {\n\tscanf(\"%d\", &n);\n\trop(i, 1, n) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT.push(x, y);\n\t\tT.push(y, x);\n\t}\n\tmx[0] = 100000000;\n\tcout << T.dfs(1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <functional>\n#include <iterator>\n#include <utility>\n#include <bitset>\n#include <cstdlib>\n#include <ctime>\n#include <complex>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\n#define FOR(i, a, b) for(int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define REPD(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define SZ(x) ((int)x.size())\n#define openfile {freopen(\"inp.txt\",\"rt\",stdin);freopen(\"out.txt\",\"wt\",stdout);}\n#define debug 0\n\ntemplate <typename T> inline void next_int(T &x) {\n\tx = 0; char c; bool neg = false;\n\twhile (!isdigit(c = getchar())) if (c == '-') neg = true;\n\tdo x = x*10 + c - 48; while (isdigit(c = getchar()));\n\tif (neg) x = -x;\n}\n\ntemplate <typename T> inline void write_int(T x) {\n\tif (x > 9) write_int(x / 10);\n\tputchar(x % 10 + 48);\n}\n\nconst int N = (int)1e5+5;\nint n, n2, sz[N], ans[N];\nbool vis[N];\nvector< vector<int> > g;\n\nvoid dfs_sz(int u, int p) {\n\tsz[u] = 1, ++n2;\n\tREP(i, 0, SZ(g[u])) {\n\t\tint v = g[u][i];\n\t\tif (vis[v] || v == p) continue;\n\t\tdfs_sz(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nint dfs_center(int u, int p) {\n\tREP(i, 0, SZ(g[u])) {\n\t\tint v = g[u][i];\n\t\tif (vis[v] || v == p) continue;\n\t\tif (sz[v] > n2 / 2) return dfs_center(v, u);\n\t}\n\treturn u;\n}\n\nvoid decompose(int u, int depth) {\n\tn2 = 0;\n\tdfs_sz(u, 0);\n\tint mid = dfs_center(u, 0);\n\tans[mid] = depth, vis[mid] = true;\n\tREP(i, 0, SZ(g[mid])) {\n\t\tint v = g[mid][i];\n\t\tif (vis[v]) continue;\n\t\tdecompose(v, depth + 1);\n\t}\n}\n\nint main() {\n\tnext_int(n);\n\tg.resize(n + 1);\n\tREP(i, 1, n) {\n\t\tint u, v;\n\t\tnext_int(u), next_int(v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdecompose(1, 0);\n\tprintf(\"%d\", *max_element(ans + 1, ans + n + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 123456;\n\nint n, foo[N], key[N], answer;\nvector<int> adj[N];\n\nvoid dfs(int x, int f) {\n  int bar = 0;\n  for (auto y : adj[x]) {\n    if (y != f) {\n      dfs(y, x);\n      bar |= foo[x] & foo[y];\n      foo[x] |= foo[y];\n    }\n  }\n  if (!foo[x]) {\n    key[x] = 0;\n    foo[x] = 1;\n  } else {\n    while ((1 << key[x]) <= bar || (foo[x] >> key[x] & 1)) {\n      ++key[x];\n    }\n    for (int i = 0; i < key[x]; ++i) {\n      foo[x] -= (foo[x] >> i & 1) << i;\n    }\n    foo[x] |= 1 << key[x];\n    answer = max(answer, key[x]);\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 1, x, y; i < n; ++i) {\n    cin >> x >> y;\n    adj[x].push_back(y);\n    adj[y].push_back(x);\n  }\n  dfs(1, 0);\n  cout << answer << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic vector<int> adj[100005];\nint ans = 0;\n\nint dp(int u, int p){\n\tint cnt[20];\n\tfill(cnt,cnt+20,0);\n\tfor(int v : adj[u]){\n\t\tif(v == p) continue;\n\t\tint mask = dp(v, u);\n\t\tfor(int i = 0;i < 20;i++){\n\t\t\tif(((1 << i) & mask)) cnt[i]++;\n\t\t}\n\t}\n\t\n\tint bit = 19;\n\tfor(;bit >= 0 && cnt[bit] <= 1;bit--) continue;\n\tfor(bit++;cnt[bit] > 0;bit++) continue;\n\tans = max(ans,bit);\n\tint mask = 1 << bit;\n\tfor(int i = bit;i < 19;i++){\n\t\tif(cnt[i] > 0) mask |= (1 << i);\n\t}\n\n\treturn mask;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n; cin >> n;\n\tfor(int i = 1;i < n;i++){\n\t\tint a, b; cin >> a >> b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t} \n\tdp(1,0);\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define sz(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define pb push_back\n///////////////////////\n\nint const N = 3e5 + 41;\nint const M = 25;\n\nint n;\nint d[N];\nvector<int> e[N];\n\nint dfs(int u, int p){\n\tint atleastOne = 0;\n\tint atleastTwo = 0;\n\trep(i, 0, sz(e[u])){\n\t\tint to = e[u][i];\n\t\tif(to == p) continue;\n\t\tint res = dfs(to, u);\n\t\tatleastTwo|= (atleastOne & res);\n\t\tatleastOne |= res;\n\t}\n\tint ret;\n\trep(i, 0, M){\n\t\tif( ((1<<i) > atleastTwo) && !(atleastOne&(1<<i)) ){\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tint result = (1 << ret);\n\trep(i, ret, M){\n\t\tresult |= ((1 << i) & atleastOne);\n\t}\n\n\treturn d[u] = result;\n}\n\nvoid solve(){\n\tcin >> n;\n\trep(i, 0, n-1){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u;--v;\n\t\te[u].pb(v);\n\t\te[v].pb(u);\n\t}\n\tint ansMask = dfs(0, 0);\n\tint ans = -1;\n\twhile(ansMask){\n\t\t++ans;\n\t\tansMask /= 2;\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n#ifdef _DEBUG\n\tfreopen(\"input.txt\",\"r\",stdin);\n\tfreopen(\"output.txt\",\"w\",stdout);\n#endif\n\n\tsolve();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int   N   = 1e5 + 1;\n\nvector<int> g[N];\n\nbool vis[N];\nint  nCh[N], n;\n\nvoid dfs(int u,int p)   {\n    nCh[u] = 1;\n    for(int v : g[u])\n    if(v != p && !vis[v])   {\n        dfs(v,u);\n        nCh[u] += nCh[v];\n    }\n}\nint lead(int u,int p,int R) {\n    for(int v : g[u])\n        if(!vis[v] && v != p && nCh[v] > nCh[R] / 2)\n            return lead(v,u,R);\n    return u;\n}\n\nint ans = 0;\n\nvoid decompose(int u,int h) {\n    ans = max(ans,h);\n    dfs(u,0);\n    int C = lead(u,0,u);\n    vis[C] = 1;\n    for(int v : g[C])\n        if(!vis[v])\n            decompose(v,h + 1);\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1 ; i < n ; ++i)    {\n        int x, y;   cin >> x >> y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    decompose(1,0);\n\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define pii pair<int, int>\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define ll long long \n#define ull unsigned long long \n#define ld long double\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n \n#define y1 what\n\nusing namespace std;\n \nconst int N = (int) 1e5 + 10;\nconst int M = (int) 101;\nconst ll big =  (1LL << 51);\nconst ll LINF = (ll) 2e18;\nconst int INF = (int) 1e9 + 7;\nconst int INF1 = (int) 1e9 + 3;\nconst double EPS = (double) 1e-6;\nconst double PI =  3.14159265359;\n\nint n;\nvector<int> v[N];\nint dp[N];\nint ans;\n\nvoid dfs(int x, int p = -1) {\n  vector<int> cnt(20, 0);\n  for (auto it : v[x]) {\n    if (it == p)\n      continue;\n    dfs(it, x);\n    for (int i = 0; i < 20; i++) {\n      cnt[i] += (dp[it] >> i) % 2;\n    }\n  }\n  int mx = -1;\n  for (int i = 0; i < 20; i++) {\n    if (cnt[i] > 1) {\n      mx = max(mx, i);\n    }\n  }\n  for (int i = mx + 1; ; i++) {\n    if (!cnt[i]) {\n      ans = max(ans, i);\n      dp[x] |= (1 << i);\n      mx = i;\n      break;\n    }\n  }\n  for (int i = mx + 1; i < 20; i++) {\n    if (cnt[i] == 1) {\n      dp[x] |= (1 << i);\n    }\n  }\n  //cout << x << \" \" << dp[x] << \"\\n\";\n}\n\nint main() {\n    #define fn \"balls\"\n    #ifdef witch\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    #else\n//        freopen(fn\".in\", \"r\", stdin);\n//        freopen(fn\".out\", \"w\", stdout);\n    #endif\n    srand(time(0));\n    cin >> n;\n    for (int i = 1, x, y; i < n; i++) {\n      cin >> x >> y;\n      v[x].pb(y);\n      v[y].pb(x);\n    }\n    dfs(1);\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++) assert(used[i]);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    //break;\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n\n      if(c<0){\n\tused[v]=1;\n\tbelong[v]=t;\n\tcontinue;\n      }\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      \n      for(Int u:G[c]){\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    //break;\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      assert(used[i]);\n      //if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n//very good problem\nvector<int>edge[100005];\nint n;\nint dfs(int v,int u){\n\tint cnt[20]={}; vector<int>vec;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(u == edge[v][i]) continue;\n\t\tint y = dfs(edge[v][i],v);\n\t\trep(j,20) if(((y>>j)&1)) cnt[j]++;\n\t\tvec.pb(y);\n\t}\n\tint mx = INF;\n\tfor(int j=19;j>=0;j--){\n\t\tif(cnt[j] == 0) mx=j;\n\t\telse if(cnt[j] >= 2) break;\n\t}\n\tint ret = (1<<mx);\n\tfor(int i=0;i<vec.size();i++){\n\t\tint x = vec[i]/(1<<mx) * (1<<mx);\n\t\tret |= x;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n;\n\trep(i,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\tedge[a].pb(b);\n\t\tedge[b].pb(a);\n\t}\n\tint x = dfs(1,-1);\n\trep(i,20) if(((x>>(19-i))&1)) {cout<<19-i<<endl;return 0;}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 100010;\n\nstruct Edge{ int to, next;} edge[N * 2];\nint head[N], num;\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\n\nint s[N], ans;\n\nvoid dfs(int x, int f)\n{\n\tint tmp = 0;\n\tRepG(i, x) if (v != f){\n\t\tdfs(v, x);\n\t\tint ts = (s[v] & s[x]), t0 = 20;\n\t\tif (ts) {\n\t\t\twhile (!(ts & (1 << t0))) t0 --; \n\t\t\ttmp = max(tmp, t0 + 1);\n\t\t}\n\t\ts[x] |= s[v];\n\t}\n\tfor (int i = tmp; i <= 20; i ++){\n\t\tif (!(s[x] & (1 << i))){\n\t\t\ts[x] |= (1 << i), ans = max(ans, i);\n\t\t\tbreak;\n\t\t}\n\t\telse s[x] ^= (1 << i);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd_edge(a, b); add_edge(b, a);\n\t}\n\t\n\tdfs(1, 0);\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n\n          A FAN OF FIZZYDAVID\n\n*/\n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n#define FILL(a,b) memset((a),(b),sizeof((a)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<LL> vl;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\n\nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n\ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1,typename T2,typename T3,typename T4>\nvoid scf(T1 &x,T2 &y,T3 &z,T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\n#ifdef ONLINE_JUDGE\n#define debug(x,c) ;\n#else\n#define DEBUG\n#define debug(x,c) cerr<<#x<<\"=\"<<x<<c;\n#endif\n\n//---------------------------head----------------------------\n\nconst int N = 1e5 + 100;\nconst int M = 2147483647;\n\nint dp[N];\nvi g[N];\n\nint lowbit(int x){ return x & (-x); }\n\nvoid dfs(int u = 1, int fa = 0)\n{\n    int on = 0, tw = 0;\n    for(int v: g[u]) if(v != fa)\n    {\n        dfs(v, u);\n        tw |= on & dp[v];\n        on |= dp[v];\n    }\n    while(lowbit(tw) != tw) tw ^= lowbit(tw);\n    if(!tw) tw = 1; else tw <<= 1;\n    while(on & tw) tw <<= 1;\n    dp[u] = (on & (M ^ (tw - 1))) | tw;\n    return;\n}\n\norz yjz()\n{\n    int n; scf(n);\n    rep(i, n - 1)\n    {\n        int u, v; scf(u, v);\n        g[u].pb(v); g[v].pb(u);\n    }\n    dfs();\n    nrof(i, 30, 0) if(dp[1] & (1 << i)){ printf(\"%d\\n\",i); fizzydavid ak la }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500000;\nconst int INF = 1<<30;\n\nint n, ans=-INF, tot=1, front[N], bit[N], f[N];\n\nstruct tEdge{\n    int v, next;\n    inline void addEdge(int tmpu, int tmpv){\n        v = tmpv;\n        next = front[tmpu];\n        front[tmpu] = tot;\n    }\n} e[N<<1];\ninline void add(int u, int v){\n    e[++tot].addEdge(u, v);\n    e[++tot].addEdge(v, u);\n}\n\nvoid dfs(int u, int fa){\n    bit[u] = f[u] = 0; int l = 0;\n    for(int i=front[u]; i; i=e[i].next){\n        int v = e[i].v;\n        if(v == fa) continue;\n\n\t\tdfs(v, u);\n        l |= (bit[u] & bit[v]);\n        // 如果bit[u] 和 bit[v] 在 i 位上同时为1, l 在 i 位上也是1\n        // 即如果两个超过两个儿子对于 i 都良好, 则该节点的编号必须超过 i\n        bit[u] |= bit[v];\n    }\n\n    if(!bit[u]) bit[u] = 1;\n    else{\n        while((1<<f[u]) < l || (1<<f[u]) & bit[u]) f[u] ++;\n        //如果2^f[u] < l 或者 bit[u]在f[u]上为1\n        bit[u] = ((bit[u] >> f[u] << f[u]) | (1<<f[u]));\n        //重置bit[u], 去掉f[u]后的位\n    }\n\n    ans = max(ans, f[u]);\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i=1,x,y; i< n; i++){\n        scanf(\"%d%d\", &x, &y);\n        add(x, y);\n    }\n    \n    dfs(1, 0);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nint i,j,k,n,m,x,y,t,b[20];\nint fi[N*2],ne[N*2],la[N*2],a[N*2],w[N];\nint f[N][20],g[N][20];\nvoid add(int x,int y){\n\tk++;a[k]=y;\n\tif (fi[x]==0)fi[x]=k;else ne[la[x]]=k;\n\tla[x]=k;\n}\nvoid dfs(int x,int fa){\n\tw[x]=1;g[x][1]=1;\n\tfor (j=1;j<20;j++)f[x][j]=1;\n\tfor (int i=fi[x];i;i=ne[i])if (a[i]!=fa){\n\t\tdfs(a[i],x);\n\t\tfor (j=1;j<20;j++)f[x][j]&=f[a[i]][j],g[x][j]|=g[a[i]][j];\n\t\tint mx=0;for (j=1;j<20;j++)if (!g[a[i]][j]){mx=j-1;break;}\n\t\tfor (j=w[x];j<20;j++)\n\t\t\tif (f[a[i]][j]||j>mx){\n\t\t\t\tw[x]=max(w[x],j);break;\n\t\t\t}\n\t}\n\tfor (int i=1;i<w[x];i++)f[x][i]=1;g[x][w[x]]=1;f[x][w[x]]=0;\n//\tprintf(\"%d\\n\",x);\n//\tfor (int i=1;i<20;i++)printf(\"%d \",f[x][i]);printf(\"\\n\");\n//\tfor (int i=1;i<20;i++)printf(\"%d \",g[x][i]);printf(\"\\n\");\n//\tprintf(\"---\\n\");\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,-1);\n\tint ans=0;\n\tfor (i=1;i<=n;i++)ans=max(ans,w[i]);\n//\tfor (i=1;i<=n;i++)printf(\"%d \",w[i]);printf(\"\\n\");\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\nconst int maxn = 100010;\n#define pb push_back\n\nvi g[maxn];\n\nint c[maxn];\nint bt[1024 + 2];\n\nint low_bit(int x) { return x & -x; }\nint lg(int x) { return x > 1024 ? 10 + lg(x >> 10) : bt[x]; }\n\nint dfs(int u,int par) {\n\tint val = 0, lim = 0;\n\tfor(auto v: g[u]) if(v != par) {\n\t\tint r = dfs(v, u);\n\t\tlim |= r & val;\n\t\tval |= r;\n\t}\n\tc[u] = 0;\n\twhile((1 << c[u]) <= lim || (val >> c[u] & 1) > 0) ++c[u];\n\tval ^= val & ((1<<c[u]) - 1);\n\tval |= 1 << c[u];\n\treturn val;\n}\n\nint main() {\n\tfor(int i = 0; i <= 10; ++i) bt[1 << i] = i;\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 1; i < n; ++i) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tg[u].pb(v); g[v].pb(u);\n\t}\n\tdfs(1, 0);\n\tcout << *max_element(c + 1, c + n + 1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\n#define F(i , a , b) for(int (i) = (a) ; (i) <= (b) ; (i)++)\n#define pb push_back\n#define ll long long\n#define E(a) cerr << #a << \" = \" << a << '\\n'\n#define X first\n#define Y second\n#define INF 10000000000000\n\nconst int MAX_N = 100000 + 10 , mod = 1000000007;\n\nint n,num[MAX_N],javab,path[MAX_N];\nvector <int> v[MAX_N],ans;\nqueue<int> q;\nbool mark[MAX_N];\n\nint the(int x){\n\tfor(int y : v[x]){\n\t\tif(mark[y] == 0 && num[y] == 2) return y;\n\t\tnum[y]--;\n\t}\n\treturn 0;\n}\nvoid make(int x){\n\tfor(int z : v[x]){\n\t\tif(mark[z] == 1){\n\t\t\tpath[x] = max(path[x],path[z] + 1);\n\t\t}\n\t}\n}\nint32_t main(){\n    \n    //    freopen(\"input.txt\" , \"r\" , stdin);\n    //    freopen(\"output.txt\" , \"w\" , stdout);\n    //    cout << setprecision(10) << fixed;\n    ios::sync_with_stdio(0); cin.tie() ; cout.tie();\n    \n    int x,y;\n    cin >> n;\n    for(int i =0 ; i<n-1 ;i++){\n    \tcin >> x >> y;\n    \tv[x].pb(y);\n    \tv[y].pb(x);\n    \tnum[x]++;\n    \tnum[y]++;\n    }\n    for(int i =1 ; i<=n ; i++){\n    \tif(num[i] == 1) q.push(i),mark[i] = 1,ans.pb(i),num[i]--;\n    }\n    int i = 100;\n    while(ans.size() < n && i){\n\n    \tint x = q.front(),z;\n    \tq.pop();\n    \tz = the(x);\n    \tif(z == 0){\n    \t}\n    \telse{\n    \t\tmark[z] = 1;\n    \t\tq.push(z);\n    \t\tans.pb(z);\n    \t\tnum[z]--;\n    \t}\n    \ti--;\n\n    }\n\n    fill(mark,mark+MAX_N,0);\n    mark[ans[n-1]] = 1;\n    for(int i =n-2 ; i+1 ; i--){\n    \tmake(ans[i]);\n    \tmark[ans[i]] = 1;\n    }\n    for(int i =1 ; i<=n ; i++){\n    \tjavab = max(javab,path[i]);\n    }\n    javab++;\n    cout << ceil(1.0*javab/2);\n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 100100;\n\nvector<int> g[MAX];\n\nint D[MAX];\nint mx;\n\nvoid go(int x, int p, int val, int diff)\n{\n\t//cout<<x<<' '<<val<<' '<<mx<<endl;\n\tif (val == -1)\n\t{\n\t\tmx++;\n\t\tD[x] = mx;\n\t\tdiff = 1;\n\t}\n\telse\n\t{\n\t\tif (val == mx - 1) diff = -1;\n\t\tD[x] = val;\n\t}\n\n\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (to == p) continue;\n\n\t\tgo(to, x, val + diff, diff, mx);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n-1)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\t}\n\n\tgo(0, -1, 0, -1, 0);\n\tint res = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tres = max(res, D[i]);\n\t//\tcout<<i+1<<' '<<D[i]<<endl;\n\t}\n\n\tcout<<res<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\n\nint N;\nvector <int> E[100010];\nint ans, d[100010];\n\nvoid dfs(int x, int fa){\n\tint X = 0;\n\tfor(int e : E[x])if(e != fa){\n\t\tdfs(e, x);\n\t\tX |= d[e];\n\t}\n\td[x] = X + 1;\n\tfor(int i=0;i<20;i++)if(1<<i & d[x])ans = max(ans, i);\n}\n\nvoid solve(){\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<N;i++){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tE[x].pb(y);\n\t\tE[y].pb(x);\n\t}\n\tdfs(1, -1);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\tint Tc = 1; // scanf(\"%d\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nconst int NV=202020;\nint N;\nvector<int> E[NV];\nint ret;\n\nint dfs(int cur,int pre) {\n\tint cnt[32]={};\n\tint mi=-1;\n\tint mask=0,i;\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tint tr = dfs(r,cur);\n\t\tmask |= tr;\n\t\tFOR(i,30) if(mask&(1<<i)) {\n\t\t\tcnt[i]++;\n\t\t\tif(cnt[i]>=2) mi=max(mi,i);\n\t\t}\n\t}\n\tmi++;\n\twhile(cnt[mi]) mi++;\n\tmask |= 1<<mi;\n\tret=max(ret,mi);\n\tmask &= ~((1<<mi)-1);\n\treturn mask;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tdfs(0,-1);\n\tcout<<ret<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100100\nusing namespace std;\nvector<int>G[maxn];\nint n,dp[maxn],len;\nint dfs(int u,int f){\n\tint mx1=0,mx2=0;\n\tfor(int i=0;i<G[u].size();++i)\n\t\tif(G[u][i]!=f){\n\t\t\tint s=dfs(G[u][i],u);\n\t\t\tif(s>mx1)mx2=mx1,mx1=s;\n\t\t\telse if(s>mx2)mx2=s;\n\t\t}\n\tlen=max(len,mx1+mx2+1);\n\treturn mx1+1;\n}\nint cal(int x){\n\tif(x==1)return 0;\n\tif(x<=3)return 1;\n\treturn max(cal((x-1)/2),cal(x-1-(x-1)/2))+1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=2,u,v;i<=n;++i)\n\t\tscanf(\"%d%d\",&u,&v),\n\t\tG[v].push_back(u),\n\t\tG[u].push_back(v);\n\tdfs(1,0);\n\tprintf(\"%d\",cal(len));\n}"
  },
  {
    "language": "C++",
    "code": "//cwystc <--> 陈威宇是天才  --by cwy\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst double PI=acos(-1);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n#define travel_set(it,a) for (set<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_map(it,a) for (map<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_vec(it,a) for (vector<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define p(x) cout << x << endl;\n#define def cout << \"find\" << endl;\n#define what_is(x) cout << #x << \" is \" << x << endl;\ntemplate <class T>T sqr(T x){return x*x;}\ntemplate <class T>T alex(T x){return (x>0)?x:-x;}\ntemplate <class T>void read(T&x){\n\tx=0;T f=1;char ch=getchar();\n\twhile ((ch<48||ch>57)&&ch!=45)ch=getchar();\n\tif (ch==45)f=-1,ch=getchar();\n\twhile (ch>=48&&ch<=57)x=x*10+ch-48,ch=getchar();\n\tx*=f;\n}\n\n//-------------------------------------------------head-------------------------------------------------\n\n#define maxn 100005\nint n;\nvector<int>E[maxn];\nint sign[maxn];bool vis[maxn];\nbool gbit(int x,int bit){return (x>>bit)&1;}\nvoid dfs(int x){\n\tvis[x]=true;int _sign=0;int s=0;\n\tRep(i,0,E[x].size())if (!vis[E[x][i]]){\n\t\tdfs(E[x][i]);s|=(_sign&sign[E[x][i]]);_sign|=sign[E[x][i]];\n\t}\n\tRep(i,(int)log2(s),20)if (gbit(_sign,i)==0){_sign=_sign>>i<<i|(1<<i);break;}\n\tsign[x]=_sign;\n}\nint main(){\n\t// freopen(\"D.in\",\"r\",stdin);\n\t// freopen(\"D.out\",\"w\",stdout);\n\tread(n);\n\tRep(i,1,n){\n\t\tint x,y;read(x);read(y);\n\t\tE[x].pb(y);E[y].pb(x);\n\t}\n\tdfs(1);int res=0;\n\trep(i,1,n)res=max(res,sign[i]);/*\n\tcerr << (int)log2(1<<0) << endl;\n\tcerr << (int)log2(1<<1) << endl;\n\tcerr << (int)log2(1<<2) << endl;\n\tcerr << (int)log2(1<<3) << endl;\n\tcerr << (int)log2(1<<4) << endl;\n\tcerr << (int)log2(1<<5) << endl;\n\tcerr << (int)log2(1<<6) << endl;\n\tcerr << (int)log2(1<<7) << endl;\n\tcerr << (int)log2(1<<8) << endl;\n\tcerr << (int)log2(1<<9) << endl;\n\tcerr << (int)log2(1<<10) << endl;\n\tcerr << (int)log2(1<<11) << endl;\n\tcerr << (int)log2(1<<12) << endl;\n\tcerr << (int)log2(1<<13) << endl;\n\tcerr << (int)log2(1<<14) << endl;\n\tcerr << (int)log2(1<<15) << endl;\n\tcerr << (int)log2(1<<16) << endl;\n\tcerr << (int)log2(1<<17) << endl;\n\tcerr << (int)log2(1<<18) << endl;\n\tcerr << (int)log2(1<<19) << endl;*/\n\tres=(int)log2(res);printf(\"%d\\n\",res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\n\nconst int N = 100100;\nVI edges[N];\n\nll dp[N];\n\nvoid dfs(int v, int par) {\n  VL ch;\n  ll orl = 0;\n  for (auto w: edges[v]) {\n    if (w == par) { continue; }\n    dfs(w, v);\n    ch.push_back(dp[w]);\n    orl |= dp[w];\n  }\n  vector<int> hb(64);\n  REP(b, 0, 64) {\n    int cnt = 0;\n    for (ll t: ch) {\n      if (t & (1LL << b)) {\n\tcnt += 1;\n      }\n    }\n    hb[b] = cnt;\n  }\n  int c = 0;\n  REP(b, 0, 64) {\n    if (hb[b] >= 2) {\n      c = b + 1;\n    }\n  }\n  int t = -1;\n  REP(b, c, 64) {\n    if (hb[b] == 0) {\n      t = b;\n      break;\n    }\n  }\n  ll mask = 1LL << t;\n  dp[v] = (orl & ~(mask - 1)) | mask;\n}\n\n// This was implemented after the author read the editorial.\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n - 1) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    edges[a].push_back(b);\n    edges[b].push_back(a);\n  }\n  dfs(0, -1);\n  int b = 0;\n  REP(i, 0, 64) {\n    if (dp[0] & 1LL << i) {\n      b = i;\n    }\n  }\n  cout << b << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MaxN = 100010;\nconst int MaxLabel = 20;\n\nint n, ans, f[MaxN]; vector<int> edge[MaxN];\n\nvoid dfs(int x, int fa) {\n  int all = 0;\n  for (int y : edge[x]) {\n    if (y == fa)\n      continue;\n    dfs(y, x);\n    all |= (f[x] & f[y]);\n    f[x] |= f[y];\n  }\n  \n  int t = 0;\n  while ((1 << t) <= all && f[x] >> t & 1)\n    ++t;\n  ans = max(ans, t);\n  f[x] >>= t;\n  f[x] <<= t;\n  f[x] |= (1 << t);\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1, u, v; i < n; i++) {\n    scanf(\"%d%d\", &u, &v);\n    edge[u].push_back(v);\n    edge[v].push_back(u);\n  }\n  \n  dfs(1, 0);\n  cout << ans << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <iostream>\n\nusing namespace std;\n#define MAX_N 100000\n\nint N;\nvector<int> gp[MAX_N+1];\nint lv[MAX_N+1];\n\nvoid dfs(int x){\n\tfor(int i=0; i<gp[x].size(); i++){\n\t\tif(lv[gp[x][i]]==0){\n\t\t\tlv[gp[x][i]] = lv[x]+1;\n\t\t\tdfs(gp[x][i]);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &N);\n\tfor(int i=0; i<N-1; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgp[a].push_back(b); gp[b].push_back(a);\n\t}\n\tdfs(1);\n\tint u = 1;\n\tfor(int i=2; i<=N; i++){\n\t\tif(lv[i]>=lv[u]){\n\t\t\tu = i;\n\t\t}\n\t}\n\tfor(int i=1; i<=N; i++){\n\t\tlv[i] = 0;\n\t}\n\tdfs(u);\n\tint l = 0;\n\tfor(int i=1; i<=N; i++){\n\t\tl = max(l, lv[i]);\n\t}\n\tint k = 0, ans = 0;\n\twhile(1){\n\t\tif(k>=l){\n\t\t\tprintf(\"%d\", ans);\n\t\t\tbreak;\n\t\t}\n\t\tk*=2; k+=2; ans++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<19)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\twhile((f[u]>>mn&1) || ((1<<mn)<=mx))++mn;\n\tf[u]=(f[u]>>mn<<mn)|(1<<mn);\n\tans=max(ans,mn);\n\t// for(int i=18;;--i)\n\t// \tif(i<mn || (mx>>i&1))\n\t// \t{\n\t// \t\t++i;\n\t// \t\t// f[u]&=S-((1<<i)-1);\n\t// \t\t// f[u]|=1<<i;\n\t// \t\tf[u]=(f[u]>>i<<i)|(1<<i);\n\t// \t\tans=max(ans,i);\n\t// \t\t// cerr<<u<<\" \"<<i<<endl;\n\t// \t\tbreak;\n\t// \t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n4 8\n8 9\n9 10\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100010;\nint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\nvoid addedge(int b, int e) {\n\tnxt[++tot] = head[b]; to[head[b] = tot] = e;\n\tnxt[++tot] = head[e]; to[head[e] = tot] = b;\n}\nint n;\nint dfs(int u, int fa = 0) {\n\tint pre = 0, hav = 0;\n\tfor (int i = head[u]; i; i = nxt[i]) if (to[i] != fa) {\n\t\tint t = dfs(to[i], u);\n\t\thav |= pre & t;\n\t\tpre |= t;\n\t}\n\tint p = hav ? std::__lg(hav) + 1 : 0;\n\tp = __builtin_ctz((pre >> p) + 1);\n\tpre ^= pre & (1 << p) - 1;\n\treturn pre | 1 << p;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, addedge(t1, t2);\n\tstd::cout << std::__lg(dfs(1)) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//cwystc <--> 陈威宇是天才  --by cwy\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst double PI=acos(-1);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n#define travel_set(it,a) for (set<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_map(it,a) for (map<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_vec(it,a) for (vector<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define p(x) cout << x << endl;\n#define def cout << \"find\" << endl;\n#define what_is(x) cout << #x << \" is \" << x << endl;\ntemplate <class T>T sqr(T x){return x*x;}\ntemplate <class T>T alex(T x){return (x>0)?x:-x;}\ntemplate <class T>void read(T&x){\n\tx=0;T f=1;char ch=getchar();\n\twhile ((ch<48||ch>57)&&ch!=45)ch=getchar();\n\tif (ch==45)f=-1,ch=getchar();\n\twhile (ch>=48&&ch<=57)x=x*10+ch-48,ch=getchar();\n\tx*=f;\n}\n\n//-------------------------------------------------head-------------------------------------------------\n\n#define maxn 100005\nint n;\nvector<int>E[maxn];\nint sign[maxn];bool vis[maxn];\nbool gbit(int x,int bit){return (x>>bit)&1;}\nvoid dfs(int x){\n\tvis[x]=true;int _sign=0;int s=0;\n\tRep(i,0,E[x].size())if (!vis[E[x][i]]){\n\t\tdfs(E[x][i]);s|=(_sign&sign[E[x][i]]);_sign^=sign[E[x][i]];\n\t}\n\tRep(i,(int)log2(s),20){_sign^=(1<<i);if (gbit(_sign,i)==1)break;}\n\tsign[x]=_sign;\n}\nint main(){\n\t// freopen(\"D.in\",\"r\",stdin);\n\t// freopen(\"D.out\",\"w\",stdout);\n\tread(n);\n\tRep(i,1,n){\n\t\tint x,y;read(x);read(y);\n\t\tE[x].pb(y);E[y].pb(x);\n\t}\n\tdfs(1);int res=0;\n\trep(i,1,n)res=max(res,sign[i]);/*\n\tcerr << (int)log2(1<<0) << endl;\n\tcerr << (int)log2(1<<1) << endl;\n\tcerr << (int)log2(1<<2) << endl;\n\tcerr << (int)log2(1<<3) << endl;\n\tcerr << (int)log2(1<<4) << endl;\n\tcerr << (int)log2(1<<5) << endl;\n\tcerr << (int)log2(1<<6) << endl;\n\tcerr << (int)log2(1<<7) << endl;\n\tcerr << (int)log2(1<<8) << endl;\n\tcerr << (int)log2(1<<9) << endl;\n\tcerr << (int)log2(1<<10) << endl;\n\tcerr << (int)log2(1<<11) << endl;\n\tcerr << (int)log2(1<<12) << endl;\n\tcerr << (int)log2(1<<13) << endl;\n\tcerr << (int)log2(1<<14) << endl;\n\tcerr << (int)log2(1<<15) << endl;\n\tcerr << (int)log2(1<<16) << endl;\n\tcerr << (int)log2(1<<17) << endl;\n\tcerr << (int)log2(1<<18) << endl;\n\tcerr << (int)log2(1<<19) << endl;*/\n\tres=(int)log2(res);printf(\"%d\\n\",res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N];\nint mask [MAX_N];\n\nvoid dfs (int u, int p) {\n  int chb = 0;\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      dfs(nxt, u);\n      if (mask[u] & mask[nxt]) {\n        chb = max(chb, 31 - __builtin_clz(mask[u] & mask[nxt]));\n      }\n      mask[u] |= mask[nxt];\n    }\n  }\n\n  while (mask[u] & 1 << chb) {\n    chb++;\n  }\n\n  mask[u] += 1 << chb;\n  mask[u] -= mask[u] % (1 << chb);\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  dfs(1, 0);\n\n  cout << 31 - __builtin_clz(mask[1]) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[100001];\nint h[100001];\nll dp[100001];\n\nvoid dfs(int u, int p)\n{\n\tif(p==-1) h[u]=0;\n\telse h[u]=h[p]+1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tif(adj[u][i]==p) continue;\n\t\tdfs(adj[u][i],u);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tdp[1] = 2;\n\tfor(int i = 2; i <= 60; i++)\n\t{\n\t\tdp[i] = (dp[i-1]*2+1);\n\t}\n\tint n; cin>>n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tdfs(0,-1);\n\tint best = 0; int idx = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t\tidx=i;\n\t\t}\n\t}\n\tdfs(idx,-1);\n\tbest=0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t}\n\t}\n\tfor(int i = 1; i <= 60; i++)\n\t{\n\t\tif(best<=dp[i])\n\t\t{\n\t\t\tcout<<i<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++) assert(used[i]);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    //break;\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n\n      if(c<0){\n\tused[v]=1;\n\tbelong[v]=t;\n\tcontinue;\n      }\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      \n      for(Int u:G[c]){\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    //break;\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      assert(used[i]);\n      //if(!used[i]) exit(0);\n      assert(0<=belong[i]&&belong[i]<(int)T.size());\n      //if(belong[i]<0) exit(0);\n      //if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define efo(i,q) for(int i=A[q];i;i=B[i][0])\nusing namespace std;\nconst int N=100500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n,ans;\nint B[2*N][2],A[N],B0;\nint f[N];\nint er[N];\nvoid link(int q,int w)\n{\n\tB[++B0][0]=A[q],A[q]=B0,B[B0][1]=w;\n\tB[++B0][0]=A[w],A[w]=B0,B[B0][1]=q;\n}\nvoid dfs(int q,int fa)\n{\n\tint t=0;\n\tefo(i,q)if(B[i][1]!=fa)\n\t{\n\t\tdfs(B[i][1],q);\n\t\tt=max(t,f[q]&f[B[i][1]]);\n\t\tf[q]|=f[B[i][1]];\n\t}\n\tfo(i,1,22)if(er[i]>t&&!(f[q]&er[i])){t=i;break;}\n\tans=max(ans,t);\n\t// printf(\"%d %d\\n\",q,t);\n\tf[q]=(f[q]&(er[23]-er[t]))|er[t];\n}\nint main()\n{\n\tint q,w;\n\ter[1]=1;fo(i,2,23)er[i]=er[i-1]<<1;\n\tread(n);\n\tfo(i,1,n-1)read(q),read(w),link(q,w);\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint n,w[N],head[N],nxt[N];\nvoid add(int f,int t){\n\tstatic int cnt=0;\n\tw[++cnt]=t;\n\tnxt[cnt]=head[f];\n\thead[f]=cnt;\n}\n//问题等价于给点标号,若k(u)=k(v),则(u,v)路径上存在一点x使得k(x)>k(v) \n//贪心选择最小的标号 \nint S[N],ans;\nvoid dfs(int x,int fa){\n\tint K=0;\n\tfor (int i=head[x];i;i=nxt[i]){\n\t\tint v=w[i];\n\t\tif (v==fa) continue;\n\t\tdfs(v,x);\n\t\tfor (int i=0;i<30;i++)\n\t\tif ((S[x]&S[v])>>i&1) K=max(K,i+1);\n\t\tS[x]|=S[v];\n\t}\n\twhile (S[x]>>K&1) K++;\n\tans=max(ans,K);\n\tS[x]&=~((1<<K)-1);\n\tS[x]|=(1<<K);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);add(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#define travel(x, y, i) for (int i = fir[x], y = e[i].to; i; i = e[i].nxt, y = e[i].to)\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nstruct edge {\n  int nxt, to;\n} e[N << 1];\nint fir[N], cnt = 0;\nint n, dp[N];\n\ninline void addedge(int x, int y) {\n  e[++ cnt] = (edge) { fir[x], y }; fir[x] = cnt;\n}\n\ninline int Log(int x) {\n  int res = 0;\n  if (x >= (1 << 16)) x >>= 16, res += 16;\n  if (x >= (1 << 8)) x >>= 8, res += 8;\n  if (x >= (1 << 4)) x >>= 4, res += 4;\n  if (x >= (1 << 2)) x >>= 2, res += 2;\n  if (x >= (1 << 1)) x >>= 1, res += 1;\n  return res;\n}\n\ninline void Dfs(int x, int f) {\n  int msk = 0, t = 0;\n  travel(x, y, i) {\n    if (y == f) continue;\n    Dfs(y, x);\n    int tmp = dp[y];\n    for (int j = 17; j > t; j --)\n      if ((msk & tmp) & (1 << j)) t = j;\n    msk |= tmp;\n  }\n  while (msk & (1 << t)) t ++;\n  msk |= (1 << t) - 1;\n  msk ^= (1 << t) - 1;\n  msk |= (1 << t);\n  dp[x] = msk;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1, x, y; i < n; i ++) {\n    scanf(\"%d%d\", &x, &y);\n    addedge(x, y); addedge(y, x);\n  }\n  Dfs(1, 0);\n  printf(\"%d\\n\", Log(dp[1]));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Author       : Sun YaoFeng\n//============================================================================\n\n//#pragma \tcomment(linker, \"/STACK:100240000,100240000\")\n//#include\t<cstdio>\n//#include\t<cstdlib>\n//#include\t<cstring>\n//#include\t<algorithm>\n\n#include\t<bits/stdc++.h>\n\nusing\tnamespace\tstd;\n\n#define DB\t\tdouble\n#define\tlf\t\telse if\n#define I64\t\tlong long\n#define\tRd()\t(rand()<<15|rand())\n#define For(i,a,b)\tfor(int i=a,lim=b;i<=lim;i++)\n#define Rep(i,a,b)\tfor(int i=a,lim=b;i>=lim;i--)\n\n#define\tfi\tfirst\n#define se\tsecond\n#define MK\tmake_pair\n#define PA\tpair<int, int>\n\n//#define\tmin(a,b)\t((a)<(b)?(a):(b))\n//#define\tmax(a,b)\t((a)<(b)?(b):(a))\n\n#define\tCH\t(ch=getchar())\nint\t\tIN()\t{\n\t\tint x= 0, f= 0, ch;\n\t\tfor\t(; CH < '0' || ch > '9';)\tf= (ch == '-');\n\t\tfor\t(; ch >= '0' && ch <= '9'; CH)\tx= x*10 + ch -'0';\n\t\treturn\tf? -x : x;\n}\n\n#define n\t100005\n\nint\t\tN, D, Rt, Ans, st[n], Dep[n];\n\nstruct\tLin{\n\t\tint v, next;\n}E[n << 1];\n\nvoid\tLink(int u, int v)\t{\n\t\tE[++ D]= (Lin){v, st[u]};\tst[u]= D;\n\t\tE[++ D]= (Lin){u, st[v]};\tst[v]= D;\n}\n\nvoid\tDFS(int u, int f)\t{\n\t\tDep[u]= Dep[f] + 1;\n\t\t\n\t\tfor (int i= st[u], v; i; i= E[i].next)\n\t\t\tif\t((v= E[i].v) != f)\tDFS(v, u);\n}\n\nint\t\tmain(int argc, char* argv[]){\n\t\tN= IN();\n\t\tFor(i, 2, N)\tLink(IN(), IN());\n\t\t\n\t\tDFS(1, 0);\n\t\t\n\t\tRt= 1;\n\t\tFor(i, 2, N)\tif\t(Dep[i] > Dep[Rt])\tRt= i;\n\t\t\n\t\tDFS(Rt, 0);\n\t\t\n\t\tint\tD= 0;\n\t\tFor(i, 1, N)\tD= max(D, Dep[i]);\n\t\t\n\t\tfor (; D > 1; D>>= 1)\tAns++;\n\t\tcout << Ans + 1 << endl;\n\t\t\n\t\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-13;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nvector<int>g[110000];\nint dp[110000];\n\nint dfs(int a,int b){\n\tint tmp=0;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tif(b==g[a][i])continue;\n\t\ttmp|=dfs(g[a][i],a);\n\t}\n\ttmp++;\n\treturn dp[a]=tmp;\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a-1;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t}\n\tdfs(0,-1);\n\tint ret=0;\n\tfor(int i=0;i<a;i++)ret=max(ret,dp[i]);\n\tint ans=0;\n\twhile(ret){\n\t\tret/=2;ans++;\n\t}\n\tprintf(\"%d\\n\",ans-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<vector>\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nconst int M = 1e9 + 7;\nconst ll MLL = 1e18L + 9;\n#pragma unused(M)\n#pragma unused(MLL)\n#ifdef LOCAL\n#include\"basic.hpp\"\n#else\ntemplate <class... T> void printl(T&&...){ }\ntemplate <class... T> void printc(T&&...){ }\ntemplate <class... T> void prints(T&&...){ }\ntemplate <class... T> void printd(T&&...){ }\n#endif\n\nstruct Node{\n    vector<Node*> dests;\n    void add(Node* n){\n        dests.push_back(n);\n    }\n    void add2(Node* n){\n        add(n);\n        n->add(this);\n    }\n    pair<int, Node*> dfs(Node* from = nullptr){\n        pair<int, Node*> ret = {0, this};\n        for(Node* d : dests){\n            if(d == from){ continue; }\n            auto p = d -> dfs(this);\n            p.first++;\n            ret = max(ret, p);\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int n; cin >> n;\n    vector<Node> nodes(n);\n    for(int i=0;i<n;i++){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        nodes[a].add2(&nodes[b]);\n    }\n    auto f1 = nodes[0].dfs();\n    auto f2 = f1.second->dfs();\n    int d = f2.first;\n    printd(d);\n    int num = 0, ans = 0;\n    for(int i=1;i<M;i++){\n        num = num * 2 + 2;\n        prints(num, d, i);\n        if(num >= d){ ans = i; break; }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::max;\nusing std::min;\nconst int N=1e5+10;\n\nstruct Edge{ int to,next; }way[N<<1];\nint n,dep[N],num[N],tot,ans,val[N],cnt[N][21];\n\nvoid Build(int a,int b) { way[++tot]=(Edge){b,num[a]}; num[a]=tot; }\n\nvoid Init() {\n\tscanf(\"%d\",&n);\n\tint a,b;\n\tfor (int i=2;i<=n;++i) {\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tBuild(a,b);\n\t\tBuild(b,a);\n\t}\n}\n\nvoid Dfs(int x,int fa) {\n\tfor (int i=num[x];i;i=way[i].next) {\n\t\tint v=way[i].to;\n\t\tif (v==fa) continue;\n\t\tDfs(v,x);\n\t\tfor (int i=val[v];i<=20;++i) cnt[x][i]+=cnt[v][i];\n\t}\n\tint value=0;\n\tfor (int i=0;i<=19;++i) if (cnt[x][i]>=2) value=i+1;\n\twhile (cnt[x][value]) ++value;\n\tval[x]=value; cnt[x][value]++;\n\tans=max(ans,value);\n}\n\nvoid Solve() {\n\tDfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PII;\nconst int N = 100010;\nint n,x,y;\nvector<int> v[N],f[N];\n\nvoid dfs(int x,int fa){\n\tint t;\n\tvector<int> tmp;\n\tfor(int i=0;i<v[x].size();i++) if((t=v[x][i])!=fa){\n\t\tdfs(t,x);\n\t\tfor(int j=0;j<f[t].size();j++){\n\t\t\tif(j>=tmp.size()) tmp.push_back(f[t][j]); \n\t\t\telse tmp[j] += f[t][j];\n\t\t}\n\t}\n\tint l = tmp.size();\n\tfor(int i = tmp.size()-1;i>=0;i--){\n\t\tif(tmp[i]==0) l = i;\n\t\tif(tmp[i]>1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(l>=tmp.size()) tmp.push_back(1); else tmp[l]=1;\n\tfor(int i=l-1;i>=0;i--) tmp[i] =0;\n\tf[x] = tmp;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",f[1].size()-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\nstruct edge { int to,nxt; } e[N<<1];\nint tot=1,h[N];\nvoid adde(int u,int v) {\n    e[++tot]=(edge){v,h[u]};h[u]=tot;\n    e[++tot]=(edge){u,h[v]};h[v]=tot;\n}\nint n,ans=0,f[N][30];\nvoid dfs(int u,int fa) {\n    for(int i=h[u];i;i=e[i].nxt) {\n        int v=e[i].to; if(v==fa) continue;\n        dfs(v,u);\n        for(int j=20;j>=0;j--) f[u][j]+=f[v][j];\n    }\n    int p=0;\n    for(int i=20;i>=0;i--)\n        if(f[u][i]>1) { p=i+1;break; }\n    while(f[u][p]) p++;\n    f[u][p]++;\n    for(int j=0;j<p;j++) f[u][j]=0;\n    ans=max(ans,p);\n}\nint main() {\n    cin>>n;\n    for(int i=1,u,v;i<n;i++) u=gi(),v=gi(),adde(u,v);\n    dfs(1,0);printf(\"%d\\n\",ans);\n    return 0;\n}\n//orzgzy\n//鸡贼明年进队超稳\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define ll long long \n#define ret return\n#define PB push_back\n#define lc 2 * v\n#define rc 2 * v + 1\n#define mid (s + e) / 2\n#define pii pair <int,  int>\n#define pll pair <long long , long long>  \n#define FAST ios::sync_with_stdio(false);cin.tie(0);\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n\nconst int maxn = 3e6 + 50 , K = 25;\nvector <int> edges[maxn];\nll a[maxn] , n , ans;\n\nvoid dfs(int v, int p = -1) {\n    int b = 0;\n    for (auto u : edges[v]){\n        if (u == p) continue;\n        dfs(u , v);\n        for (int i = b; i < K; ++i) {\n            if ((a[v] & a[u]) & (1 << i)) {\n                b = i + 1;\n            }\n        }\n        a[v] |= a[u];\n        while (a[v] & (1 << b)) {\n            b++;\n        }\n    }\n    for (int i = 0; i < b; ++i) {\n        if (a[v] & (1 << i)) {\n            a[v] ^= (1 << i);\n        }\n    }\n    a[v] |= (1 << b);\n}\nint main() {\n    FAST\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        edges[u].PB(v);\n        edges[v].PB(u);\n    }\n    dfs(1);\n    for (int i = 0; i < K; ++i) {\n        if (a[1] & (1 << i)) {\n            ans = i;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#pragma comment(linker, \"/stack:16777216\")\n#include <string>\n#include <vector>\n#include <map>\n#include <list>\n#include <iterator>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <stack>\n#include <deque>\n#include <cmath>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#include <time.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\n//const int MAX = 1000007;\n\nint n, a, b;\nvector<int> g[100000];\nbool used[100000];\nbool fix[100000];\nPII resw = MP(-1,-1);\nint qwe = -1;\nvector<int> R;\n\nvoid dfs(int v, int p = -1, int len = 0)\n{\n    R.PB(v);\n    if (len > resw.second)\n    {\n        resw = MP(v,len);\n        qwe = R[SZ(R)/2];\n    }\n    FOR (i,0,g[v].size())\n    if (!fix[g[v][i]] && g[v][i] != p)\n    {\n        dfs(g[v][i],v,len+1);\n    }\n    R.pop_back();\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //ios::sync_with_stdio(false); cin.tie(0);\n    //freopen(\"/Users/Taras/Downloads/big_top.txt\", \"r\", stdin);\n    //freopen(\"/Users/Taras/Downloads/mout.txt\", \"w\", stdout);\n    \n    cin >> n;\n    FOR (i,1,n)\n    {\n        cin >> a >> b;\n        a--; b--;\n        g[a].PB(b);\n        g[b].PB(a);\n    }\n    vector<int> v, cv;\n    v.PB(0);\n    int res = 0;\n    while (v.size())\n    {\n        res++;\n        FOR (i,0,v.size())\n        {\n            //cout << v[i]<<endl;\n            fix[v[i]] = true;\n            resw = MP(-1,-1);\n            dfs(v[i]);\n            int fr1 = resw.first;\n            resw = MP(-1,-1);\n            dfs(fr1);\n            FOR (j,0,g[qwe].size())\n            if (!fix[g[qwe][j]])\n                cv.PB(g[qwe][j]);\n        }\n        //cout << \"-----\"<<endl;\n        v = cv;\n        cv.clear();\n    }\n    cout << res-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = (int) 1e5 + 10;\nvector<vector<int> > es;\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  es = vector<vector<int> >(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int s, t;\n    scanf(\"%d%d\", &s, &t);\n    --s, --t;\n    es[s].pb(t), es[t].pb(s);\n  }\n  return 1;\n}\n\nint dist[maxn];\n\nvoid dfs(int v, int p = -1) {\n  for (int u : es[v]) {\n    if (u == p) {\n      continue;\n    }\n    dist[u] = dist[v] + 1;\n    dfs(u, v);\n  }\n}\n\nvoid solve() {\n  dist[0] = 0;\n  dfs(0);\n  int v = max_element(dist, dist + n) - dist;\n\n  dist[v] = 0;\n  dfs(v);\n\n  int res = *max_element(dist, dist + n);\n  printf(\"%d\\n\", 31 - __builtin_clz(res + 1));\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\tdown[v] = 0;\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {//cerr << \"solving \" << v + 1 << '\\n';\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tif(vec.size() == 1)\n\t\treturn 0;\n\tup[v] = 0;\n\tfind_up(v);\n\t//for (int u: vec)\n\t//\tcerr << u + 1 << \" -> \" << up[u] << ' ' << down[u] << '\\n';\n\tint mini = N, cen;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\t//cerr << mini << \" cen = \" << cen + 1 << '\\n';\n\tmark[cen] = true;\n\tint maxi = 0;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<int>> G(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tqueue<int> q;\n\tvector<bool> used(n);\n\tint r = n;\n\trep(i, n) {\n\t\tif (G[i].size() == 1) {\n\t\t\tq.push(i);\n\t\t\tused[i] = true;\n\t\t\tr--;\n\t\t}\n\t}\n\tint tmp = 0;\n\twhile (true) {\n\t\tif (r == 0) {\n\t\t\tvector<bool> exi(n,false);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint id = q.front(); q.pop();\n\t\t\t\texi[id] = true;\n\t\t\t}\n\t\t\tbool g = false;\n\t\t\trep(j, n)if (exi[j]) {\n\t\t\t\trep(i, G[j].size()) {\n\t\t\t\t\tint to = G[j][i]; if (exi[to]) {\n\t\t\t\t\t\tg=true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (g)tmp++;\n\t\t\tbreak;\n\t\t}\n\t\ttmp++;\n\t\tint len = q.size();\n\t\trep (aa,len) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\trep(j, G[id].size()) {\n\t\t\t\tint to = G[id][j];\n\t\t\t\tif (used[to])continue;\n\t\t\t\tused[to] = true; r--; q.push(to);\n\t\t\t}\n\t\t}\n\t}\n\tint s = 1; int k = 1;\n\twhile (true) {\n\t\tif (tmp <= s)break;\n\t\ts = s * 2 + 1; k++;\n\t}\n\t//cout << tmp << endl;\n\tcout << k << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(9);\n\tsolve();\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N];\n\nvoid dfs (int u, int d, int p, pair<int, int> &ans) { // <dist, v>\n  ans = max(ans, make_pair(d, u));\n  for (int nxt : adj[u]) {\n    if (nxt != p) {\n      dfs(nxt, d + 1, u, ans);\n    }\n  }\n}\n\npair<int, int> farthest (int u) {\n  pair<int, int> ans = make_pair(0, u);\n  dfs(u, 0, 0, ans);\n  return ans;\n}\n\nconst int MAX_LG = 20;\nint maxd [MAX_LG];\n\nint main () {  \n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  auto pr = farthest(1);\n  int diam = farthest(pr.second).first;\n  \n  int ans = 0;\n  while (diam > 0) {\n    diam -= 2;\n    diam = (diam + 1) / 2;\n    ans++;\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint solve(int pos, int pre, vector<vector<int> > &g) {\n\tint req = 0, mx = 0;\n\tvector<int> lens;\n\tfor (int i : g[pos]) {\n\t\tif (i == pre) continue;\n\t\tint res = solve(i, pos, g);\n\t\tint res_req = 0;\n\t\tint res_len = 0;\n\t\twhile (2 << res_len < res) ++res_len;\n\t\twhile ((res >> res_req) & 1) ++res_req;\n\t\treq = max(req, res_req);\n\t\tmx = max(mx, res);\n\t\tlens.push_back(res_len);\n\t}\n\tsort(lens.begin(), lens.end(), greater<int>());\n\tif (lens.size() >= 2) req = max(req, lens[1] + 1);\n\t++mx;\n\twhile (req != 0 && (mx & (1 << (req - 1)))) ++mx;\n\treturn mx;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint n, a, b;\n\tcin >> n;\n\tvector<vector<int> > g(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcin >> a >> b; --a, --b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint ret = solve(0, -1, g);\n\tint ans = 0;\n\twhile (2 << ans <= ret) ++ans;\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstatic vector<int> e[2][100000];\n \nint recon(int i,int p,bool b,int &N)\n{\n  //printf(\"%d %d %d\\n\",i,p,N);\n  int t=N;\n  e[!b][t]=vector<int>(0);\n  N++;\n  int S=0;\n  for(int x=0;x<e[b][i].size();x++){\n    if(e[b][i][x].size()==1){\n      S++;\n    }\n  }\n  for(int x=0;x<e[b][i].size();x++){\n    int j=e[b][i][x];\n    if(j==p)continue;\n    if(e[b][j].size()==2&&S>=e[b][i].size()-1){\n      int k=(e[b][j][0]==i?e[b][j][1]:e[b][j][0]);\n      int c=recon(k,j,b,N);\n      e[!b][t].push_back(c);\n      e[!b][c].push_back(t);\n    }\n    else if(e[b][j].size()>=2){\n      int c=recon(j,i,b,N);\n      e[!b][t].push_back(c);\n      e[!b][c].push_back(t);\n    }\n  }\n  return t;\n}\n \nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  bool b=0;\n  for(int i=0;i<n-1;i++){\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    u--,v--;\n    e[b][u].push_back(v);\n    e[b][v].push_back(u);\n  }\n  int N=n,t=0;\n  while(N>1){\n    //printf(\"%d\\n\",N);\n    t++;\n    int r;\n    for(int i=0;i<N;i++){\n      if(e[b][i].size()==1){\n\tr=e[b][i][0];\n\tbreak;\n      }\n    }\n    N=0;\n    recon(r,-1,b,N);\n    b=!b;\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<vector>\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nconst int M = 1e9 + 7;\nconst ll MLL = 1e18L + 9;\n#pragma unused(M)\n#pragma unused(MLL)\n#ifdef LOCAL\n#include\"basic.hpp\"\n#else\ntemplate <class... T> void printl(T&&...){ }\ntemplate <class... T> void printc(T&&...){ }\ntemplate <class... T> void prints(T&&...){ }\n#endif\n\nstruct Node{\n    vector<Node*> dests;\n    void add(Node* n){\n        dests.push_back(n);\n    }\n    void add2(Node* n){\n        add(n);\n        n->add(this);\n    }\n    pair<int, Node*> dfs(Node* from = nullptr){\n        pair<int, Node*> ret = {0, this};\n        for(Node* d : dests){\n            if(d == from){ continue; }\n            auto p = d -> dfs(this);\n            p.first++;\n            ret = max(ret, p);\n        }\n        return ret;\n    }\n};\n\nint main(){\n    int n; cin >> n;\n    vector<Node> nodes(n);\n    for(int i=0;i<n;i++){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        nodes[a].add2(&nodes[b]);\n    }\n    auto f1 = nodes[0].dfs();\n    auto f2 = f1.second->dfs();\n    int d = f2.first;\n    printd(d);\n    int num = 0, ans = 0;\n    for(int i=1;i<M;i++){\n        num = num * 2 + 2;\n        prints(num, d, i);\n        if(num >= d){ ans = i; break; }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define maxn 100005\nusing namespace std;\nint n,ans,f[maxn][30];\nstruct node { int v; node *nxt; } edge[maxn*2],*head[maxn],*ncnt;\nvoid addedge(int u,int v)\n{\n\tncnt++;\n\tncnt->v=v,ncnt->nxt=head[u];\n\thead[u]=ncnt;\n}\nvoid dfs(int u,int fa)\n{\n\tfor(node *p=head[u];p;p=p->nxt)\n\t{\n\t\tint v=p->v;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u); \n\t\tfor(int i=0;i<=20;i++) f[u][i]+=f[v][i];\n\t}\n\tint p=0;\n\tfor(int i=20;i>=0;i--)\n\t\tif(f[u][i]>1) { p=i+1; break; }\n\twhile(f[u][p]) p++;\n\tf[u][p]++;\n\tfor(int i=0;i<p;i++) f[u][i]=0;\n\tans=max(ans,p);\n}\nint main()\n{\n\tncnt=&edge[0];\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);++i)\n#define rep11(i,n) for(int i=1;i<(int)(n);++i)\n#define repo(i,o,n) for(int i=o;i<(int)(n);++i)\n#define repm(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define sperase(v,n) (v).erase(remove(all(v), n), (v).end())\n#define vdelete(v) (v).erase(unique(all(v)), (v).end())\n#define pb(n) push_back(n)\n#define mp make_pair\n#define MOD 1000000007\n#define INF LONG_LONG_MAX\n\nint n,a,b,depth[100000],s,cnt,hoge=1,ans;\nvector<int> v[100000];\n\nint kr(int a,int now) {\n    if (depth[a]) return depth[a];\n    depth[a] = now;\n    for(auto i : v[a]) {\n        int tmp = kr(i,now+1);\n        if (cnt < tmp) {\n            cnt = tmp;\n            s = i;\n        }\n    }\n    return now;\n}\n\nsigned main() {\n    cin >> n;\n    rep(i,n-1) {\n        cin >> a >> b;\n        --a, --b;\n        v[a].pb(b);\n        v[b].pb(a);\n    }\n    kr(0,1);\n    rep(i,n) depth[i] = 0;\n    kr(s,1);\n    while(true) {\n        if (hoge > cnt) {\n            cout << ans << endl;\n            return 0;\n        }\n        ++ans;\n        hoge = hoge*2+1;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>  \n#include<cstdio>  \n#include<cstring>  \n#include<cmath>  \nusing namespace std;  \nconst int N=50000+5;  \nstruct Edge{int to,next;}e[N<<1];  \nint head[N],cnt;  \nvoid ins(int u,int v){  \n    e[++cnt]=(Edge){v,head[u]};head[u]=cnt;  \n}  \nint f[N],bin[30],s[N],m,c[30];  \nvoid dp(int u,int fa){  \n     int sv=0,cu=0,son=0;  \n     for(int i=head[u];i;i=e[i].next){  \n        int v=e[i].to;if(v==fa)continue;  \n        dp(v,u);  \n        sv|=s[v];  \n        son++;  \n     }  \n     if(!son){  \n        f[u]=0;  \n        s[u]=1;  \n        return;  \n     }  \n     memset(c,0,sizeof(c));  \n     for(int i=head[u];i;i=e[i].next)  \n     if(e[i].to!=fa)  \n     for(int j=0;j<m;j++)  \n     if(s[e[i].to]&(1<<j))c[j]++;  \n     if(son>1)  \n     for(int i=m-1;i>=0;i--)  \n     if(c[i]>=2){  \n        cu=i+1;  \n        break;  \n     }  \n     for(int i=cu;i<m;i++)  \n     if(!(sv&(1<<i))){  \n        cu=i;  \n        break;  \n     }  \n     s[u]=((sv>>cu)|1)<<cu;  \n     f[u]=cu;  \n     for(int i=head[u];i;i=e[i].next)  \n     if(e[i].to!=fa)  \n     f[u]=max(f[u],f[e[i].to]);  \n}  \nint main(){  \n    //freopen(\"a.in\",\"r\",stdin);  \n    //freopen(\"a.out\",\"w\",stdout);   \n    int n;scanf(\"%d\",&n);m=log2(n)+1;  \n    for(int i=1;i<n;i++){  \n         int u,v;scanf(\"%d%d\",&u,&v);  \n         ins(u,v);ins(v,u);  \n    }  \n    dp(1,0);  \n    printf(\"%d\\n\",f[1]);  \n    return 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define Forr(i, j, k) for(int i = j; i >= k; i--)\n#define pb push_back\n\nusing namespace std;\n\nconst int N = 100010;\n\nvector<int> G[N];\nint n, mask[N];\n\nvoid DFS(int o, int f){\n\tint label = 0, s = 0;\n\tfor(int v : G[o]){\n\t\tif(v == f) continue;\n\t\tDFS(v, o);\n\t\tlabel |= s & mask[v];\n\t\ts |= mask[v];\n\t}\n\tlabel = label << 1 | 1;\n\tForr(i, 30, 0) if(label & (1 << i))\n\t\tFor(j, i, 30) if(!(s & (1 << j))){\n\t\t\tmask[o] = (s ^ (s & ((1 << j) - 1))) | (1 << j);\n\t\t\treturn;\n\t\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFor(i, 2, n){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v), G[v].pb(u);\n\t}\n\tDFS(1, 0);\n\tForr(i, 30, 0) if(mask[1] & (1 << i)){\n\t\tprintf(\"%d\\n\", i);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=100005;\nint n,h[N],cnt,id[N],S[N],hg[65536],mx[65536],ans;\nstruct edge{int v,n;} e[N<<1];\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nvoid addedge(int u,int v)\n{\n\te[cnt]=(edge){v,h[u]},h[u]=cnt++;\n\te[cnt]=(edge){u,h[v]},h[v]=cnt++;\n}\n\nint high(int s)\n{\n\tif(!s) return -1;\n\tif(!(s&65535)) return 16+hg[s>>16];\n\treturn hg[s&65535];\n}\n\nint mex(int s)\n{\n\tif((s&65535)==65535) return 16+mx[s>>16];\n\treturn mx[s&65535];\n}\n\nvoid dfs(int x,int fa)\n{\n\tint s0=0,s1=0;\n\tfor(int i=h[x]; i!=-1; i=e[i].n)\n\t\tif(e[i].v!=fa)\n\t\t{\n\t\t\tdfs(e[i].v,x);\n\t\t\ts0|=S[e[i].v]&s1,s1|=S[e[i].v];\n\t\t}\n\tint p=high(s0);\n\tid[x]=mex(s1>>p+1)+p+1;\n\tS[x]=(s1>>id[x]<<id[x])|(1<<id[x]);\n}\n\nint main()\n{\n\tn=getint();\n\tmemset(h,-1,sizeof(h));\n\trep(i,0,15) hg[1<<i]=i;\n\trep(i,1,65535) if(!hg[i]) hg[i]=hg[i^(i&-i)];\n\trep(i,0,65535) rep(j,0,15) if(!(i&(1<<j))) {mx[i]=j; break;}\n\trep(i,1,n-1) addedge(getint(),getint());\n\tdfs(1,0);\n\trep(i,1,n) ans=max(ans,id[i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    break;\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 9;\nvector<int>V[N];\n\nint n, f[N];\n// f[i] ±íÊ¾ÒÔiÎª¸ùµÄ×ÓÊ÷ÓÐÄÄÐ©±êºÅµÄµãÐèÒª½â¾öÆ¥ÅäÎÊÌâ \nvoid Dfs (int u, int fa) {\n\tint all = 0, s = 0;\n\tfor (auto v : V[u]) if (v != fa) {\n\t\tDfs(v, u);\n\t\tall |= (s & f[v]);\n\t\ts |= f[v];\n\t}\n\tall = all << 1 | 1;\n\tfor (int i = 30; ~i; --i) if (all >> i & 1) {\n\t\twhile (s >> i & 1) ++i;\n\t\tf[u] = (s ^ (s & ((1 << i) - 1))) | (1 << i);\n\t\treturn ;\n\t}\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, a, b; i < n; ++i) scanf(\"%d%d\", &a, &b), V[a].push_back(b), V[b].push_back(a);\n\tDfs(1, 0);\n\tfor (int i=30;i>=0;i--) if (f[1]>>i&1) return printf(\"%d\\n\",i),0;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n\tvector<vector<UL>> E;\n\n\tUL ans = 0;\n\tunsigned Solve2(UL p, UL pre) {\n\t\tUL F = 0;\n\t\tfor (auto next : E[p]) {\n\t\t\tif (next == pre) continue;\n\t\t\tUL d = Solve2(next, p);\n\t\t\tans = max(ans, F + d + 1);\n\t\t\tF = max(F, d);\n\t\t}\n\t\treturn F + 1;\n\t}\n\n\tvoid Solve() {\n\t\tUL N; cin >> N;\n\t\tE.resize(N);\n\t\trep(i, N - 1) {\n\t\t\tUL a, b; cin >> a >> b; a--; b--;\n\t\t\tE[a].push_back(b); E[b].push_back(a);\n\t\t}\n\t\tUL ans = Solve2(0, (UL)-1);\n\t\tUL M = 1;\n\t\tUL uninity = 0;\n\t\twhile (M < ans) { M = M * 2 + 1; uninity++; }\n\t\tcout << uninity << endl;\n\t}\n\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n \nconst int N = 1e5 + 7;\n \nvector <int> ad[N];\nint n;\n\npair <int, int> dfs(int v, int p) {\n\tpair <int, int> mx = {v, 1};\n\tfor (auto u: ad[v])\n\t\tif (u != p) {\n\t\t\tauto t = dfs(u, v);\n\t\t\tt.second++;\n\t\t\tif (t.second > mx.second)\n\t\t\t\tmx = t;\n\t\t}\n\treturn mx;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tad[v].push_back(u);\n\t\tad[u].push_back(v);\n\t}\n\tint v = dfs(1, 0).first;\n\tint d = dfs(v, 0).second;\n\tcout << ((int)log2(d));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\nstruct edge{\n\tint k,next;\n}e[N<<1];\nint n,home[N],cnt=-1,lg2[N<<1];\nvoid add(int x,int y){\n\tcnt++;\n\te[cnt].k=y;\n\te[cnt].next=home[x];\n\thome[x]=cnt;\n}\nint f[N],sum[25];\nvoid dfs(int k,int F){\n\tmemset(sum,0,sizeof(sum));\n\tf[k]=1;\n\tfor(int i=home[k];~i;i=e[i].next)if(e[i].k!=F){\n\t\tdfs(e[i].k,k);\n\t}\n\tfor(int i=home[k];~i;i=e[i].next)if(e[i].k!=F){\n\t\tint g=f[e[i].k],t;\n\t\twhile(g) t=g&-g,sum[lg2[t]]++,g-=t;\n\t}\n\tfor(int i=20;~i;i--){\n\t\tif(sum[i]){\n\t\t\tif(sum[i]>1){\n\t\t\t\tf[k]|=(1<<i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf[k]|=(1<<i);\n\t\t}\n\t}\n}\nint main(){\n\tmemset(home,-1,sizeof(home));\n\tfor(int i=2;i<=200000;i++) lg2[i]=lg2[i>>1]+1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1,x,y;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tint ans=-1;\n\twhile(f[1]) f[1]>>=1,ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 101010\n\ttypedef long long ll;\n\ttypedef double db;\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n\tvoid file()\n\t{\n\t\t#ifdef NTFOrz\n\t\tfreopen(\"a.in\",\"r\",stdin);\n\t\t#endif\n\t}\n\tinline void chktime()\n\t{\n\t\t#ifdef NTFOrz\n\t\tcout<<(clock()-t)/1000.0<<'\\n';\n\t\t#endif\n\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nint n;\nstruct hh{int t,nxt;}edge[sz<<1];\nint head[sz],ecnt;\nvoid make_edge(int f,int t)\n{\n\tedge[++ecnt]=(hh){t,head[f]};\n\thead[f]=ecnt;\n\tedge[++ecnt]=(hh){f,head[t]};\n\thead[t]=ecnt;\n}\n\nint len;\nint dp[sz];\nvoid dfs(int x,int fa)\n{\n\t#define v edge[i].t\n\tdp[x]=0;\n\tgo(x) if (v!=fa) dfs(v,x),chkmax(len,dp[x]+dp[v]+1),chkmax(dp[x],dp[v]+1);\n\t#undef v\n}\n\nint main()\n{\n\tfile();\n\tread(n);\n\tint x,y;\n\trep(i,1,n-1) read(x,y),make_edge(x,y);\n\tdfs(1,0);\n\tint l=0,r=0,ans=0;\n\twhile (r<len) l=r+1,r=l*2,++ans;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nint N;\nvector <int> E[100010];\nint D[100010], ans;\n\nvoid dfs(int x, int fa) {\n\tvector <int> v;\n\tint c[20] = {};\n\tfor(int e : E[x]) if(e != fa) {\n\t\tdfs(e, x);\n\t\trep(i, 20) if(1<<i & D[e]) ++c[i];\n\t}\n\tint f = -1;\n\tfor(int i=19;i>=0;i--) {\n\t\tif(c[i] >= 2) break;\n\t\tif(c[i] == 0) f = i;\n\t}\n\tans = max(ans, f);\n\tfor(int i=19;i>=f;i--) if(c[i]) D[x] |= 1<<i;\n\tD[x] |= 1<<f;\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\trep(i, N-1) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tE[x].pb(y);\n\t\tE[y].pb(x);\n\t}\n\tdfs(1, -1);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 100100;\n\nvector<int> g[MAX];\n\nint D[MAX];\nint mx;\n\nvoid go(int x, int p, int val, int diff)\n{\n\t//cout<<x<<' '<<val<<' '<<mx<<endl;\n\tif (val == -1)\n\t{\n\t\tmx++;\n\t\tD[x] = mx;\n\t\tdiff = 1;\n\t}\n\telse\n\t{\n\t\tif (val == mx - 1) diff = -1;\n\t\tD[x] = val;\n\t}\n\n\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (to == p) continue;\n\n\t\tgo(to, x, val + diff, diff, mx);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n-1)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\t}\nmx = 0;\n\tgo(0, -1, 0, -1);\n\tint res = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tres = max(res, D[i]);\n\t//\tcout<<i+1<<' '<<D[i]<<endl;\n\t}\n\n\tcout<<res<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N;\nmap<int, vector<int>> to;\nvector<int> st;\nset<int> leaf;\nint n_visited;\n\nvoid solve(int uni)\n{\n    if (uni > 0) solve(uni - 1);\n    set<int> new_leaf;\n    for (auto v : leaf) if (st[v] < 0)\n    {\n        st[v] = uni;\n        n_visited++;\n        for (auto nx : to[v]) if (st[nx] < 0) new_leaf.insert(nx);\n    }\n    leaf = new_leaf;\n    if (uni > 0) solve(uni - 1);\n}\n\nint main()\n{\n    cin >> N;\n    REP(_, N - 1)\n    {\n        int a, b;\n        cin >> a >> b;\n        to[a - 1].push_back(b - 1);\n        to[b - 1].push_back(a - 1);\n    }\n    set<int> leaf_init;\n    REP(i, N) if (to[i].size() == 1) leaf_init.insert(i);\n\n    int l = -1, r = 18;\n    while (r - l > 1)\n    {\n        int c = (l + r) / 2;\n        st.assign(N, -1);\n        n_visited = 0;\n        leaf = leaf_init;\n        solve(c);\n        int cou = 0;\n        for (auto v : st) cou += (v == c);\n        ((n_visited == N and cou <= 1) ? r : l) = c;\n    }\n    cout << r << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 100010;\n\nstruct Edge{ int to, next;} edge[N * 2];\nint head[N], num;\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\n\nint s[N], ans;\n\nvoid dfs(int x, int f)\n{\n\tint tmp = 0;\n\tRepG(i, x) if (v != f){\n\t\tdfs(v, x);\n\t\tint ts = (s[v] & s[x]), t0 = 20;\n\t\tif (ts) {\n\t\t\twhile (!(ts & (1 << t0))) t0 --; \n\t\t\ttmp = max(tmp, t0 + 1);\n\t\t}\n\t\ts[x] |= s[v];\n\t}\n\tif (tmp) Rep0(i, tmp - 1) if (s[x] & (1 << i)) s[x] ^= (1 << i);\n\tfor (int i = tmp; i <= 20; i ++){\n\t\tif (!(s[x] & (1 << i))){\n\t\t\ts[x] |= (1 << i), ans = max(ans, i);\n\t\t\tbreak;\n\t\t}\n\t\telse s[x] ^= (1 << i);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadd_edge(a, b); add_edge(b, a);\n\t}\n\t\n\tdfs(1, 0);\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nstd::vector<int> adj[100005];\nint app[100005][25];\nint dfs(int u, int fa = -1)\n{\n\tint ans = 0;\n\tfor (int v : adj[u])\n\t{\n\t\tif (v == fa)\n\t\t\tcontinue;\n\t\tans = std::max(ans, dfs(v, u));\n\t\tfor (int j = 0; j < 20; j++)\n\t\t\tapp[u][j] += app[v][j];\n\t}\n\tint res = 0;\n\tfor (int i = 19; i >= 0; i--)\n\t{\n\t\tif (app[u][i] > 1)\n\t\t{\n\t\t\tres = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (app[u][res])\n\t\tres++;\n\tfor (int j = 0; j < res; j++)\n\t\tapp[u][j] = 0;\n\tapp[u][res] = 1;\n\treturn std::max(ans, res);\n}\nint main()\n{\n\t// freopen(\"AGC009-D.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadj[--u].pb(--v);\n\t\tadj[v].pb(u);\n\t}\n\tprintf(\"%d\\n\", dfs(0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    break;\n    \n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    //break;\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\ntypedef int Weight;\nWeight INF = 1000000000;\nstruct Edge{ int src, dest; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\n\nvoid bfs01(Graph &g, vector<int> &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; int v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint logg(ll n) {\n  if (n == 1) return 0;\n  return logg(n / 2) + 1;\n}\n\nbool visited[128000];\nll dfs(const Graph &g, int v) {\n  visited[v] = true;\n  vector<ll> vec;\n  for (auto i: g[v]) {\n    if (visited[i.dest]) continue;\n    vec.push_back(dfs(g, i.dest));\n  }\n  sort(ALL(vec));\n  if (vec.empty()) return 1;\n  if (vec.size() == 1) {\n    return vec.back() + 1;\n  }\n  ll res = vec.back() + 1;\n  // cout << log(res)\n  if (logg(res) == logg(res + vec[vec.size() - 2])) {\n    if (res % 2 == 1) return res + 1;\n    return res;\n  }\n  return ll(1) << (logg(res) + 1);\n}\n\nvoid solve(ll N, vector<ll> a, vector<ll> b) {\n  Graph g(N);\n  REP(i,N-1) {\n    add_edge(g, a[i] - 1, b[i] - 1, 1);\n    add_edge(g, b[i] - 1, a[i] - 1, 1);\n  }\n  ll res = dfs(g, 0);\n  // cout << res << endl;\n  cout << logg(res) << endl;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll N;\n\tscanf(\"%lld\", &N);\n\tvector<ll> b((N-1)-1+1);\n\tvector<ll> a((N-1)-1+1);\n\tfor (int i = 0 ; i <= (N-1)-1 ; i++) {\n\t  scanf(\"%lld\", &a[i]);\n\t  scanf(\"%lld\", &b[i]);\n\t}\n\tsolve(N, a, b);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//make_tuple emplace_back next_permutation push_back make_pair second first\n\n#if MYDEBUG\n#define DBG(...) {string dst__=#__VA_ARGS__;dbgsplit(dst__);stringstream dss__; dss__<<dst__; debug(dss__,__VA_ARGS__);}\n#else\n#define DBG(...)\n#endif\nvoid debug(stringstream& ds){cerr<<endl;return;}\ntemplate<typename F, typename... R>void debug(stringstream& ds,const F& f, const R&... r){string n; ds>>n; cerr<< n <<'='<<f<<' '; debug(ds,r...);}\nvoid dbgsplit(string &s){int l=s.length(),n=0;for(int i=0; i<l; ++i){if(s[i]=='(')++n;if(s[i]==')')--n;if(s[i]==','&&!n)s[i]=' ';}}\nusing LL = long long;\nconstexpr long long LINF=334ll<<53; constexpr int INF=15<<26; constexpr long long MOD=1E9+7;\n\nstruct Edge{\n    int from,to;\n};\nusing Graph = vector<vector<Edge>>;\n\n//<f,s>\npair<int,int> dfs(int par ,int cur,Graph &t){\n    if((int)t[cur].size()==1 and t[cur][0].to==par){\n        return{0,1};\n    }\n    int sum=0,prd=0,f=0;\n    for(auto &e: t[cur]){\n        if(e.to!= par){\n            auto sub = dfs(cur,e.to,t);\n            f=max(f,sub.first);\n            prd |= sum&sub.second;\n            sum |= sub.second;\n        }\n    }\n    int res=0;\n    while(prd&(1<<res))res++;\n    while(sum&(1<<res))res++;\n    return {max(f,res),(((sum>>res)^1)<<res)};\n}\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    Graph t(n);\n    for(int i=0; i<n-1; ++i){\n        int a,b;\n        cin >> a >>b;\n        --a;--b;\n        t[a].push_back({a,b});\n        t[b].push_back({b,a});\n    }\n    cout << dfs(-1,0,t).first<<\"\\n\";\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint S[N][22] , ans[N] , n , m , x , y , res , Tay[N][22];\n\nvector <int> G[N];\n\nvoid dfs(int x , int f) {\n  for(int i = 0;i < (int) G[x].size();++ i) {\n    int V = G[x][i];\n    if(V == f)  continue;\n    dfs(V , x);\n    ++ S[x][ans[V]];\n    for(int i = ans[V] + 1;i < 22;++ i) S[x][i] += S[V][i];\n  }\n  \n  for(int i = 21;i >= 0;-- i) if(S[x][i]){\n      if(S[x][i] >= 2) {\n        for(int j = i;j >= 0;-- j) Tay[x][j] = 1;\n        break;\n      }\n      else Tay[x][i] = 1;\n  }\n  for(ans[x] = 0;Tay[x][ans[x]];++ ans[x]);\n  res = max(res , ans[x]);\n}\n\nint main(void) {\n  //freopen(\"jas.in\" , \"r\" , stdin);\n  //freopen(\"jas.out\" , \"w\" , stdout);\n  cin.sync_with_stdio(0);\n  cin >> n;\n  for(int i = 1;i < n;++ i) {\n    cin >> x >> y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  dfs(1 , 0);\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n//#define rf(x) (x)=0;while(*p<48)im=*p=='-';while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);if(im)(x)=-(x);\n#define pb push_back\n#define eb emplace_back\n#define sz(V) ((int)(V).size())\n#define allv(V) ((V).begin()),((V).end())\n#define befv(V) ((V)[(sz(V)-2)])\n#define sorv(V) sort(allv(V))\n#define revv(V) reverse(allv(V))\n#define univ(V) (V).erase(unique(allv(V)),(V).end())\n#define clv(V) (V).clear()\n#define upmin(a,b) (a)=min((a),(b))\n#define upmax(a,b) (a)=max((a),(b))\n#define rb(x) ((x)&(-(x)))\n#define cb(x) (x)=(!(x))\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\n#define INFST (0x7f7f7f7f)\n#define INFLLST (0x7f7f7f7f7f7f7f7fll)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ld, ld> pdd;\ntypedef complex<ld> base;\nconst ld EPS = (ld)1e-7;\nconst ld PI = acos(0) * 2;\nbool isZero(const ld& x) { return abs(x) <= EPS; }\nint sign(const ld& x) { return isZero(x) ? 0 : (0 < x ? 1 : -1); }\nll gcd(ll a, ll b) { for(;b;a%=b,swap(a,b)){} return abs(a); }\npll operator + (const pll& a, const pll& b) { return pll(a.first+b.first, a.second+b.second); }\npll operator - (const pll& a, const pll& b) { return pll(a.first-b.first, a.second-b.second); }\npll operator * (const pll& a, const ll& b) { return pll(a.first*b, a.second*b); }\nll operator * (const pll& a, const pll& b) { return a.first*b.second - b.first*a.second; }\nll ccw(const pll& a, const pll& b, const pll& c) { return a*b + b*c + c*a; }\nvoid fg(vector<int> G[], int a, int b) { G[a].pb(b); G[b].pb(a); }\nvoid fg(vector<pii> G[], int a, int b, int c) { G[a].pb({b, c}); G[b].pb({a, c}); }\n\nconst int MAXN = 100005;\n\nvector<int> G[MAXN];\n\nint dp[3][MAXN];\nint dep[MAXN];\n\nint A[MAXN], B[MAXN];\n\nint N, Ans = INF;\n\nvoid f(int i) {\n\tint a[3] = {-1, -1, -1};\n\tfor(int v : G[i]) if(!dep[v]) {\n\t\tdep[v] = dep[i] + 1;\n\t\tf(v);\n\t\tupmax(dp[1][i], dp[0][v]);\n\t\tupmax(dp[2][i], dp[1][v]);\n\t\t\n\t\ta[2] = dp[0][v];\n\t\tsort(a, a+3);\n\t\treverse(a, a+3);\n\t}\n\tif(a[0] < 0) return;\n\n\tint &ret = dp[0][i];\n\tret = dp[2][i] + 1;\n\t//printf(\"i=%d, ret=%d\\n\", i, ret);\n\n\tfor(int v : G[i]) if(dep[i] < dep[v]) {\n\t\tint x = (a[0] == dp[0][v] ? a[1] : a[0]);\n\t\tupmin(ret, max(x, dp[2][v]) + 1);\n\t\t//printf(\"i=%d, v=%d :: x=%d, dp=%d\\n\", i, v, x, dp[2][v]);\n\t}\n}\n\nvoid g(int i, int x) {\n\tint a[3] = {-1, -1, -1};\n\tfor(int v : G[i]) if(dep[i] < dep[v]) {\n\t\ta[2] = dp[0][v];\n\t\tsort(a, a+3);\n\t\treverse(a, a+3);\n\t}\n\tif(a[0] < 0) {\n\t\tupmin(Ans, max(0, x));\n\t\treturn;\n\t}\n\tfor(int v : G[i]) if(dep[i] < dep[v]) {\n\t\tint t = (a[0] == dp[0][v] ? a[1] : a[0]);\n\t\tg(v, max(t, x) + 1);\n\t\tupmin(Ans, dp[0][v] + max(t, x) + 1);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\tfor(int i = 1; i < N; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tfg(G, A[i], B[i]);\n\t}\n\n\t{\n\t\tdep[1] = 1;\n\t\tf(1);\n\t}\n\n/*\n\tfor(int i = 1; i <= N; i++)\n\t\tprintf(\"%d : %d\\n\", i, dp[0][i]);\n*/\n\t\n\tAns = dp[0][1];\n\n\tg(1, -1);\n\n\tcout << dp[0][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=1e5+3;\nint n,lg2,f[mn],gra,beg[mn],to[mn*2],nex[mn*2];\nvoid ins(int u,int v){\n\tto[++gra]=v;\n\tnex[gra]=beg[u];\n\tbeg[u]=gra;\n}\nvoid dfs(int p,int q){\n\tfr(i,p)if(to[i]!=q){\n\t\tdfs(to[i],p);\n\t\tf[p]|=f[to[i]];\n\t}\n\tfo(i,0,lg2)if(!(f[p]&(1<<i)))\n\t\t{f[p]=((f[p]>>i)+1)<<i;return;}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tins(u,v);\n\t\tins(v,u);\n\t}\n\tlg2=log(n)/log(2);\n\tdfs(1,0);\n\tfd(i,lg2,0)if(f[1]&(1<<i)){printf(\"%d\",i);return 0;}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst ll mask = 0xAAAAAAAA;\nint n, ans;\nvector<vi> e;\nll rec(int c, int p){\n\tll s = 0, t = 0;\n\tfor(int i : e[c]) if(i != p){\n\t\tll x = rec(i, c);\n\t\ts |= x;\n\t\tt += x;\n\t\tt &= ~((t & mask) >> 1);\n\t}\n\tt &= mask;\n\tint l = t ? 64 - __builtin_clzll(t) : 0;\n\tl = __builtin_ctzll((s | (s & ~mask) << 1 | (1ll << l) - 1) + 1);\n\t\n\tans = max(ans, l / 2);\n\ts |= 1ll <<l;\n\ts &= ~((1ll << l) - 1);\n\treturn s;\n}\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tcin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\trec(0, 0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,flag[100100][20],ans;\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[200100],*tp=pool,*fst[100100];\n\nvoid dfs(int x,int fa)\n{\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->v!=fa)\n            dfs(i->v,x);\n    int w=0;\n    repu(i,0,19)\n        if (flag[x][i]>1)\n            w=i+1;\n    for (; flag[x][w]; ++w);\n    ans=max(ans,w),++flag[fa][w];\n    repu(i,w+1,19)\n        if (flag[x][i])\n            ++flag[fa][i];\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n-1)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        *tp=(edge){v,fst[u]},fst[u]=tp++;\n        *tp=(edge){u,fst[v]},fst[v]=tp++;\n    }\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvector<int> G[1 << 17];\nint n;\nint mostfar(int root,int &fin) {\n\tint ret = -1;\n\tvector<bool> used(n, false);\n\tqueue<int> q; q.push(root); used[root] = true;\n\twhile (!q.empty()) {\n\t\tint len = q.size();\n\t\trep(aa, len) {\n\t\t\tint v = q.front(); q.pop(); fin = v;\n\t\t\trep(j, G[v].size()) {\n\t\t\t\tint to = G[v][j];\n\t\t\t\tif (!used[to]) {\n\t\t\t\t\tused[to] = true;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tret++;\n\t}\n\treturn ret;\n}\nvoid solve() {\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint le, ri; mostfar(0, le);\n\tint d = mostfar(le, ri);\n\tint s = 2; int k = 1;\n\twhile (true) {\n\t\tif (d <= s)break;\n\t\ts = s * 2 + 2; k++;\n\t}\n\tcout << k << endl;\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\nvvi g;\n\nint dfs(int v,int p){\n\tvi a;\n\tfor(auto u:g[v]) if(u!=p) a.push_back(dfs(u,v));\n\tint m=a.size(),t;\n\tif(!m) return 1;\n\tfor(int i=30;i>=0;i--){\n\t\tint cnt=0;\n\t\tfor(auto j:a) if(j&1<<i) cnt++;\n\t\tif(cnt>1) break;\n\t\tif(!cnt) t=1<<i;\n\t}\n\tint res=t;\n\tfor(auto i:a) res|=i;\n\treturn (res|t-1)-t+1;\n}\n\nint main(){\n\tcin>>n;\n\tg=vvi(n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint t=dfs(0,-1);\n\tfor(int i=30;i>=0;i--) if(t&1<<i){\n\t\tcout<<i<<endl;\n\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\nconst int N=int(1e5)+5;\n\nint n;\n\ninline int bitlen(const int x){\n\tint k=0;\n\tfor(;x>>k;k++);\n\treturn k;\n}\n\nstruct node;\nstruct edge{\n\tnode *ed;\n\tedge *next;\n} E[N<<1],*newE=E;\nstruct node{\n\tedge *son;\n\tnode *pa;\n\tint f;\n\tvoid dfs(){\n\t\tint pre=0,tmp=0;\n\t\tfor(edge *e=son;e;e=e->next) if(e->ed!=pa){\n\t\t\te->ed->pa=this;\n\t\t\te->ed->dfs();\n\t\t\ttmp|=e->ed->f&pre;\n\t\t\tpre|=e->ed->f;\n\t\t}\n\t\tint k=bitlen(tmp);\n\t\tf=((pre>>k)+1)<<k;\n\t}\n} V[N];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\t*newE=(edge){V+y,V[x].son},V[x].son=newE++;\n\t\t*newE=(edge){V+x,V[y].son},V[y].son=newE++;\n\t}\n\tV[1].dfs();\n\tprintf(\"%d\\n\",bitlen(V[1].f)-1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<62;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\nset<int> adj[100009];\nint h[100009];\nint cc[100009];\n\nvoid dfs0(int x,int p){\n\tcc[x]=1;\n\tfor(int i:adj[x]){\n\t\tif(i==p)continue;\n\t\tdfs0(i,x);\n\t\tcc[x]+=cc[i];\n\t}\n}\n\nint dfs1(int x,int p,int tn){\n\tfor(int i:adj[x]){\n\t\tif(i==p)continue;\n\t\tif(2*cc[i]>=tn)return dfs1(i,x,tn);\n\t}\n\treturn x;\n}\n\nvoid decomp(int x,int lv){\n\tdfs0(x,-1);\n\tint r=dfs1(x,-1,cc[x]);\n\th[r]=lv;\n\twhile(SZ(adj[r])){\n\t\tint i=*adj[r].begin();\n\t\tadj[i].erase(r);\n\t\tadj[r].erase(adj[r].begin());\n\t\tdecomp(i,lv+1);\n\t}\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tadj[a].insert(b);adj[b].insert(a);\n\t}\n\tdecomp(0,0);\n\tint ans=0;\n\tREP(i,n)ans=max(ans,h[i]);\n\tprintf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint n;\nvector<int> g[100005];\nint mxb(int a){\n  return 31-__builtin_clz(a);\n}\nint dfs(int v,int p){\n  int mask=0,incr=-1;\n  for(auto to:g[v]){\n    if(to==p) continue;\n    int tmp=dfs(to,v);\n    if(tmp&mask) chmax(incr,mxb(tmp&mask));\n    mask|=tmp;\n  }\n  if(incr==-1) incr=0;\n  for(int i=incr;;++i) if(!(mask>>i&1)){\n    mask|=(1<<i);\n    mask&=~((1<<i)-1);\n    break;\n  }\n  return mask;\n}\n\n\nint main(){\n  cin>>n;\n  REP(i,n-1){\n    int a,b;scanf(\"%d%d\",&a,&b);--a;--b;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n  int res=dfs(0,-1);\n  int ans=0;\n  REP(i,30) if(res>>i&1) ans=i;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\nint c[MX];\n\nP cfs(int v, int d=0, int p=-1) {\n  P res(d,v);\n  for (int u : to[v]) {\n    if (c[u] || u == p) continue;\n    maxs(res, cfs(u,d+1,v));\n  }\n  return res;\n}\nvi vs;\nbool vfs(int v, int t, int p=-1) {\n  if (v == t) {\n    vs.pb(v);\n    return true;\n  }\n  for (int u : to[v]) {\n    if (c[u] || p == u) continue;\n    if (vfs(u,t,v)) {\n      vs.pb(v);\n      return true;\n    }\n  }\n  return false;\n}\nint dfs(int v) {\n  v = cfs(v).se;\n  P p = cfs(v);\n  vs = vi();\n  vfs(v,p.se);\n  v = vs[(p.fi+1)/2];\n  c[v] = 1;\n  int res = 0;\n  for (int u : to[v]) {\n    if (c[u]) continue;\n    maxs(res,dfs(u)+1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 30;\nconst int MOD = 1e9 + 7;\n\nconst int N = 1e5 + 10;\nvector<int> a[N];\nint dp[N];\n\nvoid DFS(int u, int parent) {\n  int sum = 0;\n  for (auto& v : a[u]) {\n    if (v == parent) continue;\n    DFS(v, u);\n    sum |= dp[v];\n  }\n  dp[u] = sum + 1;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 1; i < n; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x; --y;\n    a[x].push_back(y);\n    a[y].push_back(x);\n  }\n  DFS(0, -1);\n  int mask = *max_element(dp, dp + n);\n  int ret = 0;\n  for (int i = 0; i < 32; ++i) {\n    if (mask & (1 << i)) {\n      ret = max(ret, i);\n    }\n  }\n  printf(\"%d\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define iter(v, i) for (__typeof__((v).begin()) i = (v).begin(); i != (v).end(); i++)\n#define fast_io_without_cstdio ios_base::sync_with_stdio(false), cin.tie(NULL)\n#define all(v) (v).begin(), (v).end()\n\n#ifdef __linux__\n#define gc getchar_unlocked\n#define pc putchar_unlocked\n#else\n#define gc getchar\n#define pc putchar\n#endif\n\n#if __cplusplus <= 199711L\ntemplate<class BidirIt>\nBidirIt prev(BidirIt it, typename iterator_traits<BidirIt>::difference_type n = 1) {\n    advance(it, -n);\n    return it;\n}\n\ntemplate<class ForwardIt>\nForwardIt next(ForwardIt it, typename iterator_traits<ForwardIt>::difference_type n = 1) {\n    advance(it, n);\n    return it;\n}\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\n\nconst double EPS = 1e-9;\nconst double PI = 3.141592653589793238462;\n\ntemplate<typename T>\ninline T sq(T a) { return a * a; }\n\nconst int MAXN = 1e5 + 5;\n\nint ans[MAXN];\nvi gr[MAXN];\n\nvoid dfs(int u, int par) {\n    for (auto v : gr[u])\n        if (v != par) {\n            dfs(v, u);\n            ans[u] += ans[v];\n        }\n    //cout << \"before: \" << bitset<6>(ans[u]) << endl;\n    ans[u]++;\n    //cout << \"after: \" << bitset<6>(ans[u]) << endl;\n}\n\nint main() {\n    //freopen(\"\", \"rt\", stdin);\n    //freopen(\"\", \"wt\", stdout);\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        gr[a].pb(b);\n        gr[b].pb(a);\n    }\n    dfs(1, -1);\n    printf(\"%d\\n\", 31 - __builtin_clz(ans[1]));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct edges\n{\n\tint to,next;\n}edge[202020];\nint first[101010],now;\nvoid adde(int x,int y)\n{\n\tnow++;\n\tedge[now].to=y;\n\tedge[now].next=first[x];\n\tfirst[x]=now;\n}\nint s[101010],al=(1<<20)-1;\nint pre[1<<20];\nint lowbit(int x)\n{\n\treturn x&(-x);\n}\nint h=0;\nvoid work(int p,int fa)\n{\n\tint mk=1;\n\ts[p]=0;\n\tfor(int e=first[p];e;e=edge[e].next)\n\t\tif(edge[e].to!=fa)\n\t\t{\n\t\t\twork(edge[e].to,p);\n\t\t\tmk=max(mk,pre[s[p]&s[edge[e].to]]);\n\t\t\ts[p]|=s[edge[e].to];\n\t\t}\n\twhile(mk&s[p])\n\t\tmk<<=1;\n\th=max(h,mk);\n\ts[p]&=(al^(mk-1));\n\ts[p]^=mk;\n}\nint main()\n{\n\tint n,x,y,ans;\n\tscanf(\"%d\",&n);\n\tpre[0]=0;\n\tpre[1]=1;\n\tfor(int i=2;i<(1<<20);i++)\n\t\tpre[i]=pre[i>>1]<<1;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadde(x,y);\n\t\tadde(y,x);\n\t}\n\twork(1,0);\n\tans=-1;\n\twhile(h)\n\t{\n\t\tans++;\n\t\th>>=1;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint head[100001], next[199999], to[199999], q[100001], fa[100001], N, E, f[100001][20];\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, u, v; i < N; i++)\n\t{\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tnext[++E] = head[u], to[E] = v, head[u] = E;\n\t\tnext[++E] = head[v], to[E] = u, head[v] = E;\n\t}\n\tint H = 0, T = 1, u;\n\tq[1] = 1;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\tfor (int i = N; i; i--)\n\t{\n\t\tint u = q[i];\n\t\tfor (int e = head[u]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t\tfor (int j = 0; j < 20; j++)\n\t\t\t\t\tf[u][j] += f[to[e]][j];\n\t\tf[u][0]++;\n\t\tint z = -1;\n\t\tfor (int j = 0; j < 19; j++)\n\t\t\tif (f[u][j] > 1)\n\t\t\t{\n\t\t\t\tz = j;\n\t\t\t\tf[u][j] = 0;\n\t\t\t\tf[u][j + 1]++;\n\t\t\t}\n\t\tfor (int j = 0; j <= z; j++)\n\t\t\tf[u][j] = 0;\n\t}\n\tint D = 19;\n\twhile (!f[1][D])\n\t\tD--;\n\tprintf(\"%d\\n\", D);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<int> label;\n\nint dfs_init(int node, int par) {\n    int mask = 0, beat = 0;\n    for (auto vec : graph[node]) {\n        if (vec == par) continue;\n        int now = dfs_init(vec, node);\n        beat |= (mask & now);\n        mask |= now;\n    }\n    int need = 32 - __builtin_ctz(beat);\n    mask |= (1 << need) - 1;\n    label[node] = __builtin_ctz(~mask);\n    mask ^= (2 << label[node]) - 1;\n    return mask;\n}\n\nint main() {\n    int n; cin >> n;\n    label.resize(n);\n    graph.resize(n);\n    for (int i = 1; i < n; ++i) {\n        int a, b; cin >> a >> b;\n        graph[a - 1].push_back(b - 1);\n        graph[b - 1].push_back(a - 1);\n    }\n    dfs_init(0, -1);\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        res = max(res, label[i]);\n    }\n    cout << res + 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (100010)\n#define P ()\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nvector<int> G[N];\nint n,f[N],w[N],ans;\nvoid dfs(int u,int pre){\n\tint tmp=0;\n\tfor(int i=0;i<G[u].size();i++){\n\t\tint v=G[u][i];\n\t\tif(v==pre)continue;\n\t\tdfs(v,u);\n\t\ttmp|=(f[u]&f[v]);\n\t\tf[u]|=f[v];\n\t}\n//\tcout<<u<<\" \"<<f[u]<<\" \"<<tmp<<endl;\n\tif(f[u]==0){f[u]=1;return;}\n\t//f[u]:至少在2个v中出现过的 sum:并\n\twhile(((1<<w[u])&f[u])||(1<<w[u])<tmp)w[u]++;\n\tf[u]=(f[u]/(1<<w[u])*(1<<w[u]))|(1<<w[u]); ans=max(ans,w[u]);\n}\nint main(){\n\tread(n);\n\tfor(int i=1,x,y;i<n;i++)\n\tread(x),read(y),G[x].push_back(y),G[y].push_back(x); \n\tdfs(1,0); for(int i=1;i<=n;i++)ans=max(ans,w[i]);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nvector<P>G[200000];\nint ret=-1;\nbool rem[200005]={};\nint sub[200005]={},len;\nint ind;\nP xz[200005];\nint make(int v,int u)\n{\n\tint cnt=1;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint v2=G[v][i].f;\n\t\tif(rem[v2] || v2==u) continue;\n\t\tcnt+=make(v2,v);\n\t}\n\treturn sub[v]=cnt;\n}\nP search(int v,int u,int siz)\n{\n\t//size and index\n\tP res=mp(INF,-1);\n\tint s=1,m=0;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint v2=G[v][i].f;\n\t\tif(rem[v2] || v2==u) continue;\n\t\tres=min(res,search(v2,v,siz));\n\t\tm=max(m,sub[v2]);\n\t\ts+=sub[v2];\n\t}\n\tm=max(m,siz-s);\n\tres=min(res,mp(m,v));\n\treturn res;\n}\nvoid dfs(int v,int u,int dist,int d)\n{\n\tif(ret<d || dist>len) return ;\n\txz[ind++]=mp(dist,d);\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint v2=G[v][i].f;\n\t\tif(rem[v2] || v2==u) continue;\n\t\tdfs(v2,v,dist+G[v][i].s,d+1);\n\t}\n}\nvoid sol(int v,int d)\n{\n\tmake(v,-1);\n\tint cent=search(v,-1,sub[v]).s;\n\trem[cent]=true;\n\tret = max(ret,d);\n\tfor(int i=0;i<G[cent].size();i++) if(!rem[G[cent][i].f]) sol(G[cent][i].f,d+1);\n\trem[cent]=false;\n}\nint best_path(int n,int k,int e[][2],int leng[])\n{\n\tlen=k;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tint u=e[i][0];\n\t\tint v=e[i][1];\n\t\tG[u].pb(mp(v,leng[i]));\n\t\tG[v].pb(mp(u,leng[i]));\n\t}\n\tsol(1,0);\n\treturn ret;\n}\nint n,k;\nint e[200005][2],leng[200005];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tscanf(\"%d %d\",&e[i][0],&e[i][1]);\n\t\tleng[i] = 1;\n\t}\n\tint x=best_path(n,k,e,leng);\n\tprintf(\"%d\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n;\nvector<int> g[maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v, u;\n    scanf(\"%d%d\", &v, &u);\n    v--;\n    u--;\n    g[v].push_back(u);\n    g[u].push_back(v);\n  }\n  return true;\n}\n\nint dfs(int v, int p) {\n  int msk = 0;\n  int msk2 = 0;\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (u == p) {\n      continue;\n    }\n    int cur = dfs(u, v);\n    msk2 |= (cur & msk);\n    msk |= cur;\n  }\n  int bit = (msk2 ? 32 - __builtin_clz(msk2) : 0);\n  msk &= ~((1 << bit) - 1);\n  msk += (1 << bit);\n  return msk;\n}\n\nvoid solve() {\n  printf(\"%d\\n\", (31 - __builtin_clz(dfs(0, -1))));\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nvector<int> Mat[MAXN];\nint n, mxv, mxd;\n\nint dfs(int v, int p, int d) {\n\tif (mxd < d)\n\t\tmxd = d, mxv = v;\n\tfor (int i = 0; i < Mat[v].size(); i++)\n\t\tif (Mat[v][i] != p)\n\t\t\tdfs(Mat[v][i], v, d + 1);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tMat[a].push_back(b);\n\t\tMat[b].push_back(a);\n\t}\n\tdfs(1, 1, 0);\n\tdfs(mxv, mxv, 0);\n\tint num = 0;\n\tmxd++;\n\twhile (mxd > 0) {\n\t\tif (mxd == 1)\n\t\t\tbreak;\n\t\tmxd--;\n\t\tmxd = (mxd + 1) / 2;\n\t\tnum++;\n\t}\n\tcout << num;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntypedef pair<int, int> Result;\nResult visit(int p, int v, const vector<vi> &g) {\n  Result r(0, v);\n  for(int u : g[v]) if (u != p) {\n    Result t = visit(v, u, g);\n    t.first ++;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nint diameter(const vector<vi> &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n\nint T, n, m;\n\nint main(int argc, char *argv[]){\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tvector<vi> g(n);\n\tREP(i, n - 1){\n\t\tint u, v;\n\t\tcin >> u >> v; u--; v--;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint d = diameter(g);\n\tcout << (31 - __builtin_clz(d + 1)) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 101000;\n\nint n, f[N][31];\n\nstruct Edge\n{\n    int nxt, to;\n} eg[N << 1];\nint head[N], en;\n\nvoid setEdge(int u, int v)\n{\n    eg[++en] = (Edge) {head[u], v};\n    head[u] = en;\n}\n\nvoid dfs(int u, int fa)\n{\n    for (int e = head[u]; e; e = eg[e].nxt)\n    {\n        int v = eg[e].to;\n        if (v == fa) continue;\n        dfs(v, u);\n        for (int i = 0; i <= 30; i++)\n            f[u][i] += f[v][i];\n    }\n    for (int i = 0; i <= 30; i++)\n        if (f[u][i] == 0)\n        {\n            f[u][i] = 1;\n            for (int j = 0; j < i; j++)\n                f[u][j] = 0;\n            for (int j = i + 1; j <= 30; j++)\n                if (f[u][j]) f[u][j] = 1;\n            break;\n        }\n}\n\nint main()\n{\n    n = read();\n    for (int i = 1; i < n; i++)\n    {\n        int u = read(), v = read();\n        setEdge(u, v);\n        setEdge(v, u);\n    }\n    dfs(1, 0);\n    for (int i = 30; i >= 0; i--)\n        if (f[1][i])\n        {\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nstatic const int MAXN = 1e5 + 4;\nstatic const int LOGN = 18;\n\nint n;\nstd::vector<int> e[MAXN];\n\nint ans = 0;\nint f[MAXN];\nvoid dfs_dp(int u, int p = -1)\n{\n    int mask = 0, label = 0;\n    for (int v : e[u]) if (v != p) {\n        dfs_dp(v, u);\n        for (int i = label + 1; i < LOGN; ++i)\n            if ((f[v] & (1 << i)) && (mask & (1 << i))) label = i;\n        mask |= f[v];\n    }\n    //int label = 8 * sizeof(int) - __builtin_clz(f[u]) - 1;\n    while (mask & (1 << label)) ++label;\n    f[u] = (1 << label);\n    for (int i = label + 1; i < LOGN; ++i)\n        if (mask & (1 << i)) f[u] |= (1 << i);\n    if (ans < label) ans = label;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    int u, v;\n    for (int i = 0; i < n - 1; ++i) {\n        scanf(\"%d%d\", &u, &v); --u, --v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    dfs_dp(0);\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//¹Ø¼üÐÔÖÊ£ºÁ½¸öÉî¶ÈÏàÍ¬µÄµãµÄÂ·¾¶ÉÏ±ØÓÐÒ»¸öÉî¶È¸üÐ¡µÄµã \n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN=1e5+5;\n\nint N,Ans;\nint Cnt[MaxN][20];\n\nvector<int> To[MaxN];\n\nvoid DFS(int u,int fa){\n\tint i,k=0;\n\tfor(auto v:To[u])\n\t\tif(v^fa){\n\t\t\tDFS(v,u);\n\t\t\tfor(i=0;i<20;i++)\n\t\t\t\tCnt[u][i]+=Cnt[v][i];\n\t\t}\n\tfor(i=19;~i;i--)\n\t\tif(Cnt[u][i]>1){\n\t\t\tk=i+1;\n\t\t\tbreak;\n\t\t}\n\tfor(;Cnt[u][k];k++);\n\tAns=max(Ans,k);\n\tfor(i=0;i<k;i++)\n\t\tCnt[u][i]=0;\n\tCnt[u][k]++;\n}\n\nint main(){\n\tint i,u,v;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<N;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tTo[u].push_back(v);\n\t\tTo[v].push_back(u);\n\t}\n\tDFS(1,0);\n\tprintf(\"%d\\n\",Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nvector<int> graph[limit];\n\n\nint opr(vector<int> val){\n\tint last = 0;\n\n\trep(i, 30){\n\t\tif(val[i] >= 2){\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tint start = 30;\n\trep(i, last + 1, 30){\n\t\tif(val[i] == 0){\n\t\t\tstart = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tval[start] = 1;\n\trrep(i, start){\n\t\tval[i] = 0;\n\t}\n\n\tint ret = 0;\n\trep(i, 30) if(val[i] > 0) ret |= (1 << i);\n\treturn ret;\n}\n\nint dfs(int v, int p){\n\tvector<int> res(30, 0);\n\n\tfor(auto &v2: graph[v]){\n\t\tif(v2 == p) continue;\n\t\tconst int val = dfs(v2, v);\n\t\trep(i, 30) if(val >> i & 1) res[i]++;\n\t}\n\n\treturn opr(res);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i, n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\n\tconst ll val = dfs(0, -1);\n\n\trrep(ans, 30){\n\t\tif(val >> ans & 1) {\n\t\t\tcout << ans << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nvector<int> graph[limit];\n\n\nint opr(vector<int> val){\n\tint last = -1;\n\n\trep(i, 30){\n\t\tif(val[i] >= 2){\n\t\t\tlast = i;\n\t\t}\n\t}\n\n\tint start = 30;\n\trep(i, last + 1, 30){\n\t\tif(val[i] == 0){\n\t\t\tstart = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tval[start] = 1;\n\trrep(i, start){\n\t\tval[i] = 0;\n\t}\n\n\tint ret = 0;\n\trep(i, 30) if(val[i] > 0) ret |= (1 << i);\n\treturn ret;\n}\n\nint dfs(int v, int p){\n\tvector<int> res(30, 0);\n\n\tfor(auto &v2: graph[v]){\n\t\tif(v2 == p) continue;\n\t\tconst int val = dfs(v2, v);\n\t\trep(i, 30) if(val >> i & 1) res[i]++;\n\t}\n\n\treturn opr(res);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i, n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\n\tconst int val = dfs(0, -1);\n\n\trrep(ans, 30){\n\t\tif(val >> ans & 1) {\n\t\t\tcout << ans << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <list>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <assert.h>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n\nconst int SZ = 1e5 + 10;\nconst int INF = 1e9;\n\nvector<int> child[SZ];\nint d[SZ], diam;\nbool v[SZ];\n\nvoid dfs(int h) {\n\tv[h] = true;\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tdfs(i);\n\t\t\td[h] = max(d[h], d[i] + 1);\n\t\t}\n}\n\nvoid dfs1(int h, int top) {\n\tv[h] = true;\n\tint mx1 = top, mx2 = 0;\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tif (d[i] + 1 >= mx1) {\n\t\t\t\tmx2 = mx1;\n\t\t\t\tmx1 = d[i] + 1;\n\t\t\t} else if (d[i] + 1 >= mx2)\n\t\t\t\tmx2 = d[i] + 1;\n\t\t}\n\tdiam = max(diam, mx1 + mx2);\n\tfor (int i : child[h])\n\t\tif (!v[i]) {\n\t\t\tif (d[i] + 1 == mx1)\n\t\t\t\tdfs1(i, mx2 + 1);\n\t\t\telse\n\t\t\t\tdfs1(i, mx1 + 1);\n\t\t}\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tchild[a].push_back(b);\n\t\tchild[b].push_back(a);\n\t}\n\tdfs(0);\n\tfor (int i = 0; i < n; i++)\n\t\tv[i] = false;\n\tdfs1(0, 0);\n\n\tdiam++;\n\tint ans = 0, p = 1;\n\twhile (p < diam) {\n\t\tans++;\n\t\tp = 2 * p + 1;\n\t}\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge\n{\n    int to, nxt;\n};\nEdge e[100010];\nint head[100010], cnt;\nconst int LG = 60;\nint dp[100010][LG + 1];\n\nvoid add_edge(int a, int b)\n{\n    e[++cnt].to = b;\n    e[cnt].nxt = head[a];\n    head[a] = cnt;\n}\n\nvoid dfs(int nod, int tata)\n{\n    for (int i = head[nod]; i; i = e[i].nxt) {\n        int v = e[i].to;\n        if (v == tata)\n            continue;\n        dfs(v, nod);\n        for (int j(1); j <= LG; j++)\n            dp[nod][j] += dp[v][j];\n    }\n    int bigg0(1);\n    for (int i(1); i <= LG; i++) {\n        if (dp[nod][i] <= 1)\n            continue;\n        int p(i);\n        while (dp[nod][p])\n            p++;\n        dp[nod][p] = 1;\n        for (int i(bigg0); i < p; i++)\n            dp[nod][i] = 0;\n        bigg0 = p;\n    }\n\n    int p(1);\n    while (dp[nod][p])\n        p++;\n    dp[nod][p] = 1;\n    for (int i(1); i < p; i++)\n        dp[nod][i] = 0;\n}\n\nint main()\n{\n    int n, a, b;\n    scanf(\"%d\", &n);\n\n    while (--n) {\n        scanf(\"%d%d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n\n    dfs(1, 0);\n\n    for (int i(LG); ; i--) {\n        if (dp[1][i]) {\n            printf(\"%d\\n\", i - 1);\n            return 0;\n        }\n    }\n    assert(false);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,ans;\n\nvector<int> G[maxn];\n\nint sz[maxn],vi[maxn];\n\nvoid dfs(int u,int f){\n\tsz[u]=1;\n\tfor(auto v:G[u])if(v!=f&&!vi[v])dfs(v,u),sz[u]+=sz[v];\n}\n\nint dfs2(int u,int f,int s){\n\tfor(auto v:G[u])if(v!=f&&!vi[v]&&sz[v]>=s/2)return dfs2(v,u,s);\n\treturn u;\n}\n\nvoid solve(int u,int dep){\n\tdfs(u,0);\n\tu=dfs2(u,0,sz[u]);\n\tans=max(ans,dep);\n\tvi[u]=1;\n\tfor(auto v:G[u])if(!vi[v])solve(v,dep+1);\n}\n\nvoid Work(){\n\tsolve(1,0);\n\tiout(ans);\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,2,n){\n\t\tint u,v;\n\t\tread(u,v);\n\t\tG[u].PB(v);G[v].PB(u);\n\t}\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<19)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\twhile((f[u]>>mn&1) || (mn<=mx))++mn;\n\tf[u]=(f[u]>>mn<<mn)|(1<<mn);\n\tans=max(ans,mn);\n\t// for(int i=18;;--i)\n\t// \tif(i<mn || (mx>>i&1))\n\t// \t{\n\t// \t\t++i;\n\t// \t\t// f[u]&=S-((1<<i)-1);\n\t// \t\t// f[u]|=1<<i;\n\t// \t\tf[u]=(f[u]>>i<<i)|(1<<i);\n\t// \t\tans=max(ans,i);\n\t// \t\t// cerr<<u<<\" \"<<i<<endl;\n\t// \t\tbreak;\n\t// \t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n/*\n10\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n4 8\n8 9\n9 10\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\ntypedef int Weight;\nWeight INF = 1000000000;\nstruct Edge{ int src, dest; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\n\nvoid bfs01(Graph &g, vector<int> &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; int v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint logg(ll n) {\n  if (n == 1) return 0;\n  return logg(n / 2) + 1;\n}\n\nbool visited[128000];\nll dfs(const Graph &g, int v) {\n  visited[v] = true;\n  vector<int> vec;\n  for (auto i: g[v]) {\n    if (visited[i.dest]) continue;\n    vec.push_back(dfs(g, i.dest));\n  }\n  sort(ALL(vec));\n  if (vec.empty()) return 1;\n  if (vec.size() == 1) {\n    return vec.back() + 1;\n  }\n  ll res = vec.back() + 1;\n  // cout << log(res)\n  if (logg(res) == logg(res + vec[vec.size() - 2])) {\n    if (res % 2 == 1) return res + 1;\n    return res;\n  }\n  return ll(1) << (logg(res) + 1);\n}\n\nvoid solve(ll N, vector<ll> a, vector<ll> b) {\n  Graph g(N);\n  REP(i,N-1) {\n    add_edge(g, a[i] - 1, b[i] - 1, 1);\n    add_edge(g, b[i] - 1, a[i] - 1, 1);\n  }\n  int res = dfs(g, 0);\n  // cout << res << endl;\n  cout << logg(res) << endl;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll N;\n\tscanf(\"%lld\", &N);\n\tvector<ll> b((N-1)-1+1);\n\tvector<ll> a((N-1)-1+1);\n\tfor (int i = 0 ; i <= (N-1)-1 ; i++) {\n\t  scanf(\"%lld\", &a[i]);\n\t  scanf(\"%lld\", &b[i]);\n\t}\n\tsolve(N, a, b);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define epr(...) fprintf(stderr, __VA_ARGS__)\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\"; \n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)a.size()\n#define pw(n) (1ll << (n))\n\n#define equal equalll\n#define less lesss\nconst int N = 1e5 + 10;\nconst long long INF = 1e9 + 19;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint n;\nvector<int> e[N];\nint use[N];\n\nvoid read() {   \n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++) {\n        int v,u;\n        scanf(\"%d%d\", &v, &u); v--; u--;\n        e[v].pb(u);\n        e[u].pb(v);\n    }\n\n}\n\nint mxBit(int mask) {\n    assert(mask != 0);\n    int res = 0;\n    for (; mask > 0; mask /= 2, res++);\n    return res - 1;\n}\n\nint dfs(int v) {\n    use[v] = 1;\n    int sMask = 0;\n    int dMask = 0;\n    for (auto u: e[v])\n        if (!use[u]) {\n            int rMask = dfs(u);\n            dMask |= sMask & rMask;\n            sMask |= rMask;\n        }\n    int val = 0;\n    if (dMask != 0) {\n        val = mxBit(dMask) + 1;\n    }\n    for (int i = val; ; i++) {\n        if ((sMask & pw(i)) == 0) {\n            int res = ((sMask >> i) << i) | pw(i);\n            return res;\n        }\n    }\n    assert(false);\n}\n\nint solve(int st = 0) {\n    for (int i = 0; i < n; i++)\n        use[i] = 0; \n    int mask = dfs(st);\n    return mxBit(mask);\n}\n\nvoid stress() {\n    for (int tt = 0; ; tt++) {\n        db(tt);\n        n = rand() % 100 + 1; \n        for (int i = 0; i < n; i++)\n            e[i].clear();\n        for (int i = 1; i < n; i++) {\n            int v = rand() % i;\n            e[v].pb(i);\n            e[i].pb(v);\n        }\n        set<int> val;\n        for (int i = 0; i < n; i++)\n            val.insert(solve(i));\n\n        db(*val.begin());\n        assert(val.size() == 1);\n    }\n\n}\n\nint main(){\n#ifdef HOME \n    freopen(\"in\", \"r\", stdin);\n#endif\n    if (1) {\n        read();\n        cout << solve(0) << endl;\n        //for (int i = 0; i < n; i++)\n            //cout << solve(i) << \" \";\n        //cout << endl;\n    }\n    else {\n        stress();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 100200;\nint n,b[N][18];Vi e[N];\nvoid dfs(int u, int fa){\n\tint mx=0;\n\trep(i,0,SZ(e[u])-1)if(e[u][i]!=fa){\n\t\tdfs(e[u][i],u);int v=e[u][i];\n\t\trep(j,0,17)umax(mx,b[u][j]+b[v][j]==2?j:0),b[u][j]|=b[v][j];\n\t}\n\tmx++;while(b[u][mx])mx++;\n\tb[u][mx]=1;rep(i,0,mx-1)b[u][i]=0;\n}\nint main() {\n\tread(n);rep(i,1,n-1){int u,v;read(u);read(v);e[u].pb(v);e[v].pb(u);}\n\tdfs(1,0);int res=0;rep(i,0,17)if(b[1][i])res=i;\n\tcout<<res-1;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _LOCAL_\n\t#define cout cerr\n#endif\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define FORalld(it, a) for (__typeof((a).rbegin()) it = (a).rbegin(); it != (a).rend(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ntemplate<class T> inline T isqrt(T k) {T r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ntemplate<class T> inline T icbrt(T k) {T r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n\nconst int maxn = 100000 + 5;\nint n;\nvi adj[maxn];\n\nint dfs(int u, int p = -1) {\n\tint res = 0;\n\tFOR(i, 0, sz(adj[u])) {\n\t\tint v = adj[u][i];\n\t\tif (v != p) {\n\t\t\tres |= dfs(v, u);\n\t\t}\n\t}\n\tFOR(i, 0, 30) if (!bit(res, i)) {\n\t\tFOR(j, 0, i) res |= 1 << j, res ^= 1 << j;\n\t\tres |= 1 << i;\n\t\tbreak;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> n;\n\tFOR(i, 0, n - 1) {\n\t\tint u, v; cin >> u >> v; u--, v--;\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tcout << __lg(dfs(0)) << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n#ifdef _LOCAL_\n\tfreopen(\"in.txt\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tsolve();\n#ifdef _LOCAL_\n\t//printf(\"\\nTime elapsed: %dms\", 1000 * clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<62;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\nvector<int> adj[100009];\n\nint dfs(int x,int p){//returns bitmask of visible positions\n\tbool hasc=0;\n\tint visible=0;\n\tint doubleup=0;\n\tfor(int i:adj[x]){\n\t\tif(i==p)continue;\n\t\thasc=1;\n\t\tint dfsv=dfs(i,x);\n\t\tdoubleup|=(visible&dfsv);\n\t\tvisible|=dfsv;\n\t}\n\tif(!hasc)return 1;\n\tint m1=0,m2=0;\n\tREP(i,20){\n\t\tif(!(visible&(1<<i))){m1=i;break;}\n\t}\n\tfor(int i=19;i>=0;i--){\n\t\tif(doubleup&(1<<i)){m2=i;break;}\n\t}\n\tint v=max(m1,m2);\n\tvisible|=(1<<v);\n\tREP(i,v){\n\t\tif(visible&(1<<i))\n\t\tvisible^=(1<<i);\n\t}\n\treturn visible;\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tadj[a].PB(b);adj[b].PB(a);\n\t}\n\tint vv=dfs(0,-1);\n\t//printf(\"%d \",vv);\n\tfor(int i=20;i>=0;i--){\n\t\tif(vv&(1<<i)){printf(\"%d\",i);return 0;}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// Crt. 2019-12-08  09:24:29\n// give $ v $ a val. of k + 1\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#define N 200005\nusing namespace std;\n\nint n, num[N][22], val[N], ans;\nint tot, fir[N], nxt[N << 1], to[N << 1];\n\ninline void addE(int u, int v) {\n    nxt[++tot] = fir[u], fir[u] = tot, to[tot] = v;\n}\n\nvoid dfs(int u, int p) {\n    for (int i = fir[u], v; i; i = nxt[i]) {\n        v = to[i];\n        if (v == p) continue;\n        dfs(v, u);\n        for (int j = 0; j <= 20; ++j)\n            num[u][j] += num[v][j];\n    }\n    for (int i = 0; i <= 20; ++i)\n        if (num[u][i] > 1) val[u] = max(val[u], i);\n    while (num[u][val[u]]) ++val[u];\n    for (int i = 0; i < val[u]; ++i)\n        num[u][i] = 0;\n    num[u][val[u]] = 1;\n    ans = max(ans, val[u]);\n}\n\nint main() {\n#ifdef LOCAL_JUDGE\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n    for (int i = 1, u, v; i < n; ++i)\n        scanf(\"%d%d\", &u, &v), addE(u, v), addE(v, u);\n\n    dfs(1, 0);\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++)\n\tif(!used[i]) exit(0);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    //break;\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n\n      if(c<0) continue;\n      \n      for(Int u:G[c]){\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  used[u]=2;\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    //break;\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n      if(belong[i]>=(Int)T.size()) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<unordered_set>\nusing namespace std;\ntypedef long long ll;\ntypedef unordered_set<ll> set;\n#define N 100010\n#define D 40\nll n;\nvector<ll> g[N];\nset solve(ll x,ll from){\n  ll cnt[D]; for(int i=0;i<D;i++)cnt[i]=0;\n  for(auto y:g[x])if(y!=from){\n    set cur=solve(y,x);\n    for(auto z:cur)cnt[z]++;\n  }\n  ll clash=-1;\n  for(ll i=0;i<D;i++){\n    if(cnt[i]>=2){clash=i; break;}\n  }\n  ll gen;\n  for(ll i=clash+1;;i++){\n    if(cnt[i]==0){gen=i; break;}\n  }\n  set res; res.insert(gen);\n  for(ll i=gen+1;i<D;i++){\n    if(cnt[i]>0)res.insert(i);\n  }\n  return res;\n}\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    ll a,b;cin>>a>>b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  set res=solve(1,0);\n  ll ans=0;\n  for(auto x:res)ans=max(ans,x);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = (int) 1e5 + 5, mod = (int) 0;\nint mark[N], sz[N];\nvector<int> ver, adj[N];\nvoid dfs(int v, int p = -1) {\n    if (mark[v]) return;\n    ver.push_back(v);\n    sz[v] = 1;\n    for (int u : adj[v])\n        if (!mark[u] && u != p)\n            dfs(u, v), sz[v] += sz[u];\n}\nvoid call_dfs(int v) {\n    ver.clear();\n    dfs(v);\n}\nint solve(int v) {\n    call_dfs(v);\n    vector<int> cen;\n    for (int x : ver)\n        if (sz[v] / 2 <= sz[x]) {\n            int flag = 1;\n            for (int u : adj[x])\n                if (!mark[u] && sz[u] < sz[x])\n                    if (sz[u] >= sz[v] / 2)\n                        flag = 0;\n            if (flag)\n                cen.push_back(x);\n        }\n    int res = 1e9;\n    for (int x : cen) {\n        mark[x] = 1;\n        int mx = 0;\n        for (int u : adj[x]) if (!mark[u])\n            mx = max(solve(u), mx);\n        res = min(res, mx + 1);\n        mark[x] = 0;\n    }\n    return res;\n\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n;\n    cin >> n;\n    for (int j = 1; j < n; ++j) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    cout << solve(0)  - 1 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nbitset<30> bi[MAXN],temp;int mx;\nvoid solve(int x,int fa)\n{\n\tbool tf=false;int fi=-1;\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tif(y!=fa)\n\t\t{\n\t\t\tsolve(y,x);\n\t\t\ttemp=bi[x]&bi[y];for(int i=29;i>=0;i--)if(temp[i]){fi=max(fi,i);break;}\n\t\t\tbi[x]|=bi[y];\n\t\t}\n\t}\n\tfor(int i=0;i<=fi;i++)bi[x][i]=0;\n\twhile(bi[x][fi+1])++fi,bi[x][fi]=0;\n\tbi[x][fi+1]=1;mx=max(mx,fi+1);\n}\nint n;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tins(x,y);ins(y,x);\n\t}solve(1,0);pr2(mx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nconstexpr int MAX = 20;\n\nclass DUninity {\npublic:\n    int N;\n    vector<vector<int>> E;\n\n    int dfs(int u, int p) {\n        vector<int> CNT(MAX, 0);\n        for (int v: E[u]) if (v != p) {\n            int s = dfs(v, u);\n            for (int i = 0; i < MAX; ++i) {\n                if (s&1<<i) CNT[i]++;\n            }\n        }\n        int ans = MAX;\n        for (int i = MAX; i >= 0; --i) {\n            if (CNT[i] >= 2) break;\n            if (CNT[i] == 0) ans = i;\n        }\n        int cur = 1<<ans;\n        for (int i = ans+1; i < MAX; ++i) if (CNT[i] == 1) cur |= 1<<i;\n        return cur;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        E.resize(N);\n        for (int i = 0; i < N - 1; ++i) {\n            int a, b; cin >> a >> b;\n            --a; --b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        cout << logceil(dfs(0, -1)) - 1 << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDUninity solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\nvi g[MAXN];\n\nint prv[MAXN];\n\nvector<pii> vv;\n\npii dp[MAXN];\n\nvoid dfs(int s){\n\tREP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]){\n\t\t\tprv[to] = s;\n\t\t\tdfs(to);\n\t\t}\n\t}\n\tvv.clear();\n\tREP(i, 0, SZ(g[s])){\n\t\tint to = g[s][i];\n\t\tif (to != prv[s]){\n\t\t\tvv.pb(dp[to]);\n\t\t}\n\t}\n\tif (SZ(vv) == 0){\n\t\tdp[s] = mp(0, -1);\n\t\t\n\t\t//printf(\"%d %d %d\\n\", s, dp[s]._1, dp[s]._2);\n\t\t\n\t\treturn;\n\t}\n\tSORT(vv);\n\treverse(BE(vv));\n\tint mx = vv[0]._1;\n\tdp[s] = mp(mx + 1, mx);\n\tREP(i, 0, SZ(vv)){\n\t\tint cur_lim = vv[i]._2;\n\t\tint nxt_sz = 0;\n\t\t//int nxt_lim = -1;\n\t\tif (i < SZ(vv) - 1){\n\t\t\tnxt_sz = vv[i + 1]._1;\n\t\t\t//nxt_lim = vv[i + 1]._2;\n\t\t}\n\t\tif (nxt_sz > cur_lim){\n\t\t\tbreak;\n\t\t} else if (i == SZ(vv) - 1 || nxt_sz < cur_lim){\n\t\t\tdp[s] = mp(mx, cur_lim - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t//printf(\"%d %d %d\\n\", s, dp[s]._1, dp[s]._2);\n}\n\nvoid solve(){\n\tint n, a, b;\n\tscanf(\"%d\", &n);\n\tREP(i, 1, n){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t/*REPN(i, 1, n){\n\t\tdp[i] = mp(0, -1);\n\t}*/\n\tdfs(1);\n\tint ans = dp[1]._1;\n\tprintf(\"%d\\n\", ans);\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100010;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint e, st[MAXN], to[MAXN<<1];\nint nxt[MAXN<<1], l[MAXN][20];\ninline void Add(int u, int v) {\n\tto[++e] = v, nxt[e] = st[u];\n\tst[u] = e;\n}\n\nint n, ans;\n\nvoid dfs(int u, int fa) {\n\tint i, j;\n\tfor(i = st[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tif(v == fa) continue;\n\t\tdfs(v, u);\n\t\tfor(j = 0; j < 20; j++) l[u][j] += l[v][j];\n\t}\n\tint loc = -1;\n\tfor(j = 0; j < 20; j++) if(l[u][j] >= 2) loc = j;\n\tfor(j = loc+1; j < 20; j++) if(!l[u][j]) break;\n\tloc = j;\n\tans = max(ans, loc);\n\tl[u][loc] = 1;\n\tfor(j = 0; j < loc; j++) l[u][j] = 0;\n}\n\nint main() {\n\n\tint i;\n\n\tn = read();\n\tfor(i = 1; i < n; i++) {\n\t\tint u = read(), v = read();\n\t\tAdd(u, v), Add(v, u);\n\t}\n\n\tdfs(1, 0);\n\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 2e5 + 7;\nconst int LOG = 25;\n\nint n;\nvector<int> adj[N];\nint ans;\n\nint dfs(int u, int from) {\n\tint all = 0, least = 0;\n\tfor (int v : adj[u]) {\n\t\tif (v == from) continue;\n\t\tint mask = dfs(v, u);\n\t\tfor (int j = 0; j < LOG; j++) {\n\t\t\tif ((all >> j & 1) && (mask >> j & 1)) {\n\t\t\t\tleast = j + 1;\n\t\t\t}\n\t\t}\n\t\tall |= mask;\n\t}\n\tassert(least + 1 < LOG);\n\tfor (int i = least; ; i++) {\n\t\tif (~all >> i & 1) {\n\t\t\tans = max(ans, i);\n\t\t\tall ^= (1 << i);\n\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\tif (all >> j & 1) {\n\t\t\t\t\tall ^= (1 << j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn all;\n\t\t}\n\t}\n}\n\nint solve() {\n\tans = 0;\n\tdfs(rand() % n + 1, 0);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\t//n = 1e5;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tint ret = n;\n\tfor (int r = 1; r <= 20; r++) {\n\t\tret = min(ret, solve());\n\t}\n\tprintf(\"%d\\n\", ret);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(a,b,c) for (int a=b;a<=c;a++)\n#define per(a,b,c) for (int a=b;a>=c;a--)\n#define go(u) for (int o=ft[u],v;v=E[o].t;o=E[o].n)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> par;\nconst int N=100010;\nint ft[N],dp[N],n,tot;\nstruct edge{int t,n;}E[N<<1];\nvoid add(int x,int y){\n\tE[++tot]=(edge){y,ft[x]},ft[x]=tot;\n}\nvoid dfs(int u,int f=0){\n\tgo(u) if (v!=f){\n\t\tdfs(v,u);\n\t\tdp[u]|=dp[v];\n\t}\n\tint bit;\n\tfor (bit=1<<28;bit;bit>>=1){\n\t\tint cnt=0;\n\t\tgo(u) if (v!=f){\n\t\t\tif (dp[v]&bit) ++cnt;\n\t\t}\n\t\tif (cnt>1) break;\n\t}\n\tbit<<=1;\n\tif (!bit) bit=1;\n\tfor (;;bit<<=1){\n\t\tint cnt=0;\n\t\tgo(u) if (v!=f){\n\t\t\tif (dp[v]&bit) ++cnt;\n\t\t}\n\t\tif (!cnt) break;\n\t}\n\tdp[u]|=bit;\n\tdp[u]&=~(bit-1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,2,n){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1);\n\tper(i,28,0) if (dp[1]&1<<i){\n\t\tprintf(\"%d\\n\",i);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17, LOG = 20;\n\nint rje = 0;\nint p[MAX];\nint nesmije[MAX][LOG];\nvector <int> V[MAX];\n\nvoid dfs(int node, int par)\n{\n  for (auto it : V[node])\n    if (it != par)\n      dfs(it, node);\n\n  p[node] = -1;\n  REP(i, LOG) {\n    if (!nesmije[node][i]) {\n      p[node] = i;\n      break;\n    }\n  }\n\n  assert(p[node] != -1);\n  rje = max(rje, p[node]);\n  \n  if (par != -1) {\n    nesmije[par][p[node]] = 1;\n    FOR(i, p[node], LOG)\n      if (nesmije[node][i])\n\tnesmije[par][i] = 1;\n  }\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n\n  REP(i, n-1) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b); a--; b--;\n    V[a].push_back(b);\n    V[b].push_back(a);\n  }\n\n  dfs(0, -1);\n  printf(\"%d\\n\", rje);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\nint cd[MAXN], dp[MAXN];\nvector <int> G[MAXN];\nvoid process(int pos)\n{\n\tmemset(cd, -1, sizeof cd);\n\tqueue <int> bfs;\n\tbfs.push(pos);\n\tcd[pos] = 0;\n\twhile(!bfs.empty())\n\t{\n\t\tint top = bfs.front();\n\t\tbfs.pop();\n\t\tfor (int i = 0; i < G[top].size(); ++i)\n\t\t{\n\t\t\tint v = G[top][i];\n\t\t\tif(cd[v] == -1)\n\t\t\t{\n\t\t\t\tcd[v] = cd[top] + 1;\n\t\t\t\tbfs.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tprocess(1);\n\tint top = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tif(cd[i] > cd[top])\n\t\t\ttop = i;\n\t}\n\tprocess(top);\n\ttop = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tif(cd[i] > cd[top])\n\t\t\ttop = i;\n\t}\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tfor (int i = 2; i < MAXN; ++i)\n\t{\n\t\tint lf = i - 2;\n\t\tif(lf%2)\n\t\t\tdp[i] = 1 + max(dp[(lf-1)/2],dp[(lf+1)/2]);\n\t\telse\n\t\t\tdp[i] = 1 + dp[lf/2];\n\t}\n\tcout<<dp[cd[top]]<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> child[100005];\nvector<int> adjl[100005];\n\nint ans = 0;\n\nint func(int node){\nif (child[node].size()==0) return 1;\nvector<int> v;\nfor (int x : child[node]){\n    v.push_back(func(x));\n}\nint mx = -1;\nfor (int x = 0; x<23; x++){\n    bool c = false;\n    for (int y : v){\n        if ((y&(1<<x))!=0){\n            if (c) mx = x;\n            else c = true;\n        }\n    }\n}\nfor (int x = mx+1; x<23; x++){\n    bool can = true;\n    int t = 0;\n    for (int y : v){\n        if ((y&(1<<x))!=0){\n            can = false;\n            break;\n        }\n        t = (t|y);\n    }\n    if (can){\n        ans = max(ans,x);\n        return (t&(~((1<<(x))-1)))|(1<<x);\n    }\n}\n}\n\nvoid dfs(int node, int parent){\n    for (int x : adjl[node]){\n        if (x==parent) continue;\n        child[node].push_back(x);\n        dfs(x,node);\n    }\n}\n\nint main(){\nint n;\nscanf(\"%d\",&n);\nfor (int x = 0; x<n-1; x++){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    adjl[a].push_back(b);\n    adjl[b].push_back(a);\n}\ndfs(1,-1);\nfunc(1);\nprintf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Author       : Sun YaoFeng\n//============================================================================\n\n//#pragma \tcomment(linker, \"/STACK:100240000,100240000\")\n//#include\t<cstdio>\n//#include\t<cstdlib>\n//#include\t<cstring>\n//#include\t<algorithm>\n\n#include\t<bits/stdc++.h>\n\nusing\tnamespace\tstd;\n\n#define DB\t\tdouble\n#define\tlf\t\telse if\n#define I64\t\tlong long\n#define\tRd()\t(rand()<<15|rand())\n#define For(i,a,b)\tfor(int i=a,lim=b;i<=lim;i++)\n#define Rep(i,a,b)\tfor(int i=a,lim=b;i>=lim;i--)\n\n#define\tfi\tfirst\n#define se\tsecond\n#define MK\tmake_pair\n#define PA\tpair<int, int>\n\n//#define\tmin(a,b)\t((a)<(b)?(a):(b))\n//#define\tmax(a,b)\t((a)<(b)?(b):(a))\n\n#define\tCH\t(ch=getchar())\nint\t\tIN()\t{\n\t\tint x= 0, f= 0, ch;\n\t\tfor\t(; CH < '0' || ch > '9';)\tf= (ch == '-');\n\t\tfor\t(; ch >= '0' && ch <= '9'; CH)\tx= x*10 + ch -'0';\n\t\treturn\tf? -x : x;\n}\n\n#define n\t100005\n\nint\t\tN, D, st[n], Num[n];\n\nstruct\tLin{\n\t\tint v, next;\n}E[n << 1];\n\nvoid\tLink(int u, int v)\t{\n\t\tE[++ D]= (Lin){v, st[u]};\tst[u]= D;\n\t\tE[++ D]= (Lin){u, st[v]};\tst[v]= D;\n}\n\nset<int>\tG[n];\n\nvoid\tMerge(int u, set<int>&a, set<int>&b)\t{\n\t\tif\t(a.size() > b.size())\tswap(a, b);\n\t\tfor (set<int>::iterator it= b.begin(); it != b.end(); it++)\t{\n\t\t\tif\t(a.find(*it) != a.end())\tNum[u]= max(Num[u], (*it) + 1);\n\t\t\t\telse\ta.insert(*it);\n\t\t}\n}\n\nvoid\tDFS(int u, int f)\t{\n\t\tNum[u]= 0;\n\t\t\n\t\tfor (int i= st[u], v; i; i= E[i].next)\n\t\t\tif\t((v= E[i].v) != f)\tDFS(v, u);\n\t\t\n\t\tfor (int i= st[u], v; i; i= E[i].next)\n\t\t\tif\t((v= E[i].v) != f)\tMerge(u, G[u], G[v]);\n\t\t\n\t\tfor (; G[u].size() && *(G[u].begin()) < Num[u]; )\tG[u].erase(G[u].begin());\n\t\tfor (; G[u].find(Num[u]) != G[u].end(); )\tG[u].erase(Num[u]), Num[u]++;\n\t\tG[u].insert(Num[u]);\n\t\t\n\t//\tprintf(\"# %d %d\\n\", u, Num[u]);\n}\n\nint\t\tmain(int argc, char* argv[]){\n\t\tN= IN();\n\t\tFor(i, 2, N)\tLink(IN(), IN());\n\t\t\n\t\tDFS(1, 0);\n\t\t\n\t\tint\tAns= 0;\n\t\tFor(i, 1, N)\tAns= max(Ans, Num[i]);\n\t\t\n\t\tcout << Ans << endl;\n\t\t\n\t\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,ans;\nbool flag[100100][20];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[200100],*tp=pool,*fst[100100];\n\nvoid dfs(int x,int fa)\n{\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->v!=fa)\n            dfs(i->v,x);\n    int w=0;\n    for (; flag[x][w]; ++w);\n    ans=max(ans,w),flag[fa][w]=1;\n    repu(i,w+1,ans)\n        flag[fa][i]|=flag[x][i];\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n-1)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        *tp=(edge){v,fst[u]},fst[u]=tp++;\n        *tp=(edge){u,fst[v]},fst[v]=tp++;\n    }\n    dfs(1,0);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 101000\nusing namespace std;\nint last[N],nxt[N*2],to[N*2],n,tot=1,f[N],g[N],ans=0;\nvoid putin(int x,int y)\n{\n\tnxt[++tot]=last[x];last[x]=tot;to[tot]=y;\n}\nvoid dg(int x,int fa)\n{\n\tint jy=0;\n\tfor(int i=last[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];if(y==fa) continue;\n\t\tdg(y,x);\n\t\tjy|=g[x]&g[y];\n\t\tg[x]=g[x]|g[y];\n\t}\n\tfor(f[x]=0;((1<<f[x])<=jy)||((1<<f[x])&g[x]);f[x]++);\n\tans=max(ans,f[x]);\n\tg[x]=g[x]>>f[x]<<f[x];\n\tg[x]|=1<<f[x];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tputin(x,y);putin(y,x);\n\t}\n\tdg(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(x) ((int) (x).size())\nusing namespace std;\n\ntypedef long long i64;\n\nconst int NMAX = 100005;\nconst int KMAX = 30;\n\nvector<int> G[NMAX];\n\narray<int, KMAX> dfs(int node, int prev) {\n    array<int, KMAX> ret;\n    fill(ret.begin(), ret.end(), 0);\n    ret[0] = 1;\n    for (int to: G[node]) {\n        if (to != prev) {\n            array<int, KMAX> son = dfs(to, node);\n            for (int i = 0; i < KMAX; ++i) {\n                ret[i] += son[i];\n                if (ret[i] > 1) {\n                    ret[i] = 0;\n                    ret[i + 1]++;\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    #ifdef LOCAL_RUN\n    freopen(\"task.in\", \"r\", stdin);\n    freopen(\"task.out\", \"w\", stdout);\n    //freopen(\"task.err\", \"w\", stderr);\n    #endif // ONLINE_JUDGE\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    array<int, KMAX> ans = dfs(1, -1);\n    int fans = 0;\n    for (int i = 0; i < KMAX; ++i) {\n        if (ans[i] > 0) {\n            fans = i;\n        }\n    }\n    cout << fans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N;\nint a[110000], b[110000];\nvint G[110000];\nbool centroid[110000];\nint sos[110000];\nbool used[22][110000];\n\nvoid dfs(int v, int p, int dep) {\n    used[dep][v] = false;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || cur == p)continue;\n        dfs(cur, v, dep);\n    }\n}\n\nint size_of_subtree(int v, int p, int dep) {\n    int ret = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || used[dep][cur] || cur == p)continue;\n        ret += size_of_subtree(cur, v, dep);\n    }\n    return sos[v] = ret;\n}\n\nint search_centroid(int v, int t, int dep) {\n    int p = -1;\n    while (true) {\n        int ch, s = 0;\n        for (int i = 0; i < G[v].size(); i++) {\n            int cur = G[v][i];\n            if (centroid[cur] || used[dep][cur] || cur == p)continue;\n            if (s <= sos[cur])s = sos[cur], ch = cur;\n        }\n        if (s <= t / 2)break;\n        p = v;\n        v = ch;\n    }\n    return v;\n}\n\nint u(int v, int dep) {\n    dfs(v, -1, dep);\n    int ret = LLONG_MAX;\n    while (true) {\n        size_of_subtree(v, -1, dep);\n        int prev = v;\n        int cidx = search_centroid(v, sos[v], dep);\n        centroid[cidx] = true;\n        used[dep][cidx] = true;\n        int mu = -1;\n        for (int i = 0; i < G[cidx].size(); i++) {\n            if (centroid[G[cidx][i]])continue;\n            int cu = u(G[cidx][i], dep + 1);\n\n            if (mu <= cu)mu = cu, v = G[cidx][i];\n        }\n        ret = min(ret, mu + 1);\n        centroid[cidx] = false;\n        if (sos[prev] == 1)return ret;\n    }\n}\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++)cin >> a[i] >> b[i], a[i]--, b[i]--, G[a[i]].push_back(b[i]), G[b[i]].push_back(a[i]);\n    cout << u(0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<19)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\twhile(f[u]>>mn&1)++mn;\n\tfor(int i=18;;--i)\n\t\tif(i<mn || (mx>>i&1))\n\t\t{\n\t\t\t++i;\n\t\t\tf[u]&=S-((1<<i)-1);\n\t\t\tf[u]|=1<<i;\n\t\t\tans=max(ans,i);\n\t\t\tbreak;\n\t\t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass DUninity {\npublic:\n    int N;\n    vector<vector<int>> E;\n\n    int dfs(int u, int p) {\n        vector<int> C;\n        for (int v: E[u]) {\n            if (v != p) {\n                C.push_back(dfs(v, u));\n            }\n        }\n        int m = 0;\n        while (any_of(C.begin(),C.end(), [&](int s) { return s&1<<m; })) m++;\n        return accumulate(C.begin(), C.end(), 1<<m, [&](int a, int b) { return a|b; }) & ~((1<<m)-1);\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        E.resize(N);\n        for (int i = 0; i < N - 1; ++i) {\n            int a, b; cin >> a >> b;\n            --a; --b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        cout << logceil(dfs(0, -1)) - 1 << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDUninity solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\n\n// Source is from 2004 POI. Cave\n\nvector<int> gph[100005];\nint n;\n\nint ret;\n\nint f(int x, int p){\n\tint cnt[22] = {};\n\tfor(auto &i : gph[x]){\n\t\tif(i == p) continue;\n\t\tint v = f(i, x);\n\t\tfor(int i=0; i<20; i++){\n\t\t\tcnt[i] += ((v >> i) & 1);\n\t\t}\n\t}\n\tint lst = -1;\n\tfor(int i=20; i>=0; i--){\n\t\tif(cnt[i] >= 2){\n\t\t\tlst = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint mask = 0;\n\tfor(int i=lst+1; i<20; i++){\n\t\tif(cnt[i] == 0){\n\t\t\tret = max(ret, i);\n\t\t\tfor(int j=i+1; j<20; j++){\n\t\t\t\tif(cnt[j]) mask |= (1<<j);\n\t\t\t}\n\t\t\tmask |= (1<<i);\n\t\t\treturn mask;\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i=1; i<n; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\tgph[s].push_back(e);\n\t\tgph[e].push_back(s);\n\t}\n\tf(1, -1);\n\tcout << ret <<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 50000000;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q--) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t\t\n\t\tif (clock() > 1960)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ANS << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1 << 18;\nint col[N], ans, n;\nvector<int> G[N];\nvoid DFS(int v = 1, int par = 0) {\n\tint mx = 0, b = 0;\n\tfor (auto u : G[v])\n\t\tif (u ^ par) \n\t\t\tDFS(u, v), mx |= col[v] & col[u], col[v] |= col[u];\n\twhile ((1 << b) <= mx || col[v] & (1 << b)) b ++;\n\tans = max(ans, 31 - __builtin_clz(col[v] = col[v] & ~((1 << b) - 1) | (1 << b)));\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, v, u; i < n; i ++) {\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\tDFS();\n\tprintf(\"%d\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\n\nconst int N=1e5+9;\n\nunsigned int bit[N];\nint n,f[N],ans;\nint to[N<<1],nxt[N<<1],beg[N],tot;\n\ninline void add(int u,int v)\n{\n\tto[++tot]=v;\n\tnxt[tot]=beg[u];\n\tbeg[u]=tot;\n}\n\ninline void dfs(int u,int fa)\n{\n\tbit[u]=f[u]=0;\n\tfor(int i=beg[u],v;i;i=nxt[i])\n\t\tif((v=to[i])!=fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tbit[u]|=bit[v];\n\t\t}\n\tif(bit[u]==0)\n\t\tbit[u]=1;\n\telse\n\t{\n\t\twhile(bit[u]&(1<<f[u]))f[u]++;\n\t\tbit[u]=bit[u]&((1<<30)-(1<<f[u]));\n\t\tbit[u]|=(1<<f[u]);\n\t}\n\tif(ans<f[u])ans=f[u];\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tu=read();v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*+lmake\n * STD = c++14\n * DEFINE += WAAUTOMATON\n */\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\n#ifdef WAAUTOMATON\n#define debug(args...)                                                                             \\\n    {                                                                                              \\\n        dbg, args;                                                                                 \\\n        cerr << endl;                                                                              \\\n    }\n#else\n#define debug(args...) // Just strip off all debug tokens\n#endif\n\nstruct debugger\n{\n    template <typename T>\n    debugger &operator,(const T &v)\n    {\n        cerr << v << \" \";\n        return *this;\n    }\n} dbg;\n#define MAXN 100000\n\nstruct Edge\n{\n    int to, next;\n} e[2 * MAXN + 10];\nint head[MAXN + 10];\nvoid addEdge(int a, int b)\n{\n    static int c = 0;\n    e[++c] = (Edge){ b, head[a] };\n    head[a] = c;\n    e[++c] = (Edge){ a, head[b] };\n    head[b] = c;\n}\n\nbool f[MAXN + 10][30];\nint l[MAXN + 10];\nint m;\nvoid dfs(int now, int fa)\n{\n    int t[30];\n    memset(t, 0, sizeof(t));\n    for (int i = head[now]; i != 0; i = e[i].next) {\n        int v = e[i].to;\n        if (v == fa)\n            continue;\n        dfs(v, now);\n        f[now][l[v]] = true;\n        for (int j = l[v] + 1; j <= m; ++j) {\n            if (f[v][j])\n                f[now][j] = true;\n        }\n        for (int j = l[v]; j <= m; ++j) {\n            if (f[v][j])\n                ++t[j];\n        }\n    }\n    int Min = 999;\n    for (int j = 0; j <= m; ++j) {\n        if (t[j] == 0) {\n\t\t\tif (Min>j)\n            Min = j;\n        } else if (t[j] > 1) {\n            Min = 999;\n        }\n    }\n    l[now] = Min;\n\tf[now][l[now]]=true;\n}\nvoid solve(long long N, vector<long long> a, vector<long long> b) {\n\tm=log(N)/log(2)+1;\n\tfor(int i=0; i<N; ++i) {\n\t\taddEdge(a[i],b[i]);\n\t}\n\tdfs(1,0);\n\tint ans=0;\n\tfor(int i=1; i<=N; ++i) {\n\t\tdebug(l[i]);\n\t\tans=max(ans,l[i]);\n\t}\n\tcout<<ans<<endl;\n}\n\nint main()\n{\n#ifdef WAAUTOMATON\n     freopen(\"in.txt\",\"r\",stdin);\n#endif\n    long long N;\n    scanf(\"%lld\", &N);\n    vector<long long> b((N - 1) - 1 + 1);\n    vector<long long> a((N - 1) - 1 + 1);\n    for (int i = 0; i <= (N - 1) - 1; i++) {\n        scanf(\"%lld\", &a[i]);\n        scanf(\"%lld\", &b[i]);\n    }\n    solve(N, a, b);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define NR 101000\n\nvector<int> g[NR];\nint n;\n\nint dfs(int x, int fa) {\n\tint mask = 0;\n\tint top = -1;\n\tfor (int v : g[x]) if (v != fa) {\n\t\tint s = dfs(v, x);\n\t\tfor (int d = 20; d > top; --d) if ((mask >> d & 1) && (s >> d & 1)) { top = d; break; }\n\t\tmask |= s;\n\t}\n\t//printf(\"!%d %d %d\\n\", x, mask, top);\n\tfor (++top; mask >> top & 1; ++top);\n\tif (top > 0) mask &= ~((1 << top) - 1);\n\tmask |= 1 << top;\n\t\n\t//printf(\"%d %d %d\\n\", x, mask, top);\n\n\treturn mask;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tint mask = dfs(1, 0), ans = 0;\n\tfor (int i = 0; i < 20; ++i) if (mask >> i & 1) ans = i;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\nint c[MX];\n\nP cfs(int v, int d=0, int p=-1) {\n  P res(d,v);\n  for (int u : to[v]) {\n    if (c[u] || u == p) continue;\n    maxs(res, cfs(u,d+1,v));\n  }\n  return res;\n}\nvi vs;\nbool vfs(int v, int t, int p=-1) {\n  if (v == t) {\n    vs.pb(v);\n    return true;\n  }\n  for (int u : to[v]) {\n    if (c[u] || p == u) continue;\n    if (vfs(u,t,v)) {\n      vs.pb(v);\n      return true;\n    }\n  }\n  return false;\n}\nint dfs(int v) {\n  v = cfs(v).se;\n  v = cfs(v).se;\n  P p = cfs(v);\n  vs = vi();\n  vfs(v,p.se);\n  v = vs[(p.fi+1)/2];\n  c[v] = 1;\n  int res = 0;\n  for (int u : to[v]) {\n    if (c[u]) continue;\n    maxs(res,dfs(u)+1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Parent[500000], Dist[500000];\nset<int> G[500000];\n\nint DFS(int node, int par, int dist) {\n\tParent[node] = par;\n\tDist[node] = dist;\n\n\tint ret = node;\n\tfor(auto vec : G[node])\n\t\tif(vec != par) \n\t\t\tret = max(ret, DFS(vec, node, dist + 1), [&](int a, int b) {\n\t\t\t\treturn Dist[a] < Dist[b]; \n\t\t\t});\n\t\t\n\treturn ret;\n}\n\nint GetCenter(int node) {\n\tint last = DFS(node, 0, 0);\n\tlast = DFS(last, 0, 0);\n\n\tint d = Dist[last];\n\tfor(int i = 0; i < d / 2; ++i)\n\t\tlast = Parent[last];\n\tif(d % 2 == 1 && rand() % 2)\n\t\tlast = Parent[last];\n\t\n\tint ret = last;\n\n\tlast = DFS(last, 0, 0);\n\tassert(Dist[last] == (d + 1) / 2);\n\n\treturn ret;\n}\n\nint D[500000];\n\nint GetDiam(int node, int n) {\n\tqueue<int> Q;\n\t\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(D[i] == 0) \n\t\t\tQ.push(i);\n\t}\n\n\tfor(int i = 1; i < n; ++i) {\n\t\tint node = Q.front();\n\t\tQ.pop();\n\t\tfor(auto vec : G[node]) {\n\t\t\tif(--D[vec] == 0) {\n\t\t\t\tQ.push(vec);\n\t\t\t}\n\t\t}\n\t}\n\n\tDFS(Q.front(), 0, 0);\n\n\tint ans = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t\tans = max(ans, Dist[i]);\n\treturn ans;\n}\n\nint Decomp(int node) {\n\tint cen = GetCenter(node);\n\tfor(auto vec : G[cen]) {\n\t\tG[vec].erase(cen);\n\t}\n\n\tint ans = 0;\n\tfor(auto vec : G[cen])\n\t\tans = max(ans, Decomp(vec) + 1);\n\treturn ans;\n}\n\nint GetDP(int n) {\n\tif(n == 1) return 0;\n\treturn GetDP(n / 2) + 1;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tsrand(time(0));\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 1; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tG[a].insert(b);\n\t\tG[b].insert(a);\n\t\tD[a] += 1; D[b] += 1;\n\t}\n\n\tcout << GetDP(GetDiam(1, n)) << endl;\n\n\t// cout << Decomp(1) << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      //if(cnt[v]==0) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      //assert(cnt[v]==1);\n      //assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n      //if(c<0) continue;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1e5+7;\nstruct edge{\n\tint to,nx;\n}e[N*2];\nint n,e0[N],ep=2,f[N];\nvoid f1(int w,int pa){\n\tfor(int i=e0[w];i;i=e[i].nx){\n\t\tint u=e[i].to;\n\t\tif(u!=pa)f1(u,w);\n\t}\n\tint v1=0,v2=0,v3=1;\n\tfor(int i=e0[w];i;i=e[i].nx){\n\t\tint u=e[i].to;\n\t\tif(u!=pa){\n\t\t\tint x=f[u];\n\t\t\tv2|=v1&x;\n\t\t\tv1|=x;\n\t\t}\n\t}\n\tfor(;v3<=v2||(v3&v1);v3<<=1);\n\tf[w]=(v1|v3)&~(v3-1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1,a,b;i<n;++i){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[ep]=(edge){b,e0[a]};e0[a]=ep++;\n\t\te[ep]=(edge){a,e0[b]};e0[b]=ep++;\n\t}\n\tf1(1,0);\n\tint ans=0;\n\tfor(;f[1]>1;f[1]>>=1,++ans);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 200055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,fa[N],ans;\nbitset <22> a[N],b[N];\nint nedge,Next[N*2],head[N],to[N*2];\n#define V to[i]\nvoid add(int a,int b){\n\tNext[++nedge]=head[a];head[a]=nedge;to[nedge]=b;\n}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tgo(i,x){\n\t\tif (fa[x]==V) continue;\n\t\tfa[V]=x;dfs(V);b[x]|=a[x]&a[V];a[x]|=a[V];\n\t}\n\tint num=0;\n\tF(i,0,20) if (b[x][num]) num=i+1;\n\tF(i,num,20) if (a[x][i]==0) {num=i;break;}\n\ta[x][num]=1;\n\tans=max(ans,num);\n\tF(i,0,num-1) a[x].reset(i);\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n-1) add_ne(read(),read());\n\tdfs(1);\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define MAXN 100000\n#define LOGN 20\n\nstd::vector < int > g[MAXN + 1];\nint ans, q[MAXN];\nbool viz[MAXN + 1];\nbool t[MAXN + 1][LOGN];\nint h[LOGN];\n\ninline void solve(int x) {\n    for (int i = 0; i < LOGN; i++)\n        h[i] = 0;\n    for (auto &y : g[x])\n        if (viz[y] == 0)\n            for (int i = 0; i < LOGN; i++)\n                h[i] += t[y][i];\n    int r = 0;\n    for (int i = 0; i < LOGN; i++)\n        if (h[i] >= 2)\n            r = i;\n    while (h[r])\n        r++;\n    ans = std::max(ans, r);\n    t[x][r] = 1;\n    for (int i = r + 1; i < LOGN; i++)\n        t[x][i] = h[i];\n    viz[x] = 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    for (int i = 1; i < n; i++) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n\n    int st = 0, dr = 1;\n    q[0] = 1;\n    viz[1] = 1;\n    while (st < dr) {\n        int x = q[st++];\n        for (auto &y : g[x]) {\n            if (viz[y] == 0) {\n                viz[y] = 1;\n                q[dr++] = y;\n            }\n        }\n    }\n\n    for (int i = n - 1; i >= 0; i--)\n        solve(q[i]);\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconst int N = 100010;\n\nstd::vector <int> e[N];\nint ans[N], sz[N], sum, min, minsit;\nbool vis[N];\n\nvoid precalc(int u, int fa){\n\tsz[u] = 1;\n\tfor (auto v : e[u]){\n\t\tif (vis[v] || v == fa) continue;\n\t\tprecalc(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nvoid dfs1(int u, int fa, int sum){\n\tint max = 0, ssum = sum;\n\tfor (auto v : e[u]){\n\t\tif (vis[v] || v == fa) continue;\n\t\tdfs1(v, u, sum);\n\t\tssum -= sz[v];\n\t\tmax = std::max(max, sz[v]);\n\t}\n\tmax = std::max(max, ssum - 1);\n\tif (max < min){\n\t\tmin = max;\n\t\tminsit = u;\n\t}\n}\n\nvoid dfs(int u){\n\tprecalc(u, 0);\n\tif (sz[u] == 1) return;\n\tmin = INT_MAX;\n\tdfs1(u, 0, sz[u]);\n\tvis[minsit] = true;\n\tfor (auto v : e[minsit]){\n\t\tif (vis[v]) continue;\n\t\tdfs(v);\n\t\tans[v] = ans[minsit] - 1;\n\t}\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0, u, v; i < n - 1; ++ i){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1);\n\tint min = 0;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tmin = std::min(min, ans[i]);\n\t}\n\tprintf(\"%d\\n\", -min);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*/\n\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\n#define ldouble long double\n\nusing namespace std;\n\nconst int N = 1000031;\n\nint n;\nvector<int> g[N];\nint used[N];\nint dead[N];\nint T;\n\nvector<int> comp;\nint a[N],b[N];\n\nint par[N];\n\nint get_other(int id,int v)\n{\n\tif (a[id]==v)\n\t\treturn b[id];\n\treturn a[id];\n}\n\nvoid trace(int v)\n{\n\tif (used[v]==T)\n\t\treturn;\n\tused[v]=1;\n\tcomp.push_back(v);\n\tfor (int i=0;i<g[v].size();i++)\n\t{\n\t\tint id=g[v][i];\n\t\tif (dead[id])\n\t\t\tcontinue;\n\t\tint to=get_other(id,v);\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\ttrace(to);\n\t}\n}\n\nvoid dfs(int v)\n{\n\tfor (int i=0;i<g[v].size();i++)\n\t{\n\t\tint id=g[v][i];\n\t\tint to=get_other(id,v);\n\t\tif (dead[id])\n\t\t\tcontinue;\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tused[to]=used[v]+1;\n\t\tpar[to]=id;\n\t\tdfs(to);\n\t}\n}\n\nint solve(int v)\n{\n\t++T;\n\tcomp.clear();\n\ttrace(v);\n\tfor (int i=0;i<comp.size();i++)\n\t{\n\t\tused[comp[i]]=0;\n\t}\n\tused[v]=1;\n\tdfs(v);\n\tint fur=v;\n\tfor (int i=0;i<comp.size();i++)\n\t{\n\t\tif (used[comp[i]]>used[fur])\n\t\t\tfur=comp[i];\n\t}\n\n\tfor (int i=0;i<comp.size();i++)\n\t{\n\t\tused[comp[i]]=0;\n\t}\n\n\tused[fur]=1;\n\tdfs(fur);\n\n\tint fur2=fur;\n\tfor (int i=0;i<comp.size();i++)\n\t{\n\t\tif (used[comp[i]]>used[fur2])\n\t\t\tfur2=comp[i];\n\t}\n\tvector<int> path;\n\t/*cout<<\"%%\"<<fur<<endl;\n\tfor (int i=0;i<comp.size();i++)\n\t{\n\t\tcout<<comp[i]<<\" %\"<<used[comp[i]]<<endl;\n\t}\n*/\n\twhile (fur2!=fur)\n\t{\n\t\tpath.push_back(fur2);\n\t\tint edge=par[fur2];\n\t\tfur2=get_other(edge,fur2);\n\t}\n\tpath.push_back(fur);\n\n\t/*for (int i=0;i<path.size();i++)\n\t{\n\t\tcout<<path[i]<<\" \";\n\t}*/\n\treturn path.size();\n}\n\nint main(){\n\t//freopen(\"tree.in\",\"r\",stdin);\n\t//freopen(\"tree.out\",\"w\",stdout);\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\tg[a[i]].push_back(i);\n\t\tg[b[i]].push_back(i);\n\t}\n\n\n\tint res=solve(1);\n\n\tint ans=1000;\n\n\tfor (int i=0;i<=20;i++)\n\t{\n\t\tif (res<=(1<<i)*2-1)\n\t\t\tans=min(ans,i);\n\t}\n\tcout<<ans<<endl;\n\n\n\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct node { int t,next; }a[200010];\n\nint head[100010],bit[100010],f[100010],n,ans,tot;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void add(int x,int y) { a[++tot].t=y;a[tot].next=head[x];head[x]=tot; }\n\ninline void dfs(int x,int y)\n{\n\tbit[x]=f[x]=0;\n\tint hh=0;\n\tfor (int i=head[x];i;i=a[i].next)\n\t{\n\t\tint t=a[i].t;\n\t\tif (t==y) continue;\n\t\tdfs(t,x);\n\t\thh|=(bit[x]&bit[t]);\n\t\tbit[x]|=bit[t];\n\t}\n\tif (!bit[x]) bit[x]=1;\n\telse\n\t{\n\t\twhile ((1<<f[x])<hh||((1<<f[x])&bit[x])) f[x]++;\n\t\tbit[x]=(bit[x]>>f[x]<<f[x])|(1<<f[x]);\n\t}\n\tans=max(ans,f[x]);\n}\n\nint main()\n{\n\tn=rd();tot=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=rd(),y=rd();\n\t\tadd(x,y);add(y,x);\n\t}\n\tans=0;dfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\tfor (int i=1;i<=n;i++) printf(\"%d \",f[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nstruct IO {\n\tstatic const int maxn = 1048600;\n\tchar s[maxn], *S;\n\n\tIO() {\n\t\tfread(s, 1, maxn, stdin);\n\t\tS = s;\n\t}\n\n\toperator int() {\n\t\twhile(*S < 48) {\n\t\t\t++S;\n\t\t}\n\t\tint x = 0;\n\t\twhile(*S >= 48) {\n\t\t\t(x *= 10) += *S++ - 48;\n\t\t}\n\t\treturn x;\n\t}\n}io;\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 1e5 + 10;\n\nint n, m;\nint head[maxn], to[maxn << 1], nxt[maxn << 1];\nunsigned int dp[maxn];\n\ninline void dfs(int u = 1, int par = 0) {\n\tunsigned int s1 = 0, s2 = 0, &s = dp[u];\n\tfor (int i = head[u]; i; i = nxt[i]) {\n\t\tint &v = to[i];\n\t\tif(v != par) {\n\t\t\tdfs(v, u);\n\t\t\ts2 |= (dp[v] & s1);\n\t\t\ts1 |= dp[v];\n\t\t}\n\t}\n\ts = 1;\n\twhile(s <= s2) {\n\t\ts <<= 1;\n\t}\n\twhile(s & s1) {\n\t\ts <<= 1;\n\t}\n\ts = ((s > 1) ? (s1 & ~(s - 1)) : s1) | s;\n\treturn;\n}\n\nint main() {\n\tn = io;\n\trep (i, n - 1) {\n\t\tint u = io, v = io;\n\t\tto[++m] = v;\n\t\tnxt[m] = head[u];\n\t\thead[u] = m;\n\t\tto[++m] = u;\n\t\tnxt[m] = head[v];\n\t\thead[v] = m;\n\t}\n\tdfs();\n\tunsigned int s = 1;\n\tint ans = -1;\n\twhile(s <= dp[1]) {\n\t\ts <<= 1;\n\t\t++ans;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\ntemplate< typename T >\nstruct edge{\n    int from, to;\n    T cost;\n    edge(int to,T cost) : from(-1), to(to), cost(cost){}\n    edge(int from,int to,T cost) : from(from), to(to), cost(cost){}\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const{ return to;}\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedTree = vector< Edges<T>>;\nusing tree = vector< vector<int> >;\n\ntree make(int n,int offset = 1){\n    tree res(n);\n    for(int i = 0;i < n-1; i++){\n        int a,b; cin >> a >> b;\n        a -= offset,b -= offset;\n        res[a].emplace_back(b);\n        res[b].emplace_back(a);\n    }\n    return res;\n}\ntemplate< typename T >\nWeightedTree<T> make2(int n, int offset = 1){\n    WeightedTree<T> res(n);\n    for(int i = 0;i < n-1 ; i++){\n        int a,b ; cin >> a >> b;\n        a -= offset, b -= offset;\n        T c; cin >> c;\n        res[a].emplace_back(b,c);\n        res[b].emplace_back(a,c);\n    }\n    return res;\n}\n\nvector<int> Centers(tree &g,int idx = 0){\n    vector<int> res;\n    int max_depth = -1, leaf;\n    auto dfs = [&](auto &&self,int x,int p,int d)->bool{\n        bool flag = false;\n        if(max_depth < d){\n            max_depth = d, leaf = x, flag = true;\n            res.clear();\n        }\n        for(auto e:g[x]){\n            if(e != p)\n            flag |= self(self,e,x,d+1);\n        }\n        if(flag and (d == (max_depth>>1) or d == ((max_depth+1)>>1))) {\n            res.emplace_back(x);\n        }\n        return flag;\n    };\n    dfs(dfs,idx,-1,0);\n    max_depth = -1;\n    dfs(dfs,leaf,-1,0);\n    return res;\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    INT(n);\n    auto g = make(n);\n    rep(i,n)sort(all(g[i]));\n    auto solve = [&](auto &&self,int x) -> int{\n        if(g[x].size() == 0) return 0;\n        auto centers = Centers(g,x);\n        int res = 0;\n        if(centers.size() == 1){\n            int center = centers.back();\n            for(auto e:g[center]){\n                auto it = lower_bound(all(g[e]),center);\n                g[e].erase(it);\n                chmax(res,self(self,e));\n            }\n            return res + 1;\n        }\n        else{\n            int a = centers[0],b = centers[1];\n            auto it = lower_bound(all(g[a]),b);\n            g[a].erase(it);\n            it = lower_bound(all(g[b]),a);\n            g[b].erase(it);\n            return max(self(self,a),self(self,b)) + 1;\n        }\n    };\n    cout << solve(solve,0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<vector<int> > adj;\nvector<int> dep;\n\nvoid dfs(int u, int p) {\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        dep[v] = dep[u] + 1;\n        dfs(v, u);\n    }\n}\n\nint solve(int x) {\n    if(x == 0) return 0;\n    else return 1 + solve((x - 1) / 2);\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    adj.resize(N);\n    for(int i = 0; i < N - 1; i++) {\n        int u, v; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dep = vector<int>(N, 0);\n    dfs(0, -1);\n\n    int mx = 0, mpos = 0;\n    for(int i = 0; i < N; i++) if(mx < dep[i]) {\n        mx = dep[i];\n        mpos = i;\n    }\n\n    dep = vector<int>(N, 0);\n    dfs(mpos, -1);\n\n    mx = 0;\n    for(int i = 0; i < N; i++) if(mx < dep[i]) {\n        mx = dep[i];\n    }\n\n    printf(\"%d\", solve(mx));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 100100;\n\nvector<int> g[MAX];\n\nint ST[MAX];\nint D[MAX];\n\nvoid go(int x, int p, int val, int diff, int mx)\n{\n\t//cout<<x<<' '<<val<<' '<<mx<<endl;\n\tif (val == -1)\n\t{\n\t\tmx++;\n\t\tD[x] = mx;\n\t\tdiff = 1;\n\t}\n\telse\n\t{\n\t\tif (val == mx - 1) diff = -1;\n\t\tD[x] = val;\n\t}\n\n\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (to == p) continue;\n\n\t\tgo(to, x, val + diff, diff, mx);\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n-1)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tx--;\n\t\ty--;\n\t\tg[x].PB(y);\n\t\tg[y].PB(x);\n\n\t\tST[x]++;\n\t\tST[y]++;\n\t}\n\n\tFOR (i, 0, n)\n\t{\n\t\tif (SZ(g[i]) != 0) continue;\n\t\tgo(i, -1, 0, -1, 0);\n\t\tbreak;\n\t}\n\tint res = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tres = max(res, D[i]);\n\t//\tcout<<i+1<<' '<<D[i]<<endl;\n\t}\n\n\tcout<<res<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<set>\n#define rep(i,j,k) for(register int i = j; i <= k; i++) \n#define dow(i,j,k) for(register int i = j; i >= k; i--)\n#define fi first\n#define se second\n//#define P pair<ull,ull>\n//#define PP pair<int,pair<int,int> >\n//#define mp(a,b) make_pair(a,b)\n#define ll long long\n#define ull unsigned long long\nusing namespace std;\n \ninline int read() { \n\tint s = 0, t = 1; char c = getchar();\n\twhile( !isdigit(c) ) { if( c == '-' ) t = -1; c = getchar(); }\n\twhile( isdigit(c) ) s = s * 10 + c - 48, c = getchar();\n\treturn s * t;\n}\n\nconst int N = 1e5+5, p = 1e9+7, bit = 60;\nstruct edge{ int to, nxt; } e[N<<1];\nint head[N], cnt = 0, deg[N];\ninline void add(int x,int y) {\n\tdeg[x]++, deg[y]++; \n\te[++cnt].to = y, e[cnt].nxt = head[x], head[x] = cnt;\n\te[++cnt].to = x, e[cnt].nxt = head[y], head[y] = cnt;\n}\n\nll f[N], g[64]; \n#define ez(i,j) for(register int i = head[j]; i; i=e[i].nxt)\n#define to e[i].to\ninline void dfs(int x,int fa=0) { \n\tez(i,x) if( to != fa ) dfs(to,x);\n\tmemset(g,0,sizeof(g));\n\tez(i,x) if( to != fa ) { \n\t\trep(j,0,bit) if( (f[to] >> j) & 1 ) g[j]++;\n\t}\n\tint ret = 0; \n\tdow(i,bit,0) if( g[i] >= 2 ) { ret = i + 1; break; }\n\trep(i,ret,bit) if( !g[i] ) { ret = i; break; }\n\tf[x] = 1ll << ret;\n\trep(i,ret+1,bit) if( g[i] ) f[x] |= 1ll << i;\n}\n\nint main() {\n\tint n = read(), rt = 0;\n\trep(i,1,n-1) add(read(),read());\n\tif( n == 2 ) return puts(\"1\"), 0;\n\trep(i,1,n) if( deg[i] > 1 ) { rt = i; break; }\n\tdfs(rt);\n\tdow(i,bit,0) if( (f[rt] >> i) & 1 ) return printf(\"%d\\n\",i), 0;\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nconstexpr int MAX = 20;\n\nclass DUninity {\npublic:\n    int N;\n    vector<vector<int>> E;\n\n    int dfs(int u, int p) {\n        int any = 0, two = 0;\n        for (int v: E[u]) if (v != p) {\n            int s = dfs(v, u);\n            two |= any & s;\n            any |= s;\n        }\n        int ans = MAX;\n        for (int i = MAX-1; i >= 0; --i) {\n            if (two&1<<i) break;\n            if (any&1<<i) {} else ans = i;\n        }\n        int cur = 1<<ans|(any&~((1<<ans)-1));\n        return cur;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        E.resize(N);\n        for (int i = 0; i < N - 1; ++i) {\n            int a, b; cin >> a >> b;\n            --a; --b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        cout << logceil(dfs(0, -1)) - 1 << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDUninity solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, d[N], dp[N];\nvector <int> g[N];\n\nvoid dfs (int, int, int);\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tdfs (0, -1, 0);\n\tint far = 0;\n\tfor (int v = 1; v < n; v++)\n\t\tif (d[v] > d[far])\n\t\t\tfar = v;\n\t// cerr << far + 1 << endl;\n\tdfs (far, -1, 0);\n\tint len = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tlen = max(len, d[i]);\n\n\t// cerr << \"len: \" << len << endl;\n\tlen++;\n\tdp[1] = 0;\n\tfor (int i = 2; i <= len; i++)\n\t\tdp[i] = dp[i / 2] + 1;\n\t\n\t// for (int i = 0; i <= len; i++)\n\t// \tcout << dp[i] << ' ';\n\t// cout << endl;\n\tcout << dp[len] << endl;\n}\n\nvoid dfs (int v, int pv, int depth) {\n\t// cerr << \"dfs: \" << v + 1 << ' ' << pv + 1 << ' ' << depth << endl;\n\td[v] = depth;\n\tfor (int u: g[v])\n\t\tif (u != pv)\n\t\t\tdfs (u, v, depth + 1);\n}\n\n// SamMHD :: Feb17-2019 :: Another Simulation"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 1<<17, LOG = 20;\n\nint n;\nint rje;\nint p[MAX];\nint nesmije[MAX][LOG];\nvector <int> V[MAX];\n\nvoid dfs(int node, int par)\n{\n  for (auto it : V[node])\n    if (it != par)\n      dfs(it, node);\n\n  p[node] = -1;\n  int mn = 0;\n  for (int i=LOG-1; i>=0; i--)\n    if (nesmije[node][i] > 1) {\n      mn = i + 1;\n      break;\n    }\n\n  FOR(i, mn, LOG) {\n    if (!nesmije[node][i]) {\n      p[node] = i;\n      //      TRACE(node _ p[node]);\n      break;\n    }\n  }\n\n  assert(p[node] != -1);\n  rje = max(rje, p[node]);\n  \n  if (par != -1) {\n    nesmije[par][p[node]]++;\n    FOR(i, p[node], LOG)\n      if (nesmije[node][i])\n\tnesmije[par][i]++;\n  }\n}\n\nvoid load()\n{\n  scanf(\"%d\", &n);\n\n  REP(i, n-1) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b); a--; b--;\n    V[a].push_back(b);\n    V[b].push_back(a);\n  }\n}\n\nvoid gen()\n{\n  n = rand() % 10 + 1;\n  REP(i, n) V[i].clear();\n  \n  printf(\"%d\\n\", n);\n  FOR(i, 1, n) {\n    int a = rand() % i;\n    V[a].push_back(i);\n    V[i].push_back(a);\n    printf(\"%d %d\\n\", a+1, i+1);\n  }\n}\n\nint val[MAX];\n\nint check()\n{\n  int e[n][n];\n  REP(i, n) REP(j, n) e[i][j] = MAX;\n\n  REP(i, n)\n    for(auto it : V[i])\n    e[i][it] = max(val[i], val[it]);\n\n  REP(i, n)\n    REP(j, n)\n    REP(k, n)\n    e[j][k] = min(e[j][k], max(e[j][i], e[i][k]));\n  \n  REP(i, n)\n    REP(j, n)\n    if (i != j && val[i] == val[j] && e[i][j] <= val[i])\n      return 0;\n\n  return 1;\n}\n\nint rek(int poz, int mx)\n{\n  if (poz == n) return check();\n  REP(i, mx+1) {\n    val[poz] = i;\n    if (rek(poz+1, mx))\n      return 1;\n  }\n\n  return 0;\n}\n\nint brute()\n{\n  REP(i, LOG)\n    if (rek(0, i)) {\n      printf(\"BRUTE\\n\");\n      REP(j, n)\n\tprintf(\"%d \", val[j]);\n      printf(\"\\n\");\n      return i;\n    }\n  \n  assert(0);\n}\n\nint solve()\n{\n  REP(i, n) REP(j, LOG) nesmije[i][j] = 0;\n  rje = 0;\n  dfs(0, -1);\n  //  TRACE(p[0]);\n  return rje;\n}\n\nint main()\n{\n  // for (;;) {\n  //   gen();\n  //   int sl = solve(), br = brute();\n  //   if (sl != br) {\n  //     TRACE(sl _ br);\n  //     assert(0);\n  //   }\n  //  }\n    load();\n\n  printf(\"%d\\n\", solve());\n  //  REP(i, n) printf(\"%d \", p[i]);\n  //  printf(\"\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author jcg\n */\n\n#include <bits/stdc++.h>\n\n#include <bits/stdc++.h>\n\n\n// Complexity: O(n + k)\ntemplate<typename ForwardIt, typename Func>\nstd::vector<typename std::iterator_traits<ForwardIt>::value_type> counting_sort(ForwardIt first, ForwardIt last, const Func &func)\n{\n    int maxk = 0, n = 0;\n    for (auto it = first; it != last; ++it, ++n)\n        maxk = std::max(maxk, func(*it));\n    std::vector<int> cnt(maxk + 1);\n    for (auto it = first; it != last; ++it)\n        ++cnt[func(*it)];\n    for (int i = 0, sum = 0; i <= maxk; ++i)\n    {\n        sum += cnt[i];\n        cnt[i] = sum - cnt[i];\n    }\n    std::vector<typename std::iterator_traits<ForwardIt>::value_type> result(n);\n    for (auto it = first; it != last; ++it)\n        result[cnt[func(*it)]++] = *it;\n    return result;\n}\n\n\nstruct parent_representation\n{\n    std::vector<int> parent;\n    std::vector<int> ord; // preorder\n};\n\nparent_representation get_parent_representation(int root, const std::vector<int> &u, const std::vector<int> &v)\n{\n    const int n = u.size() + 1;\n    std::vector<int> degree(n), edges(2 * u.size());\n    for (int i = 0; i < n - 1; ++i)\n    {\n        ++degree[u[i]]; ++degree[v[i]];\n        edges[i] = i;\n        edges[i + u.size()] = i + u.size();\n    }\n    auto same = [&](int e) { return e < u.size() ? u[e] : v[e - u.size()]; };\n    auto other = [&](int e) { return e < u.size() ? v[e] : u[e - u.size()]; };\n    edges = counting_sort(edges.begin(), edges.end(), same);\n    //std::sort(edges.begin(), edges.end(), [&](int x, int y) { return same(x) < same(y); });\n    std::vector<int> first(n, -1), last(n);\n    for (int i = 0; i < (int) edges.size(); ++i)\n    {\n        int e = edges[i];\n        if (first[same(e)] == -1)\n            first[same(e)] = i;\n        last[same(e)] = i;\n    }\n    std::vector<int> parent(n, -1), ord, stk;\n    for (stk.emplace_back(root); !stk.empty();)\n    {\n        int x = stk.back();\n        ord.emplace_back(x);\n        stk.pop_back();\n        for (int k = first[x]; k <= last[x]; ++k)\n        {\n            int y = other(edges[k]);\n            if (parent[y] == -1 && y != root)\n                parent[y] = x, stk.push_back(y);\n        }\n    }\n    //assert(ord.size() == n);\n//    for (int i = 0; i < n; ++i)\n//        std::cout << i+1 << \" \" << parent[i]+1 << std::endl;\n//    for (int x : ord) std::cout << x+1 << \" \";\n//    std::cout << std::endl;\n    return parent_representation{parent, ord};\n}\n\nstd::vector<int> strategy_function(const std::vector<int> &u, const std::vector<int> &v)\n{\n    parent_representation rep = get_parent_representation(0, u, v);\n    const auto &parent = rep.parent;\n    const auto &ord = rep.ord;\n    const int n = ord.size();\n    std::vector<int> label(n), used(n), more(n);\n    for (int i = n - 1; i >= 0; --i)\n    {\n        int u = ord[i];\n        for (int k : {1, 2, 4, 8, 16})\n            more[u] |= more[u] >> k;\n        ++more[u];\n        int possible = ~used[u] & -more[u];\n        label[u] = possible & -possible;\n        used[u] |= label[u];\n        used[u] &= -label[u];\n        if (parent[u] != -1)\n        {\n            int p = parent[u];\n            more[p] |= used[u] & used[p];\n            used[p] |= used[u];\n        }\n    }\n    return label;\n}\n\nclass DUninity\n{\npublic:\n    void solve(std::istream& in, std::ostream& out)\n    {\n        using std::vector;\n\n        int n;\n        in >> n;\n\n        vector<int> u(n - 1), v(n - 1);\n        for (int i = 0; i < n - 1; ++i)\n        {\n            in >> u[i] >> v[i];\n            --u[i], --v[i];\n        }\n\n        auto label = strategy_function(u, v);\n        out << std::__lg(*std::max_element(label.begin(), label.end())) << '\\n';\n    }\n};\n\n\nint main()\n{\n    std::ios_base::sync_with_stdio(0);\n    std::istream& in(std::cin);\n    std::ostream& out(std::cout);\n    in.tie(0);\n    DUninity solver;\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=100005;\n\nint N;\nvector<int> adj[MAXN];\nint val[MAXN],ans;\n\nvoid dfs(int u,int fa=0)\n{\n\tint mk=0;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tdfs(v,u);\n\t\tmk|=(val[u]&val[v]);\n\t\tval[u]|=val[v];\n\t}\n\tif(val[u]==0)\n\t\tval[u]=1;\n\telse\n\t{\n\t\tint id=0;\n\t\twhile((1<<id)<mk||(val[u]&(1<<id)))\n\t\t\tid++;\n\t\tval[u]=((val[u]>>id)<<id)|(1<<id);\n\t\tans=max(ans,id);\n\t}\n\t//printf(\"val[%d]=%d\\n\",u,val[u]);\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tdfs(1);\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(a,b,c) for (int a=b;a<=c;a++)\n#define per(a,b,c) for (int a=b;a>=c;a--)\n#define go(u) for (int o=ft[u],v;v=E[o].t;o=E[o].n)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> par;\nconst int N=100010;\nint ft[N],dp[N],n,tot;\nstruct edge{int t,n;}E[N<<1];\nvoid add(int x,int y){\n\tE[++tot]=(edge){y,ft[x]},ft[x]=tot;\n}\nvoid dfs(int u,int f=0){\n\tgo(u) if (v!=f){\n\t\tdfs(v,u);\n\t}\n\tfor (int bit=1;;bit<<=1){\n\t\tint flag=0;\n\t\tdp[u]=0;\n\t\tgo(u) if (v!=f){\n\t\t\tif (dp[v]&bit) goto nxt;\n\t\t\tif (dp[v]>bit) ++flag,dp[u]=dp[v];\n\t\t\tif (flag>1) goto nxt;\n\t\t}\n\t\tdp[u]&=~(bit-1);\n\t\tdp[u]|=bit;\n\t\treturn;\n\tnxt:;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,2,n){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs(1);\n\tper(i,28,0) if (dp[1]&1<<i){\n\t\tprintf(\"%d\\n\",i);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 1000010\n#define MAXD 21\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1];\n\nint n;\nint g[MAXN],nume;\nint f[MAXN];\nint highbit[MAXN];\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid dfs(int x,int p){\n\tint s_or=0,s_and=0;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdfs(e[i].to,x);\n\t\t\ts_and|=f[e[i].to]&s_or;\n\t\t\ts_or|=f[e[i].to];\n\t\t}\n\tf[x]=s_or+highbit[s_and];\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"D.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d\",&n);\n\thighbit[0]=1;\n\thighbit[1]=1;\n\tfor(int i=2;i<=n<<2;i++)\n\t\thighbit[i]=highbit[i>>1]<<1;\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\tint res=0,temp=f[1];\n\twhile(temp){\n\t\tres++;\n\t\ttemp>>=1;\n\t}\n\tprintf(\"%d\\n\",res-1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=100005;\nstruct node { int y,next; } a[N<<1];\nint f[N],s[N],head[N],i,j,k,n,m,an;\nchar c;\n\ninline char getc()\n{\n\t#define VV 10000000\n\tstatic char s[VV],*l=s,*r=s;\n\tif (l==r)\n\t\tl=s,r=s+fread(s,1,VV,stdin);\n\treturn l==r?0:*l++;\n}\n\nint read(){ int z=0; do c=getc(); while (c<'0'||c>'9'); while (c>='0'&&c<='9') z*=10,z+=c-'0',c=getc(); return z; }\n\nvoid jb(int x,int y)\n{\n\ta[++k]=(node){y,head[x]},head[x]=k,\n\ta[++k]=(node){x,head[y]},head[y]=k;\n}\n\nvoid dfs(int w,int sp)\n{\n\tint z=0;\n\tfor (register int j=head[w];j;j=a[j].next)\n\t\tif ((j^1)!=sp)\n\t\t{\n\t\t\tint c=a[j].y;\n\t\t\tdfs(c,j),\n\t\t\tz|=s[w]&s[c],\n\t\t\ts[w]|=s[c];\n\t\t}\n\tif (s[w])\n\t{\n\t\twhile ((1<<f[w])<=z||(s[w]>>f[w]&1)) ++f[w];\n\t\ts[w]>>=f[w],s[w]<<=f[w],s[w]|=1<<f[w];\n\t}\n\telse\n\t\ts[w]=1;\n\tan=max(an,f[w]);\n}\n\nint main()\n{\n\tn=read(),k=1;\n\tfor (i=1;i<n;++i) jb(read(),read());\n\tdfs(1,0);\n\tprintf(\"%d\\n\",an);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N << 1];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nint N, f[MAX_N];\n\nvoid dfs(int u, int v) {\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v)\n      dfs(e[i].to, u);\n  int vis = 0, twice = 0;\n  for (int i = head[u]; i; i = e[i].nxt) \n    if (e[i].to != v) {\n      twice |= vis & f[e[i].to];\n      vis |= f[e[i].to];\n    }\n  if (!twice) {\n    f[u] = vis + 1;\n  } else {\n    int k = 20;\n    while (!(twice >> k & 1)) k--;\n    f[u] = (vis ^ (vis & ((1 << k) - 1))) + (1 << k + 1);\n  }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n\n  for (int i = 1, a, b; i < N; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    addedge(a, b);\n  }\n\n  dfs(1, 0);\n  \n  int k = 20;\n  while (!(f[1] >> k & 1)) k--;\n\n  printf(\"%d\\n\", k);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<vector<int>> graph;\nvector<int> label;\n\nint dfs_init(int node, int par) {\n    int mask = 0, beat = 0;\n    for (auto vec : graph[node]) {\n        if (vec == par) continue;\n        int now = dfs_init(vec, node);\n        beat |= (mask & now);\n        mask |= now;\n    }\n    int need = 32 - __builtin_ctz(beat);\n    mask |= (1 << need) - 1;\n    label[node] = __builtin_ctz(~mask);\n    mask ^= (1 << (need + 1)) - 1;\n    return mask;\n}\n\nint main() {\n    int n; cin >> n;\n    label.resize(n);\n    graph.resize(n);\n    for (int i = 1; i < n; ++i) {\n        int a, b; cin >> a >> b;\n        graph[a - 1].push_back(b - 1);\n        graph[b - 1].push_back(a - 1);\n    }\n    dfs_init(0, -1);\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        // cerr << label[i] << endl;\n        res = max(res, label[i]);\n    }\n    cout << res + 1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\nconst int maxn=100005;\nint n,ans=0,num,head[maxn],t[maxn<<1],ne[maxn<<1],bit[maxn],f[maxn];\ninline void addedge(int x,int y){\n\tne[++num]=head[x];head[x]=num;t[num]=y;\n\tne[++num]=head[y];head[y]=num;t[num]=x;\n}\ninline void dfs(int x,int f){\n\tint l=0,v=0;\n\tforE(i,x)if(t[i]!=f){\n\t\tdfs(t[i],x);\n\t\tl|=(bit[x]&bit[t[i]]);\n\t\tbit[x]|=bit[t[i]];\n\t}\n\tif(!bit[x])bit[x]=1;\n\telse{\n        while((1<<v)<l||(1<<v)&bit[x])v++;\n        bit[x]=(bit[x]>>v<<v)|(1<<v);\n\t}\n\tans=max(ans,v);\n}\nint main(){\n\tread(n);rep(i,1,n)head[i]=-1;\n\trep(i,1,n-1){\n\t\tint x,y;read(x);read(y);\n\t\taddedge(x,y);\n\t}dfs(1,-1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nconstexpr int MAX = 20;\n\nclass DUninity {\npublic:\n    int N;\n    vector<vector<int>> E;\n\n    int dfs(int u, int p) {\n        int any = 0, two = 0;\n        for (int v: E[u]) if (v != p) {\n            int s = dfs(v, u);\n            two |= any & s;\n            any |= s;\n        }\n        int ss = two?logceil(two):0;\n        any >>= ss;\n        any += 1;\n        any <<= ss;\n        return any;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        E.resize(N);\n        for (int i = 0; i < N - 1; ++i) {\n            int a, b; cin >> a >> b;\n            --a; --b;\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        cout << logceil(dfs(0, -1)) - 1 << '\\n';\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tDUninity solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\nint n,dep[100100],ans;\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[200100],*tp=pool,*fst[100100];\n\nint dfs(int x,int fa)\n{\n    int ret=x;\n    dep[x]=dep[fa]+1;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (i->v!=fa)\n        {\n            int t=dfs(i->v,x);\n            if (dep[t]>dep[ret])\n                ret=t;\n        }\n    return ret;0\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n-1)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        *tp=(edge){v,fst[u]},fst[u]=tp++;\n        *tp=(edge){u,fst[v]},fst[v]=tp++;\n    }\n    int t=dep[dfs(dfs(1,0),0)];\n    for (; t>1; t>>=1,++ans);\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct node {\n\tint to, next;\n} edge[MAXN*2];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nint n, a, b;\n\nint dp[MAXN], lg[MAXN];\n\ninline int lowbit(int i)\n{ return i&(-i); }\n\nvoid dfs(int nd, int f)\n{\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (to == f) continue;\n\t\tdfs(to, nd);\n\t\tdp[nd] += dp[to];\n\t}\n\tdp[nd]++;\n\t\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tlg[1] = 0;\n\tfor (int i = 2; i <= n; i++) lg[i] = lg[i>>1]+1;\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpush(a, b), push(b, a);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tans = max(ans, lg[lowbit(dp[i])]);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//cwystc <--> 陈威宇是天才  --by cwy\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst double PI=acos(-1);\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define rep(i,a,b) for (int i=(a);i<=(b);i++)\n#define per(i,a,b) for (int i=(a);i>=(b);i--)\n#define Rep(i,a,b) for (int i=(a);i<(b);i++)\n#define Per(i,a,b) for (int i=(a);i>(b);i--)\n#define travel_set(it,a) for (set<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_map(it,a) for (map<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define travel_vec(it,a) for (vector<int>::iterator (it)=(a).begin();(it)!=(a).end();(it)++)\n#define p(x) cout << x << endl;\n#define def cout << \"find\" << endl;\n#define what_is(x) cout << #x << \" is \" << x << endl;\ntemplate <class T>T sqr(T x){return x*x;}\ntemplate <class T>T alex(T x){return (x>0)?x:-x;}\ntemplate <class T>void read(T&x){\n\tx=0;T f=1;char ch=getchar();\n\twhile ((ch<48||ch>57)&&ch!=45)ch=getchar();\n\tif (ch==45)f=-1,ch=getchar();\n\twhile (ch>=48&&ch<=57)x=x*10+ch-48,ch=getchar();\n\tx*=f;\n}\n\n//-------------------------------------------------head-------------------------------------------------\n\n#define maxn 100005\nint n;\nvector<int>E[maxn];\nint sign[maxn];bool vis[maxn];\nbool gbit(int x,int bit){return (x>>bit)&1;}\nvoid dfs(int x){\n\tvis[x]=true;int _sign=0;\n\tRep(i,0,E[x].size())if (!vis[E[x][i]]){\n\t\tdfs(E[x][i]);_sign|=sign[E[x][i]];\n\t}\n\tRep(i,0,20){_sign^=(1<<i);if (gbit(_sign,i)==1)break;}\n\tsign[x]=_sign;\n}\nint main(){\n\t// freopen(\"D.in\",\"r\",stdin);\n\t// freopen(\"D.out\",\"w\",stdout);\n\tread(n);\n\tRep(i,1,n){\n\t\tint x,y;read(x);read(y);\n\t\tE[x].pb(y);E[y].pb(x);\n\t}\n\tdfs(1);int res=0;\n\trep(i,1,n)res=max(res,sign[i]);\n\tres=(int)log2(res);printf(\"%d\\n\",res);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define YYS(x, arr) for(auto& x: arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1e9 + 7;\n\ntemplate<class T> T &chmin(T &a, const T &b){return a = min(a, b);}\ntemplate<class T> T &chmax(T &a, const T &b){return a = max(a, b);}\ntemplate<class T> void UNIQUE(vector<T> &a){a.erase(unique(a.begin(), a.end()), a.end());}\n\ntemplate<class S, class T> ostream& operator <<(ostream &os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i < 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator <<(ostream &os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i < 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; assert(scanf(\"%lld\", &x) == 1); return x;}\nld fin(){double x; assert(scanf(\"%lf\", &x) == 1); return x;}\nchar yuyushiki[10000010]; string stin(){assert(scanf(\"%s\", yuyushiki) == 1); return yuyushiki;}\n\n// head\n\nvector<int> G[100010];\n\nint ans = -1;\n\nint dfs(int x, int p = -1){\n  vector<int> cnt(30);\n  int chor = 0;\n  YYS(w, G[x]){\n    if(w == p){\n      continue;\n    }\n    int res = dfs(w, x);\n    chor |= res;\n    REP(i, 30){\n      if(res & PW(i)){\n        cnt[i]++;\n      }\n    }\n  }\n  // cout << x << \" \" << chor << endl;\n  int ma = -1;\n  REP(i, 30){\n    if(cnt[i] >= 2){\n      chmax(ma, (int)i);\n    }\n  }\n  FOR(i, ma+1, 30){\n    if(cnt[i] == 0){\n      chor |= PW(i);\n      chor &= PW(30) - PW(i);\n      chmax(ans, (int)i);\n      // cout << x << \" \" << i << endl;\n      return chor;\n    }\n  }\n}\n\nint main(){\n\n  int n = in();\n  REP(i, n-1){\n    int a = in() - 1;\n    int b = in() - 1;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n\n  dfs(0);\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      //if(cnt[v]==0) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      //assert(cnt[v]==1);\n      //assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n\n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n\n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge\n{\n\tint v,next;\n}vs[N];\nint n,mask[N][30],st[N],ee,Ans;\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt,int pr)\n{\n\tint cur=-1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt);\n\t\tfor(int j=0;j<30;j++)\n\t\t{\n\t\t\tif(mask[rt][j]&&mask[vs[i].v][j]) cur=j;\n\t\t\tmask[rt][j]|=mask[vs[i].v][j];\n\t\t}\n\t}\n\tfor(++cur;cur<30;++cur) if(!mask[rt][cur]) break;\n\tAns=max(Ans,cur); mask[rt][cur]=1;\n\tfor(--cur;cur>=0;cur--) mask[rt][cur]=0;\n}\nint main()\n{\n\tn=read(); for(int i=1;i<n;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v);\n\t\taddedge(v,u);\n\t}\n\tdfs(1,0); cout << Ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\n\nvector<int> t_parent;\nvector<int> t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile (!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor (int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif (t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint N;\n\twhile (~scanf(\"%d\", &N)) {\n\t\tvector<vector<int> > g(N);\n\t\tfor (int i = 0; i < N - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tint n = (int)t_ord.size();\n\t\tvector<unsigned> a(n), b(n), f(n);\n\t\tunsigned maxf = 0;\n\t\tfor (int ix = n - 1; ix >= 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tunsigned m = b[i];\n\t\t\tm |= m >> 1;\n\t\t\tm |= m >> 2;\n\t\t\tm |= m >> 4;\n\t\t\tm |= m >> 8;\n\t\t\tm |= m >> 16;\n\t\t\tunsigned fi = ~(a[i] | m);\n\t\t\tfi &= ~fi + 1;\n\t\t\tf[i] = fi;\n\t\t\tif (maxf < fi)\n\t\t\t\tmaxf = fi;\n\t\t\tunsigned S = (a[i] & ~(fi - 1)) | fi;\n\t\t\tif (p != -1) {\n\t\t\t\tb[p] |= a[p] & S;\n\t\t\t\ta[p] |= S;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\twhile (maxf >> 1 >> ans) ++ ans;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  \n  function<Int(Int, Int)> dfs=[&](Int v,Int p){\n    Int one=0,two=0;\n    for(Int u:G[v]){\n      if(u==p) continue;\n      Int tmp=dfs(u,v);\n      two|=(one&tmp);\n      one|=tmp;\n    }\n    Int res=1;\n    while(res<=two||(one&res)) res<<=1;\n    return (one&~(res-1))|res;\n  };\n  \n  Int res=dfs(0,-1);\n  Int ans=31-__builtin_clz(res);\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\n\nint n, l[maxn], dp[maxn], e;\nint cnt[21];\n\nstruct Edge {\n\tint v, x;\n} E[maxn<<1];\n\ninline void addEdge(int u, int v) {\n\tE[e].v = v; E[e].x = l[u]; l[u] = e++;\n}\n\nvoid dfs(int u, int f) {\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (v != f) dfs(v, u);\n\t}\n\tfor (int i = 0; i <= 20; i++) cnt[i] = 0;\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tif (v != f) {\n\t\t\tfor (int j = 0; j <= 20; j++) {\n\t\t\t\tif (dp[v] & (1<<j)) {\n\t\t\t\t\t++ cnt[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint mn = 0;\n\tfor (int i = 0; i <= 20; i++) if (cnt[i] >= 2) mn = i+1;\n\tint val = 0;\n\tfor (int i = mn; i <= 20; i++) {\n\t\tif (!cnt[i]) {\n\t\t\tval = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdp[u] ^= (1 << val);\n\tfor (int i = val; i <= 20; i++) {\n\t\tif (cnt[i]) {\n\t\t\tdp[u] ^= (1<<i);\n\t\t}\n\t}\n}\n\nint main() {\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\taddEdge(u, v);\n\t\taddEdge(v, u);\n\t}\n\tdfs(1, 0);\n\tint mx = 0;\n\tfor (int i = 0; i <= 20; i++) {\n\t\tif (dp[1] & (1<<i)) {\n\t\t\tmx = i;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\nconst int N=100001;\nint n,m,cnt,res,head[N],du[N],q[N],t[N];\nstruct edge{int to,nxt;}e[N*2];\nvector<int>s[N];bool vis[N];\nbool cmp(int a,int b){return a>b;}\nvoid add(int x,int y){e[++cnt]=(edge){y,head[x]};head[x]=cnt;}\nint main(){\n\tscanf(\"%d\",&n);\n\tref(i,2,n){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tadd(x,y),add(y,x);du[x]++,du[y]++;\n\t}\n\tres=1;\n\tref(i,1,n)if(du[i]==1)q[++m]=i;\n\tref(i,1,n){\n\t\tint x=q[i];vis[x]=1;\n\t\tif(s[x].empty())s[x].push_back(1);else{\n\t\t\tint p=0,r=1,sz=s[x].size()-1;\n\t\t\tif(t[x]>1){\n\t\t\t\tsort(s[x].begin(),s[x].end(),cmp);\n\t\t\t\tref(i,1,sz)if(s[x][i]==s[x][i-1]){p=i;break;}\n\t\t\t\tif(p){\n\t\t\t\t\tr=s[x][p]+1;\n\t\t\t\t\twhile(sz>=p-1)s[x].pop_back(),sz--;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(sz>=0&&s[x][sz]==r)s[x].pop_back(),r++,sz--;\n\t\t\ts[x].push_back(r);if(r>res)res=r;\n\t\t}\n\t\tint sz=s[x].size()-1;\n\t\tfor(int j=head[x];j;j=e[j].nxt){\n\t\t\tint y=e[j].to;\n\t\t\tif(!vis[y]){\n\t\t\t\tref(I,0,sz)s[y].push_back(s[x][I]);\n\t\t\t\tdu[y]--;t[y]++;if(du[y]==1)q[++m]=y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res-1);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n;\nvvi G;\nint dfs(int a,int p){\n\tvi t;\n\trep(i,G[a].size())if(G[a][i]-p)t.pb(dfs(G[a][i],a));\n\tif(t.size()==0)return 1;\n\tint w=0;\n\trep(i,20){\n\t\tint c=0;\n\t\trep(j,t.size())if(t[j]&1<<i)c++;\n\t\tif(c>1)w=i;\n\t}\n\tint b=0;\n\trep(i,t.size())b|=t[i];\n\tloop(j,w,20)if((b&1<<j)==0){\n\t\tb>>=j;\n\t\tb++;\n\t\tb<<=j;\n\t\treturn b;\n\t}\n}\nsigned main(){\n\tcin>>n;\n\tG=vvi(n);\n\trep(i,n-1){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tint a=dfs(0,-1);\n\tfor(int i=19;i>=0;i--)if(a&1<<i){\n\t\tcout<<i<<endl;\n\t\treturn 0;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\n\nconst int N=1e5+9;\n\nunsigned int bit[N];\nint n,f[N],ans;\nint to[N<<1],nxt[N<<1],beg[N],tot;\n\ninline void add(int u,int v)\n{\n\tto[++tot]=v;\n\tnxt[tot]=beg[u];\n\tbeg[u]=tot;\n}\n\ninline void dfs(int u,int fa)\n{\n\tbit[u]=f[u]=0;\n\tint las=0;\n\tfor(int i=beg[u],v;i;i=nxt[i])\n\t\tif((v=to[i])!=fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tlas|=bit[v]&bit[u];\n\t\t\tbit[u]|=bit[v];\n\t\t}\n\tif(bit[u]==0)\n\t\tbit[u]=1;\n\telse\n\t{\n\t\twhile((1<<f[u])<las || bit[u]&(1<<f[u]))f[u]++;\n\t\tbit[u]=(bit[u]>>f[u]<<f[u])|(1<<f[u]);\n\t}\n\tif(ans<f[u])ans=f[u];\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tu=read();v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 100001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nconst int S=(1<<17)-1;\nint n,ans,f[N];\nint cnt,head[N],nxt[N+N],to[N+N];\nvoid dfs(int u,int fa)\n{\n\tint mx=0;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif((v=to[i]) != fa)\n\t\t{\n\t\t\tdfs(v,u);\n\t\t\tmx=max(mx,f[u]&f[v]);\n\t\t\tf[u]|=f[v];\n\t\t}\n\tint mn=0;\n\twhile(f[u]>>mn&1)++mn;\n\tfor(int i=16;;--i)\n\t\tif(i<mn || mx>>i&1)\n\t\t{\n\t\t\t++i;\n\t\t\tf[u]&=S-((1<<i)-1);\n\t\t\tf[u]|=1<<i;\n\t\t\tans=max(ans,i);\n\t\t\t// cerr<<u<<\" \"<<i<<endl;\n\t\t\tbreak;\n\t\t}\n}\nint main()\n{\n\tre(n);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre(u),re(v);\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\nsigned main() {\n\tINIT;\n\tVAR(int, n);\n\tVEC_ROW(int, n - 1, a, b);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n - 1) {\n\t\t--a[i]; --b[i];\n\t\tg[a[i]].emplace_back(b[i]);\n\t\tg[b[i]].emplace_back(a[i]);\n\t}\n\n\tint ans = 0;\n\twhile (true) {\n\t\tstd::vector<int> checked(g.size(), -1);\n\t\tint p = 0;\n\t\tstd::map<int, std::set<int>> map;\n\t\tREP(i, g.size()) {\n\t\t\tif (checked[i] >= 0) continue;\n\t\t\tif (g[i].size() == 1) {\n\t\t\t\tint c = g[i][0];\n\t\t\t\tif (checked[c] >= 0) continue;\n\t\t\t\tfor(const auto& j : g[c]) {\n\t\t\t\t\tchecked[j] = p;\n\t\t\t\t}\n\t\t\t\tchecked[c] = p++;\n\t\t\t}\n\t\t}\n\t\tREP(i, g.size()) {\n\t\t\tif (checked[i] >= 0) {\n\t\t\t\tif (g[i].size() == 1) {\n\t\t\t\t\tint c = g[i][0];\n\t\t\t\t\tfor (const auto& j : g[c]) {\n\t\t\t\t\t\tif (g[j].size() >= 2) {\n\t\t\t\t\t\t\tfor (const auto& k : g[j]) {\n\t\t\t\t\t\t\t\tif (k == c) continue;\n\t\t\t\t\t\t\t\tint t = k;\n\t\t\t\t\t\t\t\tif (checked[k] >= 0) t = 200000 + checked[k];\n\t\t\t\t\t\t\t\tmap[200000 + checked[c]].insert(t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (const auto& j : g[i]) {\n\t\t\t\t\tint t = j;\n\t\t\t\t\tif (checked[j] >= 0) t = 200000 + checked[j];\n\t\t\t\t\tmap[i].insert(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::map<int, int> map2;\n\t\tint ppp = 0;\n\t\tfor (const auto& x : map) {\n\t\t\tmap2[x.first] = ppp++;\n\t\t}\n\n\t\tstd::vector<std::vector<int>> gg;\n\t\tfor(const auto& x : map) {\n\t\t\tstd::vector<int> vec(x.second.size());\n\t\t\tint pp = 0;\n\t\t\tfor (const auto& y : x.second) {\n\t\t\t\tvec[pp++] = map2[y];\n\t\t\t}\n\t\t\tgg.emplace_back(vec);\n\t\t}\n\t\tg = gg;\n\t\t++ans;\n\t\tif (g.empty()) {\n\t\t\tOUT(ans)BR;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> bool chkmax(T &a, const T &b) { return a < b ? a = b, true : false; }\ntemplate <typename T> bool chkmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\ntypedef long long LL;\ntypedef long double LD;\nconst int BUF_SIZE = (int)2e7 + 10;\nstruct fastIO {\n    char buf[BUF_SIZE], buf1[BUF_SIZE];\n    int cur, cur1; FILE *in, *out;\n    fastIO() { cur = BUF_SIZE, in = stdin, out = stdout; cur1 = 0; __builtin_prefetch(buf);__builtin_prefetch(buf1);}\n    inline char getchar() { if(cur == BUF_SIZE) fread(buf, BUF_SIZE, 1, in), cur = 0; return *(buf + (cur++)); }\n    inline void putchar(char ch) { *(buf1 + (cur1++)) = ch; if (cur1 == BUF_SIZE) fwrite(buf1, BUF_SIZE, 1, out), cur1 = 0; }\n    inline int flush() { if (cur1 > 0) fwrite(buf1, cur1, 1, out); return cur1 = 0; }\n}IO;\n#define getchar IO.getchar\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n} \n\nconst int Maxn = 1e5 + 9;\nstruct edge {\n\tint to, nxt;\n}g[Maxn << 1];\nint n, head[Maxn];\nvoid add(int u, int v) { \n\tstatic int e = 0;\n\tg[++e] = (edge){v, head[u]}, head[u] = e; \n}\n\nint ans = 0;\nstatic int bit[Maxn];\n\nvoid dfs(int u, int pa) {\n\tint same = 0;\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tdfs(v, u);\n\t\t\tsame |= bit[u] & bit[v];\n\t\t\tbit[u] |= bit[v];\n\t\t}\n\t}\n\tint mx = __builtin_ffs(same);\n\twhile (bit[u] & (1 << mx)) ++mx;\n\tbit[u] |= (1 << mx);\n\tchkmax(ans, mx), bit[u] = bit[u] >> mx << mx;\n}\n\nint main() {\n\n\tclar(head, -1);\n\tn = read();\n\trep (i, 1, n - 1) {\n\t\tint u = read(), v = read();\n\t\tadd(u, v), add(v, u);\n\t}\n\tdfs(1, 0);\n\tcout << ans << endl;\n\n#ifdef Qrsikno\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\nvi to[MX];\nint c[MX];\n\nP cfs(int v, int d=0, int p=-1) {\n  P res(d,v);\n  for (int u : to[v]) {\n    if (c[u] || u == p) continue;\n    maxs(res, cfs(u,d+1,v));\n  }\n  return res;\n}\nvi vs;\nbool vfs(int v, int t, int p=-1) {\n  if (v == t) {\n    vs.pb(v);\n    return true;\n  }\n  for (int u : to[v]) {\n    if (p == u) continue;\n    if (vfs(u,t,v)) {\n      vs.pb(v);\n      return true;\n    }\n  }\n  return false;\n}\nint dfs(int v) {\n  v = cfs(v).se;\n  P p = cfs(v);\n  vs = vi();\n  vfs(v,p.se);\n  v = vs[p.fi/2];\n  c[v] = 1;\n  int res = 0;\n  for (int u : to[v]) {\n    if (c[u]) continue;\n    maxs(res,dfs(u)+1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a; --b;\n    to[a].pb(b);\n    to[b].pb(a);\n  }\n  cout<<dfs(0)<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      //if(cnt[v]==0) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      //assert(cnt[v]==1);\n      //assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n      //if(c<0) continue;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n    for(Int i=0;i<n;i++){\n      //if(!used[i]) exit(0);\n      if(belong[i]<0) exit(0);\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\nint i,t,n,ipt[200005][3],m=-0x7fffffff,p;\nint visit[200005],visit2[200005],dis[200005],dis2[200005];\npair<int,int>pt;\nqueue<int>q;\nvector<pair<int,int> >table[200005];\nvector<pair<int,int> >::iterator it;\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(i=0;i<n-1;i++) {\n        scanf(\"%d%d\",&ipt[i][0],&ipt[i][1]);\n        table[ipt[i][0]].push_back(make_pair(ipt[i][1],1));\n        table[ipt[i][1]].push_back(make_pair(ipt[i][0],1));\n    }\n    q.push(1);\n    visit[1]=1;\n    while(!q.empty()) {\n        t=q.front();\n        q.pop();\n        for(it=table[t].begin();it!=table[t].end();it++) {\n            if(!visit[(*it).first]){\n                dis[(*it).first]=dis[t]+(*it).second;\n                if(dis[(*it).first]>m) {\n                    m=dis[(*it).first];\n                    p=(*it).first;\n                }\n                q.push((*it).first);\n                visit[(*it).first]=1;\n            }\n        }\n    }\n    m=-0x7fffffff;\n    q.push(p);\n    visit2[p]=1;\n    while(!q.empty()) {\n        t=q.front();\n        q.pop();\n        for(it=table[t].begin();it!=table[t].end();it++) {\n            if(!visit2[(*it).first]){\n                dis2[(*it).first]=dis2[t]+(*it).second;\n                if(dis2[(*it).first]>m) {\n                    m=dis2[(*it).first];\n                    p=(*it).first;\n                }\n                q.push((*it).first);\n                visit2[(*it).first]=1;\n            }\n        }\n    }\n    for(int i=0;;i++) {\n\t\tif((1<<(i+1))-2 >= m) {printf(\"%d\\n\", i); return 0;}\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n\nconst int N=int(1e5)+5;\n\nint n;\n\nstruct node;\nstruct edge{\n\tnode *ed;\n\tedge *next;\n} E[N<<1],*newE=E;\nstruct node{\n\tedge *son;\n\tnode *pa;\n\tint level;\n\tint size;\n\tbool done;\n\tvoid dfs(int lev,node *from=NULL){\n\t\tsize=1;\n\t\tfor(edge *e=son;e;e=e->next) if(!e->ed->done&&e->ed!=from){\n\t\t\te->ed->dfs(lev,this);\n\t\t\tsize+=e->ed->size;\n\t\t}\n\t}\n} V[N];\n\nnode* getroot(node *u){\n\twhile(true){\n\t\tnode *v=NULL;\n\t\tfor(edge *e=u->son;e;e=e->next) if(!e->ed->done&&e->ed->size*2>u->size){\n\t\t\tv=e->ed;\n\t\t\tbreak;\n\t\t}\n\t\tif(!v) break;\n\t\tint t=u->size;\n\t\tu->size-=v->size;\n\t\tv->size=t;\n\t\tu=v;\n\t}\n\treturn u;\n}\n\nint ans=0;\n\nvoid dianfen(node *u,node *fa=NULL,int lev=0){\n\tans=max(ans,lev);\n\tu->dfs(lev);\n\tu=getroot(u);\n\tu->pa=fa;\n\tu->level=lev;\n\tu->dfs(lev);\n\tu->done=true;\n\tfor(edge *e=u->son;e;e=e->next) if(!e->ed->done){\n\t\tnode *v=e->ed;\n\t\tdianfen(v,u,lev+1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint x,y; scanf(\"%d%d\",&x,&y);\n\t\t*newE=(edge){V+y,V[x].son},V[x].son=newE++;\n\t\t*newE=(edge){V+x,V[y].son},V[y].son=newE++;\n\t}\n\tdianfen(&V[1]);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <list>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <deque>\n#include <functional>\n#include <iterator>\n#include <utility>\n#include <bitset>\n#include <cstdlib>\n#include <ctime>\n#include <complex>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\n#define FOR(i, a, b) for(int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, a, b) for (int i = (a); i < (b); ++i)\n#define REPD(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define SZ(x) ((int)x.size())\n#define openfile {freopen(\"inp.txt\",\"rt\",stdin);freopen(\"out.txt\",\"wt\",stdout);}\n#define debug 0\n\ntemplate <typename T> inline void next_int(T &x) {\n\tx = 0; char c; bool neg = false;\n\twhile (!isdigit(c = getchar())) if (c == '-') neg = true;\n\tdo x = x*10 + c - 48; while (isdigit(c = getchar()));\n\tif (neg) x = -x;\n}\n\ntemplate <typename T> inline void write_int(T x) {\n\tif (x > 9) write_int(x / 10);\n\tputchar(x % 10 + 48);\n}\n\nconst int N = (int)2e5+5;\nint n, n2, sz[N], ans[N];\nbool vis[N];\nvector< vector<int> > g;\n\nvoid dfs_sz(int u, int p) {\n\tsz[u] = 1, ++n2;\n\tREP(i, 0, SZ(g[u])) {\n\t\tint v = g[u][i];\n\t\tif (vis[v] || v == p) continue;\n\t\tdfs_sz(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nint dfs_center(int u, int p) {\n\tREP(i, 0, SZ(g[u])) {\n\t\tint v = g[u][i];\n\t\tif (vis[v] || v == p) continue;\n\t\tif (sz[v] > n2 / 2) return dfs_center(v, u);\n\t}\n\treturn u;\n}\n\nvoid decompose(int u, int depth) {\n\tn2 = 0;\n\tdfs_sz(u, 0);\n\tint mid = dfs_center(u, 0);\n\tans[mid] = depth, vis[mid] = true;\n\tREP(i, 0, SZ(g[mid])) {\n\t\tint v = g[mid][i];\n\t\tif (vis[v]) continue;\n\t\tdecompose(v, depth + 1);\n\t}\n}\n\nint main() {\n\tnext_int(n);\n\tg.resize(n + 1);\n\tREP(i, 1, n) {\n\t\tint u, v;\n\t\tnext_int(u), next_int(v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdecompose(1, 0);\n\tprintf(\"%d\", *max_element(ans + 1, ans + n + 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\ntemplate<typename T>\nvector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nstruct yes_no : numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\ntypedef int Weight;\nWeight INF = 1000000000;\nstruct Edge{ int src, dest; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int src, int dest, Weight weight) {\n  g[src].push_back((Edge){src, dest, weight});\n}\n\nvoid bfs01(Graph &g, vector<int> &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  deque<P> que;\n  que.push_back(P(0, s));\n  while (!que.empty()) {\n    P top = que.front(); que.pop_front();\n    Weight dist = top.first; int v = top.second;\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        if (e.weight) que.push_back(P(d[e.dest], e.dest));\n        else que.push_front(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint logg(int n) {\n  if (n == 1) return 0;\n  return logg(n / 2) + 1;\n}\n\nvoid solve(ll N, vector<ll> a, vector<ll> b) {\n  Graph g(N);\n  REP(i,N-1) {\n    // cout << \"Ok\" << endl;\n    add_edge(g, a[i] - 1, b[i] - 1, 1);\n    add_edge(g, b[i] - 1, a[i] - 1, 1);\n  }\n  Array d;\n  bfs01(g, d, 0);\n  int v = max_element(ALL(d)) - begin(d);\n  bfs01(g, d, v);\n  v = max_element(ALL(d)) - begin(d);\n  cout << logg(d[v] + 1) << endl;\n}\n\nint main() {\n  locale loc(locale(), new yes_no);\n  cout << boolalpha << setprecision(12) << fixed;\n  cout.imbue(loc);\n\tll N;\n\tscanf(\"%lld\", &N);\n\tvector<ll> b((N-1)-1+1);\n\tvector<ll> a((N-1)-1+1);\n\tfor (int i = 0 ; i <= (N-1)-1 ; i++) {\n\t  scanf(\"%lld\", &a[i]);\n\t  scanf(\"%lld\", &b[i]);\n\t}\n\tsolve(N, a, b);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\n#define X first\n#define Y second\n#define PB push_back\n\nusing namespace std;\n\nconst int N = 1e5 + 500;\nconst int K = 30;\n\nvector < int > v[N];\n\nint obr[N], doc[N][K], par[N], ja[N], sol, n, deg[N];\nqueue < int > Q;\n\nvoid ide(int x){\n\tfor(int y : v[x]){\n\t\tif(!obr[y]){\n\t\t\tpar[x] = y;\n\t\t\tv[x].erase(find(v[x].begin(), v[x].end(), y));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int y : v[x]){\n\t\tfor(int k = 0;k < K;k++)\n\t\t\tdoc[x][k] += doc[y][k];\n\t}\n\tint mini = K - 1;\n\tfor(;mini >= 0 && doc[x][mini] < 2;mini--);\n\tja[x] = mini + 1;\n\tfor(;doc[x][ja[x]];ja[x]++);\n\tfor(int k = 0;k <= ja[x];k++)\n\t\tdoc[x][k] = 0;\n\t//printf(\"x = %d ja = %d par = %d\\n\", x, ja[x], par[x]);\n\tdoc[x][ja[x]] = 1; obr[x] = 1;\n\tsol = max(sol, ja[x]);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1;i < n;i++){\n\t\tint x, y; scanf(\"%d%d\", &x, &y);\n\t\tv[x].PB(y); v[y].PB(x);\n\t\tdeg[x]++, deg[y]++;\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tif(deg[i] == 1)\n\t\t\tQ.push(i);\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tint gas = Q.front(); Q.pop();\n\t\tide(gas); deg[par[gas]]--;\n\t\tif(deg[par[gas]] <= 1)\n\t\t\tQ.push(par[gas]);\n\t}\n\tprintf(\"%d\\n\", sol);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 100010;\nint head[MAXN], nxt[MAXN << 1], to[MAXN << 1], tot;\nvoid addedge(int b, int e) {\n\tnxt[++tot] = head[b]; to[head[b] = tot] = e;\n\tnxt[++tot] = head[e]; to[head[e] = tot] = b;\n}\nint n, ans;\nint dfs(int u, int fa = 0) {\n\tint pre = 0, hav = 0;\n\tfor (int i = head[u]; i; i = nxt[i]) if (to[i] != fa) {\n\t\tint t = dfs(to[i], u);\n\t\thav |= pre & t;\n\t\tpre |= t;\n\t}\n\tint p = std::max(__builtin_ctz(pre + 1), hav ? std::__lg(hav) + 1 : 0);\n\tans = std::max(ans, p);\n\tpre ^= pre & (1 << p) - 1;\n\treturn pre | 1 << p;\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1, t1, t2; i < n; ++i)\n\t\tstd::cin >> t1 >> t2, addedge(t1, t2);\n\tdfs(1);\n\tstd::cout << ans << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = N, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int EXP = 30;\nconst int DIM = 200005;\n\nvector<int> edg[DIM];\n\nint dfs(int x, int f, int &ans)\n{\n    vector<int> aux(EXP, 0);\n    \n    for (int y : edg[x]) if (y != f) {\n        int val = dfs(y, x, ans);\n       \n        for (int i = 0; i < EXP; ++i)\n            aux[i] += ((val >> i) & 1);\n    }\n    \n    int pos = -1;\n    for (int i = 0; i < EXP; ++i)\n        if (aux[i] >= 2) pos = i;\n    \n    for (int i = pos + 1; i < EXP; ++i) if (!aux[i]) {\n        int msk = (1 << i);\n        for (int j = i + 1; j < EXP; ++j)\n            msk ^= (1 << j) * aux[j];\n        \n        ans = max(ans, i);\n        return msk;\n    }\n    \n    return 0;\n}\n\n\nint main(void)\n{\n    int n; cin >> n;\n    for (int i = 1; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        \n        edg[x].push_back(y);\n        edg[y].push_back(x);\n    }\n \n    int ans = 0; dfs(1, 0, ans);\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nset<int> dp[MAX];\nint over[MAX];\n\n\ninline void dfs(int b,int pr=-1){\n\tover[b] = -1;\n\tdp[b].clear();\n\tfor (int i = 0; i < v[b].size(); i++){\n\t\tif (v[b][i] == pr)continue;\n\t\tdfs(v[b][i],b);\n\t\tif (dp[b].size() < dp[v[b][i]].size()){\n\t\t\tswap(dp[b], dp[v[b][i]]);\n\t\t}\n\t\tfor (int i : dp[v[b][i]]){\n\t\t\tif (dp[b].count(i)){\n\t\t\t\tover[b] = max(over[b], i);\n\t\t\t}\n\t\t\tdp[b].insert(i);\n\t\t}\n\t\tdp[v[b][i]].clear();\n\t}\n\tauto it = dp[b].begin();\n\tint ex = 0;\n\twhile (it != dp[b].end()){\n\t\tif (ex == (*it)){\n\t\t\tit = dp[b].erase(it);\n\t\t\tex++;\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tif ((*it) <= over[b]){\n\t\t\t\tit = dp[b].erase(it);\n\t\t\t\tex = over[b]+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdp[b].insert(ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tdp[b].insert(ex);\n}\n\nint main(){\n\tcin >> n;\n\tfor (int i = 1; i < n; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0);\n\tauto r = (*dp[0].rbegin());\n\tcout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N;\nint a[110000], b[110000];\nvint G[110000];\nbool centroid[110000];\nint sos[110000];\nbool used[110000];\n\nvoid dfs(int v, int p) {\n    used[v] = false;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || cur == p)continue;\n        dfs(cur, v);\n    }\n}\n\nint size_of_subtree(int v, int p) {\n    int ret = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || used[cur] || cur == p)continue;\n        ret += size_of_subtree(cur, v);\n    }\n    return sos[v] = ret;\n}\n\nint search_centroid(int v, int t) {\n    if (used[v])return -1;\n    int p = -1;\n    while (true) {\n        int ch, s = 0;\n        for (int i = 0; i < G[v].size(); i++) {\n            int cur = G[v][i];\n            if (centroid[cur] || used[cur] || cur == p)continue;\n            if (s <= sos[cur])s = sos[cur], ch = cur;\n        }\n        if (s <= t / 2)break;\n        p = v;\n        v = ch;\n    }\n    return v;\n}\n\nint u(int v) {\n    dfs(v, -1);\n    int ret = LLONG_MAX;\n    while (true) {\n        size_of_subtree(v, -1);\n        int cidx = search_centroid(v, sos[v]);\n        if (cidx == -1)return ret;\n        centroid[cidx] = true;\n        used[cidx] = true;\n        int mu = -1, m2 = -1;\n        for (int i = 0; i < G[cidx].size(); i++) {\n            if (centroid[G[cidx][i]])continue;\n            int cu = u(G[cidx][i]);\n\n            if (mu <= cu)m2 = mu, mu = cu, v = G[cidx][i];\n        }\n        ret = min(ret, mu + 1);\n        centroid[cidx] = false;\n        if (mu == m2) return ret;\n    }\n}\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++)cin >> a[i] >> b[i], a[i]--, b[i]--, G[a[i]].push_back(b[i]), G[b[i]].push_back(a[i]);\n    cout << u(0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct node { int t,next; }a[200010];\n\nint f[100010][21],head[100010],cnt[233],n,tot;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void add(int x,int y) { a[++tot].t=y;a[tot].next=head[x];head[x]=tot; }\n\ninline void dfs(int x,int y)\n{\n\tfor (int i=head[x];i;i=a[i].next) if (a[i].t!=y) dfs(a[i].t,x);\n\tmemset(cnt,0,sizeof(cnt));\n\tfor (int i=head[x];i;i=a[i].next)\n\t{\n\t\tint t=a[i].t;\n\t\tif (t==y) continue;\n\t\tfor (int j=0;j<21;j++) if (f[t][j]) cnt[j]++;\n\t}\n\tint pos=-1;\n\twhile (cnt[++pos]);\n\tf[x][pos]=1;\n\tfor (int i=pos+1;i<21;i++) f[x][i]=cnt[i];\n}\n\nint main()\n{\n\tn=rd();tot=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=rd(),y=rd();\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tfor (int i=20;~i;i--) if (f[1][i]) { printf(\"%d\\n\",i);break; }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n\nusing namespace std;\n//using namespace __gnu_pbds;\n\n//typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 31;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\n//const int MAX_INT = (1 << 31) - 1;\n\n/*void print(vector<auto> &a)\n{\n    for (auto i : a)\n        cout << i.fi << endl;\n    cout << endl;\n}*/\n\nvector<int> g[N];\nbool used[N];\nint par[N];\nint len[N];\nint m_len[N];\nvector<int> g1[N];\nvector<int> order;\n\nvoid get_len(int u, int p)\n{\n    order.push_back(u);\n    len[u] = 0;\n    for (int v : g[u])\n        if (!used[v] && v != p)\n        {\n            get_len(v, u);\n            len[u] = max(len[u], len[v] + 1);\n        }\n}\n\nvoid dfs(int u, int p, int l)\n{\n    m_len[u] = max(len[u], l);\n    int pos = 0;\n    vector<int> pref, suff;\n    pref.push_back(0);\n    for (int v : g[u])\n        if (!used[v] && v != p)\n        {\n            pref.push_back(len[v] + 1);\n            suff.push_back(len[v] + 1);\n        }\n    suff.push_back(0);\n    for (int v : g[u])\n        if (!used[v] && v != p)\n        {\n            dfs(v, u, max(l, max(pref[pos], suff[pos + 1])) + 1);\n            pos++;\n        }\n}\n\nqueue<pair<int, int> > q;\n\nvoid solve()\n{\n    while (!q.empty())\n    {\n        auto p = q.front();\n        q.pop();\n        order.clear();\n        get_len(p.fi, -1);\n        dfs(p.fi, -1, 0);\n        int x = -1;\n        for (int u : order)\n            if (x == -1 || m_len[u] < m_len[x])\n                x = u;\n        par[x] = p.se;\n        used[x] = true;\n        for (int v : g[x])\n            if (!used[v])\n                q.push({v, x});\n    }\n}\n\nint dfs1(int u)\n{\n    int res = 0;\n    for (int v : g1[u])\n        res = max(res, dfs1(v) + 1);\n    return res;\n}\n\nint main()\n{\n    //freopen(\"decomposition.in\", \"r\", stdin);\n    //freopen(\"decomposition.out\", \"w\", stdout);\n    //ios_base::sync_with_stdio(0);\n    //cin.tie(0);\n    //cout.precision(20);\n    int n;\n    scanf(\"%d\", &n);\n    rep(i, 0, n - 1)\n    {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    q.push({0, -1});\n    solve();\n    int root = -1;\n    rep(i, 0, n)\n    {\n        if (par[i] == -1)\n            root = i;\n        else\n            g1[par[i]].push_back(i);\n    }\n    printf(\"%d\\n\", dfs1(root));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tsrand(clock());\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\twhile (true) {\n\t\tans++;\n\t\tmemset(Mark, 0, sizeof Mark);\n\t\tmemset(down, 0, sizeof down);\n\t\tmemset(up, 0, sizeof up);\n\t\tbool change = false;\n\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\tchange = true;\n\t\t\t\t\n\t\t\t\tdfs1(i, i);\n\t\t\t\tdfs2(i, i, 0);\n\t\t\t\tfindS(i, i);\n\t\t\t\tdel[S] = true;\n\t\t\t\t//cout << \"&   \" << S << \"\\n\";\n\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\n\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (!d[i]) {\n\t\t\t\t//cout << \"^ \" << i << \"\\n\";\n\t\t\t\tdel[i] = true;\n\t\t\t}\n\t\t\t\t\n\t\tif (!change)\n\t\t\tbreak;\n\t}\n\t\n\tcout << ans - 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nvector<vector<int> > g;\nvector<int> c;\nvector<int> res;\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > pq;\nint main(){\n    int n;\n    cin >> n;\n    g.resize(n);\n    c.resize(n);\n    res.resize(n);\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n        c[a]++;\n        c[b]++;\n    }\n    rep(i,n){\n        if(c[i]==1){\n            pq.push(MP(1,i));\n        }\n    }\n    while(!pq.empty()){\n        auto x = pq.top();\n        pq.pop();\n        int id = x.second;\n        for(auto y:g[id]){\n            res[id] |= res[y];\n        }\n        int bit = 0;\n        for(int i=0;i<=20;i++){\n            bit ^= (1<<i);\n            if((res[id]>>i)&1){\n            }else{\n                res[id] ^= bit; \n                break;\n            }\n        }\n        for(auto y:g[id]){\n            c[y]--;\n            if(c[y]==1){\n                pq.push(MP(res[id],y));\n            }\n        }\n    }\n    int mx = 0;\n    rep(i,n){\n        chmax(mx,res[i]);\n    }\n    cout << 31 - __builtin_clz(mx) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 1e5 + 10;\nvector < int > g[maxN];\nint msk[maxN];\nvoid dfs(int v, int p) {\n    vector < int > cnt(20);\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs(to, v);\n        for (int c = 0; c < 20; c++) {\n            if (msk[to] & (1 << c)) cnt[c]++;\n        }\n    }\n    int c = -1;\n    for (int r = 19; r >= 0; r--) {\n        if (cnt[r] > 1) {\n            c = r;\n            break;\n        }\n    }\n    int who = -1;\n    for (int d = c + 1; d <= 19; d++) {\n        if (cnt[d] == 0)  {\n            who = d;\n            break;\n        }\n    }\n    assert(who != -1);\n    msk[v] |= (1 << who);\n    for (int d = who + 1; d <= 19; d++) {\n        if (cnt[d] > 0) msk[v] |= (1 << d);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        g[a].emplace_back(b);\n        g[b].emplace_back(a);\n    }\n    dfs(1, -1);\n    int lrg = -1;\n    for (int i = 19; i >= 0; i--) {\n        if (msk[1] & (1 << i)) {\n            lrg = i;\n            break;\n        }\n    }\n    assert(lrg != -1);\n    cout << lrg;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define ll long long \n#define ret return\n#define PB push_back\n#define lc 2 * v\n#define rc 2 * v + 1\n#define mid (s + e) / 2\n#define pii pair <int,  int>\n#define pll pair <long long , long long>  \n#define FAST ios::sync_with_stdio(false);cin.tie(0);\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n\nconst int maxn = 3e6 + 50 , K = 25;\nvector <int> edges[maxn];\nll a[maxn] , n , ans;\n\nvoid dfs(int v, int p = -1) {\n    int b = 0;\n    for (auto u : edges[v]) {\n        if (u == p) continue;\n        dfs(u , v);\n        // for (int i = b; i < K; ++i) {\n        //     if ((a[v] & a[u]) & (1 << i)) {\n        //         b = i + 1;\n        //     }\n        // }\n        a[v] |= a[u];\n        while (a[v] & (1 << b)) {\n            b++;\n        }\n    }\n    for (int i = 0; i < b; ++i) {\n        a[v] -= (1 << i);\n    }\n    a[v] |= (1 << b);\n}\nint main() {\n    FAST\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        edges[u].PB(v);\n        edges[v].PB(u);\n    }\n    dfs(1);\n    for (int i = 0; i < K; ++i) {\n        if (a[1] & (1 << i)) {\n            ans = i;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nint n,lg2[100111];\nvector<int>con[100111];\nint dfs(int x,int pre=-1)\n{\n\tint tmp=0,ret=0;\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i];\n\t\tif(u==pre)continue;\n\t\tint nxt=dfs(u,x);\n\t\ttmp|=nxt&ret;\n\t\tret|=nxt;\n\t}\n\tif(tmp==0)return ret+1;\n\tint cur=lg2[tmp]+1;\n\treturn (ret&(~((1<<cur)-1)))+(1<<cur);\n}\nint main()\n{\n\tfor(int i=2;i<=100005;i++)lg2[i]=lg2[i>>1]+1;\n\tgeti(n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tgetii(x,y);\n\t\tcon[x].PB(y);\n\t\tcon[y].PB(x);\n\t}\n\tcout<<lg2[dfs(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool hasBit(int mask, int bit) {\n\treturn !!(mask & (1 << bit));\n}\n\nvector<int> G[500000];\n\nint DFS(int node, int par) {\n\t\n\tvector<int> Cnt(31);\n\tfor(auto vec : G[node]) {\n\t\tif(vec == par) continue;\n\n\t\tint take = DFS(vec, node);\n\t\tfor(int bit = 0; bit <= 30; ++bit)\n\t\t\tCnt[bit] += hasBit(take, bit);\n\t}\n\n\tint tag;\n\tfor(tag = 30; tag >= 0; --tag)\n\t\tif(Cnt[tag] >= 2)\n\t\t\tbreak;\n\tfor(++tag; Cnt[tag] >= 1; ++tag);\n\n\tint ans = (1 << tag);\n\tfor(++tag; tag <= 30; ++tag)\n\t\tans |= (Cnt[tag] << tag);\n\treturn ans;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 2; i <= n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\n\tcout << __lg(DFS(1, 0)) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n - 1) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    function<int (int, int)> go = [&](int i, int parent) {\n        int p = 0;\n        for (int j : g[i]) if (j != parent) {\n            p |= go(j, i);\n        }\n        return p + 1;\n    };\n    int p = go(0, -1);\n    int k = -1;\n    for (int acc = 1; acc < p; ) { acc <<= 1; ++ k; }\n    // output\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\npair<int,int> dfs(int v,int pre,Graph& g){\n    pair<int,int> res={0,v};\n    for(auto to:g[v]){\n        if(to==pre) continue;\n        auto ret=dfs(to,v,g);\n        ret.first++;\n        res=max(res,ret);\n    }\n    return res;\n}\n\nint diameter(Graph& g){\n    auto p=dfs(0,-1,g);\n    return dfs(p.second,-1,g).first;\n}\nint main(){\n    int N;\n    cin>>N;\n    Graph g(N);\n    for(int i=0;i+1<N;i++){\n        int a,b;\n        cin>>a>>b;\n        a--,b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    int d=diameter(g);\n    int sum=0;\n    for(int i=1;;i++){\n        sum=sum*2+2;\n        if(d<=sum){\n            cout<<i+1<<endl;\n            return 0;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint main()\n{\ncin>>n;\nprintf(\"%d\",(int)(ceil(log2(n))));\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <functional>\n\n#include <sstream>\n#include <iostream>\n\nusing namespace std;\ntypedef long long llint;\nconst llint inf = 1000000000000000000LL;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define _ << \" _ \" <<\n\nconst int MAXN = 100005;\n\nset<int> T[MAXN];\nint dad[MAXN];\nint L[MAXN];\nint R[MAXN];\n\npair<int,int> far_dfs(int i, int d = 0, int cur_dad = -1) {\n  pair<int,int> ret = {d, i};\n  dad[i] = cur_dad;\n  for (int j : T[i])\n    if (j != cur_dad)\n      ret = max(ret, far_dfs(j, d + 1, i));\n  return ret;\n}\n\nint depth(int i, int dad) {\n  int ret = 0;\n\n  for (int j : T[i]) {\n    if (j == dad) continue;\n    ret = max(ret, 1 + depth(j, i));\n  }\n\n  return ret;\n}\n\nint solve(int i) {\n  auto a = far_dfs(i);\n  auto b = far_dfs(a.second);\n\n  if (b.first <= 1)\n    return b.first;\n\n  vector<int> path;\n\n  for (int i = b.second; i != -1; i = dad[i]) \n    path.push_back(i);\n\n  int cd = 0;\n  for (int i = 0; i < (int)path.size() - 1; ++i) {\n    for (int j : T[path[i]]) {\n      if (j == path[i + 1] || i && j == path[i - 1]) continue;\n      cd = max(cd, depth(j, path[i]) + 1);\n    }\n    L[i] = cd;\n    ++cd;\n  }\n\n  cd = 0;\n  for (int i = (int)path.size() - 1; i >= 1; --i) {\n    for (int j : T[path[i]]) {\n      if (j == path[i - 1]\n\t  || i + 1 < (int)path.size() && j == path[i + 1]) continue;\n      cd = max(cd, depth(j, path[i]) + 1);\n    }\n    R[i] = cd;\n    ++cd;\n  }\n\n  int best = 1;\n  int best_len = 1e9;\n  for (int i = 1; i < (int)path.size() - 1; ++i) {\n    if (max(L[i - 1], R[i + 1]) < best_len) {\n      best_len = max(L[i - 1], R[i + 1]);\n      best = i;\n    }\n  }\n\n  int x = path[best];\n  for (int i : T[x])\n    T[i].erase(x);\n\n  int l = path[best - 1];\n  int r = path[best + 1];\n  path.clear();\n\n  return 1 + max(solve(l), solve(r));\n}\n\nint main(void) \n{\n  int N;\n  scanf(\"%d\", &N);\n\n  FOR(i, 1, N) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    T[a].insert(b);\n    T[b].insert(a);\n  }\n\n  printf(\"%d\\n\", solve(1));\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nvector<int> V[100010];\nint ans = 0;\n\nint TD(int p , int q){\n\tint a = 0;\n\tint b = 0;\n\tfor(vector<int>::iterator it = V[q].begin() ; it != V[q].end() ; ++it){\n\t\tif(p == (*it)) continue;\n\t\tint x = TD(q , (*it)) + 1;\n\t\tif(x > a){\n\t\t\tb = a;\n\t\t\ta = x;\n\t\t} else if(x > b){\n\t\t\tb = x;\n\t\t}\n\t}\n\tans = max(ans , a + b);\n\treturn a;\n}\n\nint N;\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,1,N){\n\t\tint x,y;\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tV[x].PB(y);\n\t\tV[y].PB(x);\n\t}\n\tTD(-1,1);\n\tint z = 0;\n\t++ans;\n\twhile(ans > 1){\n\t\t++z;\n\t\tans /= 2;\n\t}\n\tprintf(\"%d\\n\" , z);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#define MAXN 100010\nint n, ans, f[MAXN];\nstd::vector<int> next[MAXN];\nvoid gao(int x, int fa) {\n\tint tmp = 0, all = 0;\n\tfor (int y : next[x])\n\t\tif (y != fa) gao(y, x), tmp |= all & f[y], all |= f[y];\n\tif (!all) {\n\t\tf[x] = 1;\n\t\tans = std::max(ans, 1);\n\t} else {\n\t\tint count = 0;\n\t\twhile (((1 << count) < tmp) || ((all >> count) & 1)) count++;\n\t\tf[x] = (all >> count << count) | (1 << count);\n\t\tans = std::max(ans, count);\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int u, v, i = 1; i < n; i++) scanf(\"%d%d\", &u, &v), next[u].push_back(v), next[v].push_back(u);\n\tgao(1, 0);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\n\nconst int N=100005;\n\nvector<int>e[N];\nint mask[N],ans,n,m,cnt[20];\n\nvoid dfs(int x,int fa){\n\tfor(int v:e[x])if(v!=fa)dfs(v,x);\n\tmemset(cnt,0,sizeof(cnt));\n\tfor(int v:e[x])if(v!=fa)for(int i=0;i<m;i++)cnt[i]+=mask[v]>>i&1;\n\tint p=-1,q=-1;\n\tfor(int i=m-1;i>=0;i--){\n\t\tif(cnt[i]>1){p=i;break;}\n\t\tif(cnt[i]==0)q=i;\n\t}\n\tif(p==-1)p=q;\n\tmask[x]+=1<<p;\n\tfor(int i=p;i<m;i++)if(cnt[i])mask[x]+=1<<i;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tm=log(n)/log(2)+1;\n\tfor(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),e[u].pb(v),e[v].pb(u);\n\tdfs(1,0);\n\twhile((1<<ans)<=mask[1])ans++;\n\tprintf(\"%d\\n\",ans-1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=5e5+5,M=2e6+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n,m,bin[30]={1};\nint head[N],cnt,lg[N];\nstruct edge{int t,ne;}e[N];\nvoid adde(int a,int b){e[++cnt]=(edge){b,head[a]};head[a]=cnt;}\n#define pw(a) (1<<(a))\nint gao(int x,int f){\n\tint S=0,K=0,P=0,res=0;\n\trun(x)if(v!=f){\n\t\tK=gao(v,x);\n\t\tS|=K&P;\n\t\tP|=K;\n\t}\n\tres=(P|(pw(lg[S]+1)-1))+1;\n\treturn res;\n}\nint main(){\n\tread(n);\n\tre(i,1,n){int a,b;read(a,b);adde(a,b);adde(b,a);}\n\tlg[0]=-1;rep(i,1,1<<17)lg[i]=lg[i>>1]+1;\n\tcout<<lg[gao(1,0)];\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nvector<vector<int> > g;\nvector<int> c;\nvector<int> res;\npriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > pq;\nint main(){\n    int n;\n    cin >> n;\n    g.resize(n);\n    c.resize(n);\n    res.resize(n);\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n        c[a]++;\n        c[b]++;\n    }\n    rep(i,n){\n        if(c[i]==1){\n            pq.push(MP(1,i));\n        }\n    }\n    while(!pq.empty()){\n        auto x = pq.top();\n        pq.pop();\n        int id = x.second;\n        for(auto y:g[id]){\n            res[id] |= res[y];\n        }\n        if(res[id]==0){\n            res[id] = 1;\n        }else{\n            int kkk = 31 - __builtin_clz(res[id]) ;\n            int cc = 0;\n            for(auto y:g[id]){\n                if((res[y]>>kkk)&1)cc++;\n            }\n            int bit = 0;\n            if(cc==1){\n                for(int i=0;i<=20;i++){\n                    bit ^= (1<<i);\n                    if((res[id]>>i)&1){\n                    }else{\n                        res[id] &= ~bit; \n                        res[id] += (1<<i);\n                        break;\n                    }\n                }\n            }else{\n                res[id] = (1<<(kkk+1));\n            }\n        }\n        for(auto y:g[id]){\n            c[y]--;\n            if(c[y]==1){\n                pq.push(MP(res[id],y));\n            }\n        }\n    }\n    int mx = 0;\n    rep(i,n){\n        chmax(mx,res[i]);\n        // cerr << i+1 << \" \" << res[i] << endl;\n    }\n    cout << 31 - __builtin_clz(mx) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define N 100010\nusing namespace std;\nint nxt[N<<1],to[N<<1],head[N],cnt;\nvoid add(int u,int v)\n{\n\tnxt[++cnt]=head[u];\n\tto[cnt]=v;\n\thead[u]=cnt;\n}\nint f[N][21],ans;\nvoid dfs(int u,int pre)\n{\n\tfor(int i=head[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==pre) continue;\n\t\tdfs(v,u);\n\t\tfor(int j=0;j<=20;j++) f[u][j]+=f[v][j];\n\t}\n\tint pmin=0;\n\tfor(int j=20;j>=0;j--)\n\tif(pmin)f[u][j]=0;\n\telse if(f[u][j]>=2) pmin=j;\n\twhile(!pmin || f[u][pmin]>=2) f[u][pmin]=0,f[u][++pmin]++;\n\tans=max(ans,pmin);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\",ans-1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\nconst int N=1e6+5,M=2e6+5,mo=1e9+7;\nint n,ans,i,x,y;\nint tt,nxt[N],b[N],fst[N];\nvoid cr(int x,int y)\n{\n\ttt++;\n\tb[tt]=y;\n\tnxt[tt]=fst[x];\n\tfst[x]=tt;\n}\nint f[N],sat[N];\nvoid dfs(int x,int y)\n{\n\tint lwb=0;\n\tfor(int p=fst[x];p;p=nxt[p])\n\t\tif (b[p]!=y)\n\t\t{\n\t\t\tdfs(b[p],x);\n\t\t\tlwb|=sat[x]&sat[b[p]];\n\t\t\tsat[x]|=sat[b[p]];\n\t\t}\n\tf[x]=0;\n\twhile ((1<<f[x])<=lwb||((1<<f[x])&sat[x])) f[x]++;\n\tsat[x]=(sat[x]>>f[x]<<f[x])|(1<<f[x]);\n\tcmax(ans,f[x]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n-1)\n\t{\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tcr(x,y);\n\t\tcr(y,x);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define SZ 666666\nint M=0,fst[SZ],nxt[SZ],vb[SZ];\nvoid ad_de(int a,int b) {++M; nxt[M]=fst[a]; fst[a]=M; vb[M]=b;}\nvoid adde(int a,int b) {ad_de(a,b); ad_de(b,a);}\nint sz[SZ],ms[SZ],n,root,sum;\nbool vis[SZ];\nint groot(int x,int f)\n{\n\tsz[x]=1; ms[x]=0;\n\tfor(int e=fst[x];e;e=nxt[e])\n\t{\n\t\tint b=vb[e];\n\t\tif(b==f||vis[b]) continue;\n\t\tgroot(b,x); sz[x]+=sz[b];\n\t\tms[x]=max(ms[x],sz[b]);\n\t}\n\tms[x]=max(ms[x],sum-sz[x]);\n\tif(ms[x]<ms[root]||!root) root=x;\n}\nint md=0;\nvoid dfz(int x,int d=0)\n{\n\tmd=max(md,d); vis[x]=1;\n\tfor(int e=fst[x];e;e=nxt[e])\n\t{\n\t\tint b=vb[e]; if(vis[b]) continue;\n\t\tsum=sz[b]; root=0; groot(b,0); dfz(root,d+1);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadde(a,b);\n\t}\n\tsum=n; groot(1,0); dfz(root);\n\tprintf(\"%d\\n\",md);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> adjlist[100005];\nint furthest;\nint d[100005];\nvoid dfs(int u){\n    for (auto v : adjlist[u]){\n        if (d[v] == -1){\n            d[v] = d[u]+1;\n            if (d[furthest] < d[v]){\n                furthest = v;\n            }\n            dfs(v);\n        }\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i = 1; i < n; i++){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        adjlist[a].push_back(b);\n        adjlist[b].push_back(a);\n    }\n    memset(d,-1,sizeof(d));\n    d[1] = 0;\n    dfs(1);\n    memset(d,-1,sizeof(d));\n    d[furthest] = 0;\n    dfs(furthest);\n    int diameter = d[furthest];\n    diameter++;\n    printf(\"%d\",31-__builtin_clz(diameter));\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nvector<int> g[100111];\nint msk[100111][20],ans[100111],n;\nvoid dfs(int x,int f=0)\n{\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t\tif(g[x][i]!=f)\n\t\t{\n\t\t\tdfs(g[x][i],x);\n\t\t\tans[x]=max(ans[g[x][i]],ans[x]);\n\t\t\tfor(int j=0;j<20;j++)msk[x][j]+=msk[g[x][i]][j];\n\t\t}\n\tint cur=ans[x];\n\twhile(cur>=0&&msk[x][cur]<2)cur--;\n\tcur++;\n\tfor(int i=0;i<cur;i++)msk[x][i]=0;\n\twhile(msk[x][cur]==1)\n\t\tmsk[x][cur++]=0;\n\tmsk[x][cur]=1;\n\tans[x]=max(ans[x],cur);\n//\tfor(int i=0;i<ans[x];i++)printf(\"%d \",msk[x][i]);puts(\"\");\n}\nint main()\n{\n\tget1(n);\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tget2(u,v);\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tdfs(1);\n\tprintendl(ans[1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *\t\tAtreus\n**/\n#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int maxn = 1e5 + 10;\n\nint n;\n\nint sz[maxn];\n\nbool visited[maxn], mark[maxn];\n\nint ans[maxn];\n\nvector <int> t[maxn];\n\nint dfs (int u, int par = -1) {\n\tsz[u] = 1;\n\tfor (auto w : t[u]) {\n\t\tif (w != par and !mark[w]) {\n\t\t\tsz[u] += dfs (w, u);\n\t\t}\n\t}\n\treturn sz[u];\n}\n\nvoid centroidDecomposition (int x, int now) {\n\tint Max = dfs (x), par = -1;\n\twhile (true) {\n\t\tbool found = 0;\n\t\tfor (auto w : t[x]) {\n\t\t\tif (par != w and !mark[w] and sz[w] > Max / 2) {\n\t\t\t\tpar = x;\n\t\t\t\tx = w;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\tmark[x] = 1;\n\tans[x] = now;\n\tfor (auto w : t[x]) {\n\t\tif (!mark[w]) {\n\t\t\tcentroidDecomposition (w, now + 1);\n\t\t}\n\t}\n}\n\nvoid addEdge (int u, int w) {\n\tt[u].push_back(w);\n\tt[w].push_back(u);\n}\n\nint main () {\n\tios_base::sync_with_stdio (false);\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, w;\n\t\tcin >> u >> w;\n\t\taddEdge (u, w);\n\t}\n\tcentroidDecomposition (1, 0);\n\tcout << *max_element(ans + 1, ans + n + 1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n  int t,next;\n  Edge() {}\n  Edge(int a,int b):t(a),next(b) {}\n}; \n\nEdge e[200005];\nint head[100005];\n\nint f[100005],g[100005],ans;\n\nvoid dfs(int x,int fa) {\n  int sum=0;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) {\n    \tint u=e[i].t;\n    \tdfs(u,x);\n    \tsum|=(g[x]&g[u]);\n    \tg[x]|=g[u];\n\t}\n  for(int i=0;i<30;i++)\n    if (!(sum&(1<<i))&&!(g[x]&(1<<i))) {\n    \tf[x]=i;\n    \tbreak;\n\t} \n  g[x]=((g[x]>>f[x]<<f[x])|(1<<f[x]));\n  ans=max(ans,f[x]);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[2*i-1]=Edge(y,head[x]);\n  \thead[x]=2*i-1;\n  \te[2*i]=Edge(x,head[y]);\n  \thead[y]=2*i;\n  }\n  dfs(1,0);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, d[N];\nvector <int> g[N];\n\nvoid dfs (int, int, int);\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\n\tdfs (0, -1, 0);\n\tint far = 0;\n\tfor (int v = 1; v < n; v++)\n\t\tif (d[v] > d[far])\n\t\t\tfar = v;\n\tdfs (far - 1, -1, 0);\n\tint len = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tlen = max(len, d[i]);\n\n\tlen--;\n\tint cnt = 0;\n\twhile (len) {\n\t\tcnt++;\n\t\tlen >>= 1;\n\t}\n\tcout << cnt << endl;\n}\n\nvoid dfs (int v, int pv, int depth) {\n\td[v] = depth;\n\tfor (int u: g[v])\n\t\tif (u != pv)\n\t\t\tdfs (u, v, depth + 1);\n}\n\n// SamMHD :: Feb17-2019 :: Another Simulation"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<map>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define NMAX 100005\n#define LMAX 21\n\nint answer, n, mask[NMAX], viz[NMAX];\nvector<int> tree[NMAX];\n\nvoid dfs(int node){\n    viz[node] = 1;\n    \n    int lim = tree[node].size(), f[LMAX];\n    memset(f, 0, sizeof(f));\n    \n    for(int i = 0; i < lim; i++){\n        int neigh = tree[node][i];\n        if(!viz[neigh]){\n            dfs(neigh);\n            for(int j = 0; j < LMAX; j++)\n                if(mask[neigh] & (1 << j))\n                    f[j]++;\n        }\n    }\n    \n    int lastComm = -1;\n    for(int i = LMAX - 1; i >= 0; i--){\n        if(f[i] >= 2){\n            lastComm = i;\n            break;\n        }\n    }\n    \n    int takenMex = 0;\n    for(int i = lastComm + 1; i < LMAX; i++){\n        if(f[i] && takenMex)\n            mask[node] += (1 << i);\n        else if(!f[i] && !takenMex){\n            answer = max(answer, i);\n            mask[node] += (1 << i);\n            takenMex = 1;\n        }\n    }\n}\n\nint main (){\n    int a, b;\n    \n    scanf(\"%d\",&n);\n    for(int i = 1; i < n; i++){\n        scanf(\"%d%d\",&a,&b);\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n        \n    dfs(1);\n    \n    printf(\"%d\\n\", answer);\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int inf_int = 1e9 + 100;\nconst ll inf_ll = 1e18;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double dbl;\n#define pb push_back\n#define eb emplace_back\nconst double pi = 3.1415926535898;\n#define dout if(debug) cout\n#define fi first\n#define se second\n#define sp setprecision\n#define sz(a) (int(a.size()))\n#define mp make_pair\n#define all(a) a.begin(),a.end()\nbool debug = 0;\nconst int MAXN = 1e5 + 100;\nconst int LOG = 21;\nconst int mod = 998244353;\nconst int MX = 1e3 + 100;\ntypedef long long li;\nconst li MOD = 1000000000949747713ll;\n\ntemplate<class T1, class T2>\nstd::ostream &operator<<(std::ostream &out, const std::pair<T1, T2> &rhs) {\n    out << \"( \" << rhs.first << \" , \" << rhs.second << \" )\";\n    return out;\n}\n\nvector<int> g[MAXN];\n\nint dp[MAXN];\n\nint cnt[32];\n\nvoid dfs(int v, int p) {\n    for (int to:g[v]) {\n        if (to == p)\n            continue;\n        dfs(to, v);\n    }\n\n    memset(cnt, 0, sizeof cnt);\n    for (int to:g[v]) {\n        if (to == p)\n            continue;\n        for (int i = 0; i < 30; ++i) {\n            if (dp[to] & (1 << i)) {\n                cnt[i]++;\n            }\n        }\n    }\n    int last = 0;\n    for (int i = 0; i < 30; ++i) {\n        if (cnt[i] > 1)\n            last = i + 1;\n    }\n    for (int i = last; i < 30; ++i) {\n        if (cnt[i] == 0) {\n            last = i;\n            break;\n        } else {\n\n        }\n    }\n    int res = (1 << last);\n    for (int i = last + 1; i < 30; ++i) {\n        if (cnt[i] > 0) {\n            res = res | (1 << i);\n        }\n    }\n    dp[v] = res;\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        g[a].pb(b);\n        g[b].pb(a);\n    }\n    dfs(1, -1);\n    int res = 0;\n    for (int i = 0; i < 30; ++i) {\n        if (dp[1] & (1 << i))\n            res = i;\n    }\n    cout << res << endl;\n\n}\n\nsigned main() {\n#ifdef zxc\n    debug = 1;\n    // freopen(\"../input.txt\", \"r\", stdin);\n    // freopen(\"../output.txt\", \"w\", stdout);\n#else\n\n#endif //zxc\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(20);\n\n    int t = 1;\n    while (t--)\n        solve();\n    if (debug)\n        cerr << endl << \"time : \" << (1.0 * clock() / CLOCKS_PER_SEC) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n;\nvector<int> g[100000];\nbool del[100000];\nint sz[100000];\n\nvoid csz(int v, int p) {\n    sz[v] = 1;\n    for (int to : g[v]) if (to != p && !del[to]) {\n        csz(to, v);\n        sz[v] += sz[to];\n    }\n}\n\nint tmp = 1234;\nint zzz = 0;\n\nint cd(int v, bool root = false) {\n    csz(v, -1);\n    zzz += sz[v];\n    if (zzz > 100000) {\n        zzz = 0;\n        if (clock() > 1.9 * CLOCKS_PER_SEC) {\n            cout << tmp << endl;\n            exit(0);\n        }\n    }\n    int par = -1;\n    int szv = sz[v];\n    while (true) {\n        bool done = true;\n        for (int to : g[v]) if (to != par && !del[to] && 2 * sz[to] >= szv) {\n            par = v;\n            v = to;\n            done = false;\n            break;\n        }\n        if (done) break;\n    }\n    int res, worst, wcnt;\n    par = -1;\n    bool firstTime = true;\n    do {\n        if (firstTime) {\n            firstTime = false;\n        } else {\n            del[v] = false;\n            par = v;\n            v = worst;\n        }\n        del[v] = true;\n        res = 0;\n        worst = -1;\n        wcnt = 0;\n        if (par != -1) {\n            res = cd(par) + 1;\n            worst = par;\n            wcnt = 1;\n        }\n        for (int to : g[v]) if (!del[to] && to != par) {\n            int val = cd(to) + 1;\n            if (val > res) {\n                res = val;\n                worst = to;\n                wcnt = 1;\n            } else if (val == res) {\n                ++wcnt;\n            }\n        }\n        if (root) {\n            tmp = min(tmp, res);\n        }\n    } while (wcnt == 1 && worst != par);\n    del[v] = false;\n    return res;\n}\n\nint cd2(int v, bool root = false) {\n    csz(v, -1);\n    zzz += sz[v];\n    if (zzz > 100000) {\n        zzz = 0;\n        if (clock() > 1.9 * CLOCKS_PER_SEC) {\n            cout << tmp << endl;\n            exit(0);\n        }\n    }\n    int par = -1;\n    int szv = sz[v];\n    while (true) {\n        bool done = true;\n        for (int to : g[v]) if (to != par && !del[to] && 2 * sz[to] >= szv) {\n            par = v;\n            v = to;\n            done = false;\n            break;\n        }\n        if (done) break;\n    }\n    int res, worst, wcnt;\n    par = -1;\n    bool firstTime = true;\n    do {\n        if (firstTime) {\n            firstTime = false;\n        } else {\n            del[v] = false;\n            par = v;\n            v = worst;\n        }\n        del[v] = true;\n        res = 0;\n        worst = -1;\n        wcnt = 0;\n        if (par != -1) {\n            res = cd2(par) + 1;\n            worst = par;\n            wcnt = 1;\n        }\n        for (int to : g[v]) if (!del[to] && to != par) {\n            int val = cd2(to) + 1;\n            if (val > res) {\n                res = val;\n                worst = to;\n                wcnt = 1;\n            } else if (val == res) {\n                ++wcnt;\n            }\n        }\n        if (root) {\n            tmp = min(tmp, res);\n        }\n    } while (false);\n    del[v] = false;\n    return res;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    forn(i, n - 1) {\n        int from, to;\n        scanf(\"%d%d\", &from, &to), --from, --to;\n        g[from].pb(to);\n        g[to].pb(from);\n    }\n\n//    n = 100000;\n//    mt19937 mt(123);\n//    for (int i = 1; i < n; ++i) {\n//        int to = i / 4 + mt() % (i - i / 4);\n//        g[i].pb(to);\n//        g[to].pb(i);\n//    }\n\n    cd2(0, true);\n    //cerr << clock() << endl;\n    int res = cd(0, true);\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint solve(int pos, int pre, vector<vector<int> > &g) {\n\tint req = 0, mx = 0;\n\tfor (int i : g[pos]) {\n\t\tif (i == pre) continue;\n\t\tint res = solve(i, pos, g);\n\t\tint res_req = 0;\n\t\twhile ((res >> res_req) & 1) ++res_req;\n\t\treq = max(req, res_req);\n\t\tmx = max(mx, res);\n\t}\n\t++mx;\n\twhile (req != 0 && (mx & (1 << (req - 1)))) ++mx;\n\treturn mx;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint n, a, b;\n\tcin >> n;\n\tvector<vector<int> > g(n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcin >> a >> b; --a, --b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint ret = solve(0, -1, g);\n\tint ans = 0;\n\twhile (2 << ans < ret) ++ans;\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\n\nint main() {\n\t// input\n\tint n; scanf(\"%d\", &n);\n\tvector<vector<int> > g(n);\n\trepeat (i, n - 1) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\t// solve\n\tfunction<int (int, int)> go = [&](int i, int parent) {\n\t\tint cnt1 = 0, cnt2 = 0;\n\t\tfor (int j : g[i]) if (j != parent) {\n\t\t\tint q = go(j, i);\n\t\t\tcnt2 |= cnt1 & q;\n\t\t\tcnt1 |= q;\n\t\t}\n\t\tint p = 1;\n\t\twhile (p <= cnt2 or cnt1 & p) p <<= 1;\n\t\treturn (cnt1 & ~ (p - 1)) | p;\n\t};\n\tint p = go(0, -1);\n\tint k = 31 - __builtin_clz(p);\n\t// output\n\tprintf(\"%d\\n\", k);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nint N;\nvector<int> V[100010];\n\nint lg(int a){\n\tint b = -1;\n\tfor(; a > 0 ; a /= 2) ++b;\n\treturn b;\n}\n\nint dfs(int p , int q){\n\tint x = 0;\n\tint y = 0;\n\trepv(int,it,V[q]){\n\t\tif(p == (*it)) continue;\n\t\tint z = dfs(q,(*it));\n\t\ty |= (x&z);\n\t\tx |= z;\n\t}\n\tint w = lg(y) + 1;\n\tx >>= w;\n\twhile(x % 2 == 1){\n\t\tx /= 2;\n\t\t++w;\n\t}\n\treturn ((x + 1) << w);\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,1,N){\n\t\tint x,y;\n\t\tscanf(\"%d%d\" , &x , &y);\n\t\tV[x].PB(y);\n\t\tV[y].PB(x);\n\t}\n\tprintf(\"%d\\n\" , lg(dfs(-1,1)));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* ***********************************************\nAuthor        :axp\nCreated Time  :2017/1/23 10:14:37\nTASK\t\t  :D.cpp\nLANG          :C++\n************************************************ */\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\ntypedef long long ll;\nconst int inf = 1<<30;\nconst int md = 1e9+7;\nconst int N = 1e5+10;\nint n,m;\nint T;\nvector<int> ve[N];\nint d[N];\nint fa[N];\n\nint f(int x)\n{\n\tif(x<=1)return 0;\n\treturn f((x-2)/2+1)+1;\n}\n\nint dfs(int p,int x)\n{\n\tfa[x]=p;\n\tint re=d[x];\n\tfor(int i=0;i<ve[x].size();i++)\n\t{\n\t\tint &y=ve[x][i];\n\t\tif(y==p)continue;\n\t\td[y]=d[x]+1;\n\t\tre=max(re,dfs(x,y));\n\t}\n\treturn re;\n}\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    scanf(\"%d\",&n);\n\tint x,y;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tve[x].push_back(y);\n\t\tve[y].push_back(x);\n\t}\n\tint dep;\n\td[1]=1;\n\tdep=dfs(0,1);\n\tfor(int i=1;i<=n;i++)if(d[i]==dep)x=i;\n\td[x]=1;\n\tdep=dfs(0,x);\n\tfor(int i=1;i<=n;i++)if(d[i]==dep/2+1)x=i;\n\tdep=dfs(0,x);\n\tint mi=n,ma=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i==x)continue;\n\t\tif(ve[i].size()!=1)continue;\n\t\tmi=min(mi,d[i]);\n\t\tma=max(ma,d[i]);\n\t}\n\tint ans=0;\n\twhile( (1<<ans+1)-1<ma)ans++;\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nvector<vector<int> > g;\nvector<bool>p;\nvoid dfs(int id,int pre){\n    bool flag = 0;\n    for(auto x:g[id]){\n        if(x!=pre){\n            dfs(x,id);\n            if(!p[x]){\n                flag = 1;\n            }\n        }\n    }\n    p[id] = flag;\n}\nvector<int> c;\nvoid dfs2(int id,int pre){\n    int mx = 0;\n    for(auto x:g[id]){\n        if(x!=pre){\n            dfs2(x,id);\n            mx = max(mx,c[x]);\n        }\n    }\n    mx += p[id];\n    c[id] = mx;\n}\nint main(){\n    int n;\n    cin >> n;\n    g.resize(n);p.resize(n);\n    c.resize(n);\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].PB(b);\n        g[b].PB(a);\n    }\n    dfs(0,-1);\n    dfs2(0,-1);\n    int mxid = 0;\n    int mx = 0;\n    rep(i,n){\n        if(mx<c[i]){\n            mx = c[i];\n            mxid = i;\n        }\n        c[i] = 0;\n    }\n    dfs2(mxid,-1);\n    rep(i,n){\n        mx = max(mx,c[i]);\n    }\n    // cerr << mx << endl;\n    for(int i=0;i<30;i++){\n        if((1<<i)>mx){\n            cout << i << endl;\n            return 0;\n        }   \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vi::iterator vit;\ntypedef vi::reverse_iterator vrit;\n#define pb push_back\nconst int MX=100005;\nvi G[MX];\nint n;\nint dp(int k,int f){\n\tint v=0,v2=0;\n\tfor(auto i:G[k])if(i!=f){\n\t\tint r=dp(i,k);\n\t\tv2|=(r&v),v|=r;\n\t}\n\tint it=0;while((1<<it)<=v2)it++;\n\twhile((v>>it)&1)it++;\n\treturn (v|(1<<it))&(~((1<<it)-1));\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;cin>>a>>b;\n\t\tG[a].pb(b),G[b].pb(a);\n\t}\n\tcout<<31-__builtin_clz(dp(1,0))<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <functional>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\n\nint diameter(vector<vector<int> > const & tree) {\n    pair<int, int> result = { -1, -1 };\n    int dist = 0;\n    function<void (int, int)> dfs = [&](int i, int parent) {\n        setmax(result, make_pair(dist, i));\n        ++ dist;\n        for (int j : tree[i]) if (j != parent) {\n            dfs(j, i);\n        }\n        -- dist;\n    };\n    dfs(0, 0);\n    int k = result.second;\n    result = { -1, -1 };\n    dfs(k, 0);\n    return result.first;\n}\n\nint main() {\n    // input\n    int n; scanf(\"%d\", &n);\n    vector<vector<int> > g(n);\n    repeat (i, n) {\n        int a, b; scanf(\"%d%d\", &a, &b); -- a; -- b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    // solve\n    int d = diameter(g);\n    int k = 0;\n    for (int acc = 1; acc < d + 1; ) {\n        acc = 2 * acc + 1;\n        ++ k;\n    }\n    // output\n    printf(\"%d\\n\", k);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n#define N 100050\nint head[N],to[N<<1],nxt[N<<1],cnt,n,tmp[22],f[N][22],ans;\ninline void add(int u,int v) {\n\tto[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;\n}\nvoid merge(int *a,int *b) {\n\tint i;\n\tfor(i=0;i<=20;i++) a[i]+=b[i];\n}\nvoid dfs(int x,int y) {\n\tint i;\n\tfor(i=head[x];i;i=nxt[i]) if(to[i]!=y) dfs(to[i],x);\n\tmemset(tmp,0,sizeof(tmp));\n\tfor(i=head[x];i;i=nxt[i]) if(to[i]!=y) merge(tmp,f[to[i]]);\n\tint k=0;\n\tfor(i=20;i>=0;i--) {\n\t\tif(tmp[i]>1) {\n\t\t\tk=i+1; break;\n\t\t}\n\t}\n\tfor(;tmp[k];k++) ;\n\tmemcpy(f[x]+k,tmp+k,sizeof(int)*(20-k));\n\tf[x][k]++;\n\tans=max(ans,k);\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tint i,x,y;\n\tfor(i=1;i<n;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tdfs(1,0); printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N = 100005;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N << 1];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nint N, f[MAX_N];\n\nvoid dfs(int u, int v) {\n  for (int i = head[u]; i; i = e[i].nxt)\n    if (e[i].to != v)\n      dfs(e[i].to, u);\n  int vis = 0, twice = 0;\n  for (int i = head[u]; i; i = e[i].nxt) \n    if (e[i].to != v) {\n      twice |= vis & f[e[i].to];\n      vis |= f[e[i].to];\n    }\n  if (!twice) {\n    f[u] = vis + 1;\n  } else {\n    int k = 20;\n    while (!(twice >> k & 1)) k--;\n    f[u] = (vis ^ (vis & ((1 << k + 1) - 1))) + (1 << k + 1);\n  }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n\n  for (int i = 1, a, b; i < N; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    addedge(a, b);\n  }\n\n  dfs(1, 0);\n  \n  int k = 20;\n  while (!(f[1] >> k & 1)) k--;\n\n  printf(\"%d\\n\", k);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n;\nvector<int> G[100010];\nint dp[100010];\nint s[100010];\nvoid dfs(int v,int p){\n\ts[v] = 0;\n\tdp[v] = 0;\n\tfor(int u: G[v]){\n\t\tif(p == u)continue;\n\t\tdfs(u,v);\n\t\tint t = s[v]&s[u];\n\t\trep(i,20){\n\t\t\tif((t>>i)&1){\n\t\t\t\tdp[v] = max( dp[v] , i+1 );\n\t\t\t}\n\t\t\telse if((t>>i)>0){\n\t\t\t\tt += 1<<i;\n\t\t\t}\n\t\t}\n\t\ts[v] = s[v]+s[u]-(t<<1);\n\t}\n\twhile((s[v]>>dp[v])&1){\n\t\ts[v] -= 1<<dp[v];\n\t\tdp[v] ++;\n\t}\n\ts[v] += 1<<dp[v];\n\t//cout << v << \" \" << dp[v] << \" \" << s[v] << endl;\n}\n\nint main(){\n\tint n;\n\tint a[100010],b[100010];\n\tscanf(\"%d\",&n);\n\trep1(i,n-1){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG[a[i]].pb(b[i]);\n\t\tG[b[i]].pb(a[i]);\n\t}\n\tif(n <= 2){\n\t\tcout << n-1 << endl;\n\t\treturn 0;\n\t}\n\tint root = 1;\n\trep1(i,n){\n\t\tif(G[i].size() >= 2){\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(root,0);\n\t\n\tint ret = 0;\n\trep1(i,n)ret = max( ret , dp[i] );\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/** MIT License Copyright (c) 2018 Vasilyev Daniil **/\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\ntemplate<typename T> using v = vector<T>;\n//template<typename T, typename U>  using hmap = __gnu_pbds::gp_hash_table<T, U>;\n#define int long long\ntypedef long double ld;\ntypedef string str;\ntypedef vector<int> vint;\n#define rep(a, l, r) for(int a = (l); a < (r); a++)\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sc second\n#define sz(a) ((int) a.size())\nconst long long inf = 4611686018427387903; //2^62 - 1\n#if 0  //FileIO\nconst string fileName = \"\";\nifstream fin ((fileName == \"\" ? \"input.txt\"  : fileName + \".in\" ));\nofstream fout((fileName == \"\" ? \"output.txt\" : fileName + \".out\"));\n#define get fin>>\n#define put fout<<\n#else\n#define get cin>>\n#define put cout<<\n#endif\n#define eol put endl\n#define check(a) put #a << \": \" << a << endl;\nvoid read() {} template<typename Arg,typename... Args> void read (Arg& arg,Args&... args){get (arg)     ;read(args...) ;}\nvoid print(){} template<typename Arg,typename... Args> void print(Arg  arg,Args...  args){put (arg)<<\" \";print(args...);}\nint getInt(){int a; get a; return a;}\n//code goes here\nconst int N = 1e5 + 1;\nvint t[N];\nint siz[N];\nbitset<N> added;\nint calcSize(int cur, int p) {\n    siz[cur] = 1;\n    for (int i : t[cur])\n        if (!added.test(i) && i != p)\n            siz[cur] += calcSize(i, cur);\n    return siz[cur];\n}\n\nint make_centroid(int cur, int h) {\n    int p = calcSize(cur, -1);\n    int lim = p / 2;\n    if (p == 1)\n        return h;\n    bool again = 1;\n    int pr = -1;\n    int opt = inf;\n    while (again) {\n        again = 0;\n        for (int i : t[cur])\n            if (i != pr && !added.test(i) && siz[i] > lim) {\n                pr = cur;\n                cur = i;\n                again = 1;\n                break;\n            } else if (i != pr && !added.test(i) && p % 2 == 0 && siz[i] == lim) {\n                added.set(i);\n                opt = -1;\n                for (int j : t[i])\n                    if (!added.test(j))\n                        opt = max(opt, make_centroid(j, h + 1));\n                added.reset(i);\n            }\n    }\n\n    int man = 0;\n    added.set(cur);\n    for (int i : t[cur])\n        if (!added.test(i))\n            man = max(man, make_centroid(i, h + 1));\n    added.reset(cur);\n    return min(man, opt);\n}\n\nvoid run() {\n    int n;\n    get n;\n    rep(i, 1, n) {\n        int v, u;\n        read(v, u);\n        t[v].pb(u);\n        t[u].pb(v);\n    }\n    put make_centroid(1, 0);\n    eol;\n}\nsigned main() {srand(time(0)); ios::sync_with_stdio(0); cin.tie(0); put fixed << setprecision(15); run(); return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint n;\nvector<vector<int>> v(111111);\n\nll dfs(int s,int pre){\n\tll ret = 0;\n\tvector<ll> tmp;\n\tREP(i,v[s].size()){\n\t\tif(v[s][i] != pre){\n\t\t\ttmp.PB(dfs(v[s][i],s));\n\t\t\tret |= tmp[tmp.size()-1];\n\t\t}\n\t}\n\t\n\tif(tmp.size() == 0){\n\t\treturn 1;\n\t}\n\tint cou = 60;\n\tfor(;cou > 0;cou--){\n\t\tbool flag = true;\n\t\tREP(i,tmp.size()){\n\t\t\tflag &= (tmp[i] & (1LL << cou));\n\t\t}\n\t\tif(flag)break;\n\t}\n\t\n\tfor(;;cou++){\n\t\tif(!(ret & (1LL <<cou))){\n\t\t\tret |= (1LL << cou);\n\t\t\tret &= ((1LL << 60)-1) - ((1LL << cou) - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\t\n\tcin >> n;\n\tREP(i,n-1){\n\t\tint a,b;cin >> a >> b;\n\t\ta--;b--;\n\t\tv[a].PB(b);\n\t\tv[b].PB(a);\n\t}\n\t\t\n\tll ans = dfs(0,-1);\n\tfor(int i = 60;i >= 0;i--){\n\t\tif(ans & (1LL << i)){\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=100100;\nint i,j,k,n,En,ch,ff,ans,x,y;\nint h[N],f[N];\nstruct edge { int s,n;} E[N<<1];\nvoid R(int &x) {\n\tff=x=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) { if (ch=='-') ff=1;ch=getchar();}\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nvoid E_add(int x,int y) {\n\tE[++En].s=y;E[En].n=h[x];h[x]=En;\n\tE[++En].s=x;E[En].n=h[y];h[y]=En;\n}\nvoid dfs(int x,int F) {\n\tint t=0,tt=0;\n\tfor (int k=h[x];k;k=E[k].n) if (E[k].s!=F) {\n\t\tdfs(E[k].s,x);\n\t\ttt|=f[E[k].s]&t;\n\t\tt|=f[E[k].s];\n\t}\n\tint i=0;\n\twhile (((1<<i)<=tt) || ((1<<i)&t)) i++;\n\tans=max(ans,i);\n\tf[x]=(t>>i<<i)|(1<<i);\n}\nint main() {\n\tR(n);\n\tfor (i=1;i<n;i++) {\n\t\tR(x);R(y);\n\t\tE_add(x,y);\n\t}\n\tdfs(1,0);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/* In the name of Allah */\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint n, dp[N][2], L[N], R[N];\nvector<int> adj[N];\n\nvoid dfs1(int u, int par) {\n\tfor (auto v: adj[u])\n\t\tif (v ^ par) {\n\t\t\tdfs1(v, u);\n\t\t\tdp[u][0] = max(dp[u][0], dp[v][0] + 1);\n\t\t}\n}\n\nvoid dfs2(int u, int par) {\n\tfor (int i = 0; i <= adj[u].size(); i++)\n\t\tL[i] = R[i] = dp[u][1];\n\tfor (int i = 0; i < adj[u].size(); i++)\n\t\tL[i + 1] = max(L[i], adj[u][i] ^ par? dp[adj[u][i]][0] + 1: 0);\n\tfor (int i = adj[u].size() - 1; i; i--)\n\t\tR[i - 1] = max(R[i], adj[u][i] ^ par? dp[adj[u][i]][0] + 1: 0);\n\tfor (int i = 0; i < adj[u].size(); i++)\n\t\tif (adj[u][i] ^ par)\n\t\t\tdp[adj[u][i]][1] = max(L[i], R[i]) + 1;\n\tfor (auto v: adj[u])\n\t\tif (v ^ par)\n\t\t\tdfs2(v, u);\n}\n\ninline void readInput() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\n\t\tu--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\ninline void solve() {\n\tdfs1(0, -1);\n\tdfs2(0, -1);\n\tint ans = n;\n\tfor (int i = 0; i < n; i++)\n\t\tans = min(ans, max(dp[i][0], dp[i][1]));\n\tcout << --ans << endl;\n}\n\nint main() {\n\tios:: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\treadInput(), solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[100001];\n/*\nint h[100001];\nll dp[100001];\n\nvoid dfs(int u, int p)\n{\n\tif(p==-1) h[u]=0;\n\telse h[u]=h[p]+1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tif(adj[u][i]==p) continue;\n\t\tdfs(adj[u][i],u);\n\t}\n}\n*/\n/*\nconst int N = 1e5 + 3;\n\nint subsize[N];\nbool visited[N];\nint treesize;\nvoid dfs(int u, int par)\n{\n\tsubsize[u] = 1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tdfs(v, u);\n\t\tsubsize[u] += subsize[v];\n\t}\n\ttreesize=subsize[u];\n}\n\nint centroid(int u, int par)\n{\n\tint best = 0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tbest=max(best,subsize[v]);\n\t}\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tint maxsize = treesize-subsize[v];\n\t\tfor(int j = 0; j < adj[v].size(); j++)\n\t\t{\n\t\t\tint w = adj[v][j];\n\t\t\tif(w==u) continue;\n\t\t\tif(visited[w]) continue;.\n\t\t\tmaxsize=max(maxsize,subsize[w]);\n\t\t}\n\t\t//if(subsize[v]>treesize-subsize[v]) return centroid(v, u);\n\t\tif(maxsize<best) return centroid(v,u);\n\t}\n\treturn u;\n}\n\nint compsolve(int u)\n{\n\tdfs(u, -1);\n\tint cent = centroid(u, -1);\n\t//cerr<<u<<' '<<cent<<'\\n';\n\tvisited[cent]=1;\n\tint ans = -1;\n\tfor(int i = 0; i < adj[cent].size(); i++)\n\t{\n\t\tint v = adj[cent][i];\n\t\tif(visited[v]) continue;\n\t\tans=max(ans,compsolve(v));\n\t}\n\treturn ans+1;\n}\n*/\n\nvi dp[100001];\nint best[100001];\nint par[100001];\nvoid dfs(int u, int p)\n{\n\tpar[u]=p;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tdfs(v,u);\n\t}\n\tint a = -1;\n\tmap<int,int> ma;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(v==p) continue;\n\t\tfor(vit it = dp[v].begin(); it != dp[v].end(); it++)\n\t\t{\n\t\t\tma[(*it)]++;\n\t\t}\n\t}\n\tfor(mit it = ma.begin(); it != ma.end(); it++)\n\t{\n\t\tif(it->se>=2) a = it->fi;\n\t}\n\tint b = a + 1;\n\twhile(ma[b]>0)\n\t{\n\t\tb++;\n\t}\n\tdp[u].pb(b);\n\tfor(mit it = ma.begin(); it != ma.end(); it++)\n\t{\n\t\tif(it->fi>b) dp[u].pb(it->fi);\n\t}\n\t/*\n\tbest[u] = u;\n\tif(child>=0)\n\t{\n\t\tint z = best[child];\n\t\tbest[u] = z;\n\t\twhile(best[u]!=u)\n\t\t{\n\t\t\tint p = par[best[u]];\n\t\t\tint gain = dp[best[u]]+1;\n\t\t\t\n\t\t}\n\t}\n\t*/\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tdfs(0,-1);\n\tvit it = dp[0].end();\n\tit--;\n\tcout<<(*it)<<'\\n';\n\t//cout<<compsolve(0)<<'\\n';\n\t/*\n\tdp[1] = 2;\n\tfor(int i = 2; i <= 60; i++)\n\t{\n\t\tdp[i] = (dp[i-1]*2+2);\n\t}\n\tdfs(0,-1);\n\tint best = 0; int idx = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t\tidx=i;\n\t\t}\n\t}\n\tdfs(idx,-1);\n\tbest=0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t}\n\t}\n\t//cerr<<best<<'\\n';\n\tfor(int i = 1; i <= 60; i++)\n\t{\n\t\tif(best<=dp[i])\n\t\t{\n\t\t\tcout<<i<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define ll long long \n#define ret return\n#define PB push_back\n#define lc 2 * v\n#define rc 2 * v + 1\n#define mid (s + e) / 2\n#define pii pair <int,  int>\n#define pll pair <long long , long long>  \n#define FAST ios::sync_with_stdio(false);cin.tie(0);\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n\nconst int maxn = 3e6 + 50 , K = 25;\nvector <int> edges[maxn];\nll a[maxn] , n , ans;\n\nvoid dfs(int v, int p = -1) {\n    int b = 0;\n    for (auto u : edges[v]) {\n        if (u == p) continue;\n        dfs(u , v);\n        // for (int i = b; i < K; ++i) {\n        //     if ((a[v] & a[u]) & (1 << i)) {\n        //         b = i + 1;\n        //     }\n        // }\n        a[v] |= a[u];\n        while (a[v] & (1 << b)) {\n            b++;\n        }\n    }\n    for (int i = 0; i < b; ++i) {\n        if (a[v] & (1 << i)) {\n            a[v] ^= (1 << i);\n        }\n    }\n    a[v] |= (1 << b);\n}\nint main() {\n    FAST\n    cin >> n;\n    for (int i = 1; i < n; i++){\n        int u, v;\n        cin >> u >> v;\n        edges[u].PB(v);\n        edges[v].PB(u);\n    }\n    dfs(1);\n    for (int i = 0; i < K; ++i) {\n        if (a[1] & (1 << i)) {\n            ans = i;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define MAXN 1000010\n#define MAXD 21\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXN<<1];\n\nint n;\nint g[MAXN],nume;\nint f[MAXN];\nint highbit[MAXN];\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nvoid dfs(int x,int p){\n\tint s_or=0,s_and=0;\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(e[i].to^p){\n\t\t\tdfs(e[i].to,x);\n\t\t\ts_and|=f[e[i].to]&s_or;\n\t\t\ts_or|=f[e[i].to];\n\t\t}\n\tf[x]=s_or+highbit[s_and];\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"D.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tscanf(\"%d\",&n);\n\thighbit[0]=1;\n\thighbit[1]=1;\n\tfor(int i=2;i<MAXN;i++)\n\t\thighbit[i]=highbit[i>>1]<<1;\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t\taddEdge(v,u);\n\t}\n\tdfs(1,0);\n\tint res=0,temp=f[1];\n\twhile(temp){\n\t\tres++;\n\t\ttemp>>=1;\n\t}\n\tprintf(\"%d\\n\",res-1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXM=MAXN-1;\n\nint n;\nint ghead[MAXN],gnxt[2*MAXM],gto[2*MAXM];\n\nll dfs(int at,int par) {\n\tll ret=0; int me=0;\n\tfor(int x=ghead[at];x!=-1;x=gnxt[x]) {\n\t\tint to=gto[x]; if(to==par) continue;\n\t\tll cur=dfs(to,at);\n\t\twhile((cur&(1LL<<me))||(ret&(1LL<<me))||(1LL<<me)<(cur&ret)) ++me;\n\t\tret|=cur;\n\t}\n\tret&=~((1LL<<me)-1); ret|=(1LL<<me);\n\t//printf(\"%d = %lld\\n\",at,ret);\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n); REP(i,n) ghead[i]=-1;\n\tREP(i,n-1) {\n\t\tint a,b; scanf(\"%d%d\",&a,&b); --a,--b;\n\t\tgnxt[2*i+0]=ghead[a]; ghead[a]=2*i+0; gto[2*i+0]=b;\n\t\tgnxt[2*i+1]=ghead[b]; ghead[b]=2*i+1; gto[2*i+1]=a;\n\t}\n\tll res=dfs(0,-1);\n\tint ret=0; while(res>>(ret+1)) ++ret; printf(\"%d\\n\",ret);\n\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nvector<int> graph[limit];\n\nint opr(int val){\n\tint start = 30;\n\t\n\trep(i, 30){\n\t\tif((val >> i & 1) == 0) {\n\t\t\tstart = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tval ^= (1 << start);\n\trrep(i, start){\n\t\tif((val >> i & 1) == 1) {\n\t\t\tval ^= (1 << i);\n\t\t}\n\t}\n\n\treturn val;\n}\n\nint dfs(int v, int p){\n\tint ret = 0;\n\n\tfor(auto &v2: graph[v]){\n\t\tif(v2 == p) continue;\n\t\tret |= dfs(v2, v);\n\t}\n\n\tret = opr(ret);\n\treturn ret;\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\n\trep(i, n - 1){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\n\tconst ll val = dfs(0, -1);\n\n\trrep(ans, 30){\n\t\tif(val >> ans & 1) {\n\t\t\tcout << ans << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int LL;\ntypedef LL ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\ntypedef stringstream strs;\n \n#define X first\n#define Y second\n#define PB push_back\n#define For(i,a,b) for (int i=a;i<b;i++)\n#define Ford(i,a,b) for (int i=a;i>=b;i--)\n#define smax(a,b) a=max(a,b)\n#define smin(a,b) a=min(a,b)\n#define SZ(a) ((ll)a.size())\n#define ER(a) cout << #a << ' ' << a << endl\n#define LB(a,n,x) (lower_bound(a,(a)+(n),x)-(a))\n#define RET(x) { cout << x; exit(0); } \nconst ll M=2e5+5,LG=19,SM=600+5,inf=1e18+1;\nll mod=1e9+7;\n\nll n;\nvll g[M];\n\nll dfs(ll x,ll p)\n{\n    ll res=0;\n    for (ll y:g[x])\n    {\n        if (y!=p)\n            res|=dfs(y,x);\n    }\n    return res+1;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);\n    cin >> n;\n    For(i,1,n)\n    {\n        ll a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].PB(b);g[b].PB(a);\n    }\n    ll x=dfs(0,0);\n    ll cnt=0;\n    for (;x>1;x/=2) cnt++;\n    RET(cnt);\n}    "
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nint n;\nvector<int>con[100111];\nint dfs(int x,int pre=-1)\n{\n\tint ret=0;\n\tfor(int i=0;i<con[x].size();i++)\n\t{\n\t\tint u=con[x][i];\n\t\tif(u==pre)continue;\n\t\tret|=dfs(u,x);\n\t}\n\treturn ret+1;\n}\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tgetii(x,y);\n\t\tcon[x].PB(y);\n\t\tcon[y].PB(x);\n\t}\n\tint tmp=dfs(1);\n\tfor(int i=30;i>=0;i--)if(tmp>>i&1)\n\t{\n\t\tcout<<i<<endl;\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<vector<int>> graph(n);\n    rep(i,0,n-1){\n        int a,b;\n        cin >> a >> b;\n        --a;\n        --b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }                                                                                                                                                                                                                        \n\n    function<int(int,int)> rec=[&](int u,int p){\n        int count[32]={},mask=0;\n        for(int v:graph[u]){\n            if(v==p) continue;\n            int tmp=rec(v,u);\n            mask|=tmp;\n            rep(i,0,32) if((tmp>>i)&1) ++count[i];\n        }\n        int low=0;\n        for(int i=31; i>=0; --i) if(count[i]>=2){\n            low=i+1;\n            break;\n        }\n        rep(i,low,32) if(!count[i]) return ((mask>>(i+1))<<(i+1))|(1<<i);\n    };\n\n    int tmp=rec(0,-1);\n    for(int i=31; i>=0; --i) if((tmp>>i)&1){\n        cout << i << endl;\n        return;\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nvi adj[100001];\n/*\nint h[100001];\nll dp[100001];\n\nvoid dfs(int u, int p)\n{\n\tif(p==-1) h[u]=0;\n\telse h[u]=h[p]+1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tif(adj[u][i]==p) continue;\n\t\tdfs(adj[u][i],u);\n\t}\n}\n*/\nconst int N = 1e5 + 3;\n\nint subsize[N];\nbool visited[N];\nint treesize;\nvoid dfs(int u, int par)\n{\n\tsubsize[u] = 1;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tdfs(v, u);\n\t\tsubsize[u] += subsize[v];\n\t}\n\ttreesize=subsize[u];\n}\n\nint centroid(int u, int par)\n{\n\tint best = 0;\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tbest=max(best,subsize[v]);\n\t}\n\tfor(int i = 0; i < adj[u].size(); i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif(visited[v]) continue;\n\t\tif(v == par) continue;\n\t\tint maxsize = treesize-subsize[v];\n\t\tfor(int j = 0; j < adj[v].size(); j++)\n\t\t{\n\t\t\tint w = adj[v][j];\n\t\t\tif(w==u) continue;\n\t\t\tif(visited[w]) continue;\n\t\t\tmaxsize=max(maxsize,subsize[w]);\n\t\t}\n\t\t//if(subsize[v]>treesize-subsize[v]) return centroid(v, u);\n\t\tif(maxsize<best) return centroid(v,u);\n\t}\n\treturn u;\n}\n\nint compsolve(int u)\n{\n\tdfs(u, -1);\n\tint cent = centroid(u, -1);\n\t//cerr<<u<<' '<<cent<<'\\n';\n\tvisited[cent]=1;\n\tint ans = -1;\n\tfor(int i = 0; i < adj[cent].size(); i++)\n\t{\n\t\tint v = adj[cent][i];\n\t\tif(visited[v]) continue;\n\t\tans=max(ans,compsolve(v));\n\t}\n\treturn ans+1;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint u, v; cin>>u>>v;\n\t\tu--; v--;\n\t\tadj[u].pb(v); adj[v].pb(u);\n\t}\n\tcout<<compsolve(0)<<'\\n';\n\t/*\n\tdp[1] = 2;\n\tfor(int i = 2; i <= 60; i++)\n\t{\n\t\tdp[i] = (dp[i-1]*2+2);\n\t}\n\tdfs(0,-1);\n\tint best = 0; int idx = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t\tidx=i;\n\t\t}\n\t}\n\tdfs(idx,-1);\n\tbest=0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(h[i]>best)\n\t\t{\n\t\t\tbest=h[i];\n\t\t}\n\t}\n\t//cerr<<best<<'\\n';\n\tfor(int i = 1; i <= 60; i++)\n\t{\n\t\tif(best<=dp[i])\n\t\t{\n\t\t\tcout<<i<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define pb push_back\n\nconst int maxn = 1e5 + 20;\n\nint maxb = 20;\n\nint dp[maxn][20] , tmp[20];\n\nvector<int> adj[maxn];\n\nint last_bits(int x , int i)\n{\n\treturn (x >> i) << i;\n}\n\nvoid dfs(int v , int p = -1)\n{\n\tfor(int i = 0; i < maxb; i++)\n\t\tdp[v][i] = (1 << i);\n\n\tfor(auto u : adj[v])\n\t\tif(u != p)\n\t\t{\n\t\t\tdfs(u , v);\n\n\t\t\tfill(tmp , tmp + maxb , (1 << (maxb + 1)) - 1);\n\t\t\tfor(int i = 0; i < maxb; i++)\n\t\t\t\tfor(int j = 0; j < maxb; j++)\n\t\t\t\t\tif((dp[v][i] & dp[u][j]) == 0)\n\t\t\t\t\t\ttmp[i] = min(tmp[i] , (dp[v][i] | last_bits(dp[u][j] , i)));\n\n\t\t\tfor(int i = 0; i < maxb; i++)\n\t\t\t\tdp[v][i] = tmp[i];\n\t\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tint a , b;\n\t\tcin >> a >> b;\n\t\ta-- , b--;\n\t\t\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\n\tfor(maxb = 1; ; maxb++)\n\t{\n\t\tdfs(0);\n\t\tif(*min_element(dp[0] , dp[0] + maxb) < (1 << maxb))\n\t\t\treturn cout << maxb - 1 << endl , 0;\n\t}\n\n/*\twhile(1)\n\t{\n\t\tmaxb--;\n\t\tdfs(0);\n\n\t\tif(!maxb || *max_element(dp[0] , dp[0] + maxb) == 0)\n\t\t\treturn cout << maxb << endl , 0;\n\t}*/\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n *                                                                       *\n *                    XI Olimpiada Informatyczna                         *\n *                                                                       *\n *   Rozwi±zanie zadania: Jaskinia                                       *\n *   Plik:                jas.cpp                                        *\n *   Autor:               Arkadiusz Paterek                              *\n *************************************************************************/\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define VAR(a, b) __typeof(b) a = (b)\n#define FOREACH(it, c) for(VAR(it, (c).begin()); it != (c).end(); ++it)\n\nstruct Node {\n  vector<int> neigh; // s±siedzi wezla w drzewie\n  int f; // funkcja f z dowodu (minimalna liczba pytañ)\n  vector<int> S; // zbiór S z dowodu (warto¶ci f, które \"widaæ\" \"patrz±c\" od ojca wierzcho³ka)\n  \n  Node() : S(25, 0) { // inicjujemy S na 25 elementow, bo K = max_f nie moze byæ wiêksze niz log(rozmiar drzewa)\n    f = 0;\n  }\n};\n\nstruct Tree {\n  vector<Node> nodes; // wierzcho³ki tworz±ce drzewo\n  \n  friend istream &operator>>(istream &is, Tree &tree) { // wczytanie drzewa z wej¶æia\n    vector<Node> &nodes = tree.nodes;\n    nodes.clear();\n    \n    int size;\n    is >> size;\n    nodes.resize(size);\n\n    int a, b;\n    for (int i = 0; i < size - 1; ++i) {\n      is >> a >> b;\n      --a;\n      --b;\n      nodes[a].neigh.push_back(b);\n      nodes[b].neigh.push_back(a);\n    }\n    \n    return is;\n  }\n  \n  void computeF(int n, int father) { // DFS w drzewie - obliczenie warto¶ci f w wêŒle n\n    Node &node = nodes[n];\n    \n    FOREACH(child_i, node.neigh)\n      if (*child_i != father) { // dla wszystkich s±siadów w drzewie oprócz poprzednika\n        Node &child = nodes[*child_i];\n        computeF(*child_i, n);\n        \n        for (int i = 0; i < (int)child.S.size(); ++i)\n          if (child.S[i] > 0)\n            ++node.S[i];\n      }\n\n\n    int m = node.S.size();\n    do\n      --m;\n    while (m >= 0 && node.S[m] < 2);\n\n    node.f = m + 1;\n    while (node.S[node.f] > 0)\n      ++node.f;\n    \n    for (int i = 0; i < node.f; ++i)\n      node.S[i] = 0;\n\n    node.S[node.f] = 1;\n    \n/*    cerr << \"computeF \" << n << \" \" << father << endl;\n    cerr << \" m = \" << m << endl;\n    cerr << \" f = \" << node.f << endl;\n    cerr << \" S = \";\n    copy(node.S.begin(), node.S.end(), ostream_iterator<int>(cerr, \" \"));\n    cerr << endl;*/\n  }\n  \n  int computeAnswer() {\n    computeF(0, -1);\n    \n    int max_f = -1;\n    FOREACH(node, nodes) {\n      if (node->f > max_f)\n        max_f = node->f;\n    }\n    return max_f;\n  }\n};\n\nint main() {\n  Tree tree;\n  cin >> tree;\n  cout << tree.computeAnswer() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\nint n;\nvector<int>G[100010];\nint state[100010];\nint ans;\nvoid dfs(int x,int p)\n{\n\tfor(int i=0;i<G[x].size();i++)\n\t{\n\t\tint y=G[x][i];\n\t\tif(y==p)continue;\n\t\tdfs(y,x);\n\t    state[x]|=state[y];\n\t}\n\tint res=0;\n\tfor(int i=0;i<=20;i++)\n\t{\n\t\tif(state[x]>>i&1)continue;\n\t\tres=i;\n\t\tbreak;\n\t}\n\tstate[x]|=(1<<res);\n\tfor(int i=0;i<res;i++)if(state[x]>>i&1)state[x]^=(1<<i);\n\tans=max(ans,res);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a); \n\t}\n\tdfs(1,0);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> bool chkmax(T &a, const T &b) { return a < b ? a = b, true : false; }\ntemplate <typename T> bool chkmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\ntypedef long long LL;\ntypedef long double LD;\nconst int BUF_SIZE = (int)2e7 + 10;\nstruct fastIO {\n    char buf[BUF_SIZE], buf1[BUF_SIZE];\n    int cur, cur1; FILE *in, *out;\n    fastIO() { cur = BUF_SIZE, in = stdin, out = stdout; cur1 = 0; __builtin_prefetch(buf);__builtin_prefetch(buf1);}\n    inline char getchar() { if(cur == BUF_SIZE) fread(buf, BUF_SIZE, 1, in), cur = 0; return *(buf + (cur++)); }\n    inline void putchar(char ch) { *(buf1 + (cur1++)) = ch; if (cur1 == BUF_SIZE) fwrite(buf1, BUF_SIZE, 1, out), cur1 = 0; }\n    inline int flush() { if (cur1 > 0) fwrite(buf1, cur1, 1, out); return cur1 = 0; }\n}IO;\n#define getchar IO.getchar\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n} \n\nconst int Maxn = 1e5 + 9;\nstruct edge {\n\tint to, nxt;\n}g[Maxn << 1];\nint n, head[Maxn];\nvoid add(int u, int v) { \n\tstatic int e = 0;\n\tg[++e] = (edge){v, head[u]}, head[u] = e; \n}\n\nint ans = 0;\nstatic int bit[Maxn];\n\nvoid dfs(int u, int pa) {\n\tint same = 0;\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tdfs(v, u);\n\t\t\tsame |= bit[u] & bit[v];\n\t\t\tbit[u] |= bit[v];\n\t\t}\n\t}\n\tint mx = __builtin_ffs(same);\n\twhile (bit[u] & (1 << mx)) ++mx;\n\tbit[u] |= (1 << mx);\n\tchkmax(ans, mx), bit[u] = bit[u] >> mx << mx;\n}\n\nint main() {\n\n\tclar(head, -1);\n\tn = read();\n\trep (i, 1, n - 1) {\n\t\tint u = read(), v = read();\n\t\tadd(u, v), add(v, u);\n\t}\n\tdfs(1, 0);\n\tcout << ans << endl;\n\n#ifdef Qrsikno\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct node {\n\tint to, next;\n} edge[MAXN*2];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nint n, a, b;\n\nint dp[MAXN], lg[MAXN];\n\ninline int lowbit(int i)\n{ return i&(-i); }\n\nint lab[MAXN];\n\nvoid dfs(int nd, int f)\n{\n\tint past = 0, minv = 0;\n\tfor (int i = head[nd]; i; i = edge[i].next) {\n\t\tint to = edge[i].to;\n\t\tif (to == f) continue;\n\t\tdfs(to, nd);\n\t\tminv = max(minv, lg[past&dp[to]]);\n\t\tpast |= dp[to];\n\t}\n\tpast >>= minv;\n\tlab[nd] = lg[lowbit(past+1)]+minv;\n\tdp[nd] = (past+1)<<minv;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tlg[1] = 0;\n\tfor (int i = 2; i <= n; i++) lg[i] = lg[i>>1]+1;\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tpush(a, b), push(b, a);\n\t}\n\tdfs(1, 0);\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans = max(ans, lab[i]);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<ctime>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\t\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nstruct edge\n{\n\tint to;\n\tint next;\n}e[666666];\nint pe=222222;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n}\nint f[222222],g[222222];\nint top[555555];\nvoid dfs(int o,int fa)\n{\n\tint s=0;\n\tint min=-1;\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)\n\t\t{\n\t\t\tdfs(e[p].to,o);\n\t\t\tcmax(min,top[s&g[e[p].to]]);\n\t\t\ts|=g[e[p].to];\n\t\t}\n\tfor(register int i=min+1;i<=20;++i)\n\t\tif(!(s&1<<i)){f[o]=i;break;}\n\tg[o]=1<<f[o];\n\tfor(register int p=e[o].next;p;p=e[p].next)\n\t\tif(e[p].to!=fa)g[o]|=g[e[p].to]&~((1<<f[o])-1);\n}\nint main()\n{\n\ttop[0]=-1;\n\tfor(register int i=2;i<=524287;++i)\n\t\ttop[i]=top[i>>1]+1;\n\tif(1)\n\t{\n\t\tint n=io::F();\n\t\tif(n==0)\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(register int i=1;i<n;++i)\n\t\t{\n\t\t\tint x=io::F(),y=io::F();\n\t\t\tinsert(x,y);\n\t\t\tinsert(y,x);\n\t\t}\n\t\tdfs(1,0);\n\t\tint max=0;\n\t\tfor(register int i=1;i<=n;++i)cmax(max,f[i]);\n\t\tprintf(\"%d\\n\",max);\n\t\tpe=222222;\n\t\tfor(register int i=1;i<=n;++i)e[i].next=0;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\n# define x first    \n# define y second\n# define mp make_pair\n// everything go according to my plan      \n# define pb push_back\n# define sz(a) (int)(a.size())\n# define vec vector         \n// shimkenttin kyzdary, dzyn, dzyn, dzyn...\n# define y1    Y_U_NO_y1\n# define left  Y_U_NO_left\n# define right Y_U_NO_right  \n\nusing namespace std;\n\ntypedef pair <int, int> pii; \ntypedef long long ll;\ntypedef long double ld;\n\nconst int Mod = (int)1e9 + 7;\nconst int MX = 1073741822;\nconst ll MXLL = 4e18;\nconst int Sz = 1110111;\n// a pinch of soul\ninline void Read_rap () {\n  ios_base :: sync_with_stdio(0);\n  cin.tie(0); cout.tie(0);\n}\ninline void randomizer3000 () {\n  unsigned int seed;\n  asm (\"rdtsc\" : \"=A\"(seed));\n  srand (seed);\n}\nvoid files (string problem) {   \n  if (fopen ((problem + \".in\").c_str(),\"r\")) {\n    freopen ((problem + \".in\").c_str(),\"r\",stdin);\n    freopen ((problem + \".out\").c_str(),\"w\",stdout);\n  }\n}\nvoid localInput(const char in[] = \"s\") { \n  if (fopen (in, \"r\")) {\n    freopen (in, \"r\", stdin);\n  }\n  else\n    cerr << \"Warning: Input file not found\" << endl;\n}\nint n;\n\nvec<int> g[Sz];\n\nint mx[Sz], mx2[Sz];\nint D;\n\nvoid dfs (int v, int pr) {\n  for (int to : g[v]) {\n    if (to != pr) {\n      dfs (to, v);\n      if (mx[v] < mx[to] + 1)\n        mx2[v] = mx[v], mx[v] = mx[to] + 1;\n      else\n        mx2[v] = max (mx2[v], mx[to] + 1);\n    }\n  }\n  D = max (mx[v] + mx2[v], D);\n}\nint calc (int n) {\n  if (n == 1)\n    return 0;  \n  return calc (n / 2) + 1;\n}\nint main()\n{\n  # ifdef Local\n    //localInput();\n  # endif\n  Read_rap();\n  cin >> n;\n  for (int i = 1; i < n; i++) {\n    int a, b; cin >> a >> b;\n    g[a].pb (b);\n    g[b].pb (a);\n  }     \n  dfs (1, 1);\n  cout << calc (D + 1);        \n\n  return 0;\n}\n\n\n\n\n\n\n// Coded by Z..\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, f[55000], g[22];\nvector<int>G[55000];\n\nint mg(int x,int y){\n  for (int t;t=(x&y);){\n    x+=t&-t;\n  }\n  return min(10001000,x|y);\n}\n\nvoid dfs(int x,int fff){\n  for (auto y:G[x])\n    if (y!=fff)\n      dfs(y,x);\n  memset(g,0,sizeof g);\n  for (auto y:G[x])\n    if (y!=fff){\n      for (int i=0;i<=20;++i){\n\tint tmp=f[y]>>i<<i;\n\tif (tmp>>i&1) tmp+=1<<i;\n\tg[i]=mg(g[i],tmp);\n      }\n    }\n  f[x]=998244353;\n  for (int i=0;i<=20;++i)\n    f[x]=min(f[x],g[i]|1<<i);\n}\n\nint main(){\n  cin>>n; int x, y;\n  for (int tim=n-1;tim--;){\n    cin>>x>>y;\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  dfs(1,0);\n  int ans=0;\n  for (int t=f[1];t;t>>=1) ++ans;\n  cout<<ans-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\nusing namespace std;\nint p = 998244353;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\nconst int m = 4000;\n#define bs bitset<m>\nint kai_size = 400001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nint per(int n, int r) {\n\tint ans = kai[n] * ink[n - r];\n\tans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\nsigned main() {\n\tint n; cin >> n;\n\tvvel way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(b);\n\t\tway[b].push_back(a);\n\t}\n\tint u = most_far(0, n, way).second;\n\tint cho = most_far(u, n, way).first;\n\tcho++;\n\tint ans = 0;\n\twhile (cho > 1) {\n\t\tans++;\n\t\tcho = cho / 2;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Bismillahir Rahmanir Rahim */\n\n#include <bits/stdc++.h>\n\n#define rep(i, n)\tfor(int i=0;i<n;i++)\n#define repn(i, n)\tfor(int i=1;i<=n;i++)\n#define set(i, n)\tmemset(i, n, sizeof(i))\n\n#define pb\tpush_back\n#define f\tfirst\n#define s\tsecond\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 100007;\n\nint n, fx;\nvector<int>edge[N];\n\nint dfs(int at, int past){\n\tint mask = 0, cnt[25];\n\tset(cnt, 0);\n\trep(i, edge[at].size()){\n\t\tint u = edge[at][i];\n\t\tif(u == past) continue;\n\t\tint fask = dfs(u, at);\n\t\trep(j, 20){\n\t\t\tif(fask & (1 << j)) cnt[j]++;\n\t\t}\n\t\tmask |= fask;\n\t}\n\tint s = 0;\n\tfor(int i=20;i>=0;i--){\n\t\tif(cnt[i] > 1){\n\t\t\ts = i + 1;\n\t\t\tbreak;\n\t\t}\n\t} \n\tmask |= (1 << s);\n\tfor(int i=s-1;i>=0;i--) if(mask & (1 << i)) mask ^= (1 << i);\n\treturn mask;\n}\n\nint main(){\n\tint x, y;\n\tscanf(\"%d\", &n);\n\trepn(i, n-1){\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tint ret = dfs(1, 1);\n\tfor(int i=20;i>=0;i--){\n\t\tif(ret & (1 << i)){\n\t\t\tprintf(\"%d\\n\", i+1);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n  int t,next;\n  Edge() {}\n  Edge(int a,int b):t(a),next(b) {}\n}; \n\nEdge e[200005];\nint head[100005];\n\nint f[100005],g[100005],ans;\n\nvoid dfs(int x,int fa) {\n  int sum=0;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) {\n    \tint u=e[i].t;\n    \tdfs(u,x);\n    \tsum|=(g[x]&g[u]);\n    \tg[x]|=g[u];\n\t}\n  for(int i=0;i<20;i++)\n    if (!(sum&(1<<i))&&!(g[x]&(1<<i))) {\n    \tf[x]=i;\n    \tbreak;\n\t} \n    else g[x]&=(((1<<20)-1)^(1<<i));\n  g[x]|=(1<<f[x]);\n  ans=max(ans,f[x]);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<n;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[2*i-1]=Edge(y,head[x]);\n  \thead[x]=2*i-1;\n  \te[2*i]=Edge(x,head[y]);\n  \thead[y]=2*i;\n  }\n  dfs(1,0);\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nconst int MAXN = 100 * 1000 + 23, MXLN = 17 + 3;\n\n\n\n\n\n\n\n\n\n\n\nint n, mx, dp[MAXN], cnt[MAXN][MXLN];\nvector<int> g[MAXN];\n\n\nvoid dfs(int v = 0, int p = -1) {\n\tfor (auto u : g[v]) if (u != p) {\n\t\tdfs(u, v);\n\t\tdp[v] |= dp[u];\n\t\tfor (int i = 0; i < MXLN; i++) cnt[v][i] += ((dp[u] >> i) & 1);\n\t}\n//\t/*\n\tint b = 0, f = 1;\n\tfor (int i = 0; i < MXLN; i++) {\n\t\tif (cnt[v][i] > 1) {\n\t\t\tb = i + 1;\n\t\t\tf = 1;\n\t\t}\n\t\tif (cnt[v][i]) b += f;\n\t\telse f = 0;\n\t}\n//\t*/\n//\tfor (int i = 0; i < MXLN; i++) if (cnt[v][i] > 1) b = i;\n\tdp[v] &= (((1 << MXLN) - 1) ^ ((1 << b) - 1));\n\tdp[v] |= (1 << b);\n\tmx = max(mx, b);\n}\n\n\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[--u].push_back(--v), g[v].push_back(u);\n\t}\n\tdfs();\n\tcout << mx;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")*/\n#include<bits/stdc++.h>\n#define ll long long\n#define inf 1000000005\n#define put putchar('\\n')\n#define F(i,a,b) for (int i=(a);i<=(b);i++)\n#define D(i,a,b) for (int i=(a);i>=(b);i--)\n#define go(i,t) for (int i=head[t];i;i=Next[i])\n#define sqr(x) ((x)*(x))\n#define re register\n#define mp make_pair\n#define fi first\n#define se second\n#define pa pair<int,int>\n#define pb push_back\n#define be begin()\n#define en end()\n#define ret return puts(\"-1\"),0;\n#define mod 1000000007\n#define N 200055\n//#define int ll\nusing namespace std;\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){char c=getchar();int tot=1;while ((c<'0'|| c>'9')&&c!='-') c=getchar();if (c=='-'){tot=-1;c=getchar();}\nint sum=0;while (c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}return sum*tot;}\ninline void wr(int x){if (x<0) {putchar('-');wr(-x);return;}if(x>=10)wr(x/10);putchar(x%10+'0');}\ninline void wrn(int x){wr(x);put;}inline void wri(int x){wr(x);putchar(' ');}\ninline void wrn(int x,int y){wri(x);wrn(y);}inline void wrn(int a,int b,int c){wri(a);wrn(b,c);}\nint n,m,fa[N],ans;\nbitset <22> a[N],b[N];\nint nedge,Next[N*2],head[N],to[N*2];\n#define V to[i]\nvoid add(int a,int b){\n\tNext[++nedge]=head[a];head[a]=nedge;to[nedge]=b;\n}\nvoid add_ne(int a,int b){add(a,b);add(b,a);}\nvoid dfs(int x){\n\tgo(i,x){\n\t\tif (fa[x]==V) continue;\n\t\tfa[V]=x;dfs(V);b[x]|=a[x]&a[V];a[x]|=a[V];\n\t}\n\tint num=0;\n\tF(i,0,20) if (b[x][num]) num=i+1;\n\tF(i,num,20) if (a[x][i]==0) {num=i;break;}\n\ta[x][num]=1;\n\tans=max(ans,num);\n\tF(i,0,num-1) a[x].reset(i);\n}\nsigned main(){\n\tn=read();\n\tF(i,1,n-1) add_ne(read(),read());\n\tdfs(1);\n\tif (ans==20) while(1);\n\twrn(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In the Name of God\n//Let Our Voices Echo\n#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define X real()\n#define Y imag()\ntypedef long long ll;\ntypedef double ld; \ntypedef complex<ld> point;\nconst ld eps=1e-9;\nconst int MAX=1e5+9,MOD=1e9+7,lg=20;\nint n,ans;\nvector<int> g[MAX];\nint dfs(int v,int p=-1)\n{\n\tint res=0,mi=0;\n\tfor (auto u:g[v])\t\n\t\tif (u!=p)\n\t\t{\n\t\t\tint mask=dfs(u,v);\n\t\t\tfor (int i=0;i<lg;i++) \n\t\t\t\tif ((mask>>i&1) && (res>>i&1)) \n\t\t\t\t\tmi=max(mi,i+1);\n\t\t\tres|=mask;\n\t\t}\n\tfor (int i=mi;;i++)\n\t\tif (!(res>>i&1))\n\t\t{\n\t\t\tans=max(ans,i);\n\t\t\tres|=(1<<i);\n\t\t\tfor (int j=i-1;j>=0;j--)\n\t\t\t\tif (res>>j&1)\n\t\t\t\t\tres^=(1<<j);\n\t\t\treturn res;\n\t\t}\n\t\n}\nint main()\n{\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor (int i=1,v,u;i<n;i++) cin>>v>>u,v--,u--,g[v].push_back(u),g[u].push_back(v);\n\tdfs(0);\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 100100;\nconst int K = 20;\n\nvector<int> g[N];\nvector<pii> dp[N];\nvector<pii> a[K];\nint n;\n\nvoid dfs(int v, int par)\n{\n    int d = 0;\n    for (int u : g[v])\n    {\n        if (u == par) continue;\n        dfs(u, v);\n        d = max(d, dp[u][0].second);\n    }\n    for (int i = 0; i < K; i++)\n        a[i].clear();\n    for (int u : g[v])\n        if (u != par)\n            a[dp[u][0].second].push_back(mp(u, 0));\n    int oldd = d;\n    bool ok = true;\n//    printf(\"solving %d\\n\", v);\n    while(true)\n    {\n//        printf(\"d = %d\\n\", d);\n        if (d < 0)\n        {\n            ok = false;\n            break;\n        }\n        if (a[d].empty())\n        {\n            while(d > 0 && a[d - 1].empty()) d--;\n            dp[v].push_back(mp(v, d));\n            break;\n        }\n        if ((int)a[d].size() >= 2)\n        {\n            ok = false;\n            break;\n        }\n        int u = a[d][0].first;\n        int p = a[d][0].second;\n//        printf(\"%d %d\\n\", u, p);\n        dp[v].push_back(dp[u][p]);\n        p++;\n        if (p < (int)dp[u].size())\n            a[dp[u][p].second].push_back(mp(u, p));\n        d--;\n    }\n    if (!ok)\n    {\n  //      printf(\"! OK %d\\n\", v);\n        dp[v].clear();\n        dp[v].push_back(mp(v, oldd + 1));\n    }\n    return;\n}\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++)\n    {\n        int v, u;\n        scanf(\"%d%d\", &v, &u);\n        v--;u--;\n        g[v].push_back(u);\n        g[u].push_back(v);\n    }\n    dfs(0, -1);\n    printf(\"%d\\n\", dp[0][0].second);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *\t\tAtreus\n**/\n#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int maxn = 5e4 + 10;\n\nint n;\n\nint sz[maxn];\n\nbool visited[maxn], mark[maxn];\n\nint ans[maxn];\n\nvector <int> t[maxn];\n\nint dfs (int u, int par = -1) {\n\tsz[u] = 1;\n\tfor (auto w : t[u]) {\n\t\tif (w != par and !mark[w]) {\n\t\t\tsz[u] += dfs (w, u);\n\t\t}\n\t}\n\treturn sz[u];\n}\n\nvoid centroidDecomposition (int x, int now) {\n\tint Max = dfs (x), par = -1;\n\twhile (true) {\n\t\tbool found = 0;\n\t\tfor (auto w : t[x]) {\n\t\t\tif (par != w and !mark[w] and sz[w] > Max / 2) {\n\t\t\t\tpar = x;\n\t\t\t\tx = w;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\tmark[x] = 1;\n\tans[x] = now;\n\tfor (auto w : t[x]) {\n\t\tif (!mark[w]) {\n\t\t\tcentroidDecomposition (w, now + 1);\n\t\t}\n\t}\n}\n\nvoid addEdge (int u, int w) {\n\tt[u].push_back(w);\n\tt[w].push_back(u);\n}\n\nint main () {\n\tios_base::sync_with_stdio (false);\n\tcin >> n;\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint u, w;\n\t\tcin >> u >> w;\n\t\taddEdge (u, w);\n\t}\n\tcentroidDecomposition (1, 0);\n\tcout << *max_element(ans + 1, ans + n + 1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n \nconst int N = 1e5 + 7;\n \nvector <int> ad[N];\nint gone[N], n, mrk[N],\tsz[N];\n\nvoid dfs(int v, int p = 0) {\n\tsz[v] = 1;\n\tmrk[v] = 1;\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tdfs(u, v);\n\t\t\tsz[v] += sz[u];\n\t\t}\n\t}\n}\npair <int, int> get(int v, int p, int sall) {\n\tpair <int, int> res;\n\tres.first = v;\n\tres.second = sall - sz[v];\n\tfor (auto u: ad[v])\n\t   \tif (!gone[u] && u != p)\t\n\t\t\tres.second = max(res.second, sz[u]);\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tpair <int, int> t = get(u, v, sall);\n\t\t\tif (t.second < res.second)\n\t\t\t\tres = t;\n\t\t}\n\t}\n\treturn res;\n}\npair <int, int> ffs(int v, int p) {\n\tpair <int, int> mx = {v, 1};\n\tfor (auto u: ad[v])\n\t\tif (u != p) {\n\t\t\tauto t = ffs(u, v);\n\t\t\tt.second++;\n\t\t\tif (t.second > mx.second)\n\t\t\t\tmx = t;\n\t\t}\n\treturn mx;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tad[v].push_back(u);\n\t\tad[u].push_back(v);\n\t}\n\tint res = 0;\n\twhile (1) {\n\t\tbool was = 0;\n\t\tmemset(sz, 0, sizeof sz);\n\t\tmemset(mrk, 0, sizeof mrk);\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tif (!gone[i] && !mrk[i]) {\n\t\t\t\twas = 1;\n\t\t\t\tdfs(i);\n\t\t\t\tint v = get(i, 0, sz[i]).first;\n\t\t\t\tgone[v] = 1;\n\t\t\t}\n\t\tif (!was)\n\t\t\tbreak;\n\t\tres++;\n\t}\n\tint v = ffs(1, 0).first;\n\tint d = ffs(v, 0).second;\n\tint r2 = ((int)log2(d));\n\tif (abs(r2 - res) > 1) {\n\t\tcout << 1 / 0;\n\t}\n\tcout << (r2 + res - 1) / 2;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    if(1){\n      vector<Int> used(n,0);\n      queue<Int> q({0});\n      used[0]=1;\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tif(v<0||v>=n) exit(0);\n\tfor(Int u:G[v]){\n\t  if(u<0||u>=n) exit(0);\n\t  if(used[u]) continue;\n\t  used[u]=1;\n\t  q.emplace(u);\n\t}\n      }\n      for(Int i=0;i<n;i++) assert(used[i]);\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    //break;\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n        used[u]=2;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n\n      //cout<<v<<\":\"<<c<<endl;\n      if(c<0){\n\tused[v]=1;\n\tbelong[v]=t;\n\tcontinue;\n      }\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      \n      for(Int u:G[c]){\n\tif(used[u]) continue;\n\tused[u]=1;\n\tbelong[u]=t;\n\tdisable2(u);\n      }\n    }\n    \n    \n    for(Int i=0;i<n;i++){\n      //cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n      assert(used[i]);\n      assert(0<=belong[i]&&belong[i]<(int)T.size());\n    }\n    \n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n\n    swap(G,T);\n    //break;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i <= i##_end_; ++i)\n#define drep(i, a, b) for (int i = (a), i##_end_ = (b); i >= i##_end_; --i)\n#define clar(a, b) memset((a), (b), sizeof(a))\n#define debug(...) fprintf(stderr, __VA_ARGS__)\ntemplate <typename T> bool chkmax(T &a, const T &b) { return a < b ? a = b, true : false; }\ntemplate <typename T> bool chkmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate <typename T> T sgn(const T&a) { return (a > T(0)) - (a < T(0)); }\ntypedef long long LL;\ntypedef long double LD;\nconst int BUF_SIZE = (int)2e7 + 10;\nstruct fastIO {\n    char buf[BUF_SIZE], buf1[BUF_SIZE];\n    int cur, cur1; FILE *in, *out;\n    fastIO() { cur = BUF_SIZE, in = stdin, out = stdout; cur1 = 0; __builtin_prefetch(buf);__builtin_prefetch(buf1);}\n    inline char getchar() { if(cur == BUF_SIZE) fread(buf, BUF_SIZE, 1, in), cur = 0; return *(buf + (cur++)); }\n    inline void putchar(char ch) { *(buf1 + (cur1++)) = ch; if (cur1 == BUF_SIZE) fwrite(buf1, BUF_SIZE, 1, out), cur1 = 0; }\n    inline int flush() { if (cur1 > 0) fwrite(buf1, cur1, 1, out); return cur1 = 0; }\n}IO;\n#define getchar IO.getchar\nLL read() {\n\tLL x = 0, flag = 1;\n\tchar ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') flag *= -1;\n\tfor (; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n\treturn x * flag;\n}\nvoid write(LL x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x >= 10) write(x / 10);\n\tputchar(x % 10 + '0');\n} \n\nconst int Maxn = 1e5 + 9;\nstruct edge {\n\tint to, nxt;\n}g[Maxn << 1];\nint n, head[Maxn];\nvoid add(int u, int v) { \n\tstatic int e = 0;\n\tg[++e] = (edge){v, head[u]}, head[u] = e; \n}\n\nint ans = 0;\nstatic int bit[Maxn];\n\nvoid dfs(int u, int pa) {\n\tint same = 0;\n\tfor (int i = head[u]; ~i; i = g[i].nxt) {\n\t\tint v = g[i].to;\n\t\tif (v != pa) {\n\t\t\tdfs(v, u);\n\t\t\tsame |= bit[u] & bit[v];\n\t\t\tbit[u] |= bit[v];\n\t\t}\n\t}\n\tint mx = same ? 32 - __builtin_clz(same) : 0;\n\twhile (bit[u] & (1 << mx)) ++mx;\n\tbit[u] |= (1 << mx);\n\tchkmax(ans, mx), bit[u] = bit[u] >> mx << mx;\n}\n\nint main() {\n\n\tclar(head, -1);\n\tn = read();\n\trep (i, 1, n - 1) {\n\t\tint u = read(), v = read();\n\t\tadd(u, v), add(v, u);\n\t}\n\tdfs(1, 0);\n\tcout << ans << endl;\n\n#ifdef Qrsikno\n\tdebug(\"\\nRunning time: %.3lf(s)\\n\", clock() * 1.0 / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Bismillahir Rahmanir Rahim */\n\n#include <bits/stdc++.h>\n\n#define rep(i, n)\tfor(int i=0;i<n;i++)\n#define repn(i, n)\tfor(int i=1;i<=n;i++)\n#define set(i, n)\tmemset(i, n, sizeof(i))\n\n#define pb\tpush_back\n#define f\tfirst\n#define s\tsecond\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 100007;\n\nint n, fx;\nvector<int>edge[N];\n\nint dfs(int at, int past){\n\tint mask = 0;\n\trep(i, edge[at].size()){\n\t\tint u = edge[at][i];\n\t\tif(u == past) continue;\n\t\tmask |= dfs(u, at);\n\t}\n\tfor(int i=0;i<=20;i++){\n\t\tif(mask & (1 << i)) continue;\n\t\tmask |= (1 << i);\n\t\tfor(int j=0;j<i;j++) if(mask & (1 << j)) mask ^= (1 << j);\n\t\tfx = max(fx, i);\n\t\tbreak;\n\t} return mask;\n}\n\nint main(){\n\tint x, y;\n\tscanf(\"%d\", &n);\n\trepn(i, n-1){\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tedge[x].pb(y);\n\t\tedge[y].pb(x);\n\t}\n\tdfs(1, 1);\n\tprintf(\"%d\\n\", fx);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n// cout << fixed << setprecision(20);\n\nint N;\nint a[110000], b[110000];\nvint G[110000];\nbool centroid[110000];\nint sos[110000];\nbool used[110][110000];\n\nvoid dfs(int v, int p,int dep) {\n    used[dep][v] = false;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || cur == p)continue;\n        dfs(cur, v, dep);\n    }\n}\n\nint size_of_subtree(int v, int p,int dep) {\n    int ret = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        int cur = G[v][i];\n        if (centroid[cur] || used[dep][cur] || cur == p)continue;\n        ret += size_of_subtree(cur, v, dep);\n    }\n    return sos[v] = ret;\n}\n\nint search_centroid(int v, int t,int dep) {\n    if (used[dep][v])return -1;\n    int p = -1;\n    while (true) {\n        int ch, s = 0;\n        for (int i = 0; i < G[v].size(); i++) {\n            int cur = G[v][i];\n            if (centroid[cur] || used[dep][cur] || cur == p)continue;\n            if (s <= sos[cur])s = sos[cur], ch = cur;\n        }\n        if (s <= t / 2)break;\n        p = v;\n        v = ch;\n    }\n    return v;\n}\n\nint u(int v, int dep) {\n    dfs(v, -1, dep);\n    int ret = LLONG_MAX;\n    while (true) {\n        size_of_subtree(v, -1, dep);\n        int cidx = search_centroid(v, sos[v], dep);\n        if (cidx == -1)return ret;\n        centroid[cidx] = true;\n        used[dep][cidx] = true;\n        int prev=v;\n        int mu = -1;\n        for (int i = 0; i < G[cidx].size(); i++) {\n            if (centroid[G[cidx][i]])continue;\n            int cu = u(G[cidx][i], dep + 1);\n\n            if (mu <= cu)mu = cu, v = G[cidx][i];\n        }\n        ret = min(ret, mu + 1);\n        centroid[cidx] = false;\n        if(prev==v)return ret;\n    }\n}\n\nsigned main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++)cin >> a[i] >> b[i], a[i]--, b[i]--, G[a[i]].push_back(b[i]), G[b[i]].push_back(a[i]);\n    cout << u(0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=200100,P=1e9+7;\ninline char gc(){\n    static char buf[N],*s=buf,*t=buf;\n    return s==t&&(t=(s=buf)+fread(buf,1,N,stdin),s==t)?EOF:*s++;\n}\ninline ll read(){\n\tll x=0,f=0,c=getchar();\n\tfor(;c>'9'||c<'0';f=c=='-',c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())\n\tx=(x<<1)+(x<<3)+c-'0';return f?-x:x;\n}\ninline void write(ll x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);putchar(x%10+'0');\n}\nint n,L,h[N],ne[N],to[N],f[N],g[N],ans;\ninline void addl(int x,int y){\n\tne[++L]=h[x];h[x]=L;to[L]=y;\n\tne[++L]=h[y];h[y]=L;to[L]=x;\n}\nvoid dfs(int x,int fa){\n\tint k,fk=0;\n\tfor(k=h[x];k;k=ne[k])\n\tif(to[k]!=fa){\n\t\tdfs(to[k],x);\n\t\tfk|=g[x]&g[to[k]];\n\t\tg[x]|=g[to[k]];\n\t}f[x]=0;\n\twhile((1<<f[x])<=fk||((g[x]>>f[x])&1))f[x]++;\n\tg[x]=(g[x]>>f[x]<<f[x])|(1<<f[x]);\n\tans=max(ans,f[x]);\n}\nint main(){\n\t//freopen(\"1.out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<n;i++)addl(read(),read());\n\tdfs(1,0);printf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nconst int MAXN = 100 * 1000 + 23, MXLN = 17 + 3;\n\n\n\n\n\n\n\n\n\n\n\nint n, mx, dp[MAXN], cnt[MAXN][MXLN];\nvector<int> g[MAXN];\n\n\nvoid dfs(int v = 0, int p = -1) {\n\tfor (auto u : g[v]) if (u != p) {\n\t\tdfs(u, v);\n\t\tdp[v] |= dp[u];\n\t\tfor (int i = 0; i < MXLN; i++) cnt[v][i] += ((dp[u] >> i) & 1);\n\t}\n//\t/*\n\tint b = -1, f = 1;\n\tfor (int i = 0; i < MXLN; i++) {\n\t\tif (cnt[v][i] > 1) {\n\t\t\tb = i;\n\t\t\tf = 1;\n\t\t}\n\t\tif (cnt[v][i]) b += f;\n\t\telse f = 0;\n\t}\n//\t*/\n//\tfor (int i = 0; i < MXLN; i++) if (cnt[v][i] > 1) b = i;\n\tdp[v] &= (((1 << MXLN) - 1) ^ ((1 << b) - 1));\n\tdp[v] |= (1 << b);\n\tmx = max(mx, b);\n}\n\n\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[--u].push_back(--v), g[v].push_back(u);\n\t}\n\tdfs();\n\tcout << mx;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nvector<vector<int> > g;\nvector<bool>p;\nvoid dfs(int id,int pre){\n    bool flag = 0;\n    for(auto x:g[id]){\n        if(x!=pre){\n            dfs(x,id);\n            if(!p[x]){\n                flag = 1;\n            }\n        }\n    }\n    p[id] = flag;\n}\nvector<int> c;\nvoid dfs2(int id,int pre){\n    int mx = 0;\n    for(auto x:g[id]){\n        if(x!=pre){\n            dfs2(x,id);\n            mx = max(mx,c[x]);\n        }\n    }\n    mx += p[id];\n    c[id] = mx;\n}\nint main(){\n    int n;\n    cin >> n;\n    g.resize(n);p.resize(n);\n    c.resize(n);\n    rep(i,n-1){\n        int a,b;\n        cin >> a >> b;\n        a--;b--;\n        g[a].PB(b);\n        g[b].PB(a);\n    }\n    dfs(0,-1);\n    dfs2(0,-1);\n    int mxid = 0;\n    int mx = 0;\n    rep(i,n){\n        if(mx<c[i]){\n            mx = c[i];\n            mxid = i;\n        }\n        c[i] = 0;\n    }\n    dfs2(mxid,-1);\n    rep(i,n){\n        mx = max(mx,c[i]);\n    }\n    // cerr << mx << endl;\n    cout << (mx+1)/2 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>\n \nconst int N = 1e5 + 7;\n \nvector <int> ad[N];\nint gone[N], n, mrk[N],\tsz[N];\n\nvoid dfs(int v, int p = 0) {\n\tsz[v] = 1;\n\tmrk[v] = 1;\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tdfs(u, v);\n\t\t\tsz[v] += sz[u];\n\t\t}\n\t}\n}\npair <int, int> get(int v, int p, int sall) {\n\tpair <int, int> res;\n\tres.first = v;\n\tres.second = sall - sz[v];\n\tfor (auto u: ad[v])\n\t   \tif (!gone[u] && u != p)\t\n\t\t\tres.second = max(res.second, sz[u]);\n\tfor (auto u: ad[v]) {\n\t\tif (u != p && !gone[u]) {\n\t\t\tpair <int, int> t = get(u, v, sall);\n\t\t\tif (t.second < res.second)\n\t\t\t\tres = t;\n\t\t}\n\t}\n\treturn res;\n}\npair <int, int> ffs(int v, int p) {\n\tpair <int, int> mx = {v, 1};\n\tfor (auto u: ad[v])\n\t\tif (u != p) {\n\t\t\tauto t = ffs(u, v);\n\t\t\tt.second++;\n\t\t\tif (t.second > mx.second)\n\t\t\t\tmx = t;\n\t\t}\n\treturn mx;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tad[v].push_back(u);\n\t\tad[u].push_back(v);\n\t}\n\tint res = 0;\n\twhile (1) {\n\t\tbool was = 0;\n\t\tmemset(sz, 0, sizeof sz);\n\t\tmemset(mrk, 0, sizeof mrk);\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tif (!gone[i] && !mrk[i]) {\n\t\t\t\twas = 1;\n\t\t\t\tdfs(i);\n\t\t\t\tint v = get(i, 0, sz[i]).first;\n\t\t\t\tgone[v] = 1;\n\t\t\t}\n\t\tif (!was)\n\t\t\tbreak;\n\t\tres++;\n\t}\n\tint v = ffs(1, 0).first;\n\tint d = ffs(v, 0).second;\n\tint r2 = ((int)log2(d));\n\tcout << (r2 + res - 1) / 2;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n#include \"cmath\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tlong double a, b;\n\tcin >> a >> b;\n\tif (a < b) {\n\t\tswap(a, b);\n\t}\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong double c, d;\n\t\tcin >> c >> d;\n\t\tif (c < d) {\n\t\t\tswap(c, d);\n\t\t}\n\t\tbool flag = false;\n\t\tfor (long double j = 0; j < 3.1415926535/2; j += 0.0008) {\n\t\t\tlong double e = a*cos(j) + b*sin(j);\n\t\t\tlong double f = a*sin(j) + b*cos(j);\n\t\t\tif (e < c&&f < d) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) {\n\t\t\tcout << \"YES\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvector<int> edge[216000];\nInt cnt[216000][20];\nInt val[216000];\nInt n, u, v;\nvoid solve(Int x, Int last = -1){\n  for(Int to:edge[x]){\n    if(to == last)continue;\n    solve(to, x);\n    for(Int i = 0;i < 20;i++){\n      cnt[x][i] += cnt[to][i];\n    }\n  }\n  val[x] = 19;\n  while(val[x] > 0 && cnt[x][val[x]] <= 1)val[x]--;\n  while(cnt[x][val[x]] > 0)val[x]++;\n  for(int i = 0;i < 20;i++){\n    cnt[x][i] = !!cnt[x][i];\n    if(i < val[x])cnt[x][i] = 0;\n  }\n  cnt[x][val[x]] = 1;\n}\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n-1;i++){\n    cin >> u >> v;\n    edge[u].push_back(v);\n    edge[v].push_back(u);\t\t   \n  }\n  solve(1);\n  cout << *max_element(val, val + n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<vector<Int> > G(n);\n  for(Int i=1;i<n;i++){\n    Int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  Int ans=0;\n  while(G.size()!=1u){\n    ans++;\n    n=G.size();\n    if(0){\n      cout<<n<<endl;\n      for(Int v=0;v<n;v++)\n\tfor(Int u:G[v])\n\t  if(u<v) cout<<u<<\" \"<<v<<endl;\n    }\n    \n    vector<Int> cnt(n);\n    queue<Int> q;\n    for(Int i=0;i<n;i++){\n      cnt[i]=G[i].size();\n      if(cnt[i]==1) q.emplace(i);\n    }\n    \n    vector<Int> used(n,0);\n    vector<Int> belong(n,-1);\n    vector<vector<Int> > T;\n    \n    auto disable=[&](Int v){\n      //cout<<\"d1:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tcnt[u]--;\n\tif(cnt[u]==1) q.emplace(u);\n      }\n      used[v]=2;\n    };\n    \n    auto disable2=[&](Int v){\n      //cout<<\"d2:\"<<v<<endl;\n      for(Int u:G[v]){\n\tif(used[u]) continue;\n\tbelong[u]=T.size();\n\tT.emplace_back();\n        used[u]=2;\n\tfor(Int x:G[u]){\t  \n\t  if(used[x]) continue;\n\t  cnt[x]--;\n\t  if(cnt[x]==1) q.emplace(x);\n\t}\n      }\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      if(used[v]) continue;\n      //if(cnt[v]==0) continue;\n      //cout<<v<<endl;\n      Int t=T.size();\n      T.emplace_back();\n\n      Int c=-1;      \n      for(Int u:G[v])\n\tif(!used[u]) c=u;\n      //assert(cnt[v]==1);\n      //assert(~c);\n      //cout<<v<<\":\"<<c<<endl;\n      if(c<0) continue;\n      \n      disable(c);\n      used[c]=3;\n      belong[c]=t;\n      for(Int u:G[c]){\n\t//cout<<c<<\"->\"<<u<<endl;\n\tif(used[u]) continue;\n\t\n\tif(cnt[u]>1){\n\t  disable(u);\n\t  belong[u]=T.size();\n\t  T.emplace_back();\n\t  continue;\n\t}\n\t\n\tbelong[u]=t;\n\tused[u]=1;\n\tdisable2(u);\n      }\n    }\n    \n    //for(Int i=0;i<n;i++) cout<<i<<\":\"<<used[i]<<\" \"<<belong[i]<<endl;\n\n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n\tif(belong[v]!=belong[u])\n\t  T[belong[v]].emplace_back(belong[u]);\n    \n    for(auto &v:T){\n      sort(v.begin(),v.end());\n      v.erase(unique(v.begin(),v.end()),v.end());\n    }\n    G=T;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<map>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define NMAX 100005\n#define LMAX 21\n\nint answer, n, mask[NMAX], viz[NMAX];\nvector<int> tree[NMAX];\n\nint addMex(int bitMask){\n    for(int i = 0; i < LMAX; i++){\n        if(bitMask & (1 << i))\n            bitMask -= (1 << i);\n        else{\n            bitMask += (1 << i);\n            answer = max(answer, i);\n            return bitMask;\n        }\n    }\n    return bitMask;\n}\n\nvoid dfs(int node){\n    viz[node] = 1;\n    int lim = tree[node].size();\n    for(int i = 0; i < lim; i++){\n        int neigh = tree[node][i];\n        if(!viz[neigh]){\n            dfs(neigh);\n            mask[node] |= mask[neigh];\n        }\n    }\n    mask[node] = addMex(mask[node]);\n}\n\nint main (){\n    int a, b;\n    \n    scanf(\"%d\",&n);\n    for(int i = 1; i < n; i++){\n        scanf(\"%d%d\",&a,&b);\n        tree[a].push_back(b);\n        tree[b].push_back(a);\n    }\n        \n    dfs(1);\n    \n    printf(\"%d\\n\", answer);\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <complex>\n#include <cstring>\n \nusing namespace std;\n \nconst int N = 100000 + 5;\n \nint n;\nvector<int> adj[N];\nset<int> s[N];\n \nset<int>& dfs(int u, int f)\n{\n    set<int> &have = s[u];\n    int a = -1;\n \n    for(auto v: adj[u]) {\n        if (v == f) continue;\n        set<int> &f = dfs(v, u);\n        if (have.size() < f.size()) {\n            have.swap(f);\n        }\n        for(auto e: f) {\n            if (have.count(e)) {\n                a = max(a, e);\n            } else {\n                have.insert(e);\n            }\n        }\n    }\n \n    int b = a + 1;\n    for( ; have.count(b); b++);\n//    for( ; have.size() && *have.begin() <= b; have.erase(have.begin()));\n    have.insert(b);\n    return s[u];\n}\n \nvoid solve()\n{\n    cin >> n;\n    for(int i = 0; i < n - 1; ++ i) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    set<int> ret = dfs(0, -1);\n    int ans = *ret.rbegin();\n    cout << ans << endl;\n}\n \nint main()\n{\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int N = 1e5 + 100, inF = N;\n\nint n, u, v, ans = inF, down[N], up[N];\nbool mark[N];\nvector<int> nei[N];\n\nvoid find_down(int v, vector<int> *vec, int par = -1) {\n\t(*vec).push_back(v);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tfind_down(u, vec, v);\n\t\t\tdown[v] = max(down[v], down[u] + 1);\n\t\t}\n}\n\nvoid find_up(int v, int par = -1) {\n\tpii mx1 = pii(up[v] + 1, v), mx2 = pii(-inF, -inF);\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tmx2 = max(mx2, pii(down[u] + 2, u));\n\t\t\tif(mx2 > mx1)\n\t\t\t\tswap(mx2, mx1);\n\t\t}\n\tfor (int u: nei[v])\n\t\tif(u != par && mark[u] == false) {\n\t\t\tif(u != mx1.second)\n\t\t\t\tup[u] = mx1.first;\n\t\t\telse\n\t\t\t\tup[u] = mx2.first;\n\t\t\tfind_up(u, v);\n\t\t}\n}\n\nint solve(int v) {\n\tvector<int> vec;\n\tfind_down(v, &vec);\n\tfind_up(v);\n\tint mini = inF, cen = v;\n\tfor (int u: vec)\n\t\tif(max(up[u], down[u]) < mini) {\n\t\t\tmini = max(up[u], down[u]);\n\t\t\tcen = u;\n\t\t}\n\tfor (int u: vec)\n\t\tup[u] = down[u] = 0;\n\tmark[cen] = true;\n\tint maxi = -1;\n\tfor (int u: nei[cen])\n\t\tif(mark[u] == false)\n\t\t\tmaxi = max(maxi, solve(u));\n\treturn maxi + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcin >> u >> v;\n\t\tnei[--u].push_back(--v);\n\t\tnei[v].push_back(u);\n\t}\n\tcout << solve(0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100, lg = 20;\nvector<int> to[maxn];\nint solve(int u, int p){\n\tvector<int> cnt(lg, 0);\n\tfor(int v : to[u]){\n\t\tif(v == p) continue;\n\t\tint msk = solve(v, u);\n\t\tfor(int j = 0; j < lg; j++) if((msk>>j)&1) cnt[j]++;\n\t}\n\tint b = lg - 1;\n\twhile(b >= 0 && cnt[b] <= 1) b--;\n\tint c = b + 1;\n\twhile(cnt[c] == 1) c++;\n\tint msk = 1<<c;\n\tfor(int j = c+1; j < lg; j++) msk |= cnt[j]<<j;\n\treturn msk;\n}\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint u, v; cin >> u >> v;\n\t\tto[u].push_back(v);\n\t\tto[v].push_back(u);\n\t}\n\tint msk = solve(1, 0);\n\tint b = 0;\n\twhile(msk>>b) b++;\n\tcout << b - 1 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\n#define RF(x) freopen(x,\"r\",stdin)\n#define WF(x) freopen(x,\"w\",stdout)\ntypedef long long LL;\nusing namespace std;\ntypedef pair<LL,LL> PLL;\ntypedef pair<int,int> PII;\nconst LL MOD = 1e9+7;\nconst int SIZE = 1e6+5;\nconst LL INF = 1LL<<62;\nconst double eps = 1e-4;\nconst double PI=3.1415926535897932;\n\nvector<int> adj[100009];\nint dist[100009];\n\nvoid dfs(int x,int p){\n\tfor(int i:adj[x]){\n\t\tif(i==p)continue;\n\t\tdist[i]=dist[x]+1;\n\t\tdfs(i,x);\n\t}\n}\n\nint main(){\n\tDRI(n);\n\tREP(i,n-1){\n\t\tDRII(a,b);a--;b--;\n\t\tadj[a].PB(b);adj[b].PB(a);\n\t}\n\tdfs(0,-1);\n\tint cmax=0;\n\tREP(i,n){\n\t\tif(dist[i]>dist[cmax])cmax=i;\n\t}\n\tMS0(dist);\n\tdfs(cmax,-1);\n\tcmax=0;\n\tREP(i,n){\n\t\tcmax=max(cmax,dist[i]);\n\t}\n\t//printf(\"%d\",cmax);\n\tcmax++;int ans=0;\n\twhile(cmax>1){\n\t\tans++;cmax/=2;\n\t}\n\tprintf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int mask = 0xAAAA;\nint n, ans;\nvector<vi> e;\nint rec(int c, int p){\n\tint s = 0, t = 0;\n\tfor(int i : e[c]) if(i != p){\n\t\tint x = rec(i, c);\n\t\ts |= x;\n\t\tt += x;\n\t\tt &= ~((t & mask) >> 1);\n\t}\n\tt &= mask;\n\tint l = t ? 32 - __builtin_clz(t) : 0;\n\tl = __builtin_ctz((s | (s & ~mask) << 1 | (1 << l) - 1) + 1);\n\tans = max(ans, l / 2);\n\treturn (s | 1 << l) & ~((1 << l) - 1);\n}\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tcin >> n;\n\te.resize(n);\n\trep(i, n - 1){\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\te[a].pb(b);\n\t\te[b].pb(a);\n\t}\n\trec(0, 0);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic vector<int> e[2][100000];\n\nint recon(int i,int p,bool b,int &N)\n{\n  //printf(\"%d %d %d\\n\",i,p,N);\n  int t=N;\n  e[!b][t]=vector<int>(0);\n  N++;\n  for(int x=0;x<e[b][i].size();x++){\n    int j=e[b][i][x];\n    if(j==p)continue;\n    if(e[b][j].size()==2){\n      int k=(e[b][j][0]==i?e[b][j][1]:e[b][j][0]);\n      int c=recon(k,j,b,N);\n      e[!b][t].push_back(c);\n      e[!b][c].push_back(t);\n    }\n    else if(e[b][j].size()>2){\n      int c=recon(j,i,b,N);\n      e[!b][t].push_back(c);\n      e[!b][c].push_back(t);\n    }\n  }\n  return t;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  bool b=0;\n  for(int i=0;i<n-1;i++){\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    u--,v--;\n    e[b][u].push_back(v);\n    e[b][v].push_back(u);\n  }\n  int N=n,t=0;\n  while(N>1){\n    //printf(\"%d\\n\",N);\n    t++;\n    int r;\n    for(int i=0;i<N;i++){\n      if(e[b][i].size()==1){\n\tr=e[b][i][0];\n\tbreak;\n      }\n    }\n    N=0;\n    recon(r,-1,b,N);\n    b=!b;\n  }\n  printf(\"%d\\n\",t);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 2000;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tsrand(clock());\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t}\n\t\n\tcout << ANS << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e5+5;\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N<<1];\nint tot, head[N];\nvoid _add(int x, int y) { edge[++tot] = Edge(head[x], y), head[x] = tot; }\nvoid add(int x, int y) { _add(x, y), _add(y, x); }\nint n, f[N], ans;\nvoid dfs(int x, int fa)\n{\n    int s = 0, d = 20;\n    for(int i = head[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to; if(y == fa) continue;\n        dfs(y, x), s |= f[x]&f[y], f[x] |= f[y];\n    }\n    while(~d&&~s>>d&1) --d; ++d; while(f[x]>>d&1) ++d;\n    f[x] = (f[x]>>d|1)<<d, ans = max(ans, d);\n}\nint main()\n{\n    n = read();\n    for(int i = 1, x, y; i < n; ++i) x = read(), y = read(), add(x, y);\n    dfs(1, 0), printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nint n,fst[N],to[N*2],nxt[N*2],l,fa[N],b[N],Ans;\nvoid link(int x,int y)\n{\n\tto[++l]=y;nxt[l]=fst[x];fst[x]=l;\n\tto[++l]=x;nxt[l]=fst[y];fst[y]=l;\n}\nvoid dfs(int x)\n{\n\tint tmp=0,s=0;\n\tfor (int i=fst[x];i;i=nxt[i])\n\tif (to[i]!=fa[x])\n\t{\n\t\tfa[to[i]]=x;\n\t\tdfs(to[i]);\n\t\ts|=tmp&b[to[i]];\n\t\ttmp|=b[to[i]];\n\t}\n\tint t=0;\n\twhile(((1<<t<s))||((1<<t)&tmp))t++;\n\t//cout<<t<<endl;\n\tb[x]=tmp^(1<<t)^(tmp&((1<<t)-1));\n\tAns=max(Ans,t);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlink(x,y);\n\t}\n\tdfs(1);\n\t/*int ans=0;\n\twhile(Ans>1)Ans>>=1,ans++;*/\n\tprintf(\"%d\\n\",Ans);\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n;\nvector<int> G[100010];\nint dp[100010];\nint s[100010];\nvoid dfs(int v,int p){\n\ts[v] = 0;\n\tdp[v] = 0;\n\tfor(int u: G[v]){\n\t\tif(p == u)continue;\n\t\tdfs(u,v);\n\t\tint t = s[v]&s[u];\n\t\trep(i,20){\n\t\t\tif((t>>i)&1){\n\t\t\t\tdp[v] = max( dp[v] , i+1 );\n\t\t\t}\n\t\t}\n\t\ts[v] = (s[v]|s[u])^t;\n\t}\n\twhile((s[v]>>dp[v])&1){\n\t\ts[v] -= 1<<dp[v];\n\t\tdp[v] ++;\n\t}\n\ts[v] += 1<<dp[v];\n\t//cout << v << \" \" << dp[v] << \" \" << s[v] << endl;\n}\n\nint main(){\n\tint n;\n\tint a[100010],b[100010];\n\tscanf(\"%d\",&n);\n\trep1(i,n-1){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG[a[i]].pb(b[i]);\n\t\tG[b[i]].pb(a[i]);\n\t}\n\tif(n <= 2){\n\t\tcout << n-1 << endl;\n\t\treturn 0;\n\t}\n\tint root = 1;\n\trep1(i,n){\n\t\tif(G[i].size() >= 2){\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(root,0);\n\t\n\tint ret = 0;\n\trep1(i,n)ret = max( ret , dp[i] );\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint n;\nvector<int> G[100010];\nint dp[100010];\nint s[100010];\nvoid dfs(int v,int p){\n\ts[v] = 0;\n\tdp[v] = 0;\n\tfor(int u: G[v]){\n\t\tif(p == u)continue;\n\t\tdfs(u,v);\n\t\tint t = s[v]&s[u];\n\t\trep(i,20){\n\t\t\tif((t>>i)&1){\n\t\t\t\tdp[v] = max( dp[v] , i+1 );\n\t\t\t}\n\t\t}\n\t\ts[v] |= s[u];\n\t}\n\twhile((s[v]>>dp[v])&1){\n\t\ts[v] -= 1<<dp[v];\n\t\tdp[v] ++;\n\t}\n\ts[v] &= (-1)^((1<<dp[v])-1);\n\ts[v] += 1<<dp[v];\n\t//cout << v << \" \" << dp[v] << \" \" << s[v] << endl;\n}\n\nint main(){\n\tint n;\n\tint a[100010],b[100010];\n\tscanf(\"%d\",&n);\n\trep1(i,n-1){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tG[a[i]].pb(b[i]);\n\t\tG[b[i]].pb(a[i]);\n\t}\n\tif(n <= 2){\n\t\tcout << n-1 << endl;\n\t\treturn 0;\n\t}\n\tint root = 1;\n\trep1(i,n){\n\t\tif(G[i].size() >= 2){\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(root,0);\n\t\n\tint ret = 0;\n\trep1(i,n)ret = max( ret , dp[i] );\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\nconst int N=100005;\nint v[N*2],nxt[N*2],point[N],bs=0;\nint vis[N],dep[N];\nvoid addedge(int x,int y)\n{\n    bs++;v[bs]=y;nxt[bs]=point[x];point[x]=bs;\n    bs++;v[bs]=x;nxt[bs]=point[y];point[y]=bs;\n}\nvoid dfs(int x)\n{\n    vis[x]=1;\n    for (int p=point[x];p;p=nxt[p])\n     if (!vis[v[p]])\n     {\n          dep[v[p]]=dep[x]+1;dfs(v[p]);\n     }\n}\nint getD(int n)\n{\n    int i,x;\n    memset(vis,0,sizeof(vis));\n    dep[1]=1;dfs(1);\n    for (i=1,x=1;i<=n;i++) if (dep[i]>dep[x]) x=i;\n    memset(vis,0,sizeof(vis));\n    dep[x]=1;dfs(x);\n    for (i=1;i<=n;i++) if (dep[i]>dep[x]) x=i;\n    return dep[x];\n}\nint main(int x)\n{\n   // freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n    int i,n;\n    scanf(\"%d\",&n);\n    for (i=2;i<=n;i++) {int x,y;scanf(\"%d%d\",&x,&y);addedge(x,y);}\n    int D=getD(n);\n    for (i=0;(1<<i)<=D;i++);\n    printf(\"%d\\n\",i-1);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\n\nint n;\nvector <int> neigh[Maxn];\n\nii Get(int v, int p)\n{\n    ii res = ii(1, v);\n    for (int i = 0; i < neigh[v].size(); i++) {\n        int u = neigh[v][i];\n        if (u == p) continue;\n        ii g = Get(u, v);\n        res = max(res, ii(g.first + 1, g.second));\n    }\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        neigh[a].push_back(b);\n        neigh[b].push_back(a);\n    }\n    ii g = Get(1, 0);\n    g = Get(g.second, 0);\n    int lim = 1, pnt = 0;\n    while (lim < g.first) {\n        lim = 2 * lim + 1;\n        pnt++;\n    }\n    printf(\"%d\\n\", pnt);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nvector<int> graph[101010];\nint ids[101010];\n\nvoid remove_leaves()\n{\n\tvector<pair<int, int> > rem;\n\tfor (int i = 0; i < N; ++i) {\n\t\tids[i] = -1;\n\t\tfor (int j : graph[i]) {\n\t\t\tif (i < j && graph[i].size() > 1 && graph[j].size() > 1) {\n\t\t\t\trem.push_back({ i, j });\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) graph[i].clear();\n\n\tint idx = 0;\n\tfor (auto e : rem) {\n\t\tint u = e.first, v = e.second;\n\t\tif (ids[u] == -1) {\n\t\t\tids[u] = idx++;\n\t\t}\n\t\tif (ids[v] == -1) {\n\t\t\tids[v] = idx++;\n\t\t}\n\t\tgraph[ids[u]].push_back(ids[v]);\n\t\tgraph[ids[v]].push_back(ids[u]);\n\t}\n\tN = idx;\n}\nvoid visit(int p, int rt, int vrt, int el, int &idx, vector<pair<int, int> > &edges)\n{\n\tif (graph[p].size() == 2) {\n\t\tvisit(graph[p][0] + graph[p][1] - rt, p, vrt, el + 1, idx, edges);\n\t\treturn;\n\t}\n\tint my = idx++;\n\tvector<int> bridge;\n\tbridge.push_back(my);\n\tfor (int i = 0; i < el / 2 - 1; ++i) {\n\t\tbridge.push_back(idx++);\n\t}\n\tbridge.push_back(vrt);\n\tfor (int i = 0; i < bridge.size() - 1; ++i) {\n\t\tedges.push_back({ bridge[i], bridge[i + 1] });\n\t}\n\tfor (int q : graph[p]) if (q != rt) {\n\t\tvisit(q, p, my, 1, idx, edges);\n\t}\n}\nvoid contract()\n{\n\tint idx = 0;\n\tvector<pair<int, int> > edges;\n\tfor (int i = 0; i < N; ++i) if (graph[i].size() != 2) {\n\t\tvisit(i, -1, -1, 0, idx, edges);\n\t\tbreak;\n\t}\n\tfor (int i = 0; i < N; ++i) graph[i].clear();\n\tfor (auto e : edges) {\n\t\tint u = e.first, v = e.second;\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\tN = idx;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tint ans = 0;\n\twhile (N > 1) {\n\t\tans += 1;\n\n\t\tremove_leaves();\n\t\tcontract();\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nstd::vector<int> adj[100005];\nint app[100005][25];\nint dfs(int u, int fa = -1)\n{\n\tint ans = 0;\n\tfor (int v : adj[u])\n\t{\n\t\tif (v == fa)\n\t\t\tcontinue;\n\t\tans = std::max(ans, dfs(v, u));\n\t\tfor (int j = 0; j < 20; j++)\n\t\t\tapp[u][j] += app[v][j];\n\t}\n\tint res = 0;\n\tfor (int i = 19; i >= 0; i--)\n\t{\n\t\tif (app[u][i] > 1)\n\t\t{\n\t\t\tres = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (app[u][res])\n\t\tres++;\n\tfor (int j = 0; j < res; j++)\n\t\tapp[u][j] = 0;\n\tapp[u][res] = 1;\n\treturn std::max(ans, res);\n}\nint main()\n{\n\t// freopen(\"AGC009-D.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadj[--u].pb(--v);\n\t\tadj[v].pb(u);\n\t}\n\tprintf(\"%d\\n\", dfs(0));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct node { int t,next; }a[200010];\n\nint head[100010],bit[100010],f[100010],n,ans,tot;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void add(int x,int y) { a[++tot].t=y;a[tot].next=head[x];head[x]=tot; }\n\ninline void dfs(int x,int y)\n{\n\tbit[x]=f[x]=0;\n\tint hh=0;\n\tfor (int i=head[x];i;i=a[i].next)\n\t{\n\t\tint t=a[i].t;\n\t\tif (t==y) continue;\n\t\tdfs(t,x);\n\t\thh|=(bit[x]&bit[t]);\n\t\tbit[x]|=bit[t];\n\t}\n\tif (!bit[x]) bit[x]=1;\n\telse\n\t{\n\t\twhile ((1<<f[x])<hh||((1<<f[x])&bit[x])) f[x]++;\n\t\tbit[x]=(bit[x]>>f[x]<<f[x])|(1<<f[x]);\n\t}\n\tans=max(ans,f[x]);\n}\n\nint main()\n{\n\tn=rd();tot=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=rd(),y=rd();\n\t\tadd(x,y);add(y,x);\n\t}\n\tans=0;dfs(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n;\nvector<llint> G[100005];\n\nllint dfs(int v, int p)\n{\n\tllint sum = 0, sum2 = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tllint res = dfs(G[v][i], v);\n\t\tsum2 |= sum & res;\n\t\tsum |= res;\n\t}\n\t\n\tllint pos = -1;\n\tfor(int i = 20; i >= 0; i--){\n\t\tif(sum2 & (1<<i)){\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpos++;\n\t\n\tfor(int i = pos; i <= 20; i++){\n\t\tif((sum & (1<<i)) == 0){\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsum >>= pos, sum <<= pos;\n\tsum |= 1<<pos;\n\t\n\treturn sum;\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tllint u, v;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tllint res = dfs(1, -1);\n\t\n\tllint ans = 0;\n\tfor(;res;res>>=1) ans++;\n\tcout << ans-1 << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nset<int> S[MAX_N];\nvector<int> G[MAX_N];\nint cnt[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t\tcnt[a]++;\n\t\tcnt[b]++;\n\t}\n\tqueue<int> que;\n\trep(i, 0, N) {\n\t\tif(cnt[i] == 1) que.push(i);\n\t}\n\tint ans = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tint at = 0;\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] != 0) continue;\n\t\t\tif(sz(S[n]) > sz(S[v])) swap(S[n], S[v]);\n\t\t\tfor(auto d : S[n]) {\n\t\t\t\tif(S[v].count(d)) {\n\t\t\t\t\twhile((*(S[v].begin())) < d) S[v].erase(S[v].begin());\n\t\t\t\t\tat = d;\n\t\t\t\t}\n\t\t\t\telse if(d >= at) S[v].insert(d);\n\t\t\t}\n\t\t}\n\t\twhile(!S[v].empty() && (*(S[v].begin())) == at) {\n\t\t\tS[v].erase(S[v].begin());\n\t\t\tat++;\n\t\t}\n\t\tS[v].insert(at);\n\t\tMAX(ans, at);\n\n\t\t// debug(v, vi(all(S[v])));\n\n\t\trep(i, 0, sz(G[v])) {\n\t\t\tint n = G[v][i];\n\t\t\tif(cnt[n] == 0) continue;\n\t\t\tcnt[n]--;\n\t\t\tcnt[v]--;\n\t\t\tif(cnt[n] == 1) que.push(n);\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> pip;\n\nstruct HASH {\n\tsize_t operator() (const pair<int,int> &x) const {\n\t\treturn hash <long long> () (((long long)x.first) ^ (((long long)x.second) << 32));\n\t}\n};\n\nconst int MAX_N = 1e5 + 5;\nint n, cnt, ans, S, ANS = 1e9 + 7, T = 500;\nbool Mark[MAX_N];\nbool del[MAX_N];\nint d[MAX_N];\nint down[MAX_N];\nint up[MAX_N];\nunordered_map <pii, int, HASH> Map;\n\nvector <pii> G[MAX_N];\n\nvoid dfs1 (int v,  int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p) {\n\t\t\tdfs1(G[v][i].first, v);\n\t\t\tdown[v] += 1 + down[G[v][i].first];\n\t\t}\n}\n\nvoid dfs2 (int v, int p, int u) {\n\tMark[v] = true;\n\tup[v] = u;\n\t\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p)\n\t\t\tdfs2(G[v][i].first, v, u + down[v] - down[G[v][i].first]);\n}\n\nvoid findS (int v, int p) {\n\tfor (int i = 0; i < G[v].size(); i++)\n\t\tif (G[v][i].second && G[v][i].first != p && (up[G[v][i].first] < 1 + down[G[v][i].first] || (up[G[v][i].first] == 1 + down[G[v][i].first] && rand() % 2))) {\n\t\t\tfindS(G[v][i].first, v);\n\t\t\treturn ;\n\t\t}\n\t\n\tS = v;\n}\n\nint main() {\n\tsrand(clock());\n\tcin >> n;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\td[v]++;\n\t\td[u]++;\n\t\t\n\t\tMap[{v, u}] = G[u].size();\n\t\tMap[{u, v}] = G[v].size();\n\t\tG[v].push_back({u, 1});\n\t\tG[u].push_back({v, 1});\n\t}\n\t\n\tfor (int Q = 0; Q < T; Q++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\td[i] = G[i].size();\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tG[i][j].second = true;\n\t\t}\n\t\t\t\t\n\t\twhile (true) {\n\t\t\tans++;\n\t\t\tmemset(Mark, 0, sizeof Mark);\n\t\t\tmemset(down, 0, sizeof down);\n\t\t\tmemset(up, 0, sizeof up);\n\t\t\tbool change = false;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!del[i] && !Mark[i]) {\n\t\t\t\t\tchange = true;\n\t\t\t\t\t\n\t\t\t\t\tdfs1(i, i);\n\t\t\t\t\tdfs2(i, i, 0);\n\t\t\t\t\tfindS(i, i);\n\t\t\t\t\tdel[S] = true;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < G[S].size(); j++)\n\t\t\t\t\t\tif (G[S][j].second) {\n\t\t\t\t\t\t\tint v = G[S][j].first;\n\t\t\t\t\t\t\tint ind = Map[{S, v}];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\td[v]--;\n\t\t\t\t\t\t\tG[v][ind].second = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif (!d[i])\n\t\t\t\t\tdel[i] = true;\n\t\t\t\t\t\n\t\t\tif (!change)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tANS = min(ANS, ans - 1);\n\t}\n\t\n\tcout << ANS << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int K=20;\nconst int N=1e6;\nint n,head[N+10],tot=0;\nstruct data {\n    int next,num;\n}edge[N+10];\nvoid Add(int u,int v) {\n    edge[++tot].next=head[u];\n    edge[tot].num=v;\n    head[u]=tot;\n}\nint dfs(int x,int fat) {\n    int nowx=0,maxbit=-1;\n    for (int i=head[x];i!=-1;i=edge[i].next) {\n        int kx=edge[i].num;\n        if (kx==fat) continue;\n        int nowv=dfs(kx,x);\n        for (int j=0;j<=K;j++)\n            if ((nowv&(1<<j))&&(nowx&(1<<j)))\n                maxbit=max(maxbit,j);\n        nowx|=nowv;\n    }\n    for (int j=maxbit+1;j<=K;j++)\n        if ((nowx&(1<<j))==0) {\n            nowx|=(1<<j);\n            return nowx;\n        }\n        else nowx^=(1<<j);\n    return 233;\n}\nint main() {\n    memset(head,-1,sizeof(head));\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++) {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        Add(u,v);\n        Add(v,u);\n    }\n    int ans=dfs(1,-1);\n    for (int i=K;i>=0;i--)\n        if (ans&(1<<i)) {\n            printf(\"%d\\n\",i);\n            return 0;\n        }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vi::iterator vit;\ntypedef vi::reverse_iterator vrit;\n#define pb push_back\n\nconst int MX=100005;\nvi G[MX];\nint n;\nint dp(int k,int f){\n\tint v=0,v2=0;\n\tfor(auto i:G[k])if(i!=f){\n\t\tint r=dp(i,k);\n\t\tv2|=(r&v),v|=r;\n\t}\n\tint it=0;while((1<<it)<=v2)it++;\n\twhile((v>>it)&1)it++;\n\treturn (v|(1<<it))&(~((1<<it)-1));\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;cin>>a>>b;\n\t\tG[a].pb(b),G[b].pb(a);\n\t}\n\tcout<<31-__builtin_clz(dp(1,0))<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst int MAXN = 120000;\nconst int LOG = 20;\n\nint was[MAXN];\nvector<int> eds[MAXN];\nint n;\nset<tuple<int, int, int> > ss;\nint dp[MAXN][LOG];\n\nvector<int> get() {\n\tvector<int> ans;\n\tif (ss.empty()) {\n\t\tans.push_back(0);\n\t\treturn ans;\n\t}\n\tif (ss.size() >= 2) {\n\t\tauto it = ss.end();\n\t\t--it;\n\t\tauto it2 = prev(it);\n\t\tif (get<0>(*it) == get<0>(*it2)) {\n\t\t\tans.push_back(get<0>(*it) + 1);\n\t\t\treturn ans;\n\t\t}\n\t}\n\tint k, x, y;\n\ttie(k, x, y) = *ss.rbegin();\n\tss.erase(make_tuple(k, x, y));\n\t++y;\n\tif (dp[x][y] != -1)\n\t\tss.insert(make_tuple(dp[x][y], x, y));\n\tans = get();\n\tif (ans.back() < k) {\n\t\tans.push_back(k);\n\t\treturn ans;\n\t}\n\telse {\n\t\tans.clear();\n\t\tans.push_back(k + 1);\n\t\treturn ans;\n\t}\n}\n\nvoid dfs1(int v) {\n\twas[v] = 1;\n\tvector<int> vv;\n\tfor (int u: eds[v]) {\n\t\tif (was[u])\n\t\t\tcontinue;\n\t\tvv.push_back(u);\n\t\tdfs1(u);\n\t}\n\tif (vv.empty()) {\n\t\tdp[v][0] = 0;\n\t\tfor (int i = 1; i < LOG; ++i)\n\t\t\tdp[v][i] = -1;\n\t\treturn;\n\t}\n\tss.clear();\n\tfor (int i: vv)\n\t\tss.insert(make_tuple(dp[i][0], i, 0));\n\tvector<int> tmp = get();\n\treverse(tmp.begin(), tmp.end());\n\tfor (int i = 0; i < tmp.size(); ++i)\n\t\tdp[v][i] = tmp[i];\n\tfor (int i = tmp.size(); i < LOG; ++i)\n\t\tdp[v][i] = -1;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a, --b;\n\t\teds[a].push_back(b);\n\t\teds[b].push_back(a);\n\t}\n\tdfs1(0);\n\tcout << dp[0][0] << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=1e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\nint f[N],n,res;\nvoid dfs(int u,int fa){\n\tR int s=0;\n\tgo(u)if(v!=fa)dfs(v,u),s|=(f[u]&f[v]),f[u]|=f[v];\n\tif(!f[u])return f[u]=1,void();\n\tR int c=0;\n\twhile((1<<c)<=s||(f[u]>>c&1))++c;\n\tf[u]=((f[u]>>c|1)<<c),cmax(res,c);\n//\tprintf(\"%d %d %d\\n\",u,f[u],c);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(R int i=1,u,v;i<n;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tdfs(1,0);\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200005;\nint tot,fi[N],ne[N],zz[N],sd[N],n,x,y;\nvoid jb(int x,int y){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n}\nvoid dfs(int x,int y,int z){\n\tsd[x]=z;\n\tfor (int i=fi[x];i;i=ne[i])\n\t\tif (zz[i]!=y)dfs(zz[i],x,z+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tif (n==1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tjb(x,y);jb(y,x);\n\t}\n\tdfs(1,0,1);int now=1;\n\tfor (int i=2;i<=n;i++)\n\t\tif (sd[i]>sd[now])now=i;\n\tdfs(now,0,1);now=0;\n\tfor (int i=1;i<=n;i++)now=max(now,sd[i]);\t\n\tint k=1,ans=0;\n\twhile (k<now){\n\t\tk=k*2+1;\n\t\tans++;\n\t}\n\tprintf(\"%d\\n\",ans);\n} "
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\null dp[N_MAX];\null dfs (ull v, ull p) {\n\tull x[25] = {0};\n\tfor (sll i = gin[v]; i < gin[v + 1]; i++) {\n\t\tull u = xy[i].b;\n\t\tif (u == p) continue;\n\n\t\tull y = dfs(u, v);\n\t\tfor (sll j = 0; j < 25; j++) {\n\t\t\tif (y & (1LL << j)) {\n\t\t\t\tx[j]++;\n\t\t\t}\n\t\t}\n\t}\n\tsll sup = -1;\n\tfor (sll i = 0; i < 25; i++) {\n\t\tif (x[i] > 1) sup = i;\n\t}\n\tfor (sll i = sup + 1; i < 25; i++) {\n\t\tif (!x[i]) {\n\t\t\tdp[v] = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tull ret = (1LL << dp[v]);\n\tfor (sll i = dp[v] + 1; i < 25; i++) {\n\t\tif (x[i]) ret ^= (1LL << i);\n\t}\n\treturn ret;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i < n - 1; i++) {\n\t\tc[a[i]]++;\n\t\tc[b[i]]++;\n\t\txy[i * 2] = (hwll){a[i], b[i]};\n\t\txy[i * 2 + 1] = (hwll){b[i], a[i]};\n\t}\n\tqsort(xy, (n - 1) * 2, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < (n - 1) * 2 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tull root = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (c[i] > root) root = i;\n\t}\n\n\tdfs(root, n);\n\tfor (i = 0; i < n; i++) {\n\t\tresult = smax(result, dp[i]);\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Hanako\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Jiro\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%llu\", &d[i]);\n\t// }\n\tfor (i = 0; i < n - 1; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \ta[i]--;\n\t// \tb[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    int[] from = new int[n-1];\n    int[] to = new int[n-1];\n    for (int i = 0; i < n - 1; i ++) {\n      from[i] = ni() - 1;\n      to[i] = ni() - 1;\n    }\n    int[][] g = packU(n, from, to);\n    \n    int ret = dfs(0, new boolean[n], g);\n    System.out.println(ret - 1);\n  }\n  \n  private static int dfs(int now, boolean[] ved, int[][] g) {\n\n    int[] dia = diameter(g, now, ved);\n    ved[dia[3]] = true;\n    int max = -1;\n    \n    for (int next : g[dia[3]]) {\n      if (ved[next]) continue;\n      max = Math.max(max, dfs(next, ved, g));\n    }\n    \n    return max + 1;\n  }\n  \n  public static int[][] packU(int n, int[] from, int[] to){ return packU(n, from, to, from.length); }\n  public static int[][] packU(int n, int[] from, int[] to, int sup)\n  {\n      int[][] g = new int[n][];\n      int[] p = new int[n];\n      for(int i = 0;i < sup;i++)p[from[i]]++;\n      for(int i = 0;i < sup;i++)p[to[i]]++;\n      for(int i = 0;i < n;i++)g[i] = new int[p[i]];\n      for(int i = 0;i < sup;i++){\n          g[from[i]][--p[from[i]]] = to[i];\n          g[to[i]][--p[to[i]]] = from[i];\n      }\n      return g;\n  }\n\n  \n  public static int[] diameter(int[][] g, int v, boolean[] sved)\n  {\n      int n = g.length;\n      int f0 = -1, f1 = -1, d01 = -1, c = -1;\n      int[] q = new int[n];\n      boolean[] ved = new boolean[n];\n      {\n          int qp = 0;\n          q[qp++] = v; ved[0] = true;\n          for(int i = 0;i < qp;i++){\n              int cur = q[i];\n              for(int e : g[cur]){\n                  if(!ved[e] && !sved[e]){\n                      ved[e] = true;\n                      q[qp++] = e;\n                      continue;\n                  }\n              }\n          }\n          f0 = q[qp-1];\n      }\n      {\n          int[] d = new int[n];\n          int qp = 0;\n          Arrays.fill(ved, false);\n\n          q[qp++] = f0; ved[f0] = true;\n          for(int i = 0;i < qp;i++){\n              int cur = q[i];\n              for(int e : g[cur]){\n                  if(!ved[e] && !sved[e]){\n                      ved[e] = true;\n                      q[qp++] = e;\n                      d[e] = d[cur] + 1;\n                      continue;\n                  }\n              }\n          }\n          f1 = q[qp-1];\n          c = q[qp / 2];\n          d01 = d[f1];\n      }\n      return new int[]{d01, f0, f1, c};\n  }\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tout.println(go(g));\n\t}\n\t\n\tstatic int go(int[][] g)\n\t{\n\t\tif(g.length == 1)return 0;\n\t\tint n= g.length;\n\t\tint[] cent = center(g);\n\t\tint[] map = new int[n];\n\t\tArrays.fill(map, -1);\n\t\tint[] lfrom = new int[n];\n\t\tint[] lto = new int[n];\n\t\tint max = 0;\n\t\tfor(int e : g[cent[0]]){\n\t\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\t\tq.add(e);\n\t\t\tint id = 0;\n\t\t\tmap[e] = id++;\n\t\t\tint u = 0;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint cur = q.poll();\n\t\t\t\tfor(int f : g[cur]){\n\t\t\t\t\tif(f != cent[0] && map[f] == -1){\n\t\t\t\t\t\tmap[f] = id++;\n\t\t\t\t\t\tlfrom[u] = map[cur]; lto[u] = map[f]; u++;\n\t\t\t\t\t\tq.add(f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] lg = packU(id, lfrom, lto, u);\n\t\t\tmax = Math.max(max, go(lg));\n\t\t}\n\t\treturn max + 1;\n\t}\n\t\n\tpublic static int[][] packU(int n, int[] from, int[] to){ return packU(n, from, to, from.length); }\n\tpublic static int[][] packU(int n, int[] from, int[] to, int sup)\n\t{\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor(int i = 0;i < sup;i++)p[from[i]]++;\n\t\tfor(int i = 0;i < sup;i++)p[to[i]]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new int[p[i]];\n\t\tfor(int i = 0;i < sup;i++){\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static int[] center(int[][] g)\n\t{\n\t\tint n = g.length;\n\t\tint start = 0;\n\t\tint[] d1 = dist(g, start);\n\t\tint maxd1 = -1;\n\t\tint argmaxd1 = -1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(d1[i] > maxd1){\n\t\t\t\tmaxd1 = d1[i];\n\t\t\t\targmaxd1 = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] d2 = dist(g, argmaxd1);\n\t\tint maxd2 = -1;\n\t\tint argmaxd2 = -1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(d2[i] > maxd2){\n\t\t\t\tmaxd2 = d2[i];\n\t\t\t\targmaxd2 = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(maxd2 % 2 == 0){\n\t\t\tint h = maxd2/2;\n\t\t\tint j = argmaxd2;\n\t\t\touter:\n\t\t\tfor(int i = maxd2;i > h;i--){\n\t\t\t\tfor(int e : g[j]){\n\t\t\t\t\tif(d2[e] == i-1){\n\t\t\t\t\t\tj = e;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t\treturn new int[]{j};\n\t\t}else{\n\t\t\tint h = maxd2/2;\n\t\t\tint j = argmaxd2;\n\t\t\tint[] cs = new int[2];\n\t\t\tint p = 0;\n\t\t\touter:\n\t\t\tfor(int i = maxd2;i >= h;i--){\n\t\t\t\tif(i <= h+1)cs[p++] = j;\n\t\t\t\tif(i > h){\n\t\t\t\t\tfor(int e : g[j]){\n\t\t\t\t\t\tif(d2[e] == i-1){\n\t\t\t\t\t\t\tj = e;\n\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cs;\n\t\t}\n\t}\n\t\n\tpublic static int[] dist(int[][] g, int start)\n\t{\n\t\tint n = g.length;\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, n+3);\n\t\tint[] q = new int[n];\n\t\tint p = 0;\n\t\tq[p++] = start;\n\t\td[start] = 0;\n\t\tfor(int r = 0;r < p;r++){\n\t\t\tint cur = q[r];\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(d[e] > d[cur] + 1){\n\t\t\t\t\td[e] = d[cur] + 1;\n\t\t\t\t\tq[p++] = e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\t\n\tpublic static int[][] parentToG(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint[] ct = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tct[i]++;\n\t\t\t\tct[par[i]]++;\n\t\t\t}\n\t\t}\n\t\tint[][] g = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tg[i] = new int[ct[i]];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tg[par[i]][--ct[par[i]]] = i;\n\t\t\t\tg[i][--ct[i]] = par[i];\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static int[] buildCentroidTree(int[][] g) {\n\t\tint n = g.length;\n\t\tint[] ctpar = new int[n];\n\t\tArrays.fill(ctpar, -1);\n\t\tbuildCentroidTree(g, 0, new boolean[n], new int[n], new int[n], new int[n], ctpar);\n\t\treturn ctpar;\n\t}\n\t\n\tprivate static int buildCentroidTree(int[][] g, int root, boolean[] sed, int[] par, int[] ord, int[] des, int[] ctpar)\n\t{\n\t\t// parent and level-order\n\t\tord[0] = root;\n\t\tpar[root] = -1;\n\t\tint r = 1;\n\t\tfor(int p = 0;p < r;p++) {\n\t\t\tint cur = ord[p];\n\t\t\tfor(int nex : g[cur]){\n\t\t\t\tif(par[cur] != nex && !sed[nex]){\n\t\t\t\t\tord[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if(r == 1)return;\n\t\t\n\t\t// DP and find a separator\n\t\tint sep = -1; // always exists\n\t\touter:\n\t\tfor(int i = r-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tdes[cur] = 1;\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(par[cur] != e && !sed[e])des[cur] += des[e];\n\t\t\t}\n\t\t\tif(r-des[cur] <= r/2){\n\t\t\t\tfor(int e : g[cur]){\n\t\t\t\t\tif(par[cur] != e && !sed[e] && des[e] >= r/2+1)continue outer;\n\t\t\t\t}\n\t\t\t\tsep = cur;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsed[sep] = true;\n\t\tfor(int e : g[sep]){\n\t\t\tif(!sed[e])ctpar[buildCentroidTree(g, e, sed, par, ord, des, ctpar)] = sep;\n\t\t}\n\t\treturn sep;\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    int[] from = new int[n-1];\n    int[] to = new int[n-1];\n    for (int i = 0; i < n - 1; i ++) {\n      from[i] = ni() - 1;\n      to[i] = ni() - 1;\n    }\n    int[][] g = packU(n, from, to);\n    \n    int dia = diameter(g)[0];\n    \n    int now = 0;\n    for (int k = 0;; k ++) {\n      if (now >= dia) {\n        System.out.println(k);\n        return;\n      }\n      now = now * 2 + 2;\n    }\n  }\n  \n  public static int[][] packU(int n, int[] from, int[] to){ return packU(n, from, to, from.length); }\n  public static int[][] packU(int n, int[] from, int[] to, int sup)\n  {\n      int[][] g = new int[n][];\n      int[] p = new int[n];\n      for(int i = 0;i < sup;i++)p[from[i]]++;\n      for(int i = 0;i < sup;i++)p[to[i]]++;\n      for(int i = 0;i < n;i++)g[i] = new int[p[i]];\n      for(int i = 0;i < sup;i++){\n          g[from[i]][--p[from[i]]] = to[i];\n          g[to[i]][--p[to[i]]] = from[i];\n      }\n      return g;\n  }\n\n  \n  public static int[] diameter(int[][] g)\n  {\n      int n = g.length;\n      int f0 = -1, f1 = -1, d01 = -1;\n      int[] q = new int[n];\n      boolean[] ved = new boolean[n];\n      {\n          int qp = 0;\n          q[qp++] = 0; ved[0] = true;\n          for(int i = 0;i < qp;i++){\n              int cur = q[i];\n              for(int e : g[cur]){\n                  if(!ved[e]){\n                      ved[e] = true;\n                      q[qp++] = e;\n                      continue;\n                  }\n              }\n          }\n          f0 = q[n-1];\n      }\n      {\n          int[] d = new int[n];\n          int qp = 0;\n          Arrays.fill(ved, false);\n          q[qp++] = f0; ved[f0] = true;\n          for(int i = 0;i < qp;i++){\n              int cur = q[i];\n              for(int e : g[cur]){\n                  if(!ved[e]){\n                      ved[e] = true;\n                      q[qp++] = e;\n                      d[e] = d[cur] + 1;\n                      continue;\n                  }\n              }\n          }\n          f1 = q[n-1];\n          d01 = d[f1];\n      }\n      return new int[]{d01, f0, f1};\n  }\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    int[] from = new int[n-1];\n    int[] to = new int[n-1];\n    for (int i = 0; i < n - 1; i ++) {\n      from[i] = ni() - 1;\n      to[i] = ni() - 1;\n    }\n    int[][] g = packU(n, from, to);\n    \n    ved1 = new int[n];\n    ved2 = new int[n];\n    q = new int[n];\n    int ret = dfs(0, new boolean[n], g);\n    System.out.println(ret - 1);\n  }\n  \n  private static int dfs(int now, boolean[] ved, int[][] g) {\n\n    int[] dia = diameter(g, now, ved);\n    ved[dia[3]] = true;\n    int max = -1;\n    \n    for (int next : g[dia[3]]) {\n      if (ved[next]) continue;\n      max = Math.max(max, dfs(next, ved, g));\n    }\n    \n    return max + 1;\n  }\n  \n  public static int[][] packU(int n, int[] from, int[] to){ return packU(n, from, to, from.length); }\n  public static int[][] packU(int n, int[] from, int[] to, int sup)\n  {\n      int[][] g = new int[n][];\n      int[] p = new int[n];\n      for(int i = 0;i < sup;i++)p[from[i]]++;\n      for(int i = 0;i < sup;i++)p[to[i]]++;\n      for(int i = 0;i < n;i++)g[i] = new int[p[i]];\n      for(int i = 0;i < sup;i++){\n          g[from[i]][--p[from[i]]] = to[i];\n          g[to[i]][--p[to[i]]] = from[i];\n      }\n      return g;\n  }\n\n  \n  private static int[] ved1;\n  private static int[] ved2;\n  private static int cnt = 1;\n  private static int[] q;\n  public static int[] diameter(int[][] g, int v, boolean[] sved)\n  {\n    cnt ++;\n      int f0 = -1, f1 = -1, d01 = -1, c = -1;\n      {\n          int qp = 0;\n          q[qp++] = v; ved1[0] = cnt;\n          for(int i = 0;i < qp;i++){\n              int cur = q[i];\n              for(int e : g[cur]){\n                  if(ved1[e] != cnt && !sved[e]){\n                      ved1[e] = cnt;\n                      q[qp++] = e;\n                      continue;\n                  }\n              }\n          }\n          f0 = q[qp-1];\n      }\n      {\n          int qp = 0;\n\n          q[qp++] = f0; ved2[f0] = cnt;\n          for(int i = 0;i < qp;i++){\n              int cur = q[i];\n              for(int e : g[cur]){\n                  if(ved2[e] != cnt && !sved[e]){\n                      ved2[e] = cnt;\n                      q[qp++] = e;\n                      continue;\n                  }\n              }\n          }\n          f1 = q[qp-1];\n          c = q[qp / 2];\n      }\n      return new int[]{d01, f0, f1, c};\n  }\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskD {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tadj[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint a = in.nextInt() - 1;\n\t\t\t\tint b = in.nextInt() - 1;\n\t\t\t\tadj[a].add(b);\n\t\t\t\tadj[b].add(a);\n\t\t\t}\n\t\t\tint m = dfs(0, -1, adj);\n\t\t\tint ans = 31 - Integer.numberOfLeadingZeros(m);\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate int dfs(int root, int parent, List<Integer>[] adj) {\n\t\t\tint setBits = 0;\n\t\t\tint atLeastTwice = 0;\n\t\t\tfor (int ch : adj[root]) {\n\t\t\t\tif (ch == parent) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint mask = dfs(ch, root, adj);\n\t\t\t\tatLeastTwice |= (setBits & mask);\n\t\t\t\tsetBits |= mask;\n\t\t\t}\n\t\t\t// weight(mask) = sum(M^i) for all set bits i in mask and\n\t\t\t// a large number M. Find the smallest mask such that\n\t\t\t// weight(rootmask) > sum of weights of children's masks.\n\t\t\tint last = 31 - Integer.numberOfLeadingZeros(atLeastTwice);\n\t\t\tint mask = setBits & ~((1 << (last + 1)) - 1);\n\t\t\tmask += 1 << (last + 1);\n\t\t\treturn mask;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tint[] ctpar = buildCentroidTree(g);\n\t\tint[][] cg = parentToG(ctpar);\n\t\tint root = -1;\n\t\tfor(int i = 0;i < n;i++)if(ctpar[i] == -1)root = i;\n\t\tint[][] pars = parents3(cg, root);\n//\t\ttr(ctpar);\n//\t\ttr(pars[2]);\n\t\tout.println(Arrays.stream(pars[2]).max().getAsInt());\n\t}\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\t\n\tpublic static int[][] parentToG(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint[] ct = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tct[i]++;\n\t\t\t\tct[par[i]]++;\n\t\t\t}\n\t\t}\n\t\tint[][] g = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tg[i] = new int[ct[i]];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tg[par[i]][--ct[par[i]]] = i;\n\t\t\t\tg[i][--ct[i]] = par[i];\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic static int[] buildCentroidTree(int[][] g) {\n\t\tint n = g.length;\n\t\tint[] ctpar = new int[n];\n\t\tArrays.fill(ctpar, -1);\n\t\tbuildCentroidTree(g, 0, new boolean[n], new int[n], new int[n], new int[n], ctpar);\n\t\treturn ctpar;\n\t}\n\t\n\tprivate static int buildCentroidTree(int[][] g, int root, boolean[] sed, int[] par, int[] ord, int[] des, int[] ctpar)\n\t{\n\t\t// parent and level-order\n\t\tord[0] = root;\n\t\tpar[root] = -1;\n\t\tint r = 1;\n\t\tfor(int p = 0;p < r;p++) {\n\t\t\tint cur = ord[p];\n\t\t\tfor(int nex : g[cur]){\n\t\t\t\tif(par[cur] != nex && !sed[nex]){\n\t\t\t\t\tord[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if(r == 1)return;\n\t\t\n\t\t// DP and find a separator\n\t\tint sep = -1; // always exists\n\t\touter:\n\t\tfor(int i = r-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tdes[cur] = 1;\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(par[cur] != e && !sed[e])des[cur] += des[e];\n\t\t\t}\n\t\t\tif(r-des[cur] <= r/2){\n\t\t\t\tfor(int e : g[cur]){\n\t\t\t\t\tif(par[cur] != e && !sed[e] && des[e] >= r/2+1)continue outer;\n\t\t\t\t}\n\t\t\t\tsep = cur;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsed[sep] = true;\n\t\tfor(int e : g[sep]){\n\t\t\tif(!sed[e])ctpar[buildCentroidTree(g, e, sed, par, ord, des, ctpar)] = sep;\n\t\t}\n\t\treturn sep;\n\t}\n\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n - 1];\n\t\tint[] to = new int[n - 1];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\tint[][] pars = parents3(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], dep = pars[2];\n\t\t\n\t\tlong[] dp = new long[n];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tlong once = 0;\n\t\t\tlong twice = 0;\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(par[cur] == e)continue;\n\t\t\t\tdp[cur] |= dp[e];\n\t\t\t\ttwice |= once&dp[e];\n\t\t\t\tonce |= dp[e];\n\t\t\t}\n\t\t\tlong h = Long.highestOneBit(twice);\n\t\t\tint sh = twice == 0 ? 0 : Long.numberOfTrailingZeros(h);\n\t\t\tint t = Long.numberOfTrailingZeros(~(once>>>sh)) + sh;\n\t\t\tdp[cur] = (dp[cur]>>>t|1)<<t;\n\t\t}\n\t\tout.println(Long.numberOfTrailingZeros(Long.highestOneBit(dp[0])));\n\t}\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static int[][] parentToG(int[] par)\n\t{\n\t\tint n = par.length;\n\t\tint[] ct = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tct[i]++;\n\t\t\t\tct[par[i]]++;\n\t\t\t}\n\t\t}\n\t\tint[][] g = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tg[i] = new int[ct[i]];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(par[i] >= 0){\n\t\t\t\tg[par[i]][--ct[par[i]]] = i;\n\t\t\t\tg[i][--ct[i]] = par[i];\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main\n{\n\tint n;\n\tArrayList<Integer> list[];\n\tfinal int inf=(int)(1e9+1);\n\tprivate void solve()throws IOException\n\t{\n\t\tn=nextInt();\n\t\tlist=new ArrayList[n+1];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tlist[i]=new ArrayList<>();\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint a=nextInt();\n\t\t\tint b=nextInt();\n\t\t\tlist[a].add(b);\n\t\t\tlist[b].add(a);\n\t\t}\n\t\tint dia=farthest(farthest(1).first).second;\n\t\tint ans=0;\n\t\twhile(dia>0)\n\t\t{\n\t\t\tdia=(dia-1)/2;\n\t\t\tans++;\n\t\t}\n\t\tout.println(ans);\n\t}\n\tPair farthest(int v)\n\t{\n\t\tQueue<Integer> queue=new LinkedList<>();\n\t\tqueue.add(v);\n\t\tPair max=new Pair(v,0);\n\t\tint dist[]=new int[n+1];\n\t\tArrays.fill(dist,inf);\n\t\tdist[v]=0;\n\t\twhile(!queue.isEmpty())\n\t\t{\n\t\t\tint curr=queue.remove();\n\t\t\tfor(int next:list[curr])\n\t\t\t\tif(dist[next]>dist[curr]+1)\n\t\t\t\t{\n\t\t\t\t\tdist[next]=dist[curr]+1;\n\t\t\t\t\tif(dist[next]>max.second)\n\t\t\t\t\t\tmax=new Pair(next,dist[next]);\n\t\t\t\t\tqueue.add(next);\n\t\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tclass Pair{\n\t    int first,second;\n\t    Pair(int a,int b){\n\t        first=a;\n\t        second=b;\n\t    }\n\t}\n\n\t \n\t///////////////////////////////////////////////////////////\n\n\tpublic void run()throws IOException\n\t{\n\t\tbr=new BufferedReader(new InputStreamReader(System.in));\n\t\tst=null;\n\t\tout=new PrintWriter(System.out);\n\n\t\tsolve();\n\t\t\n\t\tbr.close();\n\t\tout.close();\n\t}\n\tpublic static void main(String args[])throws IOException{\n\t\tnew Main().run();\n\t}\n\tBufferedReader br;\n\tStringTokenizer st;\n\tPrintWriter out;\n\tString nextToken()throws IOException{\n\t\twhile(st==null || !st.hasMoreTokens())\n\t\tst=new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n\tString nextLine()throws IOException{\n\t\treturn br.readLine();\n\t}\n\tint nextInt()throws IOException{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong()throws IOException{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble()throws IOException{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskD {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tadj[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint a = in.nextInt() - 1;\n\t\t\t\tint b = in.nextInt() - 1;\n\t\t\t\tadj[a].add(b);\n\t\t\t\tadj[b].add(a);\n\t\t\t}\n\t\t\tint m = dfs(0, -1, adj);\n\t\t\tint ans = 31 - Integer.numberOfLeadingZeros(m);\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tprivate int dfs(int root, int parent, List<Integer>[] adj) {\n\t\t\tint setBits = 0;\n\t\t\tint atLeastTwice = 0;\n\t\t\tfor (int ch : adj[root]) {\n\t\t\t\tif (ch == parent) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint mask = dfs(ch, root, adj);\n\t\t\t\tatLeastTwice |= (setBits & mask);\n\t\t\t\tsetBits |= mask;\n\t\t\t}\n\t\t\t// weight(mask) = sum(M^i) for all set bits i in mask and\n\t\t\t// a large number M. Find the smallest mask such that\n\t\t\t// weight(rootmask) > sum of weights of children's masks.\n\t\t\tint mask = setBits;\n\t\t\tif (atLeastTwice > 0) {\n\t\t\t\tmask |= (Integer.highestOneBit(atLeastTwice) << 1) - 1;\n\t\t\t}\n\t\t\t++mask;\n\t\t\treturn mask;\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n  fscanf(STDIN, \"%i\", $n);\n  for ($i = 1; $i < $n; $i++)\n  {\n      fscanf(STDIN, \"%i %i\", $a, $b);\n      $tree[$a][] = $b;\n      $tree[$b][] = $a;\n  }\n\n  for ($i = 1; $i <= $n; $i++)\n  {\n      $uni[$i]   = 0;\n      $multi[$i] = 0;\n  }\n  \n  $v = 1;\n  $crumbs = [];\n  while (!is_null($v))\n  {\n      $c = array_pop($tree[$v]);\n      if (!is_null($c))\n      {\n          array_remove($tree[$c], $v);\n          array_push($crumbs, $v);\n          $v = $c;\n      }\n      else\n      {\n          $c = $v;\n          $v = array_pop($crumbs);\n\n          $bits = 1 << msb($multi[$c]);\n          $uni[$c] &= ~($bits - 1);\n          $uni[$c] += $bits;\n          $multi[$v] |= $uni[$v] & $uni[$c];\n          $uni[$v]   |= $uni[$c];\n      }\n  }\n  echo (msb($uni[1]) - 1).PHP_EOL;\n\n  function array_remove(&$array, $elem)\n  {\n      $array = array_values(array_diff($array, [$elem]));\n  }\n\n  function msb($x)\n  {\n      $p = 0;\n      while ($x !== 0)\n      {\n          $x >>= 1;\n          $p++;\n      }\n      return $p;\n  }\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n  fscanf(STDIN, \"%i\", $n);\n  for ($i = 1; $i < $n; $i++)\n  {\n      fscanf(STDIN, \"%i %i\", $a, $b);\n      $tree[$a][] = $b;\n      $tree[$b][] = $a;\n  }\n\n  for ($i = 1; $i <= $n; $i++)\n  {\n      $uni[$i]   = 0;\n      $multi[$i] = 0;\n  }\n  \n  $v = 1;\n  $crumbs = [];\n  while (!is_null($v))\n  {\n      $c = array_pop($tree[$v]);\n      if (!is_null($c))\n      {\n          array_remove($tree[$c], $v);\n          array_push($crumbs, $v);\n          $v = $c;\n      }\n      else\n      {\n          $c = $v;\n          $v = array_pop($crumbs);\n\n          $bits = 1 << msb($multi[$c]);\n          $uni[$c] &= ~($bits - 1);\n          $uni[$c] += $bits;\n          $multi[$v] |= $uni[$v] & $uni[$c];\n          $uni[$v]   |= $uni[$c];\n      }\n  }\n  echo (msb($uni[1]) - 1).PHP_EOL;\n\n  function array_remove(&$array, $elem)\n  {\n      foreach ($array as $key => $value)\n      {\n          if ($value === $elem)\n          {\n              unset($array[$key]);\n              break;\n          }\n      }\n      $array = array_values($array);\n  }\n\n  function msb($x)\n  {\n      $p = 0;\n      while ($x !== 0)\n      {\n          $x >>= 1;\n          $p++;\n      }\n      return $p;\n  }\n?>\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n  fscanf(STDIN, \"%i\", $n);\n  for ($i = 1; $i < $n; $i++)\n  {\n      fscanf(STDIN, \"%i %i\", $a, $b);\n      $tree[$a][] = $b;\n      $tree[$b][] = $a;\n  }\n\n  for ($i = 1; $i <= $n; $i++)\n  {\n      $uni[$i]   = 0;\n      $multi[$i] = 0;\n  }\n  \n  $v = 1;\n  $crumbs = [];\n  while (!is_null($v))\n  {\n      $c = array_pop($tree[$v]);\n      if (!is_null($c))\n      {\n          array_remove($tree[$c], $v);\n          array_push($crumbs, $v);\n          $v = $c;\n      }\n      else\n      {\n          $c = $v;\n          $v = array_pop($crumbs);\n\n          $bits = 1 << msb($multi[$c]);\n          $uni[$c] &= ~($bits - 1);\n          $uni[$c] += $bits;\n          $multi[$v] |= $uni[$v] & $uni[$c];\n          $uni[$v]   |= $uni[$c];\n      }\n  }\n  echo (msb($uni[1]) - 1).PHP_EOL;\n\n  function array_remove(&$array, $elem)\n  {\n      $rests = [];\n      while (!is_null($peek = array_pop($array)) && $peek !== $elem)\n          array_push($rests, $peek);\n      while (!is_null($peek = array_pop($rests)))\n          array_push($array, $peek);\n  }\n\n  function msb($x)\n  {\n      $p = 0;\n      while ($x !== 0)\n      {\n          $x >>= 1;\n          $p++;\n      }\n      return $p;\n  }\n?>\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.4.0\"\n+/\nimport std.stdio, std.range, std.algorithm, std.conv;\nimport core.bitop;\n\n// import dcomp.scanner;\n\nvoid main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    sc.read(n);\n    int[][] g = new int[][](n);\n    foreach(i; 0..n-1) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a] ~= b; g[b] ~= a;\n    }\n    long dfs(int p, int b) {\n        long one, two;\n        foreach (d; g[p]) {\n            if (d == b) continue;\n            long x = dfs(d, p);\n            two |= one & x;\n            one |= x;\n        }\n        int off = two ? two.bsr + 1 : 0;\n        one = ((one >> off) + 1) << off;\n        return one;\n    }\n    \n    writeln(dfs(0, -1).bsr);\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nuninity = [0] * (N+1)\ndp = [np.zeros(30,np.int64) for _ in range(N+1)]\nanswer = -1\nfor x in order[::-1]:\n    p = parent[x]\n    A = dp[x]\n    twice = (A >= 2)\n    if np.any(twice):\n        k = np.where(twice)[0].max()\n        A[:k] = 1\n    lsb = np.where(A == 0)[0].min()\n    if answer < lsb:\n        answer += 1\n    uninity[x] = lsb\n    A[lsb] = 1\n    A[:lsb] = 0\n    A[A>0] = 1\n    dp[p] += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nfull = (1 << 60) - 1\nuninity = [0] * (N+1)\ndp = [0] * (N+1)\ntwice = [0] * (N+1)\nfor x in order[::-1]:\n    p = parent[x]\n    n = twice[x].bit_length() - 1\n    if n >= 0:\n        dp[x] |= (1 << (n+1)) - 1\n    can_use = full & (~dp[x])\n    lsb = can_use & (-can_use)\n    uninity[x] = lsb\n    dp[x] |= lsb\n    dp[x] &= full & ~(lsb - 1)\n    \n    twice[p] |= (dp[x] & dp[p])\n    dp[p] |= dp[x]\n\nx = max(uninity)\nanswer = x.bit_length() - 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef calc(rt):\n    e = edge[rt]\n    f[rt] = 1\n    g[rt] = 1\n    g1 = 0\n    g2 = 0\n    for son in e:\n        if(f[son] == 0):\n            calc(son)\n            res = f[son]\n            if(res > f[rt]):\n                f[rt] = res\n            res = g[son]\n            if res + 1 > g[rt]:\n                g[rt] = res + 1\n            if(res > g1):\n                g2 = g1\n                g1 = res\n            elif (res > g2):\n                g2 = res\n    if g1 + g2 + 1 > f[rt]:\n        f[rt] = g1 + g2 + 1\n    if g[rt] > f[rt]:\n        f[rt] = g[rt]\n\nn = int(input())\nedge = []\nf = []\ng = []\nfor i in range(0,n):\n    edge.append(set())\n    f.append(0)\n    g.append(0)\n\nfor i in range(1,n):\n    e = input().split(' ')\n    y = int(e[0]) - 1\n    x = int(e[1]) - 1\n    edge[x].add(y)\n    edge[y].add(x)\n\ncalc(0)\n\nlength = f[0]\nans = 0\nl = 1\nwhile l < length:\n    ans = ans + 1\n    l = l + l + 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nrange = xrange\n\ndef decomp(coupl, root = 0):\n    n = len(coupl)\n    visible_labels = [0] * n\n    \n    bfs = [root]\n    for node in bfs:\n        for nei in coupl[node]:\n            coupl[nei].remove(node)\n        bfs += coupl[node]\n\n    for node in reversed(bfs):\n        seen = seen_twice = 0\n        for nei in coupl[node]:\n            seen_twice |= seen & visible_labels[nei]\n            seen |= visible_labels[nei]\n        tmp = ~seen & -(1 << seen_twice.bit_length()) \n        label = tmp & -tmp\n        visible_labels[node] = (label | seen) & -label\n    \n    return [(seen & -seen).bit_length() - 1 for seen in visible_labels]\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nn = inp[ii]; ii += 1\ncoupl = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u = inp[ii] - 1; ii += 1\n    v = inp[ii] - 1; ii += 1\n    coupl[u].append(v)\n    coupl[v].append(u)\n\nprint max(decomp(coupl))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\nm = map(int,read().split())\nAB = zip(m,m)\n\ngraph = [[] for _ in range(N+1)]\nfor a,b in AB:\n    graph[a].append(b)\n    graph[b].append(a)\n\ngraph\n\nroot = 1\nparent = [0] * (N+1)\norder = []\nstack = [root]\nwhile stack:\n    x = stack.pop()\n    order.append(x)\n    for y in graph[x]:\n        if y == parent[x]:\n            continue\n        parent[y] = x\n        stack.append(y)\n\nuninity = [0] * (N+1)\ndp = [(1<<60)-1] * (N+1) # 使用可能なbitの集合\nfor x in order[::-1]:\n    p = parent[x]\n    # 使用可能なmin\n    lsb = dp[x] & (-dp[x])\n    uninity[x] = lsb\n    dp[x] ^= lsb\n    dp[x] |= (lsb - 1)\n    dp[p] &= dp[x]\n\nx = max(uninity).bit_length() - 1\nprint(x)"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn dfs(v: usize, par: usize, g: &[Vec<usize>]) -> i64 {\n    let mut a = 0;\n    for &w in &g[v] {\n        if w == par { continue; }\n        let sub = dfs(w, v, g);\n        a |= sub;\n    }\n    a + 1\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        ab: [(usize1, usize1); n - 1],\n    }\n    let mut g = vec![vec![]; n];\n    for &(a, b) in &ab {\n        g[a].push(b);\n        g[b].push(a);\n    }\n    let ret = dfs(0, n, &g);\n    let mut ma = 0;\n    for i in 0..60 {\n        if (ret & 1 << i) != 0 {\n            ma = i;\n        }\n    }\n    puts!(\"{}\\n\", ma);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn dfs(v: usize, par: usize, g: &[Vec<usize>]) -> i64 {\n    let mut a = 0;\n    let mut cnt = vec![0; 60];\n    for &w in &g[v] {\n        if w == par { continue; }\n        let sub = dfs(w, v, g);\n        a |= sub;\n        for i in 0..60 {\n            if (sub & 1 << i) != 0 {\n                cnt[i] += 1;\n            }\n        }\n    }\n    let mut twomax = 0;\n    for i in 0..60 {\n        if cnt[i] >= 2 {\n            twomax = i;\n        }\n    }\n    (a + (1 << twomax)) & (-1) << twomax\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        ab: [(usize1, usize1); n - 1],\n    }\n    let mut g = vec![vec![]; n];\n    for &(a, b) in &ab {\n        g[a].push(b);\n        g[b].push(a);\n    }\n    let ret = dfs(0, n, &g);\n    //eprintln!(\"ret = {}\", ret);\n    let mut ma = 0;\n    for i in 0..60 {\n        if (ret & 1 << i) != 0 {\n            ma = i;\n        }\n    }\n    puts!(\"{}\\n\", ma);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn dfs(v: usize, par: usize, g: &[Vec<usize>]) -> i64 {\n    let mut a = 0;\n    let mut cnt = vec![0; 60];\n    for &w in &g[v] {\n        if w == par { continue; }\n        let sub = dfs(w, v, g);\n        a |= sub;\n        for i in 0..60 {\n            if (sub & 1 << i) != 0 {\n                cnt[i] += 1;\n            }\n        }\n    }\n    let mut twomax = 0;\n    for i in 0..60 {\n        if cnt[i] >= 2 {\n            twomax = i;\n        }\n    }\n    (a + (1 << twomax)) & (-1) << twomax\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        ab: [(usize1, usize1); n - 1],\n    }\n    let mut g = vec![vec![]; n];\n    for &(a, b) in &ab {\n        g[a].push(b);\n        g[b].push(a);\n    }\n    let ret = dfs(0, n, &g);\n    eprintln!(\"ret = {}\", ret);\n    let mut ma = 0;\n    for i in 0..60 {\n        if (ret & 1 << i) != 0 {\n            ma = i;\n        }\n    }\n    puts!(\"{}\\n\", ma);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]