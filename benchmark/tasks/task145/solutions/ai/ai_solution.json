[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 5\n\nint n, m;\nchar grid[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\nint church_x, church_y;\nint total_houses = 0;\nint count = 0;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < m;\n}\n\nvoid dfs(int x, int y, int houses_visited) {\n    if (houses_visited == total_houses) {\n        for (int d = 0; d < 4; d++) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (is_valid(nx, ny) && grid[nx][ny] == 'C') {\n                count++;\n                break;\n            }\n        }\n        return;\n    }\n\n    for (int d = 0; d < 4; d++) {\n        int nx = x + dx[d];\n        int ny = y + dy[d];\n        while (is_valid(nx, ny)) {\n            if (grid[nx][ny] == 'H' && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                dfs(nx, ny, houses_visited + 1);\n                visited[nx][ny] = false;\n                break;\n            }\n            if (grid[nx][ny] == 'C' || grid[nx][ny] == '.' || (grid[nx][ny] == 'H' && visited[nx][ny])) {\n                nx += dx[d];\n                ny += dy[d];\n                continue;\n            }\n            break;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 'C') {\n                church_x = i;\n                church_y = j;\n            } else if (grid[i][j] == 'H') {\n                total_houses++;\n            }\n        }\n    }\n\n    dfs(church_x, church_y, 0);\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:49:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DirectionallyChallengedReindeer {\n    static int[][] grid;\n    static int rows, cols;\n    static int churchX, churchY;\n    static int houseCount;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n    static int routes = 0;\n\n    public static void solve(int x, int y, int visitedHouses, int lastDirection) {\n        if (visitedHouses == houseCount) {\n            if (x == churchX && y == churchY) {\n                routes++;\n            }\n            return;\n        }\n\n        for (int dir = 0; dir < 4; dir++) {\n            if (lastDirection != -1 && lastDirection != dir && lastDirection != (dir ^ 1)) {\n                continue;\n            }\n\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n\n            while (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                if (grid[nx][ny] == 1) {  // House\n                    int temp = grid[nx][ny];\n                    grid[nx][ny] = 0;\n                    solve(nx, ny, visitedHouses + 1, dir);\n                    grid[nx][ny] = temp;\n                } else if (grid[nx][ny] == 2) {  // Church\n                    solve(nx, ny, visitedHouses, dir);\n                }\n\n                nx += dx[dir];\n                ny += dy[dir];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        rows = scanner.nextInt();\n        cols = scanner.nextInt();\n        grid = new int[rows][cols];\n        houseCount = 0;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                grid[i][j] = scanner.nextInt();\n                if (grid[i][j] == 1) {\n                    houseCount++;\n                } else if (grid[i][j] == 2) {\n                    churchX = i;\n                    churchY = j;\n                }\n            }\n        }\n\n        solve(churchX, churchY, 0, -1);\n        System.out.println(routes);\n    }\n}",
    "timestamp": "2025-08-05 18:49:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint H, W;\nvector<string> grid;\nint church_i, church_j;\nint total_houses = 0;\nint visited_houses = 0;\nlong long result = 0;\n\nvoid dfs(int i, int j, int prev_dir) {\n    if (grid[i][j] == 'H') {\n        visited_houses++;\n        grid[i][j] = 'X'; // Mark as visited\n    }\n\n    if (visited_houses == total_houses) {\n        // Check if we can return to the church\n        bool can_return = false;\n        if (i == church_i && j == church_j) can_return = true;\n        else {\n            if (prev_dir == 0) { // North\n                if (i > church_i && j == church_j) can_return = true;\n            } else if (prev_dir == 1) { // South\n                if (i < church_i && j == church_j) can_return = true;\n            } else if (prev_dir == 2) { // East\n                if (i == church_i && j < church_j) can_return = true;\n            } else if (prev_dir == 3) { // West\n                if (i == church_i && j > church_j) can_return = true;\n            }\n        }\n        if (can_return) {\n            result++;\n        }\n        // Backtrack\n        if (grid[i][j] == 'X') {\n            grid[i][j] = 'H';\n            visited_houses--;\n        }\n        return;\n    }\n\n    // Try all four directions\n    for (int dir = 0; dir < 4; ++dir) {\n        if (dir == prev_dir) continue; // Same direction as previous\n\n        int ni = i, nj = j;\n        bool moved = false;\n        while (true) {\n            int next_i = ni, next_j = nj;\n            if (dir == 0) next_i--; // North\n            else if (dir == 1) next_i++; // South\n            else if (dir == 2) next_j++; // East\n            else if (dir == 3) next_j--; // West\n\n            if (next_i < 0 || next_i >= H || next_j < 0 || next_j >= W) break;\n            if (grid[next_i][next_j] == 'X') break; // Visited house\n            if (grid[next_i][next_j] == '.') { // Empty lot\n                ni = next_i;\n                nj = next_j;\n                continue;\n            }\n            // Valid move to house or church\n            moved = true;\n            ni = next_i;\n            nj = next_j;\n            break;\n        }\n\n        if (moved) {\n            dfs(ni, nj, dir);\n        }\n    }\n\n    // Backtrack\n    if (grid[i][j] == 'X') {\n        grid[i][j] = 'H';\n        visited_houses--;\n    }\n}\n\nint main() {\n    cin >> H >> W;\n    grid.resize(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 'C') {\n                church_i = i;\n                church_j = j;\n            } else if (grid[i][j] == 'H') {\n                total_houses++;\n            }\n        }\n    }\n\n    dfs(church_i, church_j, -1);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:49:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 20\n\nint H, W;\nchar grid[MAX_SIZE][MAX_SIZE];\nint houses = 0, visited_houses = 0;\nint church_x, church_y;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint count_routes(int x, int y, int visited_houses, int visited_mask) {\n    if (visited_houses == houses) {\n        return x == church_x && y == church_y;\n    }\n\n    int total_routes = 0;\n\n    for (int dir = 0; dir < 4; dir++) {\n        int nx = x, ny = y;\n        while (is_valid(nx + dx[dir], ny + dy[dir])) {\n            nx += dx[dir];\n            ny += dy[dir];\n\n            if (grid[nx][ny] == '#') continue;\n            if (grid[nx][ny] == 'H') {\n                int house_bit = (nx * W + ny);\n                if (!(visited_mask & (1 << house_bit))) {\n                    total_routes += count_routes(nx, ny, visited_houses + 1, \n                                                 visited_mask | (1 << house_bit));\n                }\n            } else {\n                total_routes += count_routes(nx, ny, visited_houses, visited_mask);\n            }\n        }\n    }\n\n    return total_routes;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n\n    houses = 0;\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == 'C') {\n                church_x = i;\n                church_y = j;\n            }\n            if (grid[i][j] == 'H') {\n                houses++;\n            }\n        }\n    }\n\n    int routes = count_routes(church_x, church_y, 0, 0);\n    printf(\"%d\\n\", routes);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:49:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_N = 20;\nint N, M;\nchar grid[MAX_N][MAX_N];\nbool visited[MAX_N][MAX_N][1 << 10][4];\nint house_count = 0;\n\nstruct State {\n    int x, y, mask, dir;\n};\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nint solve() {\n    int start_x = -1, start_y = -1;\n    \n    // Find church and count houses\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 'C') {\n                start_x = i;\n                start_y = j;\n            }\n            if (grid[i][j] == 'H') {\n                house_count++;\n            }\n        }\n    }\n    \n    queue<State> q;\n    \n    // Start in all 4 directions\n    for (int d = 0; d < 4; d++) {\n        q.push({start_x, start_y, 0, d});\n        visited[start_x][start_y][0][d] = true;\n    }\n    \n    int routes = 0;\n    \n    while (!q.empty()) {\n        State curr = q.front();\n        q.pop();\n        \n        // Reached church with all houses visited\n        if (grid[curr.x][curr.y] == 'C' && curr.mask == (1 << house_count) - 1) {\n            routes++;\n            continue;\n        }\n        \n        // Try moving in current direction\n        int nx = curr.x + dx[curr.dir];\n        int ny = curr.y + dy[curr.dir];\n        \n        if (nx < 0 || nx >= N || ny < 0 || ny >= M || grid[nx][ny] == 'S') continue;\n        \n        int new_mask = curr.mask;\n        \n        // If house and not visited\n        if (grid[nx][ny] == 'H') {\n            int house_index = 0;\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < M; j++) {\n                    if (grid[i][j] == 'H') {\n                        if (i == nx && j == ny) {\n                            new_mask |= (1 << house_index);\n                            break;\n                        }\n                        house_index++;\n                    }\n                }\n            }\n        }\n        \n        // Continue in same direction\n        if (!visited[nx][ny][new_mask][curr.dir]) {\n            q.push({nx, ny, new_mask, curr.dir});\n            visited[nx][ny][new_mask][curr.dir] = true;\n        }\n        \n        // Change direction if not church or current house\n        if (grid[nx][ny] != 'C' && !(grid[nx][ny] == 'H' && new_mask == curr.mask)) {\n            for (int new_dir = 0; new_dir < 4; new_dir++) {\n                if (new_dir != curr.dir) {\n                    if (!visited[nx][ny][new_mask][new_dir]) {\n                        q.push({nx, ny, new_mask, new_dir});\n                        visited[nx][ny][new_mask][new_dir] = true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return routes;\n}\n\nint main() {\n    cin >> N >> M;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    memset(visited, 0, sizeof(visited));\n    cout << solve() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ReindeerRoute {\n    static int H, W;\n    static char[][] grid;\n    static int houses;\n    static int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    static int[][][][] dp;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        grid = new char[H][W];\n        int startX = -1, startY = -1;\n        houses = 0;\n\n        for (int i = 0; i < H; i++) {\n            String line = sc.next();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == 'C') {\n                    startX = i;\n                    startY = j;\n                } else if (grid[i][j] == 'H') {\n                    houses++;\n                }\n            }\n        }\n\n        dp = new int[H][W][houses + 1][4];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                for (int k = 0; k <= houses; k++) {\n                    Arrays.fill(dp[i][j][k], -1);\n                }\n            }\n        }\n\n        int total = 0;\n        for (int dir = 0; dir < 4; dir++) {\n            total += dfs(startX, startY, 0, dir);\n        }\n        System.out.println(total);\n    }\n\n    static int dfs(int x, int y, int delivered, int dir) {\n        if (delivered == houses) {\n            return 1;\n        }\n\n        if (dp[x][y][delivered][dir] != -1) {\n            return dp[x][y][delivered][dir];\n        }\n\n        int res = 0;\n        int nx = x + directions[dir][0];\n        int ny = y + directions[dir][1];\n\n        if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n            if (grid[nx][ny] == 'H') {\n                char original = grid[nx][ny];\n                grid[nx][ny] = '.';\n                for (int newDir = 0; newDir < 4; newDir++) {\n                    res += dfs(nx, ny, delivered + 1, newDir);\n                }\n                grid[nx][ny] = original;\n            } else if (grid[nx][ny] == '.' || grid[nx][ny] == 'C') {\n                res += dfs(nx, ny, delivered, dir);\n            }\n        }\n\n        dp[x][y][delivered][dir] = res;\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 18:50:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_routes(grid):\n    def is_valid(x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != '#'\n    \n    def dfs(x, y, houses_visited):\n        nonlocal routes\n        if houses_visited == total_houses:\n            if x == church_x and y == church_y:\n                routes += 1\n            return\n        \n        # Try moving north\n        nx, ny = x - 1, y\n        while is_valid(nx, ny):\n            if (nx, ny) in visited:\n                break\n            if grid[nx][ny] == 'H':\n                visited.add((nx, ny))\n                dfs(nx, ny, houses_visited + 1)\n                visited.remove((nx, ny))\n            nx -= 1\n        \n        # Try moving south\n        nx, ny = x + 1, y\n        while is_valid(nx, ny):\n            if (nx, ny) in visited:\n                break\n            if grid[nx][ny] == 'H':\n                visited.add((nx, ny))\n                dfs(nx, ny, houses_visited + 1)\n                visited.remove((nx, ny))\n            nx += 1\n        \n        # Try moving east\n        nx, ny = x, y + 1\n        while is_valid(nx, ny):\n            if (nx, ny) in visited:\n                break\n            if grid[nx][ny] == 'H':\n                visited.add((nx, ny))\n                dfs(nx, ny, houses_visited + 1)\n                visited.remove((nx, ny))\n            ny += 1\n        \n        # Try moving west\n        nx, ny = x, y - 1\n        while is_valid(nx, ny):\n            if (nx, ny) in visited:\n                break\n            if grid[nx][ny] == 'H':\n                visited.add((nx, ny))\n                dfs(nx, ny, houses_visited + 1)\n                visited.remove((nx, ny))\n            ny -= 1\n    \n    church_x = church_y = total_houses = 0\n    visited = set()\n    routes = 0\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 'C':\n                church_x, church_y = i, j\n            elif grid[i][j] == 'H':\n                total_houses += 1\n    \n    dfs(church_x, church_y, 0)\n    return routes\n\n# Example usage:\ngrid = [\n    \"#####\",\n    \"#HCH#\",\n    \"#H.#H\",\n    \"#H##H\",\n    \"H.HH#\"\n]\n\nprint(count_routes(grid))",
    "timestamp": "2025-08-13 01:02:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DirectionallyChallengedReindeer {\n    private static final char HOUSE = 'H';\n    private static final char CHURCH = 'C';\n    private static final char EMPTY = '.';\n    private static int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private static int houseCount;\n    private static char[][] grid;\n    private static int n, m;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        m = scanner.nextInt();\n        grid = new char[n][m];\n\n        int startX = 0, startY = 0;\n        houseCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            String line = scanner.next();\n            for (int j = 0; j < m; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == CHURCH) {\n                    startX = i;\n                    startY = j;\n                } else if (grid[i][j] == HOUSE) {\n                    houseCount++;\n                }\n            }\n        }\n\n        System.out.println(findRoutes(startX, startY, 0, 0));\n    }\n\n    private static int findRoutes(int x, int y, int delivered, int lastDirection) {\n        if (delivered == houseCount && x == startX && y == startY) {\n            return 1;\n        }\n\n        int routes = 0;\n\n        for (int d = 0; d < 4; d++) {\n            if (delivered > 0 && d == lastDirection) continue; // Cannot change direction after landing\n\n            int nx = x, ny = y;\n            while (true) {\n                nx += directions[d][0];\n                ny += directions[d][1];\n\n                if (nx < 0 || nx >= n || ny < 0 || ny >= m || grid[nx][ny] == HOUSE && grid[nx][ny] == CHURCH) break;\n\n                if (grid[nx][ny] == HOUSE) {\n                    grid[nx][ny] = EMPTY; // mark house as delivered\n                    routes += findRoutes(nx, ny, delivered + 1, d);\n                    grid[nx][ny] = HOUSE; // backtrack\n                    break;\n                }\n            }\n        }\n\n        return routes;\n    }\n}",
    "timestamp": "2025-08-13 01:02:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 20\n#define CHURCH 'C'\n#define HOUSE 'H'\n#define EMPTY '.'\n\nint n, m;\nint houseCount = 0;\nchar town[MAX][MAX];\nint visited[MAX][MAX] = {0};\nint startX, startY;\n\nint directions[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\nint isValid(int x, int y) {\n    return x >= 0 && x < n && y >= 0 && y < m;\n}\n\nint dfs(int x, int y, int delivered) {\n    if (delivered == houseCount) {\n        return x == startX && y == startY;\n    }\n\n    int routes = 0;\n    visited[x][y] = 1;\n\n    for (int d = 0; d < 4; ++d) {\n        int newX = x + directions[d][0];\n        int newY = y + directions[d][1];\n\n        while (isValid(newX, newY) && (town[newX][newY] == EMPTY || town[newX][newY] == HOUSE || town[newX][newY] == CHURCH)) {\n            if (town[newX][newY] == HOUSE && !visited[newX][newY]) {\n                routes += dfs(newX, newY, delivered + 1);\n            }\n            newX += directions[d][0];\n            newY += directions[d][1];\n        }\n    }\n\n    visited[x][y] = 0;\n    return routes;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            scanf(\" %c\", &town[i][j]);\n            if (town[i][j] == CHURCH) {\n                startX = i;\n                startY = j;\n            } else if (town[i][j] == HOUSE) {\n                ++houseCount;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dfs(startX, startY, 0));\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:02:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom itertools import permutations\n\ndef solve(grid: List[List[str]]) -> int:\n    rows, cols = len(grid), len(grid[0])\n    church_pos = find_church(grid)\n    houses = find_houses(grid)\n    \n    if not houses:\n        return 0\n    \n    total_routes = 0\n    \n    for house_order in permutations(houses):\n        full_route = [church_pos] + list(house_order) + [church_pos]\n        \n        if is_valid_route(grid, full_route):\n            total_routes += 1\n    \n    return total_routes\n\ndef find_church(grid: List[List[str]]) -> Tuple[int, int]:\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == 'C':\n                return (r, c)\n    return (-1, -1)\n\ndef find_houses(grid: List[List[str]]) -> List[Tuple[int, int]]:\n    houses = []\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == 'H':\n                houses.append((r, c))\n    return houses\n\ndef is_valid_route(grid: List[List[str]], route: List[Tuple[int, int]]) -> bool:\n    visited = set()\n    \n    for i in range(len(route) - 1):\n        start = route[i]\n        end = route[i + 1]\n        \n        if not can_fly_between(grid, start, end, visited):\n            return False\n        \n        if start != end:\n            visited.add(start)\n    \n    return True\n\ndef can_fly_between(grid: List[List[str]], start: Tuple[int, int], end: Tuple[int, int], visited: set) -> bool:\n    sr, sc = start\n    er, ec = end\n    \n    if sr == er:  # horizontal movement\n        step = 1 if sc < ec else -1\n        for c in range(sc + step, ec + step, step):\n            if (sr, c) in visited and grid[sr][c] == 'H':\n                return False\n    \n    elif sc == ec:  # vertical movement\n        step = 1 if sr < er else -1\n        for r in range(sr + step, er + step, step):\n            if (r, sc) in visited and grid[r][sc] == 'H':\n                return False\n    \n    return True\n\n# Example usage\ndef main():\n    grid = [\n        ['C', 'H', 'E'],\n        ['E', 'H', 'E']\n    ]\n    print(solve(grid))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:02:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Find the church (starting point)\n    church_pos = None\n    house_count = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'C':\n                church_pos = (i, j)\n            elif grid[i][j] == 'H':\n                house_count += 1\n    \n    if not church_pos:\n        print(0)\n        return\n    \n    # Directions: north, south, east, west\n    directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n    \n    # We'll use a DP approach with memoization\n    # state: (x, y, visited_mask, direction)\n    # But since the number of houses is up to 10, we can represent visited as a bitmask\n    # However, for H=10, the mask is 2^10=1024, which is manageable\n    \n    # First, assign an index to each house\n    house_indices = {}\n    idx = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'H':\n                house_indices[(i, j)] = idx\n                idx += 1\n    \n    total_houses = house_count\n    if total_houses == 0:\n        print(1)\n        return\n    \n    # Initialize DP: dp[x][y][mask][last_dir] = count\n    # To save space, we can use a dictionary or a 4D array\n    # But given constraints, a dictionary might be more efficient\n    \n    from collections import defaultdict\n    dp = defaultdict(int)\n    \n    # Initial state: at church, mask 0, no last direction (or any direction)\n    x, y = church_pos\n    for dir_idx in range(4):\n        dp[(x, y, 0, dir_idx)] = 1\n    \n    # BFS or iterative DP\n    # We need to process states in order of increasing mask\n    # So we can iterate over all possible masks from 0 to 2^total_houses -1\n    \n    for mask in range(1 << total_houses):\n        # For each possible mask, process all (x,y) and directions\n        # To avoid revisiting, we can collect keys first\n        keys = [k for k in dp.keys() if k[2] == mask]\n        for (x, y, m, last_dir) in keys:\n            count = dp[(x, y, m, last_dir)]\n            if count == 0:\n                continue\n            # Try all four directions\n            for dir_idx in range(4):\n                dx, dy = directions[dir_idx]\n                nx, ny = x + dx, y + dy\n                steps = 1\n                # Move as far as possible in this direction\n                while 0 <= nx < H and 0 <= ny < W:\n                    cell = grid[nx][ny]\n                    if cell == 'C' or cell == '.':\n                        # Can pass through, but can't land unless it's the church and mask is full\n                        pass\n                    elif cell == 'H':\n                        house_pos = (nx, ny)\n                        if house_pos in house_indices:\n                            house_bit = 1 << house_indices[house_pos]\n                            if not (mask & house_bit):\n                                # Land here, deliver presents\n                                new_mask = mask | house_bit\n                                # The new direction can be any, but we'll handle in next steps\n                                # So add to dp with current direction (since we just landed)\n                                dp[(nx, ny, new_mask, dir_idx)] += count\n                                # After landing, must take off, so break\n                                break\n                        else:\n                            # Shouldn't happen\n                            pass\n                    # Continue moving in the same direction\n                    nx += dx\n                    ny += dy\n                    steps += 1\n    \n    # The answer is the sum of all states at the church, with full mask, any direction\n    total = 0\n    x, y = church_pos\n    full_mask = (1 << total_houses) - 1\n    for dir_idx in range(4):\n        total += dp.get((x, y, full_mask, dir_idx), 0)\n    \n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 01:03:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint h, w;\nvector<string> grid;\nvector<vector<vector<bool>>> visited;\nint house_count = 0;\nint start_x, start_y;\n\nvector<int> dx = {0, 0, 1, -1};\nvector<int> dy = {1, -1, 0, 0};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < h && y >= 0 && y < w;\n}\n\nint dfs(int x, int y, int houses_visited, int dir) {\n    if (houses_visited == house_count) {\n        return x == start_x && y == start_y;\n    }\n\n    int total_routes = 0;\n\n    for (int d = 0; d < 4; ++d) {\n        int nx = x + dx[d];\n        int ny = y + dy[d];\n\n        if (dir != -1 && dir != d) continue;    // Must continue in straight line\n\n        while (isValid(nx, ny) && grid[nx][ny] == '.') {\n            nx += dx[d];\n            ny += dy[d];\n        }\n\n        if (isValid(nx, ny)) {\n            if (grid[nx][ny] == 'H' && !visited[nx][ny][d]) {\n                visited[nx][ny][d] = true;\n                total_routes += dfs(nx, ny, houses_visited + 1, -1);\n                visited[nx][ny][d] = false;\n            } else if (grid[nx][ny] == 'C') {\n                total_routes += dfs(nx, ny, houses_visited, d);\n            }\n        }\n    }\n    return total_routes;\n}\n\nint main() {\n    cin >> h >> w;\n\n    grid = vector<string>(h);\n    for (int i = 0; i < h; ++i) {\n        cin >> grid[i];\n        for (int j = 0; j < w; ++j) {\n            if (grid[i][j] == 'H') {\n                house_count++;\n            } else if (grid[i][j] == 'C') {\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    visited.assign(h, vector<vector<bool>>(w, vector<bool>(4, false)));\n\n    cout << dfs(start_x, start_y, 0, -1) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:57:55"
  }
]