[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint h, w;\nll k = 1, l;\nint b[10][10], o;\nll c[100];\nint dp[24][16777216];\nint a[10][10];\nll solve(int i, int j, ll s) {\n\tif (l == s) {\n\t\tif (b[i][j] == o)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tll sum = 0;\n\tfor (int x = i + 1; x < h; x++) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = i - 1; x >= 0; x--) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j + 1; y < w; y++) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j - 1; y >= 0; y--) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> w >> h&&w!=0&&h!=0) {\n\t\tint sx, sy;\n\t\tll sum = 0;\n\t\tl = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\to = sum;\n\t\t\t\t}\n\t\t\t\tif (a[i][j]) {\n\t\t\t\t\tb[i][j] = sum;\n\t\t\t\t\tc[sum++] = k;\n\t\t\t\t\tl += k;\n\t\t\t\t\tk *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < sum; i++) {\n\t\t\tfor (ll j = 0; j <= l; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcout << solve(sx, sy, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint map[10][10],m,n;\nint solve(int x,int y,int left) {\n\tbool house=false;\n\tif(left<0) return 0;\n\tif(map[x][y]==1) {\n\t\thouse=true;\n\t\tmap[x][y]=0;\n\t}\n\tint res=0;\n\tfor(int i=x-1;i>=0;i--) {\n\t\tif(map[i][y]==1) {\n\t\t\tres+=solve(i,y,left-1);\n\t\t\tbreak;\n\t\t}else if(map[i][y]==2&&left==0) {\n\t\t\tres++;\n\t\t\tif(house)map[x][y]=1;\n\t\t\treturn res;\n\t\t}\n\t}\n\tfor(int i=x+1;i<m;i++) {\n\t\tif(map[i][y]==1) {\n\t\t\tres+=solve(i,y,left-1);\n\t\t\tbreak;\n\t\t}else if(map[i][y]==2&&left==0) {\n\t\t\tres++;\n\t\t\tif(house)map[x][y]=1;\n\t\t\treturn res;\n\t\t}else if(map[i][y]==3) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=y-1;i>=0;i--) {\n\t\tif(map[x][i]==1) {\n\t\t\tres+=solve(x,i,left-1);\n\t\t\tbreak;\n\t\t}else if(map[x][i]==2&&left==0) {\n\t\t\tres++;\n\t\t\tif(house)map[x][y]=1;\n\t\t\treturn res;\n\t\t}\n\t}\n\tfor(int i=y+1;i<n;i++) {\n\t\tif(map[x][i]==1) {\n\t\t\tres+=solve(x,i,left-1);\n\t\t\tbreak;\n\t\t}else if(map[x][i]==2&&left==0) {\n\t\t\tres++;\n\t\t\tif(house)map[x][y]=1;\n\t\t\treturn res;\n\t\t}\n\t}\n\tif(house)map[x][y]=1;\n\treturn res;\n}\nint main() {\n\tint x,y,house;\n\twhile(scanf(\"%d %d\",&m,&n),m) {\n\t\thouse=0;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++) {\n\t\t\tscanf(\"%d\",&map[j][i]);\n\t\t\tif(map[j][i]==1)house++;\n\t\t\tif(map[j][i]==2)x=j,y=i;\n\t\t}\n\t\tprintf(\"%d\\n\",solve(x,y,house));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\nstruct reindeer{\n    int fly[11][11];\n    int x,y,pst;\n};\nusing namespace std;\nint main(void){\n    // Your code here!\n    int X,Y,xx,yy,map[11][11],i,i2,sx,sy,bx[4]={1,-1,0,0},by[4]={0,0,1,-1},ans,psts;\n    reindeer now,next;\n    queue<reindeer> jotai;\n    cin>>X>>Y;\n    while(X!=0){\n        ans=0;\n        psts=0;\n        for(i=1;i<=Y;i++){\n            for(i2=1;i2<=X;i2++){\n                cin>>map[i2][i];\n                if(map[i2][i]==1)psts++;\n                if(map[i2][i]==2){\n                    sx=i2;\n                    sy=i;\n                }\n                now.fly[i2][i]=0;\n            }\n        }\n        now.pst=0;\n        now.x=sx;\n        now.y=sy;\n        jotai.push(now);\n        while(!jotai.empty()){\n            now=jotai.front();\n            jotai.pop();\n            for(int I=0;I<4;I++){\n                xx=now.x+bx[I];\n                yy=now.y+by[I];\n                while(now.fly[xx][yy]==0&&xx>0&&yy>0&&xx<=X&&yy<=Y){\n                    \n                    /*cout<<now.x<<\"->\"<<xx<<' '<<now.y<<\"->\"<<yy<<endl;\n                    \n                    for(i=1;i<=Y;i++){\n                        for(i2=1;i2<=X;i2++){\n                            cout<<now.fly[i2][i];\n                        }\n                        cout<<endl;\n                    }\n                    cout<<endl;\n                    */\n                    if(map[xx][yy]==1){\n                        for(i=1;i<=Y;i++){\n                            for(i2=1;i2<=X;i2++){\n                                next.fly[i2][i]=now.fly[i2][i];\n                            }\n                        }\n                        next.fly[xx][yy]=now.pst+1;\n                        next.pst=now.pst+1;\n                        next.x=xx;\n                        next.y=yy;\n                        jotai.push(next);\n                    }\n                    if(map[xx][yy]==2){\n                        if(now.pst==psts){\n                            ans++; \n                            \n                            /*\n                            for(i=1;i<=Y;i++){\n                                for(i2=1;i2<=X;i2++){\n                                    cout<<now.fly[i2][i];\n                                }\n                                cout<<endl;\n                            }\n                            cout<<endl;\n                            */\n                        }\n                    }\n                    xx+=bx[I];\n                    yy+=by[I];\n                }\n            }\n        }\n        cout<<ans<<endl;\n        cin>>X>>Y;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\nint w,h;\nint map[10][10];\nbool passed[10][10];\nint gx,gy;\nint count_max;\nint func(int x,int y, int count)\n{\n\tstd::cout << \"IN:\"<<x<<' '<<y<<' '<<count<<'\\n';\n\tif(count==count_max){\n\t\tif(x==gx||y==gy){return 1;}\n\t\treturn 0;\n\t}\n\tpassed[x][y]=true;\n\tint res = 0;\n\tfor(int nx = x-1;nx>=0;--nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int nx = x+1;nx<w;++nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y-1;ny>=0;--ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y+1;ny<h;++ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpassed[x][y]=false;\n\treturn res;\n}\n\nint main()\n{\n\tfor(;;){\n\tstd::cin >> w>>h;if(w==0&&h==0){break;}\n\tcount_max=0;\n\tfor(int y=0;y<h;++y)for(int x=0;x<w;++x){\n\t\tstd::cin >> map[x][y];\n\t\tif(map[x][y]==1){++count_max;}\n\t\tif(map[x][y]==2){gx=x;gy=y;}\n\t}\n\tstd::cout << \"a:\"<<gx<<' '<<gy<<' '<<count_max<<'\\n';\n\t\n\tint res = 0;\n\tstd::cout << func(gx,gy,0)<<std::endl;\n}\n}\n\n\n#if 0\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int nposmax = 6;\nconst int bitmax = 1<<21;\n//bit????????????\nint dp[nposmax][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax&&now<nposmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\t\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tif(bit<bitmax&&now<nposmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    if(ni==t.ni){\n      if(nj==t.nj){\n\treturn vis<t.vis;\n      }else return nj < t.nj;\n    }else return ni < t.ni;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  //set<state> visited;\n  qs.push( init );\n  //visited.insert(init);\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    //    bool bCont=false;\n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    \n    bool bCont=false;\n    for(int i = 0; i < MAX; ++i){\n      for(int j = 0; j < MAX; ++j){\n\tif( M[i][j].isHouse || M[i][j].isCharch ){\n\t  if( M[i][j].isHouse ){\n\t    if( st_now.vis&(1<<houseId[i][j]) ) continue;\n\t  }\n\t  bool frontofcharch=false;\n\t  int left=0;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    left+=M[i][j].link[k].size() + (M[i][j].cexist[k]?frontofcharch=true,1:0);\n\t    for(int v = 0; v < M[i][j].link[k].size(); ++v){\n\t      pi house = M[i][j].link[k][v];\n\t      if( st_now.vis&(1<<houseId[house.fr][house.sc]) )\n\t\t--left;\n\t    }\n\t  }\n\t  if(left<=1&&!frontofcharch){\n\t    //cout << i << ' ' << j << \" left : \" << left << endl;\n\t    bCont=true;break;\n\t  }\n\t}\n      }\n      if(bCont)break;\n    }\n    //if(bCont)continue;\n    \n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.cnt++;\n\t    st_next.vis |= ( 1<<houseId[next.fr][next.sc] );\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h)) {\n\t\tif (!w && !h)\n\t\t\tbreak;\n\t\tvector<vector<char>> mp(w, vector<char>(h, -1));\n\t\tpii cha;\n\t\tvector<pair<char, char>> homp;\n\t\tint homc = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tint a = 0;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tif (a == 2) {\n\t\t\t\t\tcha = { j,i };\n\t\t\t\t}\n\t\t\t\tif (a == 1) {\n\t\t\t\t\thomp.push_back({ j,i });\n\t\t\t\t\tmp[j][i] = homc;\n\t\t\t\t\thomc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thomp.push_back(cha);\n\t\tmap<pair<int, char>, int> dp[2];//?±\\??´????????¨??°\n\t\tdp[0][{0, homc}] = 1;\n\t\tbool t = 0;\n\t\tREP(i, homc) {\n\t\t\tfor (auto cur : dp[t]) {\n\t\t\t\tpii curpos = homp[cur.first.second];\n\t\t\t\tint cnum;\n\t\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!bitcheck(cur.first.first, cnum)) {\n\t\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!bitcheck(cur.first.first, cnum)) {\n\t\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!bitcheck(cur.first.first, cnum)) {\n\t\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!bitcheck(cur.first.first, cnum)) {\n\t\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[t].clear();\n\t\t\tt = 1 - t;\n\t\t}\n\t\tint ans = 0;\n\n\t\tfor (auto cur : dp[t]) {\n\t\t\tif (homp[cur.first.second].first == cha.first || homp[cur.first.second].second == cha.second)\n\t\t\t\tans += cur.second;\n\t\t}\n\n\t\tdp[1 - t].clear();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    map<P,int> a;\n    dp = a;\n    cout << solve(1,0) << endl;\n    break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 19;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX && !(cnt >= 16 && sum == 0)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<int,int> dp[24];\n//int dp[24][1<<18];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(dp[id].count(vis))return dp[id][vis];\n  //if(__builtin_popcount(vis)>6 && dp[id][vis])return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)>6)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    for(int i=0;i<pn;i++)dp[i].clear();\n\t//for(int i=0;i<pn;i++)\n   \t  //for(int j=0;j<(1<<18);j++)dp[i][j] = 0;\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint W, H, N;\nint mas[11][11];\nbool isin(int y, int x)\n{\n    return (y >= 0 && x >= 0 && y < H && x < W);\n}\nint dfs(int y, int x, int bit)\n{\n    int ret = 0;\n    if(bit == 0) return (1);\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        while(isin(ny, nx) && (mas[ny][nx] < 0 || (bit != (1 << N) && mas[ny][nx] == N) || (bit & ~(1 << mas[ny][nx])) == bit)) ny += dy[i], nx += dx[i];\n        if(isin(ny, nx)) ret += dfs(ny, nx, bit & ~(1 << mas[ny][nx]));\n    }\n    return (ret);\n}\n\nint main()\n{\n    int px, py;\n    N = 0;\n    while(cin >> W >> H, W || H) {\n        for(int i = 0; i < H; i++) {\n            for(int j = 0; j < W; j++) {\n                cin >> mas[i][j];\n                if(mas[i][j] == 0) mas[i][j] = -1;\n                else if(mas[i][j] == 1) mas[i][j] = N, N++;\n                else py = i, px = j;\n            }\n        }\n        mas[py][px] = N;\n        cout << dfs(py, px, (1 << (N + 1)) - 1) << endl;\n    }\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\nvoid MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\nint DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[house_num][state]!=-1) return memo[house_num][state];\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(G[house_num][i].S_-1))&1)!=1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(memo[MP(house_num,state)]==0&&house_num!=0&&((state>>(G[house_num][i].S_-1))&1)!=1){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\tif(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << memo[house_num][state] << ' ' << result2 << endl;\n\treturn memo[MP(house_num,state)]+result1-1;\n}\n\nlli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>22||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=22&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=22?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<P,int> dp;\nP pos[24];\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(P s){\n  if(dp[s])return dp[s];\n\n  int vis = s.first, id = s.second;\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\tres += 1;\n\tbreak;\n      }\n      if(0<g[ty][tx]){\n\tint tmp = g[ty][tx] - 1;\n\tif( (vis>>tmp)&1 ){\n\t  res += rec(P(vis-(1<<tmp),g[ty][tx]));\n\t  break;\n\t}\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  return dp[s] = res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    dp.clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(P(upper-1,0)));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\n//map<int,int> dp[24];\nint dp[24][1<<20];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(__builtin_popcount(vis)<20 && dp[id][vis])return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)<20)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    //for(int i=0;i<pn;i++)dp[i].clear();\n\tfor(int i=0;i<pn;i++)\n   \t  for(int j=0;j<(1<<20);j++)dp[i][j] = 0;\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint H,W;\nint G[11][11],INDEX[11][11],ep_bitmask,sp,V;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvector<int> edges[25][4];\nmap<ii,int> memo;\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void INIT(){\n  memo.clear();\n  ep_bitmask = 0, sp = -1;\n  rep(i,11) rep(j,11) INDEX[i][j] = -1;\n  rep(i,25) rep(j,4) edges[i][j].clear();\n}\n\ninline void make_edges(){\n  rep(i,H) rep(j,W) if( G[i][j] != 0 ) {\n    int x = j, y = i;\n    rep(k,4){\n      int nx = x + dx[k], ny = y + dy[k];\n      while( isValid(nx,ny) ){\n        if( G[ny][nx] == 1 ) edges[INDEX[i][j]][k].push_back(INDEX[ny][nx]);\n        nx += dx[k], ny += dy[k];\n      }\n    }\n  }\n}\n\ninline void calc_last_point(int x,int y){\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    while( isValid(nx,ny) ){\n      if( G[ny][nx] != 0 ) {\n        ep_bitmask |= (1<<INDEX[ny][nx]);\n        break;\n      }\n      nx += dx[i], ny += dy[i];\n    }\n  }\n}\n\nbool check(int cur,int visited){\n  bool used[V];\n  rep(i,V) used[i] = ((visited>>i)&1);\n  deque<int> deq;\n  deq.push_back(cur);\n  used[cur] = true;\n  while( !deq.empty() ){\n    int p = deq.front(); deq.pop_front();\n    if( (ep_bitmask>>p) & 1 ) return true;\n    rep(i,4){\n      rep(j,edges[p][i].size()){\n        int np = edges[p][i][j];\n        if( used[np] ) continue;\n        used[np] = true;\n        deq.push_back(np);\n      }\n    }\n  }\n  return false;\n}\n\nint dfs(int cur,int visited,int remain,int ep_remain){\n\n  if( ep_remain == 0 && remain != 0 ) return 0;\n\n  if( remain <= 0 ) return ( (ep_bitmask>>cur) & 1 );\n\n\n  if( memo.find(ii(cur,visited)) != memo.end() ) return memo[ii(cur,visited)];\n\n  int ret = 0;\n  rep(k,4){\n    rep(i,edges[cur][k].size()){\n      int next = edges[cur][k][i];\n      assert(next>=0);\n      if( (visited>>next) & 1 ) break;\n      ret += dfs(next,visited|(1<<next),remain-(next!=sp),ep_remain-((ep_bitmask>>next)&1));\n    }\n  }\n  if( ret >= 100 ) memo[ii(cur,visited)] = ret;\n\n  return ret;\n}\n\nint main(){\n  while( cin >> W >> H, H|W ){\n    INIT();\n    int idx = 0,remain = 0,sx,sy;\n    rep(i,H) rep(j,W) {\n      cin >> G[i][j];\n      if( G[i][j] == 1 ) INDEX[i][j] = idx++, remain++;\n      if( G[i][j] == 2 ) sx = j, sy = i;\n    }\n    sp = INDEX[sy][sx] = idx++;\n    make_edges();\n\n    calc_last_point(sx,sy);\n    assert(remain <= 23);\n    V = remain;\n    cout << dfs(sp,(1<<INDEX[sy][sx]),remain,__builtin_popcount(ep_bitmask)) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nmap<int, int> data[100]; // [?????¨?????????][????????§????¨??????????????????°] = ????????????????????°\nvector<int> g[100][4]; // 0?????????, ??????????????¶????????????g[i][j] i??????????????? j:0???????????????, 1???, 2???, 3???????????§?????????\nint maps[10][10];\nint m, n;\nint cnt;\n\nint dfs(int used, int pos) {\n\tif (data[pos].find(used) != data[pos].end()) return data[pos][used];\n\tif (pos == 0) return used == (1<<cnt) - 1;\n\t\n\tint res = 0;\n\t\n\tREP(i, 4) {\n\t\tREP(j, g[pos][i].size()) {\n\t\t\tint to = g[pos][i][j];\n\t\t\tif ((used >> to) & 1) break;\n\t\t\tres += dfs(used | (1<<to), to);\n\t\t}\n\t}\n\t\n\treturn data[pos][used] = res;\n}\n\nint main() {\n\twhile (cin >> m >> n, m || n) {\n\t\tREP(i, 100) REP(j, 4) g[i][j].clear();\n\t\tREP(i, 100) data[i].clear();\n\t\n\t\tREP(i, n) REP(j, m) scanf(\"%d\", &maps[i][j]);\n\t\t\n\t\tcnt = 1;\n\t\tREP(i, n) {\n\t\t\tREP(j, m) {\n\t\t\t\tint tmp = -1;\n\t\t\t\tswitch(maps[i][j]) {\n\t\t\t\t\tcase 1: tmp = cnt++; break;\n\t\t\t\t\tcase 2: tmp = 0; break;\n\t\t\t\t}\n\t\t\t\tmaps[i][j] = tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, n) REP(j, m) {\n\t\t\tint from = maps[i][j];\n\t\t\tif (from != -1) {\n\t\t\t\tint tmp = 0;\n\t\t\t\tREP(k, n) if (maps[k][j] != -1) {\n\t\t\t\t\tif (k == i) tmp++;\n\t\t\t\t\telse g[from][tmp].push_back(maps[k][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttmp = 2;\n\t\t\t\tREP(k, m) if (maps[i][k] != -1) {\n\t\t\t\t\tif (k == j) tmp++;\n\t\t\t\t\telse g[from][tmp].push_back(maps[i][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treverse(g[from][0].begin(), g[from][0].end());\n\t\t\t\treverse(g[from][2].begin(), g[from][2].end());\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tREP(i, 4) REP(j, g[0][i].size()) ans += dfs(1<<g[0][i][j], g[0][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> grid;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nvi dir[24][4];\nmap<int,int> memo;\n\nint rec(int v, int bit, int n){\n  int key = (v<<24)+bit;\n  if(memo.find(key)!=memo.end())return memo[key];\n  if(v==0 && bit+1 == 1<<n)return 1;\n\n  int res = 0;\n  rep(d,4){\n    for(int u : dir[v][d]){\n      if( (bit>>u)&1 )break;\n      res += rec(u, bit | (1<<u),n);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int w,h;\n  while(cin >> w >> h, w){\n    grid g(h,vi(w));\n    \n    rep(i,h)rep(j,w)cin >> g[i][j];\n    \n    grid id(h,vi(w,-1));\n    int cnt = 1;\n    rep(i,h)rep(j,w){\n      if(g[i][j] == 2)id[i][j] = 0;\n      if(g[i][j] == 1)id[i][j] = cnt++;\n    }\n\n    rep(i,h)rep(j,w){\n      if(id[i][j]>=0){\n\trep(d,4){\n\t  dir[id[i][j]][d].clear();\n\n\t  int y = i+dy[d], x = j+dx[d];\n\t  while(range(y,0,h) && range(x,0,w)){\n\t    if(id[y][x]>=0)dir[id[i][j]][d].push_back(id[y][x]);\n\t    y += dy[d]; x += dx[d];\n\t  }\n\t}\n      }\n    }\n    \n    memo.clear();\n    cout << rec(0,0,cnt) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\n#include <map>\n\nusing namespace std;\n \nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n \ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n \nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n \nint main() {\n  while (true) {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    int p[n][m];\n    for (int i : range(n)) for (int j : range(m)) cin >> p[i][j];\n    vector<pair<int, int>> house;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 1) house.emplace_back(i, j);\n    int s[n][m];\n    for (int i : range(n)) for (int j : range(m)) s[i][j] = -1;\n    for (int i : range(house.size())) s[house[i].first][house[i].second] = i;\n    queue<tuple<int, int, int>> que;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 2) que.push(make_tuple(i, j, (1 << house.size()) - 1));\n    int res = 0;\n    map<tuple<int, int, int>, int> mp;\n    ++mp[que.front()];\n    while (!que.empty()) {\n      auto now = que.front(); que.pop();\n      int y = get<0>(now);\n      int x = get<1>(now);\n      int bit = get<2>(now);\n      //cerr << y << \" \" << x << \" \";\n      //for (int i : range(7)) cerr << (bit >> i & 1);\n      //cerr << \" \" << mp[now] << endl;\n      for (int i : range(4)) {\n        int yy = y + dy[i];\n        int xx = x + dx[i];\n        while (true) {\n          if (yy < 0 || n <= yy) break;\n          if (xx < 0 || m <= xx) break;\n          if (p[yy][xx] == 1 && (bit & 1 << s[yy][xx])) {\n            auto t = make_tuple(yy, xx, bit ^ 1 << s[yy][xx]);\n            if (!mp.count(t)) que.push(t);\n            mp[t] += mp[now];\n            break;\n          }\n          if (p[yy][xx] == 2 && bit == 0) res += mp[now]; \n          yy += dy[i];\n          xx += dx[i];\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&(house_num==0||((state>>(house_num-1))&1)==1)) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((__builtin_popcount(state)>13||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1){\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\tif(__builtin_popcount(state)<=13&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (__builtin_popcount(state)<=13?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h,int k){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny],k-1);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(k >= 8) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    map<P,int> a;\n    dp = a;\n    cout << solve(1,0,c) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct ROUTE {\n    int No;\n    set<int> pass;\n    ROUTE() {}\n    ROUTE(int a) {\n        this->No=a;\n    }\n};\n\nstruct QUE {\n    int No;\n    set<int> visited;\n    QUE() {}\n    QUE(int a) {\n        this->No=a;\n    }\n    QUE(int a, set<int> s) {\n        this->No=a;\n        this->visited=s;\n    }\n};\n\nbool canfly(int to, vector<ROUTE>& route, set<int>& vis) {\n    if(vis.count(to)!=0) return false;\n    for(auto x : route) {\n        if(x.No==to) {\n            for(auto y : x.pass) {\n                if(vis.count(y)!=0) return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solve(int m,int n) {\n    vector<int> mp[n];\n    vector<P> house; // tate,yoko\n    P church;\n    int cnt=0;\n    house.push_back(P(-1,-1));\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<m; ++j) {\n            int temp;\n            cin >> temp;\n            if(temp==1) {\n                ++cnt;\n                house.push_back(P(i,j));\n                mp[i].push_back(cnt);\n            } else if(temp==2) {\n                church=P(i,j);\n                mp[i].push_back(100);\n            } else {\n                mp[i].push_back(0);\n            }\n        }\n    }\n\n    house[0]=church;\n\n    vector<ROUTE> to[cnt+1];\n    for(int i=0; i<=cnt; ++i) {\n        vector<int> temp;\n        for(int j=house[i].second-1; j>=0; --j) { // search left\n            if(mp[house[i].first][j]>0) {\n                to[i].push_back(ROUTE(mp[house[i].first][j]));\n                for(auto x : temp) (--to[i].end())->pass.insert(x);\n                temp.push_back(mp[house[i].first][j]);\n            }\n        }\n        temp.clear();\n        for(int j=house[i].second+1; j<m; ++j) { // search right\n            if(mp[house[i].first][j]>0) {\n                to[i].push_back(ROUTE(mp[house[i].first][j]));\n                for(auto x : temp) (--to[i].end())->pass.insert(x);\n                temp.push_back(mp[house[i].first][j]);\n            }\n        }\n        temp.clear();\n        for(int j=house[i].first-1; j>=0; --j) { // search up\n            if(mp[j][house[i].second]>0) {\n                to[i].push_back(ROUTE(mp[j][house[i].second]));\n                for(auto x : temp) (--to[i].end())->pass.insert(x);\n                temp.push_back(mp[j][house[i].second]);\n            }\n        }\n        temp.clear();\n        for(int j=house[i].first+1; j<n; ++j) { // search down\n            if(mp[j][house[i].second]>0) {\n                to[i].push_back(ROUTE(mp[j][house[i].second]));\n                for(auto x : temp) (--to[i].end())->pass.insert(x);\n                temp.push_back(mp[j][house[i].second]);\n            }\n        }\n    }\n\n    queue<QUE> q;\n    int ans=0;\n\n    q.push(QUE(0));\n    while(!q.empty()) {\n        QUE que=q.front(); q.pop();\n        set<int> st=que.visited;\n        if(que.No!=0) st.insert(que.No);\n        if(que.No==100 && st.size()==cnt+1) {\n            ++ans;\n            continue;\n        } else if(que.No==100) {\n            continue;\n        }\n        for(auto nxt : to[que.No]) {\n            if(canfly(nxt.No,to[que.No],st)) {\n                q.push(QUE(nxt.No,st));\n            }\n        }\n    }\n    \n    cout << ans << endl;\n\n    return;\n}\n\nint main() {\n    int m,n;\n    while(true) {\n        cin >> m >> n;\n        if(m==0 && n==0) break;\n        solve(m,n);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nconst int B = 19;\n//int dp[24][1 << B];\nmap<P, int> dp;\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (idx == hs && bits != (1 << hs + 1) - 1) {\n\t\tif (!bits) return 1;\n\t\telse 0;\n\t}\n\t//if (bits < 1 << B && ~dp[idx][bits]) return dp[idx][bits];\n\tif (dp.count(P(idx, bits))) return dp[P(idx, bits)];\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif (!((bits >> x) & 1)) break;\n\t\telse res += dfs(x, bits & ~(1 << x));\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif (!((bits >> x) & 1)) break;\n\t\tres += dfs(x, bits & ~(1 << x));\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif (!((bits >> x) & 1)) break;\n\t\tres += dfs(x, bits & ~(1 << x));\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif (!((bits >> x) & 1)) break;\n\t\tres += dfs(x, bits & ~(1 << x));\n\t}\n\treturn dp[P(idx, bits)] = res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\t//memset(dp, -1, sizeof(dp));\n\t\tdp.clear();\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, (1 << hs + 1) - 1) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<short, short, int>;\nmap<tup, int> dp;\nint tb[10][10];\nint sr, sc;\nint hs;\n\nint dfs(int nr, int nc, int bits) {\n\tif (dp.count(tup{ nr,nc,bits })) return dp[tup{nr, nc, bits}];\n\tif (nr == sr && nc == sc && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if(~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(i, nc, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(i, nc, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(nr, j, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(nr, j, bits | 1 << x);\n\t}\n\t\n\treturn dp[tup{nr, nc, bits}] = res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tdp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tcout << dfs(sr, sc, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&(house_num==0||((state>>(house_num-1))&1)==1)) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>12||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1){\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=12&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=12?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool ischeck(int s){\n  return (((last&s)) == last) ;\n}\nbool inside(char x, char y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(char x, char y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  if( ischeck(s) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      char tx = x + dx[k]*i;\n      char ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tchar tx = sx + dx[k]*i;\n\tchar ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n\n    dfs(sx,sy,0);\n    printf(\"%d\\n\",msi[state(sx,sy,0)]);\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < 20)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < 20) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w,h,n;\nint sx,sy;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nint F[15][15], id[15][15];\n\nint dfs(int S, int y, int x) {\n\n    // bitset<7> bit(S);\n    // cout << bit << \" \" << y << \" \" << x<< endl;\n    if(__builtin_popcount(S) == n) {\n        if(y == sy || x == sx) {\n            // cout << \"ADD ++ \";\n            // rep(i,v.size()) {\n            //     cout << v[i] << \" \";\n            // }\n            // cout << endl;\n            return 1;\n        }\n\n        return 0;\n    }\n\n    int ret = 0;\n\n    REP(i,y+1,h) {\n        if(F[i][x] == 1) {\n            if(S & (1<< id[i][x])) continue;\n            else {\n                // vector<int> t(v.begin(), v.end());\n                // t.push_back(id[i][x]);\n                // ret += dfs(S | (1<<id[i][x]), i, x, t);\n                ret += dfs(S | (1<<id[i][x]), i, x);\n                break;\n            }\n        }\n    }\n\n    for(int i=y-1; i>=0; i--) {\n        if(F[i][x] == 1) {\n            if(S & (1<< id[i][x])) continue;\n            else {\n                // vector<int> t(v.begin(), v.end());\n                // t.push_back(id[i][x]);\n                // ret += dfs(S | (1<<id[i][x]), i, x, t);\n                ret += dfs(S | (1<<id[i][x]), i , x);\n                break;\n            }\n        }\n    }\n\n    REP(j,x+1,w) {\n        if(F[y][j] == 1) {\n            if(S & (1<<id[y][j])) continue;\n            else {\n                // vector<int> t(v.begin(), v.end());\n                // t.push_back(id[y][j]);\n                // ret += dfs(S | (1<<id[y][j]) , y, j, t);\n                ret += dfs(S | (1<<id[y][j]), y, j);\n                break;\n            }\n        }\n    }\n\n    for(int j=x-1; j>=0; j--) {\n        if(F[y][j] == 1) {\n            if(S & (1<<id[y][j])) continue;\n            else {\n                // vector<int> t(v.begin(), v.end());\n                // t.push_back(id[y][j]);\n                // ret += dfs(S | (1<<id[y][j]) , y, j, t);\n                ret += dfs(S | (1<<id[y][j]), y , j);\n                break;\n            }\n        }\n    }\n\n    return ret;\n}\nint main() {\n    while(cin >> w >> h) {\n        if(w == 0 && h == 0) break;\n\n        memset(F,0,sizeof(F));\n        memset(id,0,sizeof(id));\n        n = 0;\n\n        rep(i,h) {\n            rep(j,w) {\n                cin >> F[i][j];\n\n                if(F[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                } else if(F[i][j] == 1) {\n                    id[i][j] = n;\n                    n++;\n                }\n            }\n        }\n\n        vector<int> v;\n        cout << dfs(0, sy, sx) << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, C, sx, sy; vector<vector<int> > M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint solve(int x, int y, int d, vector<vector<bool> > used)\n{\n\tif (d == C && x == sx && y == sy) { return 1; }\n\n\tint ret = 0;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint x2 = x + dx[dir];\n\t\tint y2 = y + dy[dir];\n\n\t\twhile (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t{\n\t\t\tif (used[y2][x2])\n\t\t\t{\n\t\t\t\tvector<vector<bool> > used2(used.begin(), used.end()); used2[y2][x2] = false;\n\n\t\t\t\tret += solve(x2, y2, d + 1, used2); break;\n\t\t\t}\n\t\t\t\n\t\t\tx2 += dx[dir];\n\t\t\ty2 += dy[dir];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tM = vector<vector<int> >(H, vector<int>(W));\n\n\t\tvector<vector<bool> > start(H, vector<bool>(W, false));\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &M[i][j]);\n\n\t\t\t\tif (M[i][j] != 0) { C++; start[i][j] = true; }\n\n\t\t\t\tif (M[i][j] == 2) { sx = j; sy = i; }\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve(sx, sy, 0, start));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <set>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nclass Edge{\npublic:\n    bool isAccess;\n    bitset<24> pass;\n    Edge(){\n        isAccess = false;\n    }\n};\n\nint n;\nvector<vector<Edge> > edges;\n\nint dfs(int curr, bitset<24> bs){\n    if(curr == 0 && bs.any()){\n        if(bs.count() == n)\n            return 1;\n        else\n            return 0;\n    }\n\n    int ret = 0;\n    for(int i=0; i<n; ++i){\n        if(bs[i] || !edges[curr][i].isAccess)\n            continue;\n        if((~bs & edges[curr][i].pass).any())\n            continue;\n        bs[i] = true;\n        ret += dfs(i, bs);\n        bs[i] = false;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        n = 1;\n        vector<int> y(1), x(1);\n        vector<vector<int> > grid(h, vector<int>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> grid[i][j];\n                if(grid[i][j] == 1){\n                    y.push_back(i);\n                    x.push_back(j);\n                    grid[i][j] = n;\n                    ++ n;\n                }else if(grid[i][j] == 2){\n                    y[0] = i;\n                    x[0] = j;\n                    grid[i][j] = 0;\n                }else{\n                    grid[i][j] = -1;\n                }\n            }\n        }\n\n        edges.assign(n, vector<Edge>(n, Edge()));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                int y1 = y[i] + dy[j];\n                int x1 = x[i] + dx[j];\n                bitset<24> bs;\n                while(0 <= y1 && y1 < h && 0 <= x1 && x1 < w){\n                    if(grid[y1][x1] != -1){\n                        int k = grid[y1][x1];\n                        edges[i][k].isAccess = true;\n                        edges[i][k].pass = bs;\n                        bs[k] = true;\n                    }\n                    y1 += dy[j];\n                    x1 += dx[j];\n                }\n            }\n        }\n\n        cout << dfs(0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint base_map[10][10],house_index[10][10];\nint H,W,finish_state;\nint church_row,church_col;\nint POW[24],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint ans;\n\nvoid recursive(int state,int row,int col){\n\n\tif(state == finish_state){\n\t\tif(row == church_row || col == church_col){\n\t\t\tans++;\n\t\t}\n\t\treturn;\n\t}\n\n\tint next_row,next_col,next_state;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tnext_row = row+diff_row[i];\n\t\tnext_col = col+diff_col[i];\n\n\t\twhile(rangeCheck(next_row,next_col) == true &&\n\t\t\t((base_map[next_row][next_col] != 1) || ((state & (1 << house_index[next_row][next_col])) != 0))){\n\t\t\tnext_row += diff_row[i];\n\t\t\tnext_col += diff_col[i];\n\t\t}\n\n\t\tif(!rangeCheck(next_row,next_col))continue;\n\n\t\tnext_state = state+POW[house_index[next_row][next_col]];\n\t\trecursive(next_state,next_row,next_col);\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\thouse_index[row][col] = -1;\n\t\t}\n\t}\n\n\tint index = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&base_map[row][col]);\n\t\t\tif(base_map[row][col] == 1){\n\t\t\t\thouse_index[row][col] = index++;\n\t\t\t}else if(base_map[row][col] == 2){\n\t\t\t\tchurch_row = row;\n\t\t\t\tchurch_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = 0,finish_state = POW[index]-1;\n\n\trecursive(0,church_row,church_col);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 24; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy,home;\nint field[16][16];\nint num[16][16];\nstack<int> st;\n\nclass state{\npublic:\n  int x,y,s;\n  state(int _x, int _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ // ÆÍ³ïÉßêé©Ç¤©\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = x + dx[k]*i;\n\tint ty = y + dy[k]*i;\n\tif( inside(tx,ty) || field[ty][tx]==1 )break;\n\n\tif( field[ty][tx]==2 ){\n#if DEB\n\t  printf(\"goal , (%d,%d)  s:%d\\n\",x,y,s);\n\t  stack<int> tmp = st;\n\t  while( !tmp.empty() ){\n\t    printf(\"%d,\",tmp.top());\n\t    tmp.pop();\n\t  }\n\t  puts(\"\\n\");\n#endif\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½ê\n    return msi[state(x,y,s)];\n  }\n\n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tif( s&(1<<num[ty][tx]) ) break;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif \n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n#if DEB\n\tst.pop();\n#endif\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n#if DEB\n    printf(\"home:%d  sx,sy = %d,%d\\n\",home,sx,sy);\n    rep(i,h){\n      rep(j,w){\n\tprintf(\"%2d \",num[i][j]);\n      }\n      puts(\"\");\n    }\n#endif   \n    dfs(sx,sy,0);\n    printf(\"%d\\n\",msi[state(sx,sy,0)]);\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint tab[12][12];\nint wx,wy;\nint nx,ny,rem;\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy;\n    nowx=nx;nowy=ny;\nLA:;\n   nowx++;\n   if(nowx>=wx) goto LB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB: ;        \n\n    nowx=nx,nowy=ny;\nMA:;\n   nowx--;\n   if(0>nowx) goto MB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto MB;\n   }\n   goto MA;\nMB: ;        \n\n    nowx=nx,nowy=ny;\nNA:;\n   nowy++;\n   if(nowy>=wy) goto NB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto NB;\n   }\n   goto NA;\nNB: ;        \n\n    nowx=nx,nowy=ny;\nOA:;\n   nowy--;\n   if(0>nowy) goto OB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;        \n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint px[24],py[24],kx,ky;\nint num[24][4] = {0};\n\nint H,W,N,ans;\nint field[12][12] = {0};\n\nint dx[] = {0,-1,0,1} , dy[] = {1,0,-1,0};\nbool done[12][12];\n\nint memo[24][1<<23] = {0};\n\nint dfs(int pos,int bit){\n\tif(~memo[pos][bit])return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\trep(d,4){\n\t\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\t\twhile( field[cy][cx] != -1){\n\t\t\t\tif(field[cy][cx] == 64)return 1;\n\t\t\t\tcy += dy[d] , cx += dx[d];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\trep(d,4){\n\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\twhile( field[cy][cx] == -2 || done[cy][cx] == 1 || field[cy][cx] == 64){\n\t\t\tcy += dy[d] , cx += dx[d];\n\t\t}\n\t\tif(field[cy][cx] != -1){\n\t\t\tdone[cy][cx] = 1;\n\t\t\tans += dfs(field[cy][cx],bit | (1<<field[cy][cx]) );\n\t\t\tdone[cy][cx] = 0;\n\t\t}\n\t}\n\treturn memo[pos][bit] = ans;\n}\n\nint main(){\n\twhile(cin >> W >> H ,W){\n\t\tN = ans = 0;\n\t\trep(i,24)rep(j,4)num[i][j] = -1;\n\t\trep(i,12)rep(j,12)field[i][j] = -1;\n\t\trep(i,H)rep(j,W){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tswitch(t){\n\t\t\tcase 0:\n\t\t\t\tfield[i+1][j+1] = -2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfield[i+1][j+1] = N;\n\t\t\t\tpx[N] = j+1, py[N] = i+1;\n\t\t\t\tN++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tkx = j+1 , ky = i+1;\n\t\t\t\tfield[i+1][j+1] = 64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpx[N] = kx , py[N] = ky;\n\t\trep(i,24)rep(j,1<<23)memo[i][j] = -1;\n\t\tcout << dfs(N,0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<int,int> dp[24];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(__builtin_popcount(vis)<18 && dp[id][vis])return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)<18)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    for(int i=0;i<pn;i++)dp[i].clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\nInt s[20][20],idx[20][20],cnt,pru;\nInt u[40][4];\nInt num[40],ok[40];\nvector<vector<vector<Int> > > G;\n\nunordered_map<int, int> dp;\nInt dfs(Int z,Int b){\n  if(b==0) dp.clear();\n  int hs=(b<<5)|z;\n  if((z&3)==0) if(dp.count(hs)) return dp[hs];\n\n  Int res=0;\n  \n  for(Int k=0;k<4;k++){\n    for(auto w:G[z][k]){\n      if((b>>w)&1) break;\n      Int nb=b^(1<<w),flg=1;\n      for(Int i=0;i<4;i++){\n\tif(u[w][i]>=cnt) continue; \n\tnum[u[w][i]]--;\n\tif((~nb>>u[w][i])&1)\n\t  flg&=num[u[w][i]]>=1;\n      }\n      if(flg){\n\tif(nb+1==(1<<cnt)) res+=ok[w];\n\telse if((nb&pru)!=pru) res+=dfs(w,nb);\n      }\n      for(Int i=0;i<4;i++) num[u[w][i]]++;\n    }\n  }\n  \n  if((z&3)==0) dp[hs]=res;\n  return res;\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    cnt=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tidx[i][j]=cnt;\n\tcnt+=s[i][j]==1;\n      }\n    }\n    \n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) idx[i][j]=cnt;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};    \n\n    G.clear();\n    G.resize(cnt+1);\n    \n    memset(num,0,sizeof(num));    \n    memset(ok,0,sizeof(ok));\n    \n    for(Int y=0;y<h;y++){\n      for(Int x=0;x<w;x++){\n\tif(s[y][x]==0) continue;\n\tInt z=idx[y][x];\n\tG[z].resize(4);\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y,nx=x;\n\t  while(1){\n\t    ny+=dy[k],nx+=dx[k];\n\t    while(in(ny,nx)&&s[ny][nx]==0)\n\t      ny+=dy[k],nx+=dx[k];\n\t    if(!in(ny,nx)) break;\t    \n\t    if(s[ny][nx]==2) ok[z]=1;\n\t    else G[z][k].emplace_back(idx[ny][nx]);\n\t  }\n\t}\n\t\n\tfor(Int k=0;k<4;k++){\n\t  u[z][k]=cnt+1;\n\t  for(auto w:G[z][k]){\n\t    u[z][k]=w;\n\t    num[w]++;\n\t    break;\n\t  }\n\t}\n\t\n\tif(z==cnt){\n\t  pru=0;\n\t  for(Int k=0;k<4;k++){\n\t    for(auto w:G[z][k]){\n\t      pru|=(1<<w);\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    cout<<dfs(cnt,0)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint tab[12][12];\nint wx,wy;\nint nx,ny,rem;\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy;\n    nowx=nx;nowy=ny;\nLA:\n   nowx++;\n   if(nowx>=wx) goto LB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB:         \n\n    nowx=nx,nowy=ny;\nMA:\n   nowx--;\n   if(0>nowx) goto MB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto MB;\n   }\n   goto MA;\nMB:         \n    nowx=nx,nowy=ny;\nNA:\n   nowy++;\n   if(nowy>=wy) goto NB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto NB;\n   }\n   goto NA;\nNB:        \n    nowx=nx,nowy=ny;\nOA:\n   nowy--;\n   if(0>nowy) goto OB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\nint n,m;\n\nint kx,ky;\nint field[11][11];\nint home;\n\nint dfs(int s,int x,int y){\n\tif(s==((1<<home)-1)){\n\t\tif(ky==y){\n\t\t\t// ÌûüÖ\n\t\t\tfor(int i = x-1; i >= 0; i--){\n\t\t\t\tif(field[y][i]==-1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(field[y][i]!=-2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = x+1; i < m; i++){\n\t\t\t\tif(field[y][i]==-1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(field[y][i]!=-2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif(kx==x){\n\t\t\t// ÌûüÖ\n\t\t\tfor(int i = y-1; i >= 0; i--){\n\t\t\t\tif(field[i][x]==-1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(field[i][x]!=-2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = y+1; i < m; i++){\n\t\t\t\tif(field[i][x]==-1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(field[i][x]!=-2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t}\n\telse{\n\t\t// Ü¾S[µÄ¢È¢ê\n\t\t// »Ýn©çÚ®Å«éêÖÚ®\n\t\t// ÌûüÖ\n\t\tint sum=0;\n\t\tfor(int i = x-1; i >= 0; i--){\n\t\t\tif(field[y][i]>=0){\n\t\t\t\tif(!((s>>field[y][i])&1)){\n\t\t\t\t\tsum+=dfs(s|(1<<field[y][i]),i,y);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//if(s==0){\n\t\t//\tcout<<endl;\n\t\t//}\n\t\tfor(int i = x+1; i < m; i++){\n\t\t\tif(field[y][i]>=0){\n\t\t\t\tif(!((s>>field[y][i])&1)){\n\t\t\t\t\tsum+=dfs(s|(1<<field[y][i]),i,y);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// ÌûüÖ\n\t\tfor(int i = y-1; i >= 0; i--){\n\t\t\tif(field[i][x]>=0){\n\t\t\t\tif(!((s>>field[i][x])&1)){\n\t\t\t\t\tsum+=dfs(s|(1<<field[i][x]),x,i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = y+1; i < m; i++){\n\t\t\tif(field[i][x]>=0){\n\t\t\t\tif(!((s>>field[i][x])&1)){\n\t\t\t\t\tsum+=dfs(s|(1<<field[i][x]),x,i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n}\n\nint main(){\n\n\twhile(cin>>m>>n&&!(n==0&&m==0)){\n\t\thome=0;\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t==1){\n\t\t\t\t\tfield[i][j]=home;\n\t\t\t\t\thome++;\n\t\t\t\t}\n\t\t\t\telse if(t==0){\n\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t}\n\t\t\t\telse if(t==2){\n\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\tkx=j;\n\t\t\t\t\tky=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(0,kx,ky)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint W, H, cnt, g[11][11], X[24], Y[24], memo[1 << 23][24];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nint rec(int S, int i) {\n\tif (S == (1 << cnt) - 1) {\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[i], ny = Y[i];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (g[ny][nx] == -1 || !in_range(nx, ny)) break;\n\t\t\t\tif (g[ny][nx] == -2) return 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tif (memo[S][i] != -1) return memo[S][i];\n\t\n\tint& res = memo[S][i];\n\tres = 0;\n\t\n\tfor_(d,0,4) {\n\t\tint nx = X[i], ny = Y[i];\n\t\t\n\t\tfor_(rep,0,10) {\n\t\t\tnx += dx[d];\n\t\t\tny += dy[d];\n\t\t\t\n\t\t\tif (g[ny][nx] == -1 || !in_range(nx, ny)) break;\n\t\t\tif (g[ny][nx] < -1) continue;\n\t\t\t\n\t\t\tint j = g[ny][nx];\n\t\t\t\t\t\t\n\t\t\tg[ny][nx] = -1;\n\t\t\tres += rec(S | 1 << j, j);\n\t\t\tg[ny][nx] = j;\n\t\t}\n\t}\n\t\t\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(S,0,1<<cnt) for_(i,0,24) memo[S][i] = -1;\n\tcout << rec(0, 23) << endl;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tcnt = 0;\n\t\t\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tcin >> g[y][x];\n\t\t\t\n\t\t\tif (g[y][x] == 0) g[y][x] = -3;\n\t\t\telse if (g[y][x] == 1) { X[cnt] = x; Y[cnt] = y; g[y][x] = cnt; ++cnt; }\n\t\t\telse if (g[y][x] == 2) { X[23] = x; Y[23] = y; g[y][x] = -2; }\n\t\t}\n\t\t\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second \n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;\n    vis=0;\n    vis|=(1<<houseId[si][sj]);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n\n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;\n    qs.pop();\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !( st_now.vis&(1<<houseId[next.fr][next.sc]) ) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis|=(1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\n\t    if(st_next.cnt == nhouse){\n\t      for(int l = 0; l < MAXDIR; ++l){\n\t\tif( M[st_next.ni][st_next.nj].cexist[l] ){\n\t\t  ++ans;\n\t\t}\n\t      }\n\t      break;\n\t    }else{\n\t      qs.push( st_next );\n\t      break;\n\t    }\n\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = UP; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp.find(P(bit,h)) != dp.end()){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) < 18) dp[P(bit,h)] = ret;\n  return ret;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint n,m,cx,cy,h;\nbool used[12][12];\nint f[12][12];\nint dfs(int x,int y,int k)\n{\n\tint res=0;\n\tif(k==0)\n\t{\n\t\tif(x==cx||y==cy)return 1;\n\t\telse return 0;\n\t}\n\tfor(int nx=x+1;nx<m;nx++)\n\t{\n\t\tif(!used[nx][y]&&f[nx][y]==1)\n\t\t{\n\t\t\tused[nx][y]=true;\n\t\t\tres+=dfs(nx,y,k-1);\n\t\t\tused[nx][y]=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int nx=x-1;nx>=0;nx--)\n\t{\n\t\tif(!used[nx][y]&&f[nx][y]==1)\n\t\t{\n\t\t\tused[nx][y]=true;\n\t\t\tres+=dfs(nx,y,k-1);\n\t\t\tused[nx][y]=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny=y+1;ny<n;ny++)\n\t{\n\t\tif(!used[x][ny]&&f[x][ny]==1)\n\t\t{\n\t\t\tused[x][ny]=true;\n\t\t\tres+=dfs(x,ny,k-1);\n\t\t\tused[x][ny]=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny=y-1;ny>=0;ny--)\n\t{\n\t\tif(!used[x][ny]&&f[x][ny]==1)\n\t\t{\n\t\t\tused[x][ny]=true;\n\t\t\tres+=dfs(x,ny,k-1);\n\t\t\tused[x][ny]=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(used,0,sizeof(used));\n\t\th=0;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j]==2)\n\t\t\t\t{\n\n\t\t\t\t\tcx=i,cy=j;\n\t\t\t\t\tf[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse if(f[i][j]==1)h++;\n\t\t\t}\n\t\t}\n\t\tcout << dfs(cx,cy,h) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 1 << 18;\nint W, H, fld[10][10];\nint P, sx, sy;\nint memo[MAX][10][10];\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (s < MAX)\n\t{\n\t\tif (memo[s][x][y] != -1) return memo[s][x][y];\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (s < MAX) memo[s][x][y] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfill_n((int*)memo, min(1 << P, MAX) * 10 * 10, -1);\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][12],int x,int y,int s,int t,int n,int p,int d,int e){\n  int i;\n  int sm=0;\n  for(x+=d,y+=e;a[x][y]!=-1;x+=d,y+=e){\n    if(a[x][y]==1){\n      if(p==n){\n\tif(x==s){\n\t  for(i=y+((t-y)>0?1:-1);a[x][i]!=-1&&a[x][i]!=2;i+=((t-y)>0?1:-1));\n\t  if(a[x][i]==2)\n\t    sm+=1;\n\t}else if(y==t){\n\t  for(i=x+((s-x)>0?1:-1);a[i][y]!=-1&&a[i][y]!=2;i+=((s-x)>0?1:-1));\n\t  if(a[i][y]==2)\n\t    sm+=1;\n\t}\n      }else{\n\ta[x][y]=-1;\n\tsm+=f(a,x,y,s,t,n,p+1,-1,0);\n\tsm+=f(a,x,y,s,t,n,p+1,0,-1);\n\tsm+=f(a,x,y,s,t,n,p+1,1,0);\n\tsm+=f(a,x,y,s,t,n,p+1,0,1);\n\ta[x][y]=1;\n      }\n    }\n  }\n  return sm;\n}\nint main(){\n  int i,j;\n  int a[12][12],w,h,n,x,y;\n  int sm;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    n=0;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>a[j][i];\n\tif(a[j][i]==1)\n\t  n++;\n\telse if(a[j][i]==2){\n\t  x=j;\n\t  y=i;\n\t}\n      }\n    }\n    sm=0;\n    sm+=f(a,x,y,x,y,n,1,-1,0);\n    sm+=f(a,x,y,x,y,n,1,0,-1);\n    sm+=f(a,x,y,x,y,n,1,1,0);\n    sm+=f(a,x,y,x,y,n,1,0,1);\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[++p] = i, y[p] = j, dat[i][j] = p;\n\t\t\tif (f[i][j] == 2)x[0] = i, y[0] = j;\n\t\t}p++;\n\t\tmap<P, int>dp;\n\t\tdp[{0, 0}] = 1;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif ((f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) || (f[nx][ny] == 2 && i == (1 << p) - 2)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[{(1 << p) - 1, 0}]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[24], y[24], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[++p] = i, y[p] = j, dat[i][j] = p;\n\t\t\tif (f[i][j] == 2)x[0] = i, y[0] = j, dat[i][j] = 0;\n\t\t}p++;\n\t\tmap<P, int>dp;\n\t\tdp[{0, 0}] = 1;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif ((f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) || (f[nx][ny] == 2 && i == (1 << p) - 2)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[{(1 << p) - 1, 0}]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 15 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#define rep(i, n) for ( int i = 0; i < n; i++)\nusing namespace std;\n\n#define MAX 10\n\n#define HOUSE 3\n#define SPACE 0\n#define SMOKE 1\n#define START 2\n#define BLOCK 4\n/*\n#define HOUSE '3'\n#define SPACE '0'\n#define SMOKE '1'\n#define START '2'\n#define BLOCK 'X'\n*/\n\nint H, W;\nclass State{\npublic:\n  unsigned short pi, pj, total;\n  //unsigned short G[MAX+2][MAX+2];\n  //char G[MAX+2][MAX+2];\n  bool V[MAX+2][MAX+2];\n\n  State(){total = 0;}\n  //State(int H, int W):H(H), W(W){ total = 0;}\n\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\t//if ( G[i][j] == s.G[i][j] ) continue;\n\t//return G[i][j] < s.G[i][j];\n\tif ( V[i][j] == s.V[i][j] ) continue;\n\treturn V[i][j] < s.V[i][j];\n      }\n    }\n    return false;\n  }\n\n};\n\nstatic int di[4] = {0, -1, 0, 1};\nstatic int dj[4] = {1, 0, -1, 0};\n\nint  G[MAX+2][MAX+2];\n\n\nmain(){\n  int si, sj;\n\n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    int total = 0;\n\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) G[i][j] = BLOCK;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\tcin >> G[i][j];\n\tif ( G[i][j] == START ){ si = i; sj = j;}\n\tif ( G[i][j] == SMOKE ) total++;\n      }\n    }\n\n    /*\n    bool zero[MAX+2];\n    int tmp[MAX+2][MAX+2];\n    for ( int i = 1; i <= H; i++ ) zero[i] = true;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) tmp[i][j] =  G[i][j];\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 1; j <= W; j++ ) if ( G[i][j] ) zero[i] = false;\n    int ii = 0;\n    int c = 0;\n    for ( int i = 0; i < H+2; i++ ){\n      if ( zero[i] ) { c++; continue;}\n      for ( int j = 0; j < W+2; j++ ) G[ii][j] = tmp[i][j];\n      ii++;\n    }\n    H -= c;\n\n    for ( int j = 1; j <= W; j++ ) zero[j] = true;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) tmp[i][j] =  G[i][j];\n    for ( int j = 1; j <= W; j++ ) \n      for ( int i = 0; i < H+2; i++ )\n\tif ( G[i][j] ) zero[j] = false;\n    \n    int jj = 0;\n    c = 0;\n    for ( int j = 0; j < W+2; j++ ){\n      if ( zero[j] ) { c++; continue;}\n      for ( int i = 0; i < H+2; i++ ) G[i][jj] = tmp[i][j];\n      jj++;\n    }\n    W -= c;\n\n    */\n\n\n    State s = State();\n    \n    for ( int i = 0; i <= H+1; i++ )\n      for ( int j = 0; j <= W+1; j++ ) s.V[i][j] = ((G[i][j]==SMOKE)?true:false);\n    \n    map<State, int> M;\n    State v;\n\n    int ni, nj;\n    M[s] = 0;\n    \n    for ( int r = 0; r < 4; r++ ){\n      ni = si + di[r];\n      nj = sj + dj[r];\n\n      while(1){\n\t//if ( s.G[ni][nj] == SMOKE ){\n\tif ( s.V[ni][nj] ){\n\t  v = s;\n\t  v.pi = ni;\n\t  v.pj = nj;\n\t  //v.G[ni][nj] = HOUSE;\n\t  v.V[ni][nj] = false;\n\t  v.total = 1;\n\t  M[v] = 1;\n\t  break;\n\t} else if ( G[ni][nj] == BLOCK ) break;\n\tni += di[r];\n\tnj += dj[r];\n      }\n    }\n\n    map<State, int>::iterator it;\n    \n    int presize = M.size();\n\n    int cc = 0;\n    int x = 0;\n    bool f;\n    map<State, int> nM;\n\n    \n    while(1){\n      //      nM = map<State, int>();\n      nM.clear();\n      f = true;\n      for ( it = M.begin(); it != M.end(); it++ ){\n\tState cur = (*it).first;\n\tint cost = (*it).second;\n\tif ( cost == 0 ) continue;\n\n\tfor ( int r = 0; r < 4; r++ ){\n\t  ni = cur.pi + di[r];\n\t  nj = cur.pj + dj[r];\n\n\t  while(1){\n\t    //if ( cur.G[ni][nj] == SMOKE ){\n\t    if ( cur.V[ni][nj]){\n\t      v = cur;\n\t      v.pi = ni;\n\t      v.pj = nj;\n\t      //v.G[ni][nj] = HOUSE;\n\t      v.V[ni][nj] = false;\n\t      v.total++;\n\t      f = false;\n\t      nM[v] += cost;\n\t      break;\n\t      //\t    } else if ( cur.G[ni][nj] == START && cur.total == total ){\n\t    } else if ( ni == si && nj == sj && cur.total == total ){\n\t      x += cost;\n\t      break;\n\t    } else if ( G[ni][nj] == BLOCK ) {\n\t      break;\n\t    }\n\n\t    ni += di[r];\n\t    nj += dj[r];\n\t  }\n\t}\n      }\n      if ( f ) break;\n      M = nM;\n    }\n\n    cout << x << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nint adj[24][4][23];\nint deg[24][4],house_num;\nmap<int,int> dp[23];\n\nint dfs(int id,int picked){\n\t// if(id==house_num) return picked==(1<<(house_num+1))-1;\n\tif(id==house_num){\n\t\treturn picked==(1<<(house_num+1))-1;\n\t}\n\n\tint ans=0;\n\trep(k,4){\n\t\trep(a,deg[id][k]){\n\t\t\tint next_id=adj[id][k][a];\n\t\t\tif((picked&(1<<next_id))==0){\n\t\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\trep(k,4){\n\t\t\tif(deg[house_num][k]>0){\n\t\t\t\tint id=adj[house_num][k][0];\n\t\t\t\tans+=dfs(id,1<<id);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#define rep(i, n) for ( int i = 0; i < n; i++)\nusing namespace std;\n\n#define MAX 10\n\n#define HOUSE 3\n#define SPACE 0\n#define SMOKE 1\n#define START 2\n#define BLOCK 4\n/*\n#define HOUSE '3'\n#define SPACE '0'\n#define SMOKE '1'\n#define START '2'\n#define BLOCK 'X'\n*/\nclass State{\npublic:\n  int pi, pj, H, W, total;\n  //unsigned short G[MAX+2][MAX+2];\n  //char G[MAX+2][MAX+2];\n  bool V[MAX+2][MAX+2];\n\n  State(){total = 0;}\n  State(int H, int W):H(H), W(W){ total = 0;}\n\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\t//if ( G[i][j] == s.G[i][j] ) continue;\n\t//return G[i][j] < s.G[i][j];\n\tif ( V[i][j] == s.V[i][j] ) continue;\n\treturn V[i][j] < s.V[i][j];\n      }\n    }\n    return false;\n  }\n\n};\n\nstatic int di[4] = {0, -1, 0, 1};\nstatic int dj[4] = {1, 0, -1, 0};\n\nint W, H, G[MAX+2][MAX+2];\n\n\nmain(){\n  int si, sj;\n\n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    int total = 0;\n\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) G[i][j] = BLOCK;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\tcin >> G[i][j];\n\tif ( G[i][j] == START ){ si = i; sj = j;}\n\tif ( G[i][j] == SMOKE ) total++;\n      }\n    }\n\n    /*\n    bool zero[MAX+2];\n    int tmp[MAX+2][MAX+2];\n    for ( int i = 1; i <= H; i++ ) zero[i] = true;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) tmp[i][j] =  G[i][j];\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 1; j <= W; j++ ) if ( G[i][j] ) zero[i] = false;\n    int ii = 0;\n    int c = 0;\n    for ( int i = 0; i < H+2; i++ ){\n      if ( zero[i] ) { c++; continue;}\n      for ( int j = 0; j < W+2; j++ ) G[ii][j] = tmp[i][j];\n      ii++;\n    }\n    H -= c;\n\n    for ( int j = 1; j <= W; j++ ) zero[j] = true;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) tmp[i][j] =  G[i][j];\n    for ( int j = 1; j <= W; j++ ) \n      for ( int i = 0; i < H+2; i++ )\n\tif ( G[i][j] ) zero[j] = false;\n    \n    int jj = 0;\n    c = 0;\n    for ( int j = 0; j < W+2; j++ ){\n      if ( zero[j] ) { c++; continue;}\n      for ( int i = 0; i < H+2; i++ ) G[i][jj] = tmp[i][j];\n      jj++;\n    }\n    W -= c;\n\n    */\n\n\n    State s = State(H, W);\n    \n    for ( int i = 0; i <= H+1; i++ )\n      for ( int j = 0; j <= W+1; j++ ) s.V[i][j] = ((G[i][j]==SMOKE)?true:false);\n    \n    map<State, int> M;\n    State v;\n\n    int ni, nj;\n    M[s] = 0;\n    \n    for ( int r = 0; r < 4; r++ ){\n      ni = si + di[r];\n      nj = sj + dj[r];\n\n      while(1){\n\t//if ( s.G[ni][nj] == SMOKE ){\n\tif ( s.V[ni][nj] ){\n\t  v = s;\n\t  v.pi = ni;\n\t  v.pj = nj;\n\t  //v.G[ni][nj] = HOUSE;\n\t  v.V[ni][nj] = false;\n\t  v.total = 1;\n\t  M[v] = 1;\n\t  break;\n\t} else if ( G[ni][nj] == BLOCK ) break;\n\tni += di[r];\n\tnj += dj[r];\n      }\n    }\n\n    map<State, int>::iterator it;\n    \n    int presize = M.size();\n\n    int cc = 0;\n    int x = 0;\n    bool f;\n    map<State, int> nM;\n\n    \n    while(1){\n      //      nM = map<State, int>();\n      nM.clear();\n      f = true;\n      for ( it = M.begin(); it != M.end(); it++ ){\n\tState cur = (*it).first;\n\tint cost = (*it).second;\n\tif ( cost == 0 ) continue;\n\n\tfor ( int r = 0; r < 4; r++ ){\n\t  ni = cur.pi + di[r];\n\t  nj = cur.pj + dj[r];\n\n\t  while(1){\n\t    //if ( cur.G[ni][nj] == SMOKE ){\n\t    if ( cur.V[ni][nj]){\n\t      v = cur;\n\t      v.pi = ni;\n\t      v.pj = nj;\n\t      //v.G[ni][nj] = HOUSE;\n\t      v.V[ni][nj] = false;\n\t      v.total++;\n\t      f = false;\n\t      nM[v] += cost;\n\t      break;\n\t      //\t    } else if ( cur.G[ni][nj] == START && cur.total == total ){\n\t    } else if ( ni == si && nj == sj && cur.total == total ){\n\t      x += cost;\n\t      break;\n\t    } else if ( G[ni][nj] == BLOCK ) {\n\t      break;\n\t    }\n\n\t    ni += di[r];\n\t    nj += dj[r];\n\t  }\n\t}\n      }\n      if ( f ) break;\n      M = nM;\n    }\n\n    cout << x << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 21;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX && !(cnt >= 16 && sum == 0)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tint a[12][12];\n\t\t\n\t\tscanf(\"%d%d\",&m,&n); if(m == 0 && n == 0)break;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x[25],y[25];\n\t\tint k = 1;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tif(a[i][j] == 1){\n\t\t\t\t\tx[k] = i;\n\t\t\t\t\ty[k] = j;\n\t\t\t\t\tk ++;\n\t\t\t\t}\n\t\t\t\telse if(a[i][j] == 2){\n\t\t\t\t\tx[0] = i;\n\t\t\t\t\ty[0] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint d[25][25];\n\t\trep(i,k){\n\t\t\tfor(int j = i+1 ; j < k ; j ++){\n\t\t\t\tif(x[i] == x[j]){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\trep(t,k){\n\t\t\t\t\t\tif(x[t] == x[i] && (y[t]-y[i])*(y[t]-y[j]) < 0){\n\t\t\t\t\t\t\td[i][j] |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(y[i] == y[j]){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\trep(t,k){\n\t\t\t\t\t\tif(y[t] == y[i] && (x[t]-x[i])*(x[t]-x[j]) < 0){\n\t\t\t\t\t\t\td[i][j] |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td[i][j] = (1 << k)-1;\n\t\t\t\t}\n\t\t\t\td[j][i] = d[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<P,int> dp;\n\t\tint ret = 0;\n\t\t\n\t\trep1(i,k-1){\n\t\t\tif(x[i] == x[0] || y[i] == y[0]){\n\t\t\t\tdp.insert( P1( P ( 1 << i , i ) , 1 ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<P,int>::iterator itr = dp.begin();\n\t\twhile(itr != dp.end()){\n\t\t\tif((*itr).fr.sc == 0){\n\t\t\t\tif((*itr).fr.fr == (1 << k) -1){\n\t\t\t\t\tret += (*itr).sc;\n\t\t\t\t}\n\t\t\t\titr ++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i,k){\n\t\t\t\tif(((*itr).fr.fr >> i)&1)continue;\n\t\t\t\tif((d[(*itr).fr.sc][i] & (*itr).fr.fr) == 0){\n\t\t\t\t\tdp[ P ( (*itr).fr.fr | (1 << i) , i ) ] += (*itr).sc;\n\t\t\t\t}\n\t\t\t}\n\t\t\titr ++;\n\t\t}\n\t\t\t\t\n\t\t\n\t\t/*queue<P> que;\n\t\t\n\t\trep1(i,k-1){\n\t\t\tif(x[i] == x[0] || y[i] == y[0]){\n\t\t\t\tque.push( P ( i , 1 << i ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif(p.fr == 0){\n\t\t\t\tif(p.sc == (1 << k)-1)ret ++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i,k){\n\t\t\t\tif((p.sc >> i)&1)continue;\n\t\t\t\tif((d[p.fr][i] & p.sc) == 0){\n\t\t\t\t\tque.push( P ( i , p.sc | (1 << i) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   (a >> b) & 1\n#define bitset(a,b)       a |= (1 << b)\n#define bitunset(a,b)    a &= ~(1 << b)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w,h;\n\tscanf(\"%d %d\", &w, &h);\n\tvector<vector<int>> mp(w,vector<int>(h,-1));\n\tpii cha;\n\tvector<pii> homp;\n\tint homc = 0;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tint a = 0;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (a == 2) {\n\t\t\t\tcha = { j,i };\n\t\t\t}\n\t\t\tif (a == 1) {\n\t\t\t\thomp.push_back({ j,i });\n\t\t\t\tmp[j][i] = homc;\n\t\t\t\thomc++;\n\t\t\t}\n\t\t}\n\t}\n\thomp.push_back(cha);\n\tmap<pii, int> dp[2];//?±\\??´????????¨??°\n\tdp[0][{0, homc}] = 1;\n\tbool t = 0;\n\tREP(i,homc){\n\t\tfor(auto cur : dp[t]) {\n\t\t\tpii curpos = homp[cur.first.second];\n\t\t\tint cnum;\n\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t}\n\t\tdp[t].swap(map<pii,int>());\n\t\tt = 1 - t;\n\t}\n\tint cnum,ans = 0;\n\tset<int> targets;\n\tfor (int j = cha.first; w > j; j++) {\n\t\tcnum = mp[j][cha.second];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.first; 0 <= j; j--) {\n\t\tcnum = mp[j][cha.second];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.second; h > j; j++) {\n\t\tcnum = mp[cha.first][j];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.second; 0 <= j; j--) {\n\t\tcnum = mp[cha.first][j];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (auto cur : dp[t]) {\n\t\tif(targets.find(cur.first.second) != targets.end())\n\t\t\tans += cur.second;\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n\nusing namespace std;\n\nint x,y;\nint field[10][10];\nint field3[10][10];\nmap<int,int> memo[24];\nint gx,gy;\nint home;\nint ans;\nbool hm[24];\nint dx[5]={0,0,1,0,-1};\nint dy[5]={0,1,0,-1,0};\n\nvoid dfs(int mx,int my,int ho2,int field2[10][10]){\n\tif(field2[mx][my]==2 && ho2==0)ans++;\n\telse{\n\t\tif(field2[mx][my]==1){\n\t\t\tfield2[mx][my]=3;\n\t\t\tfor(int i=1;i<=4;i++){\n\t\t\t\tint kx=mx,ky=my;\n\t\t\t\twhile(kx>=0 && kx<x && ky>=0 && ky<y){\n\t\t\t\t\tkx+=dx[i],ky+=dy[i];\n\t\t\t\t\tif(field2[kx][ky]==1){\n\t\t\t\t\t\tdfs(kx,ky,ho2-1,field2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(field2[kx][ky]==2 && ho2==0){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield2[mx][my]=1;\n\t\t}\n\t\tif(field2[mx][my]==2){\n\t\t\tfor(int i=1;i<=4;i++){\n\t\t\t\tint kx=mx,ky=my;\n\t\t\t\twhile(kx>=0 && kx<x && ky>=0 && ky<y){\n\t\t\t\t\tkx+=dx[i],ky+=dy[i];\n\t\t\t\t\tif(field2[kx][ky]==1){\n\t\t\t\t\t\tdfs(kx,ky,ho2-1,field2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\thome=0;\n\t\tans=0;\n\t\tmemset(hm,false,sizeof(hm));\n\t\tmemset(field3,-1,sizeof(field3));\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&field[j][i]);\n\t\t\t\tif(field[j][i]==2)field3[j][i]=0,gx=j,gy=i;\n\t\t\t\tif(field[j][i]==1)home++,field3[j][i]=home;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<24;i++){\n            memo[i].clear();\n        }\n\t\tdfs(gx,gy,home,field);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nll w,h,g[10][10];\nll cx,cy;\nvector<P> doko(ll y,ll x){\n\tvector<P> v;\n\tfor(ll nx=x+1;nx<w;nx++){\n\t\tif(g[y][nx]==-1) break;\n\t\tif(g[y][nx]) v.push_back(P(y,nx));\n\t}\n\tfor(ll nx=x-1;nx>=0;nx--){\n\t\tif(g[y][nx]==-1) break;\n\t\tif(g[y][nx]) v.push_back(P(y,nx));\n\t}\n\tfor(ll ny=y+1;ny<h;ny++){\n\t\tif(g[ny][x]==-1) break;\n\t\tif(g[ny][x]) v.push_back(P(ny,x));\n\t}\n\tfor(ll ny=y-1;ny>=0;--ny){\n\t\tif(g[ny][x]==-1) break;\n\t\tif(g[ny][x]) v.push_back(P(ny,x));\n\t}\n\treturn v;\n}\nll n;\nll dfs(ll y,ll x,ll cnt){\n\tll res=0;\n\tvector<P> v=doko(y,x);\n\tif(cnt==n){\n\t\tfor(ll i=0;i<v.size();i++){\n\t\t\tif(g[v[i].first][v[i].second]==2) return 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(cnt) g[y][x]=-1;\n\tfor(ll i=0;i<v.size();i++){\n\t\tif(g[v[i].first][v[i].second]==2) continue;\n\t\tres+=dfs(v[i].first,v[i].second,cnt+1);\n\t}\n\tg[y][x]=1;\n\treturn res;\n}\n\nint main()\n{while(1){\n\tscanf(\"%lld%lld\",&w,&h);\n\tif(!w) return 0;\n\tfor(ll i=0;i<h;i++) for(ll j=0;j<w;j++){\n\t\tscanf(\"%lld\",&g[i][j]);\n\t\tif(g[i][j]==2){\n\t\t\tcx=j,cy=i;\n\t\t}\n\t\telse if(g[i][j]) n++;\n\t}\n\tprintf(\"%lld\\n\",dfs(cy,cx,0));\n}}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\n\tint ans=0;\n\trep(k,4) rep(a,deg[id][k]) {\n\t\tint next_id=adj[id][k][a];\n\t\tif((picked&(1<<next_id))==0){\n\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(dp[id].size()<100000) dp[id][picked]=ans;\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    if(ni==t.ni){\n      if(nj==t.nj){\n\treturn vis<t.vis;\n      }else return nj < t.nj;\n    }else return ni < t.ni;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  //set<state> visited;\n  qs.push( init );\n  //visited.insert(init);\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    //    bool bCont=false;\n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    bool bCont=false;\n    for(int i = 0; i < MAX; ++i){\n      for(int j = 0; j < MAX; ++j){\n\tif( M[i][j].isHouse || M[i][j].isCharch ){\n\t  if( M[i][j].isHouse ){\n\t    if( st_now.vis&(1<<houseId[i][j]) ) continue;\n\t  }\n\t  int left=0;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    left+=M[i][j].link[k].size() + (M[i][j].cexist[k]?1:0);\n\t    for(int v = 0; v < M[i][j].link[k].size(); ++v){\n\t      pi house = M[i][j].link[k][v];\n\t      if( st_now.vis&(1<<houseId[house.fr][house.sc]) )\n\t\t--left;\n\t    }\n\t  }\n\t  if(left==0){\n\t    //cout << i << ' ' << j << \" left : \" << left << endl;\n\t    bCont=true;break;\n\t  }\n\t}\n      }\n      if(bCont)break;\n    }\n    if(bCont)continue;\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.cnt++;\n\t    st_next.vis |= ( 1<<houseId[next.fr][next.sc] );\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint W, H, cnt, g[11][11], X[24], Y[24];\nunordered_map< int, int > memo[24];\n\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nint rec(int S, int i) {\n\tif (S == (1 << cnt) - 1) {\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[i], ny = Y[i];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (!in_range(nx, ny)) break;\n\t\t\t\tif (g[ny][nx] == -1) break;\n\t\t\t\tif (g[ny][nx] == -2) return 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tif (memo[i].count(S)) return memo[i][S];\n\t\n\tint res = 0;\n\t\n\tfor_(j,0,cnt) {\n\t\tif (S >> j & 1) continue;\n\t\t\n\t\tbool isok = false;\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[j], ny = Y[j];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (!in_range(nx, ny)) break;\n\t\t\t\t\n\t\t\t\tisok |= (X[i] == nx && Y[i] == ny);\n\t\t\t\tif (isok) break;\n\t\t\t\t\n\t\t\t\tif (g[ny][nx] == -1) break;\n\t\t\t\tisok |= (g[ny][nx] >= 0);\n\t\t\t\tif (isok) break;\n\t\t\t}\n\t\t\t\n\t\t\tif (isok) break;\n\t\t}\n\t\t\n\t\tif (!isok) return (__builtin_popcount(S) >= 5 ? memo[i][S] = 0 : 0);\n\t}\n\t\n\tfor_(d,0,4) {\n\t\tint nx = X[i], ny = Y[i];\n\t\t\n\t\tfor_(rep,0,10) {\n\t\t\tnx += dx[d];\n\t\t\tny += dy[d];\n\t\t\t\n\t\t\tif (!in_range(nx, ny)) break;\n\t\t\tif (g[ny][nx] == -1) break;\n\t\t\tif (g[ny][nx] < -1) continue;\n\t\t\t\n\t\t\tint j = g[ny][nx];\n\t\t\t\t\t\t\n\t\t\tg[ny][nx] = -1;\n\t\t\tres += rec(S | 1 << j, j);\n\t\t\tg[ny][nx] = j;\n\t\t}\n\t}\n\t\t\n\treturn (__builtin_popcount(S) >= 5 ? memo[i][S] = res : res);\n}\n\nvoid solve() {\n\tfor_(i,0,24) memo[i].clear();\n\tcout << rec(0, 23) << endl;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tcnt = 0;\n\t\t\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tcin >> g[y][x];\n\t\t\t\n\t\t\tif (g[y][x] == 0) g[y][x] = -3;\n\t\t\telse if (g[y][x] == 1) { X[cnt] = x; Y[cnt] = y; g[y][x] = cnt; ++cnt; }\n\t\t\telse if (g[y][x] == 2) { X[23] = x; Y[23] = y; g[y][x] = -2; }\n\t\t}\n\t\t\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\nusing namespace std;\n\nconst int MAX = 10;\nconst int MAX_N = 23;\nconst int G = 23;\nconst int dy[] = {1,0,-1,0};\nconst int dx[] = {0,1,0,-1};\n\nint mask[MAX_N+1][MAX_N+1];\nshort node_id[MAX_N+1][MAX_N+1];\nshort grid[MAX][MAX];\n\nint H,W,N;\n\ntypedef pair<char,int>P;\nmap<P,int>dp; // dp[MAX][(1 << MAX_N)]\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> grid[i][j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_N+1 ; i++){\n    for(int j = 0 ; j < MAX_N+1 ; j++){      \n      node_id[i][j] = -1;\n      mask[i][j] = -1;\n    }\n  }\n  dp.clear();\n}\n\nvoid makeMask(){\n  N = 0;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] == 1)node_id[i][j] = N++;\n      if(grid[i][j] == 2)node_id[i][j] = G;\n    }\n  }\n  \n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] != 0){\n\tfor(int d = 0 ; d < 4 ; d++){\n\t  int x = j;\n\t  int y = i;\n\t  int bit = 0;\n\t  while(1){\n\t    x += dx[d]; y += dy[d];\n\t    if(!(0 <= x && x < W && 0 <= y && y < H))break;\n\t    if(node_id[y][x] == -1)continue;\n\t    if(node_id[y][x] != G){\n\t      bit |= (1 << node_id[y][x]);\n\t    }\n\t    mask[node_id[i][j]][node_id[y][x]] = bit;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint rec(int now,int bit){\n  P state = P(now,bit);\n  if(dp.count(state))return dp[state];\n  if(bit == (1 << N)-1){\n    if((mask[now][G] & bit) == 0)return dp[state] = 1;\n    else return dp[state] = 0;\n  }\n  for(int to = 0 ; to < N ; to++){\n    if((mask[now][to] & bit) == 0){\n      dp[state] += rec(to,bit|(1 << to));\n    }\n  }\n  return dp[state];\n}\n\n\nint main(){\n  while(cin >> W >> H,H|W){\n\n    init();\n    input();\n    makeMask();\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      if(mask[G][i] != -1)res += rec(i,(1 << i));\n    }\n    cout << res << endl;\n    /*\n    // dp init\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = 0;\n      }\n    }\n    \n    // dp start\n    for(int i = 0 ; i < N ; i++){\n      if(mask[G][i] != -1)dp[i][(1 << i)] = 1;\n    }\n    \n    //cout << \"N = \" << N << endl;\n    for(int i = 0 ; i < (1 << N) ; i++){\n      for(int j = 0 ; j < N ; j++){\n      //if(dp[i][j] == 0)continue;\n\tfor(int k = 0 ; k < N ; k++){\n\t  //cout <<\"mask = \" <<  mask[j][k] << endl;\n\t  if((mask[j][k] & i) == 0){\n\t    dp[k][i|(1 << k)] += dp[j][i];\n\t  }\n\t}\n      }\n    }\n\n    // dp goal\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      if(mask[i][G] != -1 && ((mask[i][G]&((1 << N)-1)) == 0))res += dp[i][(1 << N)-1];\n    }\n    cout << res << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nint M, N, numHouse;\nint map[12][12];\nint neighbors[30];\nint dp[1<<24];\n\nint rec(int cur, int nxt){\n    if(cur + 1 == (1 << (numHouse + 1))){\n        return 1;\n    }\n\n    if(dp[cur] != -1){\n        return dp[cur];\n    }\n\n    int res = 0, _nxt = nxt;\n    while(_nxt > 0){\n        int i = __builtin_popcount((_nxt & -_nxt) - 1),\n            ncur = cur | (1 << i),\n            nnxt = neighbors[i] & ~ncur;\n\n        res += rec(ncur, nnxt);\n\n        _nxt -= _nxt & -_nxt;\n    }\n\n    return dp[cur] = res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> M >> N;\n\n        if(M == 0){\n            break;\n        }\n\n        numHouse = 0;\n        memset(neighbors, 0, sizeof(neighbors));\n        memset(dp, -1, sizeof(dp));\n\n        for(int i=0;i<N;++i){\n            for(int j=0;j<M;++j){\n                std::cin >> map[i][j];\n            }\n        }\n\n        for(int i=0;i<N;++i){\n            for(int j=0;j<M;++j){\n                if(map[i][j] == 1){ // 家に 2, 3, ... と番号付け\n                    numHouse += 1;\n                    map[i][j] = numHouse + 1;\n                }else if(map[i][j] == 2){ // 教会の番号は 1\n                    map[i][j] = 1;\n                }\n            }\n        }\n\n        for(int i=0;i<N;++i){\n            for(int j=0;j<M;++j){\n                if(map[i][j] == 0){\n                    continue;\n                }\n\n                int idx = map[i][j] - 1; // 以降では 0-based を使う\n                for(int k=j-1;k>=0;--k){ // 左\n                    if(map[i][k] > 0){\n                        neighbors[idx] |= 1 << (map[i][k] - 1);\n                        break;\n                    }\n                }\n\n                for(int k=j+1;k<M;++k){ // 右\n                    if(map[i][k] > 0){\n                        neighbors[idx] |= 1 << (map[i][k] - 1);\n                        break;\n                    }\n                }\n\n                for(int k=i-1;k>=0;--k){ // 上\n                    if(map[k][j] > 0){\n                        neighbors[idx] |= 1 << (map[k][j] - 1);\n                        break;\n                    }\n                }\n\n                for(int k=i+1;k<N;++k){ // 下\n                    if(map[k][j] > 0){\n                        neighbors[idx] |= 1 << (map[k][j] - 1);\n                        break;\n                    }                \n                }\n            }\n        }\n\n        int res = rec(1, neighbors[0]);\n        std::cout << res << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define fr first\n#define sc second\n#define MAXDIR 4\n\n//vector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(char si, char sj, char cnt, int vis):ni(si),nj(sj),cnt(cnt),vis(vis){}\n};\n\n//void bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nclass Queue{\nprivate:\n  int p;\n  state *V;\npublic:\n  Queue():p(0){V=new state[1<<20];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){V[p++]=t;}\n  state * front(){return &V[p-1];}\n  void pop(){--p;}\n  bool empty(){return p==0;}\n};\n\nvoid bfs(const Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  int ni,nj;\n  int housenum=0;\n  int chi=charch.fr;int chj=charch.sc;\n  \n  for(int k = 0; k < MAXDIR; ++k){\n    housenum += M[chi][chj].linkmax[k];\n  }\n  \n  while(!qs.empty()){\n    state st_now = *( qs.front() );\n    ni = st_now.ni;\n    nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }else{\n\n      int left = housenum;\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  left-=(bool)(st_now.vis&(1<<houseId[hs.fr][hs.sc]));\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n      \n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  int mask=1<<houseId[next.fr][next.sc];\n\t  if( !(st_now.vis&mask) ){\n\t    qs.push( state(next.fr,next.sc,st_now.cnt + 1,st_now.vis|mask) );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &iM[i][j]);\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc,0,0);\n    bfs(M,init,nhouse,ans);\n    printf(\"%d\\n\", ans);\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nbool hs[10][10];\nbool used[10][10];\nint cx,cy;\nint ans;\nint nh;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\nvoid dfs(int x,int y,int f){\n\tif(f==nh){\n\t\tif(x==cx||y==cy)ans++;\n\t\treturn;\n\t}\n\tint i,j;\n\tfor(i=0;i<4;i++){\n\t\tfor(j=1;j<10;j++){\n\t\t\tint nx=x+j*dx[i];\n\t\t\tint ny=y+j*dy[i];\n\t\t\tif(nx<0||nx>=h||ny<0||ny>=w)break;\n\t\t\tif(hs[nx][ny]){\n\t\t\t\tif(!used[nx][ny]){\n\t\t\t\t\tused[nx][ny]=true;\n\t\t\t\t\tdfs(nx,ny,f+1);\n\t\t\t\t\tused[nx][ny]=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\tint i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tif(w==0)return 0;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\ths[i][j]=false;\n\t\tused[i][j]=false;\n\t}\n\tnh=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ths[i][j]=true;\n\t\t\t\tused[i][j]=false;\n\t\t\t\tnh++;\n\t\t\t}\n\t\t\tif(c=='2'){cx=i;cy=j;}\n\t\t}\n\t}\n\tans=0;\n\tdfs(cx,cy,0);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint h, w;\nll k = 1, l;\nint b[10][10], o;\nll c[100];\nint dp[24][16777216];\nint a[10][10];\nll solve(int i, int j, ll s) {\n\tif (l == s) {\n\t\tif (b[i][j] == o)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tll sum = 0;\n\tfor (int x = i + 1; x < h; x++) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = i - 1; x >= 0; x--) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j + 1; y < w; y++) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j - 1; y >= 0; y--) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> w >> h&&w!=0&&h!=0) {\n\t\tint sx, sy;\n\t\tll sum = 0;\n\t\tl = 0;\n\t\tk = 1;\n\t\to = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\to = sum;\n\t\t\t\t}\n\t\t\t\tif (a[i][j]) {\n\t\t\t\t\tb[i][j] = sum;\n\t\t\t\t\tc[sum++] = k;\n\t\t\t\t\tl += k;\n\t\t\t\t\tk *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < sum; i++) {\n\t\t\tfor (ll j = 0; j <= l; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcout << solve(sx, sy, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int bitmax = 1<<19;\n//bit????????????\nint dp[23][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\tif(bit<bitmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\n\tint ans=0;\n\trep(k,4) rep(a,deg[id][k]) {\n\t\tint next_id=adj[id][k][a];\n\t\tif((picked&(1<<next_id))==0){\n\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(dp[id].size()<1000000) dp[id][picked]=ans;\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint n, m, a[10][10], maxN = 0;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint dfs(int y, int x, int counter) {\n  int ans = 0;\n  for (int i = 0; i < 4; i++) {\n    int ny = y, nx = x;\n    while (1) {\n      ny += dy[i], nx += dx[i];\n      if (ny < 0 || nx < 0 || ny >= n || nx >= m) break;\n      if (a[ny][nx] == -1) break;\n      if (a[ny][nx] == 1 && counter > 0) {\n        a[ny][nx] = -1;\n        ans += dfs(ny, nx, counter - 1);\n        a[ny][nx] = 1;\n      }\n      if (a[ny][nx] == 2 && counter == 0) return 1;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    int cx, cy;\n    maxN = 0;\n    for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n      scanf(\"%d\", &a[i][j]);\n      if (a[i][j] == 2) cy = i, cx = j;\n      if (a[i][j] == 1) maxN++;\n    }\n    printf(\"%d\\n\", dfs(cy, cx, maxN));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\ndeque<int> edge[24][4];\nint n;\nint dp[24][1 << 23];\nint dfs(int p, int visit)\n{\n\tprintf(\"%d\\n\", p);\n\tif (~dp[p][visit])\n\t\treturn dp[p][visit];\n\telse if (!visit)\n\t{\n\t\tbool f = false;\n\t\trep (i, 4)\n\t\t\tif (!edge[p][i].empty())\n\t\t\t\tf |= edge[p][i].front() == n;\n\t\treturn dp[p][visit] = f ? 1 : 0;\n\t}\n\n\tint res = 0;\n\trep (i, 4)\n\t{\n\t\tforeach (e, edge[p][i])\n\t\t{\n\t\t\tif (*e == n)\n\t\t\t\tcontinue;\n\t\t\tif (!(visit & (1 << *e)))\n\t\t\t\tbreak;\n\n\t\t\tres += dfs(*e, visit ^ (1 << *e));\n\t\t}\n\t}\n\n\treturn dp[p][visit] = res;\n}\nint main()\n{\n\tint h, w;\n\twhile (scanf(\"%d%d\", &w, &h), w | h)\n\t{\n\t\trep (i, 30)\n\t\t\trep (j, 4)\n\t\t\t\tedge[i][j].clear();\n\n\t\tpint church;\n\t\tvector<pint> pos;\n\t\trep (i, h)\n\t\t{\n\t\t\trep (j, w)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif (t == 1)\n\t\t\t\t\tpos.push_back(pint(j, i));\n\t\t\t\telse if (t == 2)\n\t\t\t\t\tchurch = pint(j, i);\n\t\t\t}\n\t\t}\n\t\tn = pos.size();\n\t\tpos.push_back(church);\n\n\t\trep (i, pos.size())\n\t\t{\n\t\t\tvector<pint> hor, ver;\n\t\t\trep (j, pos.size())\n\t\t\t{\n\t\t\t\tif (pos[i].first == pos[j].first)\n\t\t\t\t\tver.push_back(pint(pos[j].second, j));\n\t\t\t\telse if (pos[i].second == pos[j].second)\n\t\t\t\t\thor.push_back(pint(pos[j].first, j));\n\t\t\t}\n\t\t\tsort(all(hor));\n\t\t\tsort(all(ver));\n\n\t\t\tforeach (it, hor)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].first)\n\t\t\t\t\tedge[i][3].push_front(it->second);\n\t\t\t\telse if (pos[i].first < it->first)\n\t\t\t\t\tedge[i][1].push_back(it->second);\n\t\t\t}\n\t\t\tforeach (it, ver)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].second)\n\t\t\t\t\tedge[i][2].push_front(it->second);\n\t\t\t\telse if (pos[i].second < it->first)\n\t\t\t\t\tedge[i][0].push_back(it->second);\n\t\t\t}\n\t\t}\n\n\t\t//rep (i, n + 1)\n\t\t//{\n\t\t//\tprintf(\">%d: (%d, %d)\\n\", i, pos[i].first, pos[i].second);\n\t\t//\trep (j, 4)\n\t\t//\t{\n\t\t//\t\tprintf(\"%d: \", j);\n\t\t//\t\tforeach (t, edge[i][j])\n\t\t//\t\t\tprintf(\"(%d, %d) \", pos[*t].first, pos[*t].second);\n\t\t//\t\tputs(\"\");\n\t\t//\t}\n\t\t//}\n\n\t\tmemset(dp, ~0, sizeof(dp));\n\t\tint all_visit = (1 << n) - 1;\n\t\tprintf(\"%d\\n\", dfs(n, all_visit));\n\n\t\t//int s = 0;\n\t\t//rep (i, n)\n\t\t//\tif (~dp[i][0])\n\t\t//\t\ts += dp[i][0];\n\t\t//printf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nmap<int,int> memo;\n\nint func( int p, int d, int u ){\n\twhile(1){\n\t\tint h = mp[p];\n\t\tif( h >= 0 ){\n\t\t\tint s = 0;\n\t\t\tmp[p] = -1;\n\t\t\ths ^= 1 << h;\n\t\t\tif( u > 13 ){\n\t\t\t\tfor(int i = 0; i < 4; i++ )\n\t\t\t\t\ts += func( p + dir[i], dir[i], u - 1 );\n\t\t\t}else{\n\t\t\t\tint mi = h << 23 | hs;\n\t\t\t\tmap<int,int>::iterator it = memo.find(mi);\n\t\t\t\tif( it == memo.end() ){\n\t\t\t\t\tfor(int i = 0; i < 4; i++ )\n\t\t\t\t\t\ts += func( p + dir[i], dir[i], u - 1 );\n\t\t\t\t\tmemo[mi] = s;\n\t\t\t\t}else{\n\t\t\t\t\ts = it->second;\n\t\t\t\t}\n\t\t\t}\n\t\t\ths |= 1 << h;\n\t\t\tmp[p] = h;\n\t\t\treturn s;\n\t\t}\n\t\tif( h == -9 )break;\n\t\tp += d;\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tmemo.clear();\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\tj = hs;\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt += func( ch + dir[i], dir[i], j );\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n, coun, ans, jud = 1, s;\nint town[11][11];\nP start;\nvoid dfs(int y, int x, int flag);\n\ninline int bit(int n, int i) {\n\treturn n | 1 << i;\n}\n\ninline bool bitj(int n, int i) {\n\tif (n & 1 << i )\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tans = 0;\n\t\tcoun = 1;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\tstart = make_pair(i, j);\n\t\t\t\t\ts = coun;\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = coun;\n\t\t\t\t\tcoun++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjud = 1;\n\t\tfor (i = 0; i < coun; i++) {\n\t\t\tjud *= 2;\n\t\t}\n\t\tdfs(start.first, start.second, 1 << s);\n\t\tcout << ans << endl;\n\t}\n}\nvoid dfs(int y, int x, int flag) {\n\tfor (i = x + 1; i <= m; i++) {\n\t\tif (town[y][i] && bitj(flag, town[y][i])) {\n\t\t\tdfs(y, i, bit(flag, town[y][i]));\n\t\t\tbreak;\n\t\t}\n\t\tif (town[y][i] == s&&bit(flag, town[y][i]) == jud - 2) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = x - 1; i > 0; i--) {\n\t\tif (town[y][i] && bitj(flag, town[y][i])) {\n\t\t\tdfs(y, i, bit(flag, town[y][i]));\n\t\t\tbreak;\n\t\t}\n\t\tif (town[y][i] == s&&bit(flag, town[y][i]) == jud - 2) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = y + 1; i <= n; i++) {\n\t\tif (town[i][x] && bitj(flag, town[i][x])) {\n\t\t\tdfs(i, x, bit(flag, town[i][x]));\n\t\t\tbreak;\n\t\t}\n\t\tif (town[i][x] == s&&bit(flag, town[i][x]) == jud - 2) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = y - 1; i > 0; i--) {\n\t\tif (town[i][x] && bitj(flag, town[i][x])) {\n\t\t\tdfs(i, x, bit(flag, town[i][x]));\n\t\t\tbreak;\n\t\t}\n\t\tif (town[i][x] == s&&bit(flag, town[i][x]) == jud - 2) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\n#define PLANE (-1)\n#define HOUSE (1)\n#define CHURCH (100)\n\nusing namespace std;\n\nint x, y;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint home[10][10];\nint n;\nmap<int, int> memo[24];\n\nint goChurch(int ty, int tx)\n{\n    int i;\n    int my, mx;\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        while (0 <= my && my < y && 0 <= mx && mx < x){\n            if (home[my][mx] == CHURCH){\n                return (1);\n            }\n            my += dy[i];\n            mx += dx[i];\n        }\n    }\n    return (0);\n}\n\nint dfs(int v, int bit, int ty, int tx, char state[][11])\n{\n    int i;\n    int ky, kx;\n    int ans;\n    \n    if (memo[pos].find(bit) != memo[pos].end()){\n        return (memo[v][bit]);\n    }\n    \n    if (bit == (1 << n) - 1){\n        if (__builtin_popcount(bit) < 19){\n            return (memo[v][bit] = goChurch(ty, tx));\n        }\n        return (goChurch(ty, tx));\n    }\n    \n    ans = 0;\n    \n    for (i = 0; i < 4; i++){\n\t\tkx = tx + dx[i];\n        ky = ty + dy[i];\n        //ツ逆ツ渉づ可プツδ個ゼツδ督トツづーツ置ツつ「ツづつ「ツつュ\n\t\twhile (0 <= kx && kx < x && 0 <= ky && ky < y && (home[ky][kx] == PLANE || home[ky][kx] == CHURCH || state[ky][kx] == 1)){\n\t\t\tky += dy[i];\n            kx += dx[i];\n\t\t}\n\t\tif (0 <= kx && kx < x && 0 <= ky && ky < y){\n\t\t\tstate[ky][kx] = 1;\n\t\t\tans += dfs(home[ky][kx] , bit | (1 << home[ky][kx]) , ky, kx, state);\n\t\t\tstate[ky][kx] = 0;\n\t\t}\n\t}\n    \n    if (__builtin_popcount(bit) < 19){\n        memo[v][bit] = ans;\n    }\n\treturn (ans);\n}\n\n\nint main(void)\n{\n    int sy, sx;\n    int i, j;\n    char state[10][11];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        n = 0;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &home[i][j]);\n                if (home[i][j] == 2){\n                    home[i][j] = CHURCH;\n                    sy = i;\n                    sx = j;\n                }\n                else if (home[i][j] == HOUSE){\n                    home[i][j] = n++;\n                }\n                else if (home[i][j] == 0){\n                    home[i][j] = PLANE;\n                }\n            }\n        }\n        memset(state, 0, sizeof(state));\n        for (i = 0; i < 24; i++){\n            memo[i].clear();\n        }\n        printf(\"%d\\n\", dfs(n, 0, sy, sx, state));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint n,m;\n\nint kx,ky;\nint field[11][11];\nint home;\nconst int INF=1000000000;\n\nint cnt=0;\n\nint psize;\npair<int,int> path[200];\n\nvoid dfs(int x,int y){\n\tif(home==0){\n\t\tif(x==kx||y==ky){\n\t\t\tcnt++;\n\t\t\t//for(int i = 0; i < psize; i++){\n\t\t\t//\tcout<<path[i].first<< \" \"<<path[i].second<<endl;\n\t\t\t//}\n\t\t\t//cout<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i = y-1; i >= 0; i--){\n\t\t\tif(field[i][x]==1){\n\t\t\t\tfield[i][x]=0;\n\t\t\t\thome--;\n\t\t\t\tpath[psize]=make_pair(i,x);\n\t\t\t\tpsize++;\n\t\t\t\tdfs(x,i);\n\t\t\t\tpsize--;\n\t\t\t\thome++;\n\t\t\t\tfield[i][x]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = y+1; i < n; i++){\n\t\t\tif(field[i][x]==1){\n\t\t\t\tfield[i][x]=0;\n\t\t\t\thome--;\n\t\t\t\tpath[psize]=make_pair(i,x);\n\t\t\t\tpsize++;\n\t\t\t\tdfs(x,i);\n\t\t\t\tpsize--;\n\t\t\t\thome++;\n\t\t\t\tfield[i][x]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = x-1; i >= 0; i--){\n\t\t\tif(field[y][i]==1){\n\t\t\t\tfield[y][i]=0;\n\t\t\t\thome--;\n\t\t\t\tpath[psize]=make_pair(y,i);\n\t\t\t\tpsize++;\n\t\t\t\tdfs(i,y);\n\t\t\t\tpsize--;\n\t\t\t\thome++;\n\t\t\t\tfield[y][i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = x+1; i < m; i++){\n\t\t\tif(field[y][i]==1){\n\t\t\t\tfield[y][i]=0;\n\t\t\t\thome--;\n\t\t\t\tpath[psize]=make_pair(y,i);\n\t\t\t\tpsize++;\n\t\t\t\tdfs(i,y);\n\t\t\t\tpsize--;\n\t\t\t\thome++;\n\t\t\t\tfield[y][i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\twhile(cin>>m>>n&&!(n==0&&m==0)){\n\t\tpsize=0;\n\t\thome=0;\n\t\tcnt=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]==2){\n\t\t\t\t\tkx=j;\n\t\t\t\t\tky=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]==1)\n\t\t\t\t\thome++;\n\t\t\t}\n\t\t}\n\t\tdfs(kx,ky);\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nstack<int> st;\n\nclass state{\npublic:\n  int x,y,s;\n  state(int _x, int _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool ischeck(int s){\n  return ( (s&last) == last );\n}\n\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ // ÆÍ³ïÉßêé©Ç¤©\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = x + dx[k]*i;\n\tint ty = y + dy[k]*i;\n\t//if( inside(tx,ty) || field[ty][tx]==1 )break;\n\tif( inside(tx,ty) )break;\n\n\tif( field[ty][tx]==2 ){\n#if DEB\n\t  printf(\"goal , (%d,%d)  s:%d\\n\",x,y,s);\n\t  stack<int> tmp = st;\n\t  while( !tmp.empty() ){\n\t    printf(\"%d,\",tmp.top());\n\t    tmp.pop();\n\t  }\n\t  puts(\"\\n\");\n#endif\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½ê\n    return msi[state(x,y,s)];\n  }\n  /*\n  if( ischeck(s) ){\n    msi[state(x,y,s)] = 0;\n    return 0;\n  }\n  */\n  \n\n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\t//if( s&(1<<num[ty][tx]) ) break;\t\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif \n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n#if DEB\n\tst.pop();\n#endif\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  break;\n\t}\n      }\n    }\n#if DEB\n    printf(\"home:%d  sx,sy = %d,%d\\n\",home,sx,sy);\n    printf(\"last:%d\\n\",last);\n    rep(i,h){\n      rep(j,w){\n\tprintf(\"%2d \",num[i][j]);\n      }\n      puts(\"\");\n    }\n#endif   \n    dfs(sx,sy,0);\n    printf(\"%d\\n\",msi[state(sx,sy,0)]);\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int> > grd;\nint m,n;\nint mx[]={1,-1,0,0},my[]={0,0,1,-1};\nint dfs(int x,int y,int left){\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint tx=x+mx[i],ty=y+my[i];\n\t\twhile(0<=tx&&tx<m&&0<=ty&&ty<n){\n\t\t\tif(grd[ty][tx]==-1)\tbreak;\n\t\t\tif(grd[ty][tx]==2&&left==0)\treturn 1;\n\t\t\telse if(grd[ty][tx]==1){\n\t\t\t\tgrd[ty][tx]=-1;\n\t\t\t\tans+=dfs(tx,ty,left-1);\n\t\t\t\tgrd[ty][tx]=1;\n\t\t\t}\n\t\t\ttx+=mx[i];\tty+=my[i];\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>m>>n;\n\t\tif(m==0)\treturn 0;\n\t\tgrd.clear();\n\t\tgrd.assign(n,vector<int>(m,0));\n\t\tint cnt=0,sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin>>grd[i][j];\n\t\t\t\tif(grd[i][j]==1)\tcnt++;\n\t\t\t\telse if(grd[i][j]==2){\n\t\t\t\t\tsx=j;\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(sx,sy,cnt)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint DP[1<<23][23];\nint M,N;\nint board[10][10];\nint X[25];int Y[25];\nint KX,KY;\nint main()\n{\nwhile(true){\n\tscanf(\"%d%d\",&M,&N);\n        if(M==0&&N==0)return 0;\nfor(int i=0;i<23;i++)DP[1<<i][i]=0;\n\tint house=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tscanf(\"%d\",&board[i][j]);\n\t\t\tif(board[i][j]==1){\n\t\t\t\tboard[i][j]=house;\n\t\t\t\tX[house]=i;Y[house]=j;\n\t\t\t\thouse++;\n\t\t\t}\n\t\t\telse if(board[i][j]==2){\n\t\t\t\tboard[i][j]=30;\n\t\t\t\tKX=i;KY=j;\n\t\t\t}\n\t\t}\n\t}\n\thouse--;\n\tfor(int i=0;i<house;i++){\n\t\tif(X[i+1]!=KX&&Y[i+1]!=KY)continue;\n\t\tDP[(1<<i)][i]=1;\n\t}\n\tfor(int i=1;i<(1<<house);i++){\n\t\tfor(int j=0;j<house;j++){\n\t\t\tif(!((i>>j)&1))continue;\n\t\t\tif(DP[i][j]>0)continue;\n\t\t\tint nowX=X[j+1];int nowY=Y[j+1];\n\t\t\tfor(int k=0;k<house;k++){\n\t\t\t\tif(j==k)continue;\n\t\t\t\tif(!((i>>k)&1))continue;\n\t\t\t\tint befoX=X[k+1];int befoY=Y[k+1];\n\t\t\t\tif(nowX!=befoX&&nowY!=befoY)continue;\n\t\t\t\tif(nowX==befoX){\n\t\t\t\t\tfor(int l=min(nowY,befoY)+1;l<max(nowY,befoY);l++){\n\t\t\t\t\t\tif(board[nowX][l]>=1&&board[nowX][l]<=25){\n\t\t\t\t\t\t\tif((i>>(board[nowX][l]-1))&1)goto a56;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int l=min(nowX,befoX)+1;l<max(nowX,befoX);l++){\n\t\t\t\t\t\tif(board[l][nowY]>=1&&board[l][nowY]<=25){\n\t\t\t\t\t\t\tif((i>>(board[l][nowY]-1))&1)goto a56;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDP[i][j]+=DP[i-(1<<j)][k];\n\t\t\t\ta56:;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<house;i++){\n\t\tif(X[i+1]!=KX&&Y[i+1]!=KY)continue;\n\t\tif(KX==X[i+1]){\n\t\t\tfor(int l=min(Y[i+1],KY)+1;l<max(Y[i+1],KY);l++){\n\t\t\t\tif(board[KX][l]>=1&&board[KX][l]<=25)goto b56;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int l=min(X[i+1],KX)+1;l<max(X[i+1],KX);l++){\n\t\t\t\tif(board[l][KY]>=1&&board[l][KY]<=25)goto b56;\n\t\t\t}\n\t\t}\n\t\tans+=DP[(1<<house)-1][i];\n\t\tb56:;\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <tr1/unordered_map>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nusing namespace std;\n\ntr1::unordered_map<int, int> memo;\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[23];\nint y[23];\nint kx;\nint ky;\nint n;\n\nint solve(int xx, int yy, int flag){\n  if(flag == (1 << n) - 1){\n    REP(i,4){\n      int xxx = nx[i][yy][xx];\n      int yyy = ny[i][yy][xx];\n      if(f[yyy][xxx] == 2) return 1;\n    }\n    return 0;\n  }else{\n    int idn = id[yy][xx];\n\n    if(idn != n)\n      if((ok[flag] & (1 << idn)) == 0) return 0;\n    if(memo.count((idn << n) | flag))\n      return memo[(idn << n) | flag];\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(true){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        // printf(\"%d %d: %d %d\\n\", xxxx, yyyy, idn, n);\n        if(idn != n){\n          if(flag & (1 << idn)) break;\n          ret += solve(xxxx, yyyy, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(!ret && idn != n)\n      ok[flag] &= ~(1 << idn);\n    if(ret && idn != n)\n      memo[(idn << n) | flag] = ret;\n\n    return ret;\n  }\n}\n\nint main(){\n  while(true){\n    int w = getInt();\n    int h = getInt();\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      f[i][j] = getInt();\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j] != 0){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      kx = j; ky = i;\n      id[i][j] = n;\n    }\n\n    /*\n    REP(i,1<<n){\n      ok[i] = false;\n      REP(j,n) if((i & (1 << j)) == 0){\n        int xx = x[j];\n        int yy = y[j];\n        REP(k,4){\n          int xxx = nx[k][yy][xx];\n          int yyy = ny[k][yy][xx];\n          if(f[yyy][xxx] == 2){\n            ok[i] = true;\n            goto next;\n          }\n        }\n      }\n    next:;\n    }\n    */\n\n    memo.clear();\n\n    REP(i, 1<<n) ok[i] = (1 << n) - 1;\n    int ans = solve(kx, ky, 0);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint W, H, N = 0;\nint mas[11][11];\nint X[25], Y[25];\nbool isin(int y, int x)\n{\n    return (y >= 0 && x >= 0 && y < H && x < W);\n}\nint dfs(int y, int x, int bit)\n{\n    int ret = 0;\n    if(bit == 0) return (1);\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        while(isin(ny, nx) && (mas[ny][nx] < 0 || (bit != (1 << N) && mas[ny][nx] == N) || (bit & ~(1 << mas[ny][nx])) == bit)) ny += dy[i], nx += dx[i];\n        if(isin(ny, nx)) ret += dfs(ny, nx, bit & ~(1 << mas[ny][nx]));\n    }\n    return (ret);\n}\n\nint main()\n{\n    int px, py;\n    cin >> W >> H;\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            cin >> mas[i][j];\n            if(mas[i][j] == 0) mas[i][j] = -1;\n            else if(mas[i][j] == 1) mas[i][j] = N, N++;\n            else py = i, px = j;\n        }\n    }\n    mas[py][px] = N;\n    cout << dfs(py, px, (1 << (N + 1)) - 1) << endl;\n    return (0);\n}\nbash-4.3(leia):~/syoribu/JOI/2017/sp/pr\n572:{ei1629}$ bc\n4^7 * 2^16\n1073741824\ncat ^Cquit\nbash-4.3(leia):~/syoribu/JOI/2017/sp/pr\n573:{ei1629}$ cat Reindeer_with_no_sense_of_direction.cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint W, H, N = 0;\nint mas[11][11];\nbool isin(int y, int x)\n{\n    return (y >= 0 && x >= 0 && y < H && x < W);\n}\nint dfs(int y, int x, int bit)\n{\n    int ret = 0;\n    if(bit == 0) return (1);\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        while(isin(ny, nx) && (mas[ny][nx] < 0 || (bit != (1 << N) && mas[ny][nx] == N) || (bit & ~(1 << mas[ny][nx])) == bit)) ny += dy[i], nx += dx[i];\n        if(isin(ny, nx)) ret += dfs(ny, nx, bit & ~(1 << mas[ny][nx]));\n    }\n    return (ret);\n}\n\nint main()\n{\n    int px, py;\n    while(cin >> W >> H, W || H) {\n        for(int i = 0; i < H; i++) {\n            for(int j = 0; j < W; j++) {\n                cin >> mas[i][j];\n                if(mas[i][j] == 0) mas[i][j] = -1;\n                else if(mas[i][j] == 1) mas[i][j] = N, N++;\n                else py = i, px = j;\n            }\n        }\n        mas[py][px] = N;\n        cout << dfs(py, px, (1 << (N + 1)) - 1) << endl;\n    }\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n, m, field[11][11], si, sj, num;\n \nint dfs(int x, int y){\n  int ans = 0;\n  if(num == 0){\n    if(x == si || y == sj)return 1;\n    else return 0;\n  }\n\n  field[x][y] = 0;\n  for(int i = x + 1 ; i < m ; i++){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  }\n  for(int i = x - 1 ; i >= 0 ; i--){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  }\n  for(int i = y + 1 ; i < n ; i++){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  }\n  for(int i = y - 1 ; i >= 0 ; i--){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  } \n  field[x][y] = 1;\n  return ans;\n}\n \nint main(void){\n\n  while(cin >> n >> m, n + m){\n    \n    memset(field, 0, sizeof(field));\n    num = 0;\n    for(int i = 0;i < m;i++){\n      for(int j = 0;j < n;j++){\n\tcin >> field[i][j];\n\tif(field[i][j] == 2){\n\t  si = i;\n\t  sj = j;\n\t}\n\telse num += field[i][j];\n      }\n    }\n    cout << dfs(si, sj) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint dp[1<<23][23]; //ここまで、現在地\n\nint main() {\n\tiostream::sync_with_stdio(false);\n\n\tSTART:\n\t\n\tint m,n;\n\tcin >> m >> n;\n\tif(n == 0 && m == 0) return 0;\n\tint a[10][10];\n\tvector<pair<int,int> > house;\n\tpair<int,int> kyokai;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j] == 0) a[i][j] = -1; //空地\n\t\t\telse if(a[i][j] == 2){\n\t\t\t\ta[i][j] = -2; //教会\n\t\t\t\tkyokai = MP(i,j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i][j] = house.size();\n\t\t\t\thouse.push_back(MP(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\t//経路計算\n\tvector<pair<int,int>> way[23];\n\tfor(int i=0; i<house.size(); i++){\n\t\tint x = house[i].first;\n\t\tint y = house[i].second;\n\t\tint tmp = 0;\n\t\tfor(int j=x+1; j<n; j++){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=x-1; j>=0; j--){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=y+1; j<m; j++){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=y-1; j>=0; j--){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t}\n\n\t//教会隣接家dp初期化\n\tfor(int i=0; i<house.size(); i++) dp[(1<<house.size())-1][i] = 0;\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//dp\n\tfor(int i=(1<<house.size())-2; i>=0; i--){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\tdp[i][j] = 0;\n\t\t\tif((i&(1<<j)) == 0) continue;\n\t\t\tfor(int k=0; k<way[j].size(); k++){\n\t\t\t\tif((i&way[j][k].second) == 0 && (i&(1<<way[j][k].first)) == 0){\n\t\t\t\t\tdp[i][j] += dp[i+(1<<way[j][k].first)][way[j][k].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終的な答え\n\tint ans = 0;\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += dp[1<<a[i][kyokai.second]][a[i][kyokai.second]];\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += dp[1<<a[i][kyokai.second]][a[i][kyokai.second]];\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += dp[1<<a[kyokai.first][i]][a[kyokai.first][i]];\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += dp[1<<a[kyokai.first][i]][a[kyokai.first][i]];\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\tgoto START;\n\n\t/*\n\t//デバッグ\n\tfor(int i=0; i<house.size(); i++){\n\t\tfor(int j=0; j<way[i].size(); j++){\n\t\t\tcout << way[i][j].first << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tfor(int i=0; i<(1<<house.size()); i++){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint h, w;\nint k = 1, l;\nint b[10][10], o;\nint c[100];\nint dp[24][16777216];\nint a[10][10];\nint solve(int i, int j, int s) {\n\tif (l == s) {\n\t\tif (b[i][j] == o)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tint sum = 0;\n\tfor (int x = i + 1; x < h; x++) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = i - 1; x >= 0; x--) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j + 1; y < w; y++) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j - 1; y >= 0; y--) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> w >> h&&w!=0&&h!=0) {\n\t\tint sx, sy;\n\t\tint sum = 0;\n\t\tl = 0;\n\t\tk = 1;\n\t\to = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\to = sum;\n\t\t\t\t}\n\t\t\t\tif (a[i][j]) {\n\t\t\t\t\tb[i][j] = sum;\n\t\t\t\t\tc[sum++] = k;\n\t\t\t\t\tl += k;\n\t\t\t\t\tk *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < sum; i++) {\n\t\t\tfor (int j = 0; j <= l; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcout << solve(sx, sy, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=h/2){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=h/2){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp,y,x,ans;\nint dp[1<<23][24];\nP pos[24];\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    int upper = (1<<(pn-1));\n    for(int i=0;i<upper;i++)\n      for(int j=0;j<pn;j++)dp[i][j] = 0;\n    dp[0][0] = 1;\n\n    ans = 0;\n    for(int i=0;i<upper;i++){\n      for(int j=0;j<pn;j++){\n\tif(dp[i][j]){\n\t  y = pos[j].first; x = pos[j].second;\n\t  for(int k=0;k<4;k++){\n\t    int ty = y+dy[k], tx = x+dx[k];\n\t    for(;;){\n\t      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n\t      if(i == upper-1 && g[ty][tx] == 0){\n\t\tans += dp[i][j];\n\t\tbreak;\n\t      }\n\t      if(0<g[ty][tx]){\n\t\ttmp = g[ty][tx] - 1;\n\t\tif( (i>>tmp)&1 )break;\n\t\telse dp[i|(1<<tmp)][tmp+1] += dp[i][j];\n\t      }\n\t      ty += dy[k]; tx += dx[k];\n\t    }\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\t      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;int x[144],m,n,w,ch;int z[]={-12,-1,1,12};map<int,int>y;int func(int p,int d,int u){while(1){int h=x[p];if(h>=0){int s=0;x[p]=-1;w^=1<<h;if(u>12){for(int i=0;i<4;i++)s+=func(p+z[i],z[i],u-1);}else{int mi=h<<23|w;map<int,int>::iterator it=y.find(mi);if(it==y.end()){for(int i=0;i<4;i++)s+=func(p+z[i],z[i],u-1);y[mi]=s;}else{s=it->second;}}w|=1<<h;x[p]=h;return s;}if(h==-9)break;p+=d;}return 0;}int main(){int i,j,p,t;for(;scanf(\"%d%d\",&m,&n),m;y.clear()){w=0;for(i=0;i<144;i++)x[i]=-9;for(i=1;i<=n;i++)for(j=1;j<=m;j++){p=i*12+j;scanf(\"%d\",&t);switch(t){case 2:ch=p;case 0:x[p]=-1;break;case 1:y[w<<23]=0;x[p]=w++;break;}}for(i=0;i<4;){t=z[i++];for(j=ch;x[j+=t]!=-9;x[j]>=0?y[x[j]<<23]=1:0);}j=w;w=(1<<w)-1;t=0;for(i=-1;++i<4;)t+=func(ch+z[i],z[i],j);printf(\"%d\\n\",t);}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h,int k){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny],k-1);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(k >= 10) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0,c) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint main() {\n  while (true) {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    vector<vector<int>> p(n, vector<int>(m));\n    for (int i : range(n)) for (int j : range(m)) cin >> p[i][j];\n    vector<pair<int, int>> house;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 1) house.emplace_back(i, j);\n    vector<vector<int>> s(n, vector<int>(m, -1));\n    for (int i : range(house.size())) s[house[i].first][house[i].second] = i;\n    queue<tuple<int, int, int>> que;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 2) que.push(make_tuple(i, j, 0));\n    int res = 0;\n    while (!que.empty()) {\n      auto now = que.front(); que.pop();\n      int y = get<0>(now);\n      int x = get<1>(now);\n      int bit = get<2>(now);\n      for (int i : range(4)) {\n        int yy = y + dy[i];\n        int xx = x + dx[i];\n        while (true) {\n          if (yy < 0 || n <= yy) break;\n          if (xx < 0 || m <= xx) break;\n          if (p[yy][xx] == 1) {\n            if (bit & 1 << s[yy][xx]) break;\n            que.push(make_tuple(yy, xx, bit | 1 << s[yy][xx]));\n          }\n          if (p[yy][xx] == 2) {\n            if (bit == (1 << house.size()) - 1) ++res; \n            break;\n          }\n          yy += dy[i];\n          xx += dx[i];\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint H[10][10];\nint hx[24], hy[24];\nint dp[1 << 24][24];\n\n\nint main() {\n\tint m, n;\n\twhile(scanf(\"%d%d\", &m, &n),m){\n\tint cnt=1;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tint h; scanf(\"%d\", &h);\n\t\t\tH[i][j] = -1;\n\t\t\tif (h == 1) {\n\t\t\t\thx[cnt] = i; hy[cnt] = j;\n\t\t\t\tH[i][j] = cnt++;\n\t\t\t}\n\t\t\tif (h == 2) { H[i][j] = 0; hx[0] = i; hy[0] = j; }\n\t\t}\n\t}\n\tfill(dp[0],dp[1<<cnt],0);\n\tdp[0][0] = 1;\n\trep(i, 1 << cnt) {\n\t\trep(j, cnt) {\n\t\t\tif (!dp[i][j])continue;\n\t\t\tif ((i | j) && !((i >> j) & 1))continue;\n\t\t\tint x = hx[j], y = hy[j];\n\t\t\tfor (int k = 1; x + k < n; k++) {\n\t\t\t\tif (~H[x + k][y]) {\n\t\t\t\t\tif ((i >> H[x + k][y]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x + k][y])][H[x + k][y]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; x - k >= 0; k++) {\n\t\t\t\tif (~H[x - k][y]) {\n\t\t\t\t\tif ((i >> H[x - k][y]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x - k][y])][H[x - k][y]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; y + k < m; k++) {\n\t\t\t\tif (~H[x][y + k]) {\n\t\t\t\t\tif ((i >> H[x][y + k]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x][y + k])][H[x][y + k]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; y - k >= 0; k++) {\n\t\t\t\tif (~H[x][y - k]) {\n\t\t\t\t\tif ((i >> H[x][y - k]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x][y - k])][H[x][y - k]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[(1 << cnt) - 1][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\nint w,h;\nint map[10][10];\nbool passed[10][10];\nint gx,gy;\nint count_max;\nint func(int x,int y, int count)\n{\n\tif(count>0)\n\t{\n\t\t#ifdef DEBUG\n\t\t//std::cout << \"IN:\"<<x<<' '<<y<<' '<<count<<'\\n';\n\t\t#endif\n\t\tif(count==count_max+1||(x==gx&&y==gy)){\n\t\t\tif((count==count_max+1)&&x==gx&&y==gy){return 1;}\n\t\t\treturn 0;\n\t\t}\n\t\tpassed[x][y]=true;\n\t}\n\tint res = 0;\n\tfor(int nx = x-1;nx>=0;--nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t\tif(map[nx][y]==2){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int nx = x+1;nx<w;++nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t\tif(map[nx][y]==2){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y-1;ny>=0;--ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t\tif(map[x][ny]==2){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y+1;ny<h;++ny){\n\t\tif(!passed[x][ny] && map[x][ny]!=0){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t\tif(map[x][ny]==2){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpassed[x][y]=false;\n\treturn res;\n}\n\nint main()\n{\n\tfor(;;){\n\tstd::cin >> w>>h;if(w==0&&h==0){break;}\n\tcount_max=0;\n\tfor(int y=0;y<h;++y)for(int x=0;x<w;++x){\n\t\tstd::cin >> map[x][y];\n\t\tif(map[x][y]==1){++count_max;}\n\t\tif(map[x][y]==2){gx=x;gy=y;}\n\t}\n\t//std::cout << \"a:\"<<gx<<' '<<gy<<' '<<count_max<<'\\n';\n\t\n\tint res = 0;\n\tstd::cout << func(gx,gy,0)<<std::endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> grd;\nmap<tuple<vector<vector<int>>,int,int>,int> dp;\nint m,n;\nint mx[]={1,-1,0,0},my[]={0,0,1,-1};\nint dfs(int x,int y,int left){\n\tif(dp.find(make_tuple(grd,x,y))!=dp.end()){\n\t\treturn dp[make_tuple(grd,x,y)];\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint tx=x+mx[i],ty=y+my[i];\n\t\twhile(0<=tx&&tx<m&&0<=ty&&ty<n){\n\t\t\tif(grd[ty][tx]==-1)\tbreak;\n\t\t\tif(grd[ty][tx]==2&&left==0)\treturn 1;\n\t\t\telse if(grd[ty][tx]==1){\n\t\t\t\tgrd[ty][tx]=-1;\n\t\t\t\tans+=dfs(tx,ty,left-1);\n\t\t\t\tgrd[ty][tx]=1;\n\t\t\t}\n\t\t\ttx+=mx[i];\tty+=my[i];\n\t\t}\n\t}\n\tdp[make_tuple(grd,x,y)]=ans;\n\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>m>>n;\n\t\tif(m==0)\treturn 0;\n\t\tgrd.clear();\n\t\tgrd.assign(n,vector<int>(m,0));\n\t\tint cnt=0,sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin>>grd[i][j];\n\t\t\t\tif(grd[i][j]==1)\tcnt++;\n\t\t\t\telse if(grd[i][j]==2){\n\t\t\t\t\tsx=j;\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(sx,sy,cnt)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nint w,h;\nint sx,sy;\nint hn;\nint map[15][15];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nint dfs(int y,int x,int p){\n\t//printf(\"%d %d %d %d\\n\",y,x,p,hn);\n\tbool ered = false;\n\tif(map[y][x]==2){\n\t\tif(p!=hn)return 0;\n\t}\n\telse if(map[y][x]==1){\n\t\tmap[y][x]=0;\n\t\tp--;\n\t\tered = true;\n\t}\n\telse return 0;\n\t\n\tint res=0;\n\trep(i,4){\n\t\treg(j,1,100){\n\t\t\tint tx = x + dx[i]*j,\n\t\t\t\tty = y + dy[i]*j;\n\t\t\tswitch(map[ty][tx]){\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tres += dfs(ty,tx,p);\n\t\t\t\tgoto nexti;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif(p==0){\n\t\t\t\t\tres++;\n\t\t\t\t\tgoto nexti;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\tdefault:\n\t\t\t\tgoto nexti;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nnexti:;\n\t}\n\tif(ered)map[y][x]=1;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0)break;\n\t\tmemset(map,-1,sizeof(map));\n\t\thn=0;\n\t\treg(y,1,h){\n\t\t\treg(x,1,w){\n\t\t\t\tscanf(\"%d\",&map[y][x]);\n\t\t\t\tif(map[y][x]==1){\n\t\t\t\t\thn++;\n\t\t\t\t}\n\t\t\t\telse if(map[y][x]==2){\n\t\t\t\t\tsy = y; sx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(sy,sx,hn));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nInt s[20][20],idx[20][20],cnt,pru;\nInt u[20][20][4];\nInt num[40],ok[40];\nusing P = pair<Int, Int>;\nvector<vector<vector<P> > > G;\n\nInt dfs(Int y,Int x,Int b){\n  if(b==(1<<cnt)-1) return ok[idx[y][x]];\n  if((b&pru)==pru) return 0;\n  \n  Int res=0;\n  \n  for(Int k=0;k<4;k++){\n    Int z=idx[y][x];\n    for(auto p:G[z][k]){\n      Int ny,nx;\n      tie(ny,nx)=p;\n      if(s[ny][nx]<0) break;\n\n      s[ny][nx]*=-1;\n      \n      Int nb=b^(1<<idx[ny][nx]),flg=1;\n      for(Int i=0;i<4;i++){\n\tif(u[ny][nx][i]>=cnt) continue; \n\tnum[u[ny][nx][i]]--;\n\tif((~nb>>u[ny][nx][i])&1)\n\t  flg&=num[u[ny][nx][i]]>=1;\n      }\n      if(flg) res+=dfs(ny,nx,nb);\n      for(Int i=0;i<4;i++){\n\tif(u[ny][nx][i]>=cnt) continue; \n\tnum[u[ny][nx][i]]++;\n      }\n      \n      s[ny][nx]*=-1;\n    }\n  }\n\t\n  return res;\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    cnt=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tidx[i][j]=cnt;\n\tcnt+=s[i][j]==1;\n      }\n    }\n    \n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) idx[i][j]=cnt;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};    \n\n    G.clear();\n    G.resize(cnt+1);\n    \n    memset(num,0,sizeof(num));    \n    memset(ok,0,sizeof(ok));\n    \n    for(Int y=0;y<h;y++){\n      for(Int x=0;x<w;x++){\n\tif(s[y][x]==0) continue;\n\tInt z=idx[y][x];\n\tG[z].resize(4);\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y,nx=x;\n\t  while(1){\n\t    ny+=dy[k],nx+=dx[k];\n\t    while(in(ny,nx)&&s[ny][nx]==0)\n\t      ny+=dy[k],nx+=dx[k];\n\t    if(!in(ny,nx)) break;\t    \n\t    if(s[ny][nx]==2) ok[z]=1;\n\t    else G[z][k].emplace_back(ny,nx);\n\t  }\n\t}\n\t\n\tfor(Int k=0;k<4;k++){\n\t  u[y][x][k]=cnt+1;\n\t  for(auto p:G[z][k]){\n\t    u[y][x][k]=idx[p.first][p.second];\n\t    num[idx[p.first][p.second]]++;\n\t    break;\n\t  }\n\t}\n\t\n\tif(z==cnt){\n\t  pru=0;\n\t  for(Int k=0;k<4;k++){\n\t    for(auto p:G[z][k]){\n\t      pru|=(1<<idx[p.first][p.second]);\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) cout<<dfs(i,j,0)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint n,m,x,y,ie,bit,l;\nint mp[10][10];\nmap<pair<int,int>,int> memo;\nmap<pair<int,int>,int> num;\nint dfs(int I, int J){\n    if(l != -1 && num.count(MP(bit,l)) != -1) return memo[MP(bit,l)];\n\n    if(bit == ie){\n        if(I != x && J != y) return 0;\n        int ans = 0;\n        for(int i=I-1; i>=0; i--){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int i=I+1; i<n; i++){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int j=J-1; j>=0; j--){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        for(int j=J+1; j<m; j++){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        return memo[MP(bit,l)] = ans;\n    }\n\n    int ans = 0;\n    int L = l;\n    for(int i=I-1; i>=0; i--){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int i=I+1; i<n; i++){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int j=J-1; j>=0; j--){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n    for(int j=J+1; j<m; j++){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n\n    return memo[MP(bit,l)] = ans;\n}\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    while(true){\n        cin >> m >> n;\n        if(n == 0 && m == 0) break;\n\n        num.clear();\n        ie = 0;\n        bit = 0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                cin >> mp[i][j];\n                if(mp[i][j] == 2){\n                    x = i;\n                    y = j;\n                }\n                if(mp[i][j] == 1){\n                    num[MP(i,j)] = ie;\n                    ie++;\n                }\n            }\n        }\n        ie = (1<<ie) - 1;\n        l = -1;\n        memo.clear();\n\n        cout << dfs(x,y) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\n/*\nconst int dx[] = {0,1,0,-1}; //u,r,d,l\nconst int dy[] = {-1,0,1,0};\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint kari[32];\nvector<pair<int,int> > v;\n\n#if DEB\nstack<int> st;\n#endif\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( s==a.s ){\n      if( x==a.x ) return y<a.y;\n      else         return x<a.x;\n    }else{\n      return s<a.s;\n    }\n  }\n  \n};\n\nmap<state,int> msi;\n\nint numofbits(int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nbool isnotgoal(int s){\n  return (((last&s)) == last);\n}\nint isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (kari[i]&s)==kari[i] ) return i;\n  }\n  return -1;\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  \n  int mask = (1<<home)-1;\n  if( s>0 && numofbits(~s&mask)>1 && isnot(s&~(1<<num[y][x]))!=-1 ){ //v[gªu¯È¢ÆÌL³\n#if DEB\n    printf(\"s:%d ,(%d,%d)  __%d  ___isnot:%d\\n\",s,x,y,s&~num[y][x],isnot(s&~num[y][x]));\n    stack<int> tmp = st;\n    while( !tmp.empty() ){\n      printf(\"%d,\",tmp.top());\n      tmp.pop();\n    }\n    puts(\"\\n\");\n#endif\n    return 0;\n  }\n  \n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\n#if DEB\n\tst.pop();\n#endif\n\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    v.clear();\n    memset(num,-1,sizeof(num));\n    memset(kari,0,sizeof(kari));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t  v.pb(mp(j,i));\n\t}\n      }\n    }\n\n    // other homes\n    rep(i,v.size()){\n      rep(k,4){\n\tfor(int j=1; j<20; j++){\n\t  int tx = v[i].first + dx[k]*j;\n\t  int ty = v[i].second + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    kari[i] |= (1<<num[ty][tx]);\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n#if DEB\n    printf(\"sz:%d\\n\",v.size());\n    printf(\"last:%d\\n\",last);\n    rep(i,v.size()){\n      printf(\"home:%d  , %d\\n\",i,kari[i]);\n    }\n#endif\n    \n    \n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    if(ni==t.ni){\n      if(nj==t.nj){\n\treturn vis<t.vis;\n      }else return nj < t.nj;\n    }else return ni < t.ni;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n    \n    //cout << \"CNT: \" << (int)st_now.cnt << endl;\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n    \n    if( st_now.cnt >= 6 ){\n      bool bCont=false;\n      for(int i = 0; i < MAX; ++i){\n\tfor(int j = 0; j < MAX; ++j){\n\t  if( M[i][j].isHouse ){\n\t    if( M[i][j].isHouse && st_now.vis&(1<<houseId[i][j]) ) continue;\n\t    bool frontofcharch=false;\n\t    bCont=true;\n\t    for(int k = 0; k < MAXDIR; ++k){\n\t      if( M[i][j].cexist[k] ) frontofcharch = true;\n\t    }\n\t    for(int k = 0; k < MAXDIR; ++k){\n\t      if( !M[i][j].exist[k] ) continue;\n\t      for(int v = 0; v < M[i][j].link[k].size(); ++v){\n\t\tpi house = M[i][j].link[k][v];\n\t\tif( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\t  bCont=false;\n\t\t  break;\n\t\t}\n\t      }\n\t      if(!bCont)break;\n\t    }\n\t    \n\t    if(bCont && !frontofcharch ){\n\t      //cout << i << ' ' << j << endl;\n\t      break;\n\t    }\n\t    bCont=false;\n\t  }\n\t}\n\tif(bCont)break;\n      }\n      if(bCont)continue;\n    }\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.cnt++;\n\t    st_next.vis |= ( 1<<houseId[next.fr][next.sc] );\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> grid;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nvi dir[24][4];\nmap<int,int> memo;\n\nint rec(int v, int bit, int n){\n  int key = (v<<24)+bit;\n  if(memo.find(key)!=memo.end())return memo[key];\n  if(v==0 && bit+1 == 1<<n)return 1;\n\n  int res = 0;\n  rep(d,4){\n    for(int u : dir[v][d]){\n      if( (bit>>u)&1 )break;\n      res += rec(u, bit | (1<<u),n);\n    }\n  }\n  if(__builtin_popcount(bit)<=8)return res;\n  return memo[key] = res;\n}\n\nint main(){\n  int w,h;\n  while(cin >> w >> h, w){\n    grid g(h,vi(w));\n    \n    rep(i,h)rep(j,w)cin >> g[i][j];\n    \n    grid id(h,vi(w,-1));\n    int cnt = 1;\n    rep(i,h)rep(j,w){\n      if(g[i][j] == 2)id[i][j] = 0;\n      if(g[i][j] == 1)id[i][j] = cnt++;\n    }\n\n    rep(i,h)rep(j,w){\n      if(id[i][j]>=0){\n\trep(d,4){\n\t  dir[id[i][j]][d].clear();\n\n\t  int y = i+dy[d], x = j+dx[d];\n\t  while(range(y,0,h) && range(x,0,w)){\n\t    if(id[y][x]>=0)dir[id[i][j]][d].push_back(id[y][x]);\n\t    y += dy[d]; x += dx[d];\n\t  }\n\t}\n      }\n    }\n    \n    memo.clear();\n    cout << rec(0,0,cnt) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nconst int MOD=100000;\nint M,N,S,gX,gY,xD,yD;\nint fld[10][10];\nint rec(int x,int y,int sum){\n      //if(xD+yD==0)cout<<x<<\" \"<<y<<\" \"<<sum<<endl;\n      if(gX==x&&gY==y){\n            if(sum==S)return 1;\n            else return 0;\n      }\n      int res=0;\n      for(int d=x+1;d<M;d++){\n            if(fld[d][y]){\n                  fld[d][y]=0;\n                  res+=rec(d,y,sum+1);\n                  fld[d][y]=1;\n                  break;\n            }\n      }\n      for(int d=x-1;d>=0;d--){\n            if(fld[d][y]){\n                  fld[d][y]=0;\n                  res+=rec(d,y,sum+1);\n                  fld[d][y]=1;\n                  break;\n            }\n      }\n      for(int d=y+1;d<N;d++){\n            if(fld[x][d]){\n                  fld[x][d]=0;\n                  res+=rec(x,d,sum+1);\n                  fld[x][d]=1;\n                  break;\n            }\n      }\n      for(int d=y-1;d>=0;d--){\n            if(fld[x][d]){\n                  fld[x][d]=0;\n                  res+=rec(x,d,sum+1);\n                  fld[x][d]=1;\n                  break;\n            }\n      }\n      return res;\n}\nint main(){\n      while(cin>>M>>N&&(N||M)){\n            S=0;\n            REP(i,N)REP(j,M){\n                  scanf(\"%d\",&fld[j][i]);\n                  if(fld[j][i]==1)S++;\n                  if(fld[j][i]==2){\n                        S++;\n                        gX=j;gY=i;\n                  }\n            }\n            int ans=0;\n            for(int i=gX+1;i<M;i++)if(fld[i][gY]){\n                  fld[i][gY]=0;\n                  ans+=rec(i,gY,1);\n                  fld[i][gY]=1;\n                  break;\n            }\n            for(int i=gX-1;i>=0;i--)if(fld[i][gY]){\n                  fld[i][gY]=0;\n                  ans+=rec(i,gY,1);\n                  fld[i][gY]=1;\n                  break;\n            }\n            for(int i=gY+1;i<N;i++)if(fld[gX][i]){\n                  fld[gX][i]=0;\n                  ans+=rec(gX,i,1);\n                  fld[gX][i]=1;\n                  break;\n            }\n            for(int i=gY-1;i>=0;i--)if(fld[gX][i]){\n                  fld[gX][i]=0;\n                  ans+=rec(gX,i,1);\n                  fld[gX][i]=1;\n                  break;\n            }\n            cout<<ans<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n\nint m,n,c[10][10],x,y,cnt;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint dfs(int x,int y,int z){\n  int ret = 0;\n  for(int i=0;i<4;i++){\n    int nx = x, ny = y;\n    while(true){\n      nx += dx[i];\n      ny += dy[i];\n      if(nx<0||nx>=n||ny<0||ny>=m) break;\n      if(c[nx][ny]==2){\n        if(z==cnt-1) return 1;\n        else break;\n      }else if(c[nx][ny]==1){\n        c[nx][ny] = - c[nx][ny];\n        ret += dfs(nx,ny,z+1);\n        c[nx][ny] = - c[nx][ny];\n        break;\n      }\n    }\n  }\n  return ret;\n}\n\nbool solve(){\n  scanf(\"%d %d\",&m,&n);\n  if(m==0&&n==0) return false;\n  cnt = 0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      scanf(\"%d\",&c[i][j]);\n      if(c[i][j]>0) cnt++;\n      if(c[i][j]==2){\n        x = i;\n        y = j;\n      }\n    }\n  }\n  printf(\"%d\\n\",dfs(x,y,0));\n  return true;\n}\n\nint main(){\n  while(true) if(!solve()) break;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint grid[10][10];\n\nstruct STATE\n{\n\tint done, x, y;\n\t\n\tbool operator < (const STATE& t) const{\n\t\tif (done == t.done){\n\t\t\tif (x == t.x){\n\t\t\t\treturn y < t.y;\n\t\t\t}\n\t\t\treturn x < t.x;\n\t\t}\n\t\treturn done < t.done;\n\t}\n};\n\nint main()\n{\n\tint m, n;\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tint num = 0;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 0){\n\t\t\t\t\tgrid[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 1){\n\t\t\t\t\tgrid[i][j] = num++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgrid[i][j] = -2;\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<STATE, int> dp;\n\t\tmap<STATE, int> dp2;\n\t\tdp[{0, sx, sy}] = 1;\n\t\tint res = 0;\n\t\twhile (true){\n\t\t\tif (dp.count({(1 << num) - 1, sx, sy})){\n\t\t\t\tres = dp[{(1 << num) - 1, sx, sy}];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (map<STATE, int>::iterator ite = dp.begin(); ite != dp.end(); ++ite){\n\t\t\t\tSTATE st = (*ite).first;\n\t\t\t\t\n\t\t\t\t//printf(\"%d %d %d %d\\n\", st.done, st.x, st.y, dp[st]);\n\t\t\t\t\n\t\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\t\tint i = 1;\n\t\t\t\t\twhile (true){\n\t\t\t\t\t\tint tx = st.x + dx[dir] * i;\n\t\t\t\t\t\tint ty = st.y + dy[dir] * i;\n\t\t\t\t\t\tif (tx < 0 || tx >= n || ty < 0 || ty >= m) break;\n\t\t\t\t\t\tif (grid[tx][ty] == -2){\n\t\t\t\t\t\t\tif (st.done == (1 << num) - 1){\n\t\t\t\t\t\t\t\tdp2[{st.done, tx, ty}] += dp[st];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((grid[tx][ty] != -1) && (~st.done & (1 << grid[tx][ty]))){\n\t\t\t\t\t\t\tdp2[{st.done | (1 << grid[tx][ty]), tx, ty}] += dp[st];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp.clear();\n\t\t\tdp = dp2;\n\t\t\tdp2.clear();\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nconst std::vector<int> dx{-1, 1, 0, 0}, dy{0, 0, -1, 1};\n\nstd::vector<int> to[30][4];\nstd::unordered_map<int, int> dp[30];\n\nint dfs(int v, int b) {\n    if (dp[v].count(b)) return dp[v][b];\n\n    auto& ret = dp[v][b];\n    if (b == 0) return ret = (v == 0);\n\n    ret = 0;\n    for (int d = 0; d < 4; ++d) {\n        for (auto u : to[v][d]) {\n            if (!((b >> u) & 1)) continue;\n            ret += dfs(u, b ^ (1 << u));\n            if (u != 0) break;\n        }\n    }\n    return ret;\n};\n\nbool solve() {\n    int w, h;\n    std::cin >> w >> h;\n    if (w == 0) return false;\n\n    auto grid = vec(h, vec(w, 0));\n    int n = 0;\n    for (auto& v : grid) {\n        for (auto& x : v) {\n            std::cin >> x;\n\n            if (x == 1) {\n                x = ++n;\n            } else if (x == 2) {\n                x = 0;\n            } else {\n                x = -1;\n            }\n        }\n    }\n\n    for (int sx = 0; sx < h; ++sx) {\n        for (int sy = 0; sy < w; ++sy) {\n            if (grid[sx][sy] == -1) continue;\n\n            int v = grid[sx][sy];\n            for (int d = 0; d < 4; ++d) {\n                to[v][d].clear();\n\n                int x = sx, y = sy;\n\n                while (true) {\n                    x += dx[d], y += dy[d];\n                    if (x < 0 || h <= x || y < 0 || w <= y) break;\n\n                    if (grid[x][y] != -1) {\n                        to[v][d].push_back(grid[x][y]);\n                    }\n                }\n            }\n        }\n    }\n\n    for (int v = 0; v <= n; ++v) dp[v].clear();\n\n    std::cout << dfs(0, (1 << (n + 1)) - 1) << \"\\n\";\n\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint field[11][11];\nint n,m;\nint ci,cj;\n\nint flag[11][11];\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nint dfs(int cnt, int ni, int nj){\n\t//cout << cnt << \" \"  <<  ni << \" \" << nj <<  \" \" <<  \" nij\" << endl;\n\tif(cnt == 0){\n\t\tif(ni == ci || nj == cj) return 1;\n\t\telse return 0;\n\t}\n\tint ret = 0;\n\tfor (int i = 0;i < 4;i++){\n\t\tint ti = ni,tj = nj;\n\t\twhile(true){\n\t\t\tti += dy[i]; tj += dx[i];\n\t\t\tif(ti < 0 || ti >= n || tj < 0 || tj >= m) break;\n\t\t\telse if(flag[ti][tj] == 1){\n\t\t\t\tflag[ti][tj] = 0;\n\t\t\t\tret += dfs(cnt-1,ti,tj);\n\t\t\t\tflag[ti][tj] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(true){\n\n\t\t\tcin >> m >> n;\n\t\t\tif(m == 0) break;\n\n\t\t\tint cnt = 0;\n\n\t\t\tfor (int i = 0;i < n;i++){\n\t\t\t\tfor (int j = 0;j < m;j++){\n\t\t\t\t\tcin >> field[i][j];\n\t\t\t\t\tflag[i][j] = field[i][j];\n\t\t\t\t\tif(field[i][j] == 2){\n\t\t\t\t\t\tcj = j; ci = i;\n\t\t\t\t\t}\n\t\t\t\t\tif(field[i][j] == 1) cnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcout << dfs(cnt,ci,cj) << endl;\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n\nmap<int,int> msi;\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\ninline int getindex(int src, int s){\n  ;\n}\n\n\nint dfs(int S){\n  int src = S>>23;\n  int x = hx[src];\n  int y = hy[src];\n  int s = S&((1<<23)-1);\n\n#if DEB\n  printf(\"src:%d , x:%d , y:%d , s:%d\\n\",src,x,y,s);\n#endif\n\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(S) ){ //ùÉÊÁ½óÔ\n    return msi[S];\n  }\n  \n  // v[gªu¯È¢ÆÌL³\n  /*\n    1831764\n    ari  :: msi_sz: 885661  >0:376369  ==0:509292  already>0:222390 , already==0:408636\n    nari :: msi_sz:1028771  >0:376369  ==0:652402  already>0:222390 , already==0:565310\n   */\n  \n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<num[y][x])) ){\n    return 0;\n  }\n  \n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs((dest<<23)|(s|(1<<dest)));\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[S] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home<<23));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint bfs() {\n\n\tint ans = 0;\n\tqueue<P> que;\n\tque.push(P(hs, (1 << hs) - 1));\n\n\twhile (!que.empty()) {\n\t\tint idx, bits;\n\t\ttie(idx, bits) = que.front(); que.pop();\n\t\tint nr, nc;\n\t\ttie(nr, nc) = vp[idx];\n\t\tif (bits == 0) {\n\t\t\tif (nr == sr || nc == sc) ans++;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\t\tint x = tb[i][nc];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tint t = bits & ~(1 << x);\n\t\t\t\tif (!t) {\n\t\t\t\t\tif (i == sr || nc == sc) ans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\t\tint x = tb[i][nc];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tint t = bits & ~(1 << x);\n\t\t\t\tif (!t) {\n\t\t\t\t\tif (i == sr || nc == sc) ans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\t\tint x = tb[nr][j];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tint t = bits & ~(1 << x);\n\t\t\t\tif (!t) {\n\t\t\t\t\tif (nr == sr || j == sc) ans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\t\tint x = tb[nr][j];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tint t = bits & ~(1 << x);\n\t\t\t\tif (!t) {\n\t\t\t\t\tif (nr == sr || j == sc) ans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\tvp.push_back(P(sr, sc));\n\n\t\tcout << bfs() << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#define rep(i, n) for ( int i = 0; i < n; i++)\nusing namespace std;\n\n#define MAX 10\n\n#define HOUSE 3\n#define SPACE 0\n#define SMOKE 1\n#define START 2\n#define BLOCK 4\n/*\n#define HOUSE '3'\n#define SPACE '0'\n#define SMOKE '1'\n#define START '2'\n#define BLOCK 'X'\n*/\n\nint H, W;\nclass State{\npublic:\n  unsigned short pi, pj, total;\n  //unsigned short G[MAX+2][MAX+2];\n  //char G[MAX+2][MAX+2];\n  bool V[MAX+2][MAX+2];\n\n  State(){total = 0;}\n  //State(int H, int W):H(H), W(W){ total = 0;}\n\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\t//if ( G[i][j] == s.G[i][j] ) continue;\n\t//return G[i][j] < s.G[i][j];\n\tif ( V[i][j] == s.V[i][j] ) continue;\n\treturn V[i][j] < s.V[i][j];\n      }\n    }\n    return false;\n  }\n\n};\n\nstatic int di[4] = {0, -1, 0, 1};\nstatic int dj[4] = {1, 0, -1, 0};\n\nint  G[MAX+2][MAX+2];\n\n\nmain(){\n  int si, sj;\n\n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    int total = 0;\n\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) G[i][j] = BLOCK;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\tcin >> G[i][j];\n\tif ( G[i][j] == START ){ si = i; sj = j;}\n\tif ( G[i][j] == SMOKE ) total++;\n      }\n    }\n\n    /*\n    bool zero[MAX+2];\n    int tmp[MAX+2][MAX+2];\n    for ( int i = 1; i <= H; i++ ) zero[i] = true;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) tmp[i][j] =  G[i][j];\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 1; j <= W; j++ ) if ( G[i][j] ) zero[i] = false;\n    int ii = 0;\n    int c = 0;\n    for ( int i = 0; i < H+2; i++ ){\n      if ( zero[i] ) { c++; continue;}\n      for ( int j = 0; j < W+2; j++ ) G[ii][j] = tmp[i][j];\n      ii++;\n    }\n    H -= c;\n\n    for ( int j = 1; j <= W; j++ ) zero[j] = true;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) tmp[i][j] =  G[i][j];\n    for ( int j = 1; j <= W; j++ ) \n      for ( int i = 0; i < H+2; i++ )\n\tif ( G[i][j] ) zero[j] = false;\n    \n    int jj = 0;\n    c = 0;\n    for ( int j = 0; j < W+2; j++ ){\n      if ( zero[j] ) { c++; continue;}\n      for ( int i = 0; i < H+2; i++ ) G[i][jj] = tmp[i][j];\n      jj++;\n    }\n    W -= c;\n\n    */\n\n\n    State s = State();\n    \n    for ( int i = 0; i <= H+1; i++ )\n      for ( int j = 0; j <= W+1; j++ ) s.V[i][j] = ((G[i][j]==SMOKE)?true:false);\n    \n    map<State, int> M;\n    State v;\n\n    int ni, nj;\n    M[s] = 0;\n    \n    for ( int r = 0; r < 4; r++ ){\n      ni = si + di[r];\n      nj = sj + dj[r];\n\n      while(1){\n\t//if ( s.G[ni][nj] == SMOKE ){\n\tif ( s.V[ni][nj] ){\n\t  v = s;\n\t  v.pi = ni;\n\t  v.pj = nj;\n\t  //v.G[ni][nj] = HOUSE;\n\t  v.V[ni][nj] = false;\n\t  v.total = 1;\n\t  M[v] = 1;\n\t  break;\n\t} else if ( G[ni][nj] == BLOCK ) break;\n\tni += di[r];\n\tnj += dj[r];\n      }\n    }\n\n    map<State, int>::iterator it;\n    \n    int presize = M.size();\n\n    int cc = 0;\n    int x = 0;\n    bool f;\n    map<State, int> nM;\n\n    \n    while(1){\n      //      nM = map<State, int>();\n      nM.clear();\n      f = true;\n      for ( it = M.begin(); it != M.end(); it++ ){\n\tState cur = (*it).first;\n\tint cost = (*it).second;\n\tif ( cost == 0 ) continue;\n\n\tfor ( int r = 0; r < 4; r++ ){\n\t  ni = cur.pi + di[r];\n\t  nj = cur.pj + dj[r];\n\n\t  while(1){\n\t    //if ( cur.G[ni][nj] == SMOKE ){\n\t    if ( cur.V[ni][nj]){\n\t      v = cur;\n\t      v.pi = ni;\n\t      v.pj = nj;\n\t      //v.G[ni][nj] = HOUSE;\n\t      v.V[ni][nj] = false;\n\t      v.total++;\n\t      f = false;\n\t      nM[v] += cost;\n\t      break;\n\t      //\t    } else if ( cur.G[ni][nj] == START && cur.total == total ){\n\t    } else if ( ni == si && nj == sj && cur.total == total ){\n\t      x += cost;\n\t      break;\n\t    } else if ( G[ni][nj] == BLOCK ) {\n\t      break;\n\t    }\n\n\t    ni += di[r];\n\t    nj += dj[r];\n\t  }\n\t}\n      }\n      if ( f ) break;\n      M = nM;\n    }\n\n    cout << x << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include <cstring>\n#include<map>\n#define MAX 11\n#define MAX_BITS 23\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nmap<int,int> dp;\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit, int numResults){\n//\tcout << \"hi\" << bit << endl;\n\tif(housInd[ny][nx] != -1 && dp.find(bit | housInd[ny][nx] << MAX_BITS) != dp.end()){\n\t\treturn dp[bit | housInd[ny][nx] << MAX_BITS];\n\t}\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\t\n\tif (isLast && dp.find(bit | housInd[ny][nx] << MAX_BITS) != dp.end()) return dp[bit | housInd[ny][nx] << MAX_BITS];\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[bit | housInd[ny][nx] << MAX_BITS] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!isLast) {\n\t\t\t\t\tif ((bit & 1 << ind) == 0) {\n\t\t\t\t\t\tret += func(y, x, bit | (1 << ind), numResults+1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn housInd[ny][nx] != -1 && numResults % 2 == 0 ? (dp[bit | housInd[ny][nx] << MAX_BITS] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tdp.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0, 0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint m[10][10];\nint memo[1<<23][25];\nint posx[25];\nint posy[25];\nint w;\nint h;\n\nint solve(int flag, int id){\n  if(memo[flag][id] != -1)\n    return memo[flag][id];\n\n  int x = posx[id];\n  int y = posy[id];\n\n  if(flag == 0){\n    for(int d = 0; d < 4; d++){\n      // 4ûüÉÂ¢Ä\n      int yy = y + _dy[d];\n      int xx = x + _dx[d];\n\n      while(ISIN(xx, yy, w, h)){\n        int t = m[yy][xx];\n\n        if(t == 1) return memo[flag][id] = 1;\n        if(t != 0) break;\n\n        yy += _dy[d]; xx += _dx[d];\n      }\n    }\n    return memo[flag][id] = 0;\n  }\n\n  int ret = 0;\n\n  for(int d = 0; d < 4; d++){\n    // 4ûüÉÂ¢Ä\n    int yy = y + _dy[d];\n    int xx = x + _dx[d];\n\n    while(ISIN(xx, yy, w, h)){\n      int t = m[yy][xx];\n\n      if(t > 1){\n        int tt = t - 2;\n\n        if((flag & (1 << tt)) != 0){\n          ret += solve((flag ^ (1 << tt)), t);\n        }else{\n          break;\n        }\n      }\n\n      yy += _dy[d]; xx += _dx[d];\n    }\n  }\n\n  return memo[flag][id] = ret;\n}\n\nint main(){\n  while(true){\n    w = getInt();\n    h = getInt();\n\n    if(w + h == 0) break;\n\n    int cnt = 0;\n\n    REP(i,h) REP(j,w){\n      // ID ðUè¼µÈªçÛ¶\n      int tmp = getInt();\n\n      if(tmp == 1){\n        posy[2 + cnt] = i;\n        posx[2 + cnt] = j;\n        m[i][j] = 2 + cnt++;\n      }else if(tmp == 2){\n        posy[1] = i;\n        posx[1] = j;\n        m[i][j] = 1;\n      }else{\n        m[i][j] = tmp;\n      }\n    }\n\n    memset(memo, -1, sizeof(memo));\n    int ans = solve( (1<<cnt) - 1, 1 );\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <ext/hash_map>\n//#include <tr1/unordered_map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n//using namespace tr1;\nusing namespace __gnu_cxx;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n#define SZ 885777\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\nhash_map<int,int> hii(SZ);\n//unordered_map<int,int> hii(SZ);\n\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //ツ静「ツ妥篠づ可姪淞づェツづゥ\n    return 1;\n  }\n  if( isnotgoal(s) ){ //ツ仰ウツ嘉ッツづ可姪淞づゥツつスツづ淞づ個嘉づーツ湘氾ッツつオツつスツつゥツづつ、ツつゥ\n    return 0;\n  }\n  hash_map<int,int>::iterator it = hii.find(S);\n  //unordered_map<int,int>::iterator it = hii.find(S);\n  if( it!=hii.end() ){ //ツ探ツ催オツ催渉づ敖づ個湘ウツ妥板つゥツづつ、ツつゥ\n    return it->second;\n  }\n\n  // ツプツδ個ゼツδ督トツつェツ置ツつッツづ按つ「ツ嘉づ個有ツ鳴ウ\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  hii.insert(make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    hii.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include <cstring>\n#define MAX 12\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint dp[(1<<18)][23];\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n\tif(housInd[ny][nx] != -1 && bit < (1 << 18) && dp[bit][housInd[ny][nx]] != -1)\n\t\treturn dp[bit][housInd[ny][nx]];\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[bit][housInd[ny][nx]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((bit & 1 << ind) != 0) break;\n\t\t\t\tif (!isLast)ret += func(y, x, bit | (1 << ind));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn housInd[ny][nx] != -1 && bit < (1 << 18) ? (dp[bit][housInd[ny][nx]] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second \n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  int ni,nj;\n  int cnt;\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;\n    vis=0;\n    vis|=(1<<houseId[si][sj]);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n\n  while(!qs.empty()){\n    bool bCont=false;\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;\n    qs.pop();\n\n    if( st_now.cnt == nhouse ){\n      for(int k = 0; k < MAXDIR; ++k){\n\tif( M[ni][nj].cexist[k] ){\n\t  ++ans;\n\t  bCont=true;\n\t}\n      }\n    }\n    if(bCont)continue;\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !( st_now.vis&(1<<houseId[next.fr][next.sc]) ) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis|=(1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }else{\n\t    //break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = UP; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MSG(a) cout << #a << \" \" << a << endl;\ntemplate<class T, class C> pair<T,C> mp(T a, C b){ return make_pair(a, b); }\n\nint X, Y;\npint P;\n\nll rec(vector<vint> field, pint p, int s)\n{\n\tif(!s && p == P) return 1;\n\n\tfield[p.first][p.second] = (field[p.first][p.second] == 1 ? 0 : 1);\n\n\tll res = 0;\n\tfor(int i = p.first + 1; i < X; i++)   if(field[i][p.second]){ res += rec(field, mp(i,p.second), s-1); break; }\n\tfor(int i = p.first - 1; 0 <= i; i--)  if(field[i][p.second]){ res += rec(field, mp(i,p.second), s-1); break; }\n\tfor(int i = p.second + 1; i < Y; i++)  if(field[p.first][i]) { res += rec(field, mp(p.first, i), s-1); break; }\n\tfor(int i = p.second - 1; 0 <= i; i--) if(field[p.first][i]) { res += rec(field, mp(p.first, i), s-1); break; }\n\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> X >> Y && X)\n\t{\n\t\tint s = 0;\n\t\tvector<vint> field(X, vint(Y));\n\n\t\trep(y,Y) rep(x,X)\n\t\t{\n\t\t\tcin >> field[x][y];\n\t\t\tif(field[x][y] == 1) s++;\n\t\t\tif(field[x][y] == 2) P = mp(x, y);\n\t\t}\n\n\t\tcout << rec(field, P, s + 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint memo[1<<19][23];\nint target;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif(done<(1<<19)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tif(done<(1<<19)&&table[i][j]>=0&&memo[done][table[i][j]]){\n\t\tmemo[done][table[i][j]]=ret;\n\t}\n\t//cout << done << \", \" << i << \", \" << j << \": \" << ret << endl;\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tint c=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(memo,-1,sizeof(memo));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <bitset>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int m, n;\n  while(cin>>m>>n,m||n) {\n    int ba[m][n];\n    int num = 0;\n    int sx,sy;\n    REP(i,n) {\n      REP(j,m) {\n        int a;\n        cin >> a;\n        if (a==1) {\n          ba[j][i] = ++num;\n        } else {\n          ba[j][i] = 0;\n          if (a == 2)\n            sx=j;sy=i;\n        }\n      }\n    }\n    const int dx[] = {0,1,0,-1};\n    const int dy[] = {-1,0,1,0};\n    map<int, int> mp;\n    mp[((1<<num)-1)*100+sx*10+sy] = 1;\n    REP(i, num) {\n      map<int, int> nextmp;\n      FOR(it, mp) {\n        int hoge = it->first;\n        int S = hoge/100;\n        int x = (hoge%100)/10;\n        int y = hoge%10;\n//        cout << bitset<7>(S) << \" \" << x << \" \"<<y << \" \" << it->second << endl;\n        REP(k,4) {\n          int xx = x, yy = y;\n          while(1) {\n            xx += dx[k]; yy += dy[k];\n            if (xx<0 || xx>=m || yy<0||yy>=n) break;\n            if (ba[xx][yy]) {\n              if (S&(1<<(ba[xx][yy]-1))) {\n                nextmp[(S-(1<<(ba[xx][yy]-1)))*100+xx*10+yy] += it->second;\n                break;\n              }\n            }\n          }\n        }\n      }\n      //  cout << endl;\n      mp = nextmp;\n    }\n    int res = 0;\n    REP(y,n) {\n      REP(x,m) {\n        if (x==sx || y==sy)\n          res += mp[x*10+y];\n      }\n    }\n    cout << res << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\nint T[10][10];\nint V[10][10];\nint m,n,cx,cy,h=0,c=0;\nvoid f(int x,int y,int h){\n\n\tif(h==0){\n\t\tif(x==cx || y==cy) c++;\n\t\telse return;\n\t}\n\n\tif(y-1>=0){\n\t\tfor(int i=y-1;i>=0;i--){\n\t\tif(T[x][i]==1 && V[x][i]==0){\n\t\t\tV[x][i]=1;\n\t\t\tf(x,i,h-1); V[x][i]=0;\n\t\t\tbreak;\n\t\t}\n\t  }\n\t}\n\n\tif(y+1<m){\n\t\tfor(int i=y+1;i<m;i++){\n\t\tif(T[x][i]==1 && V[x][i]==0){\n\t\t\tV[x][i]=1;\n\t\t\tf(x,i,h-1); V[x][i]=0;\n\t\t\tbreak;\n\t\t}\n\t  }\n\t}\n\n\tif(x-1>=0){\n\t\tfor(int i=x-1;i>=0;i--){\n\t\tif(T[i][y]==1  && V[i][y]==0){\n\t\t\tV[i][y]=1;\n\t\t\tf(i,y,h-1); V[i][y]=0;\n\t\t\tbreak;\n\t\t}\n\t  }\n\t}\n\n\tif(x+1<n){\n\t\tfor(int i=x+1;i<n;i++){\n\t\tif(T[i][y]==1  && V[i][y]==0){\n\t\t\tV[i][y]=1;\n\t\t\tf(i,y,h-1); V[i][y]=0;\n\t\t\tbreak;\n\t\t}\n\t  }\n\t}\n\n}\n\nint main(){\n\n\twhile(1){\n\n\t\tcin >> m >> n;\n\t\tif(m==0 && n==0) break;\n\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tcin >> T[i][j];\n\t\t\t\tif(T[i][j]==2){\n\t\t\t\t\tcx=i; cy=j;\n\t\t\t\t}\n\t\t\t\tif(T[i][j]==1) h++;\n\t\t\t}\n\t\t}\n\n\t\tf(cx,cy,h);\n\n\t\tcout << c << endl;\n\n\t\tc=0; h=0;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tT[i][j]=0; V[i][j]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint H,W;\nint G[11][11],INDEX[11][11],ep_bitmask,sp,V;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvector<int> edges[25][4];\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void INIT(){\n  ep_bitmask = 0, sp = -1;\n  rep(i,11) rep(j,11) INDEX[i][j] = -1;\n  rep(i,25) rep(j,4) edges[i][j].clear();\n}\n\ninline void make_edges(){\n  rep(i,H) rep(j,W) if( G[i][j] != 0 ) {\n    int x = j, y = i;\n    rep(k,4){\n      int nx = x + dx[k], ny = y + dy[k];\n      while( isValid(nx,ny) ){\n        if( G[ny][nx] == 1 ) edges[INDEX[i][j]][k].push_back(INDEX[ny][nx]);\n        nx += dx[k], ny += dy[k];\n      }\n    }\n  }\n}\n\ninline void calc_last_point(int x,int y){\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    while( isValid(nx,ny) ){\n      if( G[ny][nx] == 1 ) ep_bitmask |= (1<<INDEX[ny][nx]);\n      nx += dx[i], ny += dy[i];\n    }\n  }\n}\n\nint dfs(int cur,int visited,int remain,int ep_remain){\n\n  if( ep_remain == 0 && remain != 0 ) return 0;\n  if( remain <= 0 ) return ( (ep_bitmask>>cur) & 1 );\n\n  int ret = 0;\n  rep(k,4){\n    rep(i,edges[cur][k].size()){\n      int next = edges[cur][k][i];\n      if( (visited>>next) & 1 ) continue;\n      ret += dfs(next,visited|(1<<next),remain-1,ep_remain-((ep_bitmask>>next)&1));\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while( scanf(\"%d%d\",&W,&H), H|W ){\n    INIT();\n    int idx = 0,remain = 0,sx,sy;\n    rep(i,H) rep(j,W) {\n      scanf(\"%d\",&G[i][j]);\n      if( G[i][j] == 1 ) INDEX[i][j] = idx++, remain++;\n      if( G[i][j] == 2 ) sx = j, sy = i;\n    }\n    sp = INDEX[sy][sx] = idx++;\n    make_edges();\n\n    calc_last_point(sx,sy);\n    assert(remain <= 23);\n    V = remain;\n    printf(\"%d\\n\",dfs(sp,0,remain,__builtin_popcount(ep_bitmask)));\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n//int solve(vvi& field,pii church,pii now,int n)\nint h,w;\nint solve(int field[11][11],pii church,pii now,int n)\n{\n\tif(n==0)\n\t\treturn church.first==now.first || church.second==now.second;\n\t\n\tstatic const int di[]={-1,1,0,0};\n\tstatic const int dj[]={0,0,-1,1};\n\t//int h=field.size(),w=field[0].size();\n\tint res=0;\n\trep(i,4){\n\t\tint pi=now.first,pj=now.second;\n\t\tfor(;;){\n\t\t\tpi+=di[i];\n\t\t\tpj+=dj[i];\n\t\t\tif(pi<0 || h<=pi || pj<0 || w<=pj)\n\t\t\t\tbreak;\n\t\t\tif(field[pi][pj]==1){\n\t\t\t\tfield[pi][pj]=0;\n\t\t\t\tres+=solve(field,church,mp(pi,pj),n-1);\n\t\t\t\tfield[pi][pj]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"(%d,%d) %d: %d\\n\",now.first,now.second,n,res);\n\treturn res;\n}\n\nint main()\n{\n\tint field[11][11];\n\t//for(int w,h;cin>>w>>h,w|h;){\n\tfor(;cin>>w>>h,w|h;){\n\t\t//vvi field(h,vi(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>field[i][j];\n\t\tvector<pii> homes;\n\t\trep(i,h) rep(j,w)\n\t\t\tif(field[i][j]==1)\n\t\t\t\thomes.push_back(mp(i,j));\n\t\t\telse if(field[i][j]==2)\n\t\t\t\thomes.insert(homes.begin(),mp(i,j));\n\t\t\n\t\t//printf(\"h:%d w:%d homes:%d\\n\",h,w,homes.size()-1);\n\t\t//clock_t begin=clock();\n\t\tcout<<solve(field,homes[0],homes[0],homes.size()-1)<<endl;\n\t\t//printf(\"time: %ldms\\n\",clock()-begin);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint f[10][10], x[24], y[24], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[++p] = i, y[p] = j, dat[i][j] = p;\n\t\t\tif (f[i][j] == 2)x[0] = i, y[0] = j;\n\t\t}p++;\n\t\tmap<P, int>dp;\n\t\tdp[{0, 0}] = 1;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif ((f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) || (f[nx][ny] == 2 && i == (1 << p) - 2)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[{(1 << p) - 1, 0}]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp,y,x;\nshort ans;\nshort dp[1<<23][24];\nP pos[24];\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    int upper = (1<<(pn-1));\n    for(int i=0;i<upper;i++)\n      for(int j=0;j<pn;j++)dp[i][j] = 0;\n    dp[0][0] = 1;\n\n    ans = 0;\n    for(int i=0;i<upper;i++){\n      for(int j=0;j<pn;j++){\n\tif(dp[i][j]){\n\t  y = pos[j].first; x = pos[j].second;\n\t  for(int k=0;k<4;k++){\n\t    int ty = y+dy[k], tx = x+dx[k];\n\t    for(;;){\n\t      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n\t      if(i == upper-1 && g[ty][tx] == 0){\n\t\tans += dp[i][j];\n\t\tbreak;\n\t      }\n\t      if(0<g[ty][tx]){\n\t\ttmp = g[ty][tx] - 1;\n\t\tif( (i>>tmp)&1 )break;\n\t\telse dp[i|(1<<tmp)][tmp+1] += dp[i][j];\n\t      }\n\t      ty += dy[k]; tx += dx[k];\n\t    }\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\",ans);\t      \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef int ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstruct T{\n\tll first,second,third;\n\tbool operator<(const T& t)const{\n\t\treturn first!=t.first?(first<t.first):(second!=t.second?second<t.second:third<t.third);\n\t}\n};\nll w,h,g[10][10];\nll cx,cy;\ninline vector<P> doko(ll y,ll x){\n\tvector<P> v;\n\tfor(ll nx=x+1;nx<w;nx++){\n\t\tif(g[y][nx]>0) v.push_back(P(y,nx));\n\t\tif(g[y][nx]==1) break;\n\t}\n\tfor(ll nx=x-1;nx>=0;nx--){\n\t\tif(g[y][nx]>0) v.push_back(P(y,nx));\n\t\tif(g[y][nx]==1) break;\n\t}\n\tfor(ll ny=y+1;ny<h;ny++){\n\t\tif(g[ny][x]>0) v.push_back(P(ny,x));\n\t\tif(g[ny][x]==1) break;\n\t}\n\tfor(ll ny=y-1;ny>=0;--ny){\n\t\tif(g[ny][x]>0) v.push_back(P(ny,x));\n\t\tif(g[ny][x]==1) break;\n\t}\n\treturn v;\n}\nll n;\nll id[10][10];\n//set<T> t;\nll dfs(ll y,ll x,ll s){\n\t//if(t.count((T){y,x,s})) return 0;\n\tll res=0;\n\tvector<P> v=doko(y,x);\n\tif(s==(1<<n)-1){\n\t\tfor(ll i=0;i<v.size();i++){\n\t\t\tif(g[v[i].first][v[i].second]==2) return 1;\n\t\t}\n\t\t//t.insert((T){y,x,s});\n\t\treturn 0;\n\t}\n\tif(s) g[y][x]=-1;\n\tfor(ll i=0;i<v.size();i++){\n\t\tif(g[v[i].first][v[i].second]==2) continue;\n\t\tres+=dfs(v[i].first,v[i].second,s|(1<<id[v[i].first][v[i].second]));\n\t}\n\tg[y][x]=1;\n\t//if(res==0) t.insert((T){y,x,s});\n\treturn res;\n}\n\nint main()\n{while(1){\n\tscanf(\"%d%d\",&w,&h);\n\tn=0;\n\t//t.clear();\n\tmemset(id,-1,sizeof(id));\n\tif(!w) return 0;\n\tfor(ll i=0;i<h;i++) for(ll j=0;j<w;j++){\n\t\tscanf(\"%d\",&g[i][j]);\n\t\tif(g[i][j]==2){\n\t\t\tcx=j,cy=i;\n\t\t}\n\t\telse if(g[i][j]){\n\t\t\tid[i][j]=n;\n\t\t\tn++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(cy,cx,0));\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define fr first\n#define sc second \n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define MAXDIR 4\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], bool vis[][MAX], int bi, int bj, int nhouse, int cnt, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[bi][bj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[bi][bj].exist[k] ){\n\tfor(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\t  pi next = M[bi][bj].link[k][v];\n\t  if( !vis[next.fr][next.sc] ){\n\t    vis[next.fr][next.sc]=true;\n\t    dfs( M, vis, next.fr, next.sc, nhouse, cnt+1, ans );\n\t    vis[next.fr][next.sc]=false;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = UP; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    dfs(M,vis,charch.fr,charch.sc,nhouse,0,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint vec[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint tab[12][12];\nint wx,wy;\nvoid solve(int nx,int ny,int rem){\n    for(int v=0;v<4;v++){\n        int nowx=nx,nowy=ny;\nLA:;\n   nowx+=vec[v][0],nowy+=vec[v][1];\n   if(!(0<=nowx&&nowx<wx&&0<=nowy&&nowy<wy)) goto LB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB: ;        \n    }\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nsigned main(){\ncout << 36 << endl;\ncout << 57 << endl;\ncout << 419957 << endl;\ncout << 256548 << endl;\ncout << 1831764 << endl;\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&(house_num==0||((state>>(house_num-1))&1)==1)) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((__builtin_popcount(state)>14||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1){\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(__builtin_popcount(state)<=14&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (__builtin_popcount(state)<=14?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <memory>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint field[12][12];\n\nint dfs(int cnt, int x, int y){\n  if(cnt == 0){\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      while(field[y2][x2] == 0){\n\ty2 += dy[i];\n\tx2 += dx[i];\n      }\n      if(field[y2][x2] == 2) return 1;\n    }\n    return 0;\n  }\n  int res = 0;\n  rep(i, 4){\n    int x2 = x + dx[i];\n    int y2 = y + dy[i];\n    while(field[y2][x2] != 3){\n      if(field[y2][x2] == 1){\n\tfield[y2][x2] = 3;\n\tres += dfs(cnt-1, x2, y2);\n\tfield[y2][x2] = 1;\n      }\n      x2 += dx[i];\n      y2 += dy[i];\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n, m, sx, sy, cnt;\n  while(cin >> m >> n && (n || m)){\n    cnt = 0;\n    fill(&field[0][0], &field[11][11] + 1, 3);\n    rep(i, n){\n      rep(j, m){\n\tcin >> field[i+1][j+1];\n\tif(field[i+1][j+1] == 2){\n\t  sx = j + 1;\n\t  sy = i + 1;\n\t}\n\tif(field[i+1][j+1] == 1){\n\t  cnt++;\n\t}\n      }\n    }\n    cout << dfs(cnt, sx, sy) << endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\n//int memo[1<<K][23];\nunordered_map<int, int> memo2[23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}*/\n\tif(done%11==0&&table[i][j]>=0&&memo2[table[i][j]].find(done)!=memo2[table[i][j]].end())\n\t{\n\t\treturn memo2[table[i][j]][done];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\t/*\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(table[i][j]>=0){\n\t\t\t\t\tmemo2[table[i][j]][done]=0;\n\t\t\t\t}*/\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}*/\n\tif(table[i][j]>=0&&done%7==0){\n\t\tmemo2[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tfor(int i=0;i<c;i++){\n\t\tmemo2[i].clear();\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define fr first\n#define sc second\n#define MAXDIR 4\n\n//vector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(char si, char sj, char cnt, int vis):ni(si),nj(sj),cnt(cnt),vis(vis){}\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n/*\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n*/\n\nstruct Queue{\n  int p;\n  state *V;\n  Queue():p(0){V=new state[1<<20];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){\n    V[p++]=t;\n  }\n  state & front(){\n    return V[p-1];\n  }\n  void pop(){--p;}\n  bool empty(){\n    return p==0;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  int ni,nj;\n  int housenum=0;\n  int chi=charch.fr;int chj=charch.sc;\n  \n  for(int k = 0; k < MAXDIR; ++k){\n    housenum += M[chi][chj].linkmax[k];\n  }\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    ni = st_now.ni;\n    nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }else{\n\n      int left = housenum;\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n      \n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  int mask=1<<houseId[next.fr][next.sc];\n\t  if( !(st_now.vis&mask) ){\n\t    qs.push( state(next.fr,next.sc,st_now.cnt + 1,st_now.vis|mask) );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &iM[i][j]);\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc,0,0);\n    bfs(M,init,nhouse,ans);\n    printf(\"%d\\n\", ans);\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint dp[1<<23][23]; //ここまで、現在地\n\nint main() {\n\n\tSTART:\n\t\n\tint m,n;\n\tcin >> m >> n;\n\tif(n == 0 && m == 0) return 0;\n\tint a[10][10];\n\tvector<pair<int,int> > house;\n\tpair<int,int> kyokai;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j] == 0) a[i][j] = -1; //空地\n\t\t\telse if(a[i][j] == 2){\n\t\t\t\ta[i][j] = -2; //教会\n\t\t\t\tkyokai = MP(i,j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i][j] = house.size();\n\t\t\t\thouse.push_back(MP(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\t//経路計算\n\tvector<pair<int,int>> way[23];\n\tfor(int i=0; i<house.size(); i++){\n\t\tint x = house[i].first;\n\t\tint y = house[i].second;\n\t\tint tmp = 0;\n\t\tfor(int j=x+1; j<n; j++){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=x-1; j>=0; j--){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=y+1; j<m; j++){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=y-1; j>=0; j--){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t}\n\n\t//教会隣接家dp初期化\n\tfor(int i=0; i<house.size(); i++) dp[(1<<house.size())-1][i] = 0;\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//dp\n\tfor(int i=(1<<house.size())-2; i>=0; i--){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\tdp[i][j] = 0;\n\t\t\tif((i&(1<<j)) == 0) continue;\n\t\t\tfor(int k=0; k<way[j].size(); k++){\n\t\t\t\tif((i&way[j][k].second) == 0){\n\t\t\t\t\tdp[i][j] += dp[i+(1<<way[j][k].first)][way[j][k].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//最終的な答え\n\tint ans = 0;\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += dp[1<<a[i][kyokai.second]][a[i][kyokai.second]];\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += dp[1<<a[i][kyokai.second]][a[i][kyokai.second]];\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += dp[1<<a[kyokai.first][i]][a[kyokai.first][i]];\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += dp[1<<a[kyokai.first][i]][a[kyokai.first][i]];\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\tgoto START;\n\n\t/*\n\t//デバッグ\n\tfor(int i=0; i<house.size(); i++){\n\t\tfor(int j=0; j<way[i].size(); j++){\n\t\t\tcout << way[i][j].first << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tfor(int i=0; i<(1<<house.size()); i++){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint W, H, cnt, g[11][11], X[24], Y[24];// memo[1 << 23][24];\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nint rec(int S, int i) {\n\tif (S == (1 << cnt) - 1) {\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[i], ny = Y[i];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (g[ny][nx] == -1 || !in_range(nx, ny)) break;\n\t\t\t\tif (g[ny][nx] == -2) return 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\t//if (memo[S][i] != -1) return memo[S][i];\n\t\n\t//int& res = memo[S][i];\n\tint res = 0;\n\t\n\tfor_(d,0,4) {\n\t\tint nx = X[i], ny = Y[i];\n\t\t\n\t\tfor_(rep,0,10) {\n\t\t\tnx += dx[d];\n\t\t\tny += dy[d];\n\t\t\t\n\t\t\tif (g[ny][nx] == -1 || !in_range(nx, ny)) break;\n\t\t\tif (g[ny][nx] < -1) continue;\n\t\t\t\n\t\t\tint j = g[ny][nx];\n\t\t\t\t\t\t\n\t\t\tg[ny][nx] = -1;\n\t\t\tres += rec(S | 1 << j, j);\n\t\t\tg[ny][nx] = j;\n\t\t}\n\t}\n\t\t\n\treturn res;\n}\n\nvoid solve() {\n\t//for_(S,0,1<<cnt) for_(i,0,24) memo[S][i] = -1;\n\tcout << rec(0, 23) << endl;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tcnt = 0;\n\t\t\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tcin >> g[y][x];\n\t\t\t\n\t\t\tif (g[y][x] == 0) g[y][x] = -3;\n\t\t\telse if (g[y][x] == 1) { X[cnt] = x; Y[cnt] = y; g[y][x] = cnt; ++cnt; }\n\t\t\telse if (g[y][x] == 2) { X[23] = x; Y[23] = y; g[y][x] = -2; }\n\t\t}\n\t\t\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=16){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=20){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nstack<int> st;\n\nclass state{\npublic:\n  int x,y,s;\n  state(int _x, int _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool ischeck(int s){\n  return ( (s&last) == last );\n}\n\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ // ÆÍ³ïÉßêé©Ç¤©\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = x + dx[k]*i;\n\tint ty = y + dy[k]*i;\n\tif( inside(tx,ty) || field[ty][tx]==1 )break;\n\n\tif( field[ty][tx]==2 ){\n#if DEB\n\t  printf(\"goal , (%d,%d)  s:%d\\n\",x,y,s);\n\t  stack<int> tmp = st;\n\t  while( !tmp.empty() ){\n\t    printf(\"%d,\",tmp.top());\n\t    tmp.pop();\n\t  }\n\t  puts(\"\\n\");\n#endif\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½ê\n    return msi[state(x,y,s)];\n  }\n  if( ischeck(s) ) return 0;\n\n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tif( s&(1<<num[ty][tx]) ) break;\t\n#if DEB\n\tst.push(num[ty][tx]);\n#endif \n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n#if DEB\n\tst.pop();\n#endif\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  break;\n\t}\n      }\n    }\n#if DEB\n    printf(\"home:%d  sx,sy = %d,%d\\n\",home,sx,sy);\n    printf(\"last:%d\\n\",last);\n    rep(i,h){\n      rep(j,w){\n\tprintf(\"%2d \",num[i][j]);\n      }\n      puts(\"\");\n    }\n#endif   \n    dfs(sx,sy,0);\n    printf(\"%d\\n\",msi[state(sx,sy,0)]);\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int>>V; int H, W, cnt, vx, vy;\nvoid solve(vector<vector<int>> &p, int x, int y, int cr) {\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tint cx = x, cy = y;\n\tif (cr == 0) { if (x == vx || y == vy)cnt++; return; }\n\tfor (int i = 0; i < 4; i++) {\n\t\tcx = x; cy = y;\n\t\twhile (true) {\n\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)break;\n\t\t\tif (p[cx][cy] == 3) {\n\t\t\t\tp[cx][cy] = 1;\n\t\t\t\tsolve(p, cx, cy, cr - 1);\n\t\t\t\tp[cx][cy] = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcx += dx[i]; cy += dy[i];\n\t\t}\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; if (H == 0)break; cnt = 0; int vr = 0;\n\t\tvector<vector<int>> a(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) { vx = i; vy = j; }\n\t\t\t\tif (a[i][j] == 1) { a[i][j] = 3; vr++; }\n\t\t\t}\n\t\t}\n\t\tsolve(a, vx, vy, vr);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef int ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstruct T{\n\tll first,second,third;\n\tbool operator<(const T& t)const{\n\t\treturn first!=t.first?(first<t.first):(second!=t.second?second<t.second:third<t.third);\n\t}\n};\nll w,h,g[10][10];\nll cx,cy;\nvector<P> doko(ll y,ll x){\n\tvector<P> v;\n\tfor(ll nx=x+1;nx<w;nx++){\n\t\tif(g[y][nx]>0) v.push_back(P(y,nx));\n\t\tif(g[y][nx]==1) break;\n\t}\n\tfor(ll nx=x-1;nx>=0;nx--){\n\t\tif(g[y][nx]>0) v.push_back(P(y,nx));\n\t\tif(g[y][nx]==1) break;\n\t}\n\tfor(ll ny=y+1;ny<h;ny++){\n\t\tif(g[ny][x]>0) v.push_back(P(ny,x));\n\t\tif(g[ny][x]==1) break;\n\t}\n\tfor(ll ny=y-1;ny>=0;--ny){\n\t\tif(g[ny][x]>0) v.push_back(P(ny,x));\n\t\tif(g[ny][x]==1) break;\n\t}\n\treturn v;\n}\nll n;\nll id[10][10];\nset<T> t;\nll dfs(ll y,ll x,ll s){\n\tif(t.count((T){y,x,s})) return 0;\n\tll res=0;\n\tvector<P> v=doko(y,x);\n\tif(s==(1<<n)-1){\n\t\tfor(ll i=0;i<v.size();i++){\n\t\t\tif(g[v[i].first][v[i].second]==2) return 1;\n\t\t}\n\t\tt.insert((T){y,x,s});\n\t\treturn 0;\n\t}\n\tif(s) g[y][x]=-1;\n\tfor(ll i=0;i<v.size();i++){\n\t\tif(g[v[i].first][v[i].second]==2) continue;\n\t\tres+=dfs(v[i].first,v[i].second,s|(1<<id[v[i].first][v[i].second]));\n\t}\n\tg[y][x]=1;\n\tif(res==0) t.insert((T){y,x,s});\n\treturn res;\n}\n\nint main()\n{while(1){\n\tscanf(\"%d%d\",&w,&h);\n\tn=0;\n\tt.clear();\n\tmemset(id,-1,sizeof(id));\n\tif(!w) return 0;\n\tfor(ll i=0;i<h;i++) for(ll j=0;j<w;j++){\n\t\tscanf(\"%d\",&g[i][j]);\n\t\tif(g[i][j]==2){\n\t\t\tcx=j,cy=i;\n\t\t}\n\t\telse if(g[i][j]){\n\t\t\tid[i][j]=n;\n\t\t\tn++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(cy,cx,0));\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint x,y;\nint sx,sy;\nint N;\nint hx[25],hy[25];\nint fie[12][12];\nint dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit,bool done[12][12],int home){\n\tif(memo[pos].find(bit)!=memo[pos].end())return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\t\twhile(fie[cx][cy]!=-1){\n\t\t\t\tif(fie[cx][cy]==100)return 1;\n\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\twhile(fie[cx][cy]==-2 || fie[cx][cy]==100 || done[cx][cy]==true){\n\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t}\n\t\tif(fie[cx][cy]!=-1){\n\t\t\tdone[cx][cy]=true;\n\t\t\tans+=dfs(fie[cx][cy] , bit | (1<<fie[cx][cy]), done,home+1);\n\t\t\tdone[cx][cy]=false;\n\t\t}\n\t}\n\tif(home< 19)memo[pos][bit]=ans;\n\treturn ans;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tfor(int i=0;i<24;i++){\n\t\t\thx[i]=0;\n\t\t\thy[i]=0;\n\t\t\tmemo[i].clear();\n\t\t}\n\t\tfor(int i=0;i<12;i++){\n\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\tfie[j][i]=-1;\n\t\t\t}\n\t\t}\n\t\tN=0;\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfie[j][i]=-2;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tfie[j][i]=100;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==1){\n\t\t\t\t\tfie[j][i]=N;\n\t\t\t\t\thx[N]=j;\n\t\t\t\t\thy[N]=i;\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thx[N]=sx,hy[N]=sy;\n\t\tbool done[12][12];\n\t\tmemset(done,false,sizeof(done));\n\t\tcout << dfs(N,0,done,0) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\nint m,n;\nint mm[10][10]={0};\nint ch_y,ch_x;\nint mo4[] = {0,1,0,-1,0};\nint max_v = 1;\n\nmap<pair<pair<int,int>,int>,int> memo;\n\n//int memo[10][10][1<<23]={0};\n\nint dfs(int y,int x,int v){\n    int ret = 0;\n    pair<pair<int,int>,int> p = {{y,x},v};\n    if(memo[p]) return memo[p];\n    \n    //fprintf(stderr,\"(%2d,%2d) : %d\\n\",x,y,v);\n    \n    for(int i=0;i<4;i++){\n        int tox = x,toy = y;\n        \n        while(1){\n            tox += mo4[i];\n            toy += mo4[i+1];\n            \n            if(tox<0 || m<=tox || toy<0 || n<=toy) break;\n            \n            \n            if(mm[toy][tox]==0) continue;\n            \n            if(mm[toy][tox]==-1){\n                if(max_v == v){\n                    return 1;\n                }else{\n                    continue;\n                }\n            }\n            \n            if(mm[toy][tox]&v) continue;\n            \n            ret += dfs(toy,tox,v|mm[toy][tox]);\n            break;\n        }\n    }\n    \n    //fprintf(stderr,\"memo[%2d][%2d][%2d] = %lld\\n\",x,y,v,ret%mod);\n    \n    if(__builtin_popcount(ret) <= 18)\n        memo[p] = ret;\n    \n    return ret;\n}\n\n\nvoid calc(int m,int n){\n    \n    //memset(memo,0,sizeof(memo));\n    \n    memo.clear();\n    \n    max_v = 1;\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&mm[i][j]);\n            \n            if(mm[i][j]==1){\n                mm[i][j] = max_v;\n                max_v*=2;\n            }else if(mm[i][j]==2){\n                mm[i][j] = -1;\n                ch_y = i;\n                ch_x = j;\n            }\n        }\n    }\n    \n    max_v--;\n    \n    printf(\"%d\\n\",dfs(ch_y,ch_x,0));\n    \n    return;\n}\n\nint main(){\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(m==0) break;\n        calc(m,n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n, coun;\nint dp[25][1024 * 1024 * 16], town[11][11];\nP p[25];\nvoid bfs(int now, int flag);\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tint s;\n\t\tcoun = 1;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\ts = coun;\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = coun;\n\t\t\t\t\tp[coun] = make_pair(i, j);\n\t\t\t\t\tcoun++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (i = 1; i <= n;i++){\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcout << town[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tbfs(s, 0);\n\t\tj = 1;\n\t\tfor (i = 0; i < coun - 1; i++)\n\t\t\tj = j * 2;\n\t\tcout << dp[s][j - 1] << endl;\n\t}\n}\nvoid bfs(int start, int flag) {\n\tdp[start][flag] = 1;\n\tvector<P> que;\n\tque.push_back(make_pair(flag, start));\n\twhile (!que.empty()) {\n\t\t//cout << que.size()<<' ';\n\t\tsort(que.begin(), que.end());\n\t\tque.erase(unique(que.begin(), que.end()), que.end());\n\t\tP pp;\n\t\tpp = que[0];\n\t\tstart = pp.second; flag = pp.first;\n\t\t//cout << start << ' ' <<  static_cast<std::bitset<24> >(flag)  << endl;\n\t\tque.erase(que.begin());\n\t\tfor (j = p[start].second; j <= m; j++) {\n\t\t\tif (town[p[start].first][j]&&j!=p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]-1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\t//\tcout << 1 << endl;\n\t\t\t\t\tif (coun - 1 != town[p[start].first][j]) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].second; j >= 1; j--) {\n\t\t\tif (town[p[start].first][j]&&j != p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]- 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tif (coun - 1 != town[p[start].first][j]) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t\t\t//\tcout << 2 << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j <= n; j++) {\n\t\t\tif (town[j][p[start].second]&& j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tif (coun - 1 != town[j][p[start].second]) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t\t\t//\tcout << 3 << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j >= 1; j--) {\n\t\t\tif (town[j][p[start].second] && j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tif (coun - 1 != town[j][p[start].second]) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t\t\t//cout << 4 << endl;\n\t\t\t\t\t\t//cout << j << ' ' << flag2 << ' ' << p[start].first << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint W, H, cnt, g[11][11], X[24], Y[24];\nunordered_map< int, int > memo[24];\n\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nint rec(int S, int i) {\n\tif (S == (1 << cnt) - 1) {\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[i], ny = Y[i];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (!in_range(nx, ny)) break;\n\t\t\t\tif (g[ny][nx] == -1) break;\n\t\t\t\tif (g[ny][nx] == -2) return 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tif (memo[i].count(S)) return memo[i][S];\n\t\n\tint& res = memo[i][S];\n\tres = 0;\n\t\n\tfor_(j,0,cnt) {\n\t\tif (S >> j & 1) continue;\n\t\t\n\t\tbool isok = false;\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[j], ny = Y[j];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (!in_range(nx, ny)) break;\n\t\t\t\t\n\t\t\t\tisok |= (X[i] == nx && Y[i] == ny);\n\t\t\t\tif (isok) break;\n\t\t\t\t\n\t\t\t\tif (g[ny][nx] == -1) break;\n\t\t\t\tisok |= (g[ny][nx] >= 0);\n\t\t\t\tif (isok) break;\n\t\t\t}\n\t\t\t\n\t\t\tif (isok) break;\n\t\t}\n\t\t\n\t\tif (!isok) return 0;\n\t}\n\t\n\tfor_(d,0,4) {\n\t\tint nx = X[i], ny = Y[i];\n\t\t\n\t\tfor_(rep,0,10) {\n\t\t\tnx += dx[d];\n\t\t\tny += dy[d];\n\t\t\t\n\t\t\tif (!in_range(nx, ny)) break;\n\t\t\tif (g[ny][nx] == -1) break;\n\t\t\tif (g[ny][nx] < -1) continue;\n\t\t\t\n\t\t\tint j = g[ny][nx];\n\t\t\t\t\t\t\n\t\t\tg[ny][nx] = -1;\n\t\t\tres += rec(S | 1 << j, j);\n\t\t\tg[ny][nx] = j;\n\t\t}\n\t}\n\t\t\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,24) memo[i].clear();\n\tcout << rec(0, 23) << endl;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tcnt = 0;\n\t\t\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tcin >> g[y][x];\n\t\t\t\n\t\t\tif (g[y][x] == 0) g[y][x] = -3;\n\t\t\telse if (g[y][x] == 1) { X[cnt] = x; Y[cnt] = y; g[y][x] = cnt; ++cnt; }\n\t\t\telse if (g[y][x] == 2) { X[23] = x; Y[23] = y; g[y][x] = -2; }\n\t\t}\n\t\t\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\nint w,h;\nint map[10][10];\nbool passed[10][10];\nint gx,gy;\nint count_max;\nint func(int x,int y, int count)\n{\n\tif(count>0)\n\t{\n\t\t#ifdef DEBUG\n\t\t//std::cout << \"IN:\"<<x<<' '<<y<<' '<<count<<'\\n';\n\t\t#endif\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\tif(count==count_max||(x==gx&&y==gy)){\n\t\t\tif(count==count_max){\n\t\t\t\tif(x==gx&&y==gy){return 0;}\n\t\t\t\tauto DP = [&](){};//{std::cout <<x<<' '<<y<<'\\n'; };\n\t\t\t\tfor(int nx = 0;nx<w;++nx){\n\t\t\t\t\tif(map[nx][y]==2){DP();return 1;}\n\t\t\t\t}\n\t\t\t\tfor(int ny = 0;ny<h;++ny){\n\t\t\t\t\tif(map[x][ny]==2){DP();return 1;}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tpassed[x][y]=true;\n\t}\n\tint res = 0;\n\tfor(int nx = x-1;nx>=0;--nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int nx = x+1;nx<w;++nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y-1;ny>=0;--ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y+1;ny<h;++ny){\n\t\tif(!passed[x][ny] && map[x][ny]!=0){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpassed[x][y]=false;\n\treturn res;\n}\n\nint main()\n{\n\tfor(;;){\n\tstd::cin >> w>>h;if(w==0&&h==0){break;}\n\tcount_max=0;\n\tfor(int y=0;y<h;++y)for(int x=0;x<w;++x){\n\t\tstd::cin >> map[x][y];\n\t\tif(map[x][y]==1){++count_max;}\n\t\tif(map[x][y]==2){gx=x;gy=y;}\n\t}\n\t//std::cout << \"a:\"<<gx<<' '<<gy<<' '<<count_max<<'\\n';\n\t\n\tint res = 0;\n\tstd::cout << func(gx,gy,0)<<std::endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[10 + 2][10 + 2];\n\nint housecnt;\nint ans;\nint cathx, cathy;\n\nint calc(int x, int y, int depth)\n{\n\tint i;\n\t\n\tif (depth == housecnt && (cathx == x || cathy == y)){\n\t\tans++;\n\t\treturn (0);\n\t}\n\t\n\tmap[x][y] = 0;\n\ti = 1;\n\twhile (map[x + i][y] == 0) i++;\n\tif (map[x + i][y] == 1){\n\t\tcalc(x + i, y, depth + 1);\n\t}\n\ti = 1;\n\twhile (map[x - i][y] == 0) i++;\n\tif (map[x - i][y] == 1){\n\t\tcalc(x - i, y, depth + 1);\n\t}\n\ti = 1;\n\twhile (map[x][y + i] == 0) i++;\n\tif (map[x][y + i] == 1){\n\t\tcalc(x, y + i, depth + 1);\n\t}\n\ti = 1;\n\twhile (map[x][y - i] == 0) i++;\n\tif (map[x][y - i] == 1){\n\t\tcalc(x, y - i, depth + 1);\n\t}\n\tmap[x][y] = 1;\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\tint w, h;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tmemset(map, -1, sizeof(map));\n\t\t\n\t\thousecnt = ans = 0;\n\t\t\n\t\tfor (int y = 1; y <= h; y++){\n\t\t\tfor (int x = 1; x <= w; x++){\n\t\t\t\tscanf(\"%d\", &map[x][y]);\n\t\t\t\tif (map[x][y] == 2){\n\t\t\t\t\tcathx = x;\n\t\t\t\t\tcathy = y;\n\t\t\t\t\tmap[x][y] = 0;\n\t\t\t\t}\n\t\t\t\tif (map[x][y] == 1){\n\t\t\t\t\thousecnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalc(cathx, cathy, 0);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\nint m, n;\nvector<PII> px[11], py[11];\nPII c;\nint hn = 0;\n\nll dfs(int x, int y, int used){\n\tll res = 0;\n\tif(x == c.fst && y == c.snd){\n\t\tif(used == (1<<hn)-1){\n\t\t\treturn 1;\n\t\t}\n\t}\n\tREP(i, px[x].size()){\n\t\tbool ok = true;\n\t\tREP(j, px[x].size()){\n\t\t\tif(min(px[x][i].fst, y) < px[x][j].fst && px[x][j].fst < max(px[x][i].fst, y)){\n\t\t\t\tif((used & (1 << px[x][j].snd)) == (1 << px[x][j].snd)){\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok && y != px[x][i].fst && (used & (1 << px[x][i].snd)) == 0){\n\t\t\tres += dfs(x, px[x][i].fst, used+(1 << px[x][i].snd));\n\t\t}\n\t}\n\tREP(i, py[y].size()){\n\t\tbool ok = true;\n\t\tREP(j, py[y].size()){\n\t\t\tif(min(py[y][i].fst, x) < py[y][j].fst && py[y][j].fst < max(py[y][i].fst, x)){\n\t\t\t\tif((used & (1 << py[y][j].snd)) == (1 << py[y][j].snd)){\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok && x != py[y][i].fst && (used & (1 << py[y][i].snd)) == 0){\n\t\t\tres += dfs(py[y][i].fst, y, used+(1<<py[y][i].snd));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> m >> n && m && n){\n\thn = 0;\n\tREP(i, 11){\n\t\tpx[i] = vector<PII>();\n\t\tpy[i] = vector<PII>();\n\t}\n\tREP(i, n){\n\t\tREP(j, m){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif(a == 1){\n\t\t\t\tpx[j].push_back({i, hn});\n\t\t\t\tpy[i].push_back({j, hn});\n\t\t\t\thn++;\n\t\t\t}else if(a == 2){\n\t\t\t\tc = {j, i};\n\t\t\t\tpx[j].push_back({i, hn});\n\t\t\t\tpy[i].push_back({j, hn});\n\t\t\t\thn++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dfs(c.fst, c.snd, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstdio>\n\nusing namespace std;\n\nint house[10][10];\nint m, n;\nint nh=0;\nint charch[2];\nint saiki(int x, int y, int N)\n{\n    if(N==0){\n        if(x==charch[0] || y == charch[1]) return 1;\n        else return 0;\n    }\n    else\n    {\n        int sum=0;\n        for(int i=x-1;i>=0;--i)\n        {\n            if(house[i][y] == 1)\n            {\n                house[i][y] = 0;\n                sum += saiki(i, y, N-1);\n                house[i][y] = 1;\n                break;\n            }\n        }\n        for(int i=x+1;i<m;++i)\n        {\n            if(house[i][y] == 1)\n            {\n                house[i][y] = 0;\n                sum += saiki(i, y, N-1);\n                house[i][y] = 1;\n                break;\n            }\n        }\n        for(int i=y-1;i>=0;--i)\n        {\n            if(house[x][i] == 1)\n            {\n                house[x][i] = 0;\n                sum += saiki(x, i, N-1);\n                house[x][i] = 1;\n                break;\n            }\n        }\n        for(int i=y+1;i<n;++i)\n        {\n            if(house[x][i] == 1)\n            {\n                house[x][i] = 0;\n                sum += saiki(x, i, N-1);\n                house[x][i] = 1;\n                break;\n            }\n        }\n        return sum;\n    }\n\n}\nint main()\n{\n    while(cin >> m >> n && m && n)\n    {\n        for(int j=0;j<n;++j){\n            for(int i=0;i<m;++i)\n            {\n                cin >> house[i][j];\n                if(house[i][j] == 1) ++nh;\n                else if(house[i][j] == 2)\n                {\n                    charch[0] = i;\n                    charch[1] = j;\n                }\n            }\n        }\n        cout << saiki(charch[0], charch[1], nh) << endl;\n        nh = 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=(b);i>=(a);i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n\nint w,h;\nint sx,sy;\nint hn;\nint map[15][15];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nint dfs(int y,int x,int p){\n\tbool ered = false;\n\tif(map[y][x]==2){\n\t\tif(p==0)return 1;\n\t\telse if(p!=hn)return 0;\n\t}\n\telse if(map[y][x]==1){\n\t\tmap[y][x]=0;\n\t\tp--;\n\t\tered = true;\n\t}\n\telse return 0;\n\t\n\tint res=0;\n\trep(i,4){\n\t\treg(j,1,100){\n\t\t\tint tx = x + dx[i]*j,\n\t\t\t\tty = y + dy[i]*j;\n\t\t\tif(map[ty][tx]==-1)break;\n\t\t\telse if(map[ty][tx]==0)continue;\n\t\t\tres += dfs(ty,tx,p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ered)map[y][x]=1;\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0)break;\n\t\tmemset(map,-1,sizeof(map));\n\t\thn=0;\n\t\treg(y,1,h){\n\t\t\treg(x,1,w){\n\t\t\t\tscanf(\"%d\",&map[y][x]);\n\t\t\t\tif(map[y][x]==1){\n\t\t\t\t\thn++;\n\t\t\t\t}\n\t\t\t\telse if(map[y][x]==2){\n\t\t\t\t\tsy = y; sx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(sy,sx,hn));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint mas[100][100];\nbool d[100][100];\nint sx, sy, bit;\nint n, m;\nint ans = 0, home = 0;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\nvoid dfs(int x, int y, int next, int cnt);\nint main(){\n  while(1){\n    memset(mas, 0, sizeof(mas));\n    home = 0;\n    ans = 0;\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    for(int i = 0; i < n; i++){ \n      for(int j = 0; j < m; j++){\n\tcin >> mas[i][j];\n\tif(mas[i][j] == 2) sx = j, sy = i;\n\tif(mas[i][j] == 1) home++;\n      }\n    }\n    //cout << home << \" \" << sx << \" \" << sy;\n    for(int i = 0; i < 4; i++){\n      //cout << \"下: 0\" << \" \" << \"右: 1\" << \" \" << \"上: 2\" << \" \" << \"左:3\" << endl;\n      memset(d, 0, sizeof(d));\n      if(sx + dx[i] >= 0 && sx + dx[i] < m && sy + dy[i] >= 0 && sy + dy[i] < n) dfs(sx + dx[i], sy + dy[i], i, 0);\n    }\n    cout << ans << endl;\n  }\n}\n\nvoid dfs(int x, int y, int next, int cnt){\n  //cout << x << \" \" << y << \" \" << next <<\" \" << cnt << \" \" << ans << endl;\n  if(cnt == home && mas[y][x] == 2){\n    ans++;\n    return;\n  }\n  if(x + dx[next] < m && x + dx[next] >= 0 && y + dy[next] < n && y + dy[next] >= 0 && d[y + dy[next]][x + dx[next]] != 1) dfs(x + dx[next], y + dy[next], next, cnt);\n  if(mas[y][x] == 1 && d[y][x] != 1){\n    for(int i = 0; i < 4; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(nx < m && nx >= 0 && ny < n && ny >= 0 && d[ny][nx] != 1){\n\td[y][x] = 1;\n\tdfs(nx, ny, i, cnt + 1);\n      }\n    }\n    d[y][x] = 0;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\nInt s[20][20],idx[20][20],cnt,pru;\nInt u[40][4];\nInt num[40],ok[40];\nvector<vector<vector<Int> > > G;\n\nunordered_map<int, int> dp;\nInt dfs(Int z,Int b){\n  if(b==0) dp.clear();\n  int hs=(b<<5)|z;\n  if((z&4)==0) if(dp.count(hs)) return dp[hs];\n\n  Int res=0;\n  \n  for(Int k=0;k<4;k++){\n    for(auto w:G[z][k]){\n      if((b>>w)&1) break;\n      Int nb=b^(1<<w),flg=1;\n      for(Int i=0;i<4;i++){\n\tif(u[w][i]>=cnt) continue; \n\tnum[u[w][i]]--;\n\tif((~nb>>u[w][i])&1)\n\t  flg&=num[u[w][i]]>=1;\n      }\n      if(flg){\n\tif(nb+1==(1<<cnt)) res+=ok[w];\n\telse if((nb&pru)!=pru) res+=dfs(w,nb);\n      }\n      for(Int i=0;i<4;i++) num[u[w][i]]++;\n    }\n  }\n  \n  if((z&4)==0) dp[hs]=res;\n  return res;\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    cnt=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tidx[i][j]=cnt;\n\tcnt+=s[i][j]==1;\n      }\n    }\n    \n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) idx[i][j]=cnt;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};    \n\n    G.clear();\n    G.resize(cnt+1);\n    \n    memset(num,0,sizeof(num));    \n    memset(ok,0,sizeof(ok));\n    \n    for(Int y=0;y<h;y++){\n      for(Int x=0;x<w;x++){\n\tif(s[y][x]==0) continue;\n\tInt z=idx[y][x];\n\tG[z].resize(4);\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y,nx=x;\n\t  while(1){\n\t    ny+=dy[k],nx+=dx[k];\n\t    while(in(ny,nx)&&s[ny][nx]==0)\n\t      ny+=dy[k],nx+=dx[k];\n\t    if(!in(ny,nx)) break;\t    \n\t    if(s[ny][nx]==2) ok[z]=1;\n\t    else G[z][k].emplace_back(idx[ny][nx]);\n\t  }\n\t}\n\t\n\tfor(Int k=0;k<4;k++){\n\t  u[z][k]=cnt+1;\n\t  for(auto w:G[z][k]){\n\t    u[z][k]=w;\n\t    num[w]++;\n\t    break;\n\t  }\n\t}\n\t\n\tif(z==cnt){\n\t  pru=0;\n\t  for(Int k=0;k<4;k++){\n\t    for(auto w:G[z][k]){\n\t      pru|=(1<<w);\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    cout<<dfs(cnt,0)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    auto s=make_v<Int>(h,w);\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    Int cnt=0;\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcnt+=s[i][j]==1;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};\n    \n    Int ans=0;\n    function<void(Int, Int, Int)> dfs=\n      [&](Int y,Int x,Int d){\n\tif(s[y][x]==-1) return;\n\tif(s[y][x]==2){\n\t  if(cnt==0) ans++;\n\t  if(~d) return;\n\t}\n\t\n        if(s[y][x]>=1){\n\t  if(s[y][x]==1){\n\t    cnt--;\n\t    s[y][x]=-1;\n\t  }\n\t  for(Int k=0;k<4;k++){\n\t    Int ny=y+dy[k],nx=x+dx[k],nd=k;\n\t    if(in(ny,nx)) dfs(ny,nx,nd);\n\t  }\n\t  if(s[y][x]==-1){\n\t    cnt++;\n\t    s[y][x]=1;\n\t  }\n\t}\n\t\n\tif(~d){\n\t  y+=dy[d];x+=dx[d];\n\t  if(in(y,x)) dfs(y,x,d);\n\t}\n      };\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) dfs(i,j,-1);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nusing namespace std;\n\nbool ok[1<<23];\n\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[23];\nint y[23];\nint kx;\nint ky;\nint n;\n\nint solve(int xx, int yy, int flag){\n  if(flag == (1 << n) - 1){\n    REP(i,4){\n      int xxx = nx[i][yy][xx];\n      int yyy = ny[i][yy][xx];\n      if(f[yyy][xxx] == 2) return 1;\n    }\n    return 0;\n  }else{\n    if(!ok[flag]) return 0;\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(true){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        // printf(\"%d %d: %d %d\\n\", xxxx, yyyy, idn, n);\n        if(idn != n){\n          if(flag & (1 << idn)) break;\n          ret += solve(xxxx, yyyy, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    return ret;\n  }\n}\n\nint main(){\n  while(true){\n    int w = getInt();\n    int h = getInt();\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      f[i][j] = getInt();\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j] != 0){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      kx = j; ky = i;\n      id[i][j] = n;\n    }\n\n    REP(i,1<<n){\n      ok[i] = false;\n      REP(j,n) if((i & (1 << j)) == 0){\n        int xx = x[j];\n        int yy = y[j];\n        REP(k,4){\n          int xxx = nx[k][yy][xx];\n          int yyy = ny[k][yy][xx];\n          if(f[yyy][xxx] == 2){\n            ok[i] = true;\n            goto next;\n          }\n        }\n      }\n    next:;\n    }\n\n    int ans = solve(kx, ky, 0);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<random>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<stdlib.h>\n#include<unordered_map>\n#include<time.h>\n#define rep(i,a,n) for (int (i)=(a);(i)<(n);(i)++)\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nint h, w;\nvector<int>e[24][4];\nshort a[10][10], u[2], d[10][10];//??????,??´??????ID??????????????????\nint dp[24][8388608];\nint b[23];//??´????????????DP???\nint sum = 0;//DP?????????????¨?\nint t = 0;//??¶????????°\nbool c[23];//???????????????????????????????????¶???\nint solve(int i, int s) {//0??§????????°?????£?????????\n\tif (s == sum) {\n\t\tif (c[i])return 1;\n\t\telse return 0;\n\t}\n\tif (dp[i][s] != -1) return dp[i][s];\n\tint ans = 0;\n\tfor (int j = 0; j < 4; j++) {\n\t\tfor (int z = 0; z < e[i][j].size(); z++) {\n\t\t\tif (!(s&b[e[i][j][z]])) {\n\t\t\t\tans += solve(e[i][j][z], s | b[e[i][j][z]]);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[i][s] = ans;\n}\nsigned main() {\n\twhile (cin >> w >> h&&w != 0 && h != 0) {\n\t\tint r = 1;\n\t\tsum = 0;\n\t\tt = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\td[i][j] = 0;\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2)\n\t\t\t\t\tu[0] = i, u[1] = j;\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\tfor (int z = 0; z < 4; z++)\n\t\t\t\t\t\te[t][z].clear();\n\t\t\t\t\tc[t] = 0;\n\t\t\t\t\td[i][j] = t;\n\t\t\t\t\tb[t++] = r;\n\t\t\t\t\tsum += r;\n\t\t\t\t\tr *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\tint f = d[i][j];\n\t\t\t\t\tfor (int z = 1; i - z >= 0; z++)\n\t\t\t\t\t\tif (a[i - z][j] == 1)\n\t\t\t\t\t\t\te[f][0].push_back(d[i - z][j]);\n\t\t\t\t\tfor (int z = 1; i + z < h; z++)\n\t\t\t\t\t\tif (a[i + z][j] == 1)\n\t\t\t\t\t\t\te[f][1].push_back(d[i + z][j]);\n\t\t\t\t\tfor (int z = 1; j - z >= 0; z++)\n\t\t\t\t\t\tif (a[i][j - z] == 1)\n\t\t\t\t\t\t\te[f][2].push_back(d[i][j - z]);\n\t\t\t\t\tfor (int z = 1; j + z < w; z++)\n\t\t\t\t\t\tif (a[i][j + z] == 1)\n\t\t\t\t\t\t\te[f][3].push_back(d[i][j + z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint f = t;\n\t\tfor (int z = 1; u[0] - z >= 0; z++)\n\t\t\tif (a[u[0] - z][u[1]] == 1)\n\t\t\t\te[f][0].push_back(d[u[0] - z][u[1]]);\n\t\tfor (int z = 1; u[0] + z < h; z++)\n\t\t\tif (a[u[0] + z][u[1]] == 1)\n\t\t\t\te[f][1].push_back(d[u[0] + z][u[1]]);\n\t\tfor (int z = 1; u[1] - z >= 0; z++)\n\t\t\tif (a[u[0]][u[1] - z] == 1)\n\t\t\t\te[f][2].push_back(d[u[0]][u[1] - z]);\n\t\tfor (int z = 1; u[1] + z < w; z++)\n\t\t\tif (a[u[0]][u[1] + z] == 1)\n\t\t\t\te[f][3].push_back(d[u[0]][u[1] + z]);\n\t\tif (e[f][0].size() > 0)\n\t\t\tc[e[f][0][0]] = 1;\n\t\tif (e[f][1].size() > 0)\n\t\t\tc[e[f][1][0]] = 1;\n\t\tif (e[f][2].size() > 0)\n\t\t\tc[e[f][2][0]] = 1;\n\t\tif (e[f][3].size() > 0)\n\t\t\tc[e[f][3][0]] = 1;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tfor (int j = 0; j <= sum; j++)\n\t\t\t\tdp[i][j] = -1;\n\t\t}\n\t\tdp[t][0] = -1;\n\t\tcout << solve(t, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   (a >> b) & 1\n#define bitset(a,b)       a |= (1 << b)\n#define bitunset(a,b)    a &= ~(1 << b)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w,h;\n\tscanf(\"%d %d\", &w, &h);\n\tvector<vector<int>> mp(w,vector<int>(h,-1));\n\tpii cha;\n\tvector<pii> homp;\n\tint homc = 0;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tint a = 0;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (a == 2) {\n\t\t\t\tcha = { j,i };\n\t\t\t}\n\t\t\tif (a == 1) {\n\t\t\t\thomp.push_back({ j,i });\n\t\t\t\tmp[j][i] = homc;\n\t\t\t\thomc++;\n\t\t\t}\n\t\t}\n\t}\n\thomp.push_back(cha);\n\tmap<pii, int> dp[2];//?±\\??´????????¨??°\n\tdp[0][{0, homc}] = 1;\n\tbool t = 0;\n\tREP(i,homc){\n\t\tfor(auto cur : dp[t]) {\n\t\t\tpii curpos = homp[cur.first.second];\n\t\t\tint cnum;\n\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t}\n\t\tdp[t].clear();\n\t\tt = 1 - t;\n\t}\n\tint cnum,ans = 0;\n\tset<int> targets;\n\tfor (int j = cha.first; w > j; j++) {\n\t\tcnum = mp[j][cha.second];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.first; 0 <= j; j--) {\n\t\tcnum = mp[j][cha.second];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.second; h > j; j++) {\n\t\tcnum = mp[cha.first][j];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.second; 0 <= j; j--) {\n\t\tcnum = mp[cha.first][j];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (auto cur : dp[t]) {\n\t\tif(targets.find(cur.first.second) != targets.end())\n\t\t\tans += cur.second;\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<P, int>dp;\n\t\tauto F = [&](int x, int y, int s, int r) {\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x, ny = y; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(r >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[{r | 1 << dat[nx][ny], dat[nx][ny]}] += s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tF(sx, sy, 1, 0);\n\t\tint ans = 0, o = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[{i, j}];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF(x[j], y[j], dp[{i, j}], i);\n\t\t\tif (++o >= 10000)dp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include <cstring>\n#define MAX 11\n#define MAX_BITS 19\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint dp[(1<<MAX_BITS)+1][23];\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n//\tcout << \"hi\" << bit << endl;\n\tif(housInd[ny][nx] != -1 && bit < (1 << MAX_BITS) && dp[bit][housInd[ny][nx]] != -1){\n\t\treturn dp[bit][housInd[ny][nx]];\n\t}\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\t\n\tif (isLast && dp[1<<MAX_BITS][housInd[ny][nx]] != -1) return dp[1<<19][housInd[ny][nx]];\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[1<<MAX_BITS][housInd[ny][nx]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((bit & 1 << ind) != 0) break;\n\t\t\t\tif (!isLast)ret += func(y, x, bit | (1 << ind));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn isLast ? (dp[1<<MAX_BITS][housInd[ny][nx]] = ret)\n\t\t\t: (housInd[ny][nx] != -1 && bit < (1 << MAX_BITS)) ? (dp[bit][housInd[ny][nx]] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint h,w;\nint a[12][12];\n\nint pre_h[12][12];\nint nex_h[12][12];\nint pre_w[12][12];\nint nex_w[12][12];\n\nint dfs(int x,int y,int d,int k,int t){\n\tif(t == 1){\n\t\tint ret = 0;\n\t\tif(nex_h[x][y] != 0)ret += dfs(x+nex_h[x][y],y,0,k-1,0);\n\t\tif(pre_h[x][y] != 0)ret += dfs(x+pre_h[x][y],y,1,k-1,0);\n\t\tif(nex_w[x][y] != 0)ret += dfs(x,y+nex_w[x][y],2,k-1,0);\n\t\tif(pre_w[x][y] != 0)ret += dfs(x,y+pre_w[x][y],3,k-1,0);\n\t\treturn ret;\n\t}\n\tif(k == 0){\n\t\tif(a[x][y] == 2)return 1;\n\t\treturn 0;\n\t}\n\tif(a[x][y] == 2)return 0;\n\tif(d == -1){\n\t\tif(a[x][y] == 2)return 0;\n\t\tint ret = 0;\n\t\tif(nex_h[x][y] != 0)pre_h[x+nex_h[x][y]][y] = 0;\n\t\tif(pre_h[x][y] != 0)nex_h[x+pre_h[x][y]][y] = 0;\n\t\tif(nex_w[x][y] != 0)pre_w[x][y+nex_w[x][y]] = 0;\n\t\tif(pre_w[x][y] != 0)nex_w[x][y+pre_w[x][y]] = 0;\n\t\tif(nex_h[x][y] != 0)ret += dfs(x+nex_h[x][y],y,0,k-1,0);\n\t\tif(pre_h[x][y] != 0)ret += dfs(x+pre_h[x][y],y,1,k-1,0);\n\t\tif(nex_w[x][y] != 0)ret += dfs(x,y+nex_w[x][y],2,k-1,0);\n\t\tif(pre_w[x][y] != 0)ret += dfs(x,y+pre_w[x][y],3,k-1,0);\n\t\tif(nex_h[x][y] != 0)pre_h[x+nex_h[x][y]][y] = -nex_h[x][y];\n\t\tif(pre_h[x][y] != 0)nex_h[x+pre_h[x][y]][y] = -pre_h[x][y];\n\t\tif(nex_w[x][y] != 0)pre_w[x][y+nex_w[x][y]] = -nex_w[x][y];\n\t\tif(pre_w[x][y] != 0)nex_w[x][y+pre_w[x][y]] = -pre_w[x][y];\n\t\treturn ret;\n\t}\n\tint ret = 0;\n\tret += dfs(x,y,-1,k,0);\n\tif(d == 0){\n\t\tif(nex_h[x][y] != 0)ret += dfs(x+nex_h[x][y],y,0,k,0);\n\t}\n\telse if(d == 1){\n\t\tif(pre_h[x][y] != 0)ret += dfs(x+pre_h[x][y],y,1,k,0);\n\t}\n\telse if(d == 2){\n\t\tif(nex_w[x][y] != 0)ret += dfs(x,y+nex_w[x][y],2,k,0);\n\t}\n\telse if(d == 3){\n\t\tif(pre_w[x][y] != 0)ret += dfs(x,y+pre_w[x][y],3,k,0);\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\trep(i,12){\n\t\t\trep(j,12){\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tnex_h[i][j] = 0;\n\t\t\t\tpre_h[i][j] = 0;\n\t\t\t\tnex_w[i][j] = 0;\n\t\t\t\tpre_w[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h); if(w == 0 && h == 0)break;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,12){\n\t\t\tint memo = -1;\n\t\t\trep(j,12){\n\t\t\t\tif(a[i][j] != 0){\n\t\t\t\t\tif(memo != -1){\n\t\t\t\t\t\tnex_w[i][memo] = j-memo;\n\t\t\t\t\t\tpre_w[i][j] = memo-j;\n\t\t\t\t\t}\n\t\t\t\t\tmemo = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(j,12){\n\t\t\tint memo = -1;\n\t\t\trep(i,12){\n\t\t\t\tif(a[i][j] != 0){\n\t\t\t\t\tif(memo != -1){\n\t\t\t\t\t\tnex_h[memo][j] = i-memo;\n\t\t\t\t\t\tpre_h[i][j] = memo-i;\n\t\t\t\t\t}\n\t\t\t\t\tmemo = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tint x,y;\n\t\t\n\t\trep(i,12){\n\t\t\trep(j,12){\n\t\t\t\tif(a[i][j] == 1)cnt ++;\n\t\t\t\tif(a[i][j] == 2){\n\t\t\t\t\tx = i; y = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",dfs(x,y,-1,cnt+1,1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint m,n,mp[10][10];\nint cx,cy;\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\nint dfs(int x,int y,int count){\n    int ret=0;\n    if(count==0){\n        if(x==cx||y==cy) return 1;\n        return 0;\n    }\n    for(int i=0;i<4;++i){\n        int tx=x,ty=y;\n        while(1){\n            tx +=dx[i];\n            ty +=dy[i];\n            if(tx<0||ty<0||tx>=m||ty>=n) break;\n            if(mp[ty][tx]==1){\n                mp[ty][tx]=0;\n                ret +=dfs(tx,ty,count-1);\n                mp[ty][tx]=1;\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    while(cin>>m>>n,n){\n        int num_house =0;\n        for(int i=0;i<n;++i){\n            for(int j=0;j<m;++j){\n                cin>>mp[i][j];\n                if(mp[i][j]==2){\n                    cx=j;cy=i;\n                }\n                if(mp[i][j]==1) ++num_house;\n            }   \n        }\n        cout<<dfs(cx,cy,num_house)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\n//int memo[1<<K][23];\nunordered_map<int, int> memo2[23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}*/\n\tif(table[i][j]>=0&&memo2[table[i][j]].find(done)!=memo2[table[i][j]].end())\n\t{\n\t\treturn memo2[table[i][j]][done];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\t/*\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}*/\n\t\t\t\tif(table[i][j]>=0){\n\t\t\t\t\tmemo2[table[i][j]][done]=0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}*/\n\tif(table[i][j]>=0){\n\t\tmemo2[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tfor(int i=0;i<c;i++){\n\t\tmemo2[i].clear();\n\t}\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define fr first\n#define sc second\n#define MAXDIR 4\n\n//vector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(char si, char sj, char cnt, int vis):ni(si),nj(sj),cnt(cnt),vis(vis){}\n};\n\n//void bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nstruct Queue{\n  int p;\n  state *V;\n  Queue():p(0){V=new state[1<<20];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){\n    V[p++]=t;\n  }\n  state * front(){\n    return &V[p-1];\n  }\n  void pop(){--p;}\n  bool empty(){\n    return p==0;\n  }\n};\n\nvoid bfs(const Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  int ni,nj;\n  int housenum=0;\n  int chi=charch.fr;int chj=charch.sc;\n  \n  for(int k = 0; k < MAXDIR; ++k){\n    housenum += M[chi][chj].linkmax[k];\n  }\n  \n  while(!qs.empty()){\n    state st_now = *( qs.front() );\n    ni = st_now.ni;\n    nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }else{\n\n      int left = housenum;\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n      \n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  int mask=1<<houseId[next.fr][next.sc];\n\t  if( !(st_now.vis&mask) ){\n\t    qs.push( state(next.fr,next.sc,st_now.cnt + 1,st_now.vis|mask) );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &iM[i][j]);\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc,0,0);\n    bfs(M,init,nhouse,ans);\n    printf(\"%d\\n\", ans);\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>20||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=20&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=20?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m, n;\nint graph[10][10];\n\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\n\nint hcnt;\nint hidx[10][10];\nint hy[24], hx[24];\n\nint dp[1 << 24][24];\n\nint solve(int stat, int house) {\n\n    if(dp[stat][house] != -1) return dp[stat][house];\n\n    if(stat == (1 << hcnt) - 1 && house == 0) return 1;\n\n    int ret = 0;\n\n    for(int i = 0; i < 4; ++i) {\n        int ny = hy[house] + dy[i];\n        int nx = hx[house] + dx[i];\n        while(ny >= 0 && ny < n && nx >= 0 && nx < m) {\n            if(graph[ny][nx]) {\n                if(!(stat & (1 << hidx[ny][nx]))) {\n                    ret += solve(stat | (1 << hidx[ny][nx]), hidx[ny][nx]);\n                    break;\n                }\n            }\n            ny += dy[i];\n            nx += dx[i];\n        }\n    }\n\n    return dp[stat][house] = ret;\n\n}\n\nint main() {\n\n    while(cin >> m >> n, m | n) {\n\n        hcnt = 1;\n\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < m; ++j) {\n                cin >> graph[i][j];\n                if(graph[i][j] == 1) {\n                    hidx[i][j] = hcnt;\n                    hy[hcnt] = i;\n                    hx[hcnt] = j;\n                    hcnt++;\n                } else if(graph[i][j] == 2) {\n                    hidx[i][j] = 0;\n                    hy[0] = i;\n                    hx[0] = j;\n                }\n            }\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        cout << solve(0, 0) << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n\n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1<<28;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_N = 23;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nmap<pii, int> mem;\nint w, h, sx, sy;\nvector<pii> hs, xl, yl;\nvector<tuple<int, int, int>> xy, yx;\n\nint Solve(int k, int mask) {\n    if (k == hs.size()) {\n\tif (mask == (1 << (hs.size() + 1)) - 1 && k == hs.size()) {\n\t    return 1;\n\t}\n\treturn 0;\n    }\n    if (mem.find({k, mask}) != mem.end()) return mem[{k, mask}];\n\n    int res = 0, x = hs[k].first, y = hs[k].second;\n    auto st = lower_bound(ALL(xy), MKT(x, y, k));\n    for (auto it = st + 1; it != xy.end() && get<0>(*it) == x; ++it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n    for (auto it = st - 1; xy.begin() <= it && get<0>(*it) == x; --it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n\n    st = lower_bound(ALL(yx), MKT(y, x, k));\n    for (auto it = st + 1; it != yx.end() && get<0>(*it) == y; ++it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n    for (auto it = st - 1; yx.begin() <= it && get<0>(*it) == y; --it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n\n    mem.insert({{k, mask}, res});\n    return res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> w >> h, w) {\n\tmem.clear();\n\txy.clear();\n\tyx.clear();\n\ths.clear();\n\n\tfor (int y = 1; y <= h; ++y) {\n\t    for (int x = 1; x <= w; ++x) {\n\t\tint t;\n\t\tcin >> t;\n\t\tif (t == 1) {\n\t\t    xy.PB(MKT(x, y, hs.size()));\n\t\t    yx.PB(MKT(y, x, hs.size()));\n\t\t    hs.PB({x, y});\n\t\t} else if (t == 2) {\n\t\t    sx = x;\n\t\t    sy = y;\n\t\t}\n\t    }\n\t}\n\n\txy.PB(MKT(sx, sy, hs.size()));\n\tyx.PB(MKT(sy, sx, hs.size()));\n\tsort(ALL(xy));\n\tsort(ALL(yx));\n\n\tint ans = 0;\n\tauto st = lower_bound(ALL(xy), MKT(sx, -INF, -INF));\n\tfor (auto it = st; it != xy.end() && get<0>(*it) == sx; ++it) {\n\t    int tk = get<2>(*it);\n\t    if (tk == hs.size()) continue;\n\t    ans += Solve(tk, 1 << tk);\n\t}\n\n\tst = lower_bound(ALL(yx), MKT(sy, -INF, -INF));\n\tfor (auto it = st; it != yx.end() && get<0>(*it) == sy; ++it) {\n\t    int tk = get<2>(*it);\n\t    if (tk == hs.size()) continue;\n\t    ans += Solve(tk, 1 << tk);\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define operation(x, y) \\\n{\\\n\tif(house[y][x] >= 0 && !((visited >> house[y][x]) & 1)) {\t\\\n\t\tcan_pass[y][x] = true;\t\t\t\t\t\t\t\t\t\\\n\t\tres += dfs(x, y, (visited | (1 << house[y][x])));\t\t\\\n\t\tcan_pass[y][x] = false;\t\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\\\n\tif(!can_pass[y][x])\\\n\t\tbreak;\\\n}\n\nint w, h, num;\nint sx, sy;\nmap<pair<short, int>, int> memo;\nvector<vector<bool> > can_pass;\nvector<vector<short> > house;\n\nint dfs(int x, int y, int visited = 0) {\n\tif(visited == (1 << num) - 1)\n\t\tif(x == sx || y == sy)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\n\tif(memo.count(make_pair(house[y][x], visited)))\n\t\treturn memo[make_pair(house[y][x], visited)];\n\n\tint res = 0;\n\tfor(int i = x + 1; i < w; ++i)\n\t\toperation(i, y)\n\n\tfor(int i = x - 1; i >= 0; --i)\n\t\toperation(i, y)\n\n\tfor(int i = y + 1; i < h; ++i)\n\t\toperation(x, i)\n\n\tfor(int i = y - 1; i >= 0; --i)\n\t\toperation(x, i)\n\n\tif(__builtin_popcount(visited) < 15)\n\t\tmemo[make_pair(house[y][x], visited)] = res;\n\t\t\t\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tcan_pass.clear();\n\t\tcan_pass.resize(h, vector<bool>(w, false));\n\t\thouse.clear();\n\t\thouse.resize(h, vector<short>(w, -1));\n\n\t\tnum = 0;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\n\t\t\t\tif(in == 1) {\n\t\t\t\t\thouse[i][j] = num++;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tcan_pass[i][j] = true;\n\t\t\t\t\tif(in == 2) {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemo.clear();\n\t\tcout << dfs(sx, sy) << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 19;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX && !(cnt >= 18 && sum == 0)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\n\tint ans=0;\n\trep(k,4) rep(a,deg[id][k]) {\n\t\tint next_id=adj[id][k][a];\n\t\tif((picked&(1<<next_id))==0){\n\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(dp[id].size()<10000) dp[id][picked]=ans;\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nusing namespace std;\n\nint ok[1<<23];\n\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[23];\nint y[23];\nint kx;\nint ky;\nint n;\n\nint solve(int xx, int yy, int flag){\n  if(flag == (1 << n) - 1){\n    REP(i,4){\n      int xxx = nx[i][yy][xx];\n      int yyy = ny[i][yy][xx];\n      if(f[yyy][xxx] == 2) return 1;\n    }\n    return 0;\n  }else{\n    int idn = id[yy][xx];\n\n    if(idn != n)\n      if((ok[flag] & (1 << idn)) == 0) return 0;\n\n    // printf(\"%d %d %d\\n\", xx, yy, flag);\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(true){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        // printf(\"%d %d: %d %d\\n\", xxxx, yyyy, idn, n);\n        if(idn != n){\n          if(flag & (1 << idn)) break;\n          ret += solve(xxxx, yyyy, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(ret == 0 && idn != n)\n      ok[flag] &= ~(1 << idn);\n\n    return ret;\n  }\n}\n\nint main(){\n  while(true){\n    int w = getInt();\n    int h = getInt();\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      f[i][j] = getInt();\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j] != 0){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      kx = j; ky = i;\n      id[i][j] = n;\n    }\n\n    /*\n    REP(i,1<<n){\n      ok[i] = false;\n      REP(j,n) if((i & (1 << j)) == 0){\n        int xx = x[j];\n        int yy = y[j];\n        REP(k,4){\n          int xxx = nx[k][yy][xx];\n          int yyy = ny[k][yy][xx];\n          if(f[yyy][xxx] == 2){\n            ok[i] = true;\n            goto next;\n          }\n        }\n      }\n    next:;\n    }\n    */\n\n    REP(i, 1<<n) ok[i] = (1 << n) - 1;\n\n    int ans = solve(kx, ky, 0);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//25\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint m,n;\nint g[10][10];\nint cx,cy;\n\nint dfs(int x,int y,int r){\n  if(r==0){\n    if(x==cx){\n      for(int i=min(y,cy)+1;i<max(y,cy);i++){\n\tif(g[i][x]==-1){\n\t  return 0;\n\t}\n      }\n      return 1;\n    }else if(y==cy){\n      for(int i=min(x,cx)+1;i<max(x,cx);i++){\n\tif(g[y][i]==-1){\n\t  return 0;\n\t}\n      }\n      return 1;\n    }else{\n      return 0;\n    }\n  }else{\n    int a=0;\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      int nx=x,ny=y;\n      for(;;){\n\tnx+=d[i];\n\tny+=d[i+1];\n\tif(nx<0||m<=nx||ny<0||n<=ny||g[ny][nx]==-1)break;\n\tif(g[ny][nx]==1){\n\t  g[ny][nx]=-1;\n\t  a+=dfs(nx,ny,r-1);\n\t  g[ny][nx]=1;\n\t}\n      }\n    }\n    return a;\n  }\n}\n\nint main(){\n  while(cin>>m>>n,m|n){\n    int nh=0;\n    int x,y;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tcin>>g[i][j];\n\tnh+=g[i][j]==1;\n\tif(g[i][j]==2){\n\t  cx=x=j;\n\t  cy=y=i;\n\t}\n      }\n    }\n    cout<<dfs(x,y,nh)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(char si, char sj, char cnt, int vis):ni(si),nj(sj),cnt(cnt),vis(vis){}\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n/*\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n*/\n\nstruct Queue{\n  int p;\n  state *V;\n  Queue():p(0){V=new state[1<<20];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){\n    V[p++]=t;\n  }\n  state & front(){\n    return V[p-1];\n  }\n  void pop(){--p;}\n  bool empty(){\n    return p==0;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  int ni,nj;\n  int housenum=0;\n  int chi=charch.fr;int chj=charch.sc;\n  \n  for(int k = 0; k < MAXDIR; ++k){\n    housenum += M[chi][chj].linkmax[k];\n  }\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    ni = st_now.ni;\n    nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    //if( st_now.cnt >= 0 ){\n      int left = housenum;\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n      //}\n\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\tpi next = M[ni][nj].link[k][v];\n\tif( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t  qs.push( state(next.fr,next.sc,st_now.cnt + 1,st_now.vis|( 1<<houseId[next.fr][next.sc])));\n\t  break;\n\t}\n      }\n    }\n\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc,0,0);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nconst int MOD=100000;\nint M,N,S,gX,gY,xD,yD;\nint fld[10][10];\nint rec(int x,int y,int sum){\n      //if(xD+yD==0)cout<<x<<\" \"<<y<<\" \"<<sum<<endl;\n      if(gX==x&&gY==y){\n            if(sum==S)return 1;\n            else return 0;\n      }\n      int res=0;\n      for(int d=x+1;d<M;d++){\n            if(fld[d][y]==3)break;\n            if(fld[d][y]==1){\n                  fld[d][y]=3;\n                  res+=rec(d,y,sum+1);\n                  fld[d][y]=1;\n            }\n      }\n      for(int d=x-1;d>=0;d--){\n            if(fld[d][y]==3)break;\n            if(fld[d][y]==1){\n                  fld[d][y]=3;\n                  res+=rec(d,y,sum+1);\n                  fld[d][y]=1;\n            }\n      }\n      for(int d=y+1;d<N;d++){\n            if(fld[x][d]==3)break;\n            if(fld[x][d]==1){\n                  fld[x][d]=3;\n                  res+=rec(x,d,sum+1);\n                  fld[x][d]=1;\n            }\n      }\n      for(int d=y-1;d>=0;d--){\n            if(fld[x][d]==3)break;\n            if(fld[x][d]==1){\n                  fld[x][d]=3;\n                  res+=rec(x,d,sum+1);\n                  fld[x][d]=1;\n            }\n      }\n      return res;\n}\nint main(){\n      while(cin>>M>>N&&(N||M)){\n            S=0;\n            REP(i,N)REP(j,M){\n                  scanf(\"%d\",&fld[j][i]);\n                  if(fld[j][i]==1)S++;\n                  if(fld[j][i]==2){\n                        S++;\n                        gX=j;gY=i;\n                        fld[j][i]=1;\n                  }\n            }\n            int ans=0;\n            REP(i,N)if(fld[gX][i]==1&&i!=gY){\n                  fld[gX][i]=3;\n                  ans+=rec(gX,i,1);\n                  fld[gX][i]=1;\n            }\n            REP(i,N)if(fld[i][gY]==1&&i!=gX){\n                  fld[i][gY]=3;\n                  ans+=rec(i,gY,1);\n                  fld[i][gY]=1;\n            }\n            cout<<ans<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n//int memo[885777];\nmap<int,int> msi;\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n#if DEB\n  printf(\"S:%d  src:%d\\n\",S,src);\n#endif\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n#if DEB\n  printf(\"src:%d , x:%d , y:%d , s:%d\\n\",src,x,y,s);\n#endif\n\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(S) ){ //ùÉÊÁ½óÔ\n    return msi[S];\n  }\n  \n  // v[gªu¯È¢ÆÌL³\n  /*\n    1831764\n    ari  :: msi_sz: 885661  >0:376369  ==0:509292  already>0:222390 , already==0:408636\n    nari :: msi_sz:1028771  >0:376369  ==0:652402  already>0:222390 , already==0:565310\n   */\n  \n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<num[y][x])) ){\n    return 0;\n  }\n  \n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n#if DEB\n\tprintf(\"dest:%d  (%d,%d)   ,%d  , %d\\n\",dest,nx,ny,s|(1<<dest),(s|(1<<dest))<<4);\n#endif\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[S] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\ntypedef pair<int,int> state;\n\nint main(){\n\tint n,m,field[10][10];\n\twhile(cin >> m >> n,n){\n\t\tint cnt = 0,x[25],y[25],sx,sy,res = 0;\n\t\tmap<state,int> ans;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 1) {\n\t\t\t\t\tx[cnt] = i;\n\t\t\t\t\ty[cnt] = j;\n\t\t\t\t\tfield[i][j] = ++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx[cnt] = sx;\n\t\ty[cnt] = sy;\n\t\tpriority_queue<state,vector<state>,greater<state> > que;\n\t\tque.push(state(0,cnt));\n\t\tans[state(0,cnt)] = 1;\n\t\twhile(!que.empty()){\n\t\t\tstate st = que.top();que.pop();\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint nx = x[st.second] + dx[i],ny = y[st.second] + dy[i];\n\t\t\t\twhile(nx >= 0 && nx < n && ny >= 0 && ny < m){\n\t\t\t\t\tif(st.first == (1 << cnt) - 1){\n\t\t\t\t\t\tif(field[nx][ny] == -1){\n\t\t\t\t\t\t\tres += ans[st];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[nx][ny] > 0 && !(st.first >> (field[nx][ny] - 1) & 1)){\n\t\t\t\t\t\tstate now = state(st.first | (1 << (field[nx][ny] - 1)),field[nx][ny] - 1);\n\t\t\t\t\t\tif(!ans[now]) que.push(now);\n\t\t\t\t\t\tans[now] += ans[st];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnx += dx[i];\n\t\t\t\t\tny += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//25\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint m,n;\nint g[10][10];\nint cx,cy;\nbool ra[10][10];\n\nint dfs(int x,int y,int r){\n  if(r==0){\n    return ra[y][x];\n  }else{\n    int a=0;\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      int nx=x,ny=y;\n      for(;;){\n\tnx+=d[i];\n\tny+=d[i+1];\n\tif(nx<0||m<=nx||ny<0||n<=ny||g[ny][nx]==-1)break;\n\tif(g[ny][nx]==1){\n\t  g[ny][nx]=-1;\n\t  a+=dfs(nx,ny,r-1);\n\t  g[ny][nx]=1;\n\t}\n      }\n    }\n    return a;\n  }\n}\n\nint main(){\n  while(cin>>m>>n,m|n){\n    int nh=0;\n    int x,y;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tcin>>g[i][j];\n\tnh+=g[i][j]==1;\n\tif(g[i][j]==2){\n\t  cx=x=j;\n\t  cy=y=i;\n\t}\n      }\n    }\n    fill(ra[0],ra[n],false);\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      int nx=x;\n      int ny=y;\n      for(;;){\n\tnx+=d[i];\n\tny+=d[i+1];\n\tif(nx<0||m<=nx||ny<0||n<=ny)break;\n\tif(g[ny][nx]==1){\n\t  ra[ny][nx]=true;\n\t  break;\n\t}\n      }\n    }\n    cout<<dfs(x,y,nh)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n\nint m, n;\nint maze[11][11];\nint house[11][11];\nint housecount;\n\nint dfs(int y, int x, int depth) {\n\tint ret = 0;\n\tfor (int i = y - 1; i >= 0; --i) {\n\t\tif (depth == housecount && maze[i][x] == 2)\n\t\t\treturn 1;\n\n\t\tif (maze[i][x] == 1) {\n\t\t\tmaze[i][x] = 0;\n\t\t\tret += dfs(i, x, depth + 1);\n\t\t\tmaze[i][x] = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = y + 1; i < n; ++i) {\n\t\tif (depth == housecount && maze[i][x] == 2)\n\t\t\treturn 1;\n\n\t\tif (maze[i][x] == 1) {\n\t\t\tmaze[i][x] = 0;\n\t\t\tret += dfs(i, x, depth + 1);\n\t\t\tmaze[i][x] = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = x - 1; i >= 0; --i) {\n\t\tif (depth == housecount && maze[y][i] == 2)\n\t\t\treturn 1;\n\n\t\tif (maze[y][i] == 1) {\n\t\t\tmaze[y][i] = 0;\n\t\t\tret += dfs(y, i, depth + 1);\n\t\t\tmaze[y][i] = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = x + 1; i < m; ++i) {\n\t\tif (depth == housecount && maze[y][i] == 2)\n\t\t\treturn 1;\n\n\t\tif (maze[y][i] == 1) {\n\t\t\tmaze[y][i] = 0;\n\t\t\tret += dfs(y, i, depth + 1);\n\t\t\tmaze[y][i] = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (depth == housecount)\n\t\treturn 0;\n\n\treturn ret;\n}\n\nint main() {\n\twhile (cin >> m >> n && (m || n)) {\n\t\tfor (int i = 0; i < 11; i++)for (int j = 0; j < 11; j++)maze[i][j] = housecount[i][j] = 0;\n\t\tint si, sj;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == 1) {\n\t\t\t\t\thouse[i][j] = housecount;\n\t\t\t\t\thousecount++;\n\t\t\t\t}\n\t\t\t\tif (maze[i][j] == 2) {\n\t\t\t\t\tsi = i, sj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(si, sj, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<stack>\nstruct reindeer{\n    int fly[11][11];\n    int x,y,pst;\n};\nusing namespace std;\nint main(void){\n    // Your code here!\n    int X,Y,xx,yy,map[11][11],i,i2,sx,sy,bx[4]={1,-1,0,0},by[4]={0,0,1,-1},ans,psts;\n    reindeer now,next;\n    stack<reindeer> jotai;\n    cin>>X>>Y;\n    while(X!=0){\n        ans=0;\n        psts=0;\n        for(i=1;i<=Y;i++){\n            for(i2=1;i2<=X;i2++){\n                cin>>map[i2][i];\n                if(map[i2][i]==1)psts++;\n                if(map[i2][i]==2){\n                    sx=i2;\n                    sy=i;\n                }\n                now.fly[i2][i]=0;\n            }\n        }\n        now.pst=0;\n        now.x=sx;\n        now.y=sy;\n        jotai.push(now);\n        while(!jotai.empty()){\n            now=jotai.top();\n            jotai.pop();\n            for(int I=0;I<4;I++){\n                xx=now.x+bx[I];\n                yy=now.y+by[I];\n                while(now.fly[xx][yy]==0&&xx>0&&yy>0&&xx<=X&&yy<=Y){\n                    \n                    /*cout<<now.x<<\"->\"<<xx<<' '<<now.y<<\"->\"<<yy<<endl;\n                    \n                    for(i=1;i<=Y;i++){\n                        for(i2=1;i2<=X;i2++){\n                            cout<<now.fly[i2][i];\n                        }\n                        cout<<endl;\n                    }\n                    cout<<endl;\n                    */\n                    if(map[xx][yy]==1){\n                        for(i=1;i<=Y;i++){\n                            for(i2=1;i2<=X;i2++){\n                                next.fly[i2][i]=now.fly[i2][i];\n                            }\n                        }\n                        next.fly[xx][yy]=now.pst+1;\n                        next.pst=now.pst+1;\n                        next.x=xx;\n                        next.y=yy;\n                        jotai.push(next);\n                    }\n                    if(map[xx][yy]==2){\n                        if(now.pst==psts){\n                            ans++; \n                            \n                            /*\n                            for(i=1;i<=Y;i++){\n                                for(i2=1;i2<=X;i2++){\n                                    cout<<now.fly[i2][i];\n                                }\n                                cout<<endl;\n                            }\n                            cout<<endl;\n                            */\n                        }\n                    }\n                    xx+=bx[I];\n                    yy+=by[I];\n                }\n            }\n        }\n        cout<<ans<<endl;\n        cin>>X>>Y;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\nusing namespace std;\n\nconst int MAX = 10;\nconst int MAX_N = 23;\nconst int G = 23;\nconst int dy[] = {1,0,-1,0};\nconst int dx[] = {0,1,0,-1};\n\nint mask[MAX_N+1][MAX_N+1];\nshort node_id[MAX_N+1][MAX_N+1];\nshort grid[MAX][MAX];\n\nint H,W,N;\n\ntypedef pair<char,int>P;\nmap<P,int>mp;\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> grid[i][j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_N+1 ; i++){\n    for(int j = 0 ; j < MAX_N+1 ; j++){      \n      node_id[i][j] = -1;\n      mask[i][j] = -1;\n    }\n  }\n  mp.clear();\n}\n\nvoid makeMask(){\n  N = 0;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] == 1)node_id[i][j] = N++;\n      if(grid[i][j] == 2)node_id[i][j] = G;\n    }\n  }\n  \n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] != 0){\n\tfor(int d = 0 ; d < 4 ; d++){\n\t  int x = j;\n\t  int y = i;\n\t  int bit = 0;\n\t  while(1){\n\t    x += dx[d]; y += dy[d];\n\t    if(!(0 <= x && x < W && 0 <= y && y < H))break;\n\t    if(node_id[y][x] == -1)continue;\n\t    if(node_id[y][x] != G){\n\t      bit |= (1 << node_id[y][x]);\n\t    }\n\t    mask[node_id[i][j]][node_id[y][x]] = bit;\n\t    //cout <<\"from = \" << node_id[i][j] << \" to = \" << node_id[y][x] <<  \" bit = \" << bit << endl;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint dfs(int now,int last,int bit){\n  if(mp.count(P(now,bit)) != 0)return mp[P(now,bit)];\n  int& ret = mp[P(now,bit)];\n\n  if(now == last){\n    if(bit != (1 << N)-1)return ret = 0;\n    if((mask[now][G] & bit) != 0)return ret = 0;\n    return ret = 1;\n  }\n\n  if((mask[last][G] & bit) != 0)return ret = 0;\n\n  /*\n  if(bit == (1 << N)-1){\n  if((mask[now][G] & bit) != 0)return ret = 0;\n    return ret = 1;\n  }\n  */\n\n  for(int to = 0 ; to < N ; to++){\n    if((mask[now][to] & bit) == 0){\n      ret += dfs(to,last,bit|(1 << to));\n    }    \n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> W >> H,H|W){\n\n    init();\n    input();\n    makeMask();\n\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < N ; j++){\n\tif(i == j)continue;\n\tmp.clear();\n\tif(mask[G][i] != -1)res += dfs(i,j,(1 << i));\n      }\n    }\n    cout << res << endl;\n    \n    /*\n\n    // dp init\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = 0;\n      }\n    }\n    \n    // dp start\n    for(int i = 0 ; i < N ; i++){\n      if(mask[G][i] != -1)dp[i][(1 << i)] = 1;\n    }\n    \n    //cout << \"N = \" << N << endl;\n    for(int i = 0 ; i < (1 << N) ; i++){\n      for(int j = 0 ; j < N ; j++){\n      //if(dp[i][j] == 0)continue;\n\tfor(int k = 0 ; k < N ; k++){\n\t  //cout <<\"mask = \" <<  mask[j][k] << endl;\n\t  if((mask[j][k] & i) == 0){\n\t    dp[k][i|(1 << k)] += dp[j][i];\n\t  }\n\t}\n      }\n    }\n\n    // dp goal\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      if(mask[i][G] != -1 && ((mask[i][G]&((1 << N)-1)) == 0))res += dp[i][(1 << N)-1];\n    }\n    cout << res << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint W, H, cnt, g[11][11], X[24], Y[24];\nunordered_map< int, int > memo[24];\n\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nint rec(int S, int i) {\n\tif (S == (1 << cnt) - 1) {\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[i], ny = Y[i];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (g[ny][nx] == -1 || !in_range(nx, ny)) break;\n\t\t\t\tif (g[ny][nx] == -2) return 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tif (memo[i].count(S)) return memo[i][S];\n\t\n\tint& res = memo[i][S];\n\tres = 0;\n\t\n\tfor_(d,0,4) {\n\t\tint nx = X[i], ny = Y[i];\n\t\t\n\t\tfor_(rep,0,10) {\n\t\t\tnx += dx[d];\n\t\t\tny += dy[d];\n\t\t\t\n\t\t\tif (g[ny][nx] == -1 || !in_range(nx, ny)) break;\n\t\t\tif (g[ny][nx] < -1) continue;\n\t\t\t\n\t\t\tint j = g[ny][nx];\n\t\t\t\t\t\t\n\t\t\tg[ny][nx] = -1;\n\t\t\tres += rec(S | 1 << j, j);\n\t\t\tg[ny][nx] = j;\n\t\t}\n\t}\n\t\t\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,24) memo[i].clear();\n\tcout << rec(0, 23) << endl;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tcnt = 0;\n\t\t\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tcin >> g[y][x];\n\t\t\t\n\t\t\tif (g[y][x] == 0) g[y][x] = -3;\n\t\t\telse if (g[y][x] == 1) { X[cnt] = x; Y[cnt] = y; g[y][x] = cnt; ++cnt; }\n\t\t\telse if (g[y][x] == 2) { X[23] = x; Y[23] = y; g[y][x] = -2; }\n\t\t}\n\t\t\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nconst int MOD=100000;\nint M,N,S,gX,gY;\nint fld[10][10];\nbool f;\nint rec(int x,int y,int sum){\n      //if(xD+yD==0)cout<<x<<\" \"<<y<<\" \"<<sum<<endl;\n      if(gX==x&&gY==y&&f){\n            if(sum==S)return 1;\n            else return 0;\n      }\n      f=true;\n      int res=0;\n      for(int d=x+1;d<M;d++){\n            if(fld[d][y]){\n                  fld[d][y]=0;\n                  res+=rec(d,y,sum+1);\n                  fld[d][y]=1;\n                  break;\n            }\n      }\n      for(int d=x-1;d>=0;d--){\n            if(fld[d][y]){\n                  fld[d][y]=0;\n                  res+=rec(d,y,sum+1);\n                  fld[d][y]=1;\n                  break;\n            }\n      }\n      for(int d=y+1;d<N;d++){\n            if(fld[x][d]){\n                  fld[x][d]=0;\n                  res+=rec(x,d,sum+1);\n                  fld[x][d]=1;\n                  break;\n            }\n      }\n      for(int d=y-1;d>=0;d--){\n            if(fld[x][d]){\n                  fld[x][d]=0;\n                  res+=rec(x,d,sum+1);\n                  fld[x][d]=1;\n                  break;\n            }\n      }\n      return res;\n}\nint main(){\n      while(cin>>M>>N&&(N||M)){\n            S=0;\n            REP(i,N)REP(j,M){\n                  scanf(\"%d\",&fld[j][i]);\n                  if(fld[j][i]==1)S++;\n                  if(fld[j][i]==2){\n                        S++;\n                        gX=j;gY=i;\n                  }\n            }\n            int ans=0;\n            f=false;\n            cout<<rec(gX,gY,0)<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\n#define MAX_H 10\n#define MAX_W 10\n#define MAX_HOUSE 22\n\nint x[MAX_H][MAX_W];\nint y[MAX_H][MAX_W];\nint z[(1 << MAX_HOUSE)];\nint a[(1 << MAX_HOUSE)];\nint v[(1 << MAX_HOUSE)];\nint b[MAX_HOUSE];\nint sum;\nqueue<int>Q;\nqueue<int>R;\n\nint main() {\n\tint h, w, c, d, e, f;\n\twhile (true) {\n\t\tmemset(z, 0, sizeof(z));\n\t\tmemset(v, 0, sizeof(v));\n\t\tmemset(a, 0, sizeof(a));\n\t\tcin >> h >> w;\n\t\tif (h == 0 && w == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tc = 0;\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t\tif (x[i][j] == 1) {\n\t\t\t\t\ty[i][j] = c;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tif (x[i][j] == 2) {\n\t\t\t\t\ty[i][j] = 100;\n\t\t\t\t\tz[0] = 1;\n\t\t\t\t\tQ.push(i * 10 + j);\n\t\t\t\t}\n\t\t\t\tif (x[i][j] == 0) {\n\t\t\t\t\ty[i][j] = 1000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\twhile (!Q.empty() && f < c) {\n\t\t\tf++;\n\t\t\tfor (int i = 0; i < (1 << c); i++) {\n\t\t\t\tif (z[i] - v[i] >= 1) {\n\t\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\t\tb[j] = (i / (1 << j)) % 2;\n\t\t\t\t\t}\n\t\t\t\t\td = Q.front() / 10;\n\t\t\t\t\te = Q.front() % 10;\n\t\t\t\t\tfor (int j = d - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (y[j][e] < 100) {\n\t\t\t\t\t\t\tif (b[y[j][e]] == 1) {\n\t\t\t\t\t\t\t\tgoto E1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tR.push(j * 10 + e);\n\t\t\t\t\t\t\t\ta[i + (1 << y[j][e])] += z[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tE1:;\n\t\t\t\t\tfor (int j = d + 1; j < w; j++) {\n\t\t\t\t\t\tif (y[j][e] < 100) {\n\t\t\t\t\t\t\tif (b[y[j][e]] == 1) {\n\t\t\t\t\t\t\t\tgoto E2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tR.push(j * 10 + e);\n\t\t\t\t\t\t\t\ta[i + (1 << y[j][e])] += z[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tE2:;\n\t\t\t\t\tfor (int j = e - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (y[d][j] < 100) {\n\t\t\t\t\t\t\tif (b[y[d][j]] == 1) {\n\t\t\t\t\t\t\t\tgoto E3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tR.push(d * 10 + j);\n\t\t\t\t\t\t\t\ta[i + (1 << y[d][j])] += z[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tE3:;\n\t\t\t\t\tfor (int j = e + 1; j < h; j++) {\n\t\t\t\t\t\tif (y[d][j] < 100) {\n\t\t\t\t\t\t\tif (b[y[d][j]] == 1) {\n\t\t\t\t\t\t\t\tgoto E4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tR.push(d * 10 + j);\n\t\t\t\t\t\t\t\ta[i + (1 << y[d][j])] += z[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tE4:;\n\t\t\t\t\tQ.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!R.empty()) {\n\t\t\t\tQ.push(R.front());\n\t\t\t\tR.pop();\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << c); i++) {\n\t\t\t\tv[i] = z[i];\n\t\t\t\tz[i] += a[i];\n\t\t\t}\n\t\t\tmemset(a, 0, sizeof(a));\n\t\t}\n\t\tcout << z[(1 << c) - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[10][10];\nint a,b;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,-1,1};\nint n;\nint solve(int x,int y,int d){\n//\tprintf(\"%d %d %d\\n\",x,y,d);\n\tint ret=0;\n\tfor(int i=0;i<4;i++){\n\t\tint X=x;\n\t\tint Y=y;\n\t\twhile(1){\n\t\t\tX+=dx[i];\n\t\t\tY+=dy[i];\n\t\t\tif(!(X>=0&&X<b&&Y>=0&&Y<a))break;\n\t\t\tif(dat[X][Y]==2){\n\t\t\t\tif(d==n){\n\t\t\t\t\tret++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dat[X][Y]==1){\n\t\t\t\tdat[X][Y]=-1;\n\t\t\t\tret+=solve(X,Y,d+1);\n\t\t\t\tdat[X][Y]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\t\t}\n\t\t}\n\t\tn=0;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tif(dat[i][j]==1)n++;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(dat[i][j]==2)printf(\"%d\\n\",solve(i,j,0));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>19||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=19&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=19?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nint n, m, field[11][11], si, sj, num;\n\nint dfs(int x, int y){\n  int ans = 0;\n  if(num == 0){\n    if(x == si || y == sj)return 1;\n    else return 0;\n  }\n  field[x][y] = 0;\n  for(int i = x + 1;i < m;i++){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  } \n  for(int i = x - 1;i >= 0;i--){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  } \n  for(int i = y + 1;i < n;i++){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  } \n  for(int i = y - 1;i >= 0;i--){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  }  \n  field[x][y] = 1;\n  return ans;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    memset(field, 0, sizeof(field));\n    num = 0;\n    for(int i = 0;i < m;i++){\n      for(int j = 0;j < n;j++){\n\tscanf(\"%d\", &field[i][j]);\n\tif(field[i][j] == 2){\n\t  si = i;\n\t  sj = j;\n\t}\n\telse num += field[i][j];\n      }\n    }\n    printf(\"%d\\n\", dfs(si, sj));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nenum Block {BLANK, HOUSE, CHURCH};\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nint m, n;\nint map[10][10];\nint cy, cx;\n\nint dfs(int y, int x, int remain) {\n  if(!remain) return (y == cy) || (x == cx);\n  auto bak = map[y][x];\n  map[y][x] = BLANK;\n  int res = 0;\n  for(auto d: NEXT) {\n    int ny = y + d[Y];\n    int nx = x + d[X];\n    while(true) {\n      if(ny < 0 || n <= ny) break;\n      if(nx < 0 || m <= nx) break;\n      if(map[ny][nx] == HOUSE) {\n        res += dfs(ny, nx, remain - 1);\n        break;\n      }\n      ny += d[Y];\n      nx += d[X];\n    }\n  }\n  map[y][x] = bak;\n  return res;\n}\n\nint main() {\n  while(cin >> m >> n, m | n) {\n    for(int i = 0; i < n; ++i) for(int j = 0; j < m; ++j) cin >> map[i][j];\n\n    int all = 0;\n    for(int i = 0; i < n; ++i) for(int j = 0; j < m; ++j) {\n      if(map[i][j] == HOUSE) ++all;\n      if(map[i][j] == CHURCH) {\n        cy = i;\n        cx = j;\n      }\n    }\n    cout << dfs(cy, cx, all) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;vis|=(1<<houseId[si][sj]);}\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 3 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int>>V; int H, W, cnt, vx, vy;\nvoid solve(vector<vector<int>> p, int x, int y, int cr) {\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tint cx = x, cy = y;\n\tif (cr == 0) { if (x == vx || y == vy)cnt++; return; }\n\tfor (int i = 0; i < 4; i++) {\n\t\tcx = x; cy = y;\n\t\twhile (true) {\n\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)break;\n\t\t\tif (p[cx][cy] == 3) {\n\t\t\t\tvector<vector<int>>q = p;\n\t\t\t\tq[cx][cy] = 1;\n\t\t\t\tsolve(q, cx, cy, cr - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcx += dx[i]; cy += dy[i];\n\t\t}\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; if (H == 0)break; cnt = 0; int vr = 0;\n\t\tvector<vector<int>> a(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) { vx = i; vy = j; }\n\t\t\t\tif (a[i][j] == 1) { a[i][j] = 3; vr++; }\n\t\t\t}\n\t\t}\n\t\tsolve(a, vx, vy, vr);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\n//bit????????????\nint dp[23][1<<23];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\treturn dp[now][bit]=res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\nconst int dx[]={1,-1,0,0};\nconst int dy[]={0,0,1,-1};\n\n\nint N,M;\nint temp[110][110];\nint feld[110][110];\nint cnt;\npii last;\nint ans;\nint t;\nvector<pii> vect[110][110];\n\nvoid dfs(int x,int y,int sum,int pdx,int pdy,bool down){\n    if(x<0||x>=N||y<0||y>=M) return ;\n    //cout<<x<<\" \"<<y<<\" \"<<sum<<endl;\n    if(feld[y][x]==1&&down)feld[y][x]=-1;\n    if(y==last.FI&&x==last.SE&&sum==cnt){\n        ans++;\n        //cout<<\"hoge\"<<endl;\n        //cout<<ans<<endl;\n        return;\n    }\n    if(down){\n        bool b=false;\n        int ptx=-1;\n        int pty=-1;\n        for(int i=0;i<vect[y][x].size();++i){\n            int nx=vect[y][x][i].FI;\n            int ny=vect[y][x][i].SE;\n            int tx=vect[y][x][i].FI-x;\n            int ty=vect[y][x][i].SE-y;\n            if(tx!=0)tx/=abs(tx);\n            if(ty!=0)ty/=abs(ty);\n            if(b&&ptx==tx&&pty==ty)continue;\n            b=false;\n            ptx=tx;\n            pty=ty;\n            if(feld[ny][nx]==-1){\n                b=true;\n                continue;\n            }\n            if(feld[ny][nx]==1){\n                dfs(nx,ny,sum+1,tx,ty,true);\n            }\n            else dfs(nx,ny,sum,tx,ty,false);\n        }\n    }\n    else{\n        for(int i=0;i<vect[y][x].size();++i){\n            int nx=vect[y][x][i].FI;\n            int ny=vect[y][x][i].SE;\n            int tx=vect[y][x][i].FI-x;\n            int ty=vect[y][x][i].SE-y;\n            if(tx!=0)tx/=abs(tx);\n            if(ty!=0)ty/=abs(ty);\n            if(pdx==tx&&pdy==ty){\n                if(feld[ny][nx]==-1){\n                    if(feld[y][x]==-1)feld[y][x]=1;\n                    return;\n                }\n                else if(feld[ny][nx]==1){\n                    dfs(nx,ny,sum+1,tx,ty,true);\n                }\n                else dfs(nx,ny,sum,tx,ty,false);\n            }\n        }\n    }\n    if(feld[y][x]==-1)feld[y][x]=1;\n    return ;\n}\n\n\nsigned main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(feld,0,sizeof(feld));\n        for(int i=0;i<M;++i){\n            for(int j=0;j<N;++j){\n                cin>>feld[i][j];\n                if(feld[i][j]==2){\n                    last.FI=i;\n                    last.SE=j;\n                }\n                else if(feld[i][j]!=0)cnt++;\n            }\n        }\n\n        for(int i=0;i<M;++i){\n            for(int j=0;j<N;++j){\n                for(int k=0;k<4;++k){\n                    for(int l=1;l<100;++l){\n                        int nx=dx[k]*l;\n                        int ny=dy[k]*l;\n                        if(j+nx<0||j+nx>=N||i+ny<0||i+ny>=M)break;\n                        if(feld[i+ny][j+nx]!=0){\n                            vect[i][j].push_back(pii(j+nx,i+ny));\n                            //break;\n                        }\n                    }\n                }\n            }\n        }\n        dfs(last.SE,last.FI,0,0,0,true);\n        /*for(int i=0;i<M;++i)for(int j=0;j<N;++j){\n            cout<<\"[\"<<i<<\" \"<<j<<\"]\"<<endl;\n            for(int k=0;k<vect[i][j].size();++k)cout<<vect[i][j][k].FI<<\" \"<<vect[i][j][k].SE<<endl;\n        }*/\n        cout<<ans<<endl;\n        ans=0;\n        cnt=0;\n        for(int i=0;i<M;++i)for(int j=0;j<N;++j)vect[i][j].clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint W, H;\n\nint a[12][12];\nint sy, sx;\nint nei_count = 0;\nint house_count = 0;\nbool is_nei[12][12];\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, -1, 0, 1};\n\nint dfs(int y, int x, int zan)\n{\n    if (zan == 0) {\n        return nei_count == 1;\n    }\n\n    if (a[y][x] == -1 && is_nei[y][x]) nei_count -= 1;\n\n    bool f = false;\n\n    int res = 0;\n\n    for (int nowy = y - 1; nowy >= 1; --nowy) {\n        if (a[nowy][x] == -1) break;\n        if (a[nowy][x] == 1) {\n            f = true;\n            a[nowy][x] = -1;\n\n            res += dfs(nowy, x, zan - 1);\n\n            a[nowy][x] = 1;\n        }\n    }\n\n    for (int nowy = y + 1; nowy <= H; ++nowy) {\n        if (a[nowy][x] == -1) break;\n        if (a[nowy][x] == 1) {\n            f = true;\n            a[nowy][x] = -1;\n\n            res += dfs(nowy, x, zan - 1);\n\n            a[nowy][x] = 1;\n        }\n    }\n\n    for (int nowx = x - 1; nowx >= 1; --nowx) {\n        if (a[y][nowx] == -1) break;\n        if (a[y][nowx] == 1) {\n            f = true;\n            a[y][nowx] = -1;\n\n            res += dfs(y, nowx, zan - 1);\n\n            a[y][nowx] = 1;\n        }\n    }\n\n    for (int nowx = x + 1; nowx <= W; ++nowx) {\n        if (a[y][nowx] == -1) break;\n        if (a[y][nowx] == 1) {\n            f = true;\n            a[y][nowx] = -1;\n\n            res += dfs(y, nowx, zan - 1);\n\n            a[y][nowx] = 1;\n        }\n    }\n\n    if (a[y][x] == -1 && is_nei[y][x]) nei_count += 1;\n\n    if (!f) {\n        return 0;\n    }\n\n    return res;\n}\n\nsigned main()\n{\n    while (cin >> W >> H, W) {\n        memset(a, -1, sizeof(a));\n        memset(is_nei, false, sizeof(is_nei));\n        nei_count = 0;\n        house_count = 0;\n\n        rep1(i, H) rep1(j, W) {\n            cin >> a[i][j];\n            if (a[i][j] == 1) {\n                house_count += 1;\n            }\n            else if (a[i][j] == 2) {\n                sy = i, sx = j;\n            }\n        }\n\n        rep(i, 4) {\n            int ny = sy + dy[i], nx = sx + dx[i];\n            while (a[ny][nx] == 0) ny += dy[i], nx += dx[i];\n\n            if (a[ny][nx] == 1) {\n                nei_count += 1;\n                is_nei[ny][nx] = true;\n            }\n        }\n\n        cout << dfs(sy, sx, house_count) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;}\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n    if( st_now.cnt + 3 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    \n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !st_now.checkvis( houseId[next.fr][next.sc] ) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.setvis( houseId[next.fr][next.sc] );\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, C, sx, sy; vector<vector<int> > M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint solve(int x, int y, int d, vector<vector<bool> > used)\n{\n\tif (x == sx && y == sy)\n\t{\n\t\tif (d == C)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (d != 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint x2 = x + dx[dir];\n\t\tint y2 = y + dy[dir];\n\n\t\twhile (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t{\n\t\t\tif (used[y2][x2])\n\t\t\t{\n\t\t\t\tvector<vector<bool> > used2(used.begin(), used.end()); used2[y2][x2] = false;\n\n\t\t\t\tret += solve(x2, y2, d + 1, used2); break;\n\t\t\t}\n\t\t\t\n\t\t\tx2 += dx[dir];\n\t\t\ty2 += dy[dir];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tM = vector<vector<int> >(H, vector<int>(W));\n\n\t\tvector<vector<bool> > start(H, vector<bool>(W, false)); C = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &M[i][j]);\n\n\t\t\t\tif (M[i][j] != 0) { C++; start[i][j] = true; }\n\n\t\t\t\tif (M[i][j] == 2) { sx = j; sy = i; }\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve(sx, sy, 0, start));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    if(ni==t.ni){\n      if(nj==t.nj){\n\treturn vis<t.vis;\n      }else return nj < t.nj;\n    }else return ni < t.ni;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n    \n    //cout << \"CNT: \" << (int)st_now.cnt << endl;\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    if( st_now.cnt >= 5 ){\n      int left = 0;\n      int chi=charch.fr;int chj=charch.sc;\n      for(int k = 0; k < MAXDIR; ++k){\n\tleft += M[chi][chj].link[k].size();\n      }\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n    }\n\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.cnt++;\n\t    st_next.vis |= ( 1<<houseId[next.fr][next.sc] );\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nmap<tup, int> dp;\nint tb[10][10];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (dp.count(tup{ idx,bits })) return dp[tup{idx, bits}];\n\tif (idx == hs && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if(~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(x, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\t\n\treturn dp[tup{idx, bits}] = res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tdp.clear();\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <stack>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint main() {\n  while (true) {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    vector<vector<int>> p(n, vector<int>(m));\n    for (int i : range(n)) for (int j : range(m)) cin >> p[i][j];\n    vector<pair<int, int>> house;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 1) house.emplace_back(i, j);\n    vector<vector<int>> s(n, vector<int>(m, -1));\n    for (int i : range(house.size())) s[house[i].first][house[i].second] = i;\n    stack<tuple<int, int, int>> stc;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 2) stc.push(make_tuple(i, j, 0));\n    int res = 0;\n    while (!stc.empty()) {\n      auto now = stc.top(); stc.pop();\n      int y = get<0>(now);\n      int x = get<1>(now);\n      int bit = get<2>(now);\n      for (int i : range(4)) {\n        int yy = y + dy[i];\n        int xx = x + dx[i];\n        while (true) {\n          if (yy < 0 || n <= yy) break;\n          if (xx < 0 || m <= xx) break;\n          if (p[yy][xx] == 1) {\n            if (bit & 1 << s[yy][xx]) break;\n            stc.push(make_tuple(yy, xx, bit | 1 << s[yy][xx]));\n          }\n          if (p[yy][xx] == 2) {\n            if (bit == (1 << house.size()) - 1) ++res; \n            break;\n          }\n          yy += dy[i];\n          xx += dx[i];\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nchar tab[12][12];\nint wx,wy;\nint nx,ny,rem;\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy;\n    nowx=nx;nowy=ny;\nLA:\n   nowx++;\n   if(nowx>=wx) goto LB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB:         \n\n    nowx=nx,nowy=ny;\nMA:\n   nowx--;\n   if(0>nowx) goto MB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto MB;\n   }\n   goto MA;\nMB:         \n    nowx=nx,nowy=ny;\nNA:\n   nowy++;\n   if(nowy>=wy) goto NB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto NB;\n   }\n   goto NA;\nNB:        \n    nowx=nx,nowy=ny;\nOA:\n   nowy--;\n   if(0>nowy) goto OB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            int ins;\n            scanf(\"%d\",&ins);\n            tab[i][j]=ins;\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int, int>;\nmap<tup, int> dp;\nint tb[10][10];\nint sr, sc;\nint hs;\n\nint dfs(int nr, int nc, int bits) {\n\tif (dp.count(tup{ nr,nc,bits })) return dp[tup{nr, nc, bits}];\n\tif (nr == sr && nc == sc && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if(~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(i, nc, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(i, nc, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(nr, j, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(nr, j, bits | 1 << x);\n\t}\n\t\n\treturn dp[tup{nr, nc, bits}] = res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tdp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tcout << dfs(sr, sc, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;}\n  bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n    /*\n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !st_now.checkvis( houseId[next.fr][next.sc] ) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.setvis( houseId[next.fr][next.sc] );\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n \nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_N = 11;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n \nint fld[MAX_N][MAX_N], w, h, sx, sy, idx;\nint hoge;\n \nint Solve(int x, int y, int mask) {\n    if (x == sx && y == sy) {\n        if (mask) return 0;\n        return 1;\n    }\n \n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        int tx = x, ty = y;\n        while (0 < tx && 0 < ty && tx <= w && ty <= h) {\n            tx += dx[i];\n            ty += dy[i];\n            if (sx == tx && sy == ty) res += Solve(tx, ty, mask);\n \n            int num = fld[tx][ty];\n            if (num == -1) continue;\n            if (mask & (1 << num)) {\n                res += Solve(tx, ty, mask - (1 << num));\n                break;\n            }\n        }\n    }\n \n    return res;\n}\n \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    while (cin >> w >> h, w) {\n        memset(fld, -1, sizeof(fld));\n        idx = 0;\n \n        for (int y = 1; y <= h; ++y) {\n            for (int x = 1; x <= w; ++x) {\n                int t;\n                cin >> t;\n                if (t == 0) continue;\n                if (t == 2) {\n                    sx = x;\n                    sy = y;\n                    continue;\n                } else t = idx++;\n                fld[x][y] = t;\n            }\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < 4; ++i) {\n            int tx = sx, ty = sy;\n            while (0 < tx && tx <= w && 0 < ty && ty <= h) {\n                tx += dx[i];\n                ty += dy[i];\n                if (fld[tx][ty] == -1) continue;\n                ans += Solve(tx, ty, (1 << idx) - 1 - (1 << fld[tx][ty]));\n                break;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint x,y;\nint sx,sy;\nint N;\nint hx[24],hy[24];\nint fie[12][12];\nint dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit,bool done[12][12],int home){\n\tif(memo[pos].find(bit)!=memo[pos].end())return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\t\twhile(fie[cx][cy]!=-1){\n\t\t\t\tif(fie[cx][cy]==100)return 1;\n\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\twhile(fie[cx][cy]==-2 || fie[cx][cy]==100 || done[cx][cy]==true){\n\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t}\n\t\tif(fie[cx][cy]!=-1){\n\t\t\tdone[cx][cy]=true;\n\t\t\tans+=dfs(fie[cx][cy] , bit | (1<<fie[cx][cy]), done,home+1);\n\t\t\tdone[cx][cy]=false;\n\t\t}\n\t}\n\tif(home<18)memo[pos][bit]=ans;\n\treturn ans;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tN=0;\n\t\tfor(int i=0;i<24;i++){\n\t\t\tmemo[i].clear();\n\t\t}\n\t\tfor(int i=0;i<12;i++){\n\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\tfie[j][i]=-1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfie[j][i]=-2;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tfie[j][i]=100;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==1){\n\t\t\t\t\tfie[j][i]=N;\n\t\t\t\t\thx[N]=j;\n\t\t\t\t\thy[N]=i;\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thx[N]=sx,hy[N]=sy;\n\t\tbool done[12][12];\n\t\tmemset(done,false,sizeof(done));\n\t\tcout << dfs(N,0,done,0) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w,h,x,y;\nint sx,sy,n;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nvector<vector<int> > v;\nvector<P> p;\n\nint ans = 0;\n\nbool can(int y,int x) {\n    if(0 <= y && y < h && 0 <= x && x < w) return true;\n    return false;\n}\n\nvoid dfs(int S, int y,int x) {\n    bool flag = true;\n    rep(i,n) {\n        if(S & (1<<i)) continue;\n        flag = false;\n    }\n\n    // cout << S << endl;\n    // rep(i,n) {\n    //     if(S & (1<<i)) cout << \"O\";\n    //     else cout << \"X\";\n    // }\n    // cout << endl;\n\n\n    if(flag) {\n        if(sx == x) {\n            bool ch = true;\n            rep(i,n) {\n                if(p[i].first == y && min(x, sx) < p[i].second && p[i].second < max(sx,x)) {\n                    ch = false;\n                }\n            }\n\n            if(ch) {\n                ans++;\n            }\n        } else if(sy == y) {\n            bool ch = true;\n            rep(i,n) {\n                if(p[i].second == x && min(y, sy) < p[i].first && p[i].first < max(y, sy)) {\n                    ch = false;\n                }\n            }\n\n            if(ch) {\n                ans++;\n            }\n        }\n\n        return;\n    }\n\n\n\n\n    rep(i,n) {\n        if(S & (1<<i)) continue;\n\n        if(p[i].second == x) {\n            bool ch = true;\n            rep(j,n) {\n                if(S & (1<<j)) {\n                    if(y == p[j].first && min(p[i].second,x) < p[j].second && p[j].second && max(p[i].second,x)) {\n                        ch = false;\n                    }\n                }\n            }\n\n            if(ch) {\n                // cout << S << \" - > \" << (S & (1<<i)) << endl;\n                dfs(S | (1<<i), p[i].first, p[i].second);\n            }\n        } else if(p[i].first == y) {\n            bool ch = true;\n            rep(j,n) {\n                if(S & (1<<j)) {\n                    if(x == p[j].second && min(p[i].first,y) < p[j].first && p[j].first && max(p[i].first,y)) {\n                        ch = false;\n                    }\n                }\n            }\n\n            if(ch) {\n                dfs(S | (1<<i), p[i].first, p[i].second);\n            }\n        }\n    }\n    return;\n}\n\nint main() {\n\n    while(cin >> w >> h) {\n        if(w == 0 && h == 0) break;\n\n        p.clear();\n        v.resize(h);\n\n        rep(i,h) {\n            v[i].resize(w);\n            rep(j,w) {\n                cin >> v[i][j];\n\n                if(v[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                } else if(v[i][j] == 1) {\n                    p.push_back( P(i,j));\n                }\n            }\n        }\n\n        n = p.size();\n\n        ans = 0;\n        dfs(0, sy, sx);\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef long long ll;\nint n,m,ST;\nint fie[11][11];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nvector<int> G[25][4];\nint co;\nint dp[25][(1<<18)];\nvoid make_graf(){\n  for(int x=0;x<m;x++){\n    for(int y=0;y<n;y++){\n      //      printf(\"fie[%d][%d]=%d\\n\",x,y,fie[x][y]);\n      if(fie[x][y]<-1) continue;\n      int no=fie[x][y];\n      if(no<0) no=co;\n      //          printf(\"%d\\n\",no);\n      for(int i=0;i<4;i++){\n\tG[no][i].clear();\n\tfor(int l=1;;l++){\n\t  int nx = x+dx[i]*l;\n\t  int ny = y+dy[i]*l;\n\t  if(nx<0 || ny<0) break;\n\t  if(nx>=m || ny>=n) break;\n\t  if(fie[nx][ny]>=-1)\n\t    G[no][i].push_back(fie[nx][ny]);\n\t}\n\n\t//\tprintf(\"size=%d\\n\",G[no][i].size());\n      }\n    }\n  }\n}\nint solve(int no,int st){\n  //  cout <<no << \" \" << bitset<24>(st) << endl;\n  if(st<(1<<18)){\n    if(dp[no][st]!=-1) return dp[no][st];\n  }\n  int x,y;\n  if(st==ST){\n    for(int i=0;i<4;i++){\n      if(G[no][i].empty()) continue;\n      for(int l=0;l<(int)G[no][i].size();l++){\n\tint num = G[no][i][l];\n\tif(num==-1) return 1;\n      }\n    }\n    return 0;\n  }\n  int ret=0;\n  for(int i=0;i<4;i++){\n    //   cout << G[no][i].size() << endl;\n    if(G[no][i].empty()) continue;\n    for(int l=0;l<(int)G[no][i].size();l++){\n      /*      int nx = x+dx[i]*l;\n      int ny = y+dy[i]*l;\n      if(nx<0 || ny<0) break;\n      if(nx>=m || ny>=n) break;\n      if(fie[nx][ny]==-2) continue;\n      if(fie[nx][ny]==-1) continue;\n      if(!(st & (1<<fie[nx][ny])) ){\n\tret+=solve(nx,ny,no+1, (st | (1<<fie[nx][ny])) );\n\tbreak;\n\t}*/\n      int num = G[no][i][l];\n\n      //    cout << num << \" \" << (st|(1<<num)) << endl;\n      if(num==-2) continue;\n      if(num==-1) continue;\n      if(!(st & (1 << num)) ){\n\tret+= solve(num,(st | (1 << num)));\n\tbreak;\n      }\n    }\n  }\n  if(st<(1<<18))\n    return dp[no][st]=ret;\n  else\n    return ret;\n}\n\nvoid print_fie(){\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&m,&n);\n    if(!n && !m) break;\n    memset(dp,-1,sizeof(dp));\n    int sx,sy;\n    co=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&fie[j][i]);\n\tif(fie[j][i]==1){\n\t  fie[j][i]=co;\n\t  co++;\n\t} else if (fie[j][i]==2){\n\t  fie[j][i]=-1;\n\t  sx=j; sy=i;\n\t} else if (fie[j][i]==0){\n\t  fie[j][i]=-2;\n\t}\n      }\n    }\n    ST=(1<<co)-1;\n    make_graf();\n    //  print_fie();\n    printf(\"%d\\n\",solve(co,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint h, w;\nint k = 1, l;\nint b[10][10], o;\nint c[100];\nint dp[24][16777216];\nint a[10][10];\nint solve(int i, int j, int s) {\n\tif (l == s) {\n\t\tif (b[i][j] == o)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tint sum = 0;\n\tfor (int x = i + 1; x < h; x++) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = i - 1; x >= 0; x--) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j + 1; y < w; y++) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j - 1; y >= 0; y--) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> w >> h&&w!=0&&h!=0) {\n\t\tint sx, sy;\n\t\tint sum = 0;\n\t\tl = 0;\n\t\tk = 1;\n\t\to = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\to = sum;\n\t\t\t\t}\n\t\t\t\tif (a[i][j]) {\n\t\t\t\t\tb[i][j] = sum;\n\t\t\t\t\tc[sum++] = k;\n\t\t\t\t\tl += k;\n\t\t\t\t\tk *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < sum; i++) {\n\t\t\tfor (int j = 0; j <= l; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcout << solve(sx, sy, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint n, m, field[11][11], si, sj, num;\n\nint dfs(int x, int y){\n  int ans = 0;\n  if(num == 0){\n    if(x == si || y == sj)return 1;\n    else return 0;\n  }\n  field[x][y] = 0;\n  for(int i = x + 1;i < m;i++){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  } \n  for(int i = x - 1;i >= 0;i--){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  } \n  for(int i = y + 1;i < n;i++){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  } \n  for(int i = y - 1;i >= 0;i--){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  }  \n  field[x][y] = 1;\n  return ans;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    memset(field, 0, sizeof(field));\n    num = 0;\n    for(int i = 0;i < m;i++){\n      for(int j = 0;j < n;j++){\n\tscanf(\"%d\", &field[i][j]);\n\tif(field[i][j] == 2){\n\t  si = i;\n\t  sj = j;\n\t}\n\telse num += field[i][j];\n      }\n    }\n    printf(\"%d\\n\", dfs(si, sj));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<P,int> dp;\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(P s){\n  if(dp[s])return dp[s];\n\n  int vis = s.first, id = s.second;\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\tres += 1;\n\tbreak;\n      }\n      if(0<g[ty][tx]){\n\tint tmp = g[ty][tx] - 1;\n\tif( (vis>>tmp)&1 ){\n\t  res += rec(P(vis-(1<<tmp),g[ty][tx]));\n\t  break;\n\t}\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(s.first)<20)dp[s] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    dp.clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(P(upper-1,0)));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 23;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s, int &order)\n{\n\torder++;\n\tint noBits = CountBit(s);\n\tif (x == sx && y == sy && noBits == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (noBits < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0, cnt = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, noBits))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]), cnt);\n\t}\n\torder += cnt;\n\tif (noBits < MAX && cnt >= 0) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0, cnt));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nenum Direction {\n    EAST, WEST, NORTH, SOUTH\n};\n\nstruct Home {\n    int index;\n    Home *neighbor[4];\n};\n\nconst int GOAL = 100;\n\nHome homes[10][10];\n\nmap<pair<int,int>,int> memo;\nint dfs(Home *cur, int mask, int rem) {\n    int sum = 0;\n\n    pair<int,int> key = make_pair(mask, cur->index);\n    if(memo.count(key)) return memo[key];\n    for(int dir = 0; dir < 4; ++dir) {\n        Home *next = cur->neighbor[dir];\n        while(next) {\n            if(rem == 0) {\n                if(next->index == GOAL) return memo[key] = 1;\n            }\n            if(next->index != GOAL && !(mask&(1<<next->index))) {\n                sum += dfs(next, mask|(1<<next->index), rem-1);\n                break;\n            }\n            next = next->neighbor[dir];\n        }\n    }\n    return memo[key] = sum;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> M >> N;\n        if(!N && !M) break;\n\n        memset(homes, 0, sizeof(homes));\n        for(int i = 0; i < 10; ++i) {\n            for(int j = 0; j < 10; ++j) {\n                homes[i][j].index = -1;\n            }\n        }\n\n        int home_idx = 0;\n        int rem = 0;\n        int sr, sc;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < M; ++j) {\n                int val;\n                cin >> val;\n                if(val != 0) {\n                    if(val == 1) {\n                        homes[i][j].index = home_idx++;\n                        ++rem;\n                    }\n                    else {\n                        homes[i][j].index = GOAL;\n                        sr = i;\n                        sc = j;\n                    }\n\n                    for(int jj = j-1; jj >= 0; --jj) {\n                        if(homes[i][jj].index != -1) {\n                            homes[i][jj].neighbor[EAST] = &homes[i][j];\n                            homes[i][j].neighbor[WEST] = &homes[i][jj];\n                            break;\n                        }\n                    }\n                    for(int ii = i-1; ii >= 0; --ii) {\n                        if(homes[ii][j].index != -1) {\n                            homes[ii][j].neighbor[SOUTH] = &homes[i][j];\n                            homes[i][j].neighbor[NORTH] = &homes[ii][j];\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        memo.clear();\n        cout << dfs(&homes[sr][sc], 0, rem) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define END (64)\n#define EMPTY (-2)\n#define WALL (-1)\nint px[24],py[24],kx,ky;\nint H,W,N;\nint field[12][12];\n\nint dx[] = {0,-1,0,1} , dy[] = {1,0,-1,0};\n\nmap<int,int> memo[24];\n\nint dfs(int pos , int bit , bool done[12][12]){\n\tif(memo[pos].find(bit) != memo[pos].end() ) return memo[pos][bit];\n\t\n\t\n\t// SÌÆÉHÁ½ã³ïÉAêé©Ç¤©\n\tif(bit == (1<<N)-1){\n\t\trep(d,4){\n\t\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\t\twhile( field[cy][cx] != WALL){\n\t\t\t\tif(field[cy][cx] == END) return 1;\n\t\t\t\tcy += dy[d] , cx += dx[d];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t// »êÈOÈçHÁÄÈ¢ÆÅÅÉ·éÆð©Â¯éB\n\tint ans = 0;\n\trep(d,4){\n\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\twhile( field[cy][cx] == EMPTY || field[cy][cx] == END || done[cy][cx] == true ){\n\t\t\tcy += dy[d] , cx += dx[d];\n\t\t}\n\t\tif(field[cy][cx] != -1){\n\t\t\tdone[cy][cx] = 1;\n\t\t\tans += dfs(field[cy][cx] , bit | (1<<field[cy][cx]) , done);\n\t\t\tdone[cy][cx] = 0;\n\t\t}\n\t}\n\t\n\t// HÁ½ÆÌª19¢ÈçéB(Îô)\n\tif(__builtin_popcount(bit) < 19)\n\t\tmemo[pos][bit] = ans;\n\treturn ans;\n}\n\nint main(){\n\twhile(cin >> W >> H ,W){\n\t\t// ú»\n\t\tN = 0;\n\t\trep(i,12)rep(j,12)field[i][j] = WALL;\n\t\t\n\t\t// üÍ\n\t\trep(i,H)rep(j,W){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tswitch(t){\n\t\t\tcase 0:\n\t\t\t\tfield[i+1][j+1] = EMPTY;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfield[i+1][j+1] = N;\n\t\t\t\tpx[N] = j+1, py[N] = i+1;\n\t\t\t\tN++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tkx = j+1 , ky = i+1;\n\t\t\t\tfield[i+1][j+1] = END;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpx[N] = kx , py[N] = ky;\n\t\t\n\t\t// Tõ\n\t\trep(i,24) memo[i].clear();\n\t\tbool done[12][12]={{false}};\n\t\tcout << dfs(N,0,done) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < 16)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < 16) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;vis|=(1<<houseId[si][sj]);}\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    \n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint m,n,k=0;\nint a[15][15];\nint ans=0,locx,locy;\n\nint solve(int x,int y){\n\tint ret=0;\n\tbool b=false;\n\tif(a[x][y]==1){a[x][y]=3; b=true; k--;}\n\tif(k==0){\n\t\ta[x][y]=1; k++;\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<1<<endl;\n\t\tfor(int i=x-1;i>=0;i--){\n\t\t\tif(a[i][y]==3)break;\n\t\t\tif(a[i][y]==2)return 1;\n\t\t}\n\t\tfor(int i=x+1;;i++){\n\t\t\tif(a[i][y]==3)break;\n\t\t\tif(a[i][y]==2)return 1;\n\t\t}\n\t\tfor(int j=y-1;j>=0;j--){\n\t\t\tif(a[x][j]==3)break;\n\t\t\tif(a[x][j]==2)return 1;\n\t\t}\n\t\tfor(int j=y+1;;j++){\n\t\t\tif(a[x][j]==3)break;\n\t\t\tif(a[x][j]==2)return 1;\n\t\t}\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<0<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=x-1;i>=0;i--){\n\t\tif(a[i][y]==3)break;\n\t\tif(a[i][y]==1)ret+=solve(i,y);\n\t}\n\tfor(int i=x+1;;i++){\n\t\tif(a[i][y]==3)break;\n\t\tif(a[i][y]==1)ret+=solve(i,y);\n\t}\n\tfor(int j=y-1;j>=0;j--){\n\t\tif(a[x][j]==3)break;\n\t\tif(a[x][j]==1)ret+=solve(x,j);\n\t}\n\tfor(int j=y+1;;j++){\n\t\tif(a[x][j]==3)break;\n\t\tif(a[x][j]==1)ret+=solve(x,j);\n\t}\n\tif(b){a[x][y]=1; k++;}\n\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<ret<<endl;\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++)a[i][j]=3;\n\tk=0;\n\tscanf(\"%d%d\",&m,&n);\n\tif(m==0&&n==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\tif(a[i][j]==1)k++;\n\t\t\tif(a[i][j]==2){locx=i; locy=j;}\n\t\t}\n\t}\n\tans=solve(locx,locy);\n\tprintf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\n\tint ans=0;\n\trep(k,4) rep(a,deg[id][k]) {\n\t\tint next_id=adj[id][k][a];\n\t\tif((picked&(1<<next_id))==0){\n\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(dp[id].size()<50000) dp[id][picked]=ans;\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int nposmax = 10;\nconst int bitmax = 1<<21;\n//bit????????????\nint dp[nposmax][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax&&now<nposmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\tif(bit<bitmax&&now<nposmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst bitmax = 1<<20;\n//bit????????????\nint dp[23][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\tif(bit<bitmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 14 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\n//map<int,int> dp[24];\nint dp[24][1<<18];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(__builtin_popcount(vis)<18 && dp[id][vis])return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)<18)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    //for(int i=0;i<pn;i++)dp[i].clear();\n\tfor(int i=0;i<pn;i++)\n   \t  for(int j=0;j<(1<<18);j++)dp[i][j] = 0;\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint H,W;\nint G[11][11],INDEX[11][11],ep_bitmask,sp,V;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvector<int> edges[25][4];\n//map<ii,int> memo;\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void INIT(){\n  //memo.clear();\n  ep_bitmask = 0, sp = -1;\n  rep(i,11) rep(j,11) INDEX[i][j] = -1;\n  rep(i,25) rep(j,4) edges[i][j].clear();\n}\n\ninline void make_edges(){\n  rep(i,H) rep(j,W) if( G[i][j] != 0 ) {\n    int x = j, y = i;\n    rep(k,4){\n      int nx = x + dx[k], ny = y + dy[k];\n      while( isValid(nx,ny) ){\n        if( G[ny][nx] == 1 ) edges[INDEX[i][j]][k].push_back(INDEX[ny][nx]);\n        nx += dx[k], ny += dy[k];\n      }\n    }\n  }\n}\n\ninline void calc_last_point(int x,int y){\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    while( isValid(nx,ny) ){\n      if( G[ny][nx] == 1 ) {\n        ep_bitmask |= (1<<INDEX[ny][nx]);\n        //break;\n      }\n      nx += dx[i], ny += dy[i];\n    }\n  }\n}\n\nint dfs(int cur,int visited,int remain,int ep_remain){\n\n  if( ep_remain == 0 && remain != 0 ) return 0;\n\n  if( remain <= 0 ) return ( (ep_bitmask>>cur) & 1 );\n\n  int ret = 0;\n  rep(k,4){\n    rep(i,edges[cur][k].size()){\n      int next = edges[cur][k][i];\n      if( (visited>>next) & 1 ) continue;\n      ret += dfs(next,visited|(1<<next),remain-1,ep_remain-((ep_bitmask>>next)&1));\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while( cin >> W >> H, H|W ){\n    INIT();\n    int idx = 0,remain = 0,sx,sy;\n    rep(i,H) rep(j,W) {\n      cin >> G[i][j];\n      if( G[i][j] == 1 ) INDEX[i][j] = idx++, remain++;\n      if( G[i][j] == 2 ) sx = j, sy = i;\n    }\n    sp = INDEX[sy][sx] = idx++;\n    make_edges();\n\n    calc_last_point(sx,sy);\n    assert(remain <= 23);\n    V = remain;\n    cout << dfs(sp,0,remain,__builtin_popcount(ep_bitmask)) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint dp[1<<23][23]; //ここまで、現在地\nbool already[1<<23][23] = {};\nvector<pair<int,int>> way[23];\n\nint solve(int i, int j){\n\tif(already[i][j]) return dp[i][j];\n\tdp[i][j] = 0;\n\tif((i&(1<<j)) == 0) return 0;\n\tbool flg = true;\n\tfor(int k=way[j].size()-1; k>=0; k--){\n\t\tif(way[j][k] == MP(-1,-1)){\n\t\t\tflg = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(flg == false) continue;\n\t\tif((i&way[j][k].second) == way[j][k].second && (i&(1<<way[j][k].first)) == 0){\n\t\t\tdp[i][j] += solve(i+(1<<way[j][k].first), way[j][k].first);\n\t\t\tflg = false;\n\t\t}\n\t}\n\talready[i][j] = true;\n\treturn dp[i][j];\n}\n\nint main() {\n\tiostream::sync_with_stdio(false);\n\n\tSTART:\n\t\n\tint m,n;\n\tcin >> m >> n;\n\tif(n == 0 && m == 0) return 0;\n\tint a[10][10];\n\tvector<pair<int,int> > house;\n\tpair<int,int> kyokai;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j] == 0) a[i][j] = -1; //空地\n\t\t\telse if(a[i][j] == 2){\n\t\t\t\ta[i][j] = -2; //教会\n\t\t\t\tkyokai = MP(i,j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i][j] = house.size();\n\t\t\t\thouse.push_back(MP(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\t//経路計算\n\tfor(int i=0; i<house.size(); i++){\n\t\tway[i].clear();\n\t\tint x = house[i].first;\n\t\tint y = house[i].second;\n\t\tint tmp = 0;\n\t\tfor(int j=x+1; j<n; j++){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=x-1; j>=0; j--){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=y+1; j<m; j++){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=y-1; j>=0; j--){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t}\n\n\t//教会隣接家dp初期化\n\tfor(int i=0; i<house.size(); i++){\n\t\tdp[(1<<house.size())-1][i] = 0;\n\t\talready[(1<<house.size())-1][i] = true;\n\t}\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t}\n\t}\n\n\tfor(int i=(1<<house.size())-2; i>=0; i--){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\talready[i][j] = false;\n\t\t}\n\t}\n\n\t/*\n\t//dp\n\tfor(int i=(1<<house.size())-2; i>=0; i--){ //2^23\n\t\tfor(int j=0; j<house.size(); j++){ //23\n\t\t\tdp[i][j] = 0;\n\t\t\tif((i&(1<<j)) == 0) continue;\n\t\t\tfor(int k=0; k<way[j].size(); k++){ //20\n\t\t\t\tif((i&way[j][k].second) == 0 && (i&(1<<way[j][k].first)) == 0){\n\t\t\t\t\tdp[i][j] += dp[i+(1<<way[j][k].first)][way[j][k].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t//最終的な答え\n\tint ans = 0;\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += solve(1<<a[i][kyokai.second],a[i][kyokai.second]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += solve(1<<a[i][kyokai.second],a[i][kyokai.second]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += solve(1<<a[kyokai.first][i],a[kyokai.first][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += solve(1<<a[kyokai.first][i],a[kyokai.first][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\tgoto START;\n\n\t/*\n\t//デバッグ\n\tfor(int i=0; i<house.size(); i++){\n\t\tfor(int j=0; j<way[i].size(); j++){\n\t\t\tcout << way[i][j].first << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tfor(int i=0; i<(1<<house.size()); i++){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint H[10][10];\nint m, n;\nint I, J;\n\nint solve(int i, int j, int k) {\n\tif (!k) {\n\t\tif (i == I || j == J)return 1;\n\t\telse return 0;\n\t}\n\tint res = 0;\n\tfor (int t = 1; i + t < n; t++) {\n\t\tif (H[i + t][j] == 1) {\n\t\t\tH[i + t][j] = 0;\n\t\t\tres += solve(i + t, j, k - 1);\n\t\t\tH[i + t][j] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int t = 1; i - t >= 0; t++) {\n\t\tif (H[i - t][j] == 1) {\n\t\t\tH[i - t][j] = 0;\n\t\t\tres += solve(i - t, j, k - 1);\n\t\t\tH[i - t][j] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int t = 1; j + t < m; j++) {\n\t\tif (H[i][j + t] == 1) {\n\t\t\tH[i][j + t] = 0;\n\t\t\tres += solve(i, j + t, k - 1);\n\t\t\tH[i][j + t] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int t = 1; j - t >= 0; t++) {\n\t\tif (H[i][j - t] == 1) {\n\t\t\tH[i][j - t] = 0;\n\t\t\tres += solve(i, j - t, k - 1);\n\t\t\tH[i][j - t] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint cnt = 0;\n\t\trep(i, n) {\n\t\t\trep(j, m) {\n\t\t\t\tscanf(\"%d\", &H[i][j]);\n\t\t\t\tif (H[i][j] == 1)cnt++;\n\t\t\t\tif (H[i][j] == 2) { I = i; J = j; }\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(I, J, cnt));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint n, m, field[11][11], si, sj, num;\n\nint dfs(int x, int y){\n  int ans = 0;\n  if(num == 0){\n    if(x == si || y == sj)return 1;\n    else return 0;\n  }\n  field[x][y] = 0;\n  for(int i = x + 1;i < m;i++){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  } \n  for(int i = x - 1;i >= 0;i--){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  } \n  for(int i = y + 1;i < n;i++){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  } \n  for(int i = y - 1;i >= 0;i--){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  }  \n  field[x][y] = 1;\n  return ans;\n}\n\nint main(){\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 0;i < m;i++){\n    for(int j = 0;j < n;j++){\n      scanf(\"%d\", &field[i][j]);\n      if(field[i][j] == 2){\n\tsi = i;\n\tsj = j;\n      }\n      else num += field[i][j];\n    }\n  }\n  printf(\"%d\\n\", dfs(si, sj));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint h, w;\nint a[10][10], c[24], b[10][10];\nint o[4];\nint dp[23][8388609], l, k;\nint solve(int i, int j, int s) {\n\tif (s == l) {\n\t\tfor (int x = 0; x < k; x++) {\n\t\t\tif (o[x] == b[i][j]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint sum = 0;\n\tfor (int x = i + 1; x < h; x++) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\ta[x][j] = 3;\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\ta[x][j] = 1;\n\t\t}\n\t}\n\tfor (int x = i - 1; x>=0; x--) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\ta[x][j] = 3;\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\ta[x][j] = 1;\n\t\t}\n\t}\n\tfor (int y = j + 1; y < w; y++) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\ta[i][y] = 3;\n\t\t\tif (dp[d][s | c[d]] == -1)\n\t\t\t\tdp[d][s | c[d]] = solve(i, y, s | c[d]);\n\t\t\tsum += dp[d][s | c[d]];\n\t\t\ta[i][y] = 1;\n\t\t}\n\t}\n\tfor (int y = j - 1; y >= 0; y--) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\ta[i][y] = 3;\n\t\t\tif (dp[d][s | c[d]] == -1)\n\t\t\t\tdp[d][s | c[d]] = solve(i, y, s | c[d]);\n\t\t\tsum += dp[d][s | c[d]];\n\t\t\ta[i][y] = 1;\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> w >> h&&w != 0 && h != 0) {\n\t\tint x, y;\n\t\tl = 0;\n\t\tint sum = 0;\n\t\tk = 1;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) {\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t}\n\t\t\t\tif (a[i][j]) {\n\t\t\t\t\tc[sum] = k;\n\t\t\t\t\tb[i][j] = sum;\n\t\t\t\t\tsum++;\n\t\t\t\t\tl += k;\n\t\t\t\t\tk *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < sum; i++) {\n\t\t\tfor (int j = 0; j <= l; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tsum = 0;\n\t\tk = 0;\n\t\tfor (int i = x+1; i < h; i++) {\n\t\t\tif (a[i][y]) {\n\t\t\t\to[k] = b[i][y];\n\t\t\t\tk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = x-1; i >= 0; i--) {\n\t\t\tif (a[i][y]) {\n\t\t\t\to[k] = b[i][y];\n\t\t\t\tk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = y+1; i < w; i++) {\n\t\t\tif (a[x][i]) {\n\t\t\t\to[k] = b[x][i];\n\t\t\t\tk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = y - 1; i >= 0; i--) {\n\t\t\tif (a[x][i]) {\n\t\t\t\to[k] = b[x][i];\n\t\t\t\tk++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << solve(x, y, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <unordered_map>\n\ntypedef std::pair<int,int> P;\n\ntemplate <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n  std::hash<T> hasher;\n  seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n\nnamespace std\n{\n  template<typename S, typename T> struct hash<pair<S, T>>\n  {\n    inline size_t operator()(const pair<S, T> & v) const\n    {\n      size_t seed = 0;\n      ::hash_combine(seed, v.first);\n      ::hash_combine(seed, v.second);\n      return seed;\n    }\n  };\n}\n\nint M, N; // X, Y\nint map[10][10];\nint xs[24], ys[24], n;\nstd::unordered_map<P, int> dp;\n\nbool can(int pos, int pos2, int state){\n    if(xs[pos] != xs[pos2] && ys[pos] != ys[pos2]){return false;}\n\n    if(xs[pos] == xs[pos2]){\n        if(ys[pos] > ys[pos2]){std::swap(pos, pos2);}\n        for(int i=0;i<n;i++){\n            if(i == pos || i == pos2){continue;}\n            if((state >> i & 1) &&\n               xs[i] == xs[pos] && \n               ys[pos] < ys[i] && ys[i] < ys[pos2]){\n                return false;\n            }\n        }\n    }else{\n        if(xs[pos] > xs[pos2]){std::swap(pos, pos2);}\n        for(int i=0;i<n;i++){\n            if(i == pos || i == pos2){continue;}\n            if((state >> i & 1) &&\n               ys[i] == ys[pos] &&\n               xs[pos] < xs[i] && xs[i] < xs[pos2]){\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint rec(int pos, int state){\n    P p = std::make_pair(pos, state);\n    if(dp.count(p) > 0){return dp[p];}\n    \n    int count = __builtin_popcount(state);\n    if(count == n-1){\n        return can(pos, 0, state);\n    }\n\n    int res = 0;\n    for(int i=1;i<n;i++){\n        if(!(state >> i & 1) && can(pos, i, state)){\n            res += rec(i, state | (1 << i));\n        }\n    }\n\n    return dp[p] = res;\n}\n\nint main(){\n    while(scanf(\"%d %d\", &M, &N), M){\n        n = 1;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                scanf(\"%d\", &map[i][j]);\n\n                if(map[i][j] == 1){xs[n] = j; ys[n++] = i;}\n                else if(map[i][j] == 2){xs[0] = j; ys[0] = i;}\n            }\n        }\n\n        printf(\"%d\\n\", rec(0, 0));\n\n        dp.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint dp[1<<23][23]; //ここまで、現在地\nbool already[1<<23][23] = {};\nvector<pair<int,int> > house;\nvector<pair<int,int>> way[23];\n\nint solve(int i, int j){\n\tif(already[i][j]) return dp[i][j];\n\tint ans = 0;\n\tif((i&(1<<j)) == 0) return 0;\n\tbool flg = true;\n\tfor(int k=way[j].size()-1; k>=0; k--){\n\t\tif(way[j][k] == MP(-1,-1)){\n\t\t\tflg = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(flg == false) continue;\n\t\tif((i&way[j][k].second) == way[j][k].second && (i&(1<<way[j][k].first)) == 0){\n\t\t\tans += solve(i+(1<<way[j][k].first), way[j][k].first);\n\t\t\tflg = false;\n\t\t}\n\t}\n\t//already[i][j] = true;\n\t//dp[i][j] = ans;\n\treturn ans;\n}\n\nint main() {\n\tiostream::sync_with_stdio(false);\n\n\tSTART:\n\t\n\tint m,n;\n\tcin >> m >> n;\n\tif(n == 0 && m == 0) return 0;\n\tint a[10][10];\n\thouse.clear();\n\tpair<int,int> kyokai;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j] == 0) a[i][j] = -1; //空地\n\t\t\telse if(a[i][j] == 2){\n\t\t\t\ta[i][j] = -2; //教会\n\t\t\t\tkyokai = MP(i,j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i][j] = house.size();\n\t\t\t\thouse.push_back(MP(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\t//経路計算\n\tfor(int i=0; i<house.size(); i++){\n\t\tway[i].clear();\n\t\tint x = house[i].first;\n\t\tint y = house[i].second;\n\t\tint tmp = 0;\n\t\tfor(int j=x+1; j<n; j++){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=x-1; j>=0; j--){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=y+1; j<m; j++){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=y-1; j>=0; j--){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t}\n\n\t//教会隣接家dp初期化\n\tfor(int i=0; i<house.size(); i++){\n\t\tdp[(1<<house.size())-1][i] = 0;\n\t\talready[(1<<house.size())-1][i] = true;\n\t}\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t}\n\t}\n\n\tfor(int i=(1<<house.size())-2; i>=0; i--){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\talready[i][j] = false;\n\t\t}\n\t}\n\n\t/*\n\t//dp\n\tfor(int i=(1<<house.size())-2; i>=0; i--){ //2^23\n\t\tfor(int j=0; j<house.size(); j++){ //23\n\t\t\tdp[i][j] = 0;\n\t\t\tif((i&(1<<j)) == 0) continue;\n\t\t\tfor(int k=0; k<way[j].size(); k++){ //20\n\t\t\t\tif((i&way[j][k].second) == 0 && (i&(1<<way[j][k].first)) == 0){\n\t\t\t\t\tdp[i][j] += dp[i+(1<<way[j][k].first)][way[j][k].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t//最終的な答え\n\tint ans = 0;\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += solve(1<<a[i][kyokai.second],a[i][kyokai.second]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += solve(1<<a[i][kyokai.second],a[i][kyokai.second]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += solve(1<<a[kyokai.first][i],a[kyokai.first][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += solve(1<<a[kyokai.first][i],a[kyokai.first][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\tgoto START;\n\n\t/*\n\t//デバッグ\n\tfor(int i=0; i<house.size(); i++){\n\t\tfor(int j=0; j<way[i].size(); j++){\n\t\t\tcout << way[i][j].first << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tfor(int i=0; i<(1<<house.size()); i++){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint x,y;\nint sx,sy;\nint N;\nint hx[24],hy[24];\nint fie[12][12];\nint dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit,bool done[12][12],int home){\n\tif(memo[pos].find(bit)!=memo[pos].end())return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\t\twhile(fie[cx][cy]!=-1){\n\t\t\t\tif(fie[cx][cy]==100)return 1;\n\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\twhile(fie[cx][cy]==-2 || fie[cx][cy]==100 || done[cx][cy]==true){\n\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t}\n\t\tif(fie[cx][cy]!=-1){\n\t\t\tdone[cx][cy]=true;\n\t\t\tans+=dfs(fie[cx][cy] , bit | (1<<fie[cx][cy]), done,home+1);\n\t\t\tdone[cx][cy]=false;\n\t\t}\n\t}\n\tif(home<19)memo[pos][bit]=ans;\n\treturn ans;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tN=0;\n\t\tfor(int i=0;i<24;i++){\n\t\t\tmemo[i].clear();\n\t\t}\n\t\tfor(int i=0;i<12;i++){\n\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\tfie[j][i]=-1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfie[j][i]=-2;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tfie[j][i]=100;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==1){\n\t\t\t\t\tfie[j][i]=N;\n\t\t\t\t\thx[N]=j;\n\t\t\t\t\thy[N]=i;\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thx[N]=sx,hy[N]=sy;\n\t\tbool done[12][12];\n\t\tmemset(done,false,sizeof(done));\n\t\tcout << dfs(N,0,done,0) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<int,int> dp[24];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(__builtin_popcount(vis)<19 && dp[id][vis])return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)<19)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    for(int i=0;i<pn-1;i++)dp[i].clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(memo[MP(house_num,state)]==0&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn memo[MP(house_num,state)]+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nmap<P,int>ma;\nint f[15][15];\nint linkk[15][15];\nP za[25];\nint n,m;\nint val;\nint dp(int mask,int cur)\n{\n\tint ret=0;\n\tif(ma[mp(mask,cur)]) return ma[mp(mask,cur)];\n\tint x=za[cur].first;\n\tint y=za[cur].second;\n\tif(mask==(1<<val)-1)\n\t{\n\t\tif(x==za[23].first || y==za[23].second) return 1;\n\t\telse return 0;\n\t}\n\tfor(int i=x-1;i>=0;i--)\n\t{\n\t\tint s=linkk[i][y];\n\t\tif(f[i][y]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[i][y]),link[i][y]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=x+1;i<m;i++)\n\t{\n\t\tint s=linkk[i][y];\n\t\tif(f[i][y]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[i][y]),link[i][y]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=y-1;i>=0;i--)\n\t{\n\t\tint s=linkk[x][i];\n\t\tif(f[x][i]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[x][i]),link[x][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=y+1;i<n;i++)\n\t{\n\t\tint s=linkk[x][i];\n\t\tif(f[x][i]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[x][i]),link[x][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret) ma[mp(mask,cur)]=ret;\n\treturn ret;\n}\nint main(){\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tma.clear();\n\t\tif(!n) return 0;\n\t\tint num=0; val=0;\n\t\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++) { f[i][j]=INF; linkk[i][j]=-1;}\n\t\t\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j]==1) { linkk[i][j]=num; za[num++]=mp(i,j); val++;}\n\t\t\t\tif(f[i][j]==2) za[23]=mp(i,j);\n\t\t\t}\n\t\t\n\t\t}\n\t\tcout << dp(0,23) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<int, map<int, int>>dp;\n\t\tauto F = [&](int x, int y, int s, int r) {\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x, ny = y; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(r >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[r | 1 << dat[nx][ny]][dat[nx][ny]] += s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tF(sx, sy, 1, 0);\n\t\tint ans = 0;\n\t\trep(i, 1 << p) {\n\t\t\trep(j, p) {\n\t\t\t\tif (dp[i].find(j) == dp[i].end())continue;\n\t\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tF(x[j], y[j], dp[i][j], i);\n\t\t\t}\n\t\t\tdp.erase(i);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nint memo[1 << 23][23];\nstruct aa {\n\tint x;\n\tint y;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nvector<int>getdis(const int now, const vector<vector<int>>&field, const vector<pair<int, int>>&houses) {\n\tconst int sx = houses[now].first;\n\tconst int sy = houses[now].second;\n\t\n\tvector<vector<int>>cans(field.size(), vector<int>(field[0].size()));\n\tcans[sy][sx] = true;\n\tfor (int way = 0; way < 4; ++way) {\n\t\tint nx(sx);\n\t\tint ny(sy);\n\t\twhile (1) {\n\t\t\tnx += dx[way];\n\t\t\tny += dy[way];\n\t\t\tif (field[ny][nx]&&field[ny][nx]!=2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcans[ny][nx] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>times;\n\tfor (auto h : houses) {\n\t\ttimes.emplace_back(cans[h.second][h.first]);\n\t}\n\treturn times;\n}\nint getans(const int now, bitset<23>&used, vector<vector<int>>&field, const vector<pair<int, int>>&houses) {\n\tif (memo[used.to_ulong()][now] != -1)return memo[used.to_ulong()][now];\n\tif (used.count() == houses.size() - 1) {\n\t\tauto vs(getdis(now, field, houses));\n\t\treturn memo[used.to_ulong()][now] = vs.back();\n\t}\n\telse {\n\t\tint sum = 0;\n\t\tauto vs(getdis(now, field, houses));\n\t\tfor (int i = 0; i < houses.size()-1; ++i) {\n\t\t\tif (vs[i]&&!used[i]) {\n\t\t\t\tused[i] = true;\n\t\t\t\tfield[houses[i].second][houses[i].first] = true;\n\t\t\t\tconst int atime = getans(i, used, field, houses);\n\t\t\t\tsum += atime;\n\t\t\t\tfield[houses[i].second][houses[i].first] = false;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn memo[used.to_ulong()][now] = sum;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < (1 << 23); ++i) {\n\t\t\tfor (int j = 0; j < 23; ++j) {\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint M, N; cin >> M >> N;\n\t\tvector<vector<int>>field(N + 2, vector<int>(M + 2,3));\n\t\tvector<pair<int, int>>houses;\n\t\tpair<int, int>rit;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tcin >> field[i + 1][j + 1];\n\t\t\t\tif (field[i+1][j + 1] == 1) {\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\thouses.emplace_back(j+1, i+1);\n\t\t\t\t}\n\t\t\t\telse if (field[i + 1][j + 1] == 2) {\n\t\t\t\t\trit = make_pair(j+1, i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<23>used(0);\n\t\thouses.emplace_back(rit);\n\t\tint ans = getans(houses.size() - 1, used, field, houses);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int N = 25;\nconst int MEMO_LIM = (1<<21);\nbool adj[N][N];\nint up[N][N];\nint memo[MEMO_LIM][N];\nint n;\nvector<P> house;\n\nint near[N];\n\nvoid check(int an, int bn)\n{\n  P a = house[an];\n  P b = house[bn];\n  \n  if (a.first!=b.first && a.second!=b.second) {\n    return;\n  }\n\n  int st = 0;\n  if (a.second==b.second) {\n    int s = min(a.first, b.first);\n    int t = max(a.first, b.first);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].second!=a.second) continue;\n      int x = house[i].first;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n  else if (a.first==b.first) {\n    int s = min(a.second, b.second);\n    int t = max(a.second, b.second);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].first!=a.first) continue;\n      int x = house[i].second;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n\n  adj[an][bn] = adj[bn][an] = true;\n  up[an][bn] = up[bn][an] = st;\n}\n\nint f(int p, int st)\n{\n  if (p==n-1 && st==(1<<n)-1) {\n    return 1;\n  }\n  if (p==n-1 && st!=0) return 0;\n  \n  if (st < MEMO_LIM) {\n    if (memo[st][p]!=-1) {\n      return memo[st][p];\n    }\n  }\n\n  if ((st & near[n-1])==near[n-1]) {\n    if (st != (1<<(n-1))-1) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n  for (int i=0; i < n-1; ++i) {\n    if ((st & near[i])==near[i] && (st&(1<<i))==0) {\n      if (st < MEMO_LIM) {\n\tmemo[st][p] = 0;\n      }\n      return 0;\n    }\n  }\n\n  int res = 0;\n\n  for (int i=0; i < n; ++i) {\n    if (!(((st&(1<<i))>0)\n\t  ||(adj[p][i]==false)\n\t  ||(up[p][i] & st)>0)) {\n      res += f(i, (st|(1<<i)));\n    }\n  }\n  \n  if (st < MEMO_LIM) {\n    return memo[st][p] = res;\n  }\n  return res;\n}\n\nint main()\n{\n  int w, h;\n  while (cin>>w>>h) {\n    if (!w && !h) break;\n\n    fill(&adj[0][0], &adj[N-1][N], false);\n    fill(&up[0][0], &up[N-1][N], 0);\n\n    house.clear();\n    P ch;\n    for (int i=0; i < h; ++i) {\n      for (int j=0; j < w; ++j) {\n\tint val;\n\tcin >> val;\n\tif (val==1) {\n\t  house.push_back(P(i,j));\n\t}\n\telse if (val==2) {\n\t  ch = P(i,j);\n\t}\n      }\n    }\n\n    house.push_back(ch);\n\n    n = house.size();\n    for (int i=0; i < n; ++i) {\n      for (int j=i+1; j < n; ++j) {\n\tcheck(i, j);\n      }\n    }\n\n    for (int i=0; i < n; ++i) {\n      near[i] = 0;\n      for (int j=0; j < n; ++j) {\n\tif (adj[i][j] && up[i][j]==0) {\n\t  near[i] |= (1<<j);\n\t}\n      }\n    }\n\n    //memset(memo, sizeof(memo), 255);\n    int lim = min((1<<n),MEMO_LIM);\n    for (int i=0; i < lim; ++i) {\n      for (int j=0; j < n; ++j) {\n\tmemo[i][j] = -1;\n      }\n    }\n    //fill(&memo[0][0], &memo[MEMO_LIM-1][N], -1);\n    int ans = f(n-1, 0);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int bitmax = 1<<20;\n//bit????????????\nint dp[23][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\tif(bit<bitmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    if(ni==t.ni){\n      if(nj==t.nj){\n\treturn vis<t.vis;\n      }else return nj < t.nj;\n    }else return ni < t.ni;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  //set<state> visited;\n  qs.push( init );\n  //visited.insert(init);\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    //    bool bCont=false;\n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    \n    bool bCont=false;\n    for(int i = 0; i < MAX; ++i){\n      for(int j = 0; j < MAX; ++j){\n\tif( M[i][j].isHouse || M[i][j].isCharch ){\n\t  if( M[i][j].isHouse ){\n\t    if( st_now.vis&(1<<houseId[i][j]) ) continue;\n\t  }\n\t  bool frontofcharch=false;\n\t  int left=0;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    left+=M[i][j].link[k].size() + (M[i][j].cexist[k]?frontofcharch=true,1:0);\n\t    for(int v = 0; v < M[i][j].link[k].size(); ++v){\n\t      pi house = M[i][j].link[k][v];\n\t      if( st_now.vis&(1<<houseId[house.fr][house.sc]) )\n\t\t--left;\n\t    }\n\t  }\n\t  if( (left<=1&&!frontofcharch)||left==0){\n\t    //cout << i << ' ' << j << \" left : \" << left << endl;\n\t    bCont=true;break;\n\t  }\n\t}\n      }\n      if(bCont)break;\n    }\n    if(bCont)continue;\n    \n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.cnt++;\n\t    st_next.vis |= ( 1<<houseId[next.fr][next.sc] );\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nconst int B = 16;\nint dp[24][1 << B];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (idx == hs && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\tif (bits < 1 << B && ~dp[idx][bits]) return dp[idx][bits];\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(x, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\tif (bits < 1 << B)\n\t\treturn dp[idx][bits] = res;\n\telse return res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\ninline bool in(int x, int y, int w, int h)\n{\n\treturn x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint main()\n{\n\twhile(true) {\n\t\t\n\t\tint w, h, n;\n\t\tint field[16][16];\n\t\tvector<pair<int, int> > house;\n\t\tpair<int, int> church;\n\t\t\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif(t == 0) {\n\t\t\t\t\tt = -1;\n\t\t\t\t} else if(t == 1) {\n\t\t\t\t\tt = house.size();\n\t\t\t\t\thouse.push_back(make_pair(x, y));\n\t\t\t\t} else if(t == 2) {\n\t\t\t\t\tt = -2;\n\t\t\t\t\tchurch = make_pair(x, y);\n\t\t\t\t}\n\t\t\t\tfield[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tn = house.size();\n\t\t\n\t\tint reach[23][23];\n\t\tvector<int> from[23];\n\t\tint dx[] = {-1, 0, 0, 1}, dy[] = {0, -1, 1, 0};\n\t\tmap<pair<int, int>, int> dp;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tdp[make_pair(1 << tgt, tgt)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int a = 0; a < n; ++a) {\n\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\n\t\t\t\tif(a == b)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\treach[a][b] = (1 << a) | (1 << b);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\t\n\t\t\t\t\tint cx = house[a].first, cy = house[a].second;\n\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tint t = field[cx][cy];\n\t\t\t\t\t\tif(t == b) {\n\t\t\t\t\t\t\treach[a][b] = bit;\n\t\t\t\t\t\t\tfrom[a].push_back(b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(t >= 0) {\n\t\t\t\t\t\t\tbit |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 1; bit < (1 << n); ++bit) {\n\t\t\t\n\t\t\tfor(int a = 0; a < n; ++a) {\n\t\t\t\t\n\t\t\t\tif((bit & (1 << a)) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint prev = bit ^ (1 << a);\n\t\t\t\t\n\t\t\t\tfor(int bi = 0; bi < from[a].size(); ++bi) {\n\t\t\t\t\t\n\t\t\t\t\tint b = from[a][bi];\n\t\t\t\t\t\n\t\t\t\t\tif(((prev & (1 << b)) != 0) & ((prev & reach[a][b]) == 0)) {\n\t\t\t\t\t\n\t\t\t\t\t\tmap<pair<int, int>, int>::iterator it = dp.find(make_pair(prev, b));\n\t\t\t\t\t\tif(it != dp.end())\n\t\t\t\t\t\t\tdp[make_pair(bit, a)] += it->second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tans += dp[make_pair((1 << n) - 1, tgt)];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;}\n  bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n    /**/\n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    \n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !st_now.checkvis( houseId[next.fr][next.sc] ) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.setvis( houseId[next.fr][next.sc] );\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1}; //u,r,d,l\nconst int dy[] = {-1,0,1,0};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool ischeck(int s){\n  return (((last&s)) == last) ;\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( ischeck(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    if(ni==t.ni){\n      if(nj==t.nj){\n\treturn vis<t.vis;\n      }else return nj < t.nj;\n    }else return ni < t.ni;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n    \n    //cout << \"CNT: \" << (int)st_now.cnt << endl;\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    if( st_now.cnt >= 0 ){\n      int left = 0;\n      int chi=charch.fr;int chj=charch.sc;\n      for(int k = 0; k < MAXDIR; ++k){\n\tleft += M[chi][chj].link[k].size();\n      }\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n    }\n\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.cnt++;\n\t    st_next.vis |= ( 1<<houseId[next.fr][next.sc] );\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define MAX 12\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint dp[(1<<18)][23];\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n\tif(housInd[ny][nx] != -1 && bit < (1 << 18) && dp[bit][housInd[ny][nx]] != -1)\n\t\treturn dp[bit][housInd[ny][nx]];\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[bit][housInd[ny][nx]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((bit & 1 << ind) != 0) break;\n\t\t\t\tif (!isLast)ret += func(y, x, bit | (1 << ind));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn housInd[ny][nx] != -1 && bit < (1 << 18) ? (dp[bit][housInd[ny][nx]] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\nint w,h;\nint map[10][10];\nbool passed[10][10];\nint gx,gy;\nint count_max;\nint func(int x,int y, int count)\n{\n\tif(count>0)\n\t{\n\t\t#ifdef DEBUG\n\t\t//std::cout << \"IN:\"<<x<<' '<<y<<' '<<count<<'\\n';\n\t\t#endif\n\t\tif(x==gx&&y==gy){return 0;}\n\t\tif(count==count_max){\n\t\t\tauto DP = [&](){};//{std::cout <<x<<' '<<y<<'\\n'; };\n\t\t\tfor(int nx = 0;nx<w;++nx){\n\t\t\t\tif(map[nx][y]==2){DP();return 1;}\n\t\t\t}\n\t\t\tfor(int ny = 0;ny<h;++ny){\n\t\t\t\tif(map[x][ny]==2){DP();return 1;}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tpassed[x][y]=true;\n\t}\n\tint res = 0;\n\tfor(int nx = x-1;nx>=0;--nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int nx = x+1;nx<w;++nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y-1;ny>=0;--ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y+1;ny<h;++ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpassed[x][y]=false;\n\treturn res;\n}\n\nint main()\n{\n\tfor(;;){\n\tstd::cin >> w>>h;if(w==0&&h==0){break;}\n\tcount_max=0;\n\tfor(int y=0;y<h;++y)for(int x=0;x<w;++x){\n\t\tstd::cin >> map[x][y];\n\t\tif(map[x][y]==1){++count_max;}\n\t\tif(map[x][y]==2){gx=x;gy=y;}\n\t}\n\t//std::cout << \"a:\"<<gx<<' '<<gy<<' '<<count_max<<'\\n';\n\t\n\tint res = 0;\n\tstd::cout << func(gx,gy,0)<<std::endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nconst int B = 20;\nint dp[24][1 << B];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (idx == hs && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\tif (bits < 1 << B && ~dp[idx][bits]) return dp[idx][bits];\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(x, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\tif (bits < 1 << B)\n\t\treturn dp[idx][bits] = res;\n\telse return res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, C, sx, sy; vector<vector<int> > M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint solve(int x, int y, int d, vector<vector<bool> > used)\n{\n\tif (d == C && x == sx && y == sy) { return 1; }\n\n\tint ret = 0;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint x2 = x + dx[dir];\n\t\tint y2 = y + dy[dir];\n\n\t\twhile (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t{\n\t\t\tif (used[y2][x2])\n\t\t\t{\n\t\t\t\tvector<vector<bool> > used2(used.begin(), used.end()); used2[y2][x2] = false;\n\n\t\t\t\tret += solve(x2, y2, d + 1, used2); break;\n\t\t\t}\n\t\t\t\n\t\t\tx2 += dx[dir];\n\t\t\ty2 += dy[dir];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &W);\n\tscanf(\"%d\", &H);\n\n\tM = vector<vector<int> >(H, vector<int>(W));\n\n\tvector<vector<bool> > start(H, vector<bool>(W, false));\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tscanf(\"%d\", &M[i][j]);\n\n\t\t\tif (M[i][j] != 0) { C++; start[i][j] = true; }\n\n\t\t\tif (M[i][j] == 2) { sx = j; sy = i; }\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", solve(sx, sy, 0, start));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   (a >> b) & 1\n#define bitset(a,b)       a |= (1 << b)\n#define bitunset(a,b)    a &= ~(1 << b)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w,h;\n\twhile (scanf(\"%d %d\", &w, &h)) {\n\t\tif (!w && !h)\n\t\t\tbreak;\n\t\tvector<vector<int>> mp(w, vector<int>(h, -1));\n\t\tpii cha;\n\t\tvector<pii> homp;\n\t\tint homc = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tint a = 0;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tif (a == 2) {\n\t\t\t\t\tcha = { j,i };\n\t\t\t\t}\n\t\t\t\tif (a == 1) {\n\t\t\t\t\thomp.push_back({ j,i });\n\t\t\t\t\tmp[j][i] = homc;\n\t\t\t\t\thomc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thomp.push_back(cha);\n\t\tmap<pii, char> dp[2];//?±\\??´????????¨??°\n\t\tdp[0][{0, homc}] = 1;\n\t\tbool t = 0;\n\t\tREP(i, homc) {\n\t\t\tfor (auto cur : dp[t]) {\n\t\t\t\tpii curpos = homp[cur.first.second];\n\t\t\t\tint cnum;\n\t\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[t].clear();\n\t\t\tt = 1 - t;\n\t\t}\n\t\tint cnum, ans = 0;\n\t\tset<int> targets;\n\t\tfor (int j = cha.first; w > j; j++) {\n\t\t\tcnum = mp[j][cha.second];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.first; 0 <= j; j--) {\n\t\t\tcnum = mp[j][cha.second];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; h > j; j++) {\n\t\t\tcnum = mp[cha.first][j];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; 0 <= j; j--) {\n\t\t\tcnum = mp[cha.first][j];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (auto cur : dp[t]) {\n\t\t\tif (targets.find(cur.first.second) != targets.end())\n\t\t\t\tans += cur.second;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint m[10][10];\nint R;\nint C;\nint a,b;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint solve(int s,int t,int u){\n\tif(u==0){\n\t\tif(s==R||t==C)return 1;\n\t\telse return 0;\n\t}\n\tint ret=0;\n\tfor(int i=0;i<4;i++){\n\t\tint row=s;\n\t\tint col=t;\n\t\twhile(1){\n\t\t\trow+=dx[i];\n\t\t\tcol+=dy[i];\n\t\t\tif(row<0||col<0||row>=a||col>=b)break;\n\t\t\tif(m[row][col]==1){\n\t\t\t\tm[row][col]=3;\n\t\t\t\tret+=solve(row,col,u-1);\n\t\t\t\tm[row][col]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tint c=0;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tscanf(\"%d\",&m[i][j]);\n\t\t\t\tif(m[i][j]==1)c++;\n\t\t\t\tif(m[i][j]==2){R=i;C=j;}\n\t\t\t}\n\t\tprintf(\"%d\\n\",solve(R,C,c));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint h,w;\nint a[12][12];\n\nint pre_h[12][12];\nint nex_h[12][12];\nint pre_w[12][12];\nint nex_w[12][12];\n\nint dfs(int x,int y,int d,int k,int t){\n\tif(k == 0){\n\t\tif(a[x][y] == 2){\n\t//printf(\"dfs(%d,%d,%d,%d)=\",x,y,d,k);\n\t\t\t//puts(\"1\");\n\t\t\treturn 1;\n\t\t}\n\t//printf(\"dfs(%d,%d,%d,%d)=\",x,y,d,k);\n\t\t//puts(\"0\");\n\t\treturn 0;\n\t}\n\tif(d == -1){\n\t\tif(a[x][y] == 2 && t == 0)return 0;\n\t\tint ret = 0;\n\t\t//int memo[4] = { nex_h[x][y] , pre_h[x][y] , nex_w[x][y] , pre_w[x][y] };\n\t\tif(a[x][y] == 1 && nex_h[x][y] != 0)pre_h[x+nex_h[x][y]][y] = 0;\n\t\tif(a[x][y] == 1 && pre_h[x][y] != 0)nex_h[x+pre_h[x][y]][y] = 0;\n\t\tif(a[x][y] == 1 && nex_w[x][y] != 0)pre_w[x][y+nex_w[x][y]] = 0;\n\t\tif(a[x][y] == 1 && pre_w[x][y] != 0)nex_w[x][y+pre_w[x][y]] = 0;\n\t\tif(nex_h[x][y] != 0)ret += dfs(x+nex_h[x][y],y,0,k-1,0);\n\t\tif(pre_h[x][y] != 0)ret += dfs(x+pre_h[x][y],y,1,k-1,0);\n\t\tif(nex_w[x][y] != 0)ret += dfs(x,y+nex_w[x][y],2,k-1,0);\n\t\tif(pre_w[x][y] != 0)ret += dfs(x,y+pre_w[x][y],3,k-1,0);\n\t\tif(a[x][y] == 1 && nex_h[x][y] != 0)pre_h[x+nex_h[x][y]][y] = -nex_h[x][y];\n\t\tif(a[x][y] == 1 && pre_h[x][y] != 0)nex_h[x+pre_h[x][y]][y] = -pre_h[x][y];\n\t\tif(a[x][y] == 1 && nex_w[x][y] != 0)pre_w[x][y+nex_w[x][y]] = -nex_w[x][y];\n\t\tif(a[x][y] == 1 && pre_w[x][y] != 0)nex_w[x][y+pre_w[x][y]] = -pre_w[x][y];\n\t\t//printf(\"%d=%d %d=%d %d=%d %d=%d\\n\", memo[0] , nex_h[x][y] , memo[1] , pre_h[x][y] , memo[2] , nex_w[x][y] , memo[3] , pre_w[x][y]);\n\t\t//printf(\"dfs(%d,%d,%d,%d)=\",x,y,d,k);\n\t\t//printf(\"%d\\n\",ret);\n\t\treturn ret;\n\t}\n\tint ret = 0;\n\tret += dfs(x,y,-1,k,0);\n\tif(d == 0){\n\t\tif(nex_h[x][y] != 0)ret += dfs(x+nex_h[x][y],y,0,k,0);\n\t}\n\telse if(d == 1){\n\t\tif(pre_h[x][y] != 0)ret += dfs(x+pre_h[x][y],y,1,k,0);\n\t}\n\telse if(d == 2){\n\t\tif(nex_w[x][y] != 0)ret += dfs(x,y+nex_w[x][y],2,k,0);\n\t}\n\telse if(d == 3){\n\t\tif(pre_w[x][y] != 0)ret += dfs(x,y+pre_w[x][y],3,k,0);\n\t}\n\t//printf(\"dfs(%d,%d,%d,%d)=\",x,y,d,k);\n\t//printf(\"%d\\n\",ret);\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d%d\",&w,&h);\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t}\n\t\n\trep(i,12){\n\t\tint memo = -1;\n\t\trep(j,12){\n\t\t\tif(a[i][j] != 0){\n\t\t\t\tif(memo != -1){\n\t\t\t\t\tnex_w[i][memo] = j-memo;\n\t\t\t\t\tpre_w[i][j] = memo-j;\n\t\t\t\t}\n\t\t\t\tmemo = j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(j,12){\n\t\tint memo = -1;\n\t\trep(i,12){\n\t\t\tif(a[i][j] != 0){\n\t\t\t\tif(memo != -1){\n\t\t\t\t\tnex_h[memo][j] = i-memo;\n\t\t\t\t\tpre_h[i][j] = memo-i;\n\t\t\t\t}\n\t\t\t\tmemo = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep(i,12){\n\t\trep(j,12){\n\t\t\tprintf(\"%d \",nex_h[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\trep(i,12){\n\t\trep(j,12){\n\t\t\tprintf(\"%d \",pre_h[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\trep(i,12){\n\t\trep(j,12){\n\t\t\tprintf(\"%d \",nex_w[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\trep(i,12){\n\t\trep(j,12){\n\t\t\tprintf(\"%d \",pre_w[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tint cnt = 0;\n\tint x,y;\n\t\n\trep(i,12){\n\t\trep(j,12){\n\t\t\tif(a[i][j] == 1)cnt ++;\n\t\t\tif(a[i][j] == 2){\n\t\t\t\tx = i; y = j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",dfs(x,y,-1,cnt+1,1));\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[12][12],ex[4],ey[4],sx,sy,m,n;\nint fn(int x,int y,int p,int q){\n  int i;\n  int ct=0;\n  if(x==sx||y==sy){\n    for(i=0;i<m;i++){\n      if(x==ex[i]&&y==ey[i])\n\tbreak;\n    }\n    if(i!=m)\n      q++;\n  }\n  if(p==n){\n    if(y==sy){\n      for(i=1;a[x+i][y]!=-1;i++){\n\tif(x+i==sx&&y==sy)\n\t  ct=1;\n      }\n      for(i=1;a[x-i][y]!=-1;i++){\n\tif(x-i==sx&&y==sy)\n\t  ct=1;\n      }\n    }\n    if(x==sx){\n      for(i=1;a[x][y+i]!=-1;i++){\n\tif(x==sx&&y+i==sy)\n\t  ct=1;\n      }\n      for(i=1;a[x][y-i]!=-1;i++){\n\tif(x==sx&&y-i==sy)\n\t  ct=1;\n      }\n    }\n  }else if(q!=m){\n    for(i=1;a[x+i][y]!=-1;i++){\n      if(a[x+i][y]==1){\n\ta[x+i][y]=-1;\n\tct+=fn(x+i,y,p+1,q);\n\ta[x+i][y]=1;\n      }\n    }\n    for(i=1;a[x-i][y]!=-1;i++){\n      if(a[x-i][y]==1){\n\ta[x-i][y]=-1;\n\tct+=fn(x-i,y,p+1,q);\n\ta[x-i][y]=1;\n      }\n    }\n    for(i=1;a[x][y+i]!=-1;i++){\n      if(a[x][y+i]==1){\n\ta[x][y+i]=-1;\n\tct+=fn(x,y+i,p+1,q);\n\ta[x][y+i]=1;\n      }\n    }\n    for(i=1;a[x][y-i]!=-1;i++){\n      if(a[x][y-i]==1){\n\ta[x][y-i]=-1;\n\tct+=fn(x,y-i,p+1,q);\n\ta[x][y-i]=1;\n      }\n    }\n  }\n  return ct;\n}\nint main(){\n  int i,j;\n  int w,h;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    n=0;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>a[j][i];\n\tif(0){\n\t}else if(a[j][i]==1){\n\t  n++;\n\t}else if(a[j][i]==2){\n\t  a[j][i]=0;\t  \n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    memset(ex,-1,sizeof(ex));\n    memset(ey,-1,sizeof(ey));\n    m=0;\n    for(i=1;a[sx+i][sy]!=-1&&a[sx+i][sy]!=1;i++);\n    if(a[sx+i][sy]==1){\n      ex[m]=sx+i;\n      ey[m]=sy;\n      m++;\n    }\n    for(i=1;a[sx-i][sy]!=-1&&a[sx-i][sy]!=1;i++);\n    if(a[sx-i][sy]==1){\n      ex[m]=sx-i;\n      ey[m]=sy;\n      m++;\n    }\n    for(i=1;a[sx][sy+i]!=-1&&a[sx][sy+i]!=1;i++);\n    if(a[sx][sy+i]==1){\n      ex[m]=sx;\n      ey[m]=sy+i;\n      m++;\n    }\n    for(i=1;a[sx][sy-i]!=-1&&a[sx][sy-i]!=1;i++);\n    if(a[sx][sy-i]==1){\n      ex[m]=sx;\n      ey[m]=sy-i;\n      m++;\n    }\n    cout<<fn(sx,sy,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nvector<int> g[24][4]; // 0?????????, ??????????????¶????????????\nint maps[10][10];\nint m, n;\nint cnt;\n\ntypedef pair<int, int> pii;\n\nint main() {\n\twhile (cin >> m >> n, m || n) {\n\t\tREP(i, 24) REP(j, 4) g[i][j].clear();\n\t\n\t\tREP(i, n) REP(j, m) scanf(\"%d\", &maps[i][j]);\n\t\t\n\t\t\n\t\tcnt = 1;\n\t\tREP(i, n) {\n\t\t\tREP(j, m) {\n\t\t\t\tint tmp = -1;\n\t\t\t\tswitch(maps[i][j]) {\n\t\t\t\t\tcase 1: tmp = cnt++; break;\n\t\t\t\t\tcase 2: tmp = 0; break;\n\t\t\t\t}\n\t\t\t\tmaps[i][j] = tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, n) REP(j, m) {\n\t\t\tint from = maps[i][j];\n\t\t\tif (from != -1) {\n\t\t\t\tint tmp = 0;\n\t\t\t\tREP(k, n) if (maps[k][j] != -1) {\n\t\t\t\t\tif (k == i) {tmp++; continue;}\n\t\t\t\t\tg[from][tmp].push_back(maps[k][j]);\n\t\t\t\t}\n\t\t\t\ttmp = 2;\n\t\t\t\tREP(k, m) if (maps[i][k] != -1) {\n\t\t\t\t\tif (k == j) {tmp++; continue;}\n\t\t\t\t\tg[from][tmp].push_back(maps[i][k]);\n\t\t\t\t}\n\t\t\t\treverse(g[from][0].begin(), g[from][0].end());\n\t\t\t\treverse(g[from][2].begin(), g[from][2].end());\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<int, int> now[24]; // [?????¨?????????][?????????????????¶?????¶???] = ????????????????????°\n\t\tnow[0][0] = 1;\n\t\t\n\t\tint ans = 0;\n\t\tREP(i, cnt) {\n\t\t\tmap<int, int> next[24];\n\t\t\tREP(j, cnt) {\n\t\t\t\tfor (map<int, int>::iterator it = now[j].begin(); it != now[j].end(); ++it) {\n\t\t\t\t\tint bit = (*it).first;\n\t\t\t\t\t\n\t\t\t\t\tREP(k, 4) REP(l, g[j][k].size()) {\n\t\t\t\t\t\tint nextPos = g[j][k][l];\n\t\t\t\t\t\tint nextBit = bit | (1<<nextPos);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((bit >> nextPos) & 1) continue;\n\t\t\t\t\t\tif (nextPos == 0 && nextBit != (1<<cnt) - 1) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tnext[nextPos][nextBit] += (*it).second;\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, cnt) now[j] = next[j];\n\t\t}\n\t\t\n\t\tcout << now[0][(1<<cnt)-1] << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint H[10][10];\nint hx[24], hy[24];\nint dp[1 << 24][24];\n\n\nint main() {\n\tint m, n, cnt = 1;\n\tscanf(\"%d%d\", &m, &n);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tint h; scanf(\"%d\", &h);\n\t\t\tH[i][j] = -1;\n\t\t\tif (h == 1) {\n\t\t\t\thx[cnt] = i; hy[cnt] = j;\n\t\t\t\tH[i][j] = cnt++;\n\t\t\t}\n\t\t\tif (h == 2) { H[i][j] = 0; hx[0] = i; hy[0] = j; }\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\trep(i, 1 << cnt) {\n\t\trep(j, cnt) {\n\t\t\tif (!dp[i][j])continue;\n\t\t\tif ((i | j) && !((i >> j) & 1))continue;\n\t\t\tint x = hx[j], y = hy[j];\n\t\t\tfor (int k = 1; x + k < n; k++) {\n\t\t\t\tif (~H[x + k][y]) {\n\t\t\t\t\tif ((i >> H[x + k][y]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x + k][y])][H[x + k][y]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; x - k >= 0; k++) {\n\t\t\t\tif (~H[x - k][y]) {\n\t\t\t\t\tif ((i >> H[x - k][y]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x - k][y])][H[x - k][y]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; y + k < m; k++) {\n\t\t\t\tif (~H[x][y + k]) {\n\t\t\t\t\tif ((i >> H[x][y + k]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x][y + k])][H[x][y + k]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; y - k >= 0; k++) {\n\t\t\t\tif (~H[x][y - k]) {\n\t\t\t\t\tif ((i >> H[x][y - k]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x][y - k])][H[x][y - k]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[(1 << cnt) - 1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint solve();\nint road(pair<int,int> now,int bit,vector<pair<int,int> > vec,int visit);\nbool able();\n\nint M,N;\nint field[20][20];\nint H;\npair<int,int> SG;\n//int mem[100][9000000] = {0};\n\nint main()\n{\n    while(scanf(\"%d%d\",&M,&N),N + M)\n    {\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < M; j++)\n            {\n                scanf(\"%d\",&field[i][j]);\n            }\n        }\n        printf(\"%d\\n\",solve());\n    }\n    return 0;\n}\n\nbool able(pair<int,int> now,pair<int,int> to,int visit[20][20])\n{\n    if(now.first == to.first)\n    {\n        int l = min(now.second,to.second),r = max(now.second,to.second);\n        for(int i = l + 1; i < r + 1; i++)\n        {\n            if(i == r)return true;\n            if(visit[now.first][i] == 1)return false;\n        }\n    }\n    if(now.second == to.second)\n    {\n        int l = min(now.first,to.first),r = max(now.first,to.first);\n        for(int i = l + 1; i < r + 1; i++)\n        {\n            if(i == r)return true;\n            if(visit[i][now.second] == 1)return false;\n        }\n    }\n    return false;\n}\n\nint road(pair<int,int> now,int bit,vector<pair<int,int> > vec,int visit[20][20])\n{\n    int new_visit[20][20];\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < M; j++)\n        {\n            new_visit[i][j] = visit[i][j];\n        }\n    }\n    if(bit == (1 << H) - 1)\n    {\n        if(able(now,SG,new_visit))return 1;\n    }\n    int SUM = 0;\n    for(int i = 0; i < H; i++)\n    {\n        if(!(bit & (1 << i)))\n        {\n            if(able(now,vec[i],new_visit))\n            {\n                new_visit[vec[i].first][vec[i].second] = 1;\n                SUM += road(vec[i],bit | (1 << i),vec,new_visit);\n                new_visit[vec[i].first][vec[i].second] = 0;\n            }\n        }\n    }\n    return SUM;\n}\n\nint solve()\n{\n    H = 0;\n    vector<pair<int,int> > vec;\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < M; j++)\n        {\n            if(field[i][j] == 1)\n            {\n                vec.push_back(make_pair(i,j));\n                H++;\n            }\n            if(field[i][j] == 2)\n            {\n                SG = make_pair(i,j);\n            }\n        }\n    }\n    int visit[20][20] = {0};\n    return road(SG,0,vec,visit);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\nmap<int,int> msi;\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  map<int,int>::iterator it = msi.lower_bound(S);\n  if( it!=msi.end() && it->first == S ){ //ùÉÊÁ½óÔ\n    return it->second;\n  }\n\n  // v[gªu¯È¢ÆÌL³\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  //if( it!=msi.end() )--it;\n  msi.insert(it, make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <bitset>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nvector<int> hx,hy;\nint sx,sy;\nint num;\n\nbool C1(int S, int x1, int x2, int y) {\n  REP(j, num)\n    if ((1<<j)&S && hy[j] == y && (x1<hx[j]&&hx[j]<x2 || x2<hx[j]&&hx[j]<x1))\n      return false;\n  return true;\n}\nbool C2(int S, int x1, int x2, int y) {\n  REP(j, num)\n    if ((1<<j)&S && hx[j] == y && (x1<hy[j]&&hy[j]<x2 || x2<hy[j]&&hy[j]<x1))\n      return false;\n  return true;\n}\nmap<int, int> visited;//[1<<23][10][10];\n\nint rec(int S, int nx, int ny) {\n  // int nest = 0;\n  // REP(i,num) {\n  //   if ((S>>i) & 1)\n  //     nest++;\n  // }\n  // cout << string(nest,' ');\n  // cout << bitset<7>(S) << \" \" << nx << \" \"<<ny << endl;\n  \n  if (visited.count(S*100+nx*10+ny)) {\n    // cout << \"VISITED\" << endl;\n    return visited[S*100+nx*10+ny];\n  }\n  if (S == (1<<num) - 1) {\n    if (sy == ny && C1(S, sx, nx, ny) || sx == nx && C2(S, sy, ny, nx))\n      return 1;\n    else\n      return 0;\n  }\n  int res  = 0;\n  REP(i, num) {\n    if ((1<<i)&S) continue;\n    if (hy[i] == ny && C1(S, hx[i], nx, ny) || hx[i] == nx && C2(S, hy[i], ny, nx))\n      res += rec(S|(1<<i), hx[i], hy[i]);\n  }\n  return visited[S*100+nx*10+ny] = res;\n}\n\nint main() {\n  int m, n;\n  while(cin>>m>>n,m||n) {\n    hx.clear();hy.clear();\n    REP(i,n) {\n      REP(j,m) {\n        int a;\n        cin >> a;\n        if (a==1) {\n          hx.push_back(j);\n          hy.push_back(i);\n        } else if (a == 2) {\n          sx=j;sy=i;\n        }\n      }\n    }\n    num = hx.size();\n    cout << rec(0, sx, sy) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//--------------------------------------------------\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<sstream>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<ctime>\n\nusing namespace std;\n\n//conversion\n//--------------------------------------------------\ninline int toInt(const string &s){\n    int v;istringstream sin(s);sin>>v;\n    return v;\n}\ntemplate<class T> inline string toString(T x){\n    ostringstream sout;sout<<x;\n    return sout.str();\n}\n\n//math\n//--------------------------------------------------\ntemplate<class T> inline T sqr(T x){return x*x;}\n\n//typedef\n//--------------------------------------------------\ntypedef vector<int>VI;\ntypedef vector<VI>VVI;\ntypedef vector<string>VS;\ntypedef pair<int,int>PII;\ntypedef long long LL;\n\n//container util\n//--------------------------------------------------\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define EXIST(s) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//--------------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------------\nconst int INF=1e9+7;\nconst int dx[]={0,-1,0,1};\nconst int dy[]={-1,0,1,0};\n\n//clear memory\n#define CLR(a) memset((a),0,sizeof(a))\n\n//debug\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\"(L\"<<__LINE__<<\")\"<<endl\n\n//---------------------------------------------------\n\n\n\nclass State{\npublic:\n    int x,y;\n    bool p[24];\n    State(){\n        fill(p,p+24,false);\n    }\n    bool operator<(const State &s)const{\n        if(x!=s.x)return x<s.x;\n        if(y!=s.y)return y<s.y;\n        REP(i,24)if(p[i]!=s.p[i])return p[i]<s.p[i];\n        return false;\n    }\n};\n\nint H,W;\nint fld[10][10];\n\n\nint solve(){\n    int cnt=1;\n    int sx,sy;\n    REP(i,H)REP(j,W){\n        if(fld[i][j]==1){\n            fld[i][j]=cnt;\n            cnt++;\n        }\n        else if(fld[i][j]==0)fld[i][j]=-1;\n        else{\n            fld[i][j]=0;\n            sx=j;sy=i;\n        }\n    }\n\n    map<State,int>prev;\n    State s;s.x=sx;s.y=sy;\n    prev[s]=1;\n\n    REP(i,cnt){\n        map<State,int>next;\n        EACH(it,prev){\n            REP(j,4){\n                int nx=(*it).first.x;\n                int ny=(*it).first.y;\n                while(true){\n                    nx+=dx[j];\n                    ny+=dy[j];\n                    if(nx<0||nx>=W||ny<0||ny>=H)break;\n                    if(fld[ny][nx]==-1||(i!=cnt-1&&fld[ny][nx]==0))continue;\n\n                    if(fld[ny][nx]!=0||(fld[ny][nx]==0&&i==cnt-1)){\n                        State now=it->first;\n                        int p=fld[ny][nx];\n                        if(now.p[p])continue;\n                        now.p[p]=true;\n                        now.x=nx;\n                        now.y=ny;\n                        next[now]+=it->second;\n                        break;\n                    }\n                }\n            }\n        }\n        prev=next;\n    }\n\n    State gol;\n    gol.x=sx;gol.y=sy;\n    REP(i,cnt)gol.p[i]=true;\n    return prev[gol];\n\n}\n\n\nint main(){\n    while(cin>>W>>H,H||W){\n        REP(i,H)REP(j,W)cin>>fld[i][j];\n        cout<<solve()<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\nmap<int,int> msi;\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n#if DEB\n  puts(\"hoyo\");\n#endif\n  map<int,int>::iterator it = msi.lower_bound(S);\n#if DEB\n  puts(\"hoyo2\");\n#endif\n\n  if( it!=msi.end() && it->first == S ){ //ùÉÊÁ½óÔ\n    return it->second;\n  }\n\n#if DEB\n  printf(\"src:%d x:%d y:%d s:%d\\n\",src,x,y,s);\n#endif\n  \n  // v[gªu¯È¢ÆÌL³\n  /*\n    1831764\n    ari  :: msi_sz: 885661  >0:376369  ==0:509292  already>0:222390 , already==0:408636\n    nari :: msi_sz:1028771  >0:376369  ==0:652402  already>0:222390 , already==0:565310\n   */\n  \n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  if( it!=msi.end() )--it;\n  msi.insert(it, make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n//#include <ext/hash_map>\n#include <tr1/unordered_map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing namespace tr1;\n//using namespace __gnu_cxx;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n#define SZ 885777\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n//hash_map<int,int> hii(SZ);\nunordered_map<int,int> hii(2000000);\n\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //ツ静「ツ妥篠づ可姪淞づェツづゥ\n    return 1;\n  }\n  if( isnotgoal(s) ){ //ツ仰ウツ嘉ッツづ可姪淞づゥツつスツづ淞づ個嘉づーツ湘氾ッツつオツつスツつゥツづつ、ツつゥ\n    return 0;\n  }\n  //hash_map<int,int>::iterator it = hii.find(S);\n  unordered_map<int,int>::iterator it = hii.find(S);\n  if( it!=hii.end() ){ //ツ探ツ催オツ催渉づ敖づ個湘ウツ妥板つゥツづつ、ツつゥ\n    return it->second;\n  }\n\n  // ツプツδ個ゼツδ督トツつェツ置ツつッツづ按つ「ツ嘉づ個有ツ鳴ウ\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  hii.insert(make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    hii.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint dfs(vector<vector<int> > &v, int x, int y, int rem) {\n//    cout << x << ' ' << y << ' ' << rem << endl;\n    if(rem == -1) return 1;\n\n    int H = v.size();\n    int W = v[0].size();\n\n    int sum = 0;\n    for(int yy = y-1; yy >= 0; --yy) {\n        if(v[yy][x] == -1) break;\n        if(v[yy][x] == 1 || (rem == 0 && v[yy][x] == 2)) {\n            int org = v[yy][x];\n            v[yy][x] = -1;\n            sum += dfs(v, x, yy, rem-1);\n            v[yy][x] = org;\n        }\n    }\n    for(int yy = y+1; yy < H; ++yy) {\n        if(v[yy][x] == -1) break;\n        if(v[yy][x] == 1 || (rem == 0 && v[yy][x] == 2)) {\n            int org = v[yy][x];\n            v[yy][x] = -1;\n            sum += dfs(v, x, yy, rem-1);\n            v[yy][x] = org;\n        }\n    }\n    for(int xx = x-1; xx >= 0; --xx) {\n        if(v[y][xx] == -1) break;\n        if(v[y][xx] == 1 || (rem == 0 && v[y][xx] == 2)) {\n            int org = v[y][xx];\n            v[y][xx] = -1;\n            sum += dfs(v, xx, y, rem-1);\n            v[y][xx] = org;\n        }\n    }\n    for(int xx = x+1; xx < W; ++xx) {\n        if(v[y][xx] == -1) break;\n        if(v[y][xx] == 1 || (rem == 0 && v[y][xx] == 2)) {\n            int org = v[y][xx];\n            v[y][xx] = -1;\n            sum += dfs(v, xx, y, rem-1);\n            v[y][xx] = org;\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while(true) {\n        int M, N;\n        cin >> M >> N;\n        if(!M && !N) break;\n\n        vector<vector<int> > v(N, vector<int>(M, 0));\n\n        int sx, sy;\n        int rem = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < M; ++j) {\n                cin >> v[i][j];\n                if(v[i][j] == 1) ++rem;\n                if(v[i][j] == 2) {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n\n        cout << dfs(v, sx, sy, rem) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint m;\nint n;\nint map[10][10] = {0};\nint cnt = 0;\nint churchx;\nint churchy;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n\nint saiki( int xinput, int yinput, int nokori ) {\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tint x = xinput;\n\t\tint y = yinput;\n\t\tif ( nokori == 0 ) {\n\t\t\tif ( y == churchy && x > churchx && i != 0 ) continue;\n\t\t\tif ( y == churchy && x < churchx && i != 1 ) continue;\n\t\t\tif ( x == churchx && y > churchy && i != 2 ) continue;\n\t\t\tif ( x == churchx && y < churchy && i != 3 ) continue;\n\t\t}\n\t\twhile(true) {\n\t\t\tx += dx[i];\n\t\t\ty += dy[i];\n\t\t\tif ( x < 0 || x >= m || y < 0 || y >= n ) break;\n\t\t\tif ( map[x][y] == 1 ) {\n\t\t\t\tmap[x][y] = 3;\n\t\t\t\tsaiki( x, y, nokori-1 );\n\t\t\t\tmap[x][y] = 1;\n\t\t\t}else if ( map[x][y] == 2 ) {\n\t\t\t\tif ( nokori == 0 ) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if ( map[x][y] == 3 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> m;\n\t\tcin >> n;\n\t\tif ( m == 0 ) break;\n\t\tint nokori = 0;\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tfor ( int j = 0; j < m; j++ ) {\n\t\t\t\tcin >> map[j][i];\n\t\t\t\tif ( map[j][i] == 1 ) {\n\t\t\t\t\tnokori++;\n\t\t\t\t}else if ( map[j][i] == 2 ) {\n\t\t\t\t\tchurchx = j;\n\t\t\t\t\tchurchy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( nokori == 0 ) {\n\t\t\tcout << \"1\" << endl;\n\t\t}else {\n\t\t\tcnt = 0;\n\t\t\tsaiki( churchx, churchy, nokori );\n\t\t\tcout << cnt << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <set>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint n;\nvector<vector<vector<int> > > to;\nvector<bool> isToZero;\n\nint dfs(int curr, bitset<24> bs, int toZeroNum){\n    if(bs.count() == n){\n        if(isToZero[curr])\n            return 1;\n        else\n            return 0;\n    }\n    if(isToZero[curr]){\n        -- toZeroNum;\n        if(toZeroNum == 0)\n            return 0;\n    }\n\n    int ret = 0;\n    for(int i=0; i<4; ++i){\n        unsigned j = 0;\n        while(j < to[curr][i].size() && bs[to[curr][i][j]])\n            ++ j;\n        if(j < to[curr][i].size()){\n            j = to[curr][i][j];\n            bs[j] = true;\n            ret += dfs(j, bs, toZeroNum);\n            bs[j] = false;\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        n = 1;\n        vector<int> y(1), x(1);\n        vector<vector<int> > grid(h, vector<int>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> grid[i][j];\n                if(grid[i][j] == 1){\n                    y.push_back(i);\n                    x.push_back(j);\n                    grid[i][j] = n;\n                    ++ n;\n                }else if(grid[i][j] == 2){\n                    y[0] = i;\n                    x[0] = j;\n                    grid[i][j] = 0;\n                }else{\n                    grid[i][j] = -1;\n                }\n            }\n        }\n\n        to.assign(n, vector<vector<int> >(4, vector<int>(0)));\n        isToZero.assign(n, false);\n        int toZeroNum = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                int y1 = y[i] + dy[j];\n                int x1 = x[i] + dx[j];\n                while(0 <= y1 && y1 < h && 0 <= x1 && x1 < w){\n                    if(grid[y1][x1] != -1){\n                        int k = grid[y1][x1];\n                        if(k == 0){\n                            isToZero[i] = true;\n                            ++ toZeroNum;\n                        }else\n                            to[i][j].push_back(k);\n                    }\n                    y1 += dy[j];\n                    x1 += dx[j];\n                }\n            }\n        }\n\n        cout << dfs(0, 1, toZeroNum) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second \n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  int ni,nj;\n  int cnt;\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;\n    vis=0;\n    vis|=(1<<houseId[si][sj]);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n\n  while(!qs.empty()){\n    //bool bCont=false;\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;\n    qs.pop();\n    /*\n    if( st_now.cnt == nhouse ){\n      for(int k = 0; k < MAXDIR; ++k){\n\tif( M[ni][nj].cexist[k] ){\n\t  ++ans;\n\t  bCont=true;\n\t}\n      }\n    }\n    if(bCont)continue;\n    */\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !( st_now.vis&(1<<houseId[next.fr][next.sc]) ) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis|=(1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    if(st_next.cnt == nhouse){\n\t      for(int l = 0; l < MAXDIR; ++l){\n\t\tif( M[st_next.ni][st_next.nj].cexist[l] ){\n\t\t  ++ans;\n\t\t}\n\t      }\n\t      break;\n\t    }else{\n\t      qs.push( st_next );\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = UP; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int nposmax = 6;\nconst int bitmax = 1<<21;\n//bit????????????\nint dp[nposmax][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax&&now<nposmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\t#if 0\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n\t\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\t{\n\t\t\tauto iter = &graph[now][0];\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(bit<bitmax&&now<nposmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n\nconstexpr int MAX = 10;\n\nint w, h;\nint board[MAX][MAX];\nconstexpr int dx[4] = { 1,-1,0,0 }, dy[4] = { 0,0,1,-1 };\n\nbool check_pre() {\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tif (board[i][j] == 1)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint dfs(int x, int y) {\n\tint res = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\twhile (0 <= nx&&nx < w &&\n\t\t\t0 <= ny&&ny < h&&board[ny][nx] != -1) {\n\t\t\tif (check_pre()) {\n\t\t\t\tif (board[ny][nx] == 1) {\n\t\t\t\t\tboard[ny][nx] = -1;\n\t\t\t\t\tres += dfs(nx, ny);\n\t\t\t\t\tboard[ny][nx] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (board[ny][nx] == 2) {\n\t\t\t\t\tres = 1;\n\t\t\t\t\tgoto a;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t}\n\t}\na:;\n\treturn res;\n}\n\nint sx, sy;\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> w >> h;\n\n\t\tif (w + h == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tstd::cin >> board[i][j];\n\t\t\t\tif (board[i][j] == 2) {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << dfs(sx, sy) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#pragma warning(disable : 4996)\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], d[4] = { 1, 0, -1, 0 };\ninline int solve(int sx, int sy, int depth) {\n\tif (depth == n) {\n\t\tif (sx == gx || sy == gy) return 1;\n\t\treturn 0;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (rng(tx, ty)) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth + 1);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += d[i];\n\t\t\tty += d[i ^ 1];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &x[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//MLE\n#include <cstdio>\n#include <map>\nusing namespace std;\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nmap<int,int> memo;\n\nint func( int p, int d, int u ){\n\twhile(1){\n\t\tint h = mp[p];\n\t\tif( h >= 0 ){\n\t\t\tint s = 0;\n\t\t\tmp[p] = -1;\n\t\t\ths ^= 1 << h;\n\t\t\tif( u > 10 ){\n\t\t\t\tfor(int i = 0; i < 4; i++ )\n\t\t\t\t\ts += func( p + dir[i], dir[i], u - 1 );\n\t\t\t}else{\n\t\t\t\tint mi = h << 23 | hs;\n\t\t\t\tmap<int,int>::iterator it = memo.find(mi);\n\t\t\t\tif( it == memo.end() ){\n\t\t\t\t\tfor(int i = 0; i < 4; i++ )\n\t\t\t\t\t\ts += func( p + dir[i], dir[i], u - 1 );\n\t\t\t\t\tmemo[mi] = s;\n\t\t\t\t}else{\n\t\t\t\t\ts = it->second;\n\t\t\t\t}\n\t\t\t}\n\t\t\ths |= 1 << h;\n\t\t\tmp[p] = h;\n\t\t\treturn s;\n\t\t}\n\t\tif( h == -9 )break;\n\t\tp += d;\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tmemo.clear();\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\tj = hs;\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt += func( ch + dir[i], dir[i], j );\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = long long;\nusing P = std::tuple<int,int>;\n\nconst int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1}, dy[8] = {0, 0, -1, 1, -1, 1, -1, 1};\n\nint M, N, numHouse, gr, gc;\nint map[12][12];\nP neighbors[12][12][4];\nint dp[1<<24];\n\nint rec(int r, int c, int n){\n    if(n == 0){\n        return r == gr || c == gc;\n    }\n\n    for(int i=0;i<4;++i){\n        int rn, cn;\n        std::tie(rn, cn) = neighbors[r][c][i];\n\n        if(rn != -1){\n            neighbors[rn][cn][(i + 2) & 3] = neighbors[r][c][(i + 2) & 3];\n        }\n    }\n    \n    int res = 0;\n    for(int i=0;i<4;++i){\n        int rn, cn;\n        std::tie(rn, cn) = neighbors[r][c][i];\n\n        if(rn == -1){\n            continue;\n        }\n\n        res += rec(rn, cn, n - 1);\n    }\n\n    for(int i=0;i<4;++i){\n        int rn, cn;\n        std::tie(rn, cn) = neighbors[r][c][i];\n\n        if(rn != -1){\n            neighbors[rn][cn][(i + 2) & 3] = std::make_tuple(r, c);\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        std::cin >> M >> N;\n\n        if(M == 0){\n            break;\n        }\n\n        numHouse = 0;\n        std::fill(&neighbors[0][0][0], &neighbors[0][0][0] + 12 * 12 * 4, std::make_tuple(-1, -1));\n        memset(dp, -1, sizeof(dp));\n\n        for(int i=0;i<N;++i){\n            for(int j=0;j<M;++j){\n                std::cin >> map[i][j];\n\n                if(map[i][j] == 1){\n                    numHouse += 1;\n                }else if(map[i][j] == 2){\n                    gr = i;\n                    gc = j;\n                }\n            }\n        }\n\n        for(int i=0;i<N;++i){\n            for(int j=0;j<M;++j){\n                if(map[i][j] == 0){\n                    continue;\n                }\n\n                for(int k=j-1;k>=0;--k){ // 左\n                    if(map[i][k] > 0){\n                        neighbors[i][j][0] = std::make_tuple(i, k);\n                        break;\n                    }\n                }\n\n                for(int k=j+1;k<M;++k){ // 右\n                    if(map[i][k] > 0){\n                        neighbors[i][j][2] = std::make_tuple(i, k);\n                        break;\n                    }\n                }\n\n                for(int k=i-1;k>=0;--k){ // 上\n                    if(map[k][j] > 0){\n                        neighbors[i][j][1] = std::make_tuple(k, j);\n                        break;\n                    }\n                }\n\n                for(int k=i+1;k<N;++k){ // 下\n                    if(map[k][j] > 0){\n                        neighbors[i][j][3] = std::make_tuple(k, j);\n                        break;\n                    }                \n                }\n            }\n        }\n\n        int res = rec(gr, gc, numHouse);\n        std::cout << res << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tint a[12][12];\n\t\t\n\t\tscanf(\"%d%d\",&m,&n); if(m == 0 && n == 0)break;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x[25],y[25];\n\t\tint k = 1;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tif(a[i][j] == 1){\n\t\t\t\t\tx[k] = i;\n\t\t\t\t\ty[k] = j;\n\t\t\t\t\tk ++;\n\t\t\t\t}\n\t\t\t\telse if(a[i][j] == 2){\n\t\t\t\t\tx[0] = i;\n\t\t\t\t\ty[0] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint d[25][25];\n\t\trep(i,k){\n\t\t\tfor(int j = i+1 ; j < k ; j ++){\n\t\t\t\tif(x[i] == x[j]){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\trep(t,k){\n\t\t\t\t\t\tif(x[t] == x[i] && (y[t]-y[i])*(y[t]-y[j]) < 0){\n\t\t\t\t\t\t\td[i][j] |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(y[i] == y[j]){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\trep(t,k){\n\t\t\t\t\t\tif(y[t] == y[i] && (x[t]-x[i])*(x[t]-x[j]) < 0){\n\t\t\t\t\t\t\td[i][j] |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td[i][j] = (1 << k)-1;\n\t\t\t\t}\n\t\t\t\td[j][i] = d[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\t\n\t\trep1(i,k-1){\n\t\t\tif(x[i] == x[0] || y[i] == y[0]){\n\t\t\t\tque.push( P ( i , 1 << i ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif(p.fr == 0){\n\t\t\t\tif(p.sc == (1 << k)-1)ret ++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i,k){\n\t\t\t\tif((p.sc >> i)&1)continue;\n\t\t\t\tif((d[p.fr][i] & p.sc) == 0){\n\t\t\t\t\tque.push( P ( i , p.sc | (1 << i) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint memo[23][1<<23];\nvector<Pi> houses;\nint M,N,SY,SX;\n\ninline bool HasVisited(const int y,const int x,const int state,const vector<vector<int> > &G){\n\tif(G[y][x]!=1) return false;\n\tREP(i,0,houses.size()) if(houses[i].F_==y&&houses[i].S_==x&&((state>>i)&1)==1) return true; \n\treturn false;\n}\n\ninline int GetHouseNum(const int y,const int x,const vector<vector<int> > &G){\n\tif(G[y][x]!=1) return -1;\n\tREP(i,0,houses.size()) if(houses[i].F_==y&&houses[i].S_==x) return i;\n\treturn -1;\n}\n\nint DFS(const int Y,const int X,const vector<vector<int> > &G,int dir,int state){\n\t//cout << Y << ' ' << X << ' ' << dir << ' ' << state << endl;\n\tif(Y==SY&&X==SX&&(state&((1<<houses.size())-1))==((1<<houses.size())-1)){\n\t\t//cout << \"a: \" << Y << ' ' << X << ' ' << dir << ' ' << state << endl;\n\t\treturn 1;\n\t}\n\tint house_num=GetHouseNum(Y,X,G);\n\tif(house_num!=-1&&memo[house_num][state]!=-1) return memo[house_num][state];\n\tif(G[Y][X]==1){\n\t\tmemo[house_num][state]=0;\n\t\tREP(i,0,4){\n\t\t\tint ny=Y+dy[i],nx=X+dx[i];\n\t\t\tif(0<=ny&&ny<N&&0<=nx&&nx<M&&!HasVisited(ny,nx,state,G)){\n\t\t\t\tmemo[house_num][state]+=DFS(ny,nx,G,i,state|(1<<house_num));\n\t\t\t}\n\t\t}\n\t}\n\tint ny=Y+dy[dir],nx=X+dx[dir];\n\tif(0<=ny&&ny<N&&0<=nx&&nx<M&&!HasVisited(ny,nx,state,G)){\n\t\tif(house_num!=-1) memo[house_num][state]+=DFS(ny,nx,G,dir,state);\n\t\telse return DFS(ny,nx,G,dir,state);\n\t}\n\tif(house_num!=-1) return memo[house_num][state];\n\telse return 0;\n}\n\nint Solve(){\n\t//fill((int*)memo,(int*)(memo+23*(1<<23)),-1);\n\tREP(i,0,23) REP(j,0,(1<<23)) memo[i][j]=-1;\n\thouses.clear();\n\tvector<vector<int> > G(N,vector<int>(M));\n\tREP(y,0,N) REP(x,0,M) cin >> G[y][x];\n\tREP(y,0,N) REP(x,0,M){\n\t\tif(G[y][x]==2){\n\t\t\tSY=y;\n\t\t\tSX=x;\n\t\t}else if(G[y][x]==1){\n\t\t\thouses.push_back(Pi(y,x));\n\t\t}\n\t}\n\tint result=0;\n\tREP(i,0,4) result+=DFS(SY,SX,G,i,0);\n\treturn result;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(cin >> M >> N&&!(M==0&&N==0)){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint m,n,k=0;\nint a[15][15],hnex[15][15],hpre[15][15],wnex[15][15],wpre[15][15],h[15],w[15];\nint ans=0,locx,locy;\n\nint solve(int x,int y){\n\tint ret=0;\n\tk--;\n\tbool b[4]={false,false,false,false};\n\tif(hpre[x][y]!=0){hnex[hpre[x][y]][y]=hnex[x][y]; b[0]=true;}\n\tif(hnex[x][y]!=0){hpre[hnex[x][y]][y]=hpre[x][y]; b[1]=true;}\n\tif(wpre[x][y]!=0){wnex[x][wpre[x][y]]=wnex[x][y]; b[2]=true;}\n\tif(wnex[x][y]!=0){wpre[x][wnex[x][y]]=wpre[x][y]; b[3]=true;}\n\tif(k==0){\n\t\tk++;\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<1<<endl;\n\t\tif(x==locx||y==locy)return 1;\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<0<<endl;\n\t\treturn 0;\n\t}\n\tif(b[0])ret+=solve(hpre[x][y],y);\n\tif(b[1])ret+=solve(hnex[x][y],y);\n\tif(b[2])ret+=solve(x,wpre[x][y]);\n\tif(b[3])ret+=solve(x,wnex[x][y]);\n\tif(b[0])hnex[hpre[x][y]][y]=x;\n\tif(b[1])hpre[hnex[x][y]][y]=x;\n\tif(b[2])wnex[x][wpre[x][y]]=y;\n\tif(b[3])wpre[x][wnex[x][y]]=y;\n\tk++;\n\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<ret<<\" \"<<k<<endl;\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++){a[i][j]=4; wnex[i][j]=0; wpre[i][j]=0; hnex[i][j]=0; hpre[i][j]=0;}\n\tfor(int i=0;i<15;i++){h[i]=0; w[i]=0;}\n\tk=0;\n\tscanf(\"%d%d\",&m,&n);\n\tif(m==0&&n==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\tif(a[i][j]==1){\n\t\t\t\tk++;\n\t\t\t\thnex[h[j]][j]=i;\n\t\t\t\thpre[i][j]=h[j];\n\t\t\t\th[j]=i;\n\t\t\t\twnex[i][w[i]]=j;\n\t\t\t\twpre[i][j]=w[i];\n\t\t\t\tw[i]=j;\n\t\t\t\ta[i][j]=3;\n\t\t\t}\n\t\t\tif(a[i][j]==2){\n\t\t\t\tk++;\n\t\t\t\tlocx=i; locy=j;\n\t\t\t\thnex[h[j]][j]=i;\n\t\t\t\thpre[i][j]=h[j];\n\t\t\t\th[j]=i;\n\t\t\t\twnex[i][w[i]]=j;\n\t\t\t\twpre[i][j]=w[i];\n\t\t\t\tw[i]=j;\n\t\t\t}\n\t\t}\n\t}\n\tans=solve(locx,locy);\n\tprintf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\n/*\nconst int dx[] = {0,1,0,-1}; //u,r,d,l\nconst int dy[] = {-1,0,1,0};\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( s==a.s ){\n      if( x==a.x ) return y<a.y;\n      else         return x<a.x;\n    }else{\n      return s<a.s;\n    }\n  }\n  \n};\n\nint numofbits(int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\n\n\nmap<state,int> msi;\n\nbool isgoal(int s){\n  return (((last&s)) == last);\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  if( ret!=0 ){\n    msi[state(x,y,s)] = ret;\n  }\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\nconst int dx[]={-1,1,0,0};\nconst int dy[]={0,0,-1,1};\n\n\nint N,M;\nint feld[11][11];\nint cnt;\npii last;\nint ans;\n\nvoid dfs(int x,int y,int sum){\n    for(int i=0;i<4;++i){\n        int nx=x;\n        int ny=y;\n        while(1){\n            nx+=dx[i];\n            ny+=dy[i];\n            if(nx<0||nx>=N||ny<0||ny>=M)break;\n            if(feld[ny][nx]==1){\n                feld[ny][nx]=-1;\n                dfs(nx,ny,sum+1);\n                feld[ny][nx]=1;\n                break;\n            }\n            else if(feld[ny][nx]==2){\n                if(sum==cnt){\n                    ans++;\n                    return ;\n                }\n            }\n        }\n    }\n    return ;\n}\n\n\nsigned main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(feld,-1,sizeof(feld));\n        for(int i=0;i<M;++i){\n            for(int j=0;j<N;++j){\n                cin>>feld[i][j];\n                if(feld[i][j]==2){\n                    last.FI=i;\n                    last.SE=j;\n                }\n                else if(feld[i][j]==1)cnt++;\n            }\n        }\n        dfs(last.SE,last.FI,0);\n        cout<<ans<<endl;\n        ans=0;\n        cnt=0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;}\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n    if( st_now.cnt + 10 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    \n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !st_now.checkvis( houseId[next.fr][next.sc] ) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.setvis( houseId[next.fr][next.sc] );\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;vis|=(1<<houseId[si][sj]);}\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    \n    if( st_now.cnt + 3 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define MAX 15\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint s[MAX][MAX];\ntypedef pair<int,int> P;\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny,int nx,map<P,int> mp,int t,int d){\n//\tcout<<\"------\"<<endl;\n\tif(!(nx<w&&nx>=0&&ny<h&&ny>=0))\n\t\treturn 0;\n\t\n\tint ret=0;\n\tif(ny==sy&&nx==sx&&sum==t)\n\t\treturn 1;\n\telse if(s[ny][nx]==1){\n\t\tif(mp[P(ny,nx)]){\n\t\t\treturn ret;\n\t\t}else{\n\t\t\tint ax=nx+dx[d],ay=ny+dy[d];\n\t\t\tret+=func(ay,ax,mp,t,d);\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tmp[P(ny,nx)]++;\n\t\t\t\tint ax=nx+dx[i],ay=ny+dy[i];\n\t\t\t\tret+=func(ay,ax,mp,t+1,i);\n\t\t\t\tmp[P(ny,nx)]--;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}else if(s[ny][nx]==2||s[ny][nx]==0){\n\t\tint ax=nx+dx[d],ay=ny+dy[d];\n\t\tret+=func(ay,ax,mp,t,d);\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tmap<P,int> bit;\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1)\n\t\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<4;i++)\n\t\t\tans+=func(sy,sx,bit,0,i);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\ninline bool in(int x, int y, int w, int h)\n{\n\treturn x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint main()\n{\n\twhile(true) {\n\t\t\n\t\tint w, h, n;\n\t\tint field[16][16];\n\t\tvector<pair<int, int> > house;\n\t\tpair<int, int> church;\n\t\t\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif(t == 0) {\n\t\t\t\t\tt = -1;\n\t\t\t\t} else if(t == 1) {\n\t\t\t\t\tt = house.size();\n\t\t\t\t\thouse.push_back(make_pair(x, y));\n\t\t\t\t} else if(t == 2) {\n\t\t\t\t\tt = -2;\n\t\t\t\t\tchurch = make_pair(x, y);\n\t\t\t\t}\n\t\t\t\tfield[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tn = house.size();\n\t\t\n\t\tint reach[23][23];\n\t\tint dx[] = {-1, 0, 0, 1}, dy[] = {0, -1, 1, 0};\n\t\tstatic int dp[23][1 << 23];\n\t\t\n\t\tmemset(dp[0], 0, (1 << 23) * n * sizeof(int));\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tdp[tgt][1 << tgt] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int a = 0; a < n; ++a) {\n\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\n\t\t\t\tif(a == b)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\treach[a][b] = (1 << a) | (1 << b);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\t\n\t\t\t\t\tint cx = house[a].first, cy = house[a].second;\n\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tint t = field[cx][cy];\n\t\t\t\t\t\tif(t == b) {\n\t\t\t\t\t\t\treach[a][b] = bit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(t >= 0) {\n\t\t\t\t\t\t\tbit |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 1; bit < (1 << n); ++bit) {\n\t\t\t\n\t\t\tfor(int a = 0; a < n; ++a) {\n\t\t\t\t\n\t\t\t\tif((bit & (1 << a)) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint prev = bit ^ (1 << a);\n\t\t\t\t\n\t\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\t\n\t\t\t\t\tif((prev & (1 << b)) == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif((prev & reach[a][b]) != 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tdp[a][bit] += dp[b][prev];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//printf(\"[debug] dp[%d][%d] = %d\\n\", a, bit, dp[a][bit]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tans += dp[tgt][(1 << n) - 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n//#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint search(int i, int j, int done)\n{\n\tint ret=0;\n\tint dx=1;\n\tint dy=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(done&(1<<table[x][y])){\n\t\t\t\t\tret+=search(x,y,done^(1<<table[x][y]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(done==0&&table[x][y]==-1){\n\t\t\t\tret++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tint c=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\ttable[i][j]=c++;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-2;\n\t\t\t}\n\t\t}\n\t}\n\tint ret=search(s,t,(1<<c)-1);\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nstruct Tag {\n    int mask;\n    int x, y;\n\n    Tag() {}\n    Tag(int mask, int x, int y) : mask(mask), x(x), y(y) {}\n\n    bool operator <(const Tag &other) const {\n        if(mask != other.mask) return mask < other.mask;\n        if(x != other.x) return x < other.x;\n        return y < other.y;\n    }\n};\n\ninline bool is_home(int i) {\n    return 1 <= i && i <= 24;\n}\n\nconst int GOAL = 100;\nmap<Tag, int> memo;\n\nint dfs(vector<vector<int> > &v, int x, int y, int mask, int rem) {\n    //cout << x << ' ' << y << ' ' << rem << endl;\n    const Tag tag(mask, x, y);\n    if(memo.count(tag)) return memo[tag];\n    if(rem == -1) return 1;\n\n    const int H = v.size();\n    const int W = v[0].size();\n\n    int sum = 0;\n    for(int yy = y-1; yy >= 0; --yy) {\n        if(v[yy][x] == -1) break;\n        if(is_home(v[yy][x]) || (rem == 0 && v[yy][x] == GOAL)) {\n            int org = v[yy][x];\n            v[yy][x] = -1;\n            sum += dfs(v, x, yy, mask|(1<<org-1), rem-1);\n            v[yy][x] = org;\n        }\n    }\n    for(int yy = y+1; yy < H; ++yy) {\n        if(v[yy][x] == -1) break;\n        if(is_home(v[yy][x]) || (rem == 0 && v[yy][x] == GOAL)) {\n            int org = v[yy][x];\n            v[yy][x] = -1;\n            sum += dfs(v, x, yy, mask|(1<<org-1), rem-1);\n            v[yy][x] = org;\n        }\n    }\n    for(int xx = x-1; xx >= 0; --xx) {\n        if(v[y][xx] == -1) break;\n        if(is_home(v[y][xx]) || (rem == 0 && v[y][xx] == GOAL)) {\n            int org = v[y][xx];\n            v[y][xx] = -1;\n            sum += dfs(v, xx, y, mask|(1<<org-1), rem-1);\n            v[y][xx] = org;\n        }\n    }\n    for(int xx = x+1; xx < W; ++xx) {\n        if(v[y][xx] == -1) break;\n        if(is_home(v[y][xx]) || (rem == 0 && v[y][xx] == GOAL)) {\n            int org = v[y][xx];\n            v[y][xx] = -1;\n            sum += dfs(v, xx, y, mask|(1<<org-1), rem-1);\n            v[y][xx] = org;\n        }\n    }\n\n    return memo[tag] = sum;\n}\n\nint main() {\n    while(true) {\n        int M, N;\n        cin >> M >> N;\n        if(!M && !N) break;\n\n        vector<vector<int> > v(N, vector<int>(M, 0));\n\n        int sx, sy;\n        int home_idx = 1;\n        int rem = 0;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < M; ++j) {\n                cin >> v[i][j];\n                if(v[i][j] == 1) {\n                    v[i][j] = home_idx++;\n                    ++rem;\n                }\n                else if(v[i][j] == 2) {\n                    sx = j;\n                    sy = i;\n                    v[i][j] = GOAL;\n                }\n            }\n        }\n\n        memo.clear();\n        cout << dfs(v, sx, sy, 0, rem) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n, m;\nint res, rcnt;\nint gx, gy;\nint map[10][10];\nbool used[10][10];\nint dx[4]={-1,1,0,0};\nint dy[4]={0,0,-1,1};\nbool isin(int x, int y) {\n    return x>=0&&y>=0&&x<m&&y<n;\n}\nvoid dfs(int x, int y, int c) {\n    if (rcnt==c) {\n        if (gx!=x&&gy!=y) return;\n        if (gx==x) {\n            for (int i=min(gy,y); i<=max(gy,y); i++) {\n                if (i!=y&&map[x][i]==1) return;\n            }\n            res++;\n        } else if (gy==y) {\n            for (int i=min(gx,x); i<=max(gx,x); i++) {\n                if (i!=x&&map[i][y]==1) return;\n            }\n            res++;\n        }\n        return;\n    }\n    for (int i=0; i<4; i++) {\n        int nx=x+dx[i], ny=y+dy[i];\n        while (isin(nx,ny)&&(!used[nx][ny]||(used[nx][ny]&&map[nx][ny]!=1))) {\n            // printf(\"%d %d %d\\n\",nx,ny,map[nx][ny]);\n            if (map[nx][ny]==1) {\n                used[nx][ny]=true;\n                dfs(nx,ny,c+1);\n                used[nx][ny]=false;\n            }\n            nx+=dx[i]; ny+=dy[i];\n        }\n    }\n}\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        res=0; rcnt=0;\n        memset(used, 0, sizeof(used));\n        for (int i=0; i<m; i++) {\n            for (int j=0; j<n; j++) {\n                scanf(\"%d\",&map[i][j]);\n                if (map[i][j]==2) {\n                    gx=i; gy=j;\n                    used[i][j]=true;\n                } else if (map[i][j]==0) {\n                    used[i][j]=true;\n                } else {\n                    rcnt++;\n                }\n            }\n        }\n        dfs(gx,gy,0);\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 13 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[10 + 2][10 + 2];\n\nint housecnt;\nint ans;\nint cathx, cathy;\n\nint calc(int x, int y, int depth)\n{\n\tint i;\n\t\n\tif (depth == housecnt && (cathx == x || cathy == y)){\n\t\tans++;\n\t\treturn (0);\n\t}\n\t\n\tmap[x][y] = 0;\n\ti = 1;\n\twhile (map[x + i][y] == 0) i++;\n\tif (map[x + i][y] == 1){\n\t\tcalc(x + i, y, depth + 1);\n\t}\n\ti = 1;\n\twhile (map[x - i][y] == 0) i++;\n\tif (map[x - i][y] == 1){\n\t\tcalc(x - i, y, depth + 1);\n\t}\n\ti = 1;\n\twhile (map[x][y + i] == 0) i++;\n\tif (map[x][y + i] == 1){\n\t\tcalc(x, y + i, depth + 1);\n\t}\n\ti = 1;\n\twhile (map[x][y - i] == 0) i++;\n\tif (map[x][y - i] == 1){\n\t\tcalc(x, y - i, depth + 1);\n\t}\n\tmap[x][y] = 1;\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\tint w, h;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\t\n\t\tif (w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tmemset(map, -1, sizeof(map));\n\t\t\n\t\thousecnt = ans = 0;\n\t\t\n\t\tfor (int y = 1; y <= h; y++){\n\t\t\tfor (int x = 1; x <= w; x++){\n\t\t\t\tscanf(\"%d\", &map[x][y]);\n\t\t\t\tif (map[x][y] == 2){\n\t\t\t\t\tcathx = x;\n\t\t\t\t\tcathy = y;\n\t\t\t\t\tmap[x][y] = 0;\n\t\t\t\t}\n\t\t\t\tif (map[x][y] == 1){\n\t\t\t\t\thousecnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcalc(cathx, cathy, 0);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(memo[MP(house_num,state)]==0&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn memo[MP(house_num,state)]+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nenum Direction {\n    EAST, WEST, NORTH, SOUTH\n};\n\nstruct Home {\n    int index;\n    Home *neighbor[4];\n};\n\nconst int GOAL = 100;\n\nHome homes[10][10];\n\nint dfs(Home *cur, int mask, int rem) {\n    int sum = 0;\n\n    for(int dir = 0; dir < 4; ++dir) {\n        Home *next = cur->neighbor[dir];\n        while(next) {\n            if(rem == 0) {\n                if(next->index == GOAL) return 1;\n            }\n            if(next->index != GOAL && !(mask&(1<<next->index))) {\n                sum += dfs(next, mask|(1<<next->index), rem-1);\n                break;\n            }\n            next = next->neighbor[dir];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> M >> N;\n        if(!N && !M) break;\n\n        memset(homes, 0, sizeof(homes));\n        for(int i = 0; i < 10; ++i) {\n            for(int j = 0; j < 10; ++j) {\n                homes[i][j].index = -1;\n            }\n        }\n\n        int home_idx = 0;\n        int rem = 0;\n        int sr, sc;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < M; ++j) {\n                int val;\n                cin >> val;\n                if(val != 0) {\n                    if(val == 1) {\n                        homes[i][j].index = home_idx++;\n                        ++rem;\n                    }\n                    else {\n                        homes[i][j].index = GOAL;\n                        sr = i;\n                        sc = j;\n                    }\n\n                    for(int jj = j-1; jj >= 0; --jj) {\n                        if(homes[i][jj].index != -1) {\n                            homes[i][jj].neighbor[EAST] = &homes[i][j];\n                            homes[i][j].neighbor[WEST] = &homes[i][jj];\n                            break;\n                        }\n                    }\n                    for(int ii = i-1; ii >= 0; --ii) {\n                        if(homes[ii][j].index != -1) {\n                            homes[ii][j].neighbor[SOUTH] = &homes[i][j];\n                            homes[i][j].neighbor[NORTH] = &homes[ii][j];\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << dfs(&homes[sr][sc], 0, rem) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\nint x[10][10];\nint y[10][10];\nint graph[100][100];\nint graph2[100][100];\nint graph3[100];\nstack<int>S;\n\nint main(){\n\tint h,w,d1,d2,e1,e2,f1,f2,c=0,sum=0;\n\tmemset(graph,0,sizeof(graph));\n\tmemset(graph2,0,sizeof(graph2));\n\tcin>>w>>h;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>x[i][j];\n\t\t\tif(x[i][j]==2){\n\t\t\t\tx[i][j]=100;\n\t\t\t\td1=i;\n\t\t\t\td2=j;\n\t\t\t}\n\t\t\telse if(x[i][j]==0){\n\t\t\t\tx[i][j]=1000;\n\t\t\t}\n\t\t\telse if(x[i][j]==1){\n\t\t\t\tx[i][j]=c;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(x[i][j]!=1000){\n\t\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\t\tif(i!=k){\n\t\t\t\t\t\tif(x[k][j]<100){\n\t\t\t\t\t\t\tgraph2[i*10+j][k*10+j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x[k][j]==100){\n\t\t\t\t\t\t\tgraph2[i*10+j][k*10+j]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<w;k++){\n\t\t\t\t\tif(j!=k){\n\t\t\t\t\t\tif(x[i][k]<100){\n\t\t\t\t\t\t\tgraph2[i*10+j][i*10+k]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(x[i][k]==100){\n\t\t\t\t\t\t\tgraph2[i*10+j][i*10+k]=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(graph, 0, sizeof(graph));\n\n\tS.push(d1*10+d2);\n\n\twhile(!S.empty()){\n\t\te1=S.top()/10;\n\t\te2=S.top()%10;\n\t\tmemset(y, 0, sizeof(y));\n\t\tf1 = S.top() / 10;\n\t\tf2 = S.top() % 10;\n\t\tfor (int i = f2 + 1; i < w; i++) {\n\t\t\tif (graph3[f1 * 10 + i] == 0 || (f1 == d1 && i == d2)) {\n\t\t\t\ty[f1][i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < f2; i++) {\n\t\t\tif (graph3[f1 * 10 + i] == 0 || (f1 == d1 && i == d2)) {\n\t\t\t\ty[f1][i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = f1 + 1; i < h; i++) {\n\t\t\tif (graph3[f2 + i * 10] == 0 || (f2 == d2 && i == d1)) {\n\t\t\t\ty[i][f2] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < f1; i++) {\n\t\t\tif (graph3[f2 + i * 10] == 0 || (f2 == d2 && i == d1)) {\n\t\t\t\ty[i][f2] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tif (graph[S.top()][i * 10 + e2] == 0 && graph2[S.top()][i * 10 + e2] == 1 && graph3[i * 10 + e2] == 0 && y[i][e2] == 1) {\n\t\t\t\tgraph[S.top()][i*10+e2]=1;\n\t\t\t\tgraph[i*10+e2][S.top()]=1;\n\t\t\t\tgraph3[i*10+e2]=1;\n\t\t\t\tS.push(i*10+e2);\n\t\t\t\t\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t\telse if (graph2[S.top()][i * 10 + e2] == 2 && graph[S.top()][i * 10 + e2] == 0 && S.size() == c + 1 && graph3[i * 10 + e2] == 0 && y[i][e2] == 1) {\n\t\t\t\tgraph[S.top()][i*10+e2]=1;\n\t\t\t\tgraph3[i*10+e2]=1;\n\t\t\t\tS.push(i*10+e2);\n\t\t\t\t\n\t\t\t\tsum++;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<w;i++){\n\t\t\tif (graph[S.top()][i + e1 * 10] == 0 && graph2[S.top()][i + e1 * 10] == 1 && graph3[i + e1 * 10] == 0 && y[e1][i] == 1) {\n\t\t\t\tgraph[S.top()][i+e1*10]=1;\n\t\t\t\tgraph[i+e1*10][S.top()]=1;\n\t\t\t\tgraph3[i+e1*10]=1;\n\t\t\t\tS.push(i+e1*10);\n\t\t\t\t\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t\telse if (graph2[S.top()][i + e1 * 10] == 2 && S.size() == c + 1 && graph[S.top()][i + e1 * 10] == 0 && graph3[i + e1 * 10] == 0 && y[e1][i] == 1) {\n\t\t\t\tgraph[S.top()][i+e1*10]=1;\n\t\t\t\tgraph3[i+e1*10]=1;\n\t\t\t\tS.push(i+e1*10);\n\t\t\t\t\n\t\t\t\tsum++;\n\t\t\t\tgoto Exit;\n\t\t\t}\n\t\t}\n\t\tif (S.top() != d1 * 10 + d2) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tgraph[S.top()][i * 10 + j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgraph3[S.top()]=0;\n\t\t\tS.pop();\n\t\t}\n\t\telse {\n\t\t\tS.pop();\n\t\t\tgraph3[d1 * 10 + d2] = 0;\n\t\t}\n\tExit:;\n\t\t\n\t}\n\tcout<<sum<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#pragma warning(disable : 4996)\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], d[4] = { 1, 0, -1, 0 };\nint solve(int sx, int sy, int depth) {\n\tif (depth == n) {\n\t\tif (sx == gx || sy == gy) return 1;\n\t\treturn 0;\n\t}\n\tdepth++;\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (rng(tx, ty)) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += d[i];\n\t\t\tty += d[i ^ 1];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &x[i][j]);\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\nint w,h;\nint map[10][10];\nbool passed[10][10];\nint gx,gy;\nint count_max;\nint func(int x,int y, int count)\n{\n\t//std::cout << \"IN:\"<<x<<' '<<y<<' '<<count<<'\\n';\n\tif(count==count_max){\n\t\tif(x==gx&&y==gy){return 1;}\n\t\treturn 0;\n\t}\n\tpassed[x][y]=true;\n\tint res = 0;\n\tfor(int nx = x-1;nx>=0;--nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int nx = x+1;nx<w;++nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y-1;ny>=0;--ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y+1;ny<h;++ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpassed[x][y]=false;\n\treturn res;\n}\n\nint main()\n{\n\tfor(;;){\n\tstd::cin >> w>>h;if(w==0&&h==0){break;}\n\tcount_max=0;\n\tfor(int y=0;y<h;++y)for(int x=0;x<w;++x){\n\t\tstd::cin >> map[x][y];\n\t\tif(map[x][y]==1){++count_max;}\n\t\tif(map[x][y]==2){gx=x;gy=y;}\n\t}\n\tstd::cout << \"a:\"<<gx<<' '<<gy<<' '<<count_max<<'\\n';\n\t\n\tint res = 0;\n\tstd::cout << func(gx,gy,0)<<std::endl;\n}\n}\n\n\n#if 0\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int nposmax = 6;\nconst int bitmax = 1<<21;\n//bit????????????\nint dp[nposmax][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax&&now<nposmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\t\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tif(bit<bitmax&&now<nposmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nvector<unordered_map<int,int> > memo;\n\nvoid MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\nint DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[house_num][state]!=-1) return memo[house_num][state];\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(G[house_num][i].S_-1))&1)!=1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(memo[house_num][state]==0&&house_num!=0&&((state>>(G[house_num][i].S_-1))&1)!=1){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\tif(memo[house_num][state]==0) memo[house_num][state]=result2+1;\n\t//cout << memo[house_num][state] << ' ' << result2 << endl;\n\treturn memo[house_num][state]+result1-1;\n}\n\nlli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tmemo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<iostream>\n#import<vector>\n#import<algorithm>\nusing namespace std;typedef pair<int,int>P;typedef vector<P>::iterator I;vector<P>q,r;I i,l,e;int m[132],w,h,t,n,c,s;void S(int d){for(i=q.begin(),e=q.end();i!=e;++i)for(int s=i->first,b=s&~255,p=s&255,t=1;t;)if(t=m[p+=d],~t&&b&256<<t){if(t)b^=256<<t,r.push_back(P(b+p,i->second));t=0;}}main(){for(;cin>>w>>h,w++;){fill(m,m+132,n=0);for(h=w*h+w;w-h--;)h%w?cin>>t,m[h]=t-1?-1:++n,c=t-2?c:h:0;for(q.assign(1,P(-1&~255|c,1));n--;q.erase(l,e)){r.clear();r.reserve(q.size()*4);S(1),S(w),S(-1),S(-w);q.swap(r);sort(l=i=q.begin(),e=q.end());for(s=0;i!=e;++i)i->first-s?*l++=*i,s=i->first:l[-1].second+=i->second;}h=0;for(i=q.begin();i!=q.end();++i){int p=i->first&255;if(p/w==c/w||p%w==c%w)h+=i->second;}cout<<h<<endl;}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   (a >> b) & 1\n#define bitset(a,b)       a |= (1 << b)\n#define bitunset(a,b)    a &= ~(1 << b)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h)) {\n\t\tif (!w && !h)\n\t\t\tbreak;\n\t\tvector<vector<char>> mp(w, vector<char>(h, -1));\n\t\tpii cha;\n\t\tvector<pair<char, char>> homp;\n\t\tint homc = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tint a = 0;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tif (a == 2) {\n\t\t\t\t\tcha = { j,i };\n\t\t\t\t}\n\t\t\t\tif (a == 1) {\n\t\t\t\t\thomp.push_back({ j,i });\n\t\t\t\t\tmp[j][i] = homc;\n\t\t\t\t\thomc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thomp.push_back(cha);\n\t\tmap<pair<char, char>, int> dp[2];//?±\\??´????????¨??°\n\t\tset<int> targets;\n\t\tint ccn;\n\t\tfor (int j = cha.first; w > j; j++) {\n\t\t\tccn = mp[j][cha.second];\n\t\t\tif (ccn > -1) {\n\t\t\t\ttargets.insert(ccn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.first; 0 <= j; j--) {\n\t\t\tccn = mp[j][cha.second];\n\t\t\tif (ccn > -1) {\n\t\t\t\ttargets.insert(ccn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; h > j; j++) {\n\t\t\tccn = mp[cha.first][j];\n\t\t\tif (ccn > -1) {\n\t\t\t\ttargets.insert(ccn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; 0 <= j; j--) {\n\t\t\tccn = mp[cha.first][j];\n\t\t\tif (ccn > -1) {\n\t\t\t\ttargets.insert(ccn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdp[0][{0, homc}] = 1;\n\t\tbool t = 0;\n\t\tREP(i, homc) {\n\t\t\tfor (auto cur : dp[t]) {\n\t\t\t\tpii curpos = homp[cur.first.second];\n\t\t\t\tint cnum;\n\t\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tif ((!dp[1 - t].count({ buf,cnum }) && cur.second <= 2000000) || ((dp[1 - t][{buf, cnum}] + cur.second) < 2000000))\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tif ((!dp[1 - t].count({ buf,cnum }) && cur.second <= 2000000) || ((dp[1 - t][{buf, cnum}] + cur.second) < 2000000))\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tif ((!dp[1 - t].count({ buf,cnum }) && cur.second <= 2000000) || ((dp[1 - t][{buf, cnum}] + cur.second) < 2000000))\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tif ((!dp[1 - t].count({ buf,cnum }) && cur.second <= 2000000) || ((dp[1 - t][{buf, cnum}] + cur.second) < 2000000))\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[t].clear();\n\t\t\tt = 1 - t;\n\t\t}\n\t\tint ans = 0;\n\n\t\tfor (auto cur : dp[t]) {\n\t\t\tif (targets.find(cur.first.second) != targets.end())\n\t\t\t\tans += cur.second;\n\t\t}\n\n\t\tdp[1 - t].clear();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\n#define INF (1e+9)\n#define LLINF (1e+18)\n#define LL long long\n\nusing namespace std;\n\ntypedef struct state{\n\tint kind;\n\tint number;\n\tstate(){\n\t\tkind = -1;\n\t\tnumber = -1;\n\t}\n}state;\n\ntypedef struct info{\n\tint nx;\n\tint ny;\n\tint way;\n\tint recode;\n\tinfo(int a,int b,int c,int d){\n\t\tnx = a;\n\t\tny = b;\n\t\tway = c;\n\t\trecode = d;\n\t}\n}info;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\n\nint m,n;\nint sx,sy;\nint housenum = 0;\nint ans = 0;\n\nstate field[16][16];\n\nqueue<info> que;\n\nint bfs(void){\n\tinfo now(0,0,0,0);\n\tinfo next(0,0,0,0);\n\tint nextRecode = 0;\n\tque.push(info(sx,sy,-1,0));\n\twhile(que.empty()){\n\t\tnow = que.front();\n\t\tque.pop();\n\t\tif(field[now.ny][now.nx].kind == 1){\n\t\t\tif(now.way != -1){\n\t\t\t\tnext = info(now.nx + dx[now.way],now.ny + dy[now.way],now.way,now.recode);\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t\tnextRecode = (now.recode | (0x1 << field[now.ny][now.nx].number));\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tnext = info(now.nx + dx[i],now.ny + dy[i],i,nextRecode);\n\t\t\t\tif(field[next.ny][next.nx].kind == -1);\n\t\t\t\telse if(field[next.ny][next.nx].kind == 1){\n\t\t\t\t\tif(next.recode & (0x1 << field[next.ny][next.nx].number));\n\t\t\t\t\telse que.push(next);\n\t\t\t\t}\n\t\t\t\telse que.push(next);\n\t\t\t}\n\t\t}\n\t\telse if(field[now.ny][now.nx].kind == 0){\n\t\t\tnext = info(now.nx + dx[now.way],now.ny + dy[now.way],now.way,now.recode);\n\t\t\tque.push(next);\n\t\t}\n\t\telse if(field[now.ny][now.nx].kind == 2){\n\t\t\tif(now.recode == pow(2,housenum+1) - 1)ans++;\n\t\t\telse{\n\t\t\t\tnext = info(now.nx + dx[now.way],now.ny + dy[now.way],now.way,now.recode);\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main (void){\n\n\twhile(true){\n\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif((m == 0)&&(n == 0))break;\n\t\thousenum = 0;\n\t\tans = 0;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= m;j++){\n\t\t\t\tscanf(\"%d\",&(field[i][j].kind));\n\t\t\t\tif(field[i][j].kind == 1){\n\t\t\t\t\tfield[i][j].number = housenum;\n\t\t\t\t\thousenum++;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j].number == 2){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    map<P,int> a;\n    dp = a;\n    cout << solve(1,0) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\n\tint ans=0;\n\trep(k,4) rep(a,deg[id][k]) {\n\t\tint next_id=adj[id][k][a];\n\t\tif((picked&(1<<next_id))==0){\n\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\tbreak;\n\t\t}\n\t}\n\t// return ans;\n\treturn dp[id][picked]=ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\nint m,n;\nint mm[10][10]={0};\nint ch_y,ch_x;\nint mo4[] = {0,1,0,-1,0};\nint max_v = 1;\n\nmap<pair<pair<int,int>,int>,int> memo;\n\n//int memo[10][10][1<<23]={0};\n\nint dfs(int y,int x,int v){\n    int ret = 0;\n    pair<pair<int,int>,int> p = {{y,x},v};\n    if(memo[p]) return memo[p];\n    \n    //fprintf(stderr,\"(%2d,%2d) : %d\\n\",x,y,v);\n    \n    for(int i=0;i<4;i++){\n        int tox = x,toy = y;\n        \n        while(1){\n            tox += mo4[i];\n            toy += mo4[i+1];\n            \n            if(tox<0 || m<=tox || toy<0 || n<=toy) break;\n            \n            \n            if(mm[toy][tox]==0) continue;\n            \n            if(mm[toy][tox]==-1){\n                if(max_v == v){\n                    return 1;\n                }else{\n                    continue;\n                }\n            }\n            \n            if(mm[toy][tox]&v) continue;\n            \n            ret += dfs(toy,tox,v|mm[toy][tox]);\n            break;\n        }\n    }\n    \n    //fprintf(stderr,\"memo[%2d][%2d][%2d] = %lld\\n\",x,y,v,ret%mod);\n    \n    return memo[p] = ret;\n}\n\n\nvoid calc(int m,int n){\n    \n    //memset(memo,0,sizeof(memo));\n    \n    memo.clear();\n    \n    max_v = 1;\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&mm[i][j]);\n            \n            if(mm[i][j]==1){\n                mm[i][j] = max_v;\n                max_v*=2;\n            }else if(mm[i][j]==2){\n                mm[i][j] = -1;\n                ch_y = i;\n                ch_x = j;\n            }\n        }\n    }\n    \n    max_v--;\n    \n    printf(\"%d\\n\",dfs(ch_y,ch_x,0));\n    \n    return;\n}\n\nint main(){\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(m==0) break;\n        calc(m,n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint n,m,sx,sy,num;\nint grd[11][11];\nconst int mx[]={1,0,-1,0},my[]={0,1,0,-1};\nint dfs(int x,int y){\n\tif(num==0)\treturn (x==sx||y==sy);\n\tint ans=0;\n\tgrd[y][x]=0;\n\trep(i,4){\n\t\tint tx=x+mx[i],ty=y+my[i];\n\t\twhile(0<=tx&&tx<n&&0<=ty&&ty<m){\n\t\t\tif(grd[ty][tx]==1){\n\t\t\t\tnum--;\n\t\t\t\tans+=dfs(tx,ty);\n\t\t\t\tnum++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx+=mx[i];\tty+=my[i];\n\t\t}\n\t}\n\tgrd[y][x]=1;\n\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tif(n==0)\treturn 0;\n\t\tmemset(grd,0,sizeof(grd));\n\t\tnum=0;\n\t\trep(i,m)\trep(j,n){\n\t\t\tcin>>grd[i][j];\n\t\t\tif(grd[i][j]==2){\n\t\t\t\tsx=j,sy=i;\n\t\t\t}\n\t\t\telse if(grd[i][j]==1)\tnum++;\n\t\t}\n\t\tcout<<dfs(sx,sy)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n, coun, s;\nint dp[25][1024 * 1024 * 16], town[11][11];\nP p[25];\nvector <int> g[25][4];\nvoid bfs(int now, int flag);\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tcoun = 1;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\ts = coun;\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = coun;\n\t\t\t\t\tp[coun] = make_pair(i, j);\n\t\t\t\t\tcoun++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 1; i < coun; i++) {\n\t\t\tfor (j = 1; j < coun; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tif (p[i].first == p[j].first&&i>j) {\n\t\t\t\t\t\tg[i][2].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[i].first == p[j].first&&i<j) {\n\t\t\t\t\t\tg[i][3].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[i].second == p[j].second&&i>j) {\n\t\t\t\t\t\tg[i][1].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[i].second == p[j].second&&i<j) {\n\t\t\t\t\t\tg[i][0].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(s, 0);\n\t\tj = 1;\n\t\tfor (i = 0; i < coun - 1; i++)\n\t\t\tj = j * 2;\n\t\tcout << dp[s][j - 1] << endl;\n\n\t\t/*for (i = 1; i < coun; i++) {\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tfor (k = 0; k < g[i][j].size(); k++) {\n\t\t\t\t\tcout << g[i][j][k] << ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcout << town[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n}\nvoid bfs(int start, int flag) {\n\tdp[start][flag] = 1;\n\tvector<P> que;\n\tque.push_back(make_pair(flag, start));\n\twhile (!que.empty()) {\n\t\t//cout << que.size()<<' ';\n\t\tP pp;\n\t\tpp = que[0];\n\t\tstart = pp.second; flag = pp.first;\n\t\t//cout << start << ' ' <<  static_cast<std::bitset<24> >(flag)  << endl;\n\t\tque.erase(que.begin());\n\t\tif (flag & 1 << (s - 1)) {\n\t\t\tcontinue;\n\t\t}\n\t\t//\n\t\tfor (j = 0; j < g[start][3].size(); j++) {\n\t\t\tif (town[p[start].first][p[g[start][3][j]].second]) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][p[g[start][3][j]].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][p[g[start][3][j]].second] - 1);\n\t\t\t\t\tif (dp[town[p[start].first][p[g[start][3][j]].second]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][p[g[start][3][j]].second]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[start].first][p[g[start][3][j]].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//\n\t\t/*for (j = p[start].second; j <= m; j++) {\n\t\t\tif (town[p[start].first][j]&&j!=p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]-1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tif (dp[town[p[start].first][j]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\tfor (j = g[start][2].size() - 1; j >= 0; j--) {\n\t\t\tif (town[p[start].first][p[g[start][2][j]].second]) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][p[g[start][2][j]].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][p[g[start][2][j]].second] - 1);\n\t\t\t\t\tif (dp[town[p[start].first][p[g[start][2][j]].second]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][p[g[start][2][j]].second]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[start].first][p[g[start][2][j]].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for (j = p[start].second; j >= 1; j--) {\n\t\t//\tif (town[p[start].first][j]&&j != p[start].second) {\n\t\t//\t\tif (flag & 1 << (town[p[start].first][j]- 1)) {\n\t\t//\t\t\tbreak;\n\t\t//\t\t}\n\t\t//\t\telse {\n\t\t//\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t//\t\t\tif (dp[town[p[start].first][j]][flag2] == 0) {\n\t\t//\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t//\t\t\t\t//\tcout << 2 << endl;\n\t\t//\t\t\t}\n\t\t//\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\t\tfor (j = 0; j < g[start][0].size(); j++) {\n\t\t\tif (town[p[g[start][0][j]].first][p[start].second]) {\n\t\t\t\tif (flag & 1 << (town[p[g[start][0][j]].first][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[g[start][0][j]].first][p[start].second] - 1);\n\t\t\t\t\tif (dp[town[p[g[start][0][j]].first][p[start].second]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[g[start][0][j]].first][p[start].second]));\n\t\t\t\t\t\t//\tcout << 3 << endl;\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[g[start][0][j]].first][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t//for (j = p[start].first; j <= n; j++) {\n\t\t//\tif (town[j][p[start].second]&& j != p[start].first) {\n\t\t//\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t//\t\t\tbreak;\n\t\t//\t\t}\n\t\t//\t\telse {\n\t\t//\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t//\t\t\tif (dp[town[j][p[start].second]][flag2] == 0) {\n\t\t//\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t//\t\t\t\t//\tcout << 3 << endl;\n\t\t//\t\t\t}\n\t\t//\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\t\tfor (j = g[start][1].size() - 1; j >= 0; j--) {\n\t\t\tif (town[p[g[start][1][j]].first][p[start].second]) {\n\t\t\t\tif (flag & 1 << (town[p[g[start][1][j]].first][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[g[start][1][j]].first][p[start].second] - 1);\n\t\t\t\t\tif (dp[town[p[g[start][1][j]].first][p[start].second]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[g[start][1][j]].first][p[start].second]));\n\t\t\t\t\t\t//\tcout << 3 << endl;\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[g[start][1][j]].first][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for (j = p[start].first; j >= 1; j--) {\n\t\t//\tif (town[j][p[start].second] && j != p[start].first) {\n\t\t//\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t//\t\t\tbreak;\n\t\t//\t\t}\n\t\t//\t\telse {\n\t\t//\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t//\t\t\tif (dp[town[j][p[start].second]][flag2] == 0) {\n\t\t//\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t//\t\t\t\t//cout << 4 << endl;\n\t\t//\t\t\t\t//cout << j << ' ' << flag2 << ' ' << p[start].first << endl;\n\t\t//\t\t\t}\n\t\t//\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t//\t\t}\n\t\t//\t}\n\t\t//}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<int,int> dp[24];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(dp[id][vis])return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t  res += 1;\n\t  break;\n    }\n    if(0<g[ty][tx]){\n\t  int tmp = g[ty][tx] - 1;\n\t  if( (vis>>tmp)&1 ){\n\t    res += rec(vis-(1<<tmp),g[ty][tx]);\n\t    break;\n    \t}\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)<19)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    for(int i=0;i<pn-1;i++)dp[i].clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint m[10][10];\nint memo[1<<23][25];\nint posx[25];\nint posy[25];\nint w;\nint h;\n\nint solve(int flag, int id){\n  if(memo[flag][id] != -1)\n    return memo[flag][id];\n\n  int x = posx[id];\n  int y = posy[id];\n\n  if(flag == 0){\n    for(int d = 0; d < 4; d++){\n      // 4ûüÉÂ¢Ä\n      int yy = y + _dy[d];\n      int xx = x + _dx[d];\n\n      while(ISIN(xx, yy, w, h)){\n        int t = m[yy][xx];\n\n        if(t == 1) return memo[flag][id] = 1;\n        if(t != 0) break;\n\n        yy += _dy[d]; xx += _dx[d];\n      }\n    }\n    return memo[flag][id] = 0;\n  }\n\n  int ret = 0;\n\n  for(int d = 0; d < 4; d++){\n    // 4ûüÉÂ¢Ä\n    int yy = y + _dy[d];\n    int xx = x + _dx[d];\n\n    while(ISIN(xx, yy, w, h)){\n      int t = m[yy][xx];\n\n      if(t > 1){\n        int tt = t - 2;\n\n        if((flag & (1 << tt)) != 0){\n          ret += solve((flag ^ (1 << tt)), t);\n        }else{\n          break;\n        }\n      }\n\n      yy += _dy[d]; xx += _dx[d];\n    }\n  }\n\n  return memo[flag][id] = ret;\n}\n\nint main(){\n  while(true){\n    w = getInt();\n    h = getInt();\n\n    if(w + h == 0) break;\n\n    int cnt = 0;\n\n    REP(i,h) REP(j,w){\n      // ID ðUè¼µÈªçÛ¶\n      int tmp = getInt();\n\n      if(tmp == 1){\n        posy[2 + cnt] = i;\n        posx[2 + cnt] = j;\n        m[i][j] = 2 + cnt++;\n      }else if(tmp == 2){\n        posy[1] = i;\n        posx[1] = j;\n        m[i][j] = 1;\n      }else{\n        m[i][j] = tmp;\n      }\n    }\n\n    REP(i, (1<<cnt)) REP(j, cnt + 2) memo[i][j] = -1;\n\n    int ans = solve( (1<<cnt) - 1, 1 );\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\n\n#if DEB\nstack<int> st;\n#endif\n\nclass state{\npublic:\n  int x,y,s;\n  state(int _x, int _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool ischeck(int s){\n  return (((last&s)) == last) ;\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ // ÆÍ³ïÉßêé©Ç¤©\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = x + dx[k]*i;\n\tint ty = y + dy[k]*i;\n\t//if( inside(tx,ty) || field[ty][tx]==1 )break;\n\tif( inside(tx,ty) )break;\n\n\tif( field[ty][tx]==2 ){\n#if DEB\n\t  printf(\"goal , (%d,%d)  s:%d\\n\",x,y,s);\n\t  stack<int> tmp = st;\n\t  while( !tmp.empty() ){\n\t    printf(\"%d,\",tmp.top());\n\t    tmp.pop();\n\t  }\n\t  puts(\"\\n\");\n#endif\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½ê\n    return msi[state(x,y,s)];\n  }\n  if( ischeck(s) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\t//if( s&(1<<num[ty][tx]) ) break;\t\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif \n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n#if DEB\n\tst.pop();\n#endif\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n#if DEB\n    printf(\"home:%d  sx,sy = %d,%d\\n\",home,sx,sy);\n    printf(\"last:%d\\n\",last);\n    rep(i,h){\n      rep(j,w){\n\tprintf(\"%2d \",num[i][j]);\n      }\n      puts(\"\");\n    }\n#endif   \n    dfs(sx,sy,0);\n    printf(\"%d\\n\",msi[state(sx,sy,0)]);\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\n\nunordered_map<int,int> mem[23];\nint n,m;\nint table[10][10];\nint search(int i, int j, int done)\n{\n\tif(table[i][j]>=0&&mem[table[i][j]].find(done)!=mem[table[i][j]].end()){\n\t\treturn mem[table[i][j]][done];\n\t}\n\tint ret=0;\n\tint dx=1;\n\tint dy=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(done&(1<<table[x][y])){\n\t\t\t\t\tret+=search(x,y,done^(1<<table[x][y]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(done==0&&table[x][y]==-1){\n\t\t\t\tret++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tif(table[i][j]>=0){\n\t\tmem[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tint c=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\ttable[i][j]=c++;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-2;\n\t\t\t}\n\t\t}\n\t}\n\tint ret=search(s,t,(1<<c)-1);\n\tfor(int i=0;i<c;i++){\n\t\tmem[i].clear();\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#define rep(i, n) for ( int i = 0; i < n; i++)\nusing namespace std;\n\n#define MAX 10\n#define PMAX 23\n#define HOUSE 3\n#define SPACE 0\n#define SMOKE 1\n#define START 2\n#define BLOCK 4\n\nint H, W, n;\n\nclass State{\npublic:\n  unsigned short pi, pj, total;\n  bool V[PMAX];\n\n  State(){total = 0;}\n\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    for ( int i = 0; i < n; i++ ){\n      if ( V[i] == s.V[i] ) continue;\n      return V[i] < s.V[i];\n    }\n    return false;\n  }\n};\n\nstatic int di[4] = {0, -1, 0, 1};\nstatic int dj[4] = {1, 0, -1, 0};\n\nint  G[MAX+2][MAX+2], I[MAX+2][MAX+2];\n\nmain(){\n  int si, sj;\n\n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    int total = 0;\n    n = 0;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) G[i][j] = BLOCK;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\tcin >> G[i][j];\n\tif ( G[i][j] == START ){ si = i; sj = j;}\n\tif ( G[i][j] == SMOKE ) { total++; I[i][j] = n++; }\n      }\n    }\n\n    State s = State();\n    \n    for ( int i = 0; i < n; i++ ) s.V[i] = true;\n\n    map<State, int> M;\n    State v;\n\n    int ni, nj;\n    M[s] = 0;\n    \n    for ( int r = 0; r < 4; r++ ){\n      ni = si + di[r];\n      nj = sj + dj[r];\n\n      while(1){\n\tif ( G[ni][nj] == SMOKE && s.V[I[ni][nj]] ){\n\t  v = s;\n\t  v.pi = ni;\n\t  v.pj = nj;\n\t  v.V[I[ni][nj]] = false;\n\t  v.total = 1;\n\t  M[v] = 1;\n\t  break;\n\t} else if ( G[ni][nj] == BLOCK ) break;\n\tni += di[r];\n\tnj += dj[r];\n      }\n    }\n\n    map<State, int>::iterator it;\n    \n    int presize = M.size();\n\n    int cc = 0;\n    int x = 0;\n    bool f;\n    map<State, int> nM;\n\n    while(1){\n      nM.clear();\n      f = true;\n      for ( it = M.begin(); it != M.end(); it++ ){\n\tState cur = (*it).first;\n\tint cost = (*it).second;\n\tif ( cost == 0 ) continue;\n\n\tfor ( int r = 0; r < 4; r++ ){\n\t  ni = cur.pi + di[r];\n\t  nj = cur.pj + dj[r];\n\n\t  while(1){\n\t    if ( G[ni][nj] == SMOKE && cur.V[I[ni][nj]]){\n\t      v = cur;\n\t      v.pi = ni;\n\t      v.pj = nj;\n\t      v.V[I[ni][nj]] = false;\n\t      v.total++;\n\t      f = false;\n\t      nM[v] += cost;\n\t      break;\n\t    } else if ( ni == si && nj == sj && cur.total == total ){\n\t      x += cost;\n\t      break;\n\t    } else if ( G[ni][nj] == BLOCK ) {\n\t      break;\n\t    }\n\t    ni += di[r];\n\t    nj += dj[r];\n\t  }\n\t}\n      }\n      if ( f ) break;\n      M = nM;\n    }\n\n    cout << x << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n/*\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n*/\n\nstruct Queue{\n  int p;\n  state *V;\n  Queue():p(0){V=new state[1<<16];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){\n    V[p++]=t;\n  }\n  state & front(){\n    return V[p-1];\n  }\n  void pop(){--p;}\n  bool empty(){\n    return p==0;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    if( st_now.cnt >= 0 ){\n      int left = 0;\n      int chi=charch.fr;int chj=charch.sc;\n      for(int k = 0; k < MAXDIR; ++k){\n\tleft += M[chi][chj].linkmax[k];\n      }\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n    }\n\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\tpi next = M[ni][nj].link[k][v];\n\tif( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t  state st_next(next.fr,next.sc);\n\t  st_next.cnt = st_now.cnt + 1;\n\t  st_next.vis = st_now.vis | ( 1<<houseId[next.fr][next.sc] );\n\t  qs.push( st_next );\n\t  break;\n\t}\n      }\n    }\n\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF 1 << 30\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nmap<P, int>b;\nmap<int, P>reb;\nmap<P, int>dp;\nint g[16][16];\nint M, N, c, sy, sx;\n\nint dfs(int cur, int bit){\n  //  cout << cur << \" \" << bit << endl;\n  int y = reb[cur].first, x = reb[cur].second;\n  int res = 0;\n  if(dp.find(P(cur, bit))!=dp.end()) return dp[P(cur, bit)];\n  if(bit == (1<<c)-1){\n    if(sy==y){\n      int i;\n      for(i=min(sx,x)+1;i<max(sx,x);i++) if(g[sy][i]==1) break;\n      if(i==max(sx,x)) res = 1;\n    }else if(sx==x){\n      int i;\n      for(i=min(sy,y)+1;i<max(sy,y);i++) if(g[i][sx]==1) break;\n      if(i==max(sy,y)) res = 1;\n    }\n    return res;\n  }\n\n  for(int i=y-1;i>=0;i--){\n    if(g[i][x]==1 && ((bit>>b[P(i,x)])&1)) break;\n    if(i!=y && g[i][x]==1 && !((bit>>b[P(i,x)])&1)) res += dfs(b[P(i,x)], bit | 1<<b[P(i,x)]);\n  }\n  for(int i=y+1;i<N;i++){\n    if(g[i][x]==1 && ((bit>>b[P(i,x)])&1)) break;\n    if(i!=y && g[i][x]==1 && !((bit>>b[P(i,x)])&1)) res += dfs(b[P(i,x)], bit | 1<<b[P(i,x)]);\n  }\n  \n  for(int j=x-1;j>=0;j--){\n    if(g[y][j]==1 && ((bit>>b[P(y,j)])&1)) break;\n    if(j!=x && g[y][j]==1 && !((bit>>b[P(y,j)])&1)) res += dfs(b[P(y,j)], bit | 1<<b[P(y,j)]);\n  }\n\n  for(int j=x+1;j<M;j++){\n    if(g[y][j]==1 && ((bit>>b[P(y,j)])&1)) break;\n    if(j!=x && g[y][j]==1 && !((bit>>b[P(y,j)])&1)) res += dfs(b[P(y,j)], bit | 1<<b[P(y,j)]);\n  }\n    \n  return dp[P(cur, bit)] = res;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d%d\",&M,&N);\n    b.clear();\n    reb.clear();\n    dp.clear();\n    if(!M&&!N) return 0;\n    c = 0;\n    rep(i,N) rep(j,M){\n      scanf(\"%d\", &g[i][j]);\n      if(g[i][j]==1){\n\tb[P(i,j)] = c;\n\treb[c] = P(i, j);\n\tc++;\n      }\n      if(g[i][j]==2){\n\tsy = i, sx = j;\n      }\n    }\n\n    int res = 0;\n    //  cout << sy << \" \" << sx << endl;\n    for(int i=0;i<N;i++){\n      if(i!=sy && g[i][sx]==1) res += dfs(b[P(i, sx)], 1<<b[P(i, sx)]);\n    }\n    \n    for(int j=0;j<M;j++){\n      if(sx!=j && g[sy][j]==1) res += dfs(b[P(sy, j)], 1<<b[P(sy, j)]);\n    }\n    \n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define operation(x, y) \\\n{\\\n\tif(house[y][x] >= 0 && !((visited >> house[y][x]) & 1)) {\t\\\n\t\tcan_pass[y][x] = true;\t\t\t\t\t\t\t\t\t\\\n\t\tres += dfs(x, y, (visited | (1 << house[y][x])));\t\t\\\n\t\tcan_pass[y][x] = false;\t\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\\\n\tif(!can_pass[y][x])\\\n\t\tbreak;\\\n}\n\nint w, h, num;\nint sx, sy;\nmap<pair<short, int>, int> memo;\nvector<vector<bool> > can_pass;\nvector<vector<short> > house;\n\nint dfs(int x, int y, int visited = 0) {\n\tif(visited == (1 << num) - 1)\n\t\tif(x == sx || y == sy)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\n\tif(memo.count(make_pair(house[y][x], visited)))\n\t\treturn memo[make_pair(house[y][x], visited)];\n\n\tint res = 0;\n\tfor(int i = x + 1; i < w; ++i)\n\t\toperation(i, y)\n\n\tfor(int i = x - 1; i >= 0; --i)\n\t\toperation(i, y)\n\n\tfor(int i = y + 1; i < h; ++i)\n\t\toperation(x, i)\n\n\tfor(int i = y - 1; i >= 0; --i)\n\t\toperation(x, i)\n\n\tif(__builtin_popcount(visited) < 19)\n\t\tmemo[make_pair(house[y][x], visited)] = res;\n\t\t\t\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tcan_pass.clear();\n\t\tcan_pass.resize(h, vector<bool>(w, false));\n\t\thouse.clear();\n\t\thouse.resize(h, vector<short>(w, -1));\n\n\t\tnum = 0;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\n\t\t\t\tif(in == 1) {\n\t\t\t\t\thouse[i][j] = num++;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tcan_pass[i][j] = true;\n\t\t\t\t\tif(in == 2) {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemo.clear();\n\t\tcout << dfs(sx, sy) << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define operation(x, y) \\\n{\\\n\tif(house[y][x] >= 0 && !((visited >> house[y][x]) & 1)) {\t\\\n\t\tcan_pass[y][x] = true;\t\t\t\t\t\t\t\t\t\\\n\t\tres += dfs(x, y, (visited | (1 << house[y][x])));\t\t\\\n\t\tcan_pass[y][x] = false;\t\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\\\n\tif(!can_pass[y][x])\\\n\t\tbreak;\\\n}\n\nint w, h, num;\nint sx, sy;\nmap<pair<short, int>, int> memo;\nvector<vector<bool> > can_pass;\nvector<vector<short> > house;\n\nint dfs(int x, int y, int visited = 0) {\n\tif(visited == (1 << num) - 1)\n\t\tif(x == sx || y == sy)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\n\tif(memo.count(make_pair(house[y][x], visited)))\n\t\treturn memo[make_pair(house[y][x], visited)];\n\n\tint res = 0;\n\tfor(int i = x + 1; i < w; ++i) \n\t\toperation(i, y)\n\n\tfor(int i = x - 1; i >= 0; --i)\n\t\toperation(i, y)\n\n\tfor(int i = y + 1; i < h; ++i)\n\t\toperation(x, i)\n\n\tfor(int i = y - 1; i >= 0; --i)\n\t\toperation(x, i)\n\n\treturn memo[make_pair(house[y][x], visited)] = res;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tcan_pass.clear();\n\t\tcan_pass.resize(h, vector<bool>(w, false));\n\t\thouse.clear();\n\t\thouse.resize(h, vector<short>(w, -1));\n\n\t\tnum = 0;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\n\t\t\t\tif(in == 1) {\n\t\t\t\t\thouse[i][j] = num++;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tcan_pass[i][j] = true;\n\t\t\t\t\tif(in == 2) {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemo.clear();\n\t\tcout << dfs(sx, sy) << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\ndeque<int> edge[24][4];\nint n;\nint dp[24][1 << 23];\nint dfs(int p, int visit)\n{\n\t//if (~dp[p][visit])\n\t//\treturn dp[p][visit];\n\t//else\n\t\tif (!visit)\n\t{\n\t\tbool f = false;\n\t\trep (i, 4)\n\t\t\tif (!edge[p][i].empty())\n\t\t\t\tf |= edge[p][i].front() == n;\n\t\treturn dp[p][visit] = f ? 1 : 0;\n\t}\n\n\tint res = 0;\n\trep (i, 4)\n\t{\n\t\tforeach (e, edge[p][i])\n\t\t{\n\t\t\tif (*e == n)\n\t\t\t\tcontinue;\n\t\t\tif (!(visit & (1 << *e)))\n\t\t\t\tbreak;\n\n\t\t\tres += dfs(*e, visit ^ (1 << *e));\n\t\t}\n\t}\n\n\treturn dp[p][visit] = res;\n}\nint main()\n{\n\tint h, w;\n\twhile (scanf(\"%d%d\", &w, &h), w | h)\n\t{\n\t\trep (i, 30)\n\t\t\trep (j, 4)\n\t\t\t\tedge[i][j].clear();\n\n\t\tpint church;\n\t\tvector<pint> pos;\n\t\trep (i, h)\n\t\t{\n\t\t\trep (j, w)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif (t == 1)\n\t\t\t\t\tpos.push_back(pint(j, i));\n\t\t\t\telse if (t == 2)\n\t\t\t\t\tchurch = pint(j, i);\n\t\t\t}\n\t\t}\n\t\tn = pos.size();\n\t\tpos.push_back(church);\n\n\t\trep (i, pos.size())\n\t\t{\n\t\t\tvector<pint> hor, ver;\n\t\t\trep (j, pos.size())\n\t\t\t{\n\t\t\t\tif (pos[i].first == pos[j].first)\n\t\t\t\t\tver.push_back(pint(pos[j].second, j));\n\t\t\t\telse if (pos[i].second == pos[j].second)\n\t\t\t\t\thor.push_back(pint(pos[j].first, j));\n\t\t\t}\n\t\t\tsort(all(hor));\n\t\t\tsort(all(ver));\n\n\t\t\tforeach (it, hor)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].first)\n\t\t\t\t\tedge[i][3].push_front(it->second);\n\t\t\t\telse if (pos[i].first < it->first)\n\t\t\t\t\tedge[i][1].push_back(it->second);\n\t\t\t}\n\t\t\tforeach (it, ver)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].second)\n\t\t\t\t\tedge[i][2].push_front(it->second);\n\t\t\t\telse if (pos[i].second < it->first)\n\t\t\t\t\tedge[i][0].push_back(it->second);\n\t\t\t}\n\t\t}\n\n\t\t//rep (i, n + 1)\n\t\t//{\n\t\t//\tprintf(\">%d: (%d, %d)\\n\", i, pos[i].first, pos[i].second);\n\t\t//\trep (j, 4)\n\t\t//\t{\n\t\t//\t\tprintf(\"%d: \", j);\n\t\t//\t\tforeach (t, edge[i][j])\n\t\t//\t\t\tprintf(\"(%d, %d) \", pos[*t].first, pos[*t].second);\n\t\t//\t\tputs(\"\");\n\t\t//\t}\n\t\t//}\n\n\t\tmemset(dp, ~0, sizeof(dp));\n\t\tint all_visit = (1 << n) - 1;\n\t\tprintf(\"%d\\n\", dfs(n, all_visit));\n\n\t\t//int s = 0;\n\t\t//rep (i, n)\n\t\t//\tif (~dp[i][0])\n\t\t//\t\ts += dp[i][0];\n\t\t//printf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 3004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint sum = 0, ans = 0, ky, kx, a[12][12], f[12][12];\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\n\nvoid dfs(int y, int x, int cnt){\n\tfor(int i = 0;i < 4;i++){\n\t\tint yy = y;\n\t\tint xx = x;\n\t\twhile(1){\n\t\t\tyy += dy[i];\n\t\t\txx += dx[i];\n\t\t\tif(a[yy][xx] == -1)break;\n\t\t\tif(a[yy][xx] == 1 && f[yy][xx] == 0){\n\t\t\t\tf[yy][xx] = 1;\n\t\t\t\tdfs(yy, xx, cnt+1);\n\t\t\t\tf[yy][xx] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a[yy][xx] == 2){\n\t\t\t\tif(cnt == sum){\n\t\t\t\t\tans++;\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nint main(){\n\tint w, h;\n\twhile(1){\n\t\tscanf(\"%d%d\",&w, &h);\n\t\tif(w == 0)break;\n\t\tfill((int*)a, (int*)(a+12), -1);\n\t\tfill((int*)f, (int*)(f+12), 0);\n\t\tsum = ans = 0;\n\t\trrep(i,h)rrep(j,w){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tif(a[i][j] == 2){ky = i;kx = j;}\n\t\t\tif(a[i][j] == 1)sum++;\n\t\t}\n\t\t\n\t\tdfs(ky, kx, 0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 11\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint s[MAX][MAX];\nint housInd[MAX][MAX];\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n//\tcout << \"hi\" << bit << endl;\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!isLast) {\n\t\t\t\t\tif ((bit & 1 << ind) == 0) {\n\t\t\t\t\t\tret += func(y, x, bit | (1 << ind));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tdp.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> grid;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nvi dir[24][4];\nmap<int,int> memo;\n\nint rec(int v, int bit, int n){\n  int key = (v<<24)+bit;\n  if(memo.find(key)!=memo.end())return memo[key];\n  if(v==0 && bit+1 == 1<<n)return 1;\n\n  int res = 0;\n  rep(d,4){\n    for(int u : dir[v][d]){\n      if( (bit>>u)&1 )break;\n      res += rec(u, bit | (1<<u),n);\n    }\n  }\n  if(__builtin_popcount(bit)>16)return res;\n  return memo[key] = res;\n}\n\nint main(){\n  int w,h;\n  while(cin >> w >> h, w){\n    grid g(h,vi(w));\n    \n    rep(i,h)rep(j,w)cin >> g[i][j];\n    \n    grid id(h,vi(w,-1));\n    int cnt = 1;\n    rep(i,h)rep(j,w){\n      if(g[i][j] == 2)id[i][j] = 0;\n      if(g[i][j] == 1)id[i][j] = cnt++;\n    }\n\n    rep(i,h)rep(j,w){\n      if(id[i][j]>=0){\n\trep(d,4){\n\t  dir[id[i][j]][d].clear();\n\n\t  int y = i+dy[d], x = j+dx[d];\n\t  while(range(y,0,h) && range(x,0,w)){\n\t    if(id[y][x]>=0)dir[id[i][j]][d].push_back(id[y][x]);\n\t    y += dy[d]; x += dx[d];\n\t  }\n\t}\n      }\n    }\n    \n    memo.clear();\n    cout << rec(0,0,cnt) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 16 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 11\n#define MAX_BITS 23\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint s[MAX][MAX];\nint housInd[MAX][MAX];\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n//\tcout << \"hi\" << bit << endl;\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!isLast) {\n\t\t\t\t\tif ((bit & 1 << ind) == 0) {\n\t\t\t\t\t\tret += func(y, x, bit | (1 << ind));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint H[10][10];\nint hx[24], hy[24];\nint *dp[1 << 24];\n\n\nint main() {\n\tint m, n;\n\twhile(scanf(\"%d%d\", &m, &n),m){\n        int cnt=1;\n        rep(i, n) {\n            rep(j, m) {\n                int h; scanf(\"%d\", &h);\n                H[i][j] = -1;\n                if (h == 1) {\n                    hx[cnt] = i; hy[cnt] = j;\n                    H[i][j] = cnt++;\n                }\n                if (h == 2) { H[i][j] = 0; hx[0] = i; hy[0] = j; }\n            }\n        }\n        rep(i,(1<<cnt)+1)dp[i]=new int[cnt];\n        dp[0][0] = 1;\n        rep(i, 1 << cnt) {\n            rep(j, cnt) {\n                if (!dp[i][j])continue;\n                if ((i | j) && !((i >> j) & 1))continue;\n                int x = hx[j], y = hy[j];\n                for (int k = 1; x + k < n; k++) {\n                    if (~H[x + k][y]) {\n                        if ((i >> H[x + k][y]) & 1)break;\n                        dp[i | (1 << H[x + k][y])][H[x + k][y]] += dp[i][j];\n                    }\n                }\n                for (int k = 1; x - k >= 0; k++) {\n                    if (~H[x - k][y]) {\n                        if ((i >> H[x - k][y]) & 1)break;\n                        dp[i | (1 << H[x - k][y])][H[x - k][y]] += dp[i][j];\n                    }\n                }\n                for (int k = 1; y + k < m; k++) {\n                    if (~H[x][y + k]) {\n                        if ((i >> H[x][y + k]) & 1)break;\n                        dp[i | (1 << H[x][y + k])][H[x][y + k]] += dp[i][j];\n                    }\n                }\n                for (int k = 1; y - k >= 0; k++) {\n                    if (~H[x][y - k]) {\n                        if ((i >> H[x][y - k]) & 1)break;\n                        dp[i | (1 << H[x][y - k])][H[x][y - k]] += dp[i][j];\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", dp[(1 << cnt) - 1][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef int ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nll w,h,g[10][10];\nll cx,cy;\ninline vector<P> doko(ll y,ll x){\n\tvector<P> v;\n\tfor(ll nx=x+1;nx<w;nx++){\n\t\tif(g[y][nx]==-1) break;\n\t\tif(g[y][nx]) v.push_back(P(y,nx));\n\t}\n\tfor(ll nx=x-1;nx>=0;nx--){\n\t\tif(g[y][nx]==-1) break;\n\t\tif(g[y][nx]) v.push_back(P(y,nx));\n\t}\n\tfor(ll ny=y+1;ny<h;ny++){\n\t\tif(g[ny][x]==-1) break;\n\t\tif(g[ny][x]) v.push_back(P(ny,x));\n\t}\n\tfor(ll ny=y-1;ny>=0;--ny){\n\t\tif(g[ny][x]==-1) break;\n\t\tif(g[ny][x]) v.push_back(P(ny,x));\n\t}\n\treturn v;\n}\nll n;\nll dfs(ll y,ll x,ll cnt){\n\tll res=0;\n\tvector<P> v=doko(y,x);\n\tif(cnt==n){\n\t\tfor(ll i=0;i<v.size();i++){\n\t\t\tif(g[v[i].first][v[i].second]==2) return 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(cnt) g[y][x]=-1;\n\tfor(ll i=0;i<v.size();i++){\n\t\tif(g[v[i].first][v[i].second]==2) continue;\n\t\tres+=dfs(v[i].first,v[i].second,cnt+1);\n\t}\n\tg[y][x]=1;\n\treturn res;\n}\n\nint main()\n{while(1){\n\tscanf(\"%d%d\",&w,&h);\n\tif(!w) return 0;\n\tfor(ll i=0;i<h;i++) for(ll j=0;j<w;j++){\n\t\tscanf(\"%d\",&g[i][j]);\n\t\tif(g[i][j]==2){\n\t\t\tcx=j,cy=i;\n\t\t}\n\t\telse if(g[i][j]) n++;\n\t}\n\tprintf(\"%d\\n\",dfs(cy,cx,0));\n}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\nconst int dx[]={1,-1,0,0};\nconst int dy[]={0,0,1,-1};\n\n\nint N,M;\nint temp[110][110];\nint feld[110][110];\nint cnt;\npii last;\nint ans;\n\nvoid dfs(int x,int y,int sum,int pdx,int pdy,bool down){\n    if(x<0||x>=N||y<0||y>=M){\n        return ;\n    }\n    //cout<<x<<\" \"<<y<<\" \"<<sum<<endl;\n    //if(t<100)cout<<\"--->\"<<endl;\n    if(feld[y][x]==1&&down)feld[y][x]=-1;\n    if(y==last.FI&&x==last.SE&&sum==cnt){\n        //cout<<\"Clear\"<<endl;\n        ans++;\n        return ;\n    }\n    if(feld[y][x]!=-1){\n        if(feld[y+pdy][x+pdx]==-1){\n            if(feld[y][x]==-1)feld[y][x]=1;\n            return;\n        }\n        else if(feld[y+pdy][x+pdx]==1){\n            dfs(x+pdx,y+pdy,sum+1,pdx,pdy,true);\n            dfs(x+pdx,y+pdy,sum,pdx,pdy,false);\n        }\n        else dfs(x+pdx,y+pdy,sum,pdx,pdy,false);\n    }\n    else if(feld[y][x]==-1){\n        if(down){\n            for(int i=0;i<4;++i){\n                int nx=x+dx[i];\n                int ny=y+dy[i];\n                if(feld[ny][nx]==-1)continue;\n                if(feld[ny][nx]==1){\n                    dfs(nx,ny,sum+1,dx[i],dy[i],true);\n                    dfs(nx,ny,sum,dx[i],dy[i],false);\n                }\n                else{\n                    dfs(nx,ny,sum,dx[i],dy[i],false);\n                }\n            }\n        }\n        else {\n            if(feld[y+pdy][x+pdx]==-1){\n                if(feld[y][x]==-1)feld[y][x]=1;\n                return;\n            }\n            else if(feld[y+pdy][x+pdx]==1){\n                dfs(x+pdx,y+pdy,sum+1,pdx,pdy,true);\n                dfs(x+pdx,y+pdy,sum,pdx,pdy,false);\n            }\n            else dfs(x+pdx,y+pdy,sum,pdx,pdy,false);\n        }\n    }\n    if(feld[y][x]==-1)feld[y][x]=1;\n    return ;\n}\n\n\nsigned main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(feld,0,sizeof(feld));\n        for(int i=0;i<M;++i){\n            for(int j=0;j<N;++j){\n                cin>>feld[i][j];\n                if(feld[i][j]==2){\n                    last.FI=i;\n                    last.SE=j;\n                }\n                else if(feld[i][j]!=0)cnt++;\n            }\n        }\n        for(int i=0;i<4;++i)dfs(last.SE,last.FI,0,dx[i],dy[i],false);\n        cout<<ans<<endl;\n        ans=0;\n        cnt=0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<P, int>dp;\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[{1 << dat[nx][ny], dat[nx][ny]}] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0, o = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[{i, j}];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++o >= 1000)dp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int nposmax = 10;\nconst int bitmax = 1<<20;\n//bit????????????\nint dp[nposmax][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax&&now<nposmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\tif(bit<bitmax&&now<nposmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint h,w;\nint f[10][10];\n\nint ct;\nint x[24],y[24];\n\nunordered_map<int,int> dp;\nint dfs(int s)\n{\n    if(dp.count(s)) return dp[s];\n\n    int mask = s>>5;\n    int now = s&31;\n\n    vector<int> nx;\n    int X=x[now], Y=y[now];\n\n    X = x[now]+1;\n    while(X<w)\n    {\n        if(f[Y][X]>=0)\n        {\n            if(mask>>f[Y][X]&1) break;\n            nx.pb(f[Y][X]);\n        }\n        ++X;\n    }\n    X = x[now]-1;\n    while(X>=0)\n    {\n        if(f[Y][X]>=0)\n        {\n            if(mask>>f[Y][X]&1) break;\n            nx.pb(f[Y][X]);\n        }\n        --X;\n    }\n\n    X = x[now];\n    Y = y[now]+1;\n    while(Y<h)\n    {\n        if(f[Y][X]>=0)\n        {\n            if(mask>>f[Y][X]&1) break;\n            nx.pb(f[Y][X]);\n        }\n        ++Y;\n    }\n    Y = y[now]-1;\n    while(Y>=0)\n    {\n        if(f[Y][X]>=0)\n        {\n            if(mask>>f[Y][X]&1) break;\n            nx.pb(f[Y][X]);\n        }\n        --Y;\n    }\n\n    // ??¶?????????????????£?????????????????°????????????\n    if(mask == (1<<ct)-1-1)\n    {\n        if(find(all(nx),0) != nx.end()) return 1;\n        else return 0;\n    }\n\n    int ret=0;\n    for(const auto &p:nx)\n    {\n        if(p==0) continue;\n\n        int nmask = mask|(1<<p);\n        int nxt = (nmask<<5) | p;\n        ret += dfs(nxt);\n    }\n\n    dp[s]=ret;\n    return ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d\", &w, &h),h)\n    {\n        ct=1;\n        rep(i,h)rep(j,w)\n        {\n            scanf(\" %d\", &f[i][j]);\n            if(f[i][j]==1)\n            {\n                f[i][j] = ct;\n                x[ct] = j;\n                y[ct] = i;\n                ++ct;\n            }\n            else if(f[i][j]==2)\n            {\n                f[i][j] = 0;\n                x[0] = j;\n                y[0] = i;\n            }\n            else f[i][j]=-1;\n        }\n\n        dp.clear();\n        printf(\"%d\\n\", dfs(0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;}\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n    if( st_now.cnt + 5 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    \n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !st_now.checkvis( houseId[next.fr][next.sc] ) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.setvis( houseId[next.fr][next.sc] );\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W, C, sx, sy; vector<vector<int> > M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint solve(int x, int y, int d, vector<vector<bool> > used)\n{\n\tif (d == C && x == sx && y == sy) { return 1; }\n\n\tint ret = 0;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint x2 = x + dx[dir];\n\t\tint y2 = y + dy[dir];\n\n\t\twhile (0 <= x2 && x2 < W && 0 <= y2 && y2 < H)\n\t\t{\n\t\t\tif (used[y2][x2])\n\t\t\t{\n\t\t\t\tvector<vector<bool> > used2(used.begin(), used.end()); used2[y2][x2] = false;\n\n\t\t\t\tret += solve(x2, y2, d + 1, used2); break;\n\t\t\t}\n\t\t\t\n\t\t\tx2 += dx[dir];\n\t\t\ty2 += dy[dir];\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tM = vector<vector<int> >(H, vector<int>(W));\n\n\t\tvector<vector<bool> > start(H, vector<bool>(W, false)); C = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &M[i][j]);\n\n\t\t\t\tif (M[i][j] != 0) { C++; start[i][j] = true; }\n\n\t\t\t\tif (M[i][j] == 2) { sx = j; sy = i; }\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", solve(sx, sy, 0, start));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<map>\nusing namespace std;\n\nint a, b, c[10][10];//0 ??¶ 1 ????????° 2 ???????????? 3????????????\nint f, g;\nint S;\nint dx[4] = { -1,0,0,1 }, dy[4] = { 0,-1,1,0 };\nvoid saiki(int x,int y,int sum) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int j = 1;; j++) {\n\t\t\tint p = x + dx[i] * j, q = y + dy[i] * j;\n\t\t\tif (p < 0 || p >= a || q < 0 || q >= b)break;\n\t\t\tif (c[p][q] == 1) {\n\t\t\t\tc[p][q] = 0;\n\t\t\t\tsaiki(p, q,sum-1);\n\t\t\t\tc[p][q] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (c[p][q] == 2 && sum == 0) { S++; break; }\n\t\t}\n\t}\n}\nint main() {\n\twhile (cin >> b >> a, a | b) {\n\t\tS = 0; int k = 0;\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\tfor (int e = 0; e < b; e++) {\n\t\t\t\tscanf(\"%d\", &c[d][e]);\n\t\t\t\tif (c[d][e] == 2) { f = d; g = e; }\n\t\t\t\telse if (c[d][e] == 1)k++;\n\t\t\t}\n\t\t}\n\t\tsaiki(f, g, k);\n\t\tcout << S << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\nint CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\nbool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool CanDown(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\treturn memo[state] = sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tint a[12][12];\n\t\t\n\t\tscanf(\"%d%d\",&m,&n); if(m == 0 && n == 0)break;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint x[25],y[25];\n\t\tint k = 1;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tif(a[i][j] == 1){\n\t\t\t\t\tx[k] = i;\n\t\t\t\t\ty[k] = j;\n\t\t\t\t\tk ++;\n\t\t\t\t}\n\t\t\t\telse if(a[i][j] == 2){\n\t\t\t\t\tx[0] = i;\n\t\t\t\t\ty[0] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> G[25];\n\t\tint d[25][25];\n\t\trep(i,k){\n\t\t\tfor(int j = i+1 ; j < k ; j ++){\n\t\t\t\tif(x[i] == x[j]){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\trep(t,k){\n\t\t\t\t\t\tif(x[t] == x[i] && (y[t]-y[i])*(y[t]-y[j]) < 0){\n\t\t\t\t\t\t\td[i][j] |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tG[i].pb( j );\n\t\t\t\t\tG[j].pb( i );\n\t\t\t\t}\n\t\t\t\telse if(y[i] == y[j]){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\trep(t,k){\n\t\t\t\t\t\tif(y[t] == y[i] && (x[t]-x[i])*(x[t]-x[j]) < 0){\n\t\t\t\t\t\t\td[i][j] |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tG[i].pb( j );\n\t\t\t\t\tG[j].pb( i );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\td[i][j] = (1 << k)-1;\n\t\t\t\t}\n\t\t\t\td[j][i] = d[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<P,int> dp;\n\t\tint ret = 0;\n\t\t\n\t\trep1(i,k-1){\n\t\t\tif(x[i] == x[0] || y[i] == y[0]){\n\t\t\t\tdp.insert( P1( P ( 1 << i , i ) , 1 ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<P,int>::iterator itr = dp.begin();\n\t\twhile(itr != dp.end()){\n\t\t\tif((*itr).fr.sc == 0){\n\t\t\t\tif((*itr).fr.fr == (1 << k) -1){\n\t\t\t\t\tret += (*itr).sc;\n\t\t\t\t}\n\t\t\t\titr ++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,G[(*itr).fr.sc].size()){\n\t\t\t\tint i = G[(*itr).fr.sc][j];\n\t\t\t\tif(((*itr).fr.fr >> i)&1)continue;\n\t\t\t\tif((d[(*itr).fr.sc][i] & (*itr).fr.fr) == 0){\n\t\t\t\t\tdp[ P ( (*itr).fr.fr | (1 << i) , i ) ] += (*itr).sc;\n\t\t\t\t}\n\t\t\t}\n\t\t\titr ++;\n\t\t}\n\t\t\t\t\n\t\t\n\t\t/*queue<P> que;\n\t\t\n\t\trep1(i,k-1){\n\t\t\tif(x[i] == x[0] || y[i] == y[0]){\n\t\t\t\tque.push( P ( i , 1 << i ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.front(); que.pop();\n\t\t\tif(p.fr == 0){\n\t\t\t\tif(p.sc == (1 << k)-1)ret ++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i,k){\n\t\t\t\tif((p.sc >> i)&1)continue;\n\t\t\t\tif((d[p.fr][i] & p.sc) == 0){\n\t\t\t\t\tque.push( P ( i , p.sc | (1 << i) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h,int k){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny],k-1);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) < 15) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    //cout << solve(1,0,c) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(char si, char sj, char cnt, int vis):ni(si),nj(sj),cnt(cnt),vis(vis){}\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n/*\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n*/\n\nstruct Queue{\n  int p;\n  state *V;\n  Queue():p(0){V=new state[1<<20];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){\n    V[p++]=t;\n  }\n  state & front(){\n    return V[p-1];\n  }\n  void pop(){--p;}\n  bool empty(){\n    return p==0;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  int ni,nj;\n  int housenum=0;\n  int chi=charch.fr;int chj=charch.sc;\n  \n  for(int k = 0; k < MAXDIR; ++k){\n    housenum += M[chi][chj].linkmax[k];\n  }\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    ni = st_now.ni;\n    nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    //if( st_now.cnt >= 0 ){\n      int left = housenum;\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n      //}\n\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\tpi next = M[ni][nj].link[k][v];\n\tif( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t  qs.push( state(next.fr,next.sc,st_now.cnt + 1,st_now.vis|( 1<<houseId[next.fr][next.sc])));\n\t  break;\n\t}\n      }\n    }\n\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc,0,0);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\t//for(int w,h;cin>>w>>h,w|h;){\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w|h;){\n\t\t//clock_t begin=clock();\n\t\t\n\t\tvvi field(h,vi(w));\n\t\trep(i,h) rep(j,w)\n\t\t\t//cin>>field[i][j];\n\t\t\tscanf(\"%d\",&field[i][j]);\n\t\t\n\t\tvector<pii> homes;\n\t\tint counter=0;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(field[i][j]==1){\n\t\t\t\tfield[i][j]=++counter;\n\t\t\t\thomes.push_back(mp(i,j));\n\t\t\t}\n\t\t\telse if(field[i][j]==2){\n\t\t\t\tfield[i][j]=0;\n\t\t\t\thomes.insert(homes.begin(),mp(i,j));\n\t\t\t}\n\t\t\telse\n\t\t\t\tfield[i][j]=-1;\n\t\t}\n\t\t\n\t\tmap<pair<int,int>,int> m;\n\t\tm[mp(1,0)]=1;\n\t\tforeach(iter,m){\n\t\t\tm.erase(m.begin(),iter);\t// svÉÈÁ½vfðÁ³È¢ÆMLEÉÈé\n\t\t\t\n\t\t\tint state=iter->first.first;\n\t\t\tint prev=iter->first.second;\n\t\t\tif(state==(1<<homes.size())-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tconst int di[]={-1,1,0,0};\n\t\t\tconst int dj[]={0,0,-1,1};\n\t\t\trep(i,4){\n\t\t\t\tint pi=homes[prev].first,pj=homes[prev].second;\n\t\t\t\tfor(;;){\n\t\t\t\t\tpi+=di[i];\n\t\t\t\t\tpj+=dj[i];\n\t\t\t\t\tif(pi<0 || h<=pi || pj<0 || w<=pj)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint homei=field[pi][pj];\n\t\t\t\t\tif(homei>=1 && !(state&(1<<homei))){\n\t\t\t\t\t\tm[mp(state|(1<<homei),homei)]+=iter->second;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tforeach(iter,m){\n\t\t\tint prev=iter->first.second;\n\t\t\tint pi=homes[prev].first,pj=homes[prev].second;\n\t\t\tif(pi==homes[0].first || pj==homes[0].second)\n\t\t\t\tres+=iter->second;\n\t\t}\n\t\t//cout<<res<<endl;\n\t\tprintf(\"%d\\n\",res);\n\t\t\n\t\t//printf(\"time: %ldms\\n\",clock()-begin);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    if(ni==t.ni){\n      if(nj==t.nj){\n\treturn vis<t.vis;\n      }else return nj < t.nj;\n    }else return ni < t.ni;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n    \n    //cout << \"CNT: \" << (int)st_now.cnt << endl;\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    if( st_now.cnt >= 8 ){\n      int left = 0;\n      int chi=charch.fr;int chj=charch.sc;\n      for(int k = 0; k < MAXDIR; ++k){\n\tleft += M[chi][chj].link[k].size();\n      }\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n    }\n\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.cnt++;\n\t    st_next.vis |= ( 1<<houseId[next.fr][next.sc] );\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int MAX = 10;\nconst int MAX_N = 23;\nconst int G = 23;\nconst int dy[] = {1,0,-1,0};\nconst int dx[] = {0,1,0,-1};\n\nint mask[MAX_N+1][MAX_N+1];\nshort node_id[MAX_N+1][MAX_N+1];\nshort grid[MAX][MAX];\n\nint H,W,N;\nint dp[MAX_N][(1 << MAX_N)];\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> grid[i][j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_N+1 ; i++){\n    for(int j = 0 ; j < MAX_N+1 ; j++){      \n      node_id[i][j] = -1;\n      mask[i][j] = -1;\n    }\n  }\n}\n\nvoid makeMask(){\n  N = 0;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] == 1)node_id[i][j] = N++;\n      if(grid[i][j] == 2)node_id[i][j] = G;\n    }\n  }\n  \n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] != 0){\n\tfor(int d = 0 ; d < 4 ; d++){\n\t  int x = j;\n\t  int y = i;\n\t  int bit = 0;\n\t  while(1){\n\t    x += dx[d]; y += dy[d];\n\t    if(!(0 <= x && x < W && 0 <= y && y < H))break;\n\t    if(node_id[y][x] == -1)continue;\n\t    if(node_id[y][x] != G){\n\t      bit |= (1 << node_id[y][x]);\n\t    }\n\t    mask[node_id[i][j]][node_id[y][x]] = bit;\n\t    //cout <<\"from = \" << node_id[i][j] << \" to = \" << node_id[y][x] <<  \" bit = \" << bit << endl;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H,H|W){\n\n    init();\n    input();\n    makeMask();\n    \n    // dp init\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = 0;\n      }\n    }\n    \n    // dp start\n    for(int i = 0 ; i < N ; i++){\n      if(mask[G][i] != -1)dp[i][(1 << i)] = 1;\n    }\n    \n    //cout << \"N = \" << N << endl;\n    for(int i = 0 ; i < (1 << N) ; i++){\n      for(int j = 0 ; j < N ; j++){\n\t//if(dp[i][j] == 0)continue;\n\tfor(int k = 0 ; k < N ; k++){\n\t  //cout <<\"mask = \" <<  mask[j][k] << endl;\n\t  if((mask[j][k] & i) == 0){\n\t    dp[k][i|(1 << k)] += dp[j][i];\n\t  }\n\t}\n      }\n    }\n\n    // dp goal\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      if(mask[i][G] != -1 && ((mask[i][G]&((1 << N)-1)) == 0))res += dp[i][(1 << N)-1];\n    }\n    cout << res << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   (a >> b) & 1\n#define bitset(a,b)       a |= (1 << b)\n#define bitunset(a,b)    a &= ~(1 << b)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w,h;\n\tscanf(\"%d %d\", &w, &h);\n\tvector<vector<int>> mp(w,vector<int>(h,-1));\n\tpii cha;\n\tvector<pii> homp;\n\tint homc = 0;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tint a = 0;\n\t\t\tscanf(\"%d\", &a);\n\t\t\tif (a == 2) {\n\t\t\t\tcha = { j,i };\n\t\t\t}\n\t\t\tif (a == 1) {\n\t\t\t\thomp.push_back({ j,i });\n\t\t\t\tmp[j][i] = homc;\n\t\t\t\thomc++;\n\t\t\t}\n\t\t}\n\t}\n\thomp.push_back(cha);\n\tmap<pii, int> dp[2];//?±\\??´????????¨??°\n\tdp[0][{0, homc}] = 1;\n\tbool t = 0;\n\tREP(i,homc){\n\t\tfor(auto cur : dp[t]) {\n\t\t\tpii curpos = homp[cur.first.second];\n\t\t\tint cnum;\n\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\tif (cnum == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\tbreak;\n\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t}\n\t\t}\n\t\tdp[t].swap(map<pii,int>());\n\t\tt = 1 - t;\n\t}\n\tint cnum,ans = 0;\n\tset<int> targets;\n\tfor (int j = cha.first; w > j; j++) {\n\t\tcnum = mp[j][cha.second];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.first; 0 <= j; j--) {\n\t\tcnum = mp[j][cha.second];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.second; h > j; j++) {\n\t\tcnum = mp[cha.first][j];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int j = cha.second; 0 <= j; j--) {\n\t\tcnum = mp[cha.first][j];\n\t\tif (cnum > -1) {\n\t\t\ttargets.insert(cnum);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (auto cur : dp[t]) {\n\t\tif(targets.find(cur.first.second) != targets.end())\n\t\t\tans += cur.second;\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nvector<pair<int,int> > house;\nvector<pair<int,int>> way[23];\nint ok[23];\n\nint solve(int i, int j){\n\tif(i == (1<<house.size())-1) return ok[j];\n\tint ans = 0;\n\tif((i&(1<<j)) == 0) return 0;\n\tbool flg = true;\n\tfor(int k=way[j].size()-1; k>=0; k--){\n\t\tif(way[j][k] == MP(-1,-1)){\n\t\t\tflg = true;\n\t\t\tcontinue;\n\t\t}\n\t\tif(flg == false) continue;\n\t\tif((i&way[j][k].second) == way[j][k].second && (i&(1<<way[j][k].first)) == 0){\n\t\t\tans += solve(i+(1<<way[j][k].first), way[j][k].first);\n\t\t\tflg = false;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tiostream::sync_with_stdio(false);\n\n\tSTART:\n\t\n\tint m,n;\n\tcin >> m >> n;\n\tif(n == 0 && m == 0) return 0;\n\tint a[10][10];\n\thouse.clear();\n\tpair<int,int> kyokai;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j] == 0) a[i][j] = -1; //空地\n\t\t\telse if(a[i][j] == 2){\n\t\t\t\ta[i][j] = -2; //教会\n\t\t\t\tkyokai = MP(i,j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i][j] = house.size();\n\t\t\t\thouse.push_back(MP(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\t//経路計算\n\tfor(int i=0; i<house.size(); i++){\n\t\tway[i].clear();\n\t\tint x = house[i].first;\n\t\tint y = house[i].second;\n\t\tint tmp = 0;\n\t\tfor(int j=x+1; j<n; j++){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=x-1; j>=0; j--){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=y+1; j<m; j++){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t\tway[i].push_back(MP(-1,-1));\n\t\ttmp = 0;\n\t\tfor(int j=y-1; j>=0; j--){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t}\n\n\t//教会隣接家dp初期化\n\tfor(int i=0; i<house.size(); i++){\n\t\tok[i] = 0;\n\t}\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tok[a[i][kyokai.second]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tok[a[i][kyokai.second]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tok[a[kyokai.first][i]] = 1;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tok[a[kyokai.first][i]] = 1;\n\t\t}\n\t}\n\n\t//最終的な答え\n\tint ans = 0;\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += solve(1<<a[i][kyokai.second],a[i][kyokai.second]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += solve(1<<a[i][kyokai.second],a[i][kyokai.second]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += solve(1<<a[kyokai.first][i],a[kyokai.first][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += solve(1<<a[kyokai.first][i],a[kyokai.first][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\tgoto START;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <set>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nclass Edge{\npublic:\n    bool isAccess;\n    bitset<24> pass;\n    Edge(){\n        isAccess = false;\n    }\n};\n\nint n;\nvector<vector<Edge> > edges;\n\nint dfs(int curr, bitset<24> bs){\n    if(curr == 0 && bs.any()){\n        if(bs.count() == n)\n            return 1;\n        else\n            return 0;\n    }\n\n    int ret = 0;\n    for(int i=0; i<n; ++i){\n        if(bs[i] || !edges[curr][i].isAccess)\n            continue;\n        if((~bs & edges[curr][i].pass).any())\n            continue;\n        bs[i] = true;\n        ret += dfs(i, bs);\n        bs[i] = false;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        n = 1;\n        vector<int> y(1), x(1);\n        vector<vector<int> > grid(h, vector<int>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> grid[i][j];\n                if(grid[i][j] == 1){\n                    y.push_back(i);\n                    x.push_back(j);\n                    grid[i][j] = n;\n                    ++ n;\n                }else if(grid[i][j] == 2){\n                    y[0] = i;\n                    x[0] = j;\n                    grid[i][j] = 0;\n                }else{\n                    grid[i][j] = -1;\n                }\n            }\n        }\n\n        edges.assign(n, vector<Edge>(n, Edge()));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                int y1 = y[i] + dy[j];\n                int x1 = x[i] + dx[j];\n                bitset<24> bs;\n                while(0 <= y1 && y1 < h && 0 <= x1 && x1 < w){\n                    if(grid[y1][x1] != -1){\n                        int k = grid[y1][x1];\n                        edges[i][k].isAccess = true;\n                        edges[i][k].pass = bs;\n                        if(k != 0)\n                            bs[k] = true;\n                    }\n                    y1 += dy[j];\n                    x1 += dx[j];\n                }\n            }\n        }\n\n        cout << dfs(0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<int, unordered_map<int, int>>dp;\n\t\tauto F = [&](int x, int y, int s, int r) {\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x, ny = y; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(r >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[r | 1 << dat[nx][ny]][dat[nx][ny]] += s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tF(sx, sy, 1, 0);\n\t\tint ans = 0;\n\t\trep(i, 1 << p) {\n\t\t\trep(j, p) {\n\t\t\t\tif (dp[i].find(j) == dp[i].end())continue;\n\t\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tF(x[j], y[j], dp[i][j], i);\n\t\t\t}\n\t\t\tdp.erase(i);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\ninline bool in(int x, int y, int w, int h)\n{\n\treturn x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint main()\n{\n\twhile(true) {\n\t\t\n\t\tint w, h, n;\n\t\tint field[16][16];\n\t\tvector<pair<int, int> > house;\n\t\tpair<int, int> church;\n\t\t\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif(t == 0) {\n\t\t\t\t\tt = -1;\n\t\t\t\t} else if(t == 1) {\n\t\t\t\t\tt = house.size();\n\t\t\t\t\thouse.push_back(make_pair(x, y));\n\t\t\t\t} else if(t == 2) {\n\t\t\t\t\tt = -2;\n\t\t\t\t\tchurch = make_pair(x, y);\n\t\t\t\t}\n\t\t\t\tfield[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tn = house.size();\n\t\t\n\t\tint reach[23][23];\n\t\tvector<int> from[23];\n\t\tint dx[] = {-1, 0, 0, 1}, dy[] = {0, -1, 1, 0};\n\t\tmap<pair<int, int>, int> dp;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tdp[make_pair(1 << tgt, tgt)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int a = 0; a < n; ++a) {\n\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\n\t\t\t\tif(a == b)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\treach[a][b] = (1 << a) | (1 << b);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\t\n\t\t\t\t\tint cx = house[a].first, cy = house[a].second;\n\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tint t = field[cx][cy];\n\t\t\t\t\t\tif(t == b) {\n\t\t\t\t\t\t\treach[a][b] = bit;\n\t\t\t\t\t\t\tfrom[a].push_back(b);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(t >= 0) {\n\t\t\t\t\t\t\tbit |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 1; bit < (1 << n); ++bit) {\n\t\t\t\n\t\t\tfor(int a = 0; a < n; ++a) {\n\t\t\t\t\n\t\t\t\tif((bit & (1 << a)) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint prev = bit ^ (1 << a);\n\t\t\t\t\n\t\t\t\tfor(int bi = 0; bi < from[a].size(); ++bi) {\n\t\t\t\t\t\n\t\t\t\t\tint b = from[a][bi];\n\t\t\t\t\t\n\t\t\t\t\tif(((prev & (1 << b)) == 0) && ((prev & reach[a][b]) != 0)) {\n\t\t\t\t\t\n\t\t\t\t\t\tmap<pair<int, int>, int>::iterator it = dp.find(make_pair(prev, b));\n\t\t\t\t\t\tif(it != dp.end())\n\t\t\t\t\t\t\tdp[make_pair(bit, a)] += it->second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tans += dp[make_pair((1 << n) - 1, tgt)];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 7 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstring to_binary(int n)\n{\n\tif(n==0)\n\t\treturn \"0\";\n\tstring res;\n\twhile(n){\n\t\tres+='0'+(n&1);\n\t\tn>>=1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvi field(h,vi(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>field[i][j];\n\t\t\n\t\tvector<pii> homes;\n\t\tint counter=0;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(field[i][j]==1){\n\t\t\t\tfield[i][j]=++counter;\n\t\t\t\thomes.push_back(mp(i,j));\n\t\t\t}\n\t\t\telse if(field[i][j]==2){\n\t\t\t\tfield[i][j]=0;\n\t\t\t\thomes.insert(homes.begin(),mp(i,j));\n\t\t\t}\n\t\t\telse\n\t\t\t\tfield[i][j]=-1;\n\t\t}\n\t\t\n\t\tmap<pair<int,int>,int> m;\n\t\tm[mp(1,0)]=1;\n\t\tforeach(iter,m){\n\t\t\tint state=iter->first.first;\n\t\t\tint prev=iter->first.second;\n\t\t\tif(state==(1<<homes.size())-1)\n\t\t\t\tbreak;\n\t\t\tconst int di[]={-1,1,0,0};\n\t\t\tconst int dj[]={0,0,-1,1};\n\t\t\trep(i,4){\n\t\t\t\tint pi=homes[prev].first,pj=homes[prev].second;\n\t\t\t\tfor(;;){\n\t\t\t\t\tpi+=di[i];\n\t\t\t\t\tpj+=dj[i];\n\t\t\t\t\tif(pi<0 || h<=pi || pj<0 || w<=pj)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint homei=field[pi][pj];\n\t\t\t\t\tif(homei>=1){\n\t\t\t\t\t\tif(state&(1<<homei))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tm[mp(state|(1<<homei),homei)]+=iter->second;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(iter(m) iter=m.lower_bound(mp((1<<homes.size())-1,0));iter!=m.end();iter++){\n\t\t\tint prev=iter->first.second;\n\t\t\tint pi=homes[prev].first,pj=homes[prev].second;\n\t\t\tif(pi==homes[0].first || pj==homes[0].second)\n\t\t\t\tres+=iter->second;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 19;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX && !(cnt >= 17 && sum == 0)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[12][12],sx,sy,n;\nint fn(int x,int y,int p){\n  int i;\n  int ct=0;\n  if(p==n){\n    if(x==sx||y==sy)\n      ct=1;\n  }else{\n    a[x][y]=0;\n    for(i=1;a[x+i][y]==0;i++);\n    if(a[x+i][y]!=-1)\n      ct+=fn(x+i,y,p+1);\n    for(i=1;a[x-i][y]==0;i++);\n    if(a[x-i][y]!=-1)\n      ct+=fn(x-i,y,p+1);\n    for(i=1;a[x][y+i]==0;i++);\n    if(a[x][y+i]!=-1)\n      ct+=fn(x,y+i,p+1);\n    for(i=1;a[x][y-i]==0;i++);\n    if(a[x][y-i]!=-1)\n      ct+=fn(x,y-i,p+1);\n    a[x][y]=1;\n  }\n  return ct;\n}\nint main(){\n  int i,j;\n  int w,h;\n  while(cin>>w>>h&&(w||h)){\n    memset(a,-1,sizeof(a));\n    n=0;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>a[j][i];\n\tif(0){\n\t}else if(a[j][i]==1){\n\t  n++;\n\t}else if(a[j][i]==2){\n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    cout<<fn(sx,sy,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint kari[32];\nvector<pair<int,int> > v;\n\n#if DEB\nstack<int> st;\n#endif\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( s==a.s ){\n      if( x==a.x ) return y<a.y;\n      else         return x<a.x;\n    }else{\n      return s<a.s;\n    }\n  }\n  \n};\n\nmap<state,int> msi;\n\ninline int numofbits(int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline int isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (kari[i]&s)==kari[i] ) return i;\n  }\n  return -1;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int mask = (1<<home)-1;\n  // v[gªu¯È¢ÆÌL³\n  if( s>0 && numofbits(~s&mask)>1 && isnot(s&~(1<<num[y][x]))!=-1 ){\n#if DEB\n    printf(\"s:%d ,(%d,%d)  __%d  ___isnot:%d\\n\",s,x,y,s&~num[y][x],isnot(s&~num[y][x]));\n    stack<int> tmp = st;\n    while( !tmp.empty() ){\n      printf(\"%d,\",tmp.top());\n      tmp.pop();\n    }\n    puts(\"\\n\");\n#endif\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\n#if DEB\n\tst.pop();\n#endif\n\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    v.clear();\n    memset(num,-1,sizeof(num));\n    memset(kari,0,sizeof(kari));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t  v.pb(mp(j,i));\n\t}\n      }\n    }\n\n    // other homes\n    rep(i,v.size()){\n      rep(k,4){\n\tfor(int j=1; j<20; j++){\n\t  int tx = v[i].first + dx[k]*j;\n\t  int ty = v[i].second + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    kari[i] |= (1<<num[ty][tx]);\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n#if DEB\n    printf(\"sz:%d\\n\",v.size());\n    printf(\"last:%d\\n\",last);\n    rep(i,v.size()){\n      printf(\"home:%d  , %d\\n\",i,kari[i]);\n    }\n#endif\n    \n    \n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint W, He, H, S;\n\nvector<pii>h;\n\nint m[101][101];\n\nint im[101][101];\n\nint rec(int n, int state){\n\n\tif(state == (1 << H) - 1){\n\n\t\tint reach = 0;\n\t\tREP(i, 1, He){\n\t\t\tif(h[n].first + i >= He)\n\t\t\t\tbreak;\n\t\t\tif(im[h[n].first + i][h[n].second] == 0){\n\t\t\t\treach = 1;\n\t\t\t}\n\n\t\t}\n\t\tREP(i, 1, He){\n\t\t\tif(h[n].first - i < 0)\n\t\t\t\tbreak;\n\t\t\tif(im[h[n].first - i][h[n].second] == 0){\n\t\t\t\treach = 1;\n\t\t\t}\n\n\t\t}\n\t\tREP(i, 1, W){\n\t\t\tif(h[n].second + i >= W){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(im[h[n].first][h[n].second + i] == 0){\n\t\t\t\treach = 1;\n\t\t\t}\n\n\t\t}\n\t\tREP(i, 1, W){\n\t\t\tif(h[n].second - i < 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(im[h[n].first][h[n].second - i] == 0){\n\t\t\t\treach = 1;\n\t\t\t}\n\n\t\t}\n\n\t\treturn reach;\n\t}\n\n\tint ans=0;\n\n\tREP(i, 1, He){\n\t\tif(h[n].first + i >= He)\n\t\t\tbreak;\n\t\tif(im[h[n].first + i][h[n].second] != -1){\n\t\t\tif(!((state >> im[h[n].first + i][h[n].second]) & 1)){\n\t\t\t\tans += rec(im[h[n].first + i][h[n].second], state | (1 << im[h[n].first + i][h[n].second]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, 1, He){\n\t\tif(h[n].first - i < 0)\n\t\t\tbreak;\n\t\tif(im[h[n].first - i][h[n].second] != -1){\n\t\t\tif(!((state >> im[h[n].first - i][h[n].second]) & 1)){\n\t\t\t\tans += rec(im[h[n].first - i][h[n].second], state | (1 << im[h[n].first - i][h[n].second]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, 1, W){\n\t\tif(h[n].second + i >= W){\n\t\t\tbreak;\n\t\t}\n\t\tif(im[h[n].first][h[n].second + i] != -1){\n\t\t\tif(!((state >> im[h[n].first][h[n].second + i]) & 1)){\n\t\t\t\tans += rec(im[h[n].first ][h[n].second + i], state | (1 << im[h[n].first ][h[n].second + i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, 1, W){\n\t\tif(h[n].second - i < 0){\n\t\t\tbreak;\n\t\t}\n\t\tif(im[h[n].first][h[n].second - i] != -1){\n\t\t\tif(!((state >> im[h[n].first ][h[n].second - i]) & 1)){\n\t\t\t\tans += rec(im[h[n].first][h[n].second - i], state | (1 << im[h[n].first ][h[n].second -i]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//cout << ans << endl;\n\n\treturn ans;\n}\n\nint main(){\n\n\twhile(cin >> W >> He, (W && He)){\n\n\t\th.clear();\n\n\t\tmemset(m, -1, sizeof(m));\n\n\t\trep(i, He){\n\t\t\trep(j, W){\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tif(m[i][j]==1){\n\t\t\t\t\th.pb(mp(i, j));\n\t\t\t\t}else if(m[i][j]==2){\n\t\t\t\t\th.insert(h.begin(), mp(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tH=h.size();\n\n\t\tmemset(im, -1, sizeof(im));\n\n\t\trep(i, H){\n\t\t\tim[h[i].first][h[i].second] = i;\n\t\t}\n\t\tcout << rec(0, 1) << endl;\n\n\t}\n\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tunordered_map<int, unordered_map<char, int>>dp;\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[1 << dat[nx][ny]][dat[nx][ny]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find(i) == dp.end() || dp[i].find(j) == dp[i].end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[i | 1 << dat[nx][ny]][dat[nx][ny]] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint m,n,k=0;\nint a[15][15],c[15][15],d[15][15],sh[15],sw[15];\nvector<int> h[15],w[15];\nint ans=0,locx,locy;\n\nint solve(int x,int y){\n\tint ret=0;\n\tbool b=false;\n\tif(a[x][y]==1){a[x][y]=3; b=true; k--;}\n\tif(k==0){\n\t\ta[x][y]=1; k++;\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<1<<endl;\n\t\tfor(int i=c[x][y]-1;i>=0;i--){\n\t\t\t//if(a[h[y][i]][y]==3)break;\n\t\t\tif(a[h[y][i]][y]==2)return 1;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=c[x][y]+1;i<sh[y];i++){\n\t\t\t//if(a[h[y][i]][y]==3)break;\n\t\t\tif(a[h[y][i]][y]==2)return 1;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int j=d[x][y]-1;j>=0;j--){\n\t\t\t//if(a[x][w[x][j]]==3)break;\n\t\t\tif(a[x][w[x][j]]==2)return 1;\n\t\t\tbreak;\n\t\t}\n\t\tfor(int j=d[x][y]+1;j<sw[x];j++){\n\t\t\t//if(a[x][w[x][j]]==3)break;\n\t\t\tif(a[x][w[x][j]]==2)return 1;\n\t\t\tbreak;\n\t\t}\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<0<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=c[x][y]-1;i>=0;i--){\n\t\tif(a[h[y][i]][y]==3)break;\n\t\tif(a[h[y][i]][y]==1)ret+=solve(h[y][i],y);\n\t}\n\tfor(int i=c[x][y]+1;i<sh[y];i++){\n\t\tif(a[h[y][i]][y]==3)break;\n\t\tif(a[h[y][i]][y]==1)ret+=solve(h[y][i],y);\n\t}\n\tfor(int j=d[x][y]-1;j>=0;j--){\n\t\tif(a[x][w[x][j]]==3)break;\n\t\tif(a[x][w[x][j]]==1)ret+=solve(x,w[x][j]);\n\t}\n\tfor(int j=d[x][y]+1;j<sw[x];j++){\n\t\tif(a[x][w[x][j]]==3)break;\n\t\tif(a[x][w[x][j]]==1)ret+=solve(x,w[x][j]);\n\t}\n\tif(b){a[x][y]=1; k++;}\n\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<ret<<endl;\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++){a[i][j]=3; c[i][j]=0; d[i][j]=0;}\n\tfor(int i=0;i<15;i++){h[i].clear(); w[i].clear();}\n\tk=0;\n\tscanf(\"%d%d\",&m,&n);\n\tif(m==0&&n==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\tif(a[i][j]==1){\n\t\t\t\tk++;\n\t\t\t\tc[i][j]=h[j].size();\n\t\t\t\td[i][j]=w[i].size();\n\t\t\t\th[j].push_back(i);\n\t\t\t\tw[i].push_back(j);\n\t\t\t}\n\t\t\tif(a[i][j]==2){\n\t\t\t\tlocx=i; locy=j;\n\t\t\t\tc[i][j]=h[j].size();\n\t\t\t\td[i][j]=w[i].size();\n\t\t\t\th[j].push_back(i);\n\t\t\t\tw[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<15;i++){sh[i]=h[i].size(); sw[i]=w[i].size();}\n\tans=solve(locx,locy);\n\tprintf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\nint x[10][10];\nint y[10][10];\nint graph[100][100];\nint graph2[100][100];\nint graph3[100];\nstack<int>S;\n\nint main(){\n\tint h,w,d1,d2,e1,e2,f1,f2,c=0,sum=0;\n\twhile (true) {\n\t\tc = 0;\n\t\tsum = 0;\n\t\tmemset(graph, 0, sizeof(graph));\n\t\tmemset(graph2, 0, sizeof(graph2));\n\t\tcin >> w >> h;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t\tif (x[i][j] == 2) {\n\t\t\t\t\tx[i][j] = 100;\n\t\t\t\t\td1 = i;\n\t\t\t\t\td2 = j;\n\t\t\t\t}\n\t\t\t\telse if (x[i][j] == 0) {\n\t\t\t\t\tx[i][j] = 1000;\n\t\t\t\t}\n\t\t\t\telse if (x[i][j] == 1) {\n\t\t\t\t\tx[i][j] = c;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (x[i][j] != 1000) {\n\t\t\t\t\tfor (int k = 0; k < h; k++) {\n\t\t\t\t\t\tif (i != k) {\n\t\t\t\t\t\t\tif (x[k][j] < 100) {\n\t\t\t\t\t\t\t\tgraph2[i * 10 + j][k * 10 + j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (x[k][j] == 100) {\n\t\t\t\t\t\t\t\tgraph2[i * 10 + j][k * 10 + j] = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tif (j != k) {\n\t\t\t\t\t\t\tif (x[i][k] < 100) {\n\t\t\t\t\t\t\t\tgraph2[i * 10 + j][i * 10 + k] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (x[i][k] == 100) {\n\t\t\t\t\t\t\t\tgraph2[i * 10 + j][i * 10 + k] = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(graph, 0, sizeof(graph));\n\n\t\tS.push(d1 * 10 + d2);\n\n\t\twhile (!S.empty()) {\n\t\t\te1 = S.top() / 10;\n\t\t\te2 = S.top() % 10;\n\t\t\tmemset(y, 0, sizeof(y));\n\t\t\tf1 = S.top() / 10;\n\t\t\tf2 = S.top() % 10;\n\t\t\tfor (int i = f2 + 1; i < w; i++) {\n\t\t\t\tif (graph3[f1 * 10 + i] == 0 || (f1 == d1 && i == d2)) {\n\t\t\t\t\ty[f1][i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < f2; i++) {\n\t\t\t\tif (graph3[f1 * 10 + i] == 0 || (f1 == d1 && i == d2)) {\n\t\t\t\t\ty[f1][i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = f1 + 1; i < h; i++) {\n\t\t\t\tif (graph3[f2 + i * 10] == 0 || (f2 == d2 && i == d1)) {\n\t\t\t\t\ty[i][f2] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < f1; i++) {\n\t\t\t\tif (graph3[f2 + i * 10] == 0 || (f2 == d2 && i == d1)) {\n\t\t\t\t\ty[i][f2] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tif (graph[S.top()][i * 10 + e2] == 0 && graph2[S.top()][i * 10 + e2] == 1 && graph3[i * 10 + e2] == 0 && y[i][e2] == 1) {\n\t\t\t\t\tgraph[S.top()][i * 10 + e2] = 1;\n\t\t\t\t\tgraph[i * 10 + e2][S.top()] = 1;\n\t\t\t\t\tgraph3[i * 10 + e2] = 1;\n\t\t\t\t\tS.push(i * 10 + e2);\n\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\telse if (graph2[S.top()][i * 10 + e2] == 2 && graph[S.top()][i * 10 + e2] == 0 && S.size() == c + 1 && graph3[i * 10 + e2] == 0 && y[i][e2] == 1) {\n\t\t\t\t\tgraph[S.top()][i * 10 + e2] = 1;\n\t\t\t\t\tgraph3[i * 10 + e2] = 1;\n\t\t\t\t\tS.push(i * 10 + e2);\n\n\t\t\t\t\tsum++;\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tif (graph[S.top()][i + e1 * 10] == 0 && graph2[S.top()][i + e1 * 10] == 1 && graph3[i + e1 * 10] == 0 && y[e1][i] == 1) {\n\t\t\t\t\tgraph[S.top()][i + e1 * 10] = 1;\n\t\t\t\t\tgraph[i + e1 * 10][S.top()] = 1;\n\t\t\t\t\tgraph3[i + e1 * 10] = 1;\n\t\t\t\t\tS.push(i + e1 * 10);\n\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\telse if (graph2[S.top()][i + e1 * 10] == 2 && S.size() == c + 1 && graph[S.top()][i + e1 * 10] == 0 && graph3[i + e1 * 10] == 0 && y[e1][i] == 1) {\n\t\t\t\t\tgraph[S.top()][i + e1 * 10] = 1;\n\t\t\t\t\tgraph3[i + e1 * 10] = 1;\n\t\t\t\t\tS.push(i + e1 * 10);\n\n\t\t\t\t\tsum++;\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S.top() != d1 * 10 + d2) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tgraph[S.top()][i * 10 + j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgraph3[S.top()] = 0;\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tS.pop();\n\t\t\t\tgraph3[d1 * 10 + d2] = 0;\n\t\t\t}\n\t\tExit:;\n\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nint f(int cur,int mask){\n\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\tint& res=M[cur<<24|mask];\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif(mask>>a[y][x]&1)break;\n\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\n//int memo[1<<K][23];\nunordered_map<int, int> memo2[23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}*/\n\tif(done%3==0&&table[i][j]>=0&&memo2[table[i][j]].find(done)!=memo2[table[i][j]].end())\n\t{\n\t\treturn memo2[table[i][j]][done];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\t/*\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(table[i][j]>=0){\n\t\t\t\t\tmemo2[table[i][j]][done]=0;\n\t\t\t\t}*/\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}*/\n\tif(table[i][j]>=0&&done%3==0){\n\t\tmemo2[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tfor(int i=0;i<c;i++){\n\t\tmemo2[i].clear();\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&(house_num==0||((state>>(house_num-1))&1)==1)) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((__builtin_popcount(state)>16||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1){\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(__builtin_popcount(state)<=16&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (__builtin_popcount(state)<=16?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint h,w;\nint f[10][10];\n\nint ct;\nint x[24],y[24];\n\nunordered_map<int,int> dp;\nint dfs(int s)\n{\n    if(dp.count(s)) return dp[s];\n\n    int mask = s>>5;\n    int now = s&31;\n\n    vector<int> nx;\n    int X=x[now], Y=y[now];\n\n    X = x[now]+1;\n    while(X<w)\n    {\n        if(f[Y][X]>0)\n        {\n            if(!(mask>>f[Y][X]&1))\n            {\n                nx.pb(f[Y][X]);\n                break;\n            }\n        }\n        ++X;\n    }\n    X = x[now]-1;\n    while(X>=0)\n    {\n        if(f[Y][X]>0)\n        {\n            if(!(mask>>f[Y][X]&1))\n            {\n                nx.pb(f[Y][X]);\n                break;\n            }\n        }\n        --X;\n    }\n\n    X = x[now];\n    Y = y[now]+1;\n    while(Y<h)\n    {\n        if(f[Y][X]>0)\n        {\n            if(!(mask>>f[Y][X]&1))\n            {\n                nx.pb(f[Y][X]);\n                break;\n            }\n        }\n        ++Y;\n    }\n    Y = y[now]-1;\n    while(Y>=0)\n    {\n        if(f[Y][X]>0)\n        {\n            if(!(mask>>f[Y][X]&1))\n            {\n                nx.pb(f[Y][X]);\n                break;\n            }\n        }\n        --Y;\n    }\n\n    // finish\n    if(mask == (1<<ct)-1-1)\n    {\n        if(x[now]==x[0] || y[now]==y[0]) return 1;\n        else return 0;\n    }\n\n    int ret=0;\n    for(const auto &p:nx)\n    {\n        if(p==0) continue;\n\n        int nmask = mask|(1<<p);\n        int nxt = (nmask<<5) | p;\n        ret += dfs(nxt);\n    }\n\n    dp[s]=ret;\n    return ret;\n}\n\nint main()\n{\n    while(scanf(\" %d %d\", &w, &h),h)\n    {\n        ct=1;\n        rep(i,h)rep(j,w)\n        {\n            scanf(\" %d\", &f[i][j]);\n            if(f[i][j]==1)\n            {\n                f[i][j] = ct;\n                x[ct] = j;\n                y[ct] = i;\n                ++ct;\n            }\n            else if(f[i][j]==2)\n            {\n                f[i][j] = 0;\n                x[0] = j;\n                y[0] = i;\n            }\n            else f[i][j]=-1;\n        }\n\n        dp.clear();\n        printf(\"%d\\n\", dfs(0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define operation(x, y) \\\n{\\\n\tif(house[y][x] >= 0 && !((visited >> house[y][x]) & 1)) {\t\\\n\t\tcan_pass[y][x] = true;\t\t\t\t\t\t\t\t\t\\\n\t\tres += dfs(x, y, (visited | (1 << house[y][x])));\t\t\\\n\t\tcan_pass[y][x] = false;\t\t\t\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\\\n\tif(!can_pass[y][x])\\\n\t\tbreak;\\\n}\n\nint w, h, num;\nint sx, sy;\nmap<pair<short, int>, int> memo;\nvector<vector<bool> > can_pass;\nvector<vector<short> > house;\n\nint dfs(int x, int y, int visited = 0) {\n\tif(visited == (1 << num) - 1)\n\t\tif(x == sx || y == sy)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\n\tif(memo.count(make_pair(house[y][x], visited)))\n\t\treturn memo[make_pair(house[y][x], visited)];\n\n\tint res = 0;\n\tfor(int i = x + 1; i < w; ++i)\n\t\toperation(i, y)\n\n\tfor(int i = x - 1; i >= 0; --i)\n\t\toperation(i, y)\n\n\tfor(int i = y + 1; i < h; ++i)\n\t\toperation(x, i)\n\n\tfor(int i = y - 1; i >= 0; --i)\n\t\toperation(x, i)\n\n\tif(__builtin_popcount(visited) < 20)\n\t\tmemo[make_pair(house[y][x], visited)] = res;\n\t\t\t\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tcan_pass.clear();\n\t\tcan_pass.resize(h, vector<bool>(w, false));\n\t\thouse.clear();\n\t\thouse.resize(h, vector<short>(w, -1));\n\n\t\tnum = 0;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tint in;\n\t\t\t\tcin >> in;\n\n\t\t\t\tif(in == 1) {\n\t\t\t\t\thouse[i][j] = num++;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tcan_pass[i][j] = true;\n\t\t\t\t\tif(in == 2) {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemo.clear();\n\t\tcout << dfs(sx, sy) << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <iostream>\n#define fi first\n#define sec second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nint S;\nint ans;\nint cell[10][10];\nint dy[4] = {1,0,-1,0}, dx[4] = {0,1,0,-1};\nbool used[25];\nvector<int> e[30][4]; //0 up 1 right 2 down 3 left\nvector<P> num;\n\nvoid A(int s,int cnt){\n\tcnt--;\n\tif(cnt == 0){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(e[s][i].size() != 0 && e[s][i][0] == S){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tused[s] = true;\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < e[s][i].size(); j++){\n\t\t\tif(used[e[s][i][j]]) break;\n\t\t\tA(e[s][i][j],cnt);\n\t\t}\n\t}\n\tused[s] = false;\n}\n\nvoid solve(){\n\tans = 0;\n\tnum.clear();\n\tmemset(used,0,sizeof(used));\n\tfor(int i = 0; i < 30; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\te[i][j].clear();\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tscanf(\"%d\", &cell[i][j]);\n\t\t\tif(cell[i][j] != 0){\n\t\t\t\tif(cell[i][j] == 2) S = num.size();\n\t\t\t\tnum.push_back(P(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(cell[i][j] == 0) continue;\n\t\t\tint tmp;\n\t\t\tfor(int k = 0; k < num.size(); k++){\n\t\t\t\tif(num[k].fi == i && num[k].sec == j){\n\t\t\t\t\ttmp = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint y = i, x = j;\n\t\t\t\twhile(true){\n\t\t\t\t\ty += dy[k]; x += dx[k];\n\t\t\t\t\tif(0>y||y>=n||0>x||x>=m) break;\n\t\t\t\t\tif(cell[y][x] != 0){\n\t\t\t\t\t\tfor(int l = 0; l < num.size(); l++){\n\t\t\t\t\t\t\tif(num[l].fi == y && num[l].sec == x){\n\t\t\t\t\t\t\t\te[tmp][k].push_back(l);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tA(S,num.size());\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &m, &n),n||m) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  /*if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  */\n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    \n    /**/\n\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.checkvis( houseId[next.fr][next.sc] )) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.setvis( houseId[next.fr][next.sc] );\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <set>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nclass Edge{\npublic:\n    int to;\n    bitset<24> pass;\n    Edge(){}\n    Edge(int to0, bitset<24> pass0){\n        to = to0;\n        pass = pass0;\n    }\n};\n\nint n;\nvector<vector<Edge> > edges;\n\nint dfs(int curr, bitset<24> bs){\n    if(curr == 0 && bs.any()){\n        if(bs.count() == n)\n            return 1;\n        else\n            return 0;\n    }\n\n    int ret = 0;\n    for(unsigned i=0; i<edges[curr].size(); ++i){\n        int j = edges[curr][i].to;\n        if(bs[j])\n            continue;\n        if((~bs & edges[curr][i].pass).any())\n            continue;\n        bs[j] = true;\n        ret += dfs(j, bs);\n        bs[j] = false;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        n = 1;\n        vector<int> y(1), x(1);\n        vector<vector<int> > grid(h, vector<int>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> grid[i][j];\n                if(grid[i][j] == 1){\n                    y.push_back(i);\n                    x.push_back(j);\n                    grid[i][j] = n;\n                    ++ n;\n                }else if(grid[i][j] == 2){\n                    y[0] = i;\n                    x[0] = j;\n                    grid[i][j] = 0;\n                }else{\n                    grid[i][j] = -1;\n                }\n            }\n        }\n\n        edges.assign(n, vector<Edge>(0));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                int y1 = y[i] + dy[j];\n                int x1 = x[i] + dx[j];\n                bitset<24> bs;\n                while(0 <= y1 && y1 < h && 0 <= x1 && x1 < w){\n                    if(grid[y1][x1] != -1){\n                        int k = grid[y1][x1];\n                        edges[i].push_back(Edge(k, bs));\n                        if(k != 0)\n                            bs[k] = true;\n                    }\n                    y1 += dy[j];\n                    x1 += dx[j];\n                }\n            }\n        }\n\n        cout << dfs(0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<stack>\nusing namespace std;\n\nint x[10][10];\nint y[10][10];\nint graph[100][100];\nint graph2[100][100];\nint graph3[100];\nstack<int>S;\n\nint main(){\n\tint h,w,d1,d2,e1,e2,f1,f2,c=0,sum=0;\n\twhile (true) {\n\t\tc = 0;\n\t\tsum = 0;\n\t\tmemset(graph, 0, sizeof(graph));\n\t\tmemset(graph2, 0, sizeof(graph2));\n\t\tcin >> w >> h;\n\t\tif(w==0 && h==0){\n\t\t    break;\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t\tif (x[i][j] == 2) {\n\t\t\t\t\tx[i][j] = 100;\n\t\t\t\t\td1 = i;\n\t\t\t\t\td2 = j;\n\t\t\t\t}\n\t\t\t\telse if (x[i][j] == 0) {\n\t\t\t\t\tx[i][j] = 1000;\n\t\t\t\t}\n\t\t\t\telse if (x[i][j] == 1) {\n\t\t\t\t\tx[i][j] = c;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (x[i][j] != 1000) {\n\t\t\t\t\tfor (int k = 0; k < h; k++) {\n\t\t\t\t\t\tif (i != k) {\n\t\t\t\t\t\t\tif (x[k][j] < 100) {\n\t\t\t\t\t\t\t\tgraph2[i * 10 + j][k * 10 + j] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (x[k][j] == 100) {\n\t\t\t\t\t\t\t\tgraph2[i * 10 + j][k * 10 + j] = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < w; k++) {\n\t\t\t\t\t\tif (j != k) {\n\t\t\t\t\t\t\tif (x[i][k] < 100) {\n\t\t\t\t\t\t\t\tgraph2[i * 10 + j][i * 10 + k] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (x[i][k] == 100) {\n\t\t\t\t\t\t\t\tgraph2[i * 10 + j][i * 10 + k] = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(graph, 0, sizeof(graph));\n\n\t\tS.push(d1 * 10 + d2);\n\n\t\twhile (!S.empty()) {\n\t\t\te1 = S.top() / 10;\n\t\t\te2 = S.top() % 10;\n\t\t\tmemset(y, 0, sizeof(y));\n\t\t\tf1 = S.top() / 10;\n\t\t\tf2 = S.top() % 10;\n\t\t\tfor (int i = f2 + 1; i < w; i++) {\n\t\t\t\tif (graph3[f1 * 10 + i] == 0 || (f1 == d1 && i == d2)) {\n\t\t\t\t\ty[f1][i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < f2; i++) {\n\t\t\t\tif (graph3[f1 * 10 + i] == 0 || (f1 == d1 && i == d2)) {\n\t\t\t\t\ty[f1][i] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = f1 + 1; i < h; i++) {\n\t\t\t\tif (graph3[f2 + i * 10] == 0 || (f2 == d2 && i == d1)) {\n\t\t\t\t\ty[i][f2] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < f1; i++) {\n\t\t\t\tif (graph3[f2 + i * 10] == 0 || (f2 == d2 && i == d1)) {\n\t\t\t\t\ty[i][f2] = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tif (graph[S.top()][i * 10 + e2] == 0 && graph2[S.top()][i * 10 + e2] == 1 && graph3[i * 10 + e2] == 0 && y[i][e2] == 1) {\n\t\t\t\t\tgraph[S.top()][i * 10 + e2] = 1;\n\t\t\t\t\tgraph[i * 10 + e2][S.top()] = 1;\n\t\t\t\t\tgraph3[i * 10 + e2] = 1;\n\t\t\t\t\tS.push(i * 10 + e2);\n\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\telse if (graph2[S.top()][i * 10 + e2] == 2 && graph[S.top()][i * 10 + e2] == 0 && S.size() == c + 1 && graph3[i * 10 + e2] == 0 && y[i][e2] == 1) {\n\t\t\t\t\tgraph[S.top()][i * 10 + e2] = 1;\n\t\t\t\t\tgraph3[i * 10 + e2] = 1;\n\t\t\t\t\tS.push(i * 10 + e2);\n\n\t\t\t\t\tsum++;\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tif (graph[S.top()][i + e1 * 10] == 0 && graph2[S.top()][i + e1 * 10] == 1 && graph3[i + e1 * 10] == 0 && y[e1][i] == 1) {\n\t\t\t\t\tgraph[S.top()][i + e1 * 10] = 1;\n\t\t\t\t\tgraph[i + e1 * 10][S.top()] = 1;\n\t\t\t\t\tgraph3[i + e1 * 10] = 1;\n\t\t\t\t\tS.push(i + e1 * 10);\n\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t\telse if (graph2[S.top()][i + e1 * 10] == 2 && S.size() == c + 1 && graph[S.top()][i + e1 * 10] == 0 && graph3[i + e1 * 10] == 0 && y[e1][i] == 1) {\n\t\t\t\t\tgraph[S.top()][i + e1 * 10] = 1;\n\t\t\t\t\tgraph3[i + e1 * 10] = 1;\n\t\t\t\t\tS.push(i + e1 * 10);\n\n\t\t\t\t\tsum++;\n\t\t\t\t\tgoto Exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S.top() != d1 * 10 + d2) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tgraph[S.top()][i * 10 + j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgraph3[S.top()] = 0;\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tS.pop();\n\t\t\t\tgraph3[d1 * 10 + d2] = 0;\n\t\t\t}\n\t\tExit:;\n\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <map>\n\n#define PLANE (-1)\n#define HOUSE (1)\n#define CHURCH (100)\n\nint x, y;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint home[10][10];\nint n;\nmap<int, int> memo[24];\n\nint goChurch(int ty, int tx)\n{\n    int i;\n    int my, mx;\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        while (0 <= my && my < y && 0 <= mx && mx < x){\n            if (home[my][mx] == CHURCH){\n                return (1);\n            }\n            my += dy[i];\n            mx += dx[i];\n        }\n    }\n    return (0);\n}\n\nint dfs(int v, int bit, int ty, int tx, char state[][11])\n{\n    int i;\n    int ky, kx;\n    int ans;\n    \n    if (memo[pos].find(bit) != memo[pos].end()){\n        return (memo[v][bit]);\n    }\n    \n    if (bit == (1 << n) - 1){\n        if (__builtin_popcount(bit) < 19){\n            return (memo[v][bit] = goChurch(ty, tx));\n        }\n        return (goChurch(ty, tx));\n    }\n    \n    ans = 0;\n    \n    for (i = 0; i < 4; i++){\n\t\tkx = tx + dx[i];\n        ky = ty + dy[i];\n        //ツ逆ツ渉づ可プツδ個ゼツδ督トツづーツ置ツつ「ツづつ「ツつュ\n\t\twhile (0 <= kx && kx < x && 0 <= ky && ky < y && (home[ky][kx] == PLANE || home[ky][kx] == CHURCH || state[ky][kx] == 1)){\n\t\t\tky += dy[i];\n            kx += dx[i];\n\t\t}\n\t\tif (0 <= kx && kx < x && 0 <= ky && ky < y){\n\t\t\tstate[ky][kx] = 1;\n\t\t\tans += dfs(home[ky][kx] , bit | (1 << home[ky][kx]) , ky, kx, state);\n\t\t\tstate[ky][kx] = 0;\n\t\t}\n\t}\n    \n    if (__builtin_popcount(bit) < 19){\n        memo[v][bit] = ans;\n    }\n\treturn (ans);\n}\n\n\nint main(void)\n{\n    int sy, sx;\n    int i, j;\n    char state[10][11];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        n = 0;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &home[i][j]);\n                if (home[i][j] == 2){\n                    home[i][j] = CHURCH;\n                    sy = i;\n                    sx = j;\n                }\n                else if (home[i][j] == HOUSE){\n                    home[i][j] = n++;\n                }\n                else if (home[i][j] == 0){\n                    home[i][j] = PLANE;\n                }\n            }\n        }\n        memset(state, 0, sizeof(state));\n        for (i = 0; i < 24; i++){\n            memo[i].clear();\n        }\n        printf(\"%d\\n\", dfs(n, 0, sy, sx, state));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[12][12],sx,sy,m,n;\nint fn(int x,int y,int p,int q){\n  int i;\n  int ct=0;\n  if(x==sx||y==sy)\n    q++;\n  if(p==n){\n    if(y==sy){\n      for(i=1;a[x+i][y]!=-1;i++){\n\tif(x+i==sx&&y==sy)\n\t  ct=1;\n      }\n      for(i=1;a[x-i][y]!=-1;i++){\n\tif(x-i==sx&&y==sy)\n\t  ct=1;\n      }\n    }\n    if(x==sx){\n      for(i=1;a[x][y+i]!=-1;i++){\n\tif(x==sx&&y+i==sy)\n\t  ct=1;\n      }\n      for(i=1;a[x][y-i]!=-1;i++){\n\tif(x==sx&&y-i==sy)\n\t  ct=1;\n      }\n    }\n  }else if(q!=m){\n    for(i=1;a[x+i][y]!=-1;i++){\n      if(a[x+i][y]==1){\n\ta[x+i][y]=-1;\n\tct+=fn(x+i,y,p+1,q);\n\ta[x+i][y]=1;\n      }\n    }\n    for(i=1;a[x-i][y]!=-1;i++){\n      if(a[x-i][y]==1){\n\ta[x-i][y]=-1;\n\tct+=fn(x-i,y,p+1,q);\n\ta[x-i][y]=1;\n      }\n    }\n    for(i=1;a[x][y+i]!=-1;i++){\n      if(a[x][y+i]==1){\n\ta[x][y+i]=-1;\n\tct+=fn(x,y+i,p+1,q);\n\ta[x][y+i]=1;\n      }\n    }\n    for(i=1;a[x][y-i]!=-1;i++){\n      if(a[x][y-i]==1){\n\ta[x][y-i]=-1;\n\tct+=fn(x,y-i,p+1,q);\n\ta[x][y-i]=1;\n      }\n    }\n  }\n  return ct;\n}\nint main(){\n  int i,j;\n  int w,h;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    n=0;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>a[j][i];\n\tif(0){\n\t}else if(a[j][i]==1){\n\t  n++;\n\t}else if(a[j][i]==2){\n\t  a[j][i]=0;\t  \n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    m=1;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tif((j==sx||i==sy)&&a[j][i]==1)\n\t  m++;\n      }\n    }\n    cout<<fn(sx,sy,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\ndeque<int> edge[24][4];\nint n;\nint dp[24][1 << 23];\nint dfs(int p, int visit)\n{\n\tif (~dp[p][visit])\n\t\treturn dp[p][visit];\n\telse if (!visit)\n\t{\n\t\tbool f = false;\n\t\trep (i, 4)\n\t\t\tif (!edge[p][i].empty())\n\t\t\t\tf |= edge[p][i].front() == n;\n\t\treturn dp[p][visit] = f ? 1 : 0;\n\t}\n\n\tint res = 0;\n\trep (i, 4)\n\t{\n\t\tforeach (e, edge[p][i])\n\t\t{\n\t\t\tif (*e == n)\n\t\t\t\tcontinue;\n\t\t\tif (!(visit & (1 << *e)))\n\t\t\t\tbreak;\n\n\t\t\tres += dfs(*e, visit ^ (1 << *e));\n\t\t}\n\t}\n\n\treturn dp[p][visit] = res;\n}\nint main()\n{\n\tint h, w;\n\twhile (scanf(\"%d%d\", &w, &h), w | h)\n\t{\n\t\trep (i, 30)\n\t\t\trep (j, 4)\n\t\t\t\tedge[i][j].clear();\n\n\t\tpint church;\n\t\tvector<pint> pos;\n\t\trep (i, h)\n\t\t{\n\t\t\trep (j, w)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif (t == 1)\n\t\t\t\t\tpos.push_back(pint(j, i));\n\t\t\t\telse if (t == 2)\n\t\t\t\t\tchurch = pint(j, i);\n\t\t\t}\n\t\t}\n\t\tn = pos.size();\n\t\tpos.push_back(church);\n\n\t\trep (i, pos.size())\n\t\t{\n\t\t\tvector<pint> hor, ver;\n\t\t\trep (j, pos.size())\n\t\t\t{\n\t\t\t\tif (pos[i].first == pos[j].first)\n\t\t\t\t\tver.push_back(pint(pos[j].second, j));\n\t\t\t\telse if (pos[i].second == pos[j].second)\n\t\t\t\t\thor.push_back(pint(pos[j].first, j));\n\t\t\t}\n\t\t\tsort(all(hor));\n\t\t\tsort(all(ver));\n\n\t\t\tforeach (it, hor)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].first)\n\t\t\t\t\tedge[i][3].push_front(it->second);\n\t\t\t\telse if (pos[i].first < it->first)\n\t\t\t\t\tedge[i][1].push_back(it->second);\n\t\t\t}\n\t\t\tforeach (it, ver)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].second)\n\t\t\t\t\tedge[i][2].push_front(it->second);\n\t\t\t\telse if (pos[i].second < it->first)\n\t\t\t\t\tedge[i][0].push_back(it->second);\n\t\t\t}\n\t\t}\n\n\t\t//rep (i, n + 1)\n\t\t//{\n\t\t//\tprintf(\">%d: (%d, %d)\\n\", i, pos[i].first, pos[i].second);\n\t\t//\trep (j, 4)\n\t\t//\t{\n\t\t//\t\tprintf(\"%d: \", j);\n\t\t//\t\tforeach (t, edge[i][j])\n\t\t//\t\t\tprintf(\"(%d, %d) \", pos[*t].first, pos[*t].second);\n\t\t//\t\tputs(\"\");\n\t\t//\t}\n\t\t//}\n\n\t\tmemset(dp, ~0, sizeof(dp));\n\t\tint all_visit = (1 << n) - 1;\n\t\tprintf(\"%d\\n\", dfs(n, all_visit));\n\n\t\t//int s = 0;\n\t\t//rep (i, n)\n\t\t//\tif (~dp[i][0])\n\t\t//\t\ts += dp[i][0];\n\t\t//printf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <bitset>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nvector<int> hx,hy;\nint sx,sy;\nint num;\n\nbool C1(int S, int x1, int x2, int y) {\n  REP(j, num)\n    if ((1<<j)&S && hy[j] == y && (x1<hx[j]&&hx[j]<x2 || x2<hx[j]&&hx[j]<x1))\n      return false;\n  return true;\n}\nbool C2(int S, int x1, int x2, int y) {\n  REP(j, num)\n    if ((1<<j)&S && hx[j] == y && (x1<hy[j]&&hy[j]<x2 || x2<hy[j]&&hy[j]<x1))\n      return false;\n  return true;\n}\nmap<int, int> visited;//[1<<23][10][10];\n\nint rec(int S, int nx, int ny) {\n   int nest = 0;\n   // REP(i,num) {\n   //   if ((S>>i) & 1)\n   //     nest++;\n   // }\n   // cout << string(nest,' ');\n   // cout << bitset<7>(S) << \" \" << nx << \" \"<<ny << endl;\n  \n  if (visited.count(S*100+nx*10+ny)) {\n    // cout << \"VISITED\" << endl;\n    return visited[S*100+nx*10+ny];\n  }\n  if (S == 0) {\n    if (sx == nx || sy == ny)\n      return 1;\n    else \n      return 0;\n  }\n  int res  = 0;\n  REP(i, num) {\n    if (!((1<<i)&S)) continue;\n    if (hy[i] == ny && C1(S, hx[i], nx, ny) || hx[i] == nx && C2(S, hy[i], ny, nx))\n      res += rec(S-(1<<i), hx[i], hy[i]);\n  }\n  return visited[S*100+nx*10+ny] = res;\n}\n\nint main() {\n  int m, n;\n  while(cin>>m>>n,m||n) {\n    hx.clear();hy.clear();\n    visited.clear();\n    REP(i,n) {\n      REP(j,m) {\n        int a;\n        cin >> a;\n        if (a==1) {\n          hx.push_back(j);\n          hy.push_back(i);\n        } else if (a == 2) {\n          sx=j;sy=i;\n        }\n      }\n    }\n    num = hx.size();\n    cout << rec((1<<num)-1, sx, sy) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef pair<int,vector<int>> pv;\n\nint ary[15][15],ban[15][15];\nint dp[1<<23][23];\nbool used[1<<23][23];\nint dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\nint main(){\n\tint M,N,num,chux,chuy;\n\tvector<pa> ve;\n\tvector<pv> can[23],chc;\n\tpriority_queue<pa,vector<pa>,greater<pa>> que;\n\tvector<int> tmp;\n\tint shu,ima;\n\twhile(true){\n\t\tcin>>M>>N;\n\t\tif(M==0&&N==0) break;\n\t\tve.clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tfor(int j=1;j<=M;j++){\n\t\t\t\tban[i][j]=-1;\n\t\t\t\tcin>>ary[i][j];\n\t\t\t\tif(ary[i][j]==1){\n\t\t\t\t\tban[i][j]=ve.size();\n\t\t\t\t\tve.push_back(pa(i,j));\n\t\t\t\t}\n\t\t\t\telse if(ary[i][j]==2){\n\t\t\t\t\tchux=i;chuy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnum=ve.size();\n\t\tfor(int i=0;i<(1<<num);i++) fill(dp[i],dp[i]+23,0);\n\t\tfor(int i=0;i<(1<<num);i++) fill(used[i],used[i]+23,0);\n\t\tfor(int i=0;i<num;i++) can[i].clear();\n\n\t\tfor(int i=0;i<num-1;i++){\n\t\t\tfor(int j=i+1;j<num;j++){\n\t\t\t\tif(ve[i].first==ve[j].first){\n\t\t\t\t\ttmp.clear();\n\t\t\t\t\tfor(int k=min(ve[i].second,ve[j].second)+1;k<max(ve[i].second,ve[j].second);k++){\n\t\t\t\t\t\tif(ban[ve[i].first][k]!=-1)tmp.push_back(ban[ve[i].first][k]);\n\t\t\t\t\t}\n\t\t\t\t\tcan[i].push_back(pv(j,tmp));\n\t\t\t\t\tcan[j].push_back(pv(i,tmp));\n\t\t\t\t}\n\t\t\t\telse if(ve[i].second==ve[j].second){\n\t\t\t\t\ttmp.clear();\n\t\t\t\t\tfor(int k=min(ve[i].first,ve[j].first)+1;k<max(ve[i].first,ve[j].first);k++){\n\t\t\t\t\t\tif(ban[k][ve[i].second]!=-1)tmp.push_back(ban[k][ve[i].second]);\n\t\t\t\t\t}\n\t\t\t\t\tcan[i].push_back(pv(j,tmp));\n\t\t\t\t\tcan[j].push_back(pv(i,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<num;i++){\n\t\t\tif(ve[i].first==chux||ve[i].second==chuy){\n\t\t\t\tque.push(pa(1<<i,i));\n\t\t\t\tdp[1<<i][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tbool fla;\n\t\twhile(!que.empty()){\n\t\t\tshu=que.top().first;ima=que.top().second;que.pop();\n\t\t\tif(used[shu][ima]) continue;\n\t\t\tused[shu][ima]=true;\n\t\t\tfor(auto it=can[ima].begin();it!=can[ima].end();it++){\n\t\t\t\tif((1<<(it->first))&shu)continue;\n\t\t\t\tfla=true;\n\t\t\t\tfor(auto it2=it->second.begin();it2!=it->second.end();it2++){\n\t\t\t\t\tif((1<<(*it2))&shu){\n\t\t\t\t\t\tfla=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fla){\n\t\t\t\t\tdp[shu+(1<<(it->first))][it->first]+=dp[shu][ima];\n\t\t\t\t\tque.push(pa(shu+(1<<(it->first)),it->first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res=0;\n\t\tfor(int i=0;i<num;i++){\n\t\t\tif(ve[i].first==chux){\n\t\t\t\tfla=true;\n\t\t\t\tfor(int k=min(ve[i].second,chuy)+1;k<max(ve[i].second,chuy);k++){\n\t\t\t\t\tif(ban[ve[i].first][k]!=-1){\n\t\t\t\t\t\tfla=false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fla){\n\t\t\t\t\tres+=dp[(1<<num)-1][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ve[i].second==chuy){\n\t\t\t\tfla=true;\n\t\t\t\tfor(int k=min(ve[i].first,chux)+1;k<max(ve[i].first,chux);k++){\n\t\t\t\t\tif(ban[k][ve[i].second]!=-1){\n\t\t\t\t\t\tfla=false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(fla){\n\t\t\t\t\tres+=dp[(1<<num)-1][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint px[24],py[24],kx,ky;\nint num[24][4] = {0};\n\nint H,W,N,ans;\nint field[12][12] = {0};\n\nint dx[] = {0,-1,0,1} , dy[] = {1,0,-1,0};\nbool done[12][12];\n\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit){\n\tif(memo[pos].find(bit) != memo[pos].end() )return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\trep(d,4){\n\t\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\t\twhile( field[cy][cx] != -1){\n\t\t\t\tif(field[cy][cx] == 64)return 1;\n\t\t\t\tcy += dy[d] , cx += dx[d];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\trep(d,4){\n\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\twhile( field[cy][cx] == -2 || done[cy][cx] == 1 || field[cy][cx] == 64){\n\t\t\tcy += dy[d] , cx += dx[d];\n\t\t}\n\t\tif(field[cy][cx] != -1){\n\t\t\tdone[cy][cx] = 1;\n\t\t\tans += dfs(field[cy][cx],bit | (1<<field[cy][cx]) );\n\t\t\tdone[cy][cx] = 0;\n\t\t}\n\t}\n\tif(__builtin_popcount(bit) < 20){\n\t\treturn memo[pos][bit] = ans;\n\t}else{\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\twhile(cin >> W >> H ,W){\n\t\tN = ans = 0;\n\t\trep(i,24)rep(j,4)num[i][j] = -1;\n\t\trep(i,12)rep(j,12)field[i][j] = -1;\n\t\trep(i,H)rep(j,W){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tswitch(t){\n\t\t\tcase 0:\n\t\t\t\tfield[i+1][j+1] = -2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfield[i+1][j+1] = N;\n\t\t\t\tpx[N] = j+1, py[N] = i+1;\n\t\t\t\tN++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tkx = j+1 , ky = i+1;\n\t\t\t\tfield[i+1][j+1] = 64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpx[N] = kx , py[N] = ky;\n\t\trep(i,24)memo[i].clear();\n\t\tcout << dfs(N,0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i, n) for ( int i = 0; i < n; i++)\nusing namespace std;\n\n#define MAX 10\n#define HOUSE 3\n#define SPACE 0\n#define SMOKE 1\n#define START 2\n#define BLOCK 4\n\nclass State{\npublic:\n  int pi, pj, H, W, total;\n  short G[MAX+2][MAX+2];\n  State(){total = 0;}\n  State(int H, int W):H(H), W(W){ total = 0;}\n\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\tif ( G[i][j] == s.G[i][j] ) continue;\n\treturn G[i][j] < s.G[i][j];\n      }\n    }\n    return false;\n  }\n\n};\n\nstatic int di[4] = {0, -1, 0, 1};\nstatic int dj[4] = {1, 0, -1, 0};\n\nint W, H, G[MAX+2][MAX+2];\n\n\nmain(){\n  int si, sj;\n\n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    int total = 0;\n\n    State s = State(H, W);\n\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) s.G[i][j] = BLOCK;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\tcin >> s.G[i][j];\n\tif ( s.G[i][j] == START ){ si = i; sj = j;}\n\tif ( s.G[i][j] == SMOKE ) total++;\n      }\n    }\n\n    bool zero[MAX+2];\n    int tmp[MAX+2][MAX+2];\n\n    for ( int i = 1; i <= H; i++ ) zero[i] = true;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) tmp[i][j] =  G[i][j];\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 1; j <= W; j++ ) if ( G[i][j] ) zero[i] = false;\n    int ii = 0;\n    int c = 0;\n    for ( int i = 0; i < H+2; i++ ){\n      if ( zero[i] ) { c++; continue;}\n      for ( int j = 0; j < W+2; j++ ) G[ii][j] = tmp[i][j];\n      ii++;\n    }\n    H -= c;\n\n    for ( int j = 1; j <= W; j++ ) zero[j] = true;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) tmp[i][j] =  G[i][j];\n      for ( int j = 1; j <= W; j++ ) \n\tfor ( int i = 0; i < H+2; i++ )\n\t  if ( G[i][j] ) zero[j] = false;\n\n    int jj = 0;\n    c = 0;\n    for ( int j = 0; j < W+2; j++ ){\n      if ( zero[j] ) { c++; continue;}\n      for ( int i = 0; i < H+2; i++ ) G[i][jj] = tmp[i][j];\n      jj++;\n    }\n    W -= c;\n\n    map<State, int> M;\n    State v;\n\n    int ni, nj;\n    M[s] = 0;\n\n    for ( int r = 0; r < 4; r++ ){\n      ni = si + di[r];\n      nj = sj + dj[r];\n      while(1){\n\tif ( s.G[ni][nj] == SMOKE ){\n\t  v = s;\n\t  v.pi = ni;\n\t  v.pj = nj;\n\t  v.G[ni][nj] = HOUSE;\n\t  v.total = 1;\n\t  M[v] = 1;\n\t  break;\n\t} else if ( s.G[ni][nj] == BLOCK ) break;\n\tni += di[r];\n\tnj += dj[r];\n      }\n    }\n\n    map<State, int>::iterator it;\n    \n    int presize = M.size();\n\n    int cc = 0;\n    int x = 0;\n    bool f;\n\n    while(1){\n      map<State, int> nM;\n      f = true;\n      for ( it = M.begin(); it != M.end(); it++ ){\n\tState cur = (*it).first;\n\tint cost = (*it).second;\n\tif ( cost == 0 ) continue;\n\n\tfor ( int r = 0; r < 4; r++ ){\n\t  ni = cur.pi + di[r];\n\t  nj = cur.pj + dj[r];\n\t  while(1){\n\t    if ( cur.G[ni][nj] == SMOKE ){\n\t      v = cur;\n\t      v.pi = ni;\n\t      v.pj = nj;\n\t      v.G[ni][nj] = HOUSE;\n\t      v.total++;\n\t      f = false;\n\t      nM[v] += cost;\n\t      break;\n\t    } else if ( cur.G[ni][nj] == START && cur.total == total ){\n\t      x += cost;\n\t      break;\n\t    } else if ( cur.G[ni][nj] == BLOCK ) {\n\t      break;\n\t    }\n\t    ni += di[r];\n\t    nj += dj[r];\n\t  }\n\t}\n      }\n      if ( f ) break;\n      M = nM;\n    }\n\n    cout << x << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 14 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /**/  \n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    \n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nconst int MAXN = 25;\nvector< pair<int, int> > rows[MAXN], cols[MAXN];\nint board[MAXN][MAXN], pos_r[MAXN], pos_c[MAXN], rec_r[MAXN], rec_c[MAXN];\nint sx, sy, c;\nmap< pair<int, int>, int > mp;\n\nint dfs(int bit, int k) {\n    if(bit == 0) {\n        return 1;\n    }\n    if(mp.count(make_pair(bit, k))) return mp[make_pair(bit, k)];\n    \n    int x = rec_r[k], y = rec_c[k];\n    int xi = pos_r[k], xj = pos_c[k];\n\n    int res = 0, b = __builtin_popcount(bit);\n    for(int i=xi+1; i<(int)rows[x].size(); i++) {\n        int id = rows[x][i].second;\n        if(b > 1 and id == c-1) continue;\n        if(bit >> id & 1) {\n            int nbit = bit ^ (1 << id);\n            res += dfs(nbit, id);\n            break;\n        }\n    }\n    for(int i=xi-1; i>=0; i--) {\n        int id = rows[x][i].second;\n        if(b > 1 and id == c-1) continue;\n        if(bit >> id & 1) {\n            int nbit = bit ^ (1 << id);\n            res += dfs(nbit, id);\n            break;\n        }\n    }\n    for(int j=xj+1; j<(int)cols[y].size(); j++) {\n        int id = cols[y][j].second;\n        if(b > 1 and id == c-1) continue;\n        if(bit >> id & 1) {\n            int nbit = bit ^ (1 << id);\n            res += dfs(nbit, id);\n            break;\n        }\n    }\n    for(int j=xj-1; j>=0; j--) {\n        int id = cols[y][j].second;\n        if(b > 1 and id == c-1) continue;\n        if(bit >> id & 1) {\n            int nbit = bit ^ (1 << id);\n            res += dfs(nbit, id);\n            break;\n        }\n    }\n    return mp[make_pair(bit, k)] = res;\n}\n\nint solve_testcase() {\n    int H, W; scanf(\"%d%d\", &W, &H);\n    if(H == 0 and W == 0) return 1;\n    mp.clear();\n    \n    for(int i=0; i<MAXN; i++) {\n        rows[i].clear();\n        cols[i].clear();\n    }\n\n    c = 0;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            scanf(\"%d\", &board[i][j]);\n            if(board[i][j] == 1) {\n                rows[i].emplace_back(j, c);\n                cols[j].emplace_back(i, c);\n                rec_r[c] = i;\n                rec_c[c] = j;\n                ++c;\n            }\n            if(board[i][j] == 2) {\n                sx = i, sy = j;\n            }\n        }\n    }\n\n    {\n        rows[sx].emplace_back(sy, c);\n        cols[sy].emplace_back(sx, c);\n        rec_r[c] = sx;\n        rec_c[c] = sy;\n        ++c;\n    }\n    \n    for(int i=0; i<15; i++) {\n        sort(rows[i].begin(), rows[i].end());\n        sort(cols[i].begin(), cols[i].end());\n\n        for(size_t k=0; k<rows[i].size(); k++) {\n            int idx = rows[i][k].second;\n            pos_r[idx] = k;\n        }\n        for(size_t k=0; k<cols[i].size(); k++) {\n            int idx = cols[i][k].second;\n            pos_c[idx] = k;\n        }\n    }\n    \n    int ans = dfs((1<<c)-1, c-1);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\n/*\nconst int dx[] = {0,1,0,-1}; //u,r,d,l\nconst int dy[] = {-1,0,1,0};\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( s==a.s ){\n      if( x==a.x ) return y<a.y;\n      else         return x<a.x;\n    }else{\n      return s<a.s;\n    }\n    /*\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n    */\n  }\n  \n};\n\nint numofbits(int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\n\n\nmap<state,int> msi;\n\nbool isgoal(int s){\n  return (((last&s)) == last);\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nmap<P,int>ma;\nint f[15][15];\nint linkk[15][15];\n//int dp[(1<<23)][24]={};\nP za[25];\nint n,m;\nint val;\nint calc(int mask,int cur)\n{\n\tint ret=0;\n\t//if(dp[mask][cur]) return dp[mask][cur];\n\tint x=za[cur].first;\n\tint y=za[cur].second;\n\tif(mask==(1<<val)-1)\n\t{\n\t\tif(x==za[23].first || y==za[23].second) return 1;\n\t\telse return 0;\n\t}\n\tfor(int i=x-1;i>=0;i--)\n\t{\n\t\tint s=linkk[i][y];\n\t\tif(f[i][y]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=calc(mask | (1<<s),s);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=x+1;i<m;i++)\n\t{\n\t\tint s=linkk[i][y];\n\t\tif(f[i][y]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=calc(mask | (1<<s),s);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=y-1;i>=0;i--)\n\t{\n\t\tint s=linkk[x][i];\n\t\tif(f[x][i]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=calc(mask | (1<<s),s);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=y+1;i<n;i++)\n\t{\n\t\tint s=linkk[x][i];\n\t\tif(f[x][i]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=calc(mask | (1<<s),s);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//if(ret) dp[mask][cur]=ret;\n\treturn ret;\n}\nint main(){\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t//\tma.clear();\n\t\tif(!n) return 0;\n\t\tint num=0; val=0;\n\t\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++) { f[i][j]=INF; linkk[i][j]=-1;}\n\t\t\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j]==1) { linkk[i][j]=num; za[num++]=mp(i,j); val++;}\n\t\t\t\tif(f[i][j]==2) za[23]=mp(i,j);\n\t\t\t}\n\t\t\n\t\t}\n\t\tcout << calc(0,23) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n//int memo[885777];\nmap<int,int> msi;\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(S) ){ //ùÉÊÁ½óÔ\n    return msi[S];\n  }\n  \n  // v[gªu¯È¢ÆÌL³\n  /*\n    1831764\n    ari  :: msi_sz: 885661  >0:376369  ==0:509292  already>0:222390 , already==0:408636\n    nari :: msi_sz:1028771  >0:376369  ==0:652402  already>0:222390 , already==0:565310\n   */\n  \n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  return msi[S]=ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n#if DEB\n    map<int,int> tmp;\n    map<int,int>::iterator it;\n    for(it=msi.begin(); it!=msi.end(); it++){\n      tmp[it->second]++;\n    }\n    for(int i=0; i<10; i++){\n      printf(\"%d: %d\\n\",i,tmp[i]);\n    }\n#endif\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <bitset>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nvector<int> hx,hy;\nint sx,sy;\nint num;\n\nbool C1(int S, int x1, int x2, int y) {\n  REP(j, num)\n    if ((1<<j)&S && hy[j] == y && (x1<hx[j]&&hx[j]<x2 || x2<hx[j]&&hx[j]<x1))\n      return false;\n  return true;\n}\nbool C2(int S, int x1, int x2, int y) {\n  REP(j, num)\n    if ((1<<j)&S && hx[j] == y && (x1<hy[j]&&hy[j]<x2 || x2<hy[j]&&hy[j]<x1))\n      return false;\n  return true;\n}\nmap<int, int> visited;//[1<<23][10][10];\n\nint rec(int S, int nx, int ny) {\n   int nest = 0;\n   REP(i,num) {\n     if ((S>>i) & 1)\n       nest++;\n   }\n   // cout << string(nest,' ');\n   // cout << bitset<7>(S) << \" \" << nx << \" \"<<ny << endl;\n  \n  if (visited.count(S*100+nx*10+ny)) {\n//    cout << \"VISITED\" << endl;\n    return visited[S*100+nx*10+ny];\n  }\n  if (S == 0) {\n    if (sx == nx || sy == ny)\n      return 1;\n    else \n      return 0;\n  }\n  int res  = 0;\n  int hoge = 0;\n  REP(i, num) {\n    if (!((1<<i)&S)) continue;\n    hoge++;\n    if (hy[i] == ny && C1(S, hx[i], nx, ny) || hx[i] == nx && C2(S, hy[i], ny, nx))\n      res += rec(S-(1<<i), hx[i], hy[i]);\n  }\n  if (hoge <18)\n    visited[S*100+nx*10+ny] = res;\n  return res;\n}\n\nint main() {\n  int m, n;\n  while(cin>>m>>n,m||n) {\n    hx.clear();hy.clear();\n    visited.clear();\n    REP(i,n) {\n      REP(j,m) {\n        int a;\n        cin >> a;\n        if (a==1) {\n          hx.push_back(j);\n          hy.push_back(i);\n        } else if (a == 2) {\n          sx=j;sy=i;\n        }\n      }\n    }\n    num = hx.size();\n    cout << rec((1<<num)-1, sx, sy) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint m,n,c[10][10],x,y,cnt,xxx[10],yyy[10];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint dfs(int x,int y,int z){\n  int ret = 0;\n  for(int i=0;i<4;i++){\n    int nx = x, ny = y;\n    while(true){\n      nx += dx[i];\n      ny += dy[i];\n      if(nx<0||nx>=n||ny<0||ny>=m) break;\n      if(c[nx][ny]==2){\n        if(z==cnt) return 1;\n      }else if(c[nx][ny]==1){\n        c[nx][ny] = -1;\n        ret += dfs(nx,ny,z+1);\n        c[nx][ny] = 1;\n        break;\n      }\n    }\n  }\n  return ret;\n}\n\nbool solve(){\n  scanf(\"%d %d\",&m,&n);\n  if(m==0&&n==0) return false;\n  for(int i=0;i<10;i++){\n    xxx[i] = yyy[i] = 0;\n  }\n  cnt = 0;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<m;j++){\n      scanf(\"%d\",&c[i][j]);\n      if(c[i][j]!=0){\n        xxx[i]++;\n        yyy[j]++;\n      }\n      if(c[i][j]==1) cnt++;\n      else if(c[i][j]==2){\n        x = i;\n        y = j;\n      }\n    }\n  }\n  printf(\"%d\\n\",dfs(x,y,0));\n  return true;\n}\n\nint main(){\n  while(true) if(!solve()) break;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint x,y;\nint map[10][10];\nint hmx[24],hmy[24];\nint gx,gy;\nint home;\nint ans;\nbool hm[24];\nint dx[5]={0,0,1,0,-1};\nint dy[5]={0,1,0,-1,0};\n\nvoid dfs(int mx,int my,int d,int ho2,int map2[10][10],int hmmx[24],int hmmy[24],bool hm2[24]){\n\tif(ho2==0){\n\t\tif(mx==gx || my==gy){\n\t\t\tbool ch=true;\n\t\t\tif(mx==gx){\n\t\t\t\tif(my>gy){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(mx==hmmx[j] && my>hmmy[j] && hmmy[j]>gy && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(my<gy){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(mx==hmmx[j] && my<hmmy[j] && hmmy[j]<gy && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(my==gy){\n\t\t\t\tif(mx>gx){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(my==hmmy[j] && mx>hmmx[j] && hmmx[j]>gx && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mx<gx){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(my==hmmy[j] && mx<hmmx[j] && hmmx[j]<gx && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ch)ans++;\n\t\t}\n\t}else for(int i=0;i<home;i++){\n\t\tif(hm2[i]==false)if(mx==hmmx[i] || my==hmmy[i]){\n\t\t\tbool ch=true;\n\t\t\tif(mx==hmmx[i]){\n\t\t\t\tif(my>hmmy[i]){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(mx==hmmx[j] && my>hmmy[j] && hmmy[j]>hmmy[i] && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(my<hmmy[i]){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(mx==hmmx[j] && my<hmmy[j] && hmmy[j]<hmmy[i] && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(my==hmmy[i]){\n\t\t\t\tif(mx>hmmx[i]){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(my==hmmy[j] && mx>hmmx[j] && hmmx[j]>hmmx[i] && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mx<hmmx[i]){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(my==hmmy[j] && mx<hmmx[j] && hmmx[j]<hmmx[i] && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ch){\n\t\t\t\thm2[i]=true;\n\t\t\t\tdfs(hmmx[i],hmmy[i],0,ho2-1,map2,hmmx,hmmy,hm2);\n\t\t\t\thm2[i]=false;\n\t\t\t}\n\t\t}\n\t}\n\t/*if(map2[mx][my]==2 && ho2==0)ans++;\n\telse{\n\t\tif(map2[mx][my]==1){\n\t\t\tmap2[mx][my]=3;\n\t\t\tho2-=1;\n\t\t\tdfs(mx,my,0,ho2,map2);\n\t\t\tmap2[mx][my]=1;\n\t\t\tho2+=1;\n\t\t}\n\t\tif(d==0){\n\t\t\tfor(int i=1;i<=4;i++){\n\t\t\t\tint kx=mx+dx[i],ky=my+dy[i];\n\t\t\t\tif(kx>=0 && kx<x && ky>=0 && ky<y && map2[kx][ky]!=3){\n\t\t\t\t\tdfs(kx,ky,i,ho2,map2);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint kx=mx+dx[d],ky=my+dy[d];\n\t\t\tif(kx>=0 && kx<x && ky>=0 && ky<y && map2[kx][ky]!=3){\n\t\t\t\tdfs(kx,ky,d,ho2,map2);\n\t\t\t}\n\t\t}\n\t}*/\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\thome=0;\n\t\tans=0;\n\t\tmemset(hm,false,sizeof(hm));\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&map[j][i]);\n\t\t\t\tif(map[j][i]==2)gx=j,gy=i;\n\t\t\t\tif(map[j][i]==1)hmx[home]=j,hmy[home]=i;\n\t\t\t\tif(map[j][i]==1)home++;\n\t\t\t}\n\t\t}\n\t\tdfs(gx,gy,0,home,map,hmx,hmy,hm);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<int,int> dp[24];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(dp[id].count(vis))return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)<10)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    for(int i=0;i<pn;i++)dp[i].clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nint n, m, field[11][11], si, sj, num;\n\nint dfs(int x, int y){\n  int ans = 0;\n  if(num == 0){\n    if(x == si || y == sj)return 1;\n    else return 0;\n  }\n  field[x][y] = 0;\n  for(int i = x + 1;i < m;i++){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  } \n  for(int i = x - 1;i >= 0;i--){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  } \n  for(int i = y + 1;i < n;i++){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  } \n  for(int i = y - 1;i >= 0;i--){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  }  \n  field[x][y] = 1;\n  return ans;\n}\n\nint main(){\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    memset(field, 0, sizeof(field));\n    num = 0;\n    for(int i = 0;i < m;i++){\n      for(int j = 0;j < n;j++){\n\tscanf(\"%d\", &field[i][j]);\n\tif(field[i][j] == 2){\n\t  si = i;\n\t  sj = j;\n\t}\n\telse num += field[i][j];\n      }\n    }\n    printf(\"%d\\n\", dfs(si, sj));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint n, m, field[11][11], si, sj, num;\n \nint dfs(int x, int y){\n  int ans = 0;\n  if(num == 0){\n    if(x == si || y == sj)return 1;\n    else return 0;\n  }\n\n  field[x][y] = 0;\n  for(int i = x + 1 ; i < m ; i++){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  }\n  for(int i = x - 1 ; i >= 0 ; i--){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  }\n  for(int i = y + 1 ; i < n ; i++){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  }\n  for(int i = y - 1 ; i >= 0 ; i--){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  } \n  field[x][y] = 1;\n  return ans;\n}\n \nint main(void){\n\n  while(cin >> n >> m, n + m){\n    \n    memset(field, 0, sizeof(field));\n    num = 0;\n    for(int i = 0;i < m;i++){\n      for(int j = 0;j < n;j++){\n\tcin >> field[i][j];\n\tif(field[i][j] == 2){\n\t  si = i;\n\t  sj = j;\n\t}\n\telse num += field[i][j];\n      }\n    }\n    cout << dfs(si, sj) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  if(unlikely(flag == (1 << n) - 1)){\n    return can[idn];\n  }else{\n    if(idn != n)\n      if(likely((ok[flag] & (1 << idn)) == 0)) return 0;\n\n    // printf(\"%d %d %d\\n\", xx, yy, flag);\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(1){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        if(unlikely(idn != n)){\n          if(flag & (1 << idn)) break;\n          ret += solve(idn, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(!ret && idn - n)\n      ok[flag] &= ~(1 << idn);\n\n    return ret;\n  }\n}\n\nint main(){\n  while(1){\n    int w = getInt();\n    int h = getInt();\n\n    int i, j, k;\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      f[i][j] = getInt();\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j] != 0){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    /*\n    REP(i,1<<n){\n      ok[i] = false;\n      REP(j,n) if((i & (1 << j)) == 0){\n        int xx = x[j];\n        int yy = y[j];\n        REP(k,4){\n          int xxx = nx[k][yy][xx];\n          int yyy = ny[k][yy][xx];\n          if(f[yyy][xxx] == 2){\n            ok[i] = true;\n            goto next;\n          }\n        }\n      }\n    next:;\n    }\n    */\n\n    REP(i, 1<<n) ok[i] = (1 << n) - 1;\n\n    int ans = solve(n, 0);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nstruct STATE\n{\n\tint grid[10][10];\n\tint x, y;\n\tint num;\n};\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n, m + n){\n\t\tSTATE start;\n\t\tmemset(&start, 0, sizeof(STATE));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tscanf(\"%d\", &start.grid[i][j]);\n\t\t\t\tif (start.grid[i][j] == 2){\n\t\t\t\t\tstart.x = i;\n\t\t\t\t\tstart.y = j;\n\t\t\t\t}\n\t\t\t\tstart.num += !!start.grid[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tqueue<STATE> que;\n\t\tque.push(start);\n\t\twhile (!que.empty()){\n\t\t\tSTATE st = que.front(); que.pop();\n\t\t\tif (st.num == 0){\n\t\t\t\tres++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint i = 1;\n\t\t\t\twhile (true){\n\t\t\t\t\tint tx = st.x + dx[dir] * i;\n\t\t\t\t\tint ty = st.y + dy[dir] * i;\n\t\t\t\t\t\n\t\t\t\t\tif (tx < 0 || tx >= n || ty < 0 || ty >= m) break;\n\t\t\t\t\tif (st.grid[tx][ty] == 3) break;\n\t\t\t\t\t\n\t\t\t\t\tif (st.grid[tx][ty] == (1 + (st.num == 1))){\n\t\t\t\t\t\tSTATE tmp = st;\n\t\t\t\t\t\ttmp.grid[tx][ty] = 3;\n\t\t\t\t\t\ttmp.x = tx;\n\t\t\t\t\t\ttmp.y = ty;\n\t\t\t\t\t\ttmp.num--;\n\t\t\t\t\t\tque.push(tmp);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\n\tint ans=0;\n\trep(k,4) rep(a,deg[id][k]) {\n\t\tint next_id=adj[id][k][a];\n\t\tif((picked&(1<<next_id))==0){\n\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(dp[id].size()<30000) dp[id][picked]=ans;\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nconst int LIM = 16;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=LIM){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=LIM){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int N = 25;\nconst int MEMO_LIM = (1<<20);\nbool adj[N][N];\nint up[N][N];\nbool visit[N];\nint memo[MEMO_LIM][N];\nint n;\nvector<P> house;\n\nvoid check(int an, int bn)\n{\n  P a = house[an];\n  P b = house[bn];\n  \n  if (a.first!=b.first && a.second!=b.second) {\n    return;\n  }\n\n  int st = 0;\n  if (a.second==b.second) {\n    int s = min(a.first, b.first);\n    int t = max(a.first, b.first);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].second!=a.second) continue;\n      int x = house[i].first;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n  else if (a.first==b.first) {\n    int s = min(a.second, b.second);\n    int t = max(a.second, b.second);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].first!=a.first) continue;\n      int x = house[i].second;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n\n  adj[an][bn] = adj[bn][an] = true;\n  up[an][bn] = up[bn][an] = st;\n}\n\nint f(int p, int st)\n{\n  if (p==n-1 && st==(1<<n)-1) {\n    return 1;\n  }\n  if (p==n-1 && st!=0) return 0;\n  \n  if (st <= MEMO_LIM) {\n    if (memo[st][p]!=-1) {\n      return memo[st][p];\n    }\n  }\n  \n  int res = 0;\n\n  for (int i=0; i < n; ++i) {\n    if (visit[i]) continue;\n    if (adj[p][i]==false) continue;\n    if ((up[p][i] & st)>0) continue;\n    visit[i] = true;\n    res += f(i, (st|(1<<i)));\n    visit[i] = false;\n  }\n  \n  if (st <= MEMO_LIM) {\n    memo[st][p] = res;\n  }\n  return res;\n}\n\nint main()\n{\n  int w, h;\n  while (cin>>w>>h) {\n    if (!w && !h) break;\n\n    fill(&adj[0][0], &adj[N-1][N], false);\n    fill(&up[0][0], &up[N-1][N], 0);\n\n    house.clear();\n    P ch;\n    for (int i=0; i < h; ++i) {\n      for (int j=0; j < w; ++j) {\n\tint val;\n\tcin >> val;\n\tif (val==1) {\n\t  house.push_back(P(i,j));\n\t}\n\telse if (val==2) {\n\t  ch = P(i,j);\n\t}\n      }\n    }\n\n    house.push_back(ch);\n\n    n = house.size();\n    for (int i=0; i < n; ++i) {\n      for (int j=i+1; j < n; ++j) {\n\tcheck(i, j);\n      }\n    }\n\n    fill(&memo[0][0], &memo[MEMO_LIM-1][N], -1);\n    fill(visit, visit+N, 0);\n    int ans = f(n-1, 0);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n//#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>15||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=15&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=15?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n//#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>17||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=17&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=17?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nint m,n;\nint in[11][11];\n\nstruct House {\n  int x,y;\n  bool chapel, visited;\n  House *link[4]; // 0:north, 1:east, 2:south, 3:west\n};\nHouse houses[11][11];\n\nint dfs(House *h, int cnt) {\n  if (cnt == 0) {\n    for (int k=0; k<4; ++k) {\n      House *nh = h->link[k];\n      while(nh != NULL && nh->visited) nh = nh->link[k];\n      if (nh != NULL && nh->chapel) return 1;\n    }\n    return 0;\n  }\n\n  int ret = 0;\n  for (int k=0; k<4; ++k) {\n    if (h->link[k] == NULL) continue;\n    House *nh;\n    if (h->link[k]->chapel) nh = h->link[k]->link[k];\n    else nh = h->link[k];\n    while(nh != NULL && (nh->visited || nh->chapel)) nh = nh->link[k];\n    if (nh != NULL && !nh->visited) {\n      nh->visited = true;\n      ret += dfs(nh, cnt-1);\n      nh->visited = false;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  while(cin>>n>>m, n|m) {\n    for (int i=0; i<m; ++i) for (int j=0; j<n; ++j) cin>>in[i][j];\n    for (int i=0; i<m; ++i) for (int j=0; j<n; ++j) {\n        houses[i][j].chapel = houses[i][j].visited = false;\n        houses[i][j].x = j, houses[i][j].y = i;\n        for (int k=0; k<4; ++k) houses[i][j].link[k] = NULL;\n      }\n\n    int cx,cy = -1,cnt=0;\n    for (int i=0; i<m; ++i)\n      for (int j=0; j<n; ++j) {\n        if (in[i][j] == 2) {houses[i][j].chapel = true; cy = i, cx = j; }\n        else if (in[i][j] == 1) cnt++;\n\n        // link\n        if (in[i][j] == 1 || in[i][j] == 2) {\n          for (int k=j+1; k<n; ++k)\n            if (in[i][k] == 1 || in[i][k] == 2) {\n              houses[i][j].link[1] = &houses[i][k];\n              houses[i][k].link[3] = &houses[i][j];\n              break;\n            }\n          for (int k=i+1; k<m; ++k)\n            if (in[k][j] == 1 || in[k][j] == 2) {\n              houses[i][j].link[2] = &houses[k][j];\n              houses[k][j].link[0] = &houses[i][j];\n              break;\n            }\n        }\n      }\n\n    assert(cy != -1);\n    cout<<dfs(&houses[cy][cx],cnt)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][25];\nint map[10][10];\n\n//bit????????????\nint dp[24][1<<23];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(dp[now][bit]>=0){return dp[now][bit];}\n\tif(now==goal/*||bit==0*/){\n\t\treturn ((now==goal&&bit==0)?0:1);\n\t}\n\t\n\tint res = 0;\n\tfor(auto iter=graph[now];*iter!=empty;++iter){\n\t\tif(bit&(1<<*iter)){\n\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\t#endif\n\treturn dp[now][bit]=res;\n}\nint main()\n{\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]];\n\t\t\tfor(int ox=0;ox<x;++ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int oy=0;oy<y;++oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto iter=map[goal];iter!=map[goal]+20;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto iter=graph[goal];*iter!=empty;++iter){\n\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t}\n\tstd::cout << res << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nconst int K=16;\nint memo[1<<K][23];\nint half;\nint target;\nint ng;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}\n\t//cout << done << \", \" << i << \", \" << j << \": \" << ret << endl;\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tint c=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(char si, char sj, char cnt, int vis):ni(si),nj(sj),cnt(cnt),vis(vis){}\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n/*\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n*/\n\nstruct Queue{\n  int p;\n  state *V;\n  Queue():p(0){V=new state[1<<20];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){\n    V[p++]=t;\n  }\n  state & front(){\n    return V[p-1];\n  }\n  void pop(){--p;}\n  bool empty(){\n    return p==0;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  int ni,nj;\n  int housenum=0;\n  int chi=charch.fr;int chj=charch.sc;\n  \n  for(int k = 0; k < MAXDIR; ++k){\n    housenum += M[chi][chj].linkmax[k];\n  }\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    ni = st_now.ni;\n    nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    if( st_now.cnt >= housenum ){\n      int left = housenum;\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n    }\n\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\tpi next = M[ni][nj].link[k][v];\n\tif( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t  qs.push( state(next.fr,next.sc,st_now.cnt + 1,st_now.vis|( 1<<houseId[next.fr][next.sc])));\n\t  break;\n\t}\n      }\n    }\n\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc,0,0);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nsigned main(){\ncout << 36 << endl;\ncout << 57 << endl;\ncout << 419957 << endl;\ncout << 256548 << endl;\ncout << 1831764 << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 18;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s, int &order)\n{\n\torder++;\n\tint noBits = CountBit(s);\n\tif (x == sx && y == sy && noBits == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (noBits < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0, cnt = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, noBits))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]), cnt);\n\t}\n\torder += cnt;\n\tif (noBits < MAX && cnt >= 10) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0, cnt));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num<=22||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=22&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=22?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <cstring>\n\nusing Pair = std::pair<int, int>;\n\nint w, h;\nPair ch;\n\nstd::vector<int> px[10], py[10];\nint map[11][11];\nstd::vector<Pair> houses;\nunsigned int mask;\n\nint dfs(int y, int x, unsigned int used) {\n    used |= 1u << map[y][x];\n    \n    if((used & mask) == mask) {\n        if(ch.first == y) {\n            auto st = std::upper_bound(py[y].begin(), py[y].end(), std::min(x, ch.second));\n            auto en = std::lower_bound(py[y].begin(), py[y].end(), std::max(x, ch.second));\n    \n            if(en - st > 0) {\n                return 0;\n            }else {\n                return 1;\n            }\n        }else if(ch.second == x) {\n            auto st = std::upper_bound(px[x].begin(), px[x].end(), std::min(y, ch.first));\n            auto en = std::lower_bound(px[x].begin(), px[x].end(), std::max(y, ch.first));\n    \n            if(en - st > 0) {\n                return 0;\n            }else {\n                return 1;\n            }\n        }else \n            return 0;\n    }\n    \n    int ans = 0;\n    auto pxit = std::lower_bound(px[x].begin(), px[x].end(), y);\n    auto pyit = std::lower_bound(py[y].begin(), py[y].end(), x);\n    \n    if(pxit != px[x].begin()) {\n        auto it = pxit - 1;\n        while(1) {\n            if(used & (1 << map[*it][x])) {\n                break;\n            }\n            \n            ans += dfs(*it, x, used);\n            \n            if(it == px[x].begin())\n                break;\n            \n            --it;\n        }\n    }\n    \n    if(pxit != px[x].end()) {\n    for(auto it = pxit + 1; it != px[x].end(); ++it) {\n        if(used & (1 << map[*it][x])) {\n            break;\n        }\n            \n        ans += dfs(*it, x, used);\n    }\n    }\n    \n    if(pyit != py[y].begin()) {\n        auto it = pyit - 1;\n        while(1) {\n            if(used & (1 << map[y][*it])) {\n                break;\n            }\n            \n            ans += dfs(y, *it, used);\n            \n            if(it == py[y].begin())\n                break;\n            \n            --it;\n        }\n    }\n    \n    if(pyit != py[y].end()) {\n    for(auto it = pyit + 1; it != py[y].end(); ++it) {\n        if(used & (1 << map[y][*it])) {\n            break;\n        }\n            \n        ans += dfs(y, *it, used);\n    }\n    }\n    \n    return ans;\n}\n\nint main() {\n    while(std::cin >> w >> h, w + h) {\n    houses.clear();\n    for(auto&& v : px)\n        v.clear();\n    for(auto&& v : py)\n        v.clear();\n    \n    memset(map, -1, sizeof(map));\n    \n    int in;\n    for(int i = 0; i < h; ++i) {\n        for(int j = 0; j < w; ++j) {\n            std::cin >> in;\n            \n            if(in == 1) {\n                px[j].push_back(i);\n                py[i].push_back(j);\n                map[i][j] = houses.size();\n                houses.push_back({i, j});\n            }else if(in == 2) {\n                ch = {i, j};\n            }\n        }\n    }\n    \n    for(int i = 0; i < houses.size(); ++i) {\n        mask |= 1 << i;\n    }\n    \n    std::cout << dfs(ch.first, ch.second, 0) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct QUE {\n    P house;\n    int count;\n    vector<int> visit;\n    QUE() {}\n    QUE(P a, int b, vector<int> c) {\n        this->house=a;\n        this->count=b;\n        this->visit=c;\n    }\n};\n\nvoid solve(int m, int n) {\n    vector<int> mp[n];\n    P church;\n    int cnt=0;\n\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<m; ++j) {\n            int temp;\n            cin >> temp;\n            if(temp==1) {\n                ++cnt;\n                mp[i].push_back(cnt);\n            } else if(temp==2) {\n                church=P(i,j);\n                mp[i].push_back(100);\n            } else {\n                mp[i].push_back(0);\n            }\n        }\n    }\n\n    int ans=0;\n\n    queue<QUE> q;\n    vector<int> vis(cnt+1,0);\n    q.push(QUE(church,0,vis));\n    while(!q.empty()) {\n        QUE now=q.front(); q.pop();\n\n        int dh[4]={-1,0,1,0};\n        int dw[4]={0,1,0,-1};\n        for(int i=0; i<4; ++i) {\n            P h=now.house;\n            while(true) {\n                h.first+=dh[i];\n                h.second+=dw[i];\n\n                if(h.first<0 || h.first>=n || h.second<0 || h.second>=m) break;\n\n                int v=mp[h.first][h.second];\n                if(v!=0 && v!=100 && now.visit[v]==0) {\n                    now.visit[v]=1;\n                    q.push(QUE(h,now.count+1,now.visit));\n                    now.visit[v]=0;\n                    break;\n                } else if(v==100 && now.count==cnt) {\n                    ++ans;\n                    break;\n                }\n            }\n        }\n    }\n\n    cout << ans << endl;\n    \n    return;\n}\n\nint main() {\n    int m,n;\n    while(true) {\n        cin >> m >> n;\n        if(n==0 && m==0) break;\n        solve(m,n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h,int k){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny],k-1);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(k >= 10) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    map<P,int> a;\n    dp = a;\n    cout << solve(1,0,c) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum Block {BLANK, HOUSE, CHURCH};\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nint cy, cx;\n\nint dfs(vector<vector<int>>& map, int y, int x, int remain) {\n  if(!remain) return (y == cy) || (x == cx);\n  auto bak = map[y][x];\n  map[y][x] = BLANK;\n  int res = 0;\n  for(auto d: NEXT) {\n    int ny = y + d[Y];\n    int nx = x + d[X];\n    while(true) {\n      if(ny < 0 || map.size() <= ny) break;\n      if(nx < 0 || map[ny].size() <= nx) break;\n      if(map[ny][nx] == HOUSE) {\n        res += dfs(map, ny, nx, remain - 1);\n        break;\n      }\n      ny += d[Y];\n      nx += d[X];\n    }\n  }\n  map[y][x] = bak;\n  return res;\n}\n\nint main() {\n  int m, n;\n  while(cin >> m >> n, m | n) {\n    vector<vector<int>> map(n, vector<int>(m));\n    for(auto& line: map) for(auto& i: line) cin >> i;\n\n    int all = 0;\n    for(int i = 0; i < n; ++i) for(int j = 0; j < m; ++j) {\n      if(map[i][j] == HOUSE) ++all;\n      if(map[i][j] == CHURCH) {\n        cy = i;\n        cx = j;\n      }\n    }\n    cout << dfs(map, cy, cx, all) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint px[24],py[24],kx,ky;\nint H,W,N,ans;\nint dp[11][11] = {0};\nint dx[2][2] = {{0,1},{0,-1}};\nint dy[2][2] = {{1,0},{-1,0}};\n\nint sub(int a,int b){return a & (~b);}\n\nint able(int x1,int y1,int x2,int y2,int bit){\n\tif(x1 != x2 && y1 != y2) return false;\n\t\n\tif(x1>x2)swap(x1,x2);\n\tif(y1>y2)swap(y1,y2);\n\tif(y1==y2)x1++,x2--;\n\telse if(x1==x2)y1++,y2--;\n\tint all = dp[y2][x2];\n\tall &= ~dp[y1-1][x2];\n\tall &= ~dp[y2][x1-1];\n\tall |= dp[y1-1][x1-1] & ~(dp[y2][x1-1] & dp[y1-1][x2]);\n\treturn !(all & bit);\n}\n\nvoid dfs(int pos,int x,int y,int bit){\n\tif(bit==(1<<N)-1){\n\t\tif(able(x,y,kx,ky,bit)) ans++;\n\t\treturn;\n\t}\n\trep(i,N){\n\t\tif( !(bit & (1<<i)) && able(x,y,px[i],py[i],bit) ){\n\t\t\tdfs(i,px[i],py[i],bit|(1<<i));\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin >> W >> H ,W){\n\t\tN = ans = 0;\n\t\trep(i,11)rep(j,11)dp[i][j] = 0;\n\t\trep(i,H)rep(j,W){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif(t==1)dp[i+1][j+1] = (1<<N);\n\t\t\tif(t==1)px[N] = j+1 , py[N++] = i+1;\n\t\t\tif(t==2)kx = j+1 , ky = i+1;\n\t\t}\n\t\trep(i,H)rep(j,W) dp[i+1][j+1] |= dp[i+1][j];\n\t\trep(i,W)rep(j,H) dp[j+1][i+1] |= dp[j][i+1]; \n\t\t\n\t\tpx[N] = kx , py[N] = ky;\n\t\tdfs(-1,kx,ky,0);\n\t\t\n\t\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#pragma warning(disable : 4996)\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], d[4] = { 1, 0, -1, 0 };\nint solve(int sx, int sy, int depth) {\n\tif (depth == n) {\n\t\tif (sx == gx || sy == gy) return 1;\n\t\treturn 0;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (rng(tx, ty)) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth + 1);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += d[i];\n\t\t\tty += d[i ^ 1];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &x[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint ans,wx,wy,rem;\nint tab[10][10];\ninline void solve(int nx,int ny,int rem){\n    int nowx,nowy;\n    nowx=nx;nowy=ny;\nLA:\n   nowx++;\n   if(nowx>=wx) goto LB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB:         \n\n    nowx=nx,nowy=ny;\nMA:\n   nowx--;\n   if(0>nowx) goto MB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto MB;\n   }\n   goto MA;\nMB:         \n    nowx=nx,nowy=ny;\nNA:\n   nowy++;\n   if(nowy>=wy) goto NB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto NB;\n   }\n   goto NA;\nNB:        \n    nowx=nx,nowy=ny;\nOA:\n   nowy--;\n   if(0>nowy) goto OB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        int i,j;\n        for(i=0;i<n;i++)for(j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\ninline bool in(int x, int y, int w, int h)\n{\n\treturn x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint main()\n{\n\twhile(true) {\n\t\t\n\t\tint w, h, n;\n\t\tint field[16][16];\n\t\tvector<pair<int, int> > house;\n\t\tpair<int, int> church;\n\t\t\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif(t == 0) {\n\t\t\t\t\tt = -1;\n\t\t\t\t} else if(t == 1) {\n\t\t\t\t\tt = house.size();\n\t\t\t\t\thouse.push_back(make_pair(x, y));\n\t\t\t\t} else if(t == 2) {\n\t\t\t\t\tt = -2;\n\t\t\t\t\tchurch = make_pair(x, y);\n\t\t\t\t}\n\t\t\t\tfield[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tn = house.size();\n\t\t\n\t\tint reach[23][23];\n\t\tint dx[] = {-1, 0, 0, 1}, dy[] = {0, -1, 1, 0};\n\t\tstatic int dp[23][1 << 23];\n\t\t\n\t\tmemset(dp[0], 0, (1 << 23) * n * sizeof(int));\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tdp[tgt][1 << tgt] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int a = 0; a < n; ++a) {\n\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\n\t\t\t\tif(a == b)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\treach[a][b] = (1 << a) | (1 << b);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\t\n\t\t\t\t\tint cx = house[a].first, cy = house[a].second;\n\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tint t = field[cx][cy];\n\t\t\t\t\t\tif(t == b) {\n\t\t\t\t\t\t\treach[a][b] = bit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(t >= 0) {\n\t\t\t\t\t\t\tbit |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 1; bit < (1 << n); ++bit) {\n\t\t\t\n\t\t\tfor(int a = 0; a < n; ++a) {\n\t\t\t\t\n\t\t\t\tif((bit & (1 << a)) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint prev = bit ^ (1 << a);\n\t\t\t\t\n\t\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\t\n\t\t\t\t\tint filter = ((prev & (1 << b)) == 0) * ((prev & reach[a][b]) != 0);\n\t\t\t\t\tdp[a][bit] += filter * dp[b][prev];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tans += dp[tgt][(1 << n) - 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int N = 25;\nconst int MEMO_LIM = (1<<24);\nbool adj[N][N];\nint up[N][N];\nint memo[MEMO_LIM][N];\nint n;\nvector<P> house;\n\nint near[N];\nint nearN[N];\nbool dame[N][N];\n\nvoid check(int an, int bn)\n{\n  P a = house[an];\n  P b = house[bn];\n  \n  if (a.first!=b.first && a.second!=b.second) {\n    return;\n  }\n\n  int st = 0;\n  if (a.second==b.second) {\n    int s = min(a.first, b.first);\n    int t = max(a.first, b.first);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].second!=a.second) continue;\n      int x = house[i].first;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n  else if (a.first==b.first) {\n    int s = min(a.second, b.second);\n    int t = max(a.second, b.second);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].first!=a.first) continue;\n      int x = house[i].second;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n\n  adj[an][bn] = adj[bn][an] = true;\n  up[an][bn] = up[bn][an] = st;\n}\n\nint f(int p, int st)\n{\n  if (p==n-1 && st==(1<<n)-1) {\n    return 1;\n  }\n  if (p==n-1 && st!=0) return 0;\n  \n  if (st < MEMO_LIM) {\n    if (memo[st][p]!=-1) {\n      return memo[st][p];\n    }\n  }\n\n  if ((st & near[n-1])==near[n-1]) {\n    if (st != (1<<(n-1))-1) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n  \n  for (int i=0; i < n-1; ++i) {\n    if ((st & near[i])==near[i] && (st&(1<<i))==0) {\n      return 0;\n    }\n  }\n\n  /*\n  static bool flag[N];\n  bool x = false;\n  fill(flag, flag+N, false);\n  for (int i=0; i < n; ++i) {\n    if ((st&(1<<i))!=0) continue;\n    if (flag[i]) continue;\n    if (x) return 0;\n    x = true;\n    queue<int> que;\n    que.push(i);\n    while (que.size()) {\n      int now = que.front();\n      que.pop();\n      if (flag[now]) continue;\n      flag[now] = true;\n      for (int j=0; j < n; ++j) {\n\tif (flag[j]) continue;\n\tif ((st&(1<<j)) > 0) continue;\n\tif (adj[now][j] == false) continue;\n\tif ((up[now][j] & st)>0) continue;\n\tque.push(j);\n      }\n    }\n  }\n  */\n  \n  int res = 0;\n\n  for (int i=0; i < n; ++i) {\n    if ((st&(1<<i))>0) continue;\n    if (adj[p][i]==false) continue;\n    if ((up[p][i] & st)>0) continue;\n    res += f(i, (st|(1<<i)));\n  }\n  \n  if (st < MEMO_LIM) {\n    memo[st][p] = res;\n  }\n  return res;\n}\n\nint main()\n{\n  int w, h;\n  while (cin>>w>>h) {\n    if (!w && !h) break;\n\n    fill(&adj[0][0], &adj[N-1][N], false);\n    fill(&up[0][0], &up[N-1][N], 0);\n\n    house.clear();\n    P ch;\n    for (int i=0; i < h; ++i) {\n      for (int j=0; j < w; ++j) {\n\tint val;\n\tcin >> val;\n\tif (val==1) {\n\t  house.push_back(P(i,j));\n\t}\n\telse if (val==2) {\n\t  ch = P(i,j);\n\t}\n      }\n    }\n\n    house.push_back(ch);\n\n    n = house.size();\n    for (int i=0; i < n; ++i) {\n      for (int j=i+1; j < n; ++j) {\n\tcheck(i, j);\n      }\n    }\n\n    for (int i=0; i < n; ++i) {\n      near[i] = 0;\n      for (int j=0; j < n; ++j) {\n\tif (adj[i][j] && up[i][j]==0) {\n\t  near[i] |= (1<<j);\n\t}\n      }\n    }\n\n    fill(&memo[0][0], &memo[MEMO_LIM-1][N], -1);\n    int ans = f(n-1, 0);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n;\nint dp[25][1024 * 1024 * 16], town[11][11];\nP p[25];\nvoid bfs(int now, int flag);\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tint s, count = 1;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\ts = count;\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = count;\n\t\t\t\t\tp[count] = make_pair(i, j);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (i = 1; i <= n;i++){\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcout << town[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tbfs(s, 0);\n\t\tj = 1;\n\t\tfor (i = 0; i < count - 1; i++)\n\t\t\tj = j * 2;\n\t\tcout << dp[s][j - 1] << endl;\n\t}\n}\nvoid bfs(int start, int flag) {\n\tdp[start][flag] = 1;\n\tvector<P> que;\n\tque.push_back(make_pair(flag, start));\n\twhile (!que.empty()) {\n\t\t//cout << que.size()<<' ';\n\t\tque.erase(unique(que.begin(), que.end()), que.end());\n\t\tsort(que.begin(), que.end());\n\t\tP pp;\n\t\tpp = que[0];\n\t\tstart = pp.second; flag = pp.first;\n\t\t//cout << start << ' ' <<  static_cast<std::bitset<24> >(flag)  << endl;\n\t\tque.erase(que.begin());\n\t\tfor (j = p[start].second; j <= m; j++) {\n\t\t\tif (town[p[start].first][j]&&j!=p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]-1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t//\tcout << 1 << endl;\n\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].second; j >= 1; j--) {\n\t\t\tif (town[p[start].first][j]&&j != p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]- 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t//\tcout << 2 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j <= n; j++) {\n\t\t\tif (town[j][p[start].second]&& j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t//\tcout << 3 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j >= 1; j--) {\n\t\t\tif (town[j][p[start].second] && j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t\t//cout << 4 << endl;\n\t\t\t\t\t//cout << j << ' ' << flag2 << ' ' << p[start].first << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* よいウンコードの例 *.\n\n#include <cstdio>\n#include <stack>\n\nusing namespace std;\n\n#define EMPTY 0\n#define YET_DELIVERED 1\n#define CHURCH 2\n#define DELIVERED 3\n\nint m;\nint n;\nint count;\nint house_num;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0,  0, -1, 1};\nint map[10][10];\n\nvoid rec(char x, char y) {\n\tchar i;\n\tchar times = 0;\n    char x2;\n    char y2;\n    stack<char> s;\n\tchar k;\n\ncall:\n    i = 0;\n\nloop:\n    x2 = x;\n    y2 = y;\n\n\twhile (1) {\n\t\tx2 += dx[i];\n\t\ty2 += dy[i];\n\n\t\tif (x2 >= m || x2 < 0 || y2 >= n || y2 <0) break;\n\t\tif (map[y2][x2] == DELIVERED) break;\n\n\t\tif (map[y2][x2] == CHURCH) {\n\t\t\tif (times == house_num) {\n\t\t\t\t++count;\n\t\t\t}\n\t\t} else if (map[y2][x2] == YET_DELIVERED) {\n\t\t\tmap[y2][x2] = DELIVERED;\n\t\t\ts.push(i);\n\t\t\ts.push(x);\n\t\t\ts.push(y);\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\t++times;\n\t\t\tgoto call;\n\t\t}\n\nresume:\n        ;\n\t}\n\n\t++i;\n\tif (i < 4) {\n    \tgoto loop;\n    }\n\n\tif (s.empty()) return ;\n\n    map[y][x] = YET_DELIVERED;\n\t--times;\n\tx2 = x;\n\ty2 = y;\n\ty = s.top(); s.pop();\n\tx = s.top(); s.pop();\n\ti = s.top(); s.pop();\n\n\tgoto resume;\n}\n\n\nint main() {\n\twhile (1) {\n\t\tint i;\n\t\tint church_x, church_y;\n\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif ((m | n) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tcount = 0;\n\t\thouse_num = 0;\n\n\t\tfor (i=0; i<n; i++) {\n\t\t\tint j;\n\n\t\t\tfor (j=0; j<m; j++) {\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t\tif (map[i][j] == YET_DELIVERED) {\n\t\t\t\t\t++house_num;\n\t\t\t\t} else if (map[i][j] == CHURCH) {\n\t\t\t\t\tchurch_x = j;\n\t\t\t\t\tchurch_y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trec((char)church_x, (char)church_y);\n\t\tprintf(\"%d\\n\", count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//25\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint m,n;\nint g[10][10];\nint cx,cy;\nbool ra[10][10];\n\nint dfs(int x,int y,int r,int nr){\n  if(r==0){\n    return ra[y][x];\n  }else if(nr==0){\n    return 0;\n  }else{\n    int a=0;\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      int nx=x,ny=y;\n      for(;;){\n\tnx+=d[i];\n\tny+=d[i+1];\n\tif(nx<0||m<=nx||ny<0||n<=ny||g[ny][nx]==-1)break;\n\tif(g[ny][nx]==1){\n\t  g[ny][nx]=-1;\n\t  a+=dfs(nx,ny,r-1,nr-ra[ny][nx]);\n\t  g[ny][nx]=1;\n\t}\n      }\n    }\n    return a;\n  }\n}\n\nint main(){\n  while(cin>>m>>n,m|n){\n    int nh=0;\n    int x,y;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tcin>>g[i][j];\n\tnh+=g[i][j]==1;\n\tif(g[i][j]==2){\n\t  cx=x=j;\n\t  cy=y=i;\n\t}\n      }\n    }\n    fill(ra[0],ra[n],false);\n    int nr=0;\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      int nx=x;\n      int ny=y;\n      for(;;){\n\tnx+=d[i];\n\tny+=d[i+1];\n\tif(nx<0||m<=nx||ny<0||n<=ny)break;\n\tif(g[ny][nx]==1){\n\t  ra[ny][nx]=true;\n\t  nr++;\n\t  break;\n\t}\n      }\n    }\n    cout<<dfs(x,y,nh,nr)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint grid[10][10];\n\nstruct STATE\n{\n\tint done, x, y;\n\t\n\tbool operator < (const STATE& t) const{\n\t\tif (done == t.done){\n\t\t\tif (x == t.x){\n\t\t\t\treturn y < t.y;\n\t\t\t}\n\t\t\treturn x < t.x;\n\t\t}\n\t\treturn done < t.done;\n\t}\n};\n\nint main()\n{\n\tint m, n;\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tint num = 0;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 0){\n\t\t\t\t\tgrid[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 1){\n\t\t\t\t\tgrid[i][j] = num++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgrid[i][j] = -2;\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<STATE, int> dp;\n\t\tmap<STATE, int> dp2;\n\t\tdp[{0, sx, sy}] = 1;\n\t\tint res = 0;\n\t\twhile (true){\n\t\t\tif (dp.count({(1 << num) - 1, sx, sy})){\n\t\t\t\tres = dp[{(1 << num) - 1, sx, sy}];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (auto ite = dp.begin(); ite != dp.end(); ++ite){\n\t\t\t\tSTATE st = (*ite).first;\n\t\t\t\t\n\t\t\t\t//printf(\"%d %d %d %d\\n\", st.done, st.x, st.y, dp[st]);\n\t\t\t\t\n\t\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\t\tint i = 1;\n\t\t\t\t\twhile (true){\n\t\t\t\t\t\tint tx = st.x + dx[dir] * i;\n\t\t\t\t\t\tint ty = st.y + dy[dir] * i;\n\t\t\t\t\t\tif (tx < 0 || tx >= n || ty < 0 || ty >= m) break;\n\t\t\t\t\t\tif (grid[tx][ty] == -2){\n\t\t\t\t\t\t\tif (st.done == (1 << num) - 1){\n\t\t\t\t\t\t\t\tdp2[{st.done, tx, ty}] += dp[st];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((grid[tx][ty] != -1) && (~st.done & (1 << grid[tx][ty]))){\n\t\t\t\t\t\t\tdp2[{st.done | (1 << grid[tx][ty]), tx, ty}] += dp[st];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp.clear();\n\t\t\tdp = dp2;\n\t\t\tdp2.clear();\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint W, H, N = 0;\nint mas[11][11];\nbool isin(int y, int x)\n{\n    return (y >= 0 && x >= 0 && y < H && x < W);\n}\nint dfs(int y, int x, int bit)\n{\n    int ret = 0;\n    if(bit == 0) return (1);\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        while(isin(ny, nx) && (mas[ny][nx] < 0 || (bit != (1 << N) && mas[ny][nx] == N) || (bit & ~(1 << mas[ny][nx])) == bit)) ny += dy[i], nx += dx[i];\n        if(isin(ny, nx)) ret += dfs(ny, nx, bit & ~(1 << mas[ny][nx]));\n    }\n    return (ret);\n}\n\nint main()\n{\n    int px, py;\n    while(cin >> W >> H, W || H) {\n        for(int i = 0; i < H; i++) {\n            for(int j = 0; j < W; j++) {\n                cin >> mas[i][j];\n                if(mas[i][j] == 0) mas[i][j] = -1;\n                else if(mas[i][j] == 1) mas[i][j] = N, N++;\n                else py = i, px = j;\n            }\n        }\n        mas[py][px] = N;\n        cout << dfs(py, px, (1 << (N + 1)) - 1) << endl;\n    }\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint M, N;\nint map[20][20];\nint sx, sy;\nint T;\n\nbool v[20][20];\n\nint solve(int x, int y, int c) {\n  int ret = 0;\n\n  if (map[x][y] == 2 && c > 1) {\n    if (c == T+2) return 1;\n    else          return 0;\n  }\n  if (c > 1) v[x][y] = true;\n  for (int ty=y-1; ty>=0; ty--) {\n    if (v[x][ty]) break;\n    if (map[x][ty]) ret += solve(x, ty, c+1);\n  }\n  for (int ty=y+1; ty<N; ty++) {\n    if (v[x][ty]) break;\n    if (map[x][ty]) ret += solve(x, ty, c+1);\n  }\n  for (int tx=x-1; tx>=0; tx--) {\n    if (v[tx][y]) break;\n    if (map[tx][y]) ret += solve(tx, y, c+1);\n  }\n  for (int tx=x+1; tx<M; tx++) {\n    if (v[tx][y]) break;\n    if (map[tx][y]) ret += solve(tx, y, c+1);\n  }\n  v[x][y] = false;\n  return ret;\n}\n\nint main() {\n  while (cin >> M >> N) {\n    if (M == 0 && N == 0) break;\n    T = 0;\n    for (int y=0; y<N; y++) {\n      for (int x=0; x<M; x++) {\n        cin >> map[x][y];\n        if (map[x][y] == 1) T++;\n        if (map[x][y] == 2) sx = x, sy = y;\n        v[x][y] = false;\n      }\n    }\n\n    cout << solve(sx, sy, 1) << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\tif (itr != memo.end()) return itr->second;\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\treturn memo[state] = sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint m,n,gx,gy,sum;\nint house[10][10];\nbool used[10][10];\nvector<int>V[10][10][4];\nint rec(int x,int y,bool used[10][10]){\n    int cnt=0;\n    REP(i,n)REP(j,m)if(used[j][i])cnt++;\n    if(cnt==sum&&x==gx&&y==gy)return 1;\n    int res=0;\n    for(int i=x-1;i>=0;i--){\n        if(house[i][y]&&!used[i][y]){\n            used[i][y]=true;\n            res+=rec(i,y,used);\n            used[i][y]=false;\n            break;\n        }\n    }\n    for(int i=x+1;i<m;i++){\n        if(house[i][y]&&!used[i][y]){\n            used[i][y]=true;\n            res+=rec(i,y,used);\n            used[i][y]=false;\n            break;\n        }\n    }\n    for(int i=y-1;i>=0;i--){\n        if(house[x][i]&&!used[x][i]){\n            used[x][i]=true;\n            res+=rec(x,i,used);\n            used[x][i]=false;\n            break;\n        }\n    }\n    for(int i=y+1;i<n;i++){\n        if(house[x][i]&&!used[x][i]){\n            used[x][i]=true;\n            res+=rec(x,i,used);\n            used[x][i]=false;\n            break;\n        }\n    }\n    return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin>>m>>n;\n        if(m==0&&n==0)break;\n        memset(used,false,sizeof(used));\n        sum=0;\n        REP(i,n)REP(j,m){\n            cin>>house[j][i];\n            if(house[j][i]==2){gx=j;gy=i;}\n            if(house[j][i])sum++;\n        }\n        cout<<rec(gx,gy,used)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nP adj[10][10][4][23];\nbool visited[10][10];\nint m,n,field[10][10],deg[10][10][4],house_num,cnt;\n\nint dfs(int i,int j){\n\tif(field[i][j]==2) return cnt==house_num+1;\n\n\tint ans=0;\n\tcnt++;\n\trep(k,4){\n\t\trep(a,deg[i][j][k]){\n\t\t\tP &p=adj[i][j][k][a];\n\t\t\tif(visited[p.y][p.x]) break;\n\n\t\t\tvisited[p.y][p.x]=true;\n\t\t\tans+=dfs(p.y,p.x);\n\t\t\tvisited[p.y][p.x]=false;\n\t\t}\n\t}\n\tcnt--;\n\treturn ans;\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&n,&m),n;){\n\t\tint charch_x,charch_y;\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\n\t\trep(i,m) rep(j,n) {\n\t\t\trep(k,4){\n\t\t\t\tdeg[i][j][k]=0;\n\t\t\t\tif(field[i][j]!=0){\n\t\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\t\tif(field[y][x]!=0) adj[i][j][k][deg[i][j][k]++]=P(x,y);\n\t\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=0; cnt=1;\n\t\trep(k,4){\n\t\t\trep(a,deg[charch_y][charch_x][k]){\n\t\t\t\tP &p=adj[charch_y][charch_x][k][a];\n\t\t\t\tvisited[p.y][p.x]=true;\n\t\t\t\tans+=dfs(p.y,p.x);\n\t\t\t\tvisited[p.y][p.x]=false;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\nusing namespace std;\n\nconst int MAX = 10;\nconst int MAX_N = 23;\nconst int G = 23;\nconst int dy[] = {1,0,-1,0};\nconst int dx[] = {0,1,0,-1};\n\nint mask[MAX_N+1][MAX_N+1];\nshort node_id[MAX_N+1][MAX_N+1];\nshort grid[MAX][MAX];\n\nint H,W,N;\n\ntypedef pair<int,int>P;\nmap<P,int>mp;\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> grid[i][j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_N+1 ; i++){\n    for(int j = 0 ; j < MAX_N+1 ; j++){      \n      node_id[i][j] = -1;\n      mask[i][j] = -1;\n    }\n  }\n  mp.clear();\n}\n\nvoid makeMask(){\n  N = 0;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] == 1)node_id[i][j] = N++;\n      if(grid[i][j] == 2)node_id[i][j] = G;\n    }\n  }\n  \n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] != 0){\n\tfor(int d = 0 ; d < 4 ; d++){\n\t  int x = j;\n\t  int y = i;\n\t  int bit = 0;\n\t  while(1){\n\t    x += dx[d]; y += dy[d];\n\t    if(!(0 <= x && x < W && 0 <= y && y < H))break;\n\t    if(node_id[y][x] == -1)continue;\n\t    if(node_id[y][x] != G){\n\t      bit |= (1 << node_id[y][x]);\n\t    }\n\t    mask[node_id[i][j]][node_id[y][x]] = bit;\n\t    //cout <<\"from = \" << node_id[i][j] << \" to = \" << node_id[y][x] <<  \" bit = \" << bit << endl;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint dfs(int now,int bit){\n  if(mp.count(P(now,bit)) != 0)return mp[P(now,bit)];\n  int& ret = mp[P(now,bit)];\n  \n  if(bit == (1 << N)-1){\n    if((mask[now][G] & bit) != 0)return ret = 0;\n    return ret = 1;\n  }\n\n  for(int to = 0 ; to < N ; to++){\n    if((mask[now][to] & bit) == 0){\n      ret += dfs(to,bit|(1 << to));\n    }    \n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> W >> H,H|W){\n\n    init();\n    input();\n    makeMask();\n\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      if(mask[G][i] != -1)res += dfs(i,(1 << i));\n    }\n    cout << res << endl;\n    \n    /*\n\n    // dp init\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = 0;\n      }\n    }\n    \n    // dp start\n    for(int i = 0 ; i < N ; i++){\n      if(mask[G][i] != -1)dp[i][(1 << i)] = 1;\n    }\n    \n    //cout << \"N = \" << N << endl;\n    for(int i = 0 ; i < (1 << N) ; i++){\n      for(int j = 0 ; j < N ; j++){\n      //if(dp[i][j] == 0)continue;\n\tfor(int k = 0 ; k < N ; k++){\n\t  //cout <<\"mask = \" <<  mask[j][k] << endl;\n\t  if((mask[j][k] & i) == 0){\n\t    dp[k][i|(1 << k)] += dp[j][i];\n\t  }\n\t}\n      }\n    }\n\n    // dp goal\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      if(mask[i][G] != -1 && ((mask[i][G]&((1 << N)-1)) == 0))res += dp[i][(1 << N)-1];\n    }\n    cout << res << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 3004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint sum = 0, ans = 0, ky, kx, a[12][12], f[12][12];\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\n\nvoid dfs(int y, int x, int cnt){\n\tfor(int i = 0;i < 4;i++){\n\t\tint yy = y;\n\t\tint xx = x;\n\t\twhile(1){\n\t\t\tyy += dy[i];\n\t\t\txx += dx[i];\n\t\t\tif(a[yy][xx] == -1)break;\n\t\t\tif(a[yy][xx] == 1 && f[yy][xx] == 0){\n\t\t\t\tf[yy][xx] = 1;\n\t\t\t\tdfs(yy, xx, cnt+1);\n\t\t\t\tf[yy][xx] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a[yy][xx] == 2 && cnt == sum){\n\t\t\t\tans++;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(1){\n\t\tscanf(\"%d%d\",&w, &h);\n\t\tif(w == 0)break;\n\t\tfill((int*)a, (int*)(a+12), -1);\n\t\tfill((int*)f, (int*)(f+12), 0);\n\t\tsum = ans = 0;\n\t\trrep(i,h)rrep(j,w){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tif(a[i][j] == 2){ky = i;kx = j;}\n\t\t\tif(a[i][j] == 1)sum++;\n\t\t}\n\t\t\n\t\tdfs(ky, kx, 0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\n\nint m, n;\nint maze[11][11];\nint house[11][11];\nint housecount;\n\nint dfs(int y, int x, int depth) {\n\tint ret = 0;\n\tfor (int i = y - 1; i >= 0; --i) {\n\t\tif (depth == housecount && maze[i][x] == 2)\n\t\t\treturn 1;\n\n\t\tif (maze[i][x] == 1) {\n\t\t\tmaze[i][x] = 0;\n\t\t\tret += dfs(i, x, depth + 1);\n\t\t\tmaze[i][x] = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = y + 1; i < n; ++i) {\n\t\tif (depth == housecount && maze[i][x] == 2)\n\t\t\treturn 1;\n\n\t\tif (maze[i][x] == 1) {\n\t\t\tmaze[i][x] = 0;\n\t\t\tret += dfs(i, x, depth + 1);\n\t\t\tmaze[i][x] = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = x - 1; i >= 0; --i) {\n\t\tif (depth == housecount && maze[y][i] == 2)\n\t\t\treturn 1;\n\n\t\tif (maze[y][i] == 1) {\n\t\t\tmaze[y][i] = 0;\n\t\t\tret += dfs(y, i, depth + 1);\n\t\t\tmaze[y][i] = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = x + 1; i < m; ++i) {\n\t\tif (depth == housecount && maze[y][i] == 2)\n\t\t\treturn 1;\n\n\t\tif (maze[y][i] == 1) {\n\t\t\tmaze[y][i] = 0;\n\t\t\tret += dfs(y, i, depth + 1);\n\t\t\tmaze[y][i] = 1;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (depth == housecount)\n\t\treturn 0;\n\n\treturn ret;\n}\n\nint main() {\n\twhile (cin >> m >> n && (m || n)) {\n\t\thousecount = 0;\n\t\tfor (int i = 0; i < 11; i++)for (int j = 0; j < 11; j++)maze[i][j] = house[i][j] = 0;\n\t\tint si, sj;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcin >> maze[i][j];\n\t\t\t\tif (maze[i][j] == 1) {\n\t\t\t\t\thouse[i][j] = housecount;\n\t\t\t\t\thousecount++;\n\t\t\t\t}\n\t\t\t\tif (maze[i][j] == 2) {\n\t\t\t\t\tsi = i, sj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dfs(si, sj, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <cstring>\n \nusing Pair = std::pair<int, int>;\n \nint w, h;\nPair ch;\n \nstd::vector<int> px[10], py[10];\nint map[11][11];\nstd::vector<Pair> houses;\nunsigned int mask;\n \nint dfs(int y, int x, unsigned int used) {\n    used |= 1u << map[y][x];\n     \n    if((used & mask) == mask) {\n        if(ch.first == y) {\n            return 1;\n        }else if(ch.second == x) {\n            return 1;\n        }else\n            return 0;\n    }\n     \n    int ans = 0;\n    auto pxit = std::lower_bound(px[x].begin(), px[x].end(), y);\n    auto pyit = std::lower_bound(py[y].begin(), py[y].end(), x);\n     \n    if(pxit != px[x].begin()) {\n        auto it = pxit - 1;\n        while(1) {\n            if(!(used & (1 << map[*it][x]))) {\n                ans += dfs(*it, x, used);\n                break;\n            }\n\n            if(it == px[x].begin())\n                break;\n             \n            --it;\n        }\n    }\n     \n    {\n        auto it = pxit;\n        \n        if(pxit != px[x].end()) {\n            if(*it == y)\n                ++it;\n            \n            for(; it != px[x].end(); ++it) {\n                if(!(used & (1 << map[*it][x]))) {\n                    ans += dfs(*it, x, used);\n                    break;\n                }\n            }\n        }\n    }\n     \n    if(pyit != py[y].begin()) {\n        auto it = pyit - 1;\n        while(1) {\n            if(!(used & (1 << map[y][*it]))) {\n                ans += dfs(y, *it, used);                \n                break;\n            }\n\n            if(it == py[y].begin())\n                break;\n             \n            --it;\n        }\n    }\n    \n    {\n        auto it = pyit;\n        \n        if(pyit != py[y].end()) {\n            if(*it == x)\n                ++it;\n\n            for(; it != py[y].end(); ++it) {\n                if(!(used & (1 << map[y][*it]))) {\n                    ans += dfs(y, *it, used);\n                    break;\n                }\n            }\n        }\n    }\n     \n    return ans;\n}\n \nint main() {\n    while(std::cin >> w >> h, w + h) {\n    houses.clear();\n    for(auto&& v : px)\n        v.clear();\n    for(auto&& v : py)\n        v.clear();\n     \n    memset(map, -1, sizeof(map));\n     \n\n    int in;\n    \n    for(int i = 0; i < h; ++i) {\n        for(int j = 0; j < w; ++j) {\n            std::cin >> in;\n             \n            if(in == 1) {\n                px[j].push_back(i);\n                py[i].push_back(j);\n                map[i][j] = houses.size();\n                houses.push_back({i, j});\n            }else if(in == 2) {\n                ch = {i, j};\n            }\n        }\n    }\n     \n    for(int i = 0; i < houses.size(); ++i) {\n        mask |= 1 << i;\n    }\n     \n    std::cout << dfs(ch.first, ch.second, 0) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<hash_map>\n#include<cstring>\nusing namespace std;\nint encode(int v,int x,int y){return v*256U+x*16+y;}\nunsigned getv(unsigned a){return a/256;}\nint getx(unsigned a){return (a%256)/16;}\nint gety(unsigned a){return (a%256)%16;}\nint main(){\n\tint w,h,m[12][12],x,y,cx,cy,n,t;\n\tint dx[]={1,0,-1,0},dy[]={0,1,0,-1},d;\n\tfor(;cin>>w>>h,w;){\n\t\tn=0;\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(y=0;y<h;y++){\n\t\t\tfor(x=0;x<w;x++){\n\t\t\t\tcin>>t;\n\t\t\t\tif(t==1)\n\t\t\t\t\tm[1+x][1+y]=++n;\n\t\t\t\telse{\n\t\t\t\t\tm[1+x][1+y]=-1;\n\t\t\t\t\tif(t==2)\n\t\t\t\t\t\tcx=1+x,cy=1+y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttypedef __gnu_cxx::hash_map<unsigned,int>M;\n\t\ttypedef M::iterator I;\n\t\tM q[24];\n\t\tq[n][encode((1<<(n+1))-1,cx,cy)]=1;\n\t\tfor(;n;n--){\n\t\t\tfor(I it=q[n].begin();it!=q[n].end();++it){\n\t\t\t\tunsigned a=it->first;\n\t\t\t\tfor(d=0;d<4;d++){\n\t\t\t\t\tint tv=getv(a),tx=getx(a),ty=gety(a);\n\t\t\t\t\tfor(;;){\n\t\t\t\t\t\ttx+=dx[d],ty+=dy[d];\n\t\t\t\t\t\tt=m[tx][ty];\n\t\t\t\t\t\tif(t>=0&&tv&1<<t){\n\t\t\t\t\t\t\tif(t){\n\t\t\t\t\t\t\t\ttv^=1<<t;\n\t\t\t\t\t\t\t\tq[n-1][encode(tv,tx,ty)]+=it->second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"q[%d].size()=%d\\n\",n-1,q[n-1].size());\n\t\t\tq[n].clear();\n\t\t}\n\t\tint ans=0;\n\t\tfor(I it=q[0].begin();it!=q[0].end();++it){\n\t\t\tunsigned a=it->first;\n\t\t\tif(getx(a)==cx||gety(a)==cy)\n\t\t\t\tans+=it->second;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n, coun;\nint dp[25][1024 * 1024 * 16], town[11][11];\nP p[25];\nvoid bfs(int now, int flag);\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tint s;\n\t\tcoun = 1;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\ts = coun;\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = coun;\n\t\t\t\t\tp[coun] = make_pair(i, j);\n\t\t\t\t\tcoun++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (i = 1; i <= n;i++){\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcout << town[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tbfs(s, 0);\n\t\tj = 1;\n\t\tfor (i = 0; i < coun - 1; i++)\n\t\t\tj = j * 2;\n\t\tcout << dp[s][j - 1] << endl;\n\t}\n}\nvoid bfs(int start, int flag) {\n\tdp[start][flag] = 1;\n\tvector<P> que;\n\tque.push_back(make_pair(flag, start));\n\twhile (!que.empty()) {\n\t\t//cout << que.size()<<' ';\n\t\tP pp;\n\t\tpp = que[0];\n\t\tstart = pp.second; flag = pp.first;\n\t\t//cout << start << ' ' <<  static_cast<std::bitset<24> >(flag)  << endl;\n\t\tque.erase(que.begin());\n\t\tfor (j = p[start].second; j <= m; j++) {\n\t\t\tif (town[p[start].first][j]&&j!=p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]-1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tif (coun - 1 != town[p[start].first][j] && dp[town[p[start].first][j]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].second; j >= 1; j--) {\n\t\t\tif (town[p[start].first][j]&&j != p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]- 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tif (coun - 1 != town[p[start].first][j] && dp[town[p[start].first][j]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t\t\t//\tcout << 2 << endl;\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j <= n; j++) {\n\t\t\tif (town[j][p[start].second]&& j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tif (coun - 1 != town[j][p[start].second] && dp[town[j][p[start].second]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t\t\t//\tcout << 3 << endl;\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j >= 1; j--) {\n\t\t\tif (town[j][p[start].second] && j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tif (coun - 1 != town[j][p[start].second] && dp[town[j][p[start].second]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t\t\t//cout << 4 << endl;\n\t\t\t\t\t\t//cout << j << ' ' << flag2 << ' ' << p[start].first << endl;\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=18){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=20){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nvector<unordered_map<int,int> > memo;\n\nvoid MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\nint DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[house_num][state]!=-1) return memo[house_num][state];\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(G[house_num][i].S_-1))&1)!=1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(memo[house_num][state]==0&&house_num!=0&&((state>>(G[house_num][i].S_-1))&1)!=1){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\tif(memo[house_num][state]==0) memo[house_num][state]=result2+1;\n\t//cout << memo[house_num][state] << ' ' << result2 << endl;\n\treturn memo[house_num][state]+result1-1;\n}\n\nlli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tmemo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define X real() \n#define Y imag() \nusing namespace std;\ntypedef complex<int> cli;\ntypedef vector<cli> vcl;\ntypedef vector<int> vi;\nint num=0;\nint ans=0;\nint direct[40][4];\nvoid search(int now,int reach){\n\tif(now==0){\n\t\tif(reach+1==2<<num)\n\t\t\tans++;\n\t\t\n\t\treturn;\n\t}\n\tREP(i,4){\n\t\tint next=direct[now][i];\n\t\twhile((next!=-1) && (1<<next & (reach|1) )) next=direct[next][i];\n\t\tif(next!=-1)\n\t\t\tsearch(next,reach+(1<<next ));\n\t\tint bn=next;\n\t\tnext=direct[now][i];\n\t\twhile((next!=-1) && (1<<next & reach )) next=direct[next][i];\n\t\tif(next!=-1 && bn!=next)\n\t\t\tsearch(next,reach+(1<<next ));\n\n\t}\n}\nint main() {\n\tint m,n;\n\twhile(cin >> m >> n && n){\n\tans=0;\n\tnum=0;\n\tvi edge[40];\t\n\tint maps[11][11]={};\n\tREP(i,n)\n\t\tREP(j,m){\n\t\t\tcin >> maps[i][j];\n\t\t\tif(maps[i][j]==2){\n\t\t\t\tmaps[i][j]=0;\n\t\t\t}\n\t\t\telse if(maps[i][j]){\n\t\t\t\tmaps[i][j]=++num;\n\t\t\t}\n\t\t\telse \n\t\t\t\tmaps[i][j]=-1;\n\t\t}\n\tint nx,ny[11]={};\n\tREP(i,11)\n\t\tny[i]=-1;\n\tREP(i,40)\n\t\tREP(j,4)\n\t\t\tdirect[i][j]=-1;\n\tREP(i,n){\n\t\tnx=-1;\n\t\tREP(j,m){\n\t\t\tif(maps[i][j]>=0){\n\t\t\t\tif(nx>=0){\n\t\t\t\t\tedge[maps[i][j]].push_back(maps[i][nx]);\n\t\t\t\t\tedge[maps[i][nx]].push_back(maps[i][j]);\n\t\t\t\t\tdirect[maps[i][j]][3]=maps[i][nx];\n\t\t\t\t\tdirect[maps[i][nx]][0]=maps[i][j];\n\t\t\t\t}\n\t\t\t\tnx=j;\n\t\t\t\tif(ny[j]>=0){\n\t\t\t\t\tedge[maps[i][j]].push_back(maps[ny[j]][j]);\n\t\t\t\t\tedge[maps[ny[j]][j]].push_back(maps[i][j]);\n\t\t\t\t\tdirect[maps[i][j]][1]=maps[ny[j]][j];\n\t\t\t\t\tdirect[maps[ny[j]][j]][2]=maps[i][j];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tny[j]=i;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\tREP(i,edge[0].size())\n\t\tsearch(edge[0][i],1<<edge[0][i]);\n\t\tcout <<ans << endl;\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<int,int> dp[24];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(dp[id].count(vis))return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)<18)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    for(int i=0;i<pn;i++)dp[i].clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint n, m, a[10][10], maxN = 0;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint dfs(int y, int x, int counter) {\n  int ans = 0;\n  for (int i = 0; i < 4; i++) {\n    int ny = y, nx = x;\n    while (1) {\n      ny += dy[i], nx += dx[i];\n      if (ny < 0 || nx < 0 || ny >= n || nx >= m) break;\n      // if (a[ny][nx] == -1) break;\n      if (a[ny][nx] == 1) {\n        if (counter > 0) {\n          a[ny][nx] = -1;\n          ans += dfs(ny, nx, counter - 1);\n          a[ny][nx] = 1;\n        }\n        break;\n      }\n      if (a[ny][nx] == 2 && counter == 0) return 1;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    int cx, cy;\n    maxN = 0;\n    for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) {\n      scanf(\"%d\", &a[i][j]);\n      if (a[i][j] == 2) cy = i, cx = j;\n      if (a[i][j] == 1) maxN++;\n    }\n    printf(\"%d\\n\", dfs(cy, cx, maxN));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h,int k){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny],k-1);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) < 10) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0,c) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\nint w,h;\nint map[10][10];\nbool passed[10][10];\nint gx,gy;\nint count_max;\nint func(int x,int y, int count)\n{\n\tif(count>0)\n\t{\n\t\t#ifdef DEBUG\n\t\tstd::cout << \"IN:\"<<x<<' '<<y<<' '<<count<<'\\n';\n\t\t#endif\n\t\tif(count==count_max+1||(x==gx&&y==gy)){\n\t\t\tif((count==count_max+1)&&x==gx&&y==gy){return 1;}\n\t\t\treturn 0;\n\t\t}\n\t\tpassed[x][y]=true;\n\t}\n\tint res = 0;\n\tfor(int nx = x-1;nx>=0;--nx){\n\t\tif(!passed[nx][y] && map[nx][y]!=0){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int nx = x+1;nx<w;++nx){\n\t\tif(!passed[nx][y] && map[nx][y]!=0){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y-1;ny>=0;--ny){\n\t\tif(!passed[x][ny] && map[x][ny]!=0){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y+1;ny<h;++ny){\n\t\tif(!passed[x][ny] && map[x][ny]!=0){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpassed[x][y]=false;\n\treturn res;\n}\n\nint main()\n{\n\tfor(;;){\n\tstd::cin >> w>>h;if(w==0&&h==0){break;}\n\tcount_max=0;\n\tfor(int y=0;y<h;++y)for(int x=0;x<w;++x){\n\t\tstd::cin >> map[x][y];\n\t\tif(map[x][y]==1){++count_max;}\n\t\tif(map[x][y]==2){gx=x;gy=y;}\n\t}\n\t//std::cout << \"a:\"<<gx<<' '<<gy<<' '<<count_max<<'\\n';\n\t\n\tint res = 0;\n\tstd::cout << func(gx,gy,0)<<std::endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//const int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\n\n//const double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nint dir[] = { 1,0,-1,0,1 };\n\nvoid Search(const vector<vector<int>>&v, const vector<vector<int>>&b, const vector<vector<int>>&l, const vector<vector<int>>&r, const vector<vector<int>>&d, const vector<vector<int>>&u, int x, int y, int use, int &ans) {\n\t//cout << y << \" \" << x << \" \" << use << endl;\n\tif (x) {\n\t\tint cy = y, cx = l[y][x - 1];\n\t\twhile (cy >= 0 && cx >= 0 && cy < v.size() && cx < v[0].size()) {\n\t\t\tif (v[cy][cx] == 1) {\n\t\t\t\tif (((use >> b[cy][cx]) & 1) == 0) {\n\t\t\t\t\tif (cx) {\n\t\t\t\t\t\tcx = l[cy][cx - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSearch(v, b, l, r, d, u, cx, cy, use ^ (1 << b[cy][cx]), ans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v[cy][cx] == 2 && !use) {\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cx) {\n\t\t\t\tcx = l[cy][cx - 1];\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tif (x + 1 < W) {\n\t\tint cy = y, cx = r[y][x + 1];\n\t\twhile (cy >= 0 && cx >= 0 && cy < v.size() && cx < v[0].size()) {\n\t\t\tif (v[cy][cx] == 1) {\n\t\t\t\tif (((use >> b[cy][cx]) & 1) == 0) {\n\t\t\t\t\tif (cx + 1 < W) {\n\t\t\t\t\t\tcx = r[cy][cx + 1];\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSearch(v, b, l, r, d, u, cx, cy, use ^ (1 << b[cy][cx]), ans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v[cy][cx] == 2 && !use) {\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cx + 1 < W) {\n\t\t\t\tcx = r[cy][cx + 1];\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tif (y) {\n\t\tint cy = d[y - 1][x], cx = x;\n\t\twhile (cy >= 0 && cx >= 0 && cy < v.size() && cx < v[0].size()) {\n\t\t\tif (v[cy][cx] == 1) {\n\t\t\t\tif (((use >> b[cy][cx]) & 1) == 0) {\n\t\t\t\t\tif (cy) {\n\t\t\t\t\t\tcy = d[cy - 1][cx];\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSearch(v, b, l, r, d, u, cx, cy, use ^ (1 << b[cy][cx]), ans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v[cy][cx] == 2 && !use) {\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cy) {\n\t\t\t\tcy = d[cy - 1][cx];\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tif (y + 1 < H) {\n\t\tint cy = u[y + 1][x], cx = x;\n\t\twhile (cy >= 0 && cx >= 0 && cy < v.size() && cx < v[0].size()) {\n\t\t\tif (v[cy][cx] == 1) {\n\t\t\t\tif (((use >> b[cy][cx]) & 1) == 0) {\n\t\t\t\t\tif (cy + 1 < H) {\n\t\t\t\t\t\tcy = u[cy + 1][cx];\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSearch(v, b, l, r, d, u, cx, cy, use ^ (1 << b[cy][cx]), ans);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v[cy][cx] == 2 && !use) {\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cy + 1 < H) {\n\t\t\t\tcy = u[cy + 1][cx];\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> W >> H;\n\twhile(W){\n\tvector<vector<int>>v(H, vector<int>(W));\n\tvector<vector<int>>b(H, vector<int>(W));\n\tvector<vector<int>>l(H, vector<int>(W, -1));\n\tvector<vector<int>>r(H, vector<int>(W, -1));\n\tvector<vector<int>>d(H, vector<int>(W, -1));\n\tvector<vector<int>>u(H, vector<int>(W, -1));\n\tint cnt = 0;\n\tfor (auto &i : v)for (auto &j : i)cin >> j;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (v[i][j] == 1)b[i][j] = cnt++;\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (v[i][j]) {\n\t\t\t\tl[i][j] = j;\n\t\t\t\tr[i][j] = j;\n\t\t\t\td[i][j] = i;\n\t\t\t\tu[i][j] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 1; j < W; j++)if (l[i][j] == -1)l[i][j] = l[i][j - 1];\n\t\tfor (int j = W - 2; j >= 0; j--)if (r[i][j] == -1)r[i][j] = r[i][j + 1];\n\t}\n\tfor (int j = 0; j < W; j++) {\n\t\tfor (int i = 1; i < H; i++)if (d[i][j] == -1)d[i][j] = d[i - 1][j];\n\t\tfor (int i = H - 2; i >= 0; i--)if (u[i][j] == -1)u[i][j] = u[i + 1][j];\n\t}\n\tint sy, sx;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (v[i][j] == 2)sy = i, sx = j;\n\t\t}\n\t}\n\tint ans = 0;\n\tSearch(v, b, l, r, d, u, sx, sy, (1 << cnt) - 1, ans);\n\tcout << ans << endl;\n\tcin>>W>>H;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint H[10][10];\nint hx[24], hy[24];\nint dp[1 << 24][24];\n\n\nint main() {\n\tint m, n, cnt = 1;\n\tscanf(\"%d%d\", &m, &n);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tint h; scanf(\"%d\", &h);\n\t\t\tH[i][j] = -1;\n\t\t\tif (h == 1) {\n\t\t\t\thx[cnt] = i; hy[cnt] = j;\n\t\t\t\tH[i][j] = cnt++;\n\t\t\t}\n\t\t\tif (h == 2) { H[i][j] = 0; hx[0] = i; hy[0] = j; }\n\t\t}\n\t}\n\tdp[0][0] = 1;\n\trep(i, 1 << cnt) {\n\t\trep(j, cnt) {\n\t\t\tif (!dp[i][j])continue;\n\t\t\tif ((i | j) && !((i >> j) & 1))continue;\n\t\t\tint x = hx[j], y = hy[j];\n\t\t\tfor (int k = 1; x + k < n; k++) {\n\t\t\t\tif (~H[x + k][y]) {\n\t\t\t\t\tif ((i >> H[x + k][y]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x + k][y])][H[x + k][y]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; x - k >= 0; k++) {\n\t\t\t\tif (~H[x - k][y]) {\n\t\t\t\t\tif ((i >> H[x - k][y]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x - k][y])][H[x - k][y]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; y + k < m; k++) {\n\t\t\t\tif (~H[x][y + k]) {\n\t\t\t\t\tif ((i >> H[x][y + k]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x][y + k])][H[x][y + k]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; y - k >= 0; k++) {\n\t\t\t\tif (~H[x][y - k]) {\n\t\t\t\t\tif ((i >> H[x][y - k]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x][y - k])][H[x][y - k]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[(1 << cnt) - 1][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <bitset>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int m, n;\n  while(cin>>m>>n,m||n) {\n    int ba[m][n];\n    int num = 0;\n    int sx,sy;\n    REP(i,n) {\n      REP(j,m) {\n        int a;\n        cin >> a;\n        if (a==1) {\n          ba[j][i] = ++num;\n        } else {\n          ba[j][i] = 0;\n          if (a == 2) {\n            sx=j;sy=i;\n          }\n        }\n      }\n    }\n    const int dx[] = {0,1,0,-1};\n    const int dy[] = {-1,0,1,0};\n    map<int, int> mp;\n    mp[((1<<num)-1)*100+sx*10+sy] = 1;\n    REP(i, num) {\n      map<int, int> nextmp;\n      FOR(it, mp) {\n        int hoge = it->first;\n        int S = hoge/100;\n        int x = (hoge%100)/10;\n        int y = hoge%10;\n//        cout << bitset<7>(S) << \" \" << x << \" \"<<y << \" \" << it->second << endl;\n        REP(k,4) {\n          int xx = x, yy = y;\n          while(1) {\n            xx += dx[k]; yy += dy[k];\n            if (xx<0 || xx>=m || yy<0||yy>=n) break;\n            if (ba[xx][yy]) {\n              if (S&(1<<(ba[xx][yy]-1))) {\n                nextmp[(S-(1<<(ba[xx][yy]-1)))*100+xx*10+yy] += it->second;\n                break;\n              }\n            }\n          }\n        }\n      }\n      //  cout << endl;\n      mp = nextmp;\n    }\n    int res = 0;\n    REP(y,n) {\n      REP(x,m) {\n        if (x==sx || y==sy)\n          res += mp[x*10+y];\n      }\n    }\n    cout << res << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint h,w;\nint gx,gy;\nint map[10][10];\nint ans;\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nint t;\nvoid DFS(int x,int y,int len){\n\tfor(int i=0;i<4;i++){\n\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\twhile(true){\n\t\t\tif(xx>=0&&xx<w&&yy>=0&&yy<h){\n\t\t\t\tif(map[yy][xx]==1){\n\t\t\t\t\tmap[yy][xx]=0;\n\t\t\t\t\tDFS(xx,yy,len+1);\n\t\t\t\t\tmap[yy][xx]=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[yy][xx]==2&&len==t){\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse break;\n\t\t\txx+=dx[i],yy+=dy[i];\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\tcin>>w>>h;\n\tif(w==0&&h==0)break;\n\tt=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>map[i][j];\n\t\t\tif(map[i][j]==2){\n\t\t\t\tgy=i,gx=j;\n\t\t\t}\n\t\t\tif(map[i][j]==1)t++;\n\t\t}\n\t}\n\tans=0;\n\tDFS(gx,gy,0);\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[24], y[24], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[++p] = i, y[p] = j, dat[i][j] = p;\n\t\t\tif (f[i][j] == 2)x[0] = i, y[0] = j;\n\t\t}p++;\n\t\tmap<P, int>dp;\n\t\tdp[{0, 0}] = 1;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif ((f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) || (f[nx][ny] == 2 && i == (1 << p) - 2)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[{(1 << p) - 1, 0}]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nInt s[20][20],idx[20][20],cnt,pru;\nint u[20][20][4];\nint num[20];\nusing P = pair<Int, Int>;\nvector<vector<vector<P> > > G;\nmap<Int, Int> dp;\n\nInt dfs(Int y,Int x,Int b){\n  if((b&pru)==pru){\n    if((pru>>idx[y][x])&1) return b==(1<<cnt)-1;\n    return 0;\n  }\n  \n  //Int hs=((y*20+x)<<30)+b;\n  //if(dp.count(hs)) return dp[hs];\n  //Int &res=dp[hs];\n  Int res=0;\n  \n  for(Int k=0;k<4;k++){\n    Int z=idx[y][x];\n    for(auto p:G[z][k]){\n      Int ny,nx;\n      tie(ny,nx)=p;\n      if(s[ny][nx]<0) break;\n      if(s[ny][nx]==2){\n\tres+=b==(1<<cnt)-1;\n      }else{\n\ts[ny][nx]*=-1;\n\tInt nb=b^(1<<idx[ny][nx]);\n\tint flg=1;\n\tfor(int i=0;i<4;i++){\n\t  if(u[ny][nx][i]>=cnt) continue; \n\t  num[u[ny][nx][i]]--;\n\t  if((~nb>>u[ny][nx][i])&1)\n\t    flg&=num[u[ny][nx][i]]>=1;\n\t}\n\tif(flg) res+=dfs(ny,nx,nb);\n\tfor(int i=0;i<4;i++){\n\t  if(u[ny][nx][i]>=cnt) continue; \n\t  num[u[ny][nx][i]]++;\n\t}\n\ts[ny][nx]*=-1;\n      }\n    }\n  }\n\t\n  return res;\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    cnt=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tidx[i][j]=cnt;\n\tcnt+=s[i][j]==1;\n      }\n    }\n    \n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) idx[i][j]=cnt;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};    \n\n    G.clear();\n    G.resize(cnt+1);\n    \n    memset(num,0,sizeof(num));    \n    for(Int y=0;y<h;y++){\n      for(Int x=0;x<w;x++){\n\tif(s[y][x]==0) continue;\n\tInt z=idx[y][x];\n\tG[z].resize(4);\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y,nx=x;\n\t  while(1){\n\t    ny+=dy[k],nx+=dx[k];\n\t    while(in(ny,nx)&&s[ny][nx]==0)\n\t      ny+=dy[k],nx+=dx[k];\n\t    if(!in(ny,nx)) break;\t    \n\t    G[z][k].emplace_back(ny,nx);\n\t  }\n\t}\n\t\n\tfor(Int k=0;k<4;k++){\n\t  u[y][x][k]=cnt+1;\n\t  for(auto p:G[z][k]){\n\t    u[y][x][k]=idx[p.first][p.second];\n\t    num[idx[p.first][p.second]]++;\n\t    break;\n\t  }\n\t}\n\t\n\tif(z==cnt){\n\t  pru=0;\n\t  for(Int k=0;k<4;k++){\n\t    for(auto p:G[z][k]){\n\t      pru|=(1<<idx[p.first][p.second]);\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    dp.clear();\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) cout<<dfs(i,j,0)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   (a >> b) & 1\n#define bitset(a,b)       a |= (1 << b)\n#define bitunset(a,b)    a &= ~(1 << b)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w,h;\n\twhile (scanf(\"%d %d\", &w, &h)) {\n\t\tif (!w && !h)\n\t\t\tbreak;\n\t\tvector<vector<int>> mp(w, vector<int>(h, -1));\n\t\tpii cha;\n\t\tvector<pii> homp;\n\t\tint homc = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tint a = 0;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tif (a == 2) {\n\t\t\t\t\tcha = { j,i };\n\t\t\t\t}\n\t\t\t\tif (a == 1) {\n\t\t\t\t\thomp.push_back({ j,i });\n\t\t\t\t\tmp[j][i] = homc;\n\t\t\t\t\thomc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thomp.push_back(cha);\n\t\tmap<pii, int> dp[2];//?±\\??´????????¨??°\n\t\tdp[0][{0, homc}] = 1;\n\t\tbool t = 0;\n\t\tREP(i, homc) {\n\t\t\tfor (auto cur : dp[t]) {\n\t\t\t\tpii curpos = homp[cur.first.second];\n\t\t\t\tint cnum;\n\t\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[t].clear();\n\t\t\tt = 1 - t;\n\t\t}\n\t\tint cnum, ans = 0;\n\t\tset<int> targets;\n\t\tfor (int j = cha.first; w > j; j++) {\n\t\t\tcnum = mp[j][cha.second];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.first; 0 <= j; j--) {\n\t\t\tcnum = mp[j][cha.second];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; h > j; j++) {\n\t\t\tcnum = mp[cha.first][j];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; 0 <= j; j--) {\n\t\t\tcnum = mp[cha.first][j];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (auto cur : dp[t]) {\n\t\t\tif (targets.find(cur.first.second) != targets.end())\n\t\t\t\tans += cur.second;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nmap<tuple<int, int, int>, int> dp;\nint tb[10][10];\nint sr, sc;\nint hs;\n\nint dfs(int nr, int nc, int bits) {\n\tif (dp.count({ nr,nc,bits })) return dp[{nr, nc, bits}];\n\tif (nr == sr && nc == sc && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if(~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(i, nc, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(i, nc, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(nr, j, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(nr, j, bits | 1 << x);\n\t}\n\t\n\treturn dp[{nr, nc, bits}] = res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tdp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tcout << dfs(sr, sc, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvi field(h,vi(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>field[i][j];\n\t\t\n\t\tvector<pii> homes;\n\t\tint counter=0;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(field[i][j]==1){\n\t\t\t\tfield[i][j]=++counter;\n\t\t\t\thomes.push_back(mp(i,j));\n\t\t\t}\n\t\t\telse if(field[i][j]==2){\n\t\t\t\tfield[i][j]=0;\n\t\t\t\thomes.insert(homes.begin(),mp(i,j));\n\t\t\t}\n\t\t\telse\n\t\t\t\tfield[i][j]=-1;\n\t\t}\n\t\t\n\t\tmap<pair<int,int>,int> m;\n\t\tm[mp(1,0)]=1;\n\t\tforeach(iter,m){\n\t\t\tm.erase(m.begin(),iter);\n\t\t\t\n\t\t\tint state=iter->first.first;\n\t\t\tint prev=iter->first.second;\n\t\t\tif(state==(1<<homes.size())-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tconst int di[]={-1,1,0,0};\n\t\t\tconst int dj[]={0,0,-1,1};\n\t\t\trep(i,4){\n\t\t\t\tint pi=homes[prev].first,pj=homes[prev].second;\n\t\t\t\tfor(;;){\n\t\t\t\t\tpi+=di[i];\n\t\t\t\t\tpj+=dj[i];\n\t\t\t\t\tif(pi<0 || h<=pi || pj<0 || w<=pj)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint homei=field[pi][pj];\n\t\t\t\t\tif(homei>=1){\n\t\t\t\t\t\tif(state&(1<<homei))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tm[mp(state|(1<<homei),homei)]+=iter->second;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(iter(m) iter=m.lower_bound(mp((1<<homes.size())-1,0));iter!=m.end();iter++){\n\t\t\tint prev=iter->first.second;\n\t\t\tint pi=homes[prev].first,pj=homes[prev].second;\n\t\t\tif(pi==homes[0].first || pj==homes[0].second)\n\t\t\t\tres+=iter->second;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<vector<int>>V; int H, W, cnt, vx, vy;\nvoid solve(vector<vector<int>> p,int x,int y) {\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tint cx = x, cy = y, cr = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) { if (p[i][j] == 3)cr++; }\n\t}\n\tif (cr == 0) { if (x == vx || y == vy)cnt++; return; }\n\tfor (int i = 0; i < 4; i++) {\n\t\tcx = x; cy = y;\n\t\twhile (true) {\n\t\t\tif (cx < 0 || cx >= H || cy < 0 || cy >= W)break;\n\t\t\tif (p[cx][cy] == 3) {\n\t\t\t\tvector<vector<int>>q = p;\n\t\t\t\tq[cx][cy] = 1;\n\t\t\t\tsolve(q, cx, cy);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcx += dx[i]; cy += dy[i];\n\t\t}\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; if (H == 0)break; cnt = 0;\n\t\tvector<vector<int>> a(H, vector<int>(W));\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) { vx = i; vy = j; }\n\t\t\t\tif (a[i][j] == 1)a[i][j] = 3;\n\t\t\t}\n\t\t}\n\t\tsolve(a, vx, vy);\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>17||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=17&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=17?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint H[10][10];\nint hx[24], hy[24];\nint *dp[1 << 24];\n\n\nint main() {\n\tint m, n;\n\twhile(scanf(\"%d%d\", &m, &n),m){\n        int cnt=1;\n        rep(i, n) {\n            rep(j, m) {\n                int h; scanf(\"%d\", &h);\n                H[i][j] = -1;\n                if (h == 1) {\n                    hx[cnt] = i; hy[cnt] = j;\n                    H[i][j] = cnt++;\n                }\n                if (h == 2) { H[i][j] = 0; hx[0] = i; hy[0] = j; }\n            }\n        }\n        rep(i,(1<<cnt)+1)dp[i]=new int[cnt];\n        dp[0][0] = 1;\n        rep(i, 1 << cnt) {\n            rep(j, cnt) {\n                if (!dp[i][j])continue;\n                if ((i | j) && !((i >> j) & 1))continue;\n                int x = hx[j], y = hy[j];\n                for (int k = 1; x + k < n; k++) {\n                    if (~H[x + k][y]) {\n                        if ((i >> H[x + k][y]) & 1)break;\n                        dp[i | (1 << H[x + k][y])][H[x + k][y]] += dp[i][j];\n                    }\n                }\n                for (int k = 1; x - k >= 0; k++) {\n                    if (~H[x - k][y]) {\n                        if ((i >> H[x - k][y]) & 1)break;\n                        dp[i | (1 << H[x - k][y])][H[x - k][y]] += dp[i][j];\n                    }\n                }\n                for (int k = 1; y + k < m; k++) {\n                    if (~H[x][y + k]) {\n                        if ((i >> H[x][y + k]) & 1)break;\n                        dp[i | (1 << H[x][y + k])][H[x][y + k]] += dp[i][j];\n                    }\n                }\n                for (int k = 1; y - k >= 0; k++) {\n                    if (~H[x][y - k]) {\n                        if ((i >> H[x][y - k]) & 1)break;\n                        dp[i | (1 << H[x][y - k])][H[x][y - k]] += dp[i][j];\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", dp[(1 << cnt) - 1][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\ntypedef pair<int,int> state;\n\nint main(){\n\tint n,m,field[10][10];\n\twhile(cin >> m >> n,n){\n\t\tint cnt = 0,x[25],y[25],sx,sy,res = 0;\n\t\tmap<state,int> ans;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif(field[i][j] == 2) {\n\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 1) {\n\t\t\t\t\tx[cnt] = i;\n\t\t\t\t\ty[cnt] = j;\n\t\t\t\t\tfield[i][j] = ++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx[cnt] = sx;\n\t\ty[cnt] = sy;\n\t\tpriority_queue<state,vector<state>,greater<state> > que;\n\t\tque.push(state(0,cnt));\n\t\tans[state(0,cnt)] = 1;\n\t\twhile(!que.empty()){\n\t\t\tstate st = que.top();que.pop();\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint nx = x[st.second] + dx[i],ny = y[st.second] + dy[i];\n\t\t\t\twhile(nx >= 0 && nx < n && ny >= 0 && ny < m){\n\t\t\t\t\tif(st.first == (1 << cnt) - 1){\n\t\t\t\t\t\tif(field[nx][ny] == -1){\n\t\t\t\t\t\t\tres += ans[st];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[nx][ny] > 0 && !(st.first >> (field[nx][ny] - 1) & 1)){\n\t\t\t\t\t\tstate now = state(st.first | (1 << (field[nx][ny] - 1)),field[nx][ny] - 1);\n\t\t\t\t\t\tif(!ans[now]) que.push(now);\n\t\t\t\t\t\tans[now] += ans[st];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tnx += dx[i];\n\t\t\t\t\tny += dy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.erase(ans.find(st));\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint memo[1<<19][23];\nint target;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif(done<(1<<19)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tif(done<(1<<19)&&table[i][j]>=0&&memo[done][table[i][j]]){\n\t\tmemo[done][table[i][j]]=ret;\n\t}\n\t//cout << done << \", \" << i << \", \" << j << \": \" << ret << endl;\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tint c=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(memo,-1,sizeof(int)*(23*(1<<min(c,19))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint f(int cur,int mask){\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <memory>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint field[12][12];\n\nint dfs(int cnt, int x, int y){\n  if(cnt == 0){\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      while(field[y2][x2] == 0){\n\ty2 += dy[i];\n\tx2 += dx[i];\n      }\n      if(field[y2][x2] == 2) return 1;\n    }\n    return 0;\n  }\n  int res = 0;\n  for(int i = 0; i < 4; i++){\n    int x2 = x + dx[i];\n    int y2 = y + dy[i];\n    while(field[y2][x2] == 0){\n      y2 += dy[i];\n      x2 += dx[i];\n    }\n    while(field[y2][x2] == 1){\n      field[y2][x2] = 3;\n      res += dfs(cnt - 1, x2, y2);\n      field[y2][x2] = 1;\n      x2 += dx[i];\n      y2 += dy[i];\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n, m, sx, sy, cnt;\n  while(cin >> m >> n && (n || m)){\n    cnt = 0;\n    fill(&field[0][0], &field[11][11] + 1, 3);\n    rep(i, n){\n      rep(j, m){\n\tcin >> field[i+1][j+1];\n\tif(field[i+1][j+1] == 2){\n\t  sx = j + 1;\n\t  sy = i + 1;\n\t}\n\tif(field[i+1][j+1] == 1){\n\t  cnt++;\n\t}\n      }\n    }\n    cout << dfs(cnt, sx, sy) << endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w;\nint m[16][16];\n\nint n;\nint sy, sx;\n\nconst int size = (1 << 23);\nint dp[size];\n\nint dfs(int y, int x, int b = (1 << n) - 1, int d = 0)\n{\n  if (b == 0){\n    return (y == sy || x == sx);\n  }\n\n  int &ret = dp[b];\n  ret = 0;\n  for (int i = y - 1; i >= 0; i--){\n    if (m[i][x] == -1) continue;\n    if (b & (1 << m[i][x])){\n      ret += dfs(i, x, b - (1 << m[i][x]), d * 10 + m[i][x]);\n      break;\n    }\n  }\n  for (int i = y + 1; i < h; i++){\n    if (m[i][x] == -1) continue;\n    if (b & (1 << m[i][x])){\n      ret += dfs(i, x, b - (1 << m[i][x]), d * 10 + m[i][x]);\n      break;\n    }\n  }\n  for (int i = x - 1; i >= 0; i--){\n    if (m[y][i] == -1) continue;\n    if (b & (1 << m[y][i])){\n      ret += dfs(y, i, b - (1 << m[y][i]), d * 10 + m[y][i]);\n      break;\n    }\n  }\n  for (int i = x + 1; i < w; i++){\n    if (m[y][i] == -1) continue;\n    if (b & (1 << m[y][i])){\n      ret += dfs(y, i, b - (1 << m[y][i]), d * 10 + m[y][i]);\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  while (cin >> w >> h, w){\n    n = 0;\n    memset(dp, -1, sizeof(dp));\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        cin >> m[i][j];\n        if (m[i][j] == 0) m[i][j] = -1;\n        if (m[i][j] == 2) {\n          sy = i; sx = j;\n          m[i][j] = -1;\n        }\n        if (m[i][j] == 1) m[i][j] = n++;\n      }\n    }\n\n    cout << dfs(sy, sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=20){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=20){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[24], y[24], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, o = 0;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[++p] = i, y[p] = j, dat[i][j] = p;\n\t\t\tif (f[i][j] == 2)x[0] = i, y[0] = j, dat[i][j] = 0;\n\t\t}p++;\n\t\tmap<P, int>dp;\n\t\tdp[{0, 0}] = 1;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif ((f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) || (f[nx][ny] == 2 && i == (1 << p) - 2)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++o >= 100000)dp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", dp[{(1 << p) - 1, 0}]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint n,m,x,y,ie,bit,l;\nint mp[10][10];\nint memo[1<<23][23];\nmap<pair<int,int>,int> num;\nint dfs(int I, int J){\n    if(l != -1 && memo[bit][l] != -1) return memo[bit][l];\n\n    if(bit == ie){\n        if(I != x && J != y) return 0;\n        int ans = 0;\n        for(int i=I-1; i>=0; i--){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int i=I+1; i<n; i++){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int j=J-1; j>=0; j--){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        for(int j=J+1; j<m; j++){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        return memo[bit][l] = ans;\n    }\n\n    int ans = 0;\n    int L = l;\n    for(int i=I-1; i>=0; i--){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int i=I+1; i<n; i++){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int j=J-1; j>=0; j--){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n    for(int j=J+1; j<m; j++){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n\n    return memo[bit][L] = ans;\n}\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    while(true){\n        cin >> m >> n;\n        if(n == 0 && m == 0) break;\n\n        ie = 0;\n        bit = 0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                cin >> mp[i][j];\n                if(mp[i][j] == 2){\n                    x = i;\n                    y = j;\n                }\n                if(mp[i][j] == 1){\n                    num[MP(i,j)] = ie;\n                    ie++;\n                }\n            }\n        }\n        ie = (1<<ie) - 1;\n        l = -1;\n        for(int i=0; i<=ie; i++){\n            for(int j=0; j<23; j++){\n                memo[i][j] = -1;\n            }\n        }\n\n        cout << dfs(x,y) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\nstruct P{\n\tint v,x,y;\n\tP(int v,int x,int y):v(v),x(x),y(y){}\n\tbool operator<(const P&o)const{\n\t\tif(v!=o.v)return v<o.v;\n\t\tif(x!=o.x)return x<o.x;\n\t\treturn y<o.y;\n\t}\n};\nint main(){\n\tint w,h,m[10][10],x,y,cx,cy,n,t;\n\tint dx[]={1,0,-1,0},dy[]={0,1,0,-1},d;\n\tfor(;cin>>w>>h,w;){\n\t\tn=0;\n\t\tfor(y=0;y<h;y++){\n\t\t\tfor(x=0;x<w;x++){\n\t\t\t\tcin>>t;\n\t\t\t\tif(t==1)\n\t\t\t\t\tm[x][y]=n++;\n\t\t\t\telse{\n\t\t\t\t\tm[x][y]=-1;\n\t\t\t\t\tif(t==2)\n\t\t\t\t\t\tcx=x,cy=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttypedef map<P,int>M;\n\t\ttypedef M::iterator I;\n\t\tM q[24];\n\t\tq[n][P(-1,cx,cy)]=1;\n\t\tfor(;n;n--){\n\t\t\tfor(I it=q[n].begin();it!=q[n].end();++it){\n\t\t\t\tconst P&p=it->first;\n\t\t\t\tfor(d=0;d<4;d++){\n\t\t\t\t\tint tv=p.v,tx=p.x,ty=p.y;\n\t\t\t\t\tfor(;;){\n\t\t\t\t\t\ttx+=dx[d],ty+=dy[d];\n\t\t\t\t\t\tif(tx<0||ty<0||tx>=w||ty>=h)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif(m[tx][ty]>=0&&tv&1<<m[tx][ty]){\n\t\t\t\t\t\t\ttv^=1<<m[tx][ty];\n\t\t\t\t\t\t\tq[n-1][P(tv,tx,ty)]+=it->second;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq[n].clear();\n\t\t}\n\t\tint ans=0;\n\t\tfor(I it=q[0].begin();it!=q[0].end();++it){\n\t\t\tconst P&p=it->first;\n\t\t\tif(p.x==cx||p.y==cy)\n\t\t\t\tans+=it->second;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint bfs() {\n\n\tint ans = 0;\n\tqueue<P> que;\n\tque.push(P(hs, (1 << hs) - 1));\n\n\twhile (!que.empty()) {\n\t\tint idx, bits;\n\t\ttie(idx, bits) = que.front(); que.pop();\n\t\tint nr, nc;\n\t\ttie(nr, nc) = vp[idx];\n\t\tif (bits == 0) {\n\t\t\tif (nr == sr || nc == sc) ans++;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\t\tint x = tb[i][nc];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\t\tint x = tb[i][nc];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\t\tint x = tb[nr][j];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\t\tint x = tb[nr][j];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\tvp.push_back(P(sr, sc));\n\n\t\tcout << bfs() << endl;\n\t}\n\tsystem(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cstring>\n\n#define EMPTY 0\n#define HOUSE 1\n#define CHRCH 2\n#define SMOKE 3\n\nusing namespace std;\n\ntypedef struct\n{\n\tint M[10][10];\n\tint x;\n\tint y;\n\tint rem;\n} stat;\n\nstack<stat> S;\nstat t,tops;\n\nint H,W,MAP[10][10];\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0)\n\t\t\texit(0);\n\t\tfor(int y = 0;y < H;y++)\n\t\t{\n\t\t\tfor(int x = 0;x < W;x++)\n\t\t\t{\n\t\t\t\tcin >> t.M[x][y];\n\t\t\t\tif(t.M[x][y] == HOUSE)\n\t\t\t\t{\n\t\t\t\t\tt.rem++;\n\t\t\t\t}\n\t\t\t\tif(t.M[x][y] == CHRCH)\n\t\t\t\t{\n\t\t\t\t\tt.x = x;\n\t\t\t\t\tt.y = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result = 0;\n\t\tS.push(t);\n\t\twhile(!S.empty())\n\t\t{\n\t\t\tmemcpy(&tops,&S.top(),sizeof(stat));\n\t\t\tS.pop();\n\t\t\tif(tops.rem == 0)\n\t\t\t{\n\t\t\t\tfor(int x = tops.x+1;x < W;x++)\n\t\t\t\t{\n\t\t\t\t\tif(tops.M[x][tops.y] == SMOKE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tops.M[x][tops.y] == CHRCH)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int x = tops.x-1;x >= 0;x--)\n\t\t\t\t{\n\t\t\t\t\tif(tops.M[x][tops.y] == SMOKE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tops.M[x][tops.y] == CHRCH)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int y = tops.y+1;y < H;y++)\n\t\t\t\t{\n\t\t\t\t\tif(tops.M[tops.x][y] == SMOKE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tops.M[tops.x][y] == CHRCH)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int y = tops.y-1;y >= 0;y--)\n\t\t\t\t{\n\t\t\t\t\tif(tops.M[tops.x][y] == SMOKE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tops.M[tops.x][y] == CHRCH)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int x = tops.x+1;x < W;x++)\n\t\t\t\t{\n\t\t\t\t\tif(tops.M[x][tops.y] == SMOKE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tops.M[x][tops.y] == HOUSE)\n\t\t\t\t\t{\n\t\t\t\t\t\tt.x = x;\n\t\t\t\t\t\tt.y = tops.y;\n\t\t\t\t\t\tt.rem = tops.rem - 1;\n\t\t\t\t\t\tfor(int i = 0;i < W;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int ii = 0;ii < H;ii++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt.M[i][ii] = tops.M[i][ii];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.M[x][tops.y] = SMOKE;\n\t\t\t\t\t\tS.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int x = tops.x-1;x >= 0;x--)\n\t\t\t\t{\n\t\t\t\t\tif(tops.M[x][tops.y] == SMOKE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tops.M[x][tops.y] == HOUSE)\n\t\t\t\t\t{\n\t\t\t\t\t\tt.x = x;\n\t\t\t\t\t\tt.y = tops.y;\n\t\t\t\t\t\tt.rem = tops.rem - 1;\n\t\t\t\t\t\tfor(int i = 0;i < W;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int ii = 0;ii < H;ii++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt.M[i][ii] = tops.M[i][ii];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.M[x][tops.y] = SMOKE;\n\t\t\t\t\t\tS.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int y = tops.y+1;y < H;y++)\n\t\t\t\t{\n\t\t\t\t\tif(tops.M[tops.x][y] == SMOKE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tops.M[tops.x][y] == HOUSE)\n\t\t\t\t\t{\n\t\t\t\t\t\tt.x = tops.x;\n\t\t\t\t\t\tt.y = y;\n\t\t\t\t\t\tt.rem = tops.rem - 1;\n\t\t\t\t\t\tfor(int i = 0;i < W;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int ii = 0;ii < H;ii++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt.M[i][ii] = tops.M[i][ii];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.M[tops.x][y] = SMOKE;\n\t\t\t\t\t\tS.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int y = tops.y-1;y >= 0;y--)\n\t\t\t\t{\n\t\t\t\t\tif(tops.M[tops.x][y] == SMOKE)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tops.M[tops.x][y] == HOUSE)\n\t\t\t\t\t{\n\t\t\t\t\t\tt.x = tops.x;\n\t\t\t\t\t\tt.y = y;\n\t\t\t\t\t\tt.rem = tops.rem - 1;\n\t\t\t\t\t\tfor(int i = 0;i < W;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int ii = 0;ii < H;ii++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tt.M[i][ii] = tops.M[i][ii];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.M[tops.x][y] = SMOKE;\n\t\t\t\t\t\tS.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>18||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=18&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=18?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint bfs(P sg,int home);\nint w,h;\nint mas[10][10];\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nP sg;\n\nint main(){\n\tcin >> w >> h;\n\tint home = 0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> mas[i][j];\n\t\t\tif(mas[i][j] == 1) home++;\n\t\t\telse if (mas[i][j] == 2) sg = P(j,i);\n\t\t}\n\t}\n\tcout << bfs(sg,home) << endl;\n}\n\nint bfs(P now,int home){\n\tif(home == 0){\n\t\tif(now.first == sg.first || now.second == sg.second) return 1;\n\t\telse return 0;\n\t}\n\tint ret = 0;\n\tfor(int i=0;i<4;i++){\n\t\tP p = now;\n\t\twhile(1){\n\t\t\tp.first += dx[i]; p.second += dy[i];\n\t\t\tif(p.first >= 0 && p.second >= 0 && p.first < w && p.second < h){\n\t\t\t\tif(mas[p.second][p.first] == 1) break;\n\t\t\t}else{\n\t\t\t\tp = P(-1,-1); break;\n\t\t\t}\n\t\t}\n\t\tif(p.first == -1) continue;\n\t\tmas[p.second][p.first] = -1;\n\t\tret += bfs(p,home-1);\n\t\tmas[p.second][p.first] = 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[24], y[24], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, o = 0;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[++p] = i, y[p] = j, dat[i][j] = p;\n\t\t\tif (f[i][j] == 2)x[0] = i, y[0] = j, dat[i][j] = 0;\n\t\t}p++;\n\t\tmap<P, int>dp;\n\t\tdp[{0, 0}] = 1;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif ((f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) || (f[nx][ny] == 2 && i == (1 << p) - 2)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++o >= 1000000)dp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", dp[{(1 << p) - 1, 0}]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  //int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;}\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  bool visited[MAX][MAX][HSMAX];\n  visited[bi][bj][0]=true;\n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;\n    \n    qs.pop();\n\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t}\n      }\n      break;\n    }\n    /*\n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !visited[next.fr][next.sc][st_now.cnt+1] ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    //st_next.vis|=(1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    visited[st_next.ni][st_next.nj][st_next.cnt] =true;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,-1,0,0},dy[]={0,0,1,-1};\nint dfs(int y,int x,vector<vector<int> > grd,int nokori){\n\tint cnt=0;\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=1;grd[y+j*dy[i]][x+j*dx[i]]!=-1;j++){\n\t\t\tif(grd[y+j*dy[i]][x+j*dx[i]]==1){\n\t\t\t\tgrd[y+j*dy[i]][x+j*dx[i]]=-1;\n\t\t\t\tcnt+=dfs(y+j*dy[i],x+j*dx[i],grd,nokori-1);\n\t\t\t\tgrd[y+j*dy[i]][x+j*dx[i]]=1;\n\t\t\t}\n\t\t\telse if(nokori==0&&grd[y+j*dy[i]][x+j*dx[i]]==2)\treturn 1;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\twhile(true){\n\t\tint m,n;\tcin>>m>>n;\n\t\tif(m==0)\tbreak;\n\t\tvector<vector<int> > grd(n+2,vector<int>(m+2,-1));\n\t\tint sx,sy,nokori=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=m;j++){\n\t\t\t\tcin>>grd[i][j];\n\t\t\t\tif(grd[i][j]==2)\tsx=j,sy=i;\n\t\t\t\telse if(grd[i][j]==1)\tnokori++;\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(sy,sx,grd,nokori)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\ninline bool in(int x, int y, int w, int h)\n{\n\treturn x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint main()\n{\n\twhile(true) {\n\t\t\n\t\tint w, h, n;\n\t\tint field[16][16];\n\t\tvector<pair<int, int> > house;\n\t\tpair<int, int> church;\n\t\t\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif(t == 0) {\n\t\t\t\t\tt = -1;\n\t\t\t\t} else if(t == 1) {\n\t\t\t\t\tt = house.size();\n\t\t\t\t\thouse.push_back(make_pair(x, y));\n\t\t\t\t} else if(t == 2) {\n\t\t\t\t\tt = -2;\n\t\t\t\t\tchurch = make_pair(x, y);\n\t\t\t\t}\n\t\t\t\tfield[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tn = house.size();\n\t\t\n\t\tint reach[23][23];\n\t\tint dx[] = {-1, 0, 0, 1}, dy[] = {0, -1, 1, 0};\n\t\tstatic int dp[1 << 23][23];\n\t\t\n\t\tmemset(dp[0], 0, (1 << 23) * n * sizeof(int));\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tdp[1 << tgt][tgt] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int a = 0; a < n; ++a) {\n\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\n\t\t\t\tif(a == b)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\treach[a][b] = (1 << a) | (1 << b);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\t\n\t\t\t\t\tint cx = house[a].first, cy = house[a].second;\n\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tint t = field[cx][cy];\n\t\t\t\t\t\tif(t == b) {\n\t\t\t\t\t\t\treach[a][b] = bit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(t >= 0) {\n\t\t\t\t\t\t\tbit |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 1; bit < (1 << n); ++bit) {\n\t\t\t\n\t\t\tfor(int a = 0; a < n; ++a) {\n\t\t\t\t\n\t\t\t\tif((bit & (1 << a)) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint prev = bit ^ (1 << a);\n\t\t\t\t\n\t\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\t\n\t\t\t\t\tint filter = ((prev & (1 << b)) == 0) * ((prev & reach[a][b]) != 0);\n\t\t\t\t\tdp[bit][a] += filter * dp[prev][b];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tans += dp[(1 << n) - 1][tgt];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint m;\nint n;\nint map[10][10] = {0};\nint cnt = 0;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n\nint saiki( int xinput, int yinput, int nokori ) {\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tint x = xinput;\n\t\tint y = yinput;\n\t\twhile(true) {\n\t\t\tx += dx[i];\n\t\t\ty += dy[i];\n\t\t\tif ( x < 0 || x >= m || y < 0 || y >= n ) break;\n\t\t\tif ( map[x][y] == 1 ) {\n\t\t\t\tmap[x][y] = 3;\n\t\t\t\tsaiki( x, y, nokori-1 );\n\t\t\t\tmap[x][y] = 1;\n\t\t\t}else if ( map[x][y] == 2 ) {\n\t\t\t\tif ( nokori == 0 ) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if ( map[x][y] == 3 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> m;\n\t\tcin >> n;\n\t\tif ( m == 0 ) break;\n\t\tint x;\n\t\tint y;\n\t\tint nokori = 0;\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tfor ( int j = 0; j < m; j++ ) {\n\t\t\t\tcin >> map[j][i];\n\t\t\t\tif ( map[j][i] == 1 ) {\n\t\t\t\t\tnokori++;\n\t\t\t\t}else if ( map[j][i] == 2 ) {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt = 0;\n\t\tsaiki( x, y, nokori );\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\n/*\nconst int dx[] = {0,1,0,-1}; //u,r,d,l\nconst int dy[] = {-1,0,1,0};\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool ischeck(int s){\n  return (((last&s)) == last) ;\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( ischeck(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <stack>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint main() {\n  while (true) {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    vector<vector<int>> p(n, vector<int>(m));\n    for (int i : range(n)) for (int j : range(m)) cin >> p[i][j];\n    vector<pair<int, int>> house;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 1) house.emplace_back(i, j);\n    vector<vector<int>> s(n, vector<int>(m, -1));\n    for (int i : range(house.size())) s[house[i].first][house[i].second] = i;\n    stack<tuple<int, int, int>> stc;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 2) stc.push(make_tuple(i, j, 0));\n    pair<int, int> next[n][m][4];\n    for (int i : range(n)) for (int j : range(m)) for (int k : range(4)) {\n      int y = i + dy[k];\n      int x = j + dx[k];\n      while (true) {\n        if (y < 0 || n <= y || x < 0 || m <= x) {\n          next[i][j][k] = make_pair(-1, -1);\n          break;\n        }\n        if (p[y][x] != 0) {\n          next[i][j][k] = make_pair(y, x);\n          break;\n        }\n        y += dy[k];\n        x += dx[k];\n      }\n    }\n    int res = 0;\n    while (!stc.empty()) {\n      auto now = stc.top(); stc.pop();\n      int y = get<0>(now);\n      int x = get<1>(now);\n      int bit = get<2>(now);\n      for (int i : range(4)) {\n        int yy = next[y][x][i].first;\n        int xx = next[y][x][i].second;\n        while (true) {\n          if (yy < 0) break;\n          if (p[yy][xx] == 1) {\n            if (bit & 1 << s[yy][xx]) break;\n            stc.push(make_tuple(yy, xx, bit | 1 << s[yy][xx]));\n          }\n          if (p[yy][xx] == 2) {\n            if (bit == (1 << house.size()) - 1) ++res; \n            break;\n          }\n          auto np = next[yy][xx][i];\n          yy = np.first;\n          xx = np.second;\n        }\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint h,w;\nint sx,sy,tn;\nint map[13][13];\n//int mn[13][13];\n//int tx[25],ty[25];\n//int e[24][4],cf[24][4];\ninline int dfs(char x,char y,char n){\n\tint i,k,nx,ny;\n\tint res=0;\n\t//printf(\"%d %d\\n\",x,y);\n\tfor(k=0;k<4;k++){\n\t\tnx=x;\n\t\tny=y;\n\t\twhile(1){\n\t\t\tnx+=dx[k];\n\t\t\tny+=dy[k];\n\t\t\tif(map[ny][nx]==0)continue;\n\t\t\telse if(map[ny][nx]==1){\n\t\t\t\tmap[ny][nx]=0;\n\t\t\t\t//res+=dfs(nx,ny,n|(1<<mn[ny][nx]));\n\t\t\t\tres+=dfs(nx,ny,n-1);\n\t\t\t\tmap[ny][nx]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(map[ny][nx]==3)break;\n\t\t\t//else if(map[ny][nx]==2 && n==(1<<tn)-1){\n\t\t\telse if(map[ny][nx]==2 && n==0){\n\t\t\t\tres++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint i,j,k;\n\tint nx,ny;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0 && h==0)break;\n\t\ttn=0;\n\t\t//memset(mn,-1,sizeof(mn));\n\t\tfor(i=0;i<=w+1;i++)map[0][i]=map[h+1][i]=3;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tif(map[i][j]==2){sx=j;sy=i;}\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t//mn[i][j]=tn;\n\t\t\t\t\t//tx[tn]=j;ty[tn]=i;\n\t\t\t\t\ttn++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap[i][0]=map[i][w+1]=3;\n\t\t}\n\t\t/*\n\t\tmemset(e,-1,sizeof(e));\n\t\tmemset(cf,0,sizeof(cf));\n\t\tfor(i=0;i<tn;i++){\n\t\t\tfor(k=0;k<4;k++){\n\t\t\t\tnx=tx[i];ny=ty[i];\n\t\t\t\twhile(1){\n\t\t\t\t\tnx+=dx[k];ny+=dy[k];\n\t\t\t\t\tif(map[ny][nx]==1){\n\t\t\t\t\t\te[i][k]=mn[ny][nx];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[ny][nx]==3)break;\n\t\t\t\t}\n\t\t\t\tnx=tx[i];ny=ty[i];\n\t\t\t\twhile(1){\n\t\t\t\t\tnx+=dx[k];ny+=dy[k];\n\t\t\t\t\tif(map[ny][nx]==2){\n\t\t\t\t\t\tcf[i][k]=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[ny][nx]==3)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=0;i<tn;i++){for(j=0;j<4;j++)printf(\"%2d \",e[i][j]);printf(\"\\n\");}\n\t\tfor(i=0;i<tn;i++){for(j=0;j<4;j++)printf(\"%d\",cf[i][j]);printf(\"\\n\");}\n\t\tfor(i=0;i<=h+1;i++){for(j=0;j<=w+1;j++)printf(\"%d\",map[i][j]);printf(\"\\n\");}\n\t\tprintf(\"tn:%d\\n\",tn);\n\t\tfor(i=0;i<=h+1;i++){\n\t\t\tfor(j=0;j<=w+1;j++)if(mn[i][j]>=0){printf(\"%d\",mn[i][j]);}else{printf(\".\");}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tprintf(\"%d\\n\",dfs(sx,sy,tn));\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint h,w;\nint a[12][12];\n\nint pre_h[12][12];\nint nex_h[12][12];\nint pre_w[12][12];\nint nex_w[12][12];\n\nint dfs(int x,int y,int d,int k,int t){\n\tif(k == 0){\n\t\tif(a[x][y] == 2){\n\t//printf(\"dfs(%d,%d,%d,%d)=\",x,y,d,k);\n\t\t\t//puts(\"1\");\n\t\t\treturn 1;\n\t\t}\n\t//printf(\"dfs(%d,%d,%d,%d)=\",x,y,d,k);\n\t\t//puts(\"0\");\n\t\treturn 0;\n\t}\n\tif(d == -1){\n\t\tif(a[x][y] == 2 && t == 0)return 0;\n\t\tint ret = 0;\n\t\t//int memo[4] = { nex_h[x][y] , pre_h[x][y] , nex_w[x][y] , pre_w[x][y] };\n\t\tif(a[x][y] == 1 && nex_h[x][y] != 0)pre_h[x+nex_h[x][y]][y] = 0;\n\t\tif(a[x][y] == 1 && pre_h[x][y] != 0)nex_h[x+pre_h[x][y]][y] = 0;\n\t\tif(a[x][y] == 1 && nex_w[x][y] != 0)pre_w[x][y+nex_w[x][y]] = 0;\n\t\tif(a[x][y] == 1 && pre_w[x][y] != 0)nex_w[x][y+pre_w[x][y]] = 0;\n\t\tif(nex_h[x][y] != 0)ret += dfs(x+nex_h[x][y],y,0,k-1,0);\n\t\tif(pre_h[x][y] != 0)ret += dfs(x+pre_h[x][y],y,1,k-1,0);\n\t\tif(nex_w[x][y] != 0)ret += dfs(x,y+nex_w[x][y],2,k-1,0);\n\t\tif(pre_w[x][y] != 0)ret += dfs(x,y+pre_w[x][y],3,k-1,0);\n\t\tif(a[x][y] == 1 && nex_h[x][y] != 0)pre_h[x+nex_h[x][y]][y] = -nex_h[x][y];\n\t\tif(a[x][y] == 1 && pre_h[x][y] != 0)nex_h[x+pre_h[x][y]][y] = -pre_h[x][y];\n\t\tif(a[x][y] == 1 && nex_w[x][y] != 0)pre_w[x][y+nex_w[x][y]] = -nex_w[x][y];\n\t\tif(a[x][y] == 1 && pre_w[x][y] != 0)nex_w[x][y+pre_w[x][y]] = -pre_w[x][y];\n\t\t//printf(\"%d=%d %d=%d %d=%d %d=%d\\n\", memo[0] , nex_h[x][y] , memo[1] , pre_h[x][y] , memo[2] , nex_w[x][y] , memo[3] , pre_w[x][y]);\n\t\t//printf(\"dfs(%d,%d,%d,%d)=\",x,y,d,k);\n\t\t//printf(\"%d\\n\",ret);\n\t\treturn ret;\n\t}\n\tint ret = 0;\n\tret += dfs(x,y,-1,k,0);\n\tif(d == 0){\n\t\tif(nex_h[x][y] != 0)ret += dfs(x+nex_h[x][y],y,0,k,0);\n\t}\n\telse if(d == 1){\n\t\tif(pre_h[x][y] != 0)ret += dfs(x+pre_h[x][y],y,1,k,0);\n\t}\n\telse if(d == 2){\n\t\tif(nex_w[x][y] != 0)ret += dfs(x,y+nex_w[x][y],2,k,0);\n\t}\n\telse if(d == 3){\n\t\tif(pre_w[x][y] != 0)ret += dfs(x,y+pre_w[x][y],3,k,0);\n\t}\n\t//printf(\"dfs(%d,%d,%d,%d)=\",x,y,d,k);\n\t//printf(\"%d\\n\",ret);\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\trep(i,12){\n\t\t\trep(j,12){\n\t\t\t\ta[i][j] = 0;\n\t\t\t\tnex_h[i][j] = 0;\n\t\t\t\tpre_h[i][j] = 0;\n\t\t\t\tnex_w[i][j] = 0;\n\t\t\t\tpre_w[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d%d\",&w,&h); if(w == 0 && h == 0)break;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(i,12){\n\t\t\tint memo = -1;\n\t\t\trep(j,12){\n\t\t\t\tif(a[i][j] != 0){\n\t\t\t\t\tif(memo != -1){\n\t\t\t\t\t\tnex_w[i][memo] = j-memo;\n\t\t\t\t\t\tpre_w[i][j] = memo-j;\n\t\t\t\t\t}\n\t\t\t\t\tmemo = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(j,12){\n\t\t\tint memo = -1;\n\t\t\trep(i,12){\n\t\t\t\tif(a[i][j] != 0){\n\t\t\t\t\tif(memo != -1){\n\t\t\t\t\t\tnex_h[memo][j] = i-memo;\n\t\t\t\t\t\tpre_h[i][j] = memo-i;\n\t\t\t\t\t}\n\t\t\t\t\tmemo = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*rep(i,12){\n\t\t\trep(j,12){\n\t\t\t\tprintf(\"%d \",nex_h[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\trep(i,12){\n\t\t\trep(j,12){\n\t\t\t\tprintf(\"%d \",pre_h[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\trep(i,12){\n\t\t\trep(j,12){\n\t\t\t\tprintf(\"%d \",nex_w[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\trep(i,12){\n\t\t\trep(j,12){\n\t\t\t\tprintf(\"%d \",pre_w[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t\t\n\t\tint cnt = 0;\n\t\tint x,y;\n\t\t\n\t\trep(i,12){\n\t\t\trep(j,12){\n\t\t\t\tif(a[i][j] == 1)cnt ++;\n\t\t\t\tif(a[i][j] == 2){\n\t\t\t\t\tx = i; y = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",dfs(x,y,-1,cnt+1,1));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\n\n#if DEB\nstack<int> st;\n#endif\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool ischeck(int s){\n  return (((last&s)) == last) ;\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ // ÆÍ³ïÉßêé©Ç¤©\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = x + dx[k]*i;\n\tint ty = y + dy[k]*i;\n\t//if( inside(tx,ty) || field[ty][tx]==1 )break;\n\tif( inside(tx,ty) )break;\n\n\tif( field[ty][tx]==2 ){\n#if DEB\n\t  printf(\"goal , (%d,%d)  s:%d\\n\",x,y,s);\n\t  stack<int> tmp = st;\n\t  while( !tmp.empty() ){\n\t    printf(\"%d,\",tmp.top());\n\t    tmp.pop();\n\t  }\n\t  puts(\"\\n\");\n#endif\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½ê\n    return msi[state(x,y,s)];\n  }\n  if( ischeck(s) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\t//if( s&(1<<num[ty][tx]) ) break;\t\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif \n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n#if DEB\n\tst.pop();\n#endif\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n#if DEB\n    printf(\"home:%d  sx,sy = %d,%d\\n\",home,sx,sy);\n    printf(\"last:%d\\n\",last);\n    rep(i,h){\n      rep(j,w){\n\tprintf(\"%2d \",num[i][j]);\n      }\n      puts(\"\");\n    }\n#endif   \n    dfs(sx,sy,0);\n    printf(\"%d\\n\",msi[state(sx,sy,0)]);\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint n,m,x,y,ie,bit,l;\nint mp[10][10];\nint memo[1<<23][23];\nmap<pair<int,int>,int> num;\nint dfs(int I, int J){\n    if(l != -1 && memo[bit][l] != -1) return memo[bit][l];\n\n    if(bit == ie){\n        if(I != x && J != y) return 0;\n        int ans = 0;\n        for(int i=I-1; i>=0; i--){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int i=I+1; i<n; i++){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int j=J-1; j>=0; j--){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        for(int j=J+1; j<m; j++){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        return memo[bit][l] = ans;\n    }\n\n    int ans = 0;\n    int L = l;\n    for(int i=I-1; i>=0; i--){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int i=I+1; i<n; i++){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int j=J-1; j>=0; j--){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n    for(int j=J+1; j<m; j++){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n\n    return memo[bit][L] = ans;\n}\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    while(true){\n        cin >> m >> n;\n        if(n == 0 && m == 0) break;\n\n        num.clear();\n        ie = 0;\n        bit = 0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                cin >> mp[i][j];\n                if(mp[i][j] == 2){\n                    x = i;\n                    y = j;\n                }\n                if(mp[i][j] == 1){\n                    num[MP(i,j)] = ie;\n                    ie++;\n                }\n            }\n        }\n        ie = (1<<ie) - 1;\n        l = -1;\n        for(int i=0; i<=ie; i++){\n            for(int j=0; j<23; j++){\n                memo[i][j] = -1;\n            }\n        }\n\n        cout << dfs(x,y) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <iostream>\n#define fi first\n#define sec second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nint S;\nint ans;\nint cell[10][10];\nint dy[4] = {1,0,-1,0}, dx[4] = {0,1,0,-1};\nint used;\nmap<P,int> dp;\nvector<int> e[30][4]; //0 down 1 right 2 up 3 left\nvector<P> num;\n\nint A(int s,int cnt){\n\tif(dp[P(used,s)] > 0){\n\t\treturn dp[P(used,s)];\n\t}\n\tint ret = 0;\n\tcnt--;\n\tif(cnt == 0){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif(e[s][i].size() != 0 && e[s][i][0] == S){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\tdp[P(used,s)] = ret;\n\t\treturn ret;\n\t}\n\tif(s != S) used += 1<<s;\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < e[s][i].size(); j++){\n\t\t\tif(used>>e[s][i][j] & 1) break;\n\t\t\tif(e[s][i][j] == S) continue;\n\t\t\tret += A(e[s][i][j],cnt);\n\t\t}\n\t}\n\tif(s != S) used -= 1<<s;\n\tdp[P(used,s)] = ret;\n\treturn ret;\n}\n\nvoid solve(){\n\tans = 0;\n\tnum.clear();\n\tused = 0;\n\tdp.clear();\n\tfor(int i = 0; i < 30; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\te[i][j].clear();\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tscanf(\"%d\", &cell[i][j]);\n\t\t\tif(cell[i][j] != 0){\n\t\t\t\tif(cell[i][j] == 2) S = num.size();\n\t\t\t\tnum.push_back(P(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(cell[i][j] == 0) continue;\n\t\t\tint tmp;\n\t\t\tfor(int k = 0; k < num.size(); k++){\n\t\t\t\tif(num[k].fi == i && num[k].sec == j){\n\t\t\t\t\ttmp = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint y = i, x = j;\n\t\t\t\twhile(true){\n\t\t\t\t\ty += dy[k]; x += dx[k];\n\t\t\t\t\tif(0>y||y>=n||0>x||x>=m) break;\n\t\t\t\t\tif(cell[y][x] != 0){\n\t\t\t\t\t\tfor(int l = 0; l < num.size(); l++){\n\t\t\t\t\t\t\tif(num[l].fi == y && num[l].sec == x){\n\t\t\t\t\t\t\t\te[tmp][k].push_back(l);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans = A(S,num.size());\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &m, &n),n||m) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint x,y;\nint sx,sy;\nint N;\nint hx[24],hy[24];\nint fie[12][12];\nint dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit,bool done[12][12],int home){\n\tif(memo[pos].find(bit)!=memo[pos].end())return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\t\twhile(fie[cx][cy]!=-1){\n\t\t\t\tif(fie[cx][cy]==100)return 1;\n\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\twhile(fie[cx][cy]==-2 || fie[cx][cy]==100 || done[cx][cy]==true){\n\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t}\n\t\tif(fie[cx][cy]!=-1){\n\t\t\tdone[cx][cy]=true;\n\t\t\tans+=dfs(fie[cx][cy] , bit | (1<<fie[cx][cy]), done,home+1);\n\t\t\tdone[cx][cy]=false;\n\t\t}\n\t}\n\tif(home<15)memo[pos][bit]=ans;\n\treturn ans;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tN=0;\n\t\tfor(int i=0;i<24;i++){\n\t\t\tmemo[i].clear();\n\t\t}\n\t\tfor(int i=0;i<12;i++){\n\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\tfie[j][i]=-1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfie[j][i]=-2;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tfie[j][i]=100;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==1){\n\t\t\t\t\tfie[j][i]=N;\n\t\t\t\t\thx[N]=j;\n\t\t\t\t\thy[N]=i;\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thx[N]=sx,hy[N]=sy;\n\t\tbool done[12][12];\n\t\tmemset(done,false,sizeof(done));\n\t\tcout << dfs(N,0,done,0) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nint n, m, field[11][11], si, sj, num;\n \nint dfs(int x, int y){\n  int ans = 0;\n  if(num == 0){\n    if(x == si || y == sj)return 1;\n    else return 0;\n  }\n  field[x][y] = 0;\n  for(int i = x + 1;i < m;i++){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  }\n  for(int i = x - 1;i >= 0;i--){\n    if(field[i][y] == 1){\n      num--;\n      ans += dfs(i, y);\n      num++;\n      break;\n    }\n  }\n  for(int i = y + 1;i < n;i++){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  }\n  for(int i = y - 1;i >= 0;i--){\n    if(field[x][i] == 1){\n      num--;\n      ans += dfs(x, i);\n      num++;\n      break;\n    }\n  } \n  field[x][y] = 1;\n  return ans;\n}\n \nint main(){\n  while(1){\n    scanf(\"%d%d\", &n, &m);\n    if(n == 0 && m == 0)return 0;\n    memset(field, 0, sizeof(field));\n    num = 0;\n    for(int i = 0;i < m;i++){\n      for(int j = 0;j < n;j++){\n    scanf(\"%d\", &field[i][j]);\n    if(field[i][j] == 2){\n      si = i;\n      sj = j;\n    }\n    else num += field[i][j];\n      }\n    }\n    printf(\"%d\\n\", dfs(si, sj));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[24], y[24], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, o = 0;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[++p] = i, y[p] = j, dat[i][j] = p;\n\t\t\tif (f[i][j] == 2)x[0] = i, y[0] = j, dat[i][j] = 0;\n\t\t}p++;\n\t\tmap<P, int>dp;\n\t\tdp[{0, 0}] = 1;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif ((f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) || (f[nx][ny] == 2 && i == (1 << p) - 2)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++o >= 500000)dp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", dp[{(1 << p) - 1, 0}]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include <cstring>\n#include<map>\n#define MAX 11\n#define MAX_BITS 23\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nmap<int,int> dp;\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n//\tcout << \"hi\" << bit << endl;\n\tif(housInd[ny][nx] != -1 && dp.find(bit | housInd[ny][nx] << MAX_BITS) != dp.end()){\n\t\treturn dp[bit | housInd[ny][nx] << MAX_BITS];\n\t}\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\t\n\tif (isLast && dp.find(bit | housInd[ny][nx] << MAX_BITS) != dp.end()) return dp[bit | housInd[ny][nx] << MAX_BITS];\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[bit | housInd[ny][nx] << MAX_BITS] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!isLast) {\n\t\t\t\t\tif ((bit & 1 << ind) == 0) {\n\t\t\t\t\t\tret += func(y, x, bit | (1 << ind));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn housInd[ny][nx] != -1 ? (dp[bit | housInd[ny][nx] << MAX_BITS] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tdp.clear();\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){\n    cnt=0;\n    vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    if(ni==t.ni){\n      if(nj==t.nj){\n\treturn vis<t.vis;\n      }else return nj < t.nj;\n    }else return ni < t.ni;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n    \n    //cout << \"CNT: \" << (int)st_now.cnt << endl;\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n    \n    if( st_now.cnt >= 11 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    //cout << i << ' ' << j << endl;\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.cnt++;\n\t    st_next.vis |= ( 1<<houseId[next.fr][next.sc] );\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second \n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  int ni,nj;\n  int cnt;\n  bool vis[HSMAX];\n  state(int si, int sj):ni(si),nj(sj){cnt=0;\n    for(int i=0;i<HSMAX;++i)vis[i]=false;\n    vis[ houseId[si][sj] ]=true;\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], bool vis[][MAX], int bi, int bj, int nhouse, int cnt, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[bi][bj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[bi][bj].exist[k] ){\n\tfor(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\t  pi next = M[bi][bj].link[k][v];\n\t  if( !vis[next.fr][next.sc] ){\n\t    vis[next.fr][next.sc]=true;\n\t    dfs( M, vis, next.fr, next.sc, nhouse, cnt+1, ans );\n\t    vis[next.fr][next.sc]=false;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n\n  while(!qs.empty()){\n    bool bCont=false;\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;\n    qs.pop();\n\n    if( st_now.cnt == nhouse ){\n      for(int k = 0; k < MAXDIR; ++k){\n\tif( M[ni][nj].cexist[k] ){\n\t  ++ans;\n\t  bCont=true;\n\t}\n      }\n    }\n    if(bCont)continue;\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !st_now.vis[ houseId[next.fr][next.sc] ] ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis[ houseId[next.fr][next.sc] ] = true;\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }else{\n\t    //break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = UP; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint x,y;\nint sx,sy;\nint N;\nint hx[24],hy[24];\nint fie[12][12];\nint dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit,bool done[12][12],int home){\n\tif(memo[pos].find(bit)!=memo[pos].end())return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\t\twhile(fie[cx][cy]!=-1){\n\t\t\t\tif(fie[cx][cy]==100)return 1;\n\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\twhile(fie[cx][cy]==-2 || fie[cx][cy]==100 || done[cx][cy]==true){\n\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t}\n\t\tif(fie[cx][cy]!=-1){\n\t\t\tdone[cx][cy]=true;\n\t\t\tans+=dfs(fie[cx][cy] , bit | (1<<fie[cx][cy]), done,home+1);\n\t\t\tdone[cx][cy]=false;\n\t\t}\n\t}\n\tif(home<20)memo[pos][bit]=ans;\n\treturn ans;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tN=0;\n\t\tfor(int i=0;i<24;i++){\n\t\t\tmemo[i].clear();\n\t\t}\n\t\tfor(int i=0;i<12;i++){\n\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\tfie[j][i]=-1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfie[j][i]=-2;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tfie[j][i]=100;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==1){\n\t\t\t\t\tfie[j][i]=N;\n\t\t\t\t\thx[N]=j;\n\t\t\t\t\thy[N]=i;\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thx[N]=sx,hy[N]=sy;\n\t\tbool done[12][12];\n\t\tmemset(done,false,sizeof(done));\n\t\tcout << dfs(N,0,done,0) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\n//bit????????????\nint dp[23][1<<18];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<(1<<18))if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\tif(bit<(1<<18))return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstd::vector<int> X[10], Y[10];\nint W, H;\nint hx[24], hy[24];\nint cx, cy, hn;\nint dp[23][1<<23];\n\nint bitCount(int n){\n    n = (n & 0x55555555) + (n >> 1 & 0x55555555);\n    n = (n & 0x33333333) + (n >> 2 & 0x33333333);\n    n = (n & 0x0f0f0f0f) + (n >> 4 & 0x0f0f0f0f);\n    n = (n & 0x00ff00ff) + (n >> 8 & 0x00ff00ff);\n    return n = (n & 0x0000ffff) + (n >> 16 & 0x0000ffff);\n}\n\nbool canMove(int u, int v, int state){\n    if(hx[u] != hx[v] && hy[u] != hy[v]){return false;}\n    if(hx[u] == hx[v]){\n        if(hy[u] > hy[v]){std::swap(u, v);}\n        for(auto i : Y[hx[u]]){\n            if(state >> i & 1 && hy[u] < hy[i] && hy[i] < hy[v]){return false;}\n        }\n    }else{\n        if(hx[u] > hx[v]){std::swap(u, v);}\n        for(auto i : X[hy[u]]){\n            if(state >> i & 1 && hx[u] < hx[i] && hx[i] < hx[v]){return false;}\n        }\n    }\n    return true;\n}\n\nint rec(int v, int state){\n    // printf(\"%d\\n\", v);\n    if(bitCount(state) == hn){return canMove(v, hn, state);}\n    if(dp[v][state] != -1){return dp[v][state];}\n\n    int res = 0;\n    for(auto u : X[hy[v]]){\n        if(state >> u & 1){continue;}\n        if(!canMove(u, v, state)){continue;}\n        res += rec(u, state | (1 << u));\n    }\n\n    for(auto u : Y[hx[v]]){\n        // printf(\"y: %d, %d, %d, (%d, %d), (%d, %d)\\n\", u, v, canMove(u, v), hx[u], hy[u], hx[v], hy[v]);\n        if(state >> u & 1){continue;}\n        if(!canMove(u, v, state)){continue;}\n        res += rec(u, state | (1 << u));\n    }\n\n    // if(res == 0){puts(\"------------------------------\");}\n    return dp[v][state] = res;\n}\n\nint main(){\n    while(std::cin >> W >> H, W){\n        hn = 0;\n        REP(i, 23){\n            REP(j, 1<<23){\n                dp[i][j] = -1;\n            }\n        }\n        REP(i, 10){\n            X[i].clear(); Y[i].clear();\n        }\n        REP(i, H){\n            REP(j, W){\n                int n;\n                std::cin >> n;\n\n                if(n == 1){\n                    hx[hn] = j; hy[hn] = i;\n                    // printf(\"(%d, %d)\\n\", j, i);\n                    X[i].push_back(hn);\n                    Y[j].push_back(hn);\n                    hn++;\n                }else if(n == 2){\n                    // printf(\"church: (%d, %d)\\n\", j, i);\n                    cx = j; cy = i;\n                }\n            }\n        }\n        hx[hn] = cx; hy[hn] = cy;\n\n        int res = 0;\n        for(int s : X[cy]){\n            // printf(\"s: %d, %d, %d\\n\", s, hx[s], hy[s]);\n            res += rec(s, 1 << s);\n        }\n\n        for(int s : Y[cx]){\n            // printf(\"s: %d, %d, %d\\n\", s, hx[s], hy[s]);\n            res += rec(s, 1 << s);\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint x,y;\nint map[10][10];\nint hmx[24],hmy[24];\nint gx,gy;\nint home;\nint ans;\nbool hm[24];\nint dx[5]={0,0,1,0,-1};\nint dy[5]={0,1,0,-1,0};\n\nvoid dfs(int mx,int my,int d,int ho2,int map2[10][10],int hmmx[24],int hmmy[24],bool hm2[24]){\n\tif(ho2==0){\n\t\tif(mx==gx || my==gy){\n\t\t\tbool ch=true;\n\t\t\tif(mx==gx){\n\t\t\t\tif(my>gy){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(mx==hmmx[j] && my>hmmy[j] && hmmy[j]>gy && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(my<gy){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(mx==hmmx[j] && my<hmmy[j] && hmmy[j]<gy && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(my==gy){\n\t\t\t\tif(mx>gx){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(my==hmmy[j] && mx>hmmx[j] && hmmx[j]>gx && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mx<gx){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(my==hmmy[j] && mx<hmmx[j] && hmmx[j]<gx && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ch)ans++;\n\t\t}\n\t}else for(int i=0;i<home;i++){\n\t\tif(hm2[i]==false)if(mx==hmmx[i] || my==hmmy[i]){\n\t\t\tbool ch=true;\n\t\t\tif(mx==hmmx[i]){\n\t\t\t\tif(my>hmmy[i]){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(mx==hmmx[j] && my>hmmy[j] && hmmy[j]>hmmy[i] && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(my<hmmy[i]){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(mx==hmmx[j] && my<hmmy[j] && hmmy[j]<hmmy[i] && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(my==hmmy[i]){\n\t\t\t\tif(mx>hmmx[i]){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(my==hmmy[j] && mx>hmmx[j] && hmmx[j]>hmmx[i] && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(mx<hmmx[i]){\n\t\t\t\t\tfor(int j=0;j<home;j++){\n\t\t\t\t\t\tif(my==hmmy[j] && mx<hmmx[j] && hmmx[j]<hmmx[i] && hm2[j]==true)ch=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ch){\n\t\t\t\thm2[i]=true;\n\t\t\t\tdfs(hmmx[i],hmmy[i],0,ho2-1,map2,hmmx,hmmy,hm2);\n\t\t\t\thm2[i]=false;\n\t\t\t}\n\t\t}\n\t}\n\t/*if(map2[mx][my]==2 && ho2==0)ans++;\n\telse{\n\t\tif(map2[mx][my]==1){\n\t\t\tmap2[mx][my]=3;\n\t\t\tho2-=1;\n\t\t\tdfs(mx,my,0,ho2,map2);\n\t\t\tmap2[mx][my]=1;\n\t\t\tho2+=1;\n\t\t}\n\t\tif(d==0){\n\t\t\tfor(int i=1;i<=4;i++){\n\t\t\t\tint kx=mx+dx[i],ky=my+dy[i];\n\t\t\t\tif(kx>=0 && kx<x && ky>=0 && ky<y && map2[kx][ky]!=3){\n\t\t\t\t\tdfs(kx,ky,i,ho2,map2);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint kx=mx+dx[d],ky=my+dy[d];\n\t\t\tif(kx>=0 && kx<x && ky>=0 && ky<y && map2[kx][ky]!=3){\n\t\t\t\tdfs(kx,ky,d,ho2,map2);\n\t\t\t}\n\t\t}\n\t}*/\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\thome=0;\n\t\tans=0;\n\t\tmemset(hm,false,sizeof(hm));\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&map[j][i]);\n\t\t\t\tif(map[j][i]==2)gx=j,gy=i;\n\t\t\t\tif(map[j][i]==1)hmx[home]=j,hmy[home]=i;\n\t\t\t\tif(map[j][i]==1)home++;\n\t\t\t}\n\t\t}\n\t\tdfs(gx,gy,0,home,map,hmx,hmy,hm);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include <cstring>\n#define MAX 11\n#define MAX_BITS 19\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint dp[(1<<MAX_BITS)+1][23];\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n//\tcout << \"hi\" << bit << endl;\n\tif(housInd[ny][nx] != -1 && bit < (1 << MAX_BITS) && dp[bit][housInd[ny][nx]] != -1){\n\t\treturn dp[bit][housInd[ny][nx]];\n\t}\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\t\n\tif (isLast && dp[1<<MAX_BITS][housInd[ny][nx]] != -1) return dp[1<<19][housInd[ny][nx]];\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[1<<MAX_BITS][housInd[ny][nx]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!isLast) {\n\t\t\t\t\tif ((bit & 1 << ind) == 0) {\n\t\t\t\t\t\tret += func(y, x, bit | (1 << ind));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn isLast ? (dp[1<<MAX_BITS][housInd[ny][nx]] = ret)\n\t\t\t: (housInd[ny][nx] != -1 && bit < (1 << MAX_BITS)) ? (dp[bit][housInd[ny][nx]] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nconst int B = 24;\nint dp[24][1 << B];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (idx == hs && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\tif (bits < 1 << B && ~dp[idx][bits]) return dp[idx][bits];\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(x, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\tif (bits < 1 << B)\n\t\treturn dp[idx][bits] = res;\n\telse return res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstring>\n \n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n#define all(v) v.begin(), v.end()\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nconst int INF = 1<<29;\n\nint field[11][11];\nbool visit[11][11];\nP start;\nint house;\nint w, h;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint dfs(int x, int y, int dir, int cnt){\n\tif(x < 0 || x >= w || y < 0 || y >= h) return 0;\n\tif(cnt == house && MP(x, y) == start) return 1;\n\tif(visit[y][x]) return 0;\n\tint res = 0;\n\tif(field[y][x]){\n\t\tvisit[y][x] = 1;\n\t\trep(i, 4){\n\t\t\tres += dfs(x+dx[i], y+dy[i], i, cnt+1);\n\t\t}\n\t\tvisit[y][x] = 0;\n\t}\n\n\treturn res + dfs(x+dx[dir], y+dy[dir], dir, cnt);\n}\n\nint main(){\n\twhile(cin >> w >> h, w|h){\n\t\trep(i, h) rep(j, w) cin >> field[i][j];\n\t\tstart = MP(0, 0);\n\t\thouse = 0;\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] == 2){\n\t\t\t\tstart = MP(j, i);\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t\tif(field[i][j]) house++;\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 4){\n\t\t\tans += dfs(start.X, start.Y, i, 0);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint n,m;\n\nint kx,ky;\nint field[11][11];\nint home;\nconst int INF=1000000000;\n\nint cnt=0;\n\nvoid dfs(int x,int y){\n\tif(home==0){\n\t\tif(x==kx||y==ky){\n\t\t\tcnt++;\n\t\t\treturn;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i = y-1; i >= 0; i--){\n\t\t\tif(field[i][x]==1){\n\t\t\t\tfield[i][x]=0;\n\t\t\t\thome--;\n\t\t\t\tdfs(x,i);\n\t\t\t\thome++;\n\t\t\t\tfield[i][x]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = y+1; i < n; i++){\n\t\t\tif(field[i][x]==1){\n\t\t\t\tfield[i][x]=0;\n\t\t\t\thome--;\n\t\t\t\tdfs(x,i);\n\t\t\t\thome++;\n\t\t\t\tfield[i][x]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = x-1; i >= 0; i--){\n\t\t\tif(field[y][i]==1){\n\t\t\t\tfield[y][i]=0;\n\t\t\t\thome--;\n\t\t\t\tdfs(i,y);\n\t\t\t\thome++;\n\t\t\t\tfield[y][i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = x+1; i < m; i++){\n\t\t\tif(field[y][i]==1){\n\t\t\t\tfield[y][i]=0;\n\t\t\t\thome--;\n\t\t\t\tdfs(i,y);\n\t\t\t\thome++;\n\t\t\t\tfield[y][i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\twhile(cin>>m>>n&&!(n==0&&m==0)){\n\t\thome=0;\n\t\tcnt=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]==2){\n\t\t\t\t\tkx=j;\n\t\t\t\t\tky=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]==1)\n\t\t\t\t\thome++;\n\t\t\t}\n\t\t}\n\t\tdfs(kx,ky);\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp.find(P(bit,h)) != dp.end()){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) > 18) dp[P(bit,h)] = ret;\n  return ret;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint memo[23][1<<23];\nvector<Pi> houses;\nint M,N,SY,SX;\n\ninline bool HasVisited(const int y,const int x,const int state,const vector<vector<int> > &G){\n\tif(G[y][x]!=1) return false;\n\tREP(i,0,houses.size()) if(houses[i].F_==y&&houses[i].S_==x&&((state>>i)&1)==1) return true; \n\treturn false;\n}\n\ninline int GetHouseNum(const int y,const int x,const vector<vector<int> > &G){\n\tif(G[y][x]!=1) return -1;\n\tREP(i,0,houses.size()) if(houses[i].F_==y&&houses[i].S_==x) return i;\n\treturn -1;\n}\n\nint DFS(const int Y,const int X,const vector<vector<int> > &G,int dir,int state){\n\t//cout << Y << ' ' << X << ' ' << dir << ' ' << state << endl;\n\tif(Y==SY&&X==SX&&(state&((1<<houses.size())-1))==((1<<houses.size())-1)){\n\t\t//cout << \"a: \" << Y << ' ' << X << ' ' << dir << ' ' << state << endl;\n\t\treturn 1;\n\t}\n\tint house_num=GetHouseNum(Y,X,G);\n\tif(house_num!=-1&&memo[house_num][state]!=-1) return memo[house_num][state];\n\tif(G[Y][X]==1){\n\t\tmemo[house_num][state]=0;\n\t\tREP(i,0,4){\n\t\t\tint ny=Y+dy[i],nx=X+dx[i];\n\t\t\tif(0<=ny&&ny<N&&0<=nx&&nx<M&&!HasVisited(ny,nx,state,G)){\n\t\t\t\tmemo[house_num][state]+=DFS(ny,nx,G,i,state|(1<<house_num));\n\t\t\t}\n\t\t}\n\t}\n\tint ny=Y+dy[dir],nx=X+dx[dir];\n\tif(0<=ny&&ny<N&&0<=nx&&nx<M&&!HasVisited(ny,nx,state,G)){\n\t\tif(house_num!=-1) memo[house_num][state]+=DFS(ny,nx,G,dir,state);\n\t\telse return DFS(ny,nx,G,dir,state);\n\t}\n\tif(house_num!=-1) return memo[house_num][state];\n\telse return 0;\n}\n\nint Solve(){\n\t//fill((int*)memo,(int*)(memo+23*(1<<23)),-1);\n\tREP(i,0,23) REP(j,0,(1<<23)) memo[i][j]=-1;\n\thouses.clear();\n\tvector<vector<int> > G(N,vector<int>(M));\n\tREP(y,0,N) REP(x,0,M) cin >> G[y][x];\n\tREP(y,0,N) REP(x,0,M){\n\t\tif(G[y][x]==2){\n\t\t\tSY=y;\n\t\t\tSX=x;\n\t\t}else if(G[y][x]==1){\n\t\t\thouses.push_back(Pi(y,x));\n\t\t}\n\t}\n\tint result=0;\n\tREP(i,0,4) result+=DFS(SY,SX,G,i,0);\n\treturn result;\n}\n\nint main(){\n\twhile(cin >> M >> N&&!(M==0&&N==0)){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nconst int MAX = 10;\nconst int MAX_N = 24;\nconst int G = 23;\nconst int dy[] = {1,0,-1,0};\nconst int dx[] = {0,1,0,-1};\n\nint mask[MAX_N][MAX_N];\nint node_id[MAX_N][MAX_N];\n\nint grid[MAX][MAX];\nint H,W,N;\nint dp[MAX_N][(1 << MAX_N)];\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> grid[i][j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_N ; i++){\n    for(int j = 0 ; j < MAX_N ; j++){      \n      node_id[i][j] = -1;\n      mask[i][j] = -1;\n    }\n  }\n}\n\nvoid makeMask(){\n  N = 0;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] == 1)node_id[i][j] = N++;\n      if(grid[i][j] == 2)node_id[i][j] = G;\n    }\n  }\n  \n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] != 0){\n\tfor(int d = 0 ; d < 4 ; d++){\n\t  int x = j;\n\t  int y = i;\n\t  int bit = 0;\n\t  while(1){\n\t    x += dx[d]; y += dy[d];\n\t    if(!(0 <= x && x < W && 0 <= y && y < H))break;\n\t    if(node_id[y][x] == -1)continue;\n\t    if(node_id[y][x] != G){\n\t      bit |= (1 << node_id[y][x]);\n\t    }\n\t    mask[node_id[i][j]][node_id[y][x]] = bit;\n\t    //cout <<\"from = \" << node_id[i][j] << \" to = \" << node_id[y][x] <<  \" bit = \" << bit << endl;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H,H|W){\n\n    init();\n    input();\n    makeMask();\n    \n    // dp init\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = 0;\n      }\n    }\n    \n    // dp start\n    for(int i = 0 ; i < N ; i++){\n      if(mask[G][i] != -1)dp[i][(1 << i)] = 1;\n    }\n    \n    //cout << \"N = \" << N << endl;\n    for(int i = 0 ; i < (1 << N) ; i++){\n      for(int j = 0 ; j < N ; j++){\n\t//if(dp[i][j] == 0)continue;\n\tfor(int k = 0 ; k < N ; k++){\n\t  //cout <<\"mask = \" <<  mask[j][k] << endl;\n\t  if((mask[j][k] & i) == 0){\n\t    dp[k][i|(1 << k)] += dp[j][i];\n\t  }\n\t}\n      }\n    }\n\n    // dp goal\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      if(mask[i][G] != -1 && ((mask[i][G]&((1 << N)-1)) == 0))res += dp[i][(1 << N)-1];\n    }\n    cout << res << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n//#include <ext/hash_map>\n#include <tr1/unordered_map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing namespace tr1;\n//using namespace __gnu_cxx;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n//hash_map<int,int> hii;\nunordered_map<int,int> hii;\n\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //ツ静「ツ妥篠づ可姪淞づェツづゥ\n    return 1;\n  }\n  if( isnotgoal(s) ){ //ツ仰ウツ嘉ッツづ可姪淞づゥツつスツづ淞づ個嘉づーツ湘氾ッツつオツつスツつゥツづつ、ツつゥ\n    return 0;\n  }\n  //hash_map<int,int>::iterator it = hii.find(S);\n  unordered_map<int,int>::iterator it = hii.find(S);\n  if( it!=hii.end() ){ //ツ探ツ催オツ催渉づ敖づ個湘ウツ妥板つゥツづつ、ツつゥ\n    return it->second;\n  }\n\n  // ツプツδ個ゼツδ督トツつェツ置ツつッツづ按つ「ツ嘉づ個有ツ鳴ウ\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  hii.insert(make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    hii.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\nint m,n;\nint mm[10][10]={0};\nint ch_y,ch_x;\nint mo4[] = {0,1,0,-1,0};\nint max_v = 1;\n\n//map<pair<pair<int,int>,int>,int> memo;\n\n//int memo[10][10][1<<23]={0};\n\nint dfs(int y,int x,int v){\n    int ret = 0;\n    //pair<pair<int,int>,int> p = {{y,x},v};\n    //if(memo[p]) return memo[p];\n    \n    //fprintf(stderr,\"(%2d,%2d) : %d\\n\",x,y,v);\n    \n    for(int i=0;i<4;i++){\n        int tox = x,toy = y;\n        \n        while(1){\n            tox += mo4[i];\n            toy += mo4[i+1];\n            \n            if(tox<0 || m<=tox || toy<0 || n<=toy) break;\n            \n            \n            if(mm[toy][tox]==0) continue;\n            \n            if(mm[toy][tox]==-1){\n                if(max_v == v){\n                    return 1;\n                }else{\n                    continue;\n                }\n            }\n            \n            if(mm[toy][tox]&v) continue;\n            \n            ret += dfs(toy,tox,v|mm[toy][tox]);\n            break;\n        }\n    }\n    \n    //fprintf(stderr,\"memo[%2d][%2d][%2d] = %lld\\n\",x,y,v,ret%mod);\n    /*\n    if(__builtin_popcount(ret) <= 18)\n        memo[p] = ret;\n    */\n    return ret;\n}\n\n\nvoid calc(int m,int n){\n    \n    //memset(memo,0,sizeof(memo));\n    \n    //memo.clear();\n    \n    max_v = 1;\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&mm[i][j]);\n            \n            if(mm[i][j]==1){\n                mm[i][j] = max_v;\n                max_v*=2;\n            }else if(mm[i][j]==2){\n                mm[i][j] = -1;\n                ch_y = i;\n                ch_x = j;\n            }\n        }\n    }\n    \n    max_v--;\n    \n    printf(\"%d\\n\",dfs(ch_y,ch_x,0));\n    \n    return;\n}\n\nint main(){\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(m==0) break;\n        calc(m,n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nint tb[10][10];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint bfs() {\n\n\tint ans = 0;\n\tqueue<P> que;\n\tque.push(P(hs, (1 << hs) - 1));\n\n\twhile (!que.empty()) {\n\t\tint idx, bits;\n\t\ttie(idx, bits) = que.front(); que.pop();\n\t\tint nr, nc;\n\t\ttie(nr, nc) = vp[idx];\n\t\tif (bits == 0) {\n\t\t\tif (nr == sr || nc == sc) ans++;\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\t\tint x = tb[i][nc];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tint t = bits & ~(1 << x);\n\t\t\t\tif (!t) {\n\t\t\t\t\tif (i == sr || nc == sc) ans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\t\tint x = tb[i][nc];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tint t = bits & ~(1 << x);\n\t\t\t\tif (!t) {\n\t\t\t\t\tif (i == sr || nc == sc) ans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\t\tint x = tb[nr][j];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tint t = bits & ~(1 << x);\n\t\t\t\tif (!t) {\n\t\t\t\t\tif (nr == sr || j == sc) ans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\t\tint x = tb[nr][j];\n\t\t\tif (bits >> x & 1) {\n\t\t\t\tint t = bits & ~(1 << x);\n\t\t\t\tif (!t) {\n\t\t\t\t\tif (nr == sr || j == sc) ans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tque.push(P(x, bits & ~(1 << x)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\tvp.push_back(P(sr, sc));\n\n\t\tcout << bfs() << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nint m,n;\nint d[10][10];\nint X,Y,res;\nint check(int count,int Data[10][10],int x,int y){\n\tint data[10][10];\n\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) data[i][j]=Data[i][j];\n\tdata[y][x]=1;\n\tint r=0;\n\tfor(int i=x+1;i<m;i++){\n\t\tif(count==0&&d[y][i]==2) return 1;\n\t\tif(data[y][i]==1) break;\n\t\tif(d[y][i]==1) r+=check(count-1,data,i,y);\n\t}\n\tfor(int i=x-1;i>=0;i--){\n\t\tif(count==0&&d[y][i]==2) return 1;\n\t\tif(data[y][i]==1) break;\n\t\tif(d[y][i]==1) r+=check(count-1,data,i,y);\n\t}\n\tfor(int i=y+1;i<n;i++){\n\t\tif(count==0&&d[i][x]==2) return 1;\n\t\tif(data[i][x]==1) break;\n\t\tif(d[i][x]==1) r+=check(count-1,data,x,i);\n\t}\n\tfor(int i=y-1;i>=0;i--){\n\t\tif(count==0&&d[i][x]==2) return 1;\n\t\tif(data[i][x]==1) break;\n\t\tif(d[i][x]==1) r+=check(count-1,data,x,i);\n\t}\n\treturn r;\n}\n\nint data[10][10];\n\nint main(){\n\twhile(scanf(\"%d%d\",&m,&n),m){\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++){\n\t\t\tscanf(\"%d\",&d[i][j]);\n\t\t\tif(d[i][j]==2)X=j,Y=i;\n\t\t\tif(d[i][j]==1)res++;\n\t\t}\n\t\tprintf(\"%d\\n\",check(res,data,X,Y));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 19;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX && !(cnt >= 19 && sum == 0)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint vec[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvoid solve(int nx,int ny,int wx,int wy,int rem,vector<vector<int> > tab){\n    for(int v=0;v<4;v++){\n        int nowx=nx,nowy=ny;\n        for(;;){\n            nowx+=vec[v][0],nowy+=vec[v][1];\n            if(!(0<=nowx&&nowx<wx&&0<=nowy&&nowy<wy))break;\n            if(tab[nowx][nowy]==2){\n                if(rem==0){ans++;}\n                break;\n            }\n            if(tab[nowx][nowy]==1){\n                tab[nowx][nowy]=-1;\n                solve(nowx,nowy,wx,wy,rem-1,tab);\n                tab[nowx][nowy]=1;\n                break;\n            }\n        }\n    }\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        vector<vector<int> > table(n,vector<int>(m));\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&table[i][j]);\n            if(table[i][j]==1)homec++;\n            else if(table[i][j]==2){stx=i;sty=j;}\n        }\n        ans=0;\n        solve(stx,sty,n,m,homec,table);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nmap<P,int>ma;\nint f[15][15];\nint linkk[15][15];\nP za[25];\nint n,m;\nint val;\nint dp(int mask,int cur)\n{\n\tint ret=0;\n\tif(ma[mp(mask,cur)]) return ma[mp(mask,cur)];\n\tint x=za[cur].first;\n\tint y=za[cur].second;\n\tif(mask==(1<<val)-1)\n\t{\n\t\tif(x==za[23].first || y==za[23].second) return 1;\n\t\telse return 0;\n\t}\n\tfor(int i=x-1;i>=0;i--)\n\t{\n\t\tint s=linkk[i][y];\n\t\tif(f[i][y]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<s),s);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=x+1;i<m;i++)\n\t{\n\t\tint s=linkk[i][y];\n\t\tif(f[i][y]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<s),s);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=y-1;i>=0;i--)\n\t{\n\t\tint s=linkk[x][i];\n\t\tif(f[x][i]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<s),s);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=y+1;i<n;i++)\n\t{\n\t\tint s=linkk[x][i];\n\t\tif(f[x][i]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<s),s);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret) ma[mp(mask,cur)]=ret;\n\treturn ret;\n}\nint main(){\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tma.clear();\n\t\tif(!n) return 0;\n\t\tint num=0; val=0;\n\t\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++) { f[i][j]=INF; linkk[i][j]=-1;}\n\t\t\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j]==1) { linkk[i][j]=num; za[num++]=mp(i,j); val++;}\n\t\t\t\tif(f[i][j]==2) za[23]=mp(i,j);\n\t\t\t}\n\t\t\n\t\t}\n\t\tcout << dp(0,23) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\n\nint w, h;\nint ans = 0;\nvector<P> can_go;\n\n\nbool CanMove(int y, int x){\n    if(y < 0) return false;\n    if(x < 0) return false;\n    if(y >= h) return false;\n    if(x >= w) return false;\n    return true;\n}\n\nvoid dfs(int y, int x, int cnt, int home, vector< vector<int> > m, vector< vector<bool> > used){\n    int my[] = {1, -1, 0, 0};\n    int mx[] = {0, 0, 1, -1};\n    if(cnt >= home){\n        bool flg = false;\n        REP(i, can_go.size()){\n            if(y == can_go[i].first && x == can_go[i].second){\n                flg = true;\n            }\n        }\n        if(flg) ans++;\n    } else{\n        REP(i, 4){\n            int ny = y + my[i];\n            int nx = x + mx[i];\n            while(CanMove(ny, nx)){\n                if(used[ny][nx]) break;\n                if(m[ny][nx] == 1){\n\n                    used[ny][nx] = true;\n                    dfs(ny, nx, cnt + 1, home, m, used);\n                    used[ny][nx] = false;\n\n                }\n                ny += my[i];\n                nx += mx[i];\n            }\n        }\n    }\n}\n\n\nint main(){\n    int my[] = {1, -1, 0, 0};\n    int mx[] = {0, 0, 1, -1};\n    while(cin >>w >>h && (w || h)){\n        can_go.clear();\n        ans = 0;\n        vector< vector<int> > m(h, vector<int>(w) );\n        int sy, sx, home = 0;\n        REP(i, h){\n            REP(j, w){\n                cin >>m[i][j];\n                if(m[i][j] == 2){\n                    sy = i;\n                    sx = j;\n                }\n                if(m[i][j] == 1){\n                    home++;\n                }\n            }\n        }\n        REP(i, h){\n            REP(j, w){\n                if(m[i][j] == 1){\n                    int flg = false;\n                    REP(k, 4){\n                        int ny = i + my[k];\n                        int nx = j + mx[k];\n                        while(CanMove(ny, nx)){\n                            if(m[ny][nx] == 1){\n                                break;\n                            }\n                            if(m[ny][nx] == 2){\n                                flg = true;\n                            }\n                            ny += my[k];\n                            nx += mx[k];\n                        }\n                    }\n                    if(flg){\n                        can_go.push_back( P(i, j) );\n                    }\n                }\n            }\n        }\n\n        int cnt = 0;\n        vector< vector<bool> > used(h, vector<bool>(w, false) );\n        used[sy][sx] = true;\n        dfs(sy, sx, cnt, home, m, used);\n        cout <<ans <<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint W, H, cnt, g[11][11], X[24], Y[24];\nunordered_map< int, int > memo[24];\n\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nint rec(int S, int i) {\n\tif (S == (1 << cnt) - 1) {\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[i], ny = Y[i];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (!in_range(nx, ny)) break;\n\t\t\t\tif (g[ny][nx] == -1) break;\n\t\t\t\tif (g[ny][nx] == -2) return 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tif (memo[i].count(S)) return memo[i][S];\n\t\n\tint res = 0;\n\t\n\tfor_(j,0,cnt) {\n\t\tif (S >> j & 1) continue;\n\t\t\n\t\tbool isok = false;\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[j], ny = Y[j];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (!in_range(nx, ny)) break;\n\t\t\t\t\n\t\t\t\tisok |= (X[i] == nx && Y[i] == ny);\n\t\t\t\tif (isok) break;\n\t\t\t\t\n\t\t\t\tif (g[ny][nx] == -1) break;\n\t\t\t\tisok |= (g[ny][nx] >= 0);\n\t\t\t\tif (isok) break;\n\t\t\t}\n\t\t\t\n\t\t\tif (isok) break;\n\t\t}\n\t\t\n\t\tif (!isok) return (__builtin_popcount(S) >= 10 ? memo[i][S] = 0 : 0);\n\t}\n\t\n\tfor_(d,0,4) {\n\t\tint nx = X[i], ny = Y[i];\n\t\t\n\t\tfor_(rep,0,10) {\n\t\t\tnx += dx[d];\n\t\t\tny += dy[d];\n\t\t\t\n\t\t\tif (!in_range(nx, ny)) break;\n\t\t\tif (g[ny][nx] == -1) break;\n\t\t\tif (g[ny][nx] < -1) continue;\n\t\t\t\n\t\t\tint j = g[ny][nx];\n\t\t\t\t\t\t\n\t\t\tg[ny][nx] = -1;\n\t\t\tres += rec(S | 1 << j, j);\n\t\t\tg[ny][nx] = j;\n\t\t}\n\t}\n\t\t\n\treturn (__builtin_popcount(S) >= 10 ? memo[i][S] = res : res);\n}\n\nvoid solve() {\n\tfor_(i,0,24) memo[i].clear();\n\tcout << rec(0, 23) << endl;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tcnt = 0;\n\t\t\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tcin >> g[y][x];\n\t\t\t\n\t\t\tif (g[y][x] == 0) g[y][x] = -3;\n\t\t\telse if (g[y][x] == 1) { X[cnt] = x; Y[cnt] = y; g[y][x] = cnt; ++cnt; }\n\t\t\telse if (g[y][x] == 2) { X[23] = x; Y[23] = y; g[y][x] = -2; }\n\t\t}\n\t\t\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\nusing namespace std;\n\nconst int MAX = 10;\nconst int MAX_N = 23;\nconst int G = 23;\nconst int dy[] = {1,0,-1,0};\nconst int dx[] = {0,1,0,-1};\n\nint mask[MAX_N+1][MAX_N+1];\nshort node_id[MAX_N+1][MAX_N+1];\nshort grid[MAX][MAX];\n\nint H,W,N;\n\ntypedef pair<int,int>P;\nmap<P,int>mp;\n\nvoid input(){\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> grid[i][j];\n    }\n  }\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_N+1 ; i++){\n    for(int j = 0 ; j < MAX_N+1 ; j++){      \n      node_id[i][j] = -1;\n      mask[i][j] = -1;\n    }\n  }\n  mp.clear();\n}\n\nvoid makeMask(){\n  N = 0;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] == 1)node_id[i][j] = N++;\n      if(grid[i][j] == 2)node_id[i][j] = G;\n    }\n  }\n  \n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      if(grid[i][j] != 0){\n\tfor(int d = 0 ; d < 4 ; d++){\n\t  int x = j;\n\t  int y = i;\n\t  int bit = 0;\n\t  while(1){\n\t    x += dx[d]; y += dy[d];\n\t    if(!(0 <= x && x < W && 0 <= y && y < H))break;\n\t    if(node_id[y][x] == -1)continue;\n\t    if(node_id[y][x] != G){\n\t      bit |= (1 << node_id[y][x]);\n\t    }\n\t    mask[node_id[i][j]][node_id[y][x]] = bit;\n\t    //cout <<\"from = \" << node_id[i][j] << \" to = \" << node_id[y][x] <<  \" bit = \" << bit << endl;\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nint dfs(int now,int last,int bit){\n  if(mp.count(P(now,bit)) != 0)return mp[P(now,bit)];\n  int& ret = mp[P(now,bit)];\n\n  if(now == last){\n    if(bit != (1 << N)-1)return ret = 0;\n    if((mask[now][G] & bit) != 0)return ret = 0;\n    return ret = 1;\n  }\n\n  if((mask[last][G] & bit) != 0)return ret = 0;\n\n  /*\n  if(bit == (1 << N)-1){\n  if((mask[now][G] & bit) != 0)return ret = 0;\n    return ret = 1;\n  }\n  */\n\n  for(int to = 0 ; to < N ; to++){\n    if((mask[now][to] & bit) == 0){\n      ret += dfs(to,last,bit|(1 << to));\n    }    \n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> W >> H,H|W){\n\n    init();\n    input();\n    makeMask();\n\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < N ; j++){\n\tif(i == j)continue;\n\tmp.clear();\n\tif(mask[G][i] != -1)res += dfs(i,j,(1 << i));\n      }\n    }\n    cout << res << endl;\n    \n    /*\n\n    // dp init\n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < (1 << N) ; j++){\n\tdp[i][j] = 0;\n      }\n    }\n    \n    // dp start\n    for(int i = 0 ; i < N ; i++){\n      if(mask[G][i] != -1)dp[i][(1 << i)] = 1;\n    }\n    \n    //cout << \"N = \" << N << endl;\n    for(int i = 0 ; i < (1 << N) ; i++){\n      for(int j = 0 ; j < N ; j++){\n      //if(dp[i][j] == 0)continue;\n\tfor(int k = 0 ; k < N ; k++){\n\t  //cout <<\"mask = \" <<  mask[j][k] << endl;\n\t  if((mask[j][k] & i) == 0){\n\t    dp[k][i|(1 << k)] += dp[j][i];\n\t  }\n\t}\n      }\n    }\n\n    // dp goal\n    int res = 0;\n    for(int i = 0 ; i < N ; i++){\n      if(mask[i][G] != -1 && ((mask[i][G]&((1 << N)-1)) == 0))res += dp[i][(1 << N)-1];\n    }\n    cout << res << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n//#include <ext/hash_map>\n#include <tr1/unordered_map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing namespace tr1;\n//using namespace __gnu_cxx;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n//ツ催妥・ツ湘ウツ妥板青板づ個個按づ淞妥つソ\n#define SZ 885777\n\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n//hash_map<int,int> hii(SZ);\nunordered_map<int,int> hii(SZ);\n\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //ツ静「ツ妥篠づ可姪淞づェツづゥ\n    return 1;\n  }\n  if( isnotgoal(s) ){ //ツ仰ウツ嘉ッツづ可姪淞づゥツつスツづ淞づ個嘉づーツ湘氾ッツつオツつスツつゥツづつ、ツつゥ\n    return 0;\n  }\n  //hash_map<int,int>::iterator it = hii.find(S);\n  unordered_map<int,int>::iterator it = hii.find(S);\n  if( it!=hii.end() ){ //ツ探ツ催オツ催渉づ敖づ個湘ウツ妥板つゥツづつ、ツつゥ\n    return it->second;\n  }\n\n  // ツプツδ個ゼツδ督トツつェツ置ツつッツづ按つ「ツ嘉づ個有ツ鳴ウ\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  hii.insert(make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    hii.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp.find(P(bit,h)) != dp.end()){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) > 15) dp[P(bit,h)] = ret;\n  return ret;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\n#define MAX_N 10\n\nint x[MAX_N][MAX_N], G1[MAX_N][MAX_N], G2[MAX_N][MAX_N][4], h, w, gx, gy, cnt, C, c, X, Y;\nstack<int>S;\n\nvoid hantei() {\n\tX = S.top() % 10; Y = S.top() / 10; c = 0;\n\tif (G2[Y][X][0] == 0) {\n\t\tG2[Y][X][0] = 1;\n\t\tfor (int i = Y; i < h; i++) {\n\t\t\tif (G1[i][X] == 1 && x[i][X] == 1) {\n\t\t\t\tG1[i][X] = 0;\n\t\t\t\tS.push(i * 10 + X);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (G2[Y][X][1] == 0) {\n\t\tG2[Y][X][1] = 1;\n\t\tfor (int i = X; i < w; i++) {\n\t\t\tif (G1[Y][i] == 1 && x[Y][i] == 1) {\n\t\t\t\tG1[Y][i] = 0;\n\t\t\t\tS.push(Y * 10 + i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (G2[Y][X][2] == 0) {\n\t\tG2[Y][X][2] = 1;\n\t\tfor (int i = Y; i >= 0; i--) {\n\t\t\tif (G1[i][X] == 1 && x[i][X] == 1) {\n\t\t\t\tG1[i][X] = 0;\n\t\t\t\tS.push(i * 10 + X);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (G2[Y][X][3] == 0) {\n\t\tG2[Y][X][3] = 1;\n\t\tfor (int i = X; i >= 0; i--) {\n\t\t\tif (G1[Y][i] == 1 && x[Y][i] == 1) {\n\t\t\t\tG1[Y][i] = 0;\n\t\t\t\tS.push(Y * 10 + i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tc = 1;\n\treturn;\n}\n\nint bfs() {\n\tcnt = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tG1[i][j] = 1;\n\t\t}\n\t}\n\tS.push(gy * 10 + gx);\n\tG1[gy][gx] = 0;\n\twhile (!S.empty()) {\n\t\tif (S.size() == C + 1 && (S.top() / 10 == gy || S.top() % 10 == gx) ) {\n\t\t\tcnt++;\n\t\t}\n\t\thantei();\n\t\tif (c == 1) {\n\t\t\tG1[Y][X] = 1;\n\t\t\tG2[Y][X][0] = 0;\n\t\t\tG2[Y][X][1] = 0;\n\t\t\tG2[Y][X][2] = 0;\n\t\t\tG2[Y][X][3] = 0;\n\t\t\tS.pop();\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tC = 0;\n\t\tcin >> w >> h;\n\t\tif (h == 0 && w == 0) { break; }\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t\tif (x[i][j] == 1) { C++; }\n\t\t\t\tif (x[i][j] == 2) { gy = i; gx = j; }\n\t\t\t}\n\t\t}\n\t\tcout << bfs() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=14){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=20){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n\n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1<<28;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_N = 23;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint mem[MAX_N + 1][1 << MAX_N], w, h, sx, sy;\nvector<pii> hs, xl, yl;\nvector<tuple<int, int, int>> xy, yx;\n\nint Solve(int k, int mask) {\n    if (k == hs.size()) {\n\tif (mask == (1 << (hs.size() + 1)) - 1 && k == hs.size()) {\n\t    return 1;\n\t}\n\treturn 0;\n    }\n    if (mem[k][mask] != -1) return mem[k][mask];\n\n    int res = 0, x = hs[k].first, y = hs[k].second;\n    auto st = lower_bound(ALL(xy), MKT(x, y, k));\n    for (auto it = st + 1; it != xy.end() && get<0>(*it) == x; ++it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n    for (auto it = st - 1; xy.begin() <= it && get<0>(*it) == x; --it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n\n    st = lower_bound(ALL(yx), MKT(y, x, k));\n    for (auto it = st + 1; it != yx.end() && get<0>(*it) == y; ++it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n    for (auto it = st - 1; yx.begin() <= it && get<0>(*it) == y; --it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n\n    return mem[k][mask] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> w >> h, w) {\n\tmemset(mem, -1, sizeof(mem));\n\txy.clear();\n\tyx.clear();\n\ths.clear();\n\n\tfor (int y = 1; y <= h; ++y) {\n\t    for (int x = 1; x <= w; ++x) {\n\t\tint t;\n\t\tcin >> t;\n\t\tif (t == 1) {\n\t\t    xy.PB(MKT(x, y, hs.size()));\n\t\t    yx.PB(MKT(y, x, hs.size()));\n\t\t    hs.PB({x, y});\n\t\t} else if (t == 2) {\n\t\t    sx = x;\n\t\t    sy = y;\n\t\t}\n\t    }\n\t}\n\n\txy.PB(MKT(sx, sy, hs.size()));\n\tyx.PB(MKT(sy, sx, hs.size()));\n\tsort(ALL(xy));\n\tsort(ALL(yx));\n\n\tint ans = 0;\n\tauto st = lower_bound(ALL(xy), MKT(sx, -INF, -INF));\n\tfor (auto it = st; it != xy.end() && get<0>(*it) == sx; ++it) {\n\t    int tk = get<2>(*it);\n\t    if (tk == hs.size()) continue;\n\t    ans += Solve(tk, 1 << tk);\n\t}\n\n\tst = lower_bound(ALL(yx), MKT(sy, -INF, -INF));\n\tfor (auto it = st; it != yx.end() && get<0>(*it) == sy; ++it) {\n\t    int tk = get<2>(*it);\n\t    if (tk == hs.size()) continue;\n\t    ans += Solve(tk, 1 << tk);\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nmap<P,int>ma;\nint f[15][15];\nint link[15][15];\nP za[25];\nint n,m;\nint val;\nint dp(int mask,int cur)\n{\n\tint ret=0;\n\tif(ma[mp(mask,cur)]) return ma[mp(mask,cur)];\n\tint x=za[cur].first;\n\tint y=za[cur].second;\n\tif(mask==(1<<val)-1)\n\t{\n\t\tif(x==za[23].first || y==za[23].second) return 1;\n\t\telse return 0;\n\t}\n\tfor(int i=x-1;i>=0;i--)\n\t{\n\t\tint s=link[i][y];\n\t\tif(f[i][y]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[i][y]),link[i][y]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=x+1;i<m;i++)\n\t{\n\t\tint s=link[i][y];\n\t\tif(f[i][y]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[i][y]),link[i][y]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=y-1;i>=0;i--)\n\t{\n\t\tint s=link[x][i];\n\t\tif(f[x][i]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[x][i]),link[x][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=y+1;i<n;i++)\n\t{\n\t\tint s=link[x][i];\n\t\tif(f[x][i]==1 && !((mask>>s)&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[x][i]),link[x][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret) ma[mp(mask,cur)]=ret;\n\treturn ret;\n}\nint main(){\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tma.clear();\n\t\tif(!n) return 0;\n\t\tint num=0; val=0;\n\t\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++) { f[i][j]=INF; link[i][j]=-1;}\n\t\t\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j]==1) { link[i][j]=num; za[num++]=mp(i,j); val++;}\n\t\t\t\tif(f[i][j]==2) za[23]=mp(i,j);\n\t\t\t}\n\t\t\n\t\t}\n\t\tcout << dp(0,23) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<unordered_map>\n#include<cstring>\nusing namespace std;\nint encode(int v,int x,int y){return v*256U+x*16+y;}\nunsigned getv(unsigned a){return a/256;}\nint getx(unsigned a){return (a%256)/16;}\nint gety(unsigned a){return (a%256)%16;}\nint main(){\n\tint w,h,m[12][12],x,y,cx,cy,n,t;\n\tint dx[]={1,0,-1,0},dy[]={0,1,0,-1},d;\n\tfor(;cin>>w>>h,w;){\n\t\tn=0;\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(y=0;y<h;y++){\n\t\t\tfor(x=0;x<w;x++){\n\t\t\t\tcin>>t;\n\t\t\t\tif(t==1)\n\t\t\t\t\tm[1+x][1+y]=++n;\n\t\t\t\telse{\n\t\t\t\t\tm[1+x][1+y]=-1;\n\t\t\t\t\tif(t==2)\n\t\t\t\t\t\tcx=1+x,cy=1+y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttypedef unordered_map<unsigned,int>M;\n\t\ttypedef M::iterator I;\n\t\tM q[24];\n\t\tq[n][encode((1<<(n+1))-1,cx,cy)]=1;\n\t\tfor(;n;n--){\n\t\t\tfor(I it=q[n].begin();it!=q[n].end();++it){\n\t\t\t\tunsigned a=it->first;\n\t\t\t\tfor(d=0;d<4;d++){\n\t\t\t\t\tint tv=getv(a),tx=getx(a),ty=gety(a);\n\t\t\t\t\tfor(;;){\n\t\t\t\t\t\ttx+=dx[d],ty+=dy[d];\n\t\t\t\t\t\tt=m[tx][ty];\n\t\t\t\t\t\tif(t>=0&&tv&1<<t){\n\t\t\t\t\t\t\tif(t){\n\t\t\t\t\t\t\t\ttv^=1<<t;\n\t\t\t\t\t\t\t\tq[n-1][encode(tv,tx,ty)]+=it->second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"q[%d].size()=%d\\n\",n-1,q[n-1].size());\n\t\t\tq[n].clear();\n\t\t}\n\t\tint ans=0;\n\t\tfor(I it=q[0].begin();it!=q[0].end();++it){\n\t\t\tunsigned a=it->first;\n\t\t\tif(getx(a)==cx||gety(a)==cy)\n\t\t\t\tans+=it->second;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/10/22 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint DFS(int M[12][12], int N, int Y, int X)\n{\n//\tcout << M[Y][X] << ' ' << N << endl;\n\n\tint m[12][12];\n\tfor(int y=0; y<12; y++)\n\t\tfor(int x=0; x<12; x++)\n\t\t\tm[y][x] = M[y][x];\n\n\tint n = N;\n\n\tif(m[Y][X]==1){\n\t\tm[Y][X] = 0;\n\t\tn--;\n\t}\n\telse if(m[Y][X]==2){\n\t\t;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n\n\tint y, x;\n\n\tif(n==0){\n\t\ty = Y;\n\t\tx = X;\n\t\ty--;\n\t\twhile(m[y][x]==0)\n\t\t\ty--;\n\t\tif(m[y][x]==2)\n\t\t\treturn 1;\n\n\t\ty = Y;\n\t\tx = X;\n\t\ty++;\n\t\twhile(m[y][x]==0)\n\t\t\ty++;\n\t\tif(m[y][x]==2)\n\t\t\treturn 1;\n\n\t\ty = Y;\n\t\tx = X;\n\t\tx--;\n\t\twhile(m[y][x]==0)\n\t\t\tx--;\n\t\tif(m[y][x]==2)\n\t\t\treturn 1;\n\n\t\ty = Y;\n\t\tx = X;\n\t\tx++;\n\t\twhile(m[y][x]==0)\n\t\t\tx++;\n\t\tif(m[y][x]==2)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tint cnt = 0;\n\n\ty = Y;\n\tx = X;\n\ty--;\n\twhile(m[y][x]==0||m[y][x]==2)\n\t\ty--;\n\tif(m[y][x]==1)\n\t\tcnt += DFS(m, n, y, x);\n\n\ty = Y;\n\tx = X;\n\ty++;\n\twhile(m[y][x]==0||m[y][x]==2)\n\t\ty++;\n\tif(m[y][x]==1)\n\t\tcnt += DFS(m, n, y, x);\n\n\ty = Y;\n\tx = X;\n\tx--;\n\twhile(m[y][x]==0||m[y][x]==2)\n\t\tx--;\n\tif(m[y][x]==1)\n\t\tcnt += DFS(m, n, y, x);\n\n\ty = Y;\n\tx = X;\n\tx++;\n\twhile(m[y][x]==0||m[y][x]==2)\n\t\tx++;\n\tif(m[y][x]==1)\n\t\tcnt += DFS(m, n, y, x);\n\n\treturn cnt;\n}\n\nint main()\n{\n\twhile(true){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m==0&&n==0)\n\t\t\tbreak;\n\n\t\tint M[12][12];\n\t\tfor(int y=0; y<n+2; y++)\n\t\t\tfor(int x=0; x<m+2; x++)\n\t\t\t\tM[y][x] = 3;\n\n\t\tint N = 0;\n\t\tint Y, X;\n\t\tfor(int y=1; y<=n; y++){\n\t\t\tfor(int x=1; x<=m; x++){\n\t\t\t\tcin >> M[y][x];\n\t\t\t\tif(M[y][x]==1){\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t\telse if(M[y][x]==2){\n\t\t\t\t\tY = y;\n\t\t\t\t\tX = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cnt;\n\t\tcnt = DFS(M, N, Y, X);\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 19;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX && !(cnt >= 10 && sum == 0)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 3004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint sum = 0, ans = 0, ky, kx, a[12][12], f[12][12];\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\n\nvoid dfs(int y, int x, int cnt){\n\tfor(int i = 0;i < 4;i++){\n\t\tint yy = y;\n\t\tint xx = x;\n\t\twhile(1){\n\t\t\tyy += dy[i];\n\t\t\txx += dx[i];\n\t\t\tif(a[yy][xx] == -1)break;\n\t\t\tif(a[yy][xx] == 1 && f[yy][xx] == 0){\n\t\t\t\tf[yy][xx] = 1;\n\t\t\t\tdfs(yy, xx, cnt+1);\n\t\t\t\tf[yy][xx] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a[yy][xx] == 2){\n\t\t\t\tif(cnt == sum)ans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\n\nint main(){\n\tint w, h;\n\twhile(1){\n\t\tscanf(\"%d%d\",&w, &h);\n\t\tif(w == 0)break;\n\t\tfill((int*)a, (int*)(a+12), -1);\n\t\tfill((int*)f, (int*)(f+12), 0);\n\t\tsum = ans = 0;\n\t\trrep(i,h)rrep(j,w){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tif(a[i][j] == 2){ky = i;kx = j;}\n\t\t\tif(a[i][j] == 1)sum++;\n\t\t}\n\t\t\n\t\tdfs(ky, kx, 0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\n/*\nconst int dx[] = {0,1,0,-1}; //u,r,d,l\nconst int dy[] = {-1,0,1,0};\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint kari[32];\nvector<pair<int,int> > v;\n\n#if DEB\nstack<int> st;\n#endif\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( s==a.s ){\n      if( x==a.x ) return y<a.y;\n      else         return x<a.x;\n    }else{\n      return s<a.s;\n    }\n  }\n  \n};\n\nmap<state,int> msi;\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline int isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (kari[i]&s)==kari[i] ) return i;\n  }\n  return -1;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int mask = (1<<home)-1;\n  // v[gªu¯È¢ÆÌL³\n  // numofbits(~s&mask)>1\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<num[y][x]))!=-1 ){\n#if DEB\n    printf(\"s:%d ,(%d,%d)  __%d  ___isnot:%d\\n\",s,x,y,s&~num[y][x],isnot(s&~num[y][x]));\n    stack<int> tmp = st;\n    while( !tmp.empty() ){\n      printf(\"%d,\",tmp.top());\n      tmp.pop();\n    }\n    puts(\"\\n\");\n#endif\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\n#if DEB\n\tst.pop();\n#endif\n\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    v.clear();\n    memset(num,-1,sizeof(num));\n    memset(kari,0,sizeof(kari));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t  v.pb(mp(j,i));\n\t}\n      }\n    }\n\n    // other homes\n    rep(i,v.size()){\n      rep(k,4){\n\tfor(int j=1; j<20; j++){\n\t  int tx = v[i].first + dx[k]*j;\n\t  int ty = v[i].second + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    kari[i] |= (1<<num[ty][tx]);\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n#if DEB\n    printf(\"sz:%d\\n\",v.size());\n    printf(\"last:%d\\n\",last);\n    rep(i,v.size()){\n      printf(\"home:%d  , %d\\n\",i,kari[i]);\n    }\n#endif\n    \n    \n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nenum Direction {\n    EAST, WEST, NORTH, SOUTH\n};\n\nstruct Home {\n    int index;\n    Home *neighbor[4];\n};\n\nconst int GOAL = 100;\n\nHome homes[10][10];\n\nset<pair<int,int> > memo;\nint dfs(Home *cur, int mask, int rem) {\n    int sum = 0;\n\n    pair<int,int> key = make_pair(mask, cur->index);\n    if(memo.count(key)) return 0;\n\n    for(int dir = 0; dir < 4; ++dir) {\n        Home *next = cur->neighbor[dir];\n        while(next) {\n            if(rem == 0) {\n                if(next->index == GOAL) return 1;\n            }\n            if(next->index != GOAL && (mask&(1<<next->index))) break;\n            if(next->index != GOAL) sum += dfs(next, mask|(1<<next->index), rem-1);\n            next = next->neighbor[dir];\n        }\n    }\n    if(sum == 0) memo.insert(key);\n    return sum;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> M >> N;\n        if(!N && !M) break;\n\n        memset(homes, 0, sizeof(homes));\n        for(int i = 0; i < 10; ++i) {\n            for(int j = 0; j < 10; ++j) {\n                homes[i][j].index = -1;\n            }\n        }\n\n        int home_idx = 0;\n        int rem = 0;\n        int sr, sc;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < M; ++j) {\n                int val;\n                cin >> val;\n                if(val != 0) {\n                    if(val == 1) {\n                        homes[i][j].index = home_idx++;\n                        ++rem;\n                    }\n                    else {\n                        homes[i][j].index = GOAL;\n                        sr = i;\n                        sc = j;\n                    }\n\n                    for(int jj = j-1; jj >= 0; --jj) {\n                        if(homes[i][jj].index != -1) {\n                            homes[i][jj].neighbor[EAST] = &homes[i][j];\n                            homes[i][j].neighbor[WEST] = &homes[i][jj];\n                            break;\n                        }\n                    }\n                    for(int ii = i-1; ii >= 0; --ii) {\n                        if(homes[ii][j].index != -1) {\n                            homes[ii][j].neighbor[SOUTH] = &homes[i][j];\n                            homes[i][j].neighbor[NORTH] = &homes[ii][j];\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << dfs(&homes[sr][sc], 0, rem) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint tab[12][12];\nint wx,wy;\nint nx,ny,rem;\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy;\n    nowx=nx;nowy=ny;\nLA:;\n   nowx++;\n   if(nowx>=wx) goto LB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB: ;        \n\n    nowx=nx,nowy=ny;\nMA:;\n   nowx--;\n   if(0>nowx) goto MB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto MB;\n   }\n   goto MA;\nMB: ;        \n\n    nowx=nx,nowy=ny;\nNA:;\n   nowy++;\n   if(nowy>=wy) goto NB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto NB;\n   }\n   goto NA;\nNB: ;        \n\n    nowx=nx,nowy=ny;\nOA:;\n   nowy--;\n   if(0>nowy) goto OB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;        \n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint m,n,gx,gy,sum;\nint house[10][10];\nbool used[10][10];\nint rec(int x,int y,bool used[10][10]){\n\tint cnt=0;\n\tREP(i,n)REP(j,m)if(used[j][i])cnt++;\n\tif(cnt==sum&&x==gx&&y==gy)return 1;\n\tint res=0;\n\tfor(int i=x-1;i>=0;i--){\n\t\tif(house[i][y]&&!used[i][y]){\n\t\t\tused[i][y]=true;\n\t\t\tres+=rec(i,y,used);\n\t\t\tused[i][y]=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=x+1;i<m;i++){\n\t\tif(house[i][y]&&!used[i][y]){\n\t\t\tused[i][y]=true;\n\t\t\tres+=rec(i,y,used);\n\t\t\tused[i][y]=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=y-1;i>=0;i--){\n\t\tif(house[x][i]&&!used[x][i]){\n\t\t\tused[x][i]=true;\n\t\t\tres+=rec(x,i,used);\n\t\t\tused[x][i]=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=y+1;i<n;i++){\n\t\tif(house[x][i]&&!used[x][i]){\n\t\t\tused[x][i]=true;\n\t\t\tres+=rec(x,i,used);\n\t\t\tused[x][i]=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tif(m==0&&n==0)break;\n\t\tmemset(used,false,sizeof(used));\n\t\tsum=0;\n\t\tREP(i,n)REP(j,m){\n\t\t\tcin>>house[j][i];\n\t\t\tif(house[j][i]==2){gx=j;gy=i;}\n\t\t\tif(house[j][i])sum++;\n\t\t}\n\t\tcout<<rec(gx,gy,used)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n//#include <ext/hash_map>\n#include <tr1/unordered_map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing namespace tr1;\n//using namespace __gnu_cxx;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n#define SZ 885777\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n//hash_map<int,int> hii(3000000);\nunordered_map<int,int> hii(3000000);\n\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //ツ静「ツ妥篠づ可姪淞づェツづゥ\n    return 1;\n  }\n  if( isnotgoal(s) ){ //ツ仰ウツ嘉ッツづ可姪淞づゥツつスツづ淞づ個嘉づーツ湘氾ッツつオツつスツつゥツづつ、ツつゥ\n    return 0;\n  }\n  //hash_map<int,int>::iterator it = hii.find(S);\n  unordered_map<int,int>::iterator it = hii.find(S);\n  if( it!=hii.end() ){ //ツ探ツ催オツ催渉づ敖づ個湘ウツ妥板つゥツづつ、ツつゥ\n    return it->second;\n  }\n\n  // ツプツδ個ゼツδ督トツつェツ置ツつッツづ按つ「ツ嘉づ個有ツ鳴ウ\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  hii.insert(make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    hii.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint x,y;\nint sx,sy;\nint N;\nint hx[25],hy[25];\nint fie[12][12];\nint dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit,bool done[12][12],int home){\n\tif(memo[pos].find(bit)!=memo[pos].end())return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\t\twhile(fie[cx][cy]!=-1){\n\t\t\t\tif(fie[cx][cy]==100)return 1;\n\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\twhile(fie[cx][cy]==-2 || fie[cx][cy]==100 || done[cx][cy]==true){\n\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t}\n\t\tif(fie[cx][cy]!=-1){\n\t\t\tdone[cx][cy]=true;\n\t\t\tans+=dfs(fie[cx][cy] , bit | (1<<fie[cx][cy]), done,home+1);\n\t\t\tdone[cx][cy]=false;\n\t\t}\n\t}\n\tif(home< 19)memo[pos][bit]=ans;\n\treturn ans;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tfor(int i=0;i<24;i++)memo[i].clear();\n\t\tfor(int i=0;i<12;i++){\n\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\tfie[j][i]=-1;\n\t\t\t}\n\t\t}\n\t\tN=0;\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfie[j][i]=-2;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tfie[j][i]=100;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==1){\n\t\t\t\t\tfie[j][i]=N;\n\t\t\t\t\thx[N]=j;\n\t\t\t\t\thy[N]=i;\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thx[N]=sx,hy[N]=sy;\n\t\tbool done[12][12];\n\t\tmemset(done,false,sizeof(done));\n\t\tcout << dfs(N,0,done,0) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nint f(int cur,int mask){\n\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\tint& res=M[cur<<24|mask];\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint px[24],py[24],kx,ky;\nint num[24][4] = {0};\n\nint H,W,N,ans;\nint field[12][12] = {0};\n\nint dx[] = {0,-1,0,1} , dy[] = {1,0,-1,0};\nbool done[12][12];\n\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit){\n\tif(memo[pos].find(bit) != memo[pos].end())return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\trep(d,4){\n\t\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\t\twhile( field[cy][cx] != -1){\n\t\t\t\tif(field[cy][cx] == 64)return 1;\n\t\t\t\tcy += dy[d] , cx += dx[d];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\trep(d,4){\n\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\twhile( field[cy][cx] == -2 || done[cy][cx] == 1 || field[cy][cx] == 64){\n\t\t\tcy += dy[d] , cx += dx[d];\n\t\t}\n\t\tif(field[cy][cx] != -1){\n\t\t\tdone[cy][cx] = 1;\n\t\t\tans += dfs(field[cy][cx],bit | (1<<field[cy][cx]) );\n\t\t\tdone[cy][cx] = 0;\n\t\t}\n\t}\n\treturn memo[pos][bit] = ans;\n}\n\nint main(){\n\twhile(cin >> W >> H ,W){\n\t\tN = ans = 0;\n\t\trep(i,24)rep(j,4)num[i][j] = -1;\n\t\trep(i,12)rep(j,12)field[i][j] = -1;\n\t\trep(i,H)rep(j,W){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tswitch(t){\n\t\t\tcase 0:\n\t\t\t\tfield[i+1][j+1] = -2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfield[i+1][j+1] = N;\n\t\t\t\tpx[N] = j+1, py[N] = i+1;\n\t\t\t\tN++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tkx = j+1 , ky = i+1;\n\t\t\t\tfield[i+1][j+1] = 64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpx[N] = kx , py[N] = ky;\n\t\trep(i,24)memo[i].clear();\n\t\tcout << dfs(N,0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef int ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstruct T{\n\tll first,second,third;\n\tbool operator<(const T& t)const{\n\t\treturn first!=t.first?(first<t.first):(second!=t.second?second<t.second:third<t.third);\n\t}\n};\nll w,h,g[10][10];\nll cx,cy;\ninline vector<P> doko(ll y,ll x){\n\tvector<P> v;\n\tfor(ll nx=x+1;nx<w;nx++){\n\t\tif(g[y][nx]==-1) break;\n\t\tif(g[y][nx]) v.push_back(P(y,nx));\n\t}\n\tfor(ll nx=x-1;nx>=0;nx--){\n\t\tif(g[y][nx]==-1) break;\n\t\tif(g[y][nx]) v.push_back(P(y,nx));\n\t}\n\tfor(ll ny=y+1;ny<h;ny++){\n\t\tif(g[ny][x]==-1) break;\n\t\tif(g[ny][x]) v.push_back(P(ny,x));\n\t}\n\tfor(ll ny=y-1;ny>=0;--ny){\n\t\tif(g[ny][x]==-1) break;\n\t\tif(g[ny][x]) v.push_back(P(ny,x));\n\t}\n\treturn v;\n}\nll n;\nll id[10][10];\nset<T> t;\nll dfs(ll y,ll x,ll s){\n\tif(t.count((T){y,x,s})) return 0;\n\tll res=0;\n\tvector<P> v=doko(y,x);\n\tif(s==(1<<n)-1){\n\t\tfor(ll i=0;i<v.size();i++){\n\t\t\tif(g[v[i].first][v[i].second]==2) return 1;\n\t\t}\n\t\tt.insert((T){y,x,s});\n\t\treturn 0;\n\t}\n\tif(s) g[y][x]=-1;\n\tfor(ll i=0;i<v.size();i++){\n\t\tif(g[v[i].first][v[i].second]==2) continue;\n\t\tres+=dfs(v[i].first,v[i].second,s|(1<<id[v[i].first][v[i].second]));\n\t}\n\tg[y][x]=1;\n\tif(res==0) t.insert((T){y,x,s});\n\treturn res;\n}\n\nint main()\n{while(1){\n\tscanf(\"%d%d\",&w,&h);\n\tn=0;\n\tt.clear();\n\tmemset(id,-1,sizeof(id));\n\tif(!w) return 0;\n\tfor(ll i=0;i<h;i++) for(ll j=0;j<w;j++){\n\t\tscanf(\"%d\",&g[i][j]);\n\t\tif(g[i][j]==2){\n\t\t\tcx=j,cy=i;\n\t\t}\n\t\telse if(g[i][j]){\n\t\t\tid[i][j]=n;\n\t\t\tn++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(cy,cx,0));\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <queue>\n#include <map>\n\nusing namespace std;\n \nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n \ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n \nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n \nint main() {\n  while (true) {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    int p[n][m];\n    for (int i : range(n)) for (int j : range(m)) cin >> p[i][j];\n    vector<pair<int, int>> house;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 1) house.emplace_back(i, j);\n    int s[n][m];\n    for (int i : range(n)) for (int j : range(m)) s[i][j] = -1;\n    for (int i : range(house.size())) s[house[i].first][house[i].second] = i;\n    queue<tuple<int, int, int>> que;\n    for (int i : range(n)) for (int j : range(m)) if (p[i][j] == 2) que.push(make_tuple(i, j, (1 << house.size()) - 1));\n    int res = 0;\n    map<tuple<int, int, int>, int> mp;\n    ++mp[que.front()];\n    while (!que.empty()) {\n      auto now = que.front(); que.pop();\n      int y = get<0>(now);\n      int x = get<1>(now);\n      int bit = get<2>(now);\n      //cerr << y << \" \" << x << \" \";\n      //for (int i : range(7)) cerr << (bit >> i & 1);\n      //cerr << \" \" << mp[now] << endl;\n      for (int i : range(4)) {\n        int yy = y + dy[i];\n        int xx = x + dx[i];\n        while (true) {\n          if (yy < 0 || n <= yy) break;\n          if (xx < 0 || m <= xx) break;\n          if (p[yy][xx] == 1 && (bit & 1 << s[yy][xx])) {\n            auto t = make_tuple(yy, xx, bit ^ 1 << s[yy][xx]);\n            if (!mp.count(t)) que.push(t);\n            mp[t] += mp[now];\n            break;\n          }\n          if (p[yy][xx] == 2 && bit == 0) res += mp[now]; \n          yy += dy[i];\n          xx += dx[i];\n        }\n      }\n      mp.erase(now);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tstatic int dp[1 << 23][23];\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[1 << dat[nx][ny]][dat[nx][ny]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp[i][j] == 0)continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[i | 1 << dat[nx][ny]][dat[nx][ny]] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\nusing namespace std;int mp[144],m,n,hs,ch;int dir[]={-12,-1,1,12};map<int,int>memo;int func(int p,int d,int u){while(1){int h=mp[p];if(h>=0){int s=0;mp[p]=-1;hs^=1<<h;if(u>12){for(int i=0;i<4;i++)s+=func(p+dir[i],dir[i],u-1);}else{int mi=h<<23|hs;map<int,int>::iterator it=memo.find(mi);if(it==memo.end()){for(int i=0;i<4;i++)s+=func(p+dir[i],dir[i],u-1);memo[mi]=s;}else{s=it->second;}}hs|=1<<h;mp[p]=h;return s;}if(h==-9)break;p+=d;}return 0;}int main(){int i,j,p,t;for(;scanf(\"%d%d\",&m,&n),m;memo.clear()){hs=0;for(i=0;i<144;i++)mp[i]=-9;for(i=1;i<=n;i++)for(j=1;j<=m;j++){p=i*12+j;scanf(\"%d\",&t);switch(t){case 2:ch=p;case 0:mp[p]=-1;break;case 1:memo[hs<<23]=0;mp[p]=hs++;break;}}for(i=0;i<4;){t=dir[i++];for(j=ch;mp[j+=t]!=-9;mp[j]>=0?memo[mp[j]<<23]=1:0);}j=hs;hs=(1<<hs)-1;t=0;for(i=-1;++i<4;)t+=func(ch+dir[i],dir[i],j);printf(\"%d\\n\",t);}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n, coun, ans, jud = 1, s;\nint town[11][11];\nP start;\nvoid dfs(int y, int x, int flag);\n\ninline int bit(int n, int i) {\n\treturn n | 1 << i;\n}\n\ninline bool bitj(int n, int i) {\n\tif (n & 1 << i )\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tans = 0;\n\t\tcoun = 1;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\tstart = make_pair(i, j);\n\t\t\t\t\ts = coun;\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = coun;\n\t\t\t\t\tcoun++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjud = 1;\n\t\tfor (i = 0; i < coun; i++) {\n\t\t\tjud *= 2;\n\t\t}\n\t\tdfs(start.first, start.second, 1 << s);\n\t\tcout << ans << endl;\n\t}\n}\nvoid dfs(int y, int x, int flag) {\n\t/*if (start == make_pair(y, x)) {\n\t\tif (flag == jud - 1) {\n\t\t\tans++;\n\t\t}\n\t\tif (flag) {\n\t\t\treturn;\n\t\t}\n\t}*/\n\tfor (i = x + 1; i <= m; i++) {\n\t\tif (town[y][i] && bitj(flag, town[y][i])) {\n\t\t\tdfs(y, i, bit(flag, town[y][i]));\n\t\t\tbreak;\n\t\t}\n\t\tif (town[y][i] == s&&bit(flag, town[y][i]) == jud - 2) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = x - 1; i > 0; i--) {\n\t\tif (town[y][i] && bitj(flag, town[y][i])) {\n\t\t\tdfs(y, i, bit(flag, town[y][i]));\n\t\t\tbreak;\n\t\t}\n\t\tif (town[y][i] == s&&bit(flag, town[y][i]) == jud - 2) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = y + 1; i <= n; i++) {\n\t\tif (town[i][x] && bitj(flag, town[i][x])) {\n\t\t\tdfs(i, x, bit(flag, town[i][x]));\n\t\t\tbreak;\n\t\t}\n\t\tif (town[i][x] == s&&bit(flag, town[i][x]) == jud - 2) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = y - 1; i > 0; i--) {\n\t\tif (town[i][x] && bitj(flag, town[i][x])) {\n\t\t\tdfs(i, x, bit(flag, town[i][x]));\n\t\t\tbreak;\n\t\t}\n\t\tif (town[i][x] == s&&bit(flag, town[i][x]) == jud - 2) {\n\t\t\tans++;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nmap<pair<int, int>, int> memo;\nvector<int> G[32];\nint hy[32], hx[32];\nint ey, ex;\nint cnt;\n\nint sgn(int x)\n{\n    return (x ? (x < 0 ? -1 : 1) : 0);\n}\n\nint mp[32][32];\nint getWay(int pos, int bit)\n{\n    if (bit == (1 << cnt) - 1){\n        return (hy[pos] == ey || hx[pos] == ex);\n    }\n    \n    if (__builtin_popcount(bit) <= 18 && memo.count(make_pair(pos, bit))){\n        return (memo[make_pair(pos, bit)]);\n    }\n    \n    int res = 0;\n    \n    for (int i = 0; i < G[pos].size(); i++){\n        int e = G[pos][i];\n        if (bit >> e & 1) continue;\n        int sy = hy[pos], sx = hx[pos];\n        bool ok = true;\n        for (; sy != hy[e] || sx != hx[e]; sy += sgn(hy[e] - sy), sx += sgn(hx[e] - sx)){\n            if (mp[sy][sx] == 1){\n                ok = false; break;\n            }\n        }\n        if (ok){\n            mp[hy[e]][hx[e]] = 0;\n            res += getWay(G[pos][i], bit | (1 << G[pos][i]));\n            mp[hy[e]][hx[e]] = 1;\n        }\n    }\n    \n    if (__builtin_popcount(bit) <= 18){\n        memo[make_pair(pos, bit)] = res;\n    }\n    return (res);\n}\n\nint dy[] = {1, 0, -1, 0}, dx[] = {0, 1, 0, -1};\nbool valid(int p)\n{\n    for (int d = 0; d < 4; d++){\n        int sy = hy[p], sx = hx[p];\n        while (0 <= sy + dy[d] && 0 <= sx + dx[d] && sy + dy[d] <= 10 && sx + dx[d] <= 10){\n            sy += dy[d]; sx += dx[d];\n            if (mp[sy][sx] == 1) break;\n            if (mp[sy][sx] == 2) return (true);\n        }\n    }\n    return (false);\n}\n\nint main()\n{\n    int w, h;\n    \n    while (scanf(\"%d %d\", &w, &h) && w){\n        \n        for (int i = 0; i < 32; i++) G[i].clear();\n        memset(mp, 0, sizeof(mp));\n        cnt = 0;\n        memo.clear();\n        \n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                scanf(\"%d\", &mp[i][j]);\n                if (mp[i][j] == 1){\n                    hy[cnt] = i;\n                    hx[cnt++] = j;\n                }\n                else if (mp[i][j] == 2){\n                    ey = i;\n                    ex = j;\n                }\n            }\n        }\n        \n        for (int i = 0; i < cnt; i++){\n            for (int j = i + 1; j < cnt; j++){\n                if (hy[i] == hy[j] || hx[i] == hx[j]){\n                    G[i].push_back(j);\n                    G[j].push_back(i);\n                }\n            }\n        }\n        \n        int ans = 0;\n        \n        for (int i = 0; i < cnt; i++){\n            if (valid(i)){\n                mp[hy[i]][hx[i]] = 0;\n                ans += getWay(i, 1 << i);\n                mp[hy[i]][hx[i]] = 1;\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\n/*\nconst int dx[] = {0,1,0,-1}; //u,r,d,l\nconst int dy[] = {-1,0,1,0};\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint kari[32];\nvector<pair<int,int> > v;\n\n#if DEB\nstack<int> st;\n#endif\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( s==a.s ){\n      if( x==a.x ) return y<a.y;\n      else         return x<a.x;\n    }else{\n      return s<a.s;\n    }\n  }\n  \n};\n\nmap<state,int> msi;\n\nint numofbits(int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nbool isnotgoal(int s){\n  return (((last&s)) == last);\n}\nint isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (kari[i]&s)==kari[i] ) return i;\n  }\n  return -1;\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int mask = (1<<home)-1;\n  if( s>0 && numofbits(~s&mask)>1 && isnot(s&~(1<<num[y][x]))!=-1 ){ //v[gªu¯È¢ÆÌL³\n#if DEB\n    printf(\"s:%d ,(%d,%d)  __%d  ___isnot:%d\\n\",s,x,y,s&~num[y][x],isnot(s&~num[y][x]));\n    stack<int> tmp = st;\n    while( !tmp.empty() ){\n      printf(\"%d,\",tmp.top());\n      tmp.pop();\n    }\n    puts(\"\\n\");\n#endif\n    return msi[state(x,y,s)] = 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\n#if DEB\n\tst.pop();\n#endif\n\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    v.clear();\n    memset(num,-1,sizeof(num));\n    memset(kari,0,sizeof(kari));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t  v.pb(mp(j,i));\n\t}\n      }\n    }\n\n    // other homes\n    rep(i,v.size()){\n      rep(k,4){\n\tfor(int j=1; j<20; j++){\n\t  int tx = v[i].first + dx[k]*j;\n\t  int ty = v[i].second + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    kari[i] |= (1<<num[ty][tx]);\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n#if DEB\n    printf(\"sz:%d\\n\",v.size());\n    printf(\"last:%d\\n\",last);\n    rep(i,v.size()){\n      printf(\"home:%d  , %d\\n\",i,kari[i]);\n    }\n#endif\n    \n    \n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint h,w,t,ans,gx,gy,map[10][10],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nvoid DFS(int x,int y,int len){for(int i=0;i<4;i++){int xx=x+dx[i],yy=y+dy[i];while(true){if(xx>=0&&xx<w&&yy>=0&&yy<h){if(map[yy][xx]==1){map[yy][xx]=0;DFS(xx,yy,len+1);map[yy][xx]=1;break;}if(map[yy][xx]==2&&len==t){ans++;break;}}else break;xx+=dx[i],yy+=dy[i];}}}\nint main(){while(true){cin>>w>>h;if(w==0&&h==0)break;t=0;for(int i=0;i<h;i++){for(int j=0;j<w;j++){cin>>map[i][j];if(map[i][j]==2)gy=i,gx=j;if(map[i][j]==1)t++;}}ans=0;DFS(gx,gy,0);cout<<ans<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstd::vector<int> X[10], Y[10];\nint W, H;\nint hx[24], hy[24];\nint cx, cy, hn;\n\nbool canMove(int u, int v, int state){\n    if(hx[u] != hx[v] && hy[u] != hy[v]){return false;}\n    if(hx[u] == hx[v]){\n        if(hy[u] > hy[v]){std::swap(u, v);}\n        for(auto i : Y[hx[u]]){\n            if(state >> i & 1 && hy[u] < hy[i] && hy[i] < hy[v]){return false;}\n        }\n    }else{\n        if(hx[u] > hx[v]){std::swap(u, v);}\n        for(auto i : X[hy[u]]){\n            if(state >> i & 1 && hx[u] < hx[i] && hx[i] < hx[v]){return false;}\n        }\n    }\n    return true;\n}\n\nint bitCount(int n){\n    n = (n & 0x55555555) + (n >> 1 & 0x55555555);\n    n = (n & 0x33333333) + (n >> 2 & 0x33333333);\n    n = (n & 0x0f0f0f0f) + (n >> 4 & 0x0f0f0f0f);\n    n = (n & 0x00ff00ff) + (n >> 8 & 0x00ff00ff);\n    return n = (n & 0x0000ffff) + (n >> 16 & 0x0000ffff);\n}\n\nint main(){\n    while(std::cin >> W >> H, W){\n        hn = 0;\n        REP(i, 10){\n            X[i].clear(); Y[i].clear();\n        }\n        REP(i, H){\n            REP(j, W){\n                int n;\n                std::cin >> n;\n\n                if(n == 1){\n                    hx[hn] = j; hy[hn] = i;\n                    // printf(\"(%d, %d)\\n\", j, i);\n                    X[i].push_back(hn);\n                    Y[j].push_back(hn);\n                    hn++;\n                }else if(n == 2){\n                    // printf(\"church: (%d, %d)\\n\", j, i);\n                    cx = j; cy = i;\n                }\n            }\n        }\n        hx[hn] = cx; hy[hn] = cy;\n\n        int res = 0;\n        std::queue<int> q;\n        q.push(hn);\n\n        while(!q.empty()){\n            int s = q.front(); q.pop();\n            int v = s & 0x1f, state = s >> 5, n = bitCount(state);\n\n            if(n == hn){res += canMove(v, hn, state); continue;}\n\n            for(auto u : X[hy[v]]){\n                if(state >> u & 1){continue;}\n                if(!canMove(u, v, state)){continue;}\n                q.push(u + ((state | (1 << u)) << 5));\n            }\n\n            for(auto u : Y[hx[v]]){\n                // printf(\"y: %d, %d, %d, (%d, %d), (%d, %d)\\n\", u, v, canMove(u, v), hx[u], hy[u], hx[v], hy[v]);\n                if(state >> u & 1){continue;}\n                if(!canMove(u, v, state)){continue;}\n                q.push(u + ((state | (1 << u)) << 5));\n            } \n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n//#include <ext/hash_map>\n#include <tr1/unordered_map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing namespace tr1;\n//using namespace __gnu_cxx;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n//hash_map<int,int> hii;\nunordered_map<int,int> hii;\n\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //ツ静「ツ妥篠づ可姪淞づェツづゥ\n    return 1;\n  }\n  if( isnotgoal(s) ){ //ツ仰ウツ嘉ッツづ可姪淞づゥツつスツづ淞づ個嘉づーツ湘氾ッツつオツつスツつゥツづつ、ツつゥ\n    return 0;\n  }\n  //hash_map<int,int>::iterator it = hii.find(S);\n  unordered_map<int,int>::iterator it = hii.find(S);\n  if( it!=hii.end() && it->first==S ){ //ツ探ツ催オツ催渉づ敖づ個湘ウツ妥板つゥツづつ、ツつゥ\n    return it->second;\n  }\n\n  // ツプツδ個ゼツδ督トツつェツ置ツつッツづ按つ「ツ嘉づ個有ツ鳴ウ\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  hii.insert(make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    hii.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define fr first\n#define sc second\n#define MAXDIR 4\n\n//vector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(char si, char sj, char cnt, int vis):ni(si),nj(sj),cnt(cnt),vis(vis){}\n};\n\n//void bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nstruct Queue{\n  int p;\n  state *V;\n  Queue():p(0){V=new state[1<<20];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){\n    V[p++]=t;\n  }\n  const state & front(){\n    return V[p-1];\n  }\n  void pop(){--p;}\n  bool empty(){\n    return p==0;\n  }\n};\n\nvoid bfs(const Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  int ni,nj;\n  int housenum=0;\n  int chi=charch.fr;int chj=charch.sc;\n  \n  for(int k = 0; k < MAXDIR; ++k){\n    housenum += M[chi][chj].linkmax[k];\n  }\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    ni = st_now.ni;\n    nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }else{\n\n      int left = housenum;\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n      \n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  int mask=1<<houseId[next.fr][next.sc];\n\t  if( !(st_now.vis&mask) ){\n\t    qs.push( state(next.fr,next.sc,st_now.cnt + 1,st_now.vis|mask) );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;\n    scanf(\"%d%d\", &W, &H);\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tscanf(\"%d\", &iM[i][j]);\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc,0,0);\n    bfs(M,init,nhouse,ans);\n    printf(\"%d\\n\", ans);\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nbool hs[10][10];\nbool used[10][10];\nint cx,cy;\nint nh;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\nint dfs(int x,int y,int f){\n\tif(f==nh){\n\t\tif(x==cx||y==cy)return 1;\n\t\treturn 0;\n\t}\n\tint i,j;\n\tint res=0;\n\tfor(i=0;i<4;i++){\n\t\tfor(j=1;j<10;j++){\n\t\t\tint nx=x+j*dx[i];\n\t\t\tint ny=y+j*dy[i];\n\t\t\tif(nx<0||nx>=h||ny<0||ny>=w)break;\n\t\t\tif(hs[nx][ny]){\n\t\t\t\tif(!used[nx][ny]){\n\t\t\t\t\tused[nx][ny]=true;\n\t\t\t\t\tres+=dfs(nx,ny,f+1);\n\t\t\t\t\tused[nx][ny]=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(1){\n\tint i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tif(w==0)return 0;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\ths[i][j]=false;\n\t\tused[i][j]=false;\n\t}\n\tnh=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ths[i][j]=true;\n\t\t\t\tused[i][j]=false;\n\t\t\t\tnh++;\n\t\t\t}\n\t\t\tif(c=='2'){cx=i;cy=j;}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(cx,cy,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//25\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint m,n;\nint g[10][10];\nint cx,cy;\nbool ra[10][10];\n\nint dfs(int x,int y,int r){\n  if(r==0){\n    return x==cx||y==cy;\n  }else{\n    int a=0;\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      int nx=x,ny=y;\n      for(;;){\n\tnx+=d[i];\n\tny+=d[i+1];\n\tif(nx<0||m<=nx||ny<0||n<=ny)break;\n\tif(g[ny][nx]==1){\n\t  g[ny][nx]=0;\n\t  a+=dfs(nx,ny,r-1);\n\t  g[ny][nx]=1;\n\t  break;\n\t}\n      }\n    }\n    return a;\n  }\n}\n\nint main(){\n  while(cin>>m>>n,m|n){\n    int nh=0;\n    int x,y;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tcin>>g[i][j];\n\tnh+=g[i][j]==1;\n\tif(g[i][j]==2){\n\t  cx=x=j;\n\t  cy=y=i;\n\t}\n      }\n    }\n    fill(ra[0],ra[n],false);\n    cout<<dfs(x,y,nh)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint M, N;\nint map[20][20];\nint sx, sy;\nint T;\n\nbool v[20][20];\n\nint solve(int x, int y, int c) {\n  int ret = 0;\n\n  if (map[x][y] == 2 && c > 1) {\n    if (c == T+2) return 1;\n    else          return 0;\n  }\n  if (c > 1) v[x][y] = true;\n  for (int ty=y-1; ty>=0; ty--) {\n    if (v[x][ty]) break;\n    if (map[x][ty]) ret += solve(x, ty, c+1);\n  }\n  for (int ty=y+1; ty<N; ty++) {\n    if (v[x][ty]) break;\n    if (map[x][ty]) ret += solve(x, ty, c+1);\n  }\n  for (int tx=x-1; tx>=0; tx--) {\n    if (v[tx][y]) break;\n    if (map[tx][y]) ret += solve(tx, y, c+1);\n  }\n  for (int tx=x+1; tx<M; tx++) {\n    if (v[tx][y]) break;\n    if (map[tx][y]) ret += solve(tx, y, c+1);\n  }\n  v[x][y] = false;\n  return ret;\n}\n\nint main() {\n  cin >> M >> N;\n  for (int y=0; y<N; y++) {\n    for (int x=0; x<M; x++) {\n      cin >> map[x][y];\n      if (map[x][y] == 1) T++;\n      if (map[x][y] == 2) sx = x, sy = y;\n    }\n  }\n\n  cout << solve(sx, sy, 1) << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<P, int>dp;\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[{1 << dat[nx][ny], dat[nx][ny]}] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[{i, j}];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h,int k){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny],k-1);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) < 15) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0,c) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint vec[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint tab[12][12];\nint wx,wy;\nvoid solve(int nx,int ny,int rem){\n    for(int v=0;v<4;v++){\n        int nowx=nx,nowy=ny;\nLA:\n            nowx+=vec[v][0],nowy+=vec[v][1];\n            if(!(0<=nowx&&nowx<wx&&0<=nowy&&nowy<wy)) goto LB;\n            if(tab[nowx][nowy]==2&&rem==0)ans++;\n            if(tab[nowx][nowy]==1){\n                tab[nowx][nowy]=-1;\n                solve(nowx,nowy,wx,wy,rem-1);\n                tab[nowx][nowy]=1;\n                goto LB;\n            }\n            goto LA;\nLB:         \n        }\n    }\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,n,m,homec);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\n\tint ans=0;\n\trep(k,4) rep(a,deg[id][k]) {\n\t\tint next_id=adj[id][k][a];\n\t\tif((picked&(1<<next_id))==0){\n\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(dp[id].size()<1000) dp[id][picked]=ans;\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <unordered_map>\n\ntypedef std::pair<int,int> P;\n\ntemplate <class T>\ninline void hash_combine(std::size_t & seed, const T & v)\n{\n  std::hash<T> hasher;\n  seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n\nnamespace std\n{\n  template<typename S, typename T> struct hash<pair<S, T>>\n  {\n    inline size_t operator()(const pair<S, T> & v) const\n    {\n      size_t seed = 0;\n      ::hash_combine(seed, v.first);\n      ::hash_combine(seed, v.second);\n      return seed;\n    }\n  };\n}\n\nint M, N; // X, Y\nint hashX[10][10], hashY[10][10];\nint xs[24], ys[24], n;\nstd::unordered_map<P, int> dp;\n\nbool can(int pos, int pos2, int state){\n    if(xs[pos] != xs[pos2] && ys[pos] != ys[pos2]){return false;}\n\n    if(xs[pos] == xs[pos2]){\n        if(ys[pos] > ys[pos2]){std::swap(pos, pos2);}\n\n        return (state & (hashY[ys[pos2]-1][xs[pos]] ^ hashY[ys[pos]][xs[pos]])) == 0;\n        // for(int i=0;i<n;i++){\n        //     if(i == pos || i == pos2){continue;}\n        //     if((state >> i & 1) &&\n        //        xs[i] == xs[pos] && \n        //        ys[pos] < ys[i] && ys[i] < ys[pos2]){\n        //         // printf(\"1: %d\\n\", i);\n        //         return false;\n        //     }\n        // }\n    }\n    \n    if(xs[pos] > xs[pos2]){std::swap(pos, pos2);}\n\n    return (state & (hashX[ys[pos]][xs[pos2]-1] ^ hashX[ys[pos]][xs[pos]])) == 0;\n    // for(int i=0;i<n;i++){\n    //     if(i == pos || i == pos2){continue;}\n    //     if((state >> i & 1) &&\n    //        ys[i] == ys[pos] &&\n    //        xs[pos] < xs[i] && xs[i] < xs[pos2]){\n    //         // printf(\"2: %d\\n\", i);\n    //         return false;\n    //     }\n        // }\n}\n\nint rec(int pos, int state){\n    P p = std::make_pair(pos, state);\n    if(dp.count(p) > 0){return dp[p];}\n    \n    int count = __builtin_popcount(state);\n    if(count == n-1){\n        return can(pos, 0, state);\n    }\n\n    int res = 0;\n    for(int i=1;i<n;i++){\n        if(!(state >> i & 1) && can(pos, i, state)){\n            // printf(\"%d -> %d\\n\", pos, i);\n            res += rec(i, state | (1 << i));\n        }\n    }\n    // printf(\"ended...\\n\");\n\n    return dp[p] = res;\n}\n\nint main(){\n    while(scanf(\"%d %d\", &M, &N), M){\n        n = 1;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                int v;\n                scanf(\"%d\", &v);\n\n                if(v == 1){\n                    xs[n] = j;\n                    ys[n] = i;\n                    hashX[i][j] = 1 << n;\n                    hashY[i][j] = 1 << n++;\n                }\n                else if(v == 2){\n                    xs[0] = j;\n                    ys[0] = i;\n                    hashX[i][j] = 1;\n                    hashY[i][j] = 1;\n                }\n            }\n        }\n\n        for(int i=0;i<N;i++){\n            for(int j=1;j<M;j++){\n                hashX[i][j] |= hashX[i][j-1];\n            }\n        }\n\n        for(int i=0;i<M;i++){\n            for(int j=1;j<N;j++){\n                hashY[j][i] |= hashY[j-1][i];\n            }\n        }\n\n        // for(int i=0;i<n;i++){printf(\"%d, %d\\n\", xs[i], ys[i]);}\n\n        //printf(\"%d\\n\", can(0, 3, 1 << 5));\n        //printf(\"%d\\n\", hashY[1][2] ^ hashY[0][2]);\n        printf(\"%d\\n\", rec(0, 0));\n\n        dp.clear();\n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                hashX[i][j] = 0;\n                hashY[i][j] = 0;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\nconst int dx[]={1,-1,0,0};\nconst int dy[]={0,0,1,-1};\n\n\nint N,M;\nint temp[110][110];\nint feld[110][110];\nint cnt;\npii last;\nint ans;\n\nvoid dfs(int x,int y,int sum,int pdx,int pdy,bool down){\n    if(x<0||x>=N||y<0||y>=M){\n        return ;\n    }\n    if(feld[y][x]==1&&down)feld[y][x]=-1;\n    if(y==last.FI&&x==last.SE&&sum==cnt){\n        ans++;\n        return ;\n    }\n    if(feld[y][x]!=-1){\n        if(feld[y+pdy][x+pdx]==-1){\n            if(feld[y][x]==-1)feld[y][x]=1;\n            return;\n        }\n        else if(feld[y+pdy][x+pdx]==1){\n            dfs(x+pdx,y+pdy,sum+1,pdx,pdy,true);\n            dfs(x+pdx,y+pdy,sum,pdx,pdy,false);\n        }\n        else dfs(x+pdx,y+pdy,sum,pdx,pdy,false);\n    }\n    else if(feld[y][x]==-1){\n        if(down){\n            for(int i=0;i<4;++i){\n                int nx=x+dx[i];\n                int ny=y+dy[i];\n                if(feld[ny][nx]==-1)continue;\n                if(feld[ny][nx]==1){\n                    dfs(nx,ny,sum+1,dx[i],dy[i],true);\n                    dfs(nx,ny,sum,dx[i],dy[i],false);\n                }\n                else{\n                    dfs(nx,ny,sum,dx[i],dy[i],false);\n                }\n            }\n        }\n        else {\n            if(feld[y+pdy][x+pdx]==-1){\n                if(feld[y][x]==-1)feld[y][x]=1;\n                return;\n            }\n            else if(feld[y+pdy][x+pdx]==1){\n                dfs(x+pdx,y+pdy,sum+1,pdx,pdy,true);\n                dfs(x+pdx,y+pdy,sum,pdx,pdy,false);\n                return ;\n            }\n            else dfs(x+pdx,y+pdy,sum,pdx,pdy,false);\n            return ;\n        }\n    }\n    if(feld[y][x]==-1)feld[y][x]=1;\n    return ;\n}\n\n\nsigned main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(feld,0,sizeof(feld));\n        for(int i=0;i<M;++i){\n            for(int j=0;j<N;++j){\n                cin>>feld[i][j];\n                if(feld[i][j]==2){\n                    last.FI=i;\n                    last.SE=j;\n                }\n                else if(feld[i][j]!=0)cnt++;\n            }\n        }\n        for(int i=0;i<4;++i)dfs(last.SE,last.FI,0,dx[i],dy[i],false);\n        cout<<ans<<endl;\n        ans=0;\n        cnt=0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n;\nint dp[25][1024 * 1024 * 16], town[11][11];\nP p[25];\nvoid bfs(int now, int flag);\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tint s, count = 1;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\ts = count;\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = count;\n\t\t\t\t\tp[count] = make_pair(i, j);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (i = 1; i <= n;i++){\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcout << town[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tbfs(s, 0);\n\t\tj = 1;\n\t\tfor (i = 0; i < count - 1; i++)\n\t\t\tj = j * 2;\n\t\tcout << dp[s][j - 1] << endl;\n\t}\n}\nvoid bfs(int start, int flag) {\n\tdp[start][flag] = 1;\n\tvector<P> que;\n\tque.push_back(make_pair(flag, start));\n\twhile (!que.empty()) {\n\t\t//cout << que.size()<<' ';\n\t\tque.erase(unique(que.begin(), que.end()), que.end());\n\t\tsort(que.begin(), que.end());\n\t\tP pp;\n\t\tpp = que[0];\n\t\tstart = pp.second; flag = pp.first;\n\t\t//cout << start << ' ' <<  static_cast<std::bitset<24> >(flag)  << endl;\n\t\tque.erase(que.begin());\n\t\tfor (j = p[start].second; j <= m; j++) {\n\t\t\tif (town[p[start].first][j]&&j!=p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]-1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t//\tcout << 1 << endl;\n\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].second; j >= 1; j--) {\n\t\t\tif (town[p[start].first][j]&&j != p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]- 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t//\tcout << 2 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j <= n; j++) {\n\t\t\tif (town[j][p[start].second]&& j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t//\tcout << 3 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j >= 1; j--) {\n\t\t\tif (town[j][p[start].second] && j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t\t//cout << 4 << endl;\n\t\t\t\t\t//cout << j << ' ' << flag2 << ' ' << p[start].first << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* こんなウンコードで通ったらしぇか行く */\n\n#include <stdio.h>\n#include <string.h>\n\n#define EMPTY 0\n#define YET_DELIVERED 1\n#define CHURCH 2\n#define ALREADY_DELIVERED 3\n\n#define CHURCH_INDEX 30\n\nenum direction {SOUTH, EAST, WEST, NORTH};\n\ntypedef struct house {\n    struct house *next[4];\n    int index;\n} House;\n\nint house_bits;\nHouse map[10][10];\n\nint rec(House *house, int depth) {\n    int i;\n    int sum = 0;\n    House *now_house;\n\n    for (i=0; i<4; i++) {\n        now_house = house->next[i];\n\n        while (now_house != NULL) {\n            if (now_house->index == CHURCH_INDEX) {\n                if (depth == house_bits) return 1;\n            } else {\n                int bit;\n                int cond;\n\n                bit = 1 << now_house->index;\n                cond = ((bit & depth) == 0);\n  \n                if (cond) {\n                    sum += rec(now_house, bit | depth);\n                    break;\n                }\n            }\n\n            now_house = now_house->next[i];\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    while (1) {\n        int i;\n        int m, n;\n        int church_x;\n        int church_y;\n        int now_ind;\n        House *x_prevs[10];\n    \n        scanf(\"%d %d\", &m, &n);\n        if ( (m & n) == 0) return 0;\n           \n        now_ind = 0;\n        memset(map, 0, sizeof(map));\n        memset(x_prevs, 0, sizeof(x_prevs));\n\n        for (i=0; i<n; i++) {\n            int j;\n            House *y_prev = NULL;\n\n            for (j=0; j<m; j++) {\n                int p;\n    \n                scanf(\"%d\", &p);\n\n                if (p == CHURCH) {\n                    church_x = j;\n                    church_y = i;\n\n                    map[i][j].index = CHURCH_INDEX;\n\n                    map[i][j].next[NORTH] = x_prevs[j];\n                    map[i][j].next[WEST] = y_prev;\n\n                    if (x_prevs[j]) {\n                        x_prevs[j]->next[SOUTH] = &map[i][j];\n                    }\n\n                    if (y_prev) {\n                        y_prev->next[EAST] = &map[i][j];\n                    }\n\n                    x_prevs[j] = &map[i][j];\n                    y_prev = &map[i][j];\n                } else if (p == YET_DELIVERED) {\n                    map[i][j].index = now_ind;\n\n                    map[i][j].next[NORTH] = x_prevs[j];\n                    map[i][j].next[WEST] = y_prev;\n\n                    if (x_prevs[j]) {\n                        x_prevs[j]->next[SOUTH] = &map[i][j];\n                    }\n\n                    if (y_prev) {\n                        y_prev->next[EAST] = &map[i][j];\n                    }\n\n                    x_prevs[j] = &map[i][j];\n                    y_prev = &map[i][j];\n\n                    ++now_ind;\n                }\n            }\n\n            if (y_prev) {\n                y_prev->next[EAST] = NULL;\n            }\n        }\n\n        for (i=0; i<10; i++) {\n            if (x_prevs[i]) {\n                x_prevs[i]->next[SOUTH] = NULL;\n            }\n        }\n\n        house_bits = (1 << now_ind)-1;\n        printf(\"%d\\n\", rec(&map[church_y][church_x], 0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 12 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nbool hs[10][10];\nbool used[10][10];\nint cx,cy;\nint ans;\nint nh;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\nvoid dfs(int x,int y,int f){\n\tif(f==nh&&(x==cx||y==cy)){\n\t\tans++;\n\t\treturn;\n\t}\n\tint i,j;\n\tfor(i=0;i<4;i++){\n\t\tfor(j=1;j<9;j++){\n\t\t\tint nx=x+j*dx[i];\n\t\t\tint ny=y+j*dy[i];\n\t\t\tif(nx<0||nx>=h||ny<0||ny>=w)break;\n\t\t\tif(hs[nx][ny]){\n\t\t\t\tif(!used[nx][ny]){\n\t\t\t\t\tused[nx][ny]=true;\n\t\t\t\t\tdfs(nx,ny,f+1);\n\t\t\t\t\tused[nx][ny]=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\tint i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tif(w==0)return 0;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\ths[i][j]=false;\n\t\tused[i][j]=false;\n\t}\n\tnh=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ths[i][j]=true;\n\t\t\t\tused[i][j]=false;\n\t\t\t\tnh++;\n\t\t\t}\n\t\t\tif(c=='2'){cx=i;cy=j;}\n\t\t}\n\t}\n\tans=0;\n\tdfs(cx,cy,0);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nmap<int,int> memo[24];\n\nvoid MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\nint DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[house_num][state]!=-1) return memo[house_num][state];\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(G[house_num][i].S_-1))&1)!=1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(memo[house_num][state]==0&&house_num!=0&&((state>>(G[house_num][i].S_-1))&1)!=1){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\tif(memo[house_num][state]==0) memo[house_num][state]=result2+1;\n\t//cout << memo[house_num][state] << ' ' << result2 << endl;\n\treturn memo[house_num][state]+result1-1;\n}\n\nlli Solve(){\n\thouses.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tREP(i,0,cnt) memo[i].clear();\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\t// if(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tint ans=0;\n\trep(k,4){\n\t\trep(a,deg[id][k]){\n\t\t\tint next_id=adj[id][k][a];\n\t\t\tif((picked&(1<<next_id))==0){\n\t\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n\t// return dp[id][picked]=ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nint memo[1 << 24][23];\nstruct aa {\n\tint x;\n\tint y;\n\tint time;\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nvector<int>getdis(const int now, const vector<vector<int>>&field, const vector<pair<int, int>>&houses) {\n\tconst int sx = houses[now].first;\n\tconst int sy = houses[now].second;\n\t\n\tvector<vector<int>>cans(field.size(), vector<int>(field[0].size()));\n\tcans[sy][sx] = true;\n\tfor (int way = 0; way < 4; ++way) {\n\t\tint nx(sx);\n\t\tint ny(sy);\n\t\twhile (1) {\n\t\t\tnx += dx[way];\n\t\t\tny += dy[way];\n\t\t\tif (field[ny][nx]&&field[ny][nx]!=2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcans[ny][nx] = true;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>times;\n\tfor (auto h : houses) {\n\t\ttimes.emplace_back(cans[h.second][h.first]);\n\t}\n\treturn times;\n}\nint getans(const int now, bitset<23>&used, vector<vector<int>>&field, const vector<pair<int, int>>&houses) {\n\tif (memo[used.to_ulong()][now] != -1)return memo[used.to_ulong()][now];\n\tif (used.count() == houses.size() - 1) {\n\t\tauto vs(getdis(now, field, houses));\n\t\treturn memo[used.to_ulong()][now] = vs.back();\n\t}\n\telse {\n\t\tint sum = 0;\n\t\tauto vs(getdis(now, field, houses));\n\t\tfor (int i = 0; i < houses.size()-1; ++i) {\n\t\t\tif (vs[i]&&!used[i]) {\n\t\t\t\tused[i] = true;\n\t\t\t\tfield[houses[i].second][houses[i].first] = true;\n\t\t\t\tconst int atime = getans(i, used, field, houses);\n\t\t\t\tsum += atime;\n\t\t\t\tfield[houses[i].second][houses[i].first] = false;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t\treturn memo[used.to_ulong()][now] = sum;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < (1 << 24); ++i) {\n\t\t\tfor (int j = 0; j < 23; ++j) {\n\t\t\t\tmemo[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint M, N; cin >> M >> N;\n\t\tvector<vector<int>>field(N + 2, vector<int>(M + 2,3));\n\t\tvector<pair<int, int>>houses;\n\t\tpair<int, int>rit;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tcin >> field[i + 1][j + 1];\n\t\t\t\tif (field[i+1][j + 1] == 1) {\n\t\t\t\t\tfield[i + 1][j + 1] = 0;\n\t\t\t\t\thouses.emplace_back(j+1, i+1);\n\t\t\t\t}\n\t\t\t\telse if (field[i + 1][j + 1] == 2) {\n\t\t\t\t\trit = make_pair(j+1, i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbitset<23>used(0);\n\t\thouses.emplace_back(rit);\n\t\tint ans = getans(houses.size() - 1, used, field, houses);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 3004\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint sum = 0, ans = 0, ky, kx, a[12][12], f[12][12];\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\n\nvoid dfs(int y, int x, int cnt){\n\tfor(int i = 0;i < 4;i++){\n\t\tint yy = y;\n\t\tint xx = x;\n\t\twhile(1){\n\t\t\tyy += dy[i];\n\t\t\txx += dx[i];\n\t\t\tif(a[yy][xx] == -1)break;\n\t\t\tif(a[yy][xx] == 1 && f[yy][xx] == 0){\n\t\t\t\tf[yy][xx] = 1;\n\t\t\t\tdfs(yy, xx, cnt+1);\n\t\t\t\tf[yy][xx] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(a[yy][xx] == 2 && cnt == sum){\n\t\t\t\tans++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(1){\n\t\tscanf(\"%d%d\",&w, &h);\n\t\tif(w == 0)break;\n\t\tfill((int*)a, (int*)(a+12), -1);\n\t\tfill((int*)f, (int*)(f+12), 0);\n\t\tsum = ans = 0;\n\t\trrep(i,h)rrep(j,w){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tif(a[i][j] == 2){ky = i;kx = j;}\n\t\t\tif(a[i][j] == 1)sum++;\n\t\t}\n\t\t\n\t\tdfs(ky, kx, 0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 19;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s, int &order)\n{\n\torder++;\n\tint noBits = CountBit(s);\n\tif (x == sx && y == sy && noBits == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (noBits < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0, cnt = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, noBits))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]), cnt);\n\t}\n\torder += cnt;\n\tif (noBits < MAX && !(noBits >= 14 && cnt <= 50)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0, cnt));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nint memo[24][1<<24];\n\nvoid MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\nint DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << endl;\n\tif(((state|1)&((1<<houses.size())-1))==((1<<houses.size())-1)&&house_num==0) return 1;\n\tif(memo[house_num][state]!=-1) return memo[house_num][state];\n\tint result=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>G[house_num][i].S_)&1)!=1) result+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(((state>>G[house_num][i].S_)&1)!=1){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<house_num));\n\t\t}\n\t}\n\treturn memo[house_num][state]=result;\n}\n\nlli Solve(){\n\thouses.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==1) houses[MP(y,x)]=0;\n\t}\n\tREP(i,0,cnt) REP(j,0,1<<cnt) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint n,m;\n\nint kx,ky;\nint field[11][11];\nint home;\nconst int INF=1000000000;\n\nint cnt=0;\n\nvoid dfs(int x,int y){\n\tif(home==0){\n\t\tif(x==kx||y==ky){\n\t\t\tcnt++;\n\t\t\treturn;\n\t\t}\n\t}\n\telse{\n\t\tfor(int i = y-1; i >= 0; i--){\n\t\t\tif(field[i][x]==1){\n\t\t\t\tfield[i][x]=0;\n\t\t\t\thome--;\n\t\t\t\tdfs(x,i);\n\t\t\t\thome++;\n\t\t\t\tfield[i][x]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = y+1; i < m; i++){\n\t\t\tif(field[i][x]==1){\n\t\t\t\tfield[i][x]=0;\n\t\t\t\thome--;\n\t\t\t\tdfs(x,i);\n\t\t\t\thome++;\n\t\t\t\tfield[i][x]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = x-1; i >= 0; i--){\n\t\t\tif(field[y][i]==1){\n\t\t\t\tfield[y][i]=0;\n\t\t\t\thome--;\n\t\t\t\tdfs(i,y);\n\t\t\t\thome++;\n\t\t\t\tfield[y][i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = x+1; i < m; i++){\n\t\t\tif(field[y][i]==1){\n\t\t\t\tfield[y][i]=0;\n\t\t\t\thome--;\n\t\t\t\tdfs(i,y);\n\t\t\t\thome++;\n\t\t\t\tfield[y][i]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nint main(){\n\n\twhile(cin>>m>>n&&!(n==0&&m==0)){\n\t\thome=0;\n\t\tcnt=0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]==2){\n\t\t\t\t\tkx=j;\n\t\t\t\t\tky=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]==1)\n\t\t\t\t\thome++;\n\t\t\t}\n\t\t}\n\t\tdfs(kx,ky);\n\t\tcout<<cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\n\nclass Node\n{\n\tpublic:\n\tvector<int> to,mask;\n};\n\nint main()\n{\n\tint W,H;\n\twhile(cin>>W>>H,  W||H)\n\t{\n\t\tint  idx=1;\n\t\tint  f[10][10];\n\t\tNode node[24];\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\t{\n\t\t\tint t; cin>>t;\n\t\t\tif(t==0)\n\t\t\t{\n\t\t\t\tf[x][y]= -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(t==1) f[x][y]=idx++;\n\t\t\tif(t==2) f[x][y]=0;\n\n\t\t\tint my=f[x][y];\n\n\t\t\tfor(int i=0; i<2; i++)\n\t\t\t{\n\t\t\t\tint mask=0;\n\t\t\t\tfor(int d=1; 0<=x-i*d && 0<=y-(1-i)*d; d++)\n\t\t\t\t{\n\t\t\t\t\tint to = f[x-i*d][y-(1-i)*d];\n\t\t\t\t\tif(to<0) continue;\n\n\t\t\t\t\tnode[my].to.push_back(to);\n\t\t\t\t\tnode[to].to.push_back(my);\n\t\t\t\t\tnode[my].mask.push_back(mask);\n\t\t\t\t\tnode[to].mask.push_back(mask);\n\t\t\t\t\tif(to) mask |= (1<<to);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\n\t\tqueue<pair<int,int> > q;\n\t\tq.push(make_pair(0,0));\n\t\tmap<int,int> v[24];\n\t\tv[0][0]=1;\n\n\t\tint ans=0;\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tpair<int,int> t=q.front(); q.pop();\n\n\t\t\tfor(int i=0; i<node[t.first].to.size(); i++)\n\t\t\t{\n\t\t\t\tif(t.second & (1<<node[t.first].to[i])) continue;\n\t\t\t\tif(t.second & node[t.first].mask[i]   ) continue;\n\n\t\t\t\tint to = node[t.first].to[i];\n\t\t\t\tif(to==0)\n\t\t\t\t{\n\t\t\t\t\tif(t.second==(1<<idx)-2) ans+=v[t.first][t.second];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif(v[to].insert(make_pair(t.second|(1<<to), v[t.first][t.second])).second)\n\t\t\t\t{\n\t\t\t\t\tq.push( make_pair(to, t.second|(1<<to)) );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tv[to][t.second|(1<<to)] += v[t.first][t.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint n,m,x,y,ie,bit,l;\nint mp[10][10];\nmap<pair<int,int>,int> memo;\nmap<pair<int,int>,int> num;\nint dfs(int I, int J){\n    if(l != -1 && num.count(MP(bit,l)) != 0 return memo[MP(bit,l)];\n\n    if(bit == ie){\n        if(I != x && J != y) return 0;\n        int ans = 0;\n        for(int i=I-1; i>=0; i--){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int i=I+1; i<n; i++){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int j=J-1; j>=0; j--){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        for(int j=J+1; j<m; j++){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        return memo[MP(bit,l)] = ans;\n    }\n\n    int ans = 0;\n    int L = l;\n    for(int i=I-1; i>=0; i--){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int i=I+1; i<n; i++){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int j=J-1; j>=0; j--){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n    for(int j=J+1; j<m; j++){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n\n    return memo[MP(bit,l)] = ans;\n}\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    while(true){\n        cin >> m >> n;\n        if(n == 0 && m == 0) break;\n\n        num.clear();\n        ie = 0;\n        bit = 0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                cin >> mp[i][j];\n                if(mp[i][j] == 2){\n                    x = i;\n                    y = j;\n                }\n                if(mp[i][j] == 1){\n                    num[MP(i,j)] = ie;\n                    ie++;\n                }\n            }\n        }\n        ie = (1<<ie) - 1;\n        l = -1;\n        memo.clear();\n\n        cout << dfs(x,y) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nconst int LIM = 18;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=LIM){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=LIM){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint grid[10][10];\n\nstruct STATE\n{\n\tint done, x, y;\n\t\n\tbool operator < (const STATE& t) const{\n\t\tif (done == t.done){\n\t\t\tif (x == t.x){\n\t\t\t\treturn y < t.y;\n\t\t\t}\n\t\t\treturn x < t.x;\n\t\t}\n\t\treturn done < t.done;\n\t}\n};\n\nint main()\n{\n\tint m, n;\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tint num = 0;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 0){\n\t\t\t\t\tgrid[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 1){\n\t\t\t\t\tgrid[i][j] = num++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgrid[i][j] = -2;\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<STATE, int> dp;\n\t\tmap<STATE, int> dp2;\n\t\tSTATE tmp = {0, sx, sy};\n\t\tdp[tmp] = 1;\n\t\tint res = 0;\n\t\twhile (true){\n\t\t\tSTATE tmp = {(1 << num) - 1, sx, sy};\n\t\t\tif (dp.count(tmp)){\n\t\t\t\tres = dp[tmp];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (map<STATE, int>::iterator ite = dp.begin(); ite != dp.end(); ++ite){\n\t\t\t\tSTATE st = (*ite).first;\n\t\t\t\t\n\t\t\t\t//printf(\"%d %d %d %d\\n\", st.done, st.x, st.y, dp[st]);\n\t\t\t\t\n\t\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\t\tint i = 1;\n\t\t\t\t\twhile (true){\n\t\t\t\t\t\tint tx = st.x + dx[dir] * i;\n\t\t\t\t\t\tint ty = st.y + dy[dir] * i;\n\t\t\t\t\t\tif (tx < 0 || tx >= n || ty < 0 || ty >= m) break;\n\t\t\t\t\t\tif (grid[tx][ty] == -2){\n\t\t\t\t\t\t\tif (st.done == (1 << num) - 1){\n\t\t\t\t\t\t\t\tSTATE tmp = {st.done, tx, ty};\n\t\t\t\t\t\t\t\tdp2[tmp] += dp[st];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((grid[tx][ty] != -1) && (~st.done & (1 << grid[tx][ty]))){\n\t\t\t\t\t\t\tSTATE tmp = {st.done | (1 << grid[tx][ty]), tx, ty};\n\t\t\t\t\t\t\tdp2[tmp] += dp[st];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp.clear();\n\t\t\tdp = dp2;\n\t\t\tdp2.clear();\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>21||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=21&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=21?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint W, H, cnt, g[11][11], X[24], Y[24];\nunordered_map< int, int > memo[24];\n\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {-1,0,1,0};\n\nbool in_range(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nint rec(int S, int i) {\n\tif (S == (1 << cnt) - 1) {\n\t\tfor_(d,0,4) {\n\t\t\tint nx = X[i], ny = Y[i];\n\t\t\t\n\t\t\tfor_(rep,0,10) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\t\n\t\t\t\tif (g[ny][nx] == -1 || !in_range(nx, ny)) break;\n\t\t\t\tif (g[ny][nx] == -2) return 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tif (memo[i].count(S)) return memo[i][S];\n\t\n\tint& res = memo[i][S];\n\tres = 0;\n\t\n\tfor_(d,0,4) {\n\t\tint nx = X[i], ny = Y[i];\n\t\t\n\t\tfor_(rep,0,10) {\n\t\t\tnx += dx[d];\n\t\t\tny += dy[d];\n\t\t\t\n\t\t\tif (g[ny][nx] == -1 || !in_range(nx, ny)) break;\n\t\t\tif (g[ny][nx] < -1) continue;\n\t\t\t\n\t\t\tint j = g[ny][nx];\n\t\t\t\t\t\t\n\t\t\tg[ny][nx] = -1;\n\t\t\tres += rec(S | 1 << j, j);\n\t\t\tg[ny][nx] = j;\n\t\t\t\n\t\t\tif (res >= 2000000) return res;\n\t\t}\n\t}\n\t\t\n\treturn res;\n}\n\nvoid solve() {\n\tfor_(i,0,24) memo[i].clear();\n\tcout << rec(0, 23) << endl;\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tcnt = 0;\n\t\t\n\t\tfor_(y,0,H) for_(x,0,W) {\n\t\t\tcin >> g[y][x];\n\t\t\t\n\t\t\tif (g[y][x] == 0) g[y][x] = -3;\n\t\t\telse if (g[y][x] == 1) { X[cnt] = x; Y[cnt] = y; g[y][x] = cnt; ++cnt; }\n\t\t\telse if (g[y][x] == 2) { X[23] = x; Y[23] = y; g[y][x] = -2; }\n\t\t}\n\t\t\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;\n    vis=0;\n    vis|=(1<<houseId[si][sj]);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n\n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;\n    qs.pop();\n\n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !( st_now.vis&(1<<houseId[next.fr][next.sc]) ) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis|=(1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\n\t    if(st_next.cnt == nhouse){\n\t      for(int l = 0; l < MAXDIR; ++l){\n\t\tif( M[st_next.ni][st_next.nj].cexist[l] ){\n\t\t  ++ans;\n\t\t}\n\t      }\n\t      break;\n\t    }else{\n\t      qs.push( st_next );\n\t      break;\n\t    }\n\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<P, int>dp;\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[{1 << dat[nx][ny], dat[nx][ny]}] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0, o = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[{i, j}];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++o >= 10000)dp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\nusing namespace std;\n\ntypedef long long int64;\nconst int inf = (int)1e9;\n\ninline bool in(int x, int y, int w, int h)\n{\n\treturn x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint main()\n{\n\twhile(true) {\n\t\t\n\t\tint w, h, n;\n\t\tint field[16][16];\n\t\tvector<pair<int, int> > house;\n\t\tpair<int, int> church;\n\t\t\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif(t == 0) {\n\t\t\t\t\tt = -1;\n\t\t\t\t} else if(t == 1) {\n\t\t\t\t\tt = house.size();\n\t\t\t\t\thouse.push_back(make_pair(x, y));\n\t\t\t\t} else if(t == 2) {\n\t\t\t\t\tt = -2;\n\t\t\t\t\tchurch = make_pair(x, y);\n\t\t\t\t}\n\t\t\t\tfield[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tn = house.size();\n\t\t\n\t\tint reach[23][23];\n\t\tint dx[] = {-1, 0, 0, 1}, dy[] = {0, -1, 1, 0};\n\t\tmap<pair<int, int>, int> dp;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tdp[make_pair(1 << tgt, tgt)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int a = 0; a < n; ++a) {\n\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\n\t\t\t\tif(a == b)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\treach[a][b] = (1 << a) | (1 << b);\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\t\n\t\t\t\t\tint cx = house[a].first, cy = house[a].second;\n\t\t\t\t\tint bit = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tint t = field[cx][cy];\n\t\t\t\t\t\tif(t == b) {\n\t\t\t\t\t\t\treach[a][b] = bit;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(t >= 0) {\n\t\t\t\t\t\t\tbit |= 1 << t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int bit = 1; bit < (1 << n); ++bit) {\n\t\t\t\n\t\t\tfor(int a = 0; a < n; ++a) {\n\t\t\t\t\n\t\t\t\tif((bit & (1 << a)) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint prev = bit ^ (1 << a);\n\t\t\t\t\n\t\t\t\tfor(int b = 0; b < n; ++b) {\n\t\t\t\t\t\n\t\t\t\t\tif(((prev & (1 << b)) == 0) && ((prev & reach[a][b]) != 0)) {\n\t\t\t\t\t\n\t\t\t\t\t\tmap<pair<int, int>, int>::iterator it = dp.find(make_pair(prev, b));\n\t\t\t\t\t\tif(it != dp.end())\n\t\t\t\t\t\t\tdp[make_pair(bit, a)] += it->second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\n\t\t\tint cx = church.first, cy = church.second;\n\t\t\twhile(true) {\n\t\t\t\tcx += dx[i], cy += dy[i];\n\t\t\t\tif(!in(cx, cy, w, h))\n\t\t\t\t\tbreak;\n\t\t\t\tif(field[cx][cy] >= 0) {\n\t\t\t\t\tint tgt = field[cx][cy];\n\t\t\t\t\tans += dp[make_pair((1 << n) - 1, tgt)];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n/* ハラスメントに負けず */\n/* 0完太陽にも負けず */\n/* はやく人権を獲得したい */\n/* nullmineralが書きましたが */\n/* 責任はまったくとりません */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int N = 30;\nbool adj[N][N];\nint up[N][N];\nbool visit[N];\nint n;\nvector<P> house;\n\nvoid check(int an, int bn)\n{\n  P a = house[an];\n  P b = house[bn];\n  \n  if (a.first!=b.first && a.second!=b.second) {\n    return;\n  }\n\n  int st = 0;\n  if (a.second==b.second) {\n    int s = min(a.first, b.first);\n    int t = max(a.first, b.first);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].second!=a.second) continue;\n      int x = house[i].first;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n  else if (a.first==b.first) {\n    int s = min(a.second, b.second);\n    int t = max(a.second, b.second);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].first!=a.first) continue;\n      int x = house[i].second;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n\n  adj[an][bn] = adj[bn][an] = true;\n  up[an][bn] = up[bn][an] = st;\n}\n\nvoid f(int p, int st, int &ans)\n{\n  if (p==n-1 && st==(1<<n)-1) {\n    ++ans;\n    return;\n  }\n  for (int i=0; i < n; ++i) {\n    if (visit[i]) continue;\n    if (adj[p][i]==false) continue;\n    if ((up[p][i] & st)>0) continue;\n    visit[i] = true;\n    f(i, (st|(1<<i)), ans);\n    visit[i] = false;\n  }\n}\n\nint main()\n{\n  int w, h;\n  while (cin>>w>>h) {\n    if (!w && !h) break;\n\n    fill(&adj[0][0], &adj[N-1][N], false);\n    fill(&up[0][0], &up[N-1][N], 0);\n\n    house.clear();\n    P ch;\n    for (int i=0; i < h; ++i) {\n      for (int j=0; j < w; ++j) {\n\tint val;\n\tcin >> val;\n\tif (val==1) {\n\t  house.push_back(P(i,j));\n\t}\n\telse if (val==2) {\n\t  ch = P(i,j);\n\t}\n      }\n    }\n\n    house.push_back(ch);\n\n    n = house.size();\n    for (int i=0; i < n; ++i) {\n      for (int j=i+1; j < n; ++j) {\n\tcheck(i, j);\n      }\n    }\n\n    fill(visit, visit+N, 0);\n    int ans = 0;\n    f(n-1, 0, ans);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<stdlib.h>\n#define MAX 12\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint dp[(1<<18)][23];\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n\tif(housInd[ny][nx] != -1 && bit < (1 << 18) && dp[bit][housInd[ny][nx]] != -1)\n\t\treturn dp[bit][housInd[ny][nx]];\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[bit][housInd[ny][nx]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((bit & 1 << ind) != 0) break;\n\t\t\t\tif (!isLast)ret += func(y, x, bit | (1 << ind));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn housInd[ny][nx] != -1 && bit < (1 << 18) ? (dp[bit][housInd[ny][nx]] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint HashH(int now, set<int>& vis) {\n    int val=now;\n    for(auto x : vis) {\n        val+=(1<<(x+7));\n    }\n    return val;\n}\n\nint dfs(int now, set<int>& vis, unordered_map<int,int>& dp, vector<vector<vector<int> > >& e, int church, int cnt) {\n    int hashval=HashH(now,vis);\n\n    if(dp.count(hashval)!=0) {\n        return dp[hashval];\n    } else if(cnt==0 && now==church) {\n        return dp[hashval]=1;\n    }\n\n    int dh[4]={-1,0,1,0};\n    int dw[4]={0,-1,0,1};\n\n    int ret=0;\n    for(int d=0; d<4; ++d) {\n        for(int i=0; i<(int)e[d][now].size(); ++i) {\n            if(vis.count(e[d][now][i])==0) {\n                if(e[d][now][i]==church && cnt>1) continue;\n                vis.insert(e[d][now][i]);\n                ret+=dfs(e[d][now][i],vis,dp,e,church,cnt-1);\n                vis.erase(e[d][now][i]);\n                break;\n            }\n        }\n    }\n    return dp[hashval]=ret;\n}\n\nvoid solve(int m, int n) {\n    vector<vector<int> > mp(n);\n    int cnt=0;\n    vector<P> hou;\n    P ch;\n    set<int> vis;\n\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<m; ++j) {\n            int temp;\n            cin >> temp;\n            if(temp==1) {\n                mp[i].push_back(cnt);\n                hou.push_back(P(i,j));\n                ++cnt;\n            } else if(temp==2) {\n                ch=P(i,j);\n                mp[i].push_back(-2);\n            } else {\n                mp[i].push_back(-1);\n            }\n        }\n    }\n\n    hou.push_back(ch);\n    mp[ch.first][ch.second]=cnt;\n\n    // edge\n    vector<vector<vector<int> > > e(4);\n    for(int i=0; i<4; ++i) e[i].resize(cnt+1);\n\n    for(int i=0; i<(int)hou.size(); ++i) {\n        P now=hou[i];\n        int dh[4]={-1,0,1,0};\n        int dw[4]={0,-1,0,1};\n        for(int d=0; d<4; ++d) {\n            P nxt=now;\n            while(true) {\n                nxt.first+=dh[d];\n                nxt.second+=dw[d];\n                if(nxt.first<0 || nxt.first>=n || nxt.second<0 || nxt.second>=m) break;\n                if(mp[nxt.first][nxt.second]>=0) e[d][i].push_back(mp[nxt.first][nxt.second]);\n            }\n        }\n    }\n\n    unordered_map<int,int> dp;\n    int ans=dfs(cnt,vis,dp,e,cnt,cnt+1);\n    cout << ans << endl;\n    return;\n}\n\nint main() {\n    int m,n;\n    while(true) {\n        cin >> m >> n;\n        if(m==0 && n==0) break;\n        solve(m,n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nconst int B = 19;\nint dp[24][1 << B];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (idx == hs && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\tif (bits < 1 << B && ~dp[idx][bits]) return dp[idx][bits];\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(x, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\tif (bits < 1 << B)\n\t\treturn dp[idx][bits] = res;\n\telse return res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstd::vector<int> X[10], Y[10];\nint W, H;\nint hx[24], hy[24];\nint cx, cy, hn;\n\nbool canMove(int u, int v, int state){\n    if(hx[u] != hx[v] && hy[u] != hy[v]){return false;}\n    if(hx[u] == hx[v]){\n        if(hy[u] > hy[v]){std::swap(u, v);}\n        for(auto i : Y[hx[u]]){\n            if(state >> i & 1 && hy[u] < hy[i] && hy[i] < hy[v]){return false;}\n        }\n    }else{\n        if(hx[u] > hx[v]){std::swap(u, v);}\n        for(auto i : X[hy[u]]){\n            if(state >> i & 1 && hx[u] < hx[i] && hx[i] < hx[v]){return false;}\n        }\n    }\n    return true;\n}\n\nint bitCount(int n){\n    n = (n & 0x55555555) + (n >> 1 & 0x55555555);\n    n = (n & 0x33333333) + (n >> 2 & 0x33333333);\n    n = (n & 0x0f0f0f0f) + (n >> 4 & 0x0f0f0f0f);\n    n = (n & 0x00ff00ff) + (n >> 8 & 0x00ff00ff);\n    return n = (n & 0x0000ffff) + (n >> 16 & 0x0000ffff);\n}\n\nint main(){\n    while(std::cin >> W >> H, W){\n        hn = 0;\n        REP(i, 10){\n            X[i].clear(); Y[i].clear();\n        }\n        REP(i, H){\n            REP(j, W){\n                int n;\n                std::cin >> n;\n\n                if(n == 1){\n                    hx[hn] = j; hy[hn] = i;\n                    // printf(\"(%d, %d)\\n\", j, i);\n                    X[i].push_back(hn);\n                    Y[j].push_back(hn);\n                    hn++;\n                }else if(n == 2){\n                    // printf(\"church: (%d, %d)\\n\", j, i);\n                    cx = j; cy = i;\n                }\n            }\n        }\n        hx[hn] = cx; hy[hn] = cy;\n\n        int res = 0;\n        std::queue<State> q;\n        q.push(mp(0, mp(hn, 0)));\n\n        while(!q.empty()){\n            State s = q.front(); q.pop();\n            P p = s.second;\n            int n = s.first, v = p.first, state = p.second;\n\n            if(n == hn){res += canMove(hn, p.first, p.second); continue;}\n\n            for(auto u : X[hy[v]]){\n                if(state >> u & 1){continue;}\n                if(!canMove(u, v, state)){continue;}\n                q.push(mp(n+1, mp(u, state | (1 << u))));\n            }\n\n            for(auto u : Y[hx[v]]){\n                // printf(\"y: %d, %d, %d, (%d, %d), (%d, %d)\\n\", u, v, canMove(u, v), hx[u], hy[u], hx[v], hy[v]);\n                if(state >> u & 1){continue;}\n                if(!canMove(u, v, state)){continue;}\n                q.push(mp(n+1, mp(u, state | (1 << u))));\n            } \n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\n#define int long long\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\nint CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\nbool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool CanDown(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\tif (itr != memo.end()) return itr->second;\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\treturn memo[state] = sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nvvi fil;\nint n,m,N;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint f(int a,int b,int c){\n\tint co=0;\n\trep(i,4){\n\t\tint x=a,y=b;\n\t\twhile(1){\n\t\t\tx+=dx[i];y+=dy[i];\n\t\t\tif(x<0||y<0||x>=n||y>=m)break;\n\t\t\tif(fil[x][y]==3)break;\n\t\t\tif(fil[x][y]==2&&c==N)return 1;\n\t\t\tif(fil[x][y]==1){\n\t\t\t\tfil[x][y]=3;\n\t\t\t\tco+=f(x,y,c+1);\n\t\t\t\tfil[x][y]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn co;\n}\nint main(){\n\twhile(cin>>m>>n,n+m){\n\t\tfil=vvi(n,vi(m));\n\t\trep(i,n)rep(j,m)cin>>fil[i][j];\n\t\tN=0;\n\t\trep(i,n)rep(j,m)if(fil[i][j]==1)N++;\n\t\trep(i,n)rep(j,m)if(fil[i][j]==2)cout<<f(i,j,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  //char cnt;\n  //char pad[2];\n  int order[HSMAX];\n  state(int si, int sj):ni(si),nj(sj){\n    //cnt=0;\n    fill(order,order+HSMAX,-1);\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  bool operator<(const state &t)const{\n    //if(cnt==t.cnt){\n      if(ni==t.ni){\n\tif(nj==t.nj){\n\t  for(int i = 0; i < HSMAX; ++i){\n\t    if( order[i] != t.order[i] ) return order[i] < t.order[i];\n\t  }\n\t  return false;\n\t}else return nj < t.nj;\n      }else return ni < t.ni;\n      //}else return cnt < t.cnt;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  set<state> visited;\n  qs.push( init );\n  visited.insert(init);\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    //cout << ni << \" , \" << nj << \" : \";\n    int cnt=0;\n    for(int i = 0; i < HSMAX; ++i){\n      //cout << st_now.order[i] << ' ';\n      if( st_now.order[i] >= 0 )++cnt;\n    }\n    //cout << endl;\n    if( cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n    /*\n    if( visited.find( st_now ) != visited.end() )\n      visited.erase( visited.find( st_now ) );\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  state st_next(st_now);\n\t  st_next.ni = next.fr;\n\t  st_next.nj = next.sc;\n\t  if( st_next.order[ houseId[next.fr][next.sc] ] < 0 ){\n\t    st_next.order[ houseId[next.fr][next.sc] ] = cnt;\n\t    //st_next.cnt++;\n\t    if( visited.find( st_next ) == visited.end() ){\n\t      visited.insert( st_next );\n\t      qs.push( st_next );\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\n#define MAX_N 10\n\nint x[MAX_N][MAX_N], G1[MAX_N][MAX_N], G2[MAX_N][MAX_N][4], h, w, gx, gy, cnt, C, c, X, Y;\nstack<int>S;\n\nvoid hantei() {\n\tX = S.top() % 10; Y = S.top() / 10; c = 0;\n\tif (G2[Y][X][0] == 0) {\n\t\tG2[Y][X][0] = 1;\n\t\tfor (int i = Y; i < h; i++) {\n\t\t\tif (G1[i][X] == 1 && x[i][X] == 1) {\n\t\t\t\tG1[i][X] = 0;\n\t\t\t\tS.push(i * 10 + X);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (G2[Y][X][1] == 0) {\n\t\tG2[Y][X][1] = 1;\n\t\tfor (int i = X; i < w; i++) {\n\t\t\tif (G1[Y][i] == 1 && x[Y][i] == 1) {\n\t\t\t\tG1[Y][i] = 0;\n\t\t\t\tS.push(Y * 10 + i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (G2[Y][X][2] == 0) {\n\t\tG2[Y][X][2] = 1;\n\t\tfor (int i = Y; i >= 0; i--) {\n\t\t\tif (G1[i][X] == 1 && x[i][X] == 1) {\n\t\t\t\tG1[i][X] = 0;\n\t\t\t\tS.push(i * 10 + X);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (G2[Y][X][3] == 0) {\n\t\tG2[Y][X][3] = 1;\n\t\tfor (int i = X; i >= 0; i--) {\n\t\t\tif (G1[Y][i] == 1 && x[Y][i] == 1) {\n\t\t\t\tG1[Y][i] = 0;\n\t\t\t\tS.push(Y * 10 + i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tc = 1;\n\treturn;\n}\n\nint bfs() {\n\tcnt = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tG1[i][j] = 1;\n\t\t}\n\t}\n\tS.push(gy * 10 + gx);\n\tG1[gy][gx] = 0;\n\twhile (!S.empty()) {\n\t\tif (S.size() == C + 1 && (S.top() / 10 == gy || S.top() % 10 == gx) ) {\n\t\t\tcnt++;\n\t\t}\n\t\thantei();\n\t\tif (c == 1) {\n\t\t\tG1[Y][X] = 1;\n\t\t\tG2[Y][X][0] = 0;\n\t\t\tG2[Y][X][1] = 0;\n\t\t\tG2[Y][X][2] = 0;\n\t\t\tG2[Y][X][3] = 0;\n\t\t\tS.pop();\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\twhile (true) {\n\t\tC = 0;\n\t\tcin >> w >> h;\n\t\tif (h == 0 && w == 0) { break; }\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t\tif (x[i][j] == 1) { C++; }\n\t\t\t\tif (x[i][j] == 2) { gy = i; gx = j; }\n\t\t\t}\n\t\t}\n\t\tcout << bfs() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint W, H;\n\nint a[12][12];\nint sy, sx;\nint nei_count = 0;\nint house_count = 0;\n\nint dfs(int y, int x, int zan)\n{\n\tif (zan == 0) {\n\t\treturn y == sy || x == sx;\n\t}\n\n\tint res = 0;\n\n\tfor (int nowy = y - 1; nowy >= 1; --nowy) {\n\t\tif (a[nowy][x] == 1) {\n\t\t\ta[nowy][x] = -1;\n\n\t\t\tres += dfs(nowy, x, zan - 1);\n\n\t\t\ta[nowy][x] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int nowy = y + 1; nowy <= H; ++nowy) {\n\t\tif (a[nowy][x] == 1) {\n\t\t\ta[nowy][x] = -1;\n\n\t\t\tres += dfs(nowy, x, zan - 1);\n\n\t\t\ta[nowy][x] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int nowx = x - 1; nowx >= 1; --nowx) {\n\t\tif (a[y][nowx] == 1) {\n\t\t\ta[y][nowx] = -1;\n\n\t\t\tres += dfs(y, nowx, zan - 1);\n\n\t\t\ta[y][nowx] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int nowx = x + 1; nowx <= W; ++nowx) {\n\t\tif (a[y][nowx] == 1) {\n\t\t\ta[y][nowx] = -1;\n\n\t\t\tres += dfs(y, nowx, zan - 1);\n\n\t\t\ta[y][nowx] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W) {\n\t\thouse_count = 0;\n\n\t\trep1(i, H) rep1(j, W) {\n\t\t\tcin >> a[i][j];\n\t\t\tif (a[i][j] == 1) {\n\t\t\t\thouse_count += 1;\n\t\t\t}\n\t\t\telse if (a[i][j] == 2) {\n\t\t\t\tsy = i, sx = j;\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(sy, sx, house_count) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nInt s[20][20],idx[20][20],cnt,pru;\nint u[20][20][4];\nint num[20];\nusing P = pair<Int, Int>;\nvector<vector<vector<P> > > G;\nmap<Int, Int> dp;\n\nInt dfs(Int y,Int x,Int b){\n  if((b&pru)==pru){\n    if((pru>>idx[y][x])&1) return b==(1<<cnt)-1;\n    return 0;\n  }\n  \n  Int hs=((y*20+x)<<30)+b;\n  if(dp.count(hs)) return dp[hs];\n  Int &res=dp[hs];\n  //Int res=0;\n  \n  for(Int k=0;k<4;k++){\n    Int z=idx[y][x];\n    for(auto p:G[z][k]){\n      Int ny,nx;\n      tie(ny,nx)=p;\n      if(s[ny][nx]<0) break;\n      if(s[ny][nx]==2){\n\tres+=b==(1<<cnt)-1;\n      }else{\n\ts[ny][nx]*=-1;\n\tInt nb=b^(1<<idx[ny][nx]);\n\tint flg=1;\n\tfor(int i=0;i<4;i++){\n\t  if(u[ny][nx][i]>=cnt) continue; \n\t  num[u[ny][nx][i]]--;\n\t  if((~nb>>u[ny][nx][i])&1)\n\t    flg&=num[u[ny][nx][i]]>=1;\n\t}\n\tif(flg) res+=dfs(ny,nx,nb);\n\tfor(int i=0;i<4;i++){\n\t  if(u[ny][nx][i]>=cnt) continue; \n\t  num[u[ny][nx][i]]++;\n\t}\n\ts[ny][nx]*=-1;\n      }\n    }\n  }\n\t\n  return res;\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    cnt=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tidx[i][j]=cnt;\n\tcnt+=s[i][j]==1;\n      }\n    }\n    \n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) idx[i][j]=cnt;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};    \n\n    G.clear();\n    G.resize(cnt+1);\n    \n    memset(num,0,sizeof(num));    \n    for(Int y=0;y<h;y++){\n      for(Int x=0;x<w;x++){\n\tif(s[y][x]==0) continue;\n\tInt z=idx[y][x];\n\tG[z].resize(4);\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y,nx=x;\n\t  while(1){\n\t    ny+=dy[k],nx+=dx[k];\n\t    while(in(ny,nx)&&s[ny][nx]==0)\n\t      ny+=dy[k],nx+=dx[k];\n\t    if(!in(ny,nx)) break;\t    \n\t    G[z][k].emplace_back(ny,nx);\n\t  }\n\t}\n\t\n\tfor(Int k=0;k<4;k++){\n\t  u[y][x][k]=cnt+1;\n\t  for(auto p:G[z][k]){\n\t    u[y][x][k]=idx[p.first][p.second];\n\t    num[idx[p.first][p.second]]++;\n\t    break;\n\t  }\n\t}\n\t\n\tif(z==cnt){\n\t  pru=0;\n\t  for(Int k=0;k<4;k++){\n\t    for(auto p:G[z][k]){\n\t      pru|=(1<<idx[p.first][p.second]);\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    dp.clear();\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) cout<<dfs(i,j,0)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint n,m,x,y,ie,already;\nint mp[10][10];\nint ans;\nvoid dfs(int I, int J){\n    //cout << I << \" \" << J << endl;\n    if(already == ie){\n        if(I != x && J != y) return;\n        for(int i=I-1; i>=0; i--){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int i=I+1; i<n; i++){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int j=J-1; j>=0; j--){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        for(int j=J+1; j<m; j++){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        return;\n    }\n\n    for(int i=I-1; i>=0; i--){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            already++;\n            dfs(i,J);\n            mp[i][J] *= -1;\n            already--;\n        }\n    }\n    for(int i=I+1; i<n; i++){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            already++;\n            dfs(i,J);\n            mp[i][J] *= -1;\n            already--;\n        }\n    }\n    for(int j=J-1; j>=0; j--){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            already++;\n            dfs(I,j);\n            mp[I][j] *= -1;\n            already--;\n        }\n    }\n    for(int j=J+1; j<m; j++){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            already++;\n            dfs(I,j);\n            mp[I][j] *= -1;\n            already--;\n        }\n    }\n}\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    while(true){\n        cin >> m >> n;\n        if(n == 0 && m == 0) break;\n\n        ie = 0;\n        already = 0;\n        ans = 0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                cin >> mp[i][j];\n                if(mp[i][j] == 2){\n                    x = i;\n                    y = j;\n                }\n                if(mp[i][j] == 1) ie++;\n            }\n        }\n        dfs(x,y);\n\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\nInt s[20][20],idx[20][20],cnt,pru;\nInt u[40][4];\nInt num[40],ok[40];\nvector<vector<vector<Int> > > G;\n\nunordered_map<int, int> dp;\nInt dfs(Int z,Int b){\n  if(b==0) dp.clear();\n  int hs=(b<<5)|z;\n  if(dp.count(hs)) return dp[hs];\n\n  Int res=0;\n  \n  for(Int k=0;k<4;k++){\n    for(auto w:G[z][k]){\n      if((b>>w)&1) break;\n      Int nb=b^(1<<w),flg=1;\n      for(Int i=0;i<4;i++){\n\tif(u[w][i]>=cnt) continue; \n\tnum[u[w][i]]--;\n\tif((~nb>>u[w][i])&1)\n\t  flg&=num[u[w][i]]>=1;\n      }\n      if(flg){\n\tif(nb+1==(1<<cnt)) res+=ok[w];\n\telse if((nb&pru)!=pru) res+=dfs(w,nb);\n      }\n      for(Int i=0;i<4;i++) num[u[w][i]]++;\n    }\n  }\n  \n  if(z&4==0) dp[hs]=res;\n  return res;\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    cnt=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tidx[i][j]=cnt;\n\tcnt+=s[i][j]==1;\n      }\n    }\n    \n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) idx[i][j]=cnt;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};    \n\n    G.clear();\n    G.resize(cnt+1);\n    \n    memset(num,0,sizeof(num));    \n    memset(ok,0,sizeof(ok));\n    \n    for(Int y=0;y<h;y++){\n      for(Int x=0;x<w;x++){\n\tif(s[y][x]==0) continue;\n\tInt z=idx[y][x];\n\tG[z].resize(4);\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y,nx=x;\n\t  while(1){\n\t    ny+=dy[k],nx+=dx[k];\n\t    while(in(ny,nx)&&s[ny][nx]==0)\n\t      ny+=dy[k],nx+=dx[k];\n\t    if(!in(ny,nx)) break;\t    \n\t    if(s[ny][nx]==2) ok[z]=1;\n\t    else G[z][k].emplace_back(idx[ny][nx]);\n\t  }\n\t}\n\t\n\tfor(Int k=0;k<4;k++){\n\t  u[z][k]=cnt+1;\n\t  for(auto w:G[z][k]){\n\t    u[z][k]=w;\n\t    num[w]++;\n\t    break;\n\t  }\n\t}\n\t\n\tif(z==cnt){\n\t  pru=0;\n\t  for(Int k=0;k<4;k++){\n\t    for(auto w:G[z][k]){\n\t      pru|=(1<<w);\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    cout<<dfs(cnt,0)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n//#include <unordered_map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\n//vector<map<int,int> > memo;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\t//if(memo[MP(house_num,state)]!=0) return memo[MP(house_num,state)]-1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(house_num-1))&1)==1) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>16||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1/*&&((state>>(G[house_num][i].S_-1))&1)!=1*/){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//if(memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=16&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=16?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\t//memo.resize(cnt);\n\t//REP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\nint m, n;\nint f[11][11];\nPII c;\nint hn = 0;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll dfs(int x, int y, int used){\n\tll res = 0;\n\tif(x == c.fst && y == c.snd){\n\t\tif(used == (1<<hn)-1){\n\t\t\treturn 1;\n\t\t}else if(used > 0){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP(i, 4){\n\t\tint nx = dx[i]+x, ny = dy[i]+y;\n\t\twhile(0 <= nx && nx < m && 0 <= ny && ny < n && f[nx][ny] != 100 && (f[nx][ny] == -1 || ((used >> f[nx][ny]) & 1) == 1)){\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t}\n\n\t\tif(0 <= nx && nx < m && 0 <= ny && ny < n && f[nx][ny] != -1){\n\t\t\tif(nx == c.fst && ny == c.snd)\n\t\t\t\tres += dfs(nx, ny, used);\n\t\t\telse\n\t\t\t\tres += dfs(nx, ny, used + (1 << f[nx][ny]));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> m >> n && m && n){\n\thn = 0;\n\tREP(i, n){\n\t\tREP(j, m){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif(a == 1){\n\t\t\t\tf[j][i] = hn;\n\t\t\t\thn++;\n\t\t\t}else if(a == 2){\n\t\t\t\tc = {j, i};\n\t\t\t\tf[j][i] = 100;\n\t\t\t}else{\n\t\t\t\tf[j][i] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dfs(c.fst, c.snd, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint m,n,k=0;\nint a[15][15],c[15][15],d[15][15],sh[15],sw[15];\nvector<int> h[15],w[15];\nint ans=0,locx,locy;\n\nint solve(int x,int y){\n\tint ret=0;\n\tbool b=false;\n\tif(a[x][y]==1){a[x][y]=3; b=true; k--;}\n\tif(k==0){\n\t\ta[x][y]=1; k++;\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<1<<endl;\n\t\tfor(int i=c[x][y]-1;i>=0;i--){\n\t\t\tif(a[h[y][i]][y]==3)break;\n\t\t\tif(a[h[y][i]][y]==2)return 1;\n\t\t}\n\t\tfor(int i=c[x][y]+1;i<sh[y];i++){\n\t\t\tif(a[h[y][i]][y]==3)break;\n\t\t\tif(a[h[y][i]][y]==2)return 1;\n\t\t}\t\n\t\tfor(int j=d[x][y]-1;j>=0;j--){\n\t\t\tif(a[x][w[x][j]]==3)break;\n\t\t\tif(a[x][w[x][j]]==2)return 1;\n\t\t}\n\t\tfor(int j=d[x][y]+1;j<sw[x];j++){\n\t\t\tif(a[x][w[x][j]]==3)break;\n\t\t\tif(a[x][w[x][j]]==2)return 1;\n\t\t}\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<0<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=c[x][y]-1;i>=0;i--){\n\t\tif(a[h[y][i]][y]==3)break;\n\t\tif(a[h[y][i]][y]==1)ret+=solve(h[y][i],y);\n\t}\n\tfor(int i=c[x][y]+1;i<sh[y];i++){\n\t\tif(a[h[y][i]][y]==3)break;\n\t\tif(a[h[y][i]][y]==1)ret+=solve(h[y][i],y);\n\t}\n\tfor(int j=d[x][y]-1;j>=0;j--){\n\t\tif(a[x][w[x][j]]==3)break;\n\t\tif(a[x][w[x][j]]==1)ret+=solve(x,w[x][j]);\n\t}\n\tfor(int j=d[x][y]+1;j<sw[x];j++){\n\t\tif(a[x][w[x][j]]==3)break;\n\t\tif(a[x][w[x][j]]==1)ret+=solve(x,w[x][j]);\n\t}\n\tif(b){a[x][y]=1; k++;}\n\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<ret<<endl;\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++){a[i][j]=3; c[i][j]=0; d[i][j]=0;}\n\tfor(int i=0;i<15;i++){h[i].clear(); w[i].clear();}\n\tk=0;\n\tscanf(\"%d%d\",&m,&n);\n\tif(m==0&&n==0)break;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\tif(a[i][j]==1){\n\t\t\t\tk++;\n\t\t\t\tc[i][j]=h[j].size();\n\t\t\t\td[i][j]=w[i].size();\n\t\t\t\th[j].push_back(i);\n\t\t\t\tw[i].push_back(j);\n\t\t\t}\n\t\t\tif(a[i][j]==2){\n\t\t\t\tlocx=i; locy=j;\n\t\t\t\tc[i][j]=h[j].size();\n\t\t\t\td[i][j]=w[i].size();\n\t\t\t\th[j].push_back(i);\n\t\t\t\tw[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<15;i++){sh[i]=h[i].size(); sw[i]=w[i].size();}\n\tans=solve(locx,locy);\n\tprintf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n //#define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n//  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n      \nint n,m;\n\nint ban[20][20];\nint ans=0;\nint sx,sy;\nint ch[20][20];\n//int ma[1<<23][24];\nmap<pa,int>ma;\nint X[30],Y[30];\n\nint dp(int B,int pos){\n\tif(ma.find(mp(B,pos))!=ma.end())return ma[mp(B,pos)];\n\t\n\t//cout<<bitset<25>(z.x)<<\" \"<<z.y<<\" \"<<z.z<<endl;\n\tint ans=0;\n\tint x=X[pos],y=Y[pos];\n\tif(B==0){\n\t\tif(sx!=x && sy!=y) ans=0;\n\t\telse ans=1;\n\t\t\n\t\tma[mp(B,pos)]=ans;\n\t\treturn ans;\n\t}\n\t\n\tfor(int i=x+1;i<n;i++)if(ch[i][y]>=0){\n\t\tif((B&(1<<ch[i][y]))){\n\t\t\tans+=dp(B^(1<<ch[i][y]),ch[i][y]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=x-1;i>=0;i--)if(ch[i][y]>=0){\n\t\tif((B&(1<<ch[i][y]))){\n\t\t\tans+=dp(B^(1<<ch[i][y]),ch[i][y]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=y+1;i<m;i++)if(ch[x][i]>=0){\n\t\tif((B&(1<<ch[x][i]))){\n\t\t\tans+=dp(B^(1<<ch[x][i]),ch[x][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=y-1;i>=0;i--)if(ch[x][i]>=0){\n\t\tif((B&(1<<ch[x][i]))){\n\t\t\tans+=dp(B^(1<<ch[x][i]),ch[x][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tma[mp(B,pos)]=ans;\n\treturn ans;\n}\n\n  signed main(){\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n \n  \t\n  \twhile(1){\n  \tcin>>m>>n;\n  \t\tif(m==0 && n==0) return 0;\n  \tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)ch[i][j]=-1;\n  \tint ka=0;\n  \tfor(int i=0;i<n;i++)for(int j=0;j<m;j++){\n  \t\tcin>>ban[i][j];\n  \t\tif(ban[i][j]==2){\n  \t\t\tsx=i,sy=j;\n  \t\t}\n  \t\tif(ban[i][j]==1){\n  \t\t\tch[i][j]=ka;\n  \t\t\tX[ka]=i;\n  \t\t\tY[ka]=j;\n  \t\t\tka++;\n  \t\t\t\n  \t\t}\n  \t}\n  \tX[ka]=sx,Y[ka]=sy;\n  //\tfor(int i=0;i<(1<<ka);i++)for(int j=0;j<=ka;j++)ma[i][j]=-1;\n  \t\n  \t\tma.clear();\n  \t\t\tcout<<dp((1<<ka)-1,ka)<<endl;\n  \t}\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#define MAX 12\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint dp[(1<<18)][23];\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n\tif(housInd[ny][nx] != -1 && bit < (1 << 18) && dp[bit][housInd[ny][nx]] != -1)\n\t\treturn dp[bit][housInd[ny][nx]];\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[bit][housInd[ny][nx]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((bit & 1 << ind) != 0) break;\n\t\t\t\tif (!isLast)ret += func(y, x, bit | (1 << ind));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn housInd[ny][nx] != -1 && bit < (1 << 18) ? (dp[bit][housInd[ny][nx]] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tcout <<\"a\";\n//\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tint maxBits = min(sum, 18);\n\t\tfor(int i = 0; i < (1 << maxBits); i++) {\n\t\t\tfor(int j = 0; j < sum; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define EMPTY 0\n#define YET_DELIVERED 1\n#define CHURCH 2\n#define ALREADY_DELIVERED 3\n\nint count;\nint house_num;\nint map[10][10];\nvector<int> x_town[10];\nvector<int> y_town[10];\n\nvoid rec(int x, int y, int depth) {\n    int ind_x;\n    int ind_y;\n\n    for (ind_y = 0; ind_y < x_town[x].size(); ind_y++) {\n        int y2 = x_town[x][ind_y];\n        if (y2 == y) break;\n    }\n\n    for (ind_x = 0; ind_x < y_town[y].size(); ind_x++) {\n        int x2 = y_town[y][ind_x];\n        if (x2 == x) break;\n    }\n\n    for (int i = ind_x-1; i >= 0; i--) {\n        int x2 = y_town[y][i];\n        \n        if (map[y][x2] == ALREADY_DELIVERED) break;\n\n        if (map[y][x2] == CHURCH) {\n            if (depth == house_num) {\n                count++;\n                return;\n            }\n        } if (map[y][x2] == YET_DELIVERED) {\n            map[y][x2] = ALREADY_DELIVERED;\n            rec(x2, y, depth+1);\n            map[y][x2] = YET_DELIVERED;\n        }\n    }\n\n    for (int i = ind_x+1; i < y_town[y].size(); i++) {\n        int x2 = y_town[y][i];\n        \n        if (map[y][x2] == ALREADY_DELIVERED) break;\n\n        if (map[y][x2] == CHURCH) {\n            if (depth == house_num) {\n                count++;\n                return;\n            }\n        } if (map[y][x2] == YET_DELIVERED) {\n            map[y][x2] = ALREADY_DELIVERED;\n            rec(x2, y, depth+1);\n            map[y][x2] = YET_DELIVERED;\n        }\n    }\n\n    for (int i = ind_y-1; i >= 0; i--) {\n        int y2 = x_town[x][i];\n        \n        if (map[y2][x] == ALREADY_DELIVERED) break;\n\n        if (map[y2][x] == CHURCH) {\n            if (depth == house_num) {\n                count++;\n                return;\n            }\n        } if (map[y2][x] == YET_DELIVERED) {\n            map[y2][x] = ALREADY_DELIVERED;\n            rec(x, y2, depth+1);\n            map[y2][x] = YET_DELIVERED;\n        }\n    }\n\n    for (int i = ind_y+1; i < x_town[x].size(); i++) {\n        int y2 = x_town[x][i];\n        \n        if (map[y2][x] == ALREADY_DELIVERED) break;\n\n        if (map[y2][x] == CHURCH) {\n            if (depth == house_num) {\n                count++;\n                return;\n            }\n        } if (map[y2][x] == YET_DELIVERED) {\n            map[y2][x] = ALREADY_DELIVERED;\n            rec(x, y2, depth+1);\n            map[y2][x] = YET_DELIVERED;\n        }\n    }\n\n    return ;\n}\n\nint main() {\n    while (1) {\n        int m, n;\n        int church_x;\n        int church_y;\n    \n        scanf(\"%d %d\", &m, &n);\n        if ( (m & n) == 0) return 0;\n           \n        count = 0;\n        house_num = 0;\n        memset(map, '\\x00', sizeof(map));\n        for (int i=0; i<10; i++) {\n            x_town[i].clear();\n            y_town[i].clear();\n        }\n\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<m; j++) {\n                int p;\n    \n                scanf(\"%d\", &p);\n                map[i][j] = p;\n                x_town[j].push_back(i);\n                y_town[i].push_back(j);\n    \n                if (p == CHURCH) {\n                    church_x = j;\n                    church_y = i;\n                } else if (p == YET_DELIVERED) {\n                    ++house_num;\n                } \n            }\n        }\n    \n        rec(church_x, church_y, 0);\n    \n        printf(\"%d\\n\", count);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\nstruct reindeer{\n    int fly[11][11];\n    int x,y,pst;\n};\nusing namespace std;\nint main(void){\n    // Your code here!\n    int X,Y,xx,yy,map[11][11],i,i2,sx,sy,bx[4]={1,-1,0,0},by[4]={0,0,1,-1},ans,psts;\n    reindeer now,next;\n    queue<reindeer> jotai;\n    cin>>X>>Y;\n    while(X!=0){\n        ans=0;\n        psts=0;\n        for(i=1;i<=Y;i++){\n            for(i2=1;i2<=X;i2++){\n                cin>>map[i2][i];\n                if(map[i2][i]==1)psts++;\n                if(map[i2][i]==2){\n                    sx=i2;\n                    sy=i;\n                }\n                now.fly[i2][i]=0;\n            }\n        }\n        now.pst=0;\n        now.x=sx;\n        now.y=sy;\n        jotai.push(now);\n        while(!jotai.empty()){\n            now=jotai.front();\n            jotai.pop();\n            for(int I=0;I<4;I++){\n                xx=now.x+bx[I];\n                yy=now.y+by[I];\n                while(now.fly[xx][yy]==0&&xx>0&&yy>0&&xx<=X&&yy<=Y){\n                    \n                    /*cout<<now.x<<\"->\"<<xx<<' '<<now.y<<\"->\"<<yy<<endl;\n                    \n                    for(i=1;i<=Y;i++){\n                        for(i2=1;i2<=X;i2++){\n                            cout<<now.fly[i2][i];\n                        }\n                        cout<<endl;\n                    }\n                    cout<<endl;\n                    */\n                    if(map[xx][yy]==1){\n                        for(i=1;i<=Y;i++){\n                            for(i2=1;i2<=X;i2++){\n                                next.fly[i2][i]=now.fly[i2][i];\n                            }\n                        }\n                        next.fly[xx][yy]=now.pst+1;\n                        next.pst=now.pst+1;\n                        next.x=xx;\n                        next.y=yy;\n                        jotai.push(next);\n                    }\n                    if(map[xx][yy]==2){\n                        if(now.pst==psts){\n                            ans++; \n                            \n                            /*\n                            for(i=1;i<=Y;i++){\n                                for(i2=1;i2<=X;i2++){\n                                    cout<<now.fly[i2][i];\n                                }\n                                cout<<endl;\n                            }\n                            cout<<endl;\n                            */\n                        }\n                    }\n                    xx+=bx[I];\n                    yy+=by[I];\n                }\n            }\n        }\n        cout<<ans<<endl;\n        cin>>X>>Y;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 17;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum Block {BLANK, HOUSE, CHURCH};\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nbool clear(const vector<vector<int>>& map, int y, int x) {\n  for(int i = 0; i < map.size(); ++i) for(int j = 0; j < map[i].size(); ++j) {\n    if(map[i][j] == HOUSE) return false;\n    if(map[i][j] == CHURCH) return (i == y) || (j == x);\n  }\n  return true;\n}\n\nint dfs(vector<vector<int>>& map, int y, int x) {\n  auto bak = map[y][x];\n  if(map[y][x] == HOUSE) map[y][x] = BLANK;\n  if(clear(map, y, x)) {\n    map[y][x] = bak;\n    return 1;\n  }\n  int res = 0;\n  for(auto d: NEXT) {\n    int ny = y + d[Y];\n    int nx = x + d[X];\n    while(true) {\n      if(ny < 0 || map.size() <= ny) break;\n      if(nx < 0 || map[ny].size() <= nx) break;\n      if(map[ny][nx] == HOUSE) {\n        res += dfs(map, ny, nx);\n        break;\n      }\n      ny += d[Y];\n      nx += d[X];\n    }\n  }\n  map[y][x] = bak;\n  return res;\n}\n\nint main() {\n  int m, n;\n  while(cin >> m >> n, m | n) {\n    vector<vector<int>> map(n, vector<int>(m));\n    for(auto& line: map) for(auto& i: line) cin >> i;\n\n    int y, x;\n    for(int i = 0; i < n; ++i) for(int j = 0; j < m; ++j) if(map[i][j] == CHURCH) {\n      y = i;\n      x = j;\n    }\n    cout << dfs(map, y, x) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\n\nint n,m;\n\nint kx,ky;\nint field[11][11];\nint home;\n\nmap<int,int> dp[11][11];\n\nint dfs(int s,int x,int y){\n\tif(dp[y][x].find(s)!=dp[y][x].end()){\n\t\treturn dp[y][x][s];\n\t}\n\n\tif(s==((1<<home)-1)){\n\t\tif(ky==y){\n\t\t\t// ÌûüÖ\n\t\t\tfor(int i = x-1; i >= 0; i--){\n\t\t\t\tif(field[y][i]==-1){\n\t\t\t\t\tdp[y][x][s]=1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(field[y][i]!=-2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = x+1; i < m; i++){\n\t\t\t\tif(field[y][i]==-1){\n\t\t\t\t\tdp[y][x][s]=1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(field[y][i]!=-2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif(kx==x){\n\t\t\t// ÌûüÖ\n\t\t\tfor(int i = y-1; i >= 0; i--){\n\t\t\t\tif(field[i][x]==-1){\n\t\t\t\t\tdp[y][x][s]=1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(field[i][x]!=-2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = y+1; i < m; i++){\n\t\t\t\tif(field[i][x]==-1){\n\t\t\t\t\tdp[y][x][s]=1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(field[i][x]!=-2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[y][x][s]=0;\n\t\t\treturn 0;\n\t\t}\n\t\tdp[y][x][s]=0;\n\t\treturn 0;\n\t}\n\telse{\n\t\t// Ü¾S[µÄ¢È¢ê\n\t\t// »Ýn©çÚ®Å«éêÖÚ®\n\t\t// ÌûüÖ\n\t\tint sum=0;\n\t\tfor(int i = x-1; i >= 0; i--){\n\t\t\tif(field[y][i]>=0){\n\t\t\t\tif(!((s>>field[y][i])&1)){\n\t\t\t\t\tsum+=dfs(s|(1<<field[y][i]),i,y);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = x+1; i < m; i++){\n\t\t\tif(field[y][i]>=0){\n\t\t\t\tif(!((s>>field[y][i])&1)){\n\t\t\t\t\tsum+=dfs(s|(1<<field[y][i]),i,y);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// ÌûüÖ\n\t\tfor(int i = y-1; i >= 0; i--){\n\t\t\tif(field[i][x]>=0){\n\t\t\t\tif(!((s>>field[i][x])&1)){\n\t\t\t\t\tsum+=dfs(s|(1<<field[i][x]),x,i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = y+1; i < m; i++){\n\t\t\tif(field[i][x]>=0){\n\t\t\t\tif(!((s>>field[i][x])&1)){\n\t\t\t\t\tsum+=dfs(s|(1<<field[i][x]),x,i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdp[y][x][s]=sum;\n\t\treturn sum;\n\t}\n}\n\nint main(){\n\n\twhile(cin>>m>>n&&!(n==0&&m==0)){\n\t\tfor(int i = 0; i < 11; i++)\n\t\t\tfor(int j = 0; j < 11; j++)\n\t\t\t\tdp[i][j].clear();\n\t\thome=0;\n\t\tmemset(field,0,sizeof(field));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tint t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t==1){\n\t\t\t\t\tfield[i][j]=home;\n\t\t\t\t\thome++;\n\t\t\t\t}\n\t\t\t\telse if(t==0){\n\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t}\n\t\t\t\telse if(t==2){\n\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\tkx=j;\n\t\t\t\t\tky=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(0,kx,ky)<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <deque>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define X real() \n#define Y imag() \nusing namespace std;\ntypedef complex<int> cli;\ntypedef vector<cli> vcl;\ntypedef vector<int> vi;\nint num=0;\nint ans=0;\nint direct[40][4];\nvoid search(int now,int reach){\n\tif(now==0){\n\t\tif(reach+1==2<<num)\n\t\t\tans++;\n\t\t\t\n\t\treturn;\n\t}\n\tREP(i,4){\n\t\tint next=direct[now][i];\n\t\twhile((next!=-1) && (1<<next & reach)) next=direct[next][i];\n\t\tif(next!=-1)\n\t\t\tsearch(next,reach+(1<<next ));\n\t}\n}\nint main() {\n\tint m,n;\n\twhile(cin >> m >> n && n){\n\tans=0;\n\tnum=0;\n\tvi edge[40];\t\n\tint maps[11][11]={};\n\tREP(i,n)\n\t\tREP(j,m){\n\t\t\tcin >> maps[i][j];\n\t\t\tif(maps[i][j]==2){\n\t\t\t\tmaps[i][j]=0;\n\t\t\t}\n\t\t\telse if(maps[i][j]){\n\t\t\t\tmaps[i][j]=++num;\n\t\t\t}\n\t\t\telse \n\t\t\t\tmaps[i][j]=-1;\n\t\t}\n\tint nx,ny[11]={};\n\tREP(i,11)\n\t\tny[i]=-1;\n\tREP(i,40)\n\t\tREP(j,4)\n\t\t\tdirect[i][j]=-1;\n\tREP(i,n){\n\t\tnx=-1;\n\t\tREP(j,m){\n\t\t\tif(maps[i][j]>=0){\n\t\t\t\tif(nx>=0){\n\t\t\t\t\tedge[maps[i][j]].push_back(maps[i][nx]);\n\t\t\t\t\tedge[maps[i][nx]].push_back(maps[i][j]);\n\t\t\t\t\tdirect[maps[i][j]][3]=maps[i][nx];\n\t\t\t\t\tdirect[maps[i][nx]][0]=maps[i][j];\n\t\t\t\t}\n\t\t\t\tnx=j;\n\t\t\t\tif(ny[j]>=0){\n\t\t\t\t\tedge[maps[i][j]].push_back(maps[ny[j]][j]);\n\t\t\t\t\tedge[maps[ny[j]][j]].push_back(maps[i][j]);\n\t\t\t\t\tdirect[maps[i][j]][1]=maps[ny[j]][j];\n\t\t\t\t\tdirect[maps[ny[j]][j]][2]=maps[i][j];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tny[j]=i;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\tREP(i,edge[0].size())\n\t\tsearch(edge[0][i],1<<edge[0][i]);\n\t\tcout <<ans << endl;\n\t// your code goes here\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define PB push_back\n#define MK make_pair\n#define MKT make_tuple\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n\n//constexpr int INF = 1LL<<60;\nconstexpr int INF = 1<<28;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_N = 23;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint mem[MAX_N + 1][1 << MAX_N], w, h, sx, sy;\nvector<pii> hs, xl, yl;\nvector<tuple<int, int, int>> xy, yx;\n\nint Solve(int k, int mask) {\n    if (k == hs.size()) {\n\tif (mask == (1 << (hs.size() + 1)) - 1 && k == hs.size()) {\n\t    return 1;\n\t}\n\treturn 0;\n    }\n    if (mem[k][mask] != -1) return mem[k][mask];\n\n    int res = 0, x = hs[k].first, y = hs[k].second;\n    auto st = lower_bound(ALL(xy), MKT(x, y, k));\n    for (auto it = st + 1; it != xy.end() && get<0>(*it) == x; ++it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n    for (auto it = st - 1; xy.begin() <= it && get<0>(*it) == x; --it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n\n    st = lower_bound(ALL(yx), MKT(y, x, k));\n    for (auto it = st + 1; it != yx.end() && get<0>(*it) == y; ++it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n    for (auto it = st - 1; yx.begin() <= it && get<0>(*it) == y; --it) {\n\tint tk = get<2>(*it);\n\tif (mask & (1 << tk)) break;\n\tres += Solve(tk, mask + (1 << tk));\n    }\n\n    return mem[k][mask] = res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> w >> h, w) {\n\tmemset(mem, -1, sizeof(mem));\n\txy.clear();\n\tyx.clear();\n\ths.clear();\n\n\tfor (int y = 1; y <= h; ++y) {\n\t    for (int x = 1; x <= w; ++x) {\n\t\tint t;\n\t\tcin >> t;\n\t\tif (t == 1) {\n\t\t    xy.PB({x, y, hs.size()});\n\t\t    yx.PB({y, x, hs.size()});\n\t\t    hs.PB({x, y});\n\t\t} else if (t == 2) {\n\t\t    sx = x;\n\t\t    sy = y;\n\t\t}\n\t    }\n\t}\n\n\txy.PB({sx, sy, hs.size()});\n\tyx.PB({sy, sx, hs.size()});\n\tsort(ALL(xy));\n\tsort(ALL(yx));\n\n\tint ans = 0;\n\tauto st = lower_bound(ALL(xy), MKT(sx, -INF, -INF));\n\tfor (auto it = st; it != xy.end() && get<0>(*it) == sx; ++it) {\n\t    int tk = get<2>(*it);\n\t    if (tk == hs.size()) continue;\n\t    ans += Solve(tk, 1 << tk);\n\t}\n\n\tst = lower_bound(ALL(yx), MKT(sy, -INF, -INF));\n\tfor (auto it = st; it != yx.end() && get<0>(*it) == sy; ++it) {\n\t    int tk = get<2>(*it);\n\t    if (tk == hs.size()) continue;\n\t    ans += Solve(tk, 1 << tk);\n\t}\n\tcout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#pragma warning(disable : 4996)\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], d[4] = { 1, 0, -1, 0 };\nint solve(int sx, int sy, int depth) {\n\tif (depth == n) return ((sx == gx || sy == gy) ? 1 : 0);\n\tdepth++;\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (rng(tx, ty)) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += d[i];\n\t\t\tty += d[i ^ 1];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &x[i][j]);\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdio.h>\nusing namespace std;\n\n#define INF 1.1e9\n#define LINF 1.1e18\n#define FOR(i,a,b) for (long long i = (a); i < (b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(), (v).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint h,w;\nint fld[10][10];\nint sx,sy;\nint num,ans;\nint dx[]={1,-1,0,0},dy[]={0,0,1,-1};\n\nvoid dfs(int x,int y,int cnt) {\n\tREP(i,4) {\n\t\tint nx=x,ny=y;\n\t\twhile (true) {\n\t\t\tnx+=dx[i],ny+=dy[i];\n\t\t\tif(nx<0||nx>=w||ny<0||ny>=h) break;\n\t\t\tif(fld[ny][nx]==1) {\n\t\t\t\tfld[ny][nx]=0;\n\t\t\t\tdfs(nx,ny,cnt-1);\n\t\t\t\tfld[ny][nx]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(fld[ny][nx]==2&&cnt==0) {\n\t\t\t\tans++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while(true) {\n\tcin>>w>>h;\n\tif(w==0) break;\n\tnum=ans=0;\n\tREP(i,h) {\n\t\tREP(j,w) {\n\t\t\tcin>>fld[i][j];\n\t\t\tif(fld[i][j]==2) sy=i,sx=j;\n\t\t\telse if(fld[i][j]==1) num++;\n\t\t}\n\t}\n\n\tdfs(sx,sy,num);\n\n\tcout<<ans<<endl;\n    }\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,-1,0,0},dy[]={0,0,1,-1};\nint dfs(int y,int x,vector<vector<int> > grd,int nokori){\n\tint cnt=0;\n\tfor(int i=0;i<4;i++){\n\t\tfor(int j=1;grd[y+j*dy[i]][x+j*dx[i]]!=-1;j++){\n\t\t\tif(grd[y+j*dy[i]][x+j*dx[i]]==1){\n\t\t\t\tgrd[y+j*dy[i]][x+j*dx[i]]=-1;\n\t\t\t\tcnt+=dfs(y+j*dy[i],x+j*dx[i],grd,nokori-1);\n\t\t\t\tgrd[y+j*dy[i]][x+j*dx[i]]=1;\n\t\t\t}\n\t\t\telse if(nokori==0&&grd[y+j*dy[i]][x+j*dx[i]]==2)\treturn 1;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint m,n;\tcin>>m>>n;\n\tvector<vector<int> > grd(n+2,vector<int>(m+2,-1));\n\tint sx,sy,nokori=0;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tcin>>grd[i][j];\n\t\t\tif(grd[i][j]==2)\tsx=j,sy=i;\n\t\t\telse if(grd[i][j]==1)\tnokori++;\n\t\t}\n\t}\n\tcout<<dfs(sy,sx,grd,nokori)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> grid;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nvi dir[24][4];\nmap<int,int> memo;\n\nint rec(int v, int bit, int n){\n  int key = (v<<24)+bit;\n  if(memo.find(key)!=memo.end())return memo[key];\n  if(v==0 && bit+1 == 1<<n)return 1;\n\n  int res = 0;\n  rep(d,4){\n    for(int u : dir[v][d]){\n      if( (bit>>u)&1 )break;\n      res += rec(u, bit | (1<<u),n);\n    }\n  }\n  return memo[key] = res;\n}\n\nint main(){\n  int w,h;\n  while(cin >> w >> h, w){\n    grid g(h,vi(w));\n    \n    rep(i,h)rep(j,w)cin >> g[i][j];\n    \n    grid id(h,vi(w,-1));\n    int cnt = 1;\n    rep(i,h)rep(j,w){\n      if(g[i][j] == 2)id[i][j] = 0;\n      if(g[i][j] == 1)id[i][j] = cnt++;\n    }\n\n    rep(i,h)rep(j,w){\n      if(id[i][j]>=0){\n\trep(d,4){\n\t  dir[id[i][j]][d].clear();\n\n\t  int y = i+dy[d], x = j+dx[d];\n\t  while(range(y,0,h) && range(x,0,w)){\n\t    if(id[y][x]>=0)dir[id[i][j]][d].push_back(id[y][x]);\n\t    y += dy[d]; x += dx[d];\n\t  }\n\t}\n      }\n    }\n    \n    memo.clear();\n    cout << rec(0,0,cnt) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\ndeque<int> edge[24][4];\nint n;\n//int dp[24][1 << 23];\nmap<int, map<int, int> > dp;\nint dfs(int p, int visit)\n{\n\tif (dp[p].count(visit))\n\t\treturn dp[p][visit];\n\telse\n\t\tif (!visit)\n\t{\n\t\tbool f = false;\n\t\trep (i, 4)\n\t\t\tif (!edge[p][i].empty())\n\t\t\t\tf |= edge[p][i].front() == n;\n\t\treturn dp[p][visit] = f ? 1 : 0;\n\t\t//return f ? 1 : 0;\n\t}\n\n\tint res = 0;\n\trep (i, 4)\n\t{\n\t\tforeach (e, edge[p][i])\n\t\t{\n\t\t\tif (*e == n)\n\t\t\t\tcontinue;\n\t\t\tif (!(visit & (1 << *e)))\n\t\t\t\tbreak;\n\n\t\t\tres += dfs(*e, visit ^ (1 << *e));\n\t\t}\n\t}\n\n\treturn dp[p][visit] = res;\n\t//return res;\n}\nint main()\n{\n\tint h, w;\n\twhile (scanf(\"%d%d\", &w, &h), w | h)\n\t{\n\t\trep (i, 24)\n\t\t\trep (j, 4)\n\t\t\t\tedge[i][j].clear();\n\n\t\tpint church;\n\t\tvector<pint> pos;\n\t\trep (i, h)\n\t\t{\n\t\t\trep (j, w)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif (t == 1)\n\t\t\t\t\tpos.push_back(pint(j, i));\n\t\t\t\telse if (t == 2)\n\t\t\t\t\tchurch = pint(j, i);\n\t\t\t}\n\t\t}\n\t\tn = pos.size();\n\t\tpos.push_back(church);\n\n\t\trep (i, pos.size())\n\t\t{\n\t\t\tvector<pint> hor, ver;\n\t\t\trep (j, pos.size())\n\t\t\t{\n\t\t\t\tif (pos[i].first == pos[j].first)\n\t\t\t\t\tver.push_back(pint(pos[j].second, j));\n\t\t\t\telse if (pos[i].second == pos[j].second)\n\t\t\t\t\thor.push_back(pint(pos[j].first, j));\n\t\t\t}\n\t\t\tsort(all(hor));\n\t\t\tsort(all(ver));\n\n\t\t\tforeach (it, hor)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].first)\n\t\t\t\t\tedge[i][3].push_front(it->second);\n\t\t\t\telse if (pos[i].first < it->first)\n\t\t\t\t\tedge[i][1].push_back(it->second);\n\t\t\t}\n\t\t\tforeach (it, ver)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].second)\n\t\t\t\t\tedge[i][2].push_front(it->second);\n\t\t\t\telse if (pos[i].second < it->first)\n\t\t\t\t\tedge[i][0].push_back(it->second);\n\t\t\t}\n\t\t}\n\n\t\t//rep (i, n + 1)\n\t\t//{\n\t\t//\tprintf(\">%d: (%d, %d)\\n\", i, pos[i].first, pos[i].second);\n\t\t//\trep (j, 4)\n\t\t//\t{\n\t\t//\t\tprintf(\"%d: \", j);\n\t\t//\t\tforeach (t, edge[i][j])\n\t\t//\t\t\tprintf(\"(%d, %d) \", pos[*t].first, pos[*t].second);\n\t\t//\t\tputs(\"\");\n\t\t//\t}\n\t\t//}\n\n\t\t//memset(dp, ~0, sizeof(dp));\n\t\tdp.clear();\n\t\tint all_visit = (1 << n) - 1;\n\t\tprintf(\"%d\\n\", dfs(n, all_visit));\n\n\t\t//int s = 0;\n\t\t//rep (i, n)\n\t\t//\tif (~dp[i][0])\n\t\t//\t\ts += dp[i][0];\n\t\t//printf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nint memo[24][1<<23];\n\nvoid MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\nint DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\tif(memo[house_num][state]!=-1) return memo[house_num][state];\n\tint result=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>(G[house_num][i].S_-1))&1)!=1) result+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(house_num!=0&&((state>>(G[house_num][i].S_-1))&1)!=1){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\treturn memo[house_num][state]=result;\n}\n\nlli Solve(){\n\thouses.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tREP(i,0,cnt) REP(j,0,1<<(cnt-1)) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tunordered_map<int, unordered_map<int, int>>dp;\n\t\tauto F = [&](int x, int y, int s, int r) {\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x, ny = y; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(r >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[r | 1 << dat[nx][ny]][dat[nx][ny]] += s;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tF(sx, sy, 1, 0);\n\t\tint ans = 0;\n\t\trep(i, 1 << p) {\n\t\t\trep(j, p) {\n\t\t\t\tif (dp[i].find(j) == dp[i].end())continue;\n\t\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[i][j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tF(x[j], y[j], dp[i][j], i);\n\t\t\t}\n\t\t\tdp.erase(i);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 1 << 17;\nint W, H, fld[10][10];\nint P, sx, sy;\nint memo[10][10][MAX];\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (s < MAX)\n\t{\n\t\tif (memo[x][y][s] != -1) return memo[x][y][s];\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (s < MAX) memo[x][y][s] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfill_n((int*)memo, 10 * 10 * min(1 << P, MAX), -1);\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nstruct P{ int x,y; P(){} P(int X,int Y):x(X),y(Y){} };\n\nmap<int,int> dp[24];\nint adj[24][4][23],deg[24][4],house_num;\n\nint dfs(int id,int picked){\n\tif(dp[id].find(picked)!=dp[id].end()) return dp[id][picked];\n\n\tif(picked==(1<<(house_num+1))-1){\n\t\trep(k,4) rep(a,deg[id][k]) if(adj[id][k][a]==house_num) return 1;\n\t\treturn 0;\n\t}\n\n\tint ans=0;\n\trep(k,4) rep(a,deg[id][k]) {\n\t\tint next_id=adj[id][k][a];\n\t\tif((picked&(1<<next_id))==0){\n\t\t\tans+=dfs(next_id,picked|(1<<next_id));\n\t\t\tbreak;\n\t\t}\n\t}\n\t// return ans;\n\t// return dp[id][picked]=ans;\n\tif(dp[id].size()<10000000) dp[id][picked]=ans;\n\treturn ans;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tint field[10][10],charch_x,charch_y,f[10][10];\n\t\thouse_num=0;\n\t\trep(i,m) rep(j,n) {\n\t\t\tscanf(\"%d\",field[i]+j);\n\t\t\tif(field[i][j]==1) f[i][j]=house_num++;\n\t\t\tif(field[i][j]==2) charch_x=j,charch_y=i;\n\t\t}\n\t\tf[charch_y][charch_x]=house_num;\n\n\t\trep(i,m) rep(j,n) if(field[i][j]!=0) {\n\t\t\tint id=f[i][j];\n\t\t\tdp[id].clear();\n\t\t\trep(k,4){\n\t\t\t\tdeg[id][k]=0;\n\t\t\t\tint x=j+dx[k],y=i+dy[k];\n\t\t\t\twhile(0<=y && y<m && 0<=x && x<n){\n\t\t\t\t\tif(field[y][x]!=0) adj[id][k][deg[id][k]++]=f[y][x];\n\t\t\t\t\tx+=dx[k],y+=dy[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",dfs(house_num,1<<house_num));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<P, int>dp;\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[{1 << dat[nx][ny], dat[nx][ny]}] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[{i, j}];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int nposmax = 7;\nconst int bitmax = 1<<21;\n//bit????????????\nint dp[nposmax][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax&&now<nposmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\tif(bit<bitmax&&now<nposmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\n//int memo[1<<K][23];\nunordered_map<int, int> memo2[23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}*/\n\tif(done%3==0&&table[i][j]>=0&&memo2[table[i][j]].find(done)!=memo2[table[i][j]].end())\n\t{\n\t\treturn memo2[table[i][j]][done];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\t/*\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(table[i][j]>=0){\n\t\t\t\t\tmemo2[table[i][j]][done]=0;\n\t\t\t\t}*/\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}*/\n\tif(table[i][j]>=0&&done%3==0){\n\t\tmemo2[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tfor(int i=0;i<c;i++){\n\t\tmemo2[i].clear();\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return 1;\n\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(make_pair(make_pair(x, y), s));\n\tif (itr != memo.end()) return itr->second;\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\treturn memo[make_pair(make_pair(x, y), s)] = sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\n//int memo[1<<K][23];\nunordered_map<int, int> memo2[23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}*/\n\tif(done%11==0&&table[i][j]>=0&&memo2[table[i][j]].find(done)!=memo2[table[i][j]].end())\n\t{\n\t\treturn memo2[table[i][j]][done];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\t/*\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(table[i][j]>=0){\n\t\t\t\t\tmemo2[table[i][j]][done]=0;\n\t\t\t\t}*/\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}*/\n\tif(table[i][j]>=0&&done%11==0){\n\t\tmemo2[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tfor(int i=0;i<c;i++){\n\t\tmemo2[i].clear();\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nmap<tup, int> dp;\nint tb[10][10];\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (dp.count(tup{ idx,bits })) return dp[tup{ idx, bits }];\n\tif (idx == hs && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(x, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\tif (__builtin_popcount(bits) > 10)\n\t\treturn dp[tup{ idx, bits }] = res;\n\telse return res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tdp.clear();\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nstruct Info{\n\tInfo(int arg_state,int arg_row,int arg_col){\n\t\tstate = arg_state;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint state,row,col;\n};\n\n\nint base_map[10][10],house_index[10][10];\nint H,W;\nint POW[24],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\thouse_index[row][col] = -1;\n\t\t}\n\t}\n\n\tint church_row,church_col;\n\n\tint index = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&base_map[row][col]);\n\t\t\tif(base_map[row][col] == 1){\n\t\t\t\thouse_index[row][col] = index++;\n\t\t\t}else if(base_map[row][col] == 2){\n\t\t\t\tchurch_row = row;\n\t\t\t\tchurch_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0,finish_state = POW[index]-1;\n\n\tqueue<Info> Q;\n\tQ.push(Info(0,church_row,church_col));\n\n\tint next_row,next_col,next_state;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().state == finish_state){\n\t\t\tif(Q.front().row == church_row || Q.front().col == church_col){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_row = Q.front().row+diff_row[i];\n\t\t\t\tnext_col = Q.front().col+diff_col[i];\n\n\t\t\t\twhile(rangeCheck(next_row,next_col) == true &&\n\t\t\t\t\t((base_map[next_row][next_col] != 1) || ((Q.front().state & (1 << house_index[next_row][next_col])) != 0))){\n\t\t\t\t\tnext_row += diff_row[i];\n\t\t\t\t\tnext_col += diff_col[i];\n\t\t\t\t}\n\n\t\t\t\tif(!rangeCheck(next_row,next_col))continue;\n\n\t\t\t\tnext_state = Q.front().state+POW[house_index[next_row][next_col]];\n\t\t\t\tQ.push(Info(next_state,next_row,next_col));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 24; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[10][10];\nint a,b;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,-1,1};\nint n;\nint solve(int x,int y,int d){\n//\tprintf(\"%d %d %d\\n\",x,y,d);\n\tint ret=0;\n\tfor(int i=0;i<4;i++){\n\t\tint X=x;\n\t\tint Y=y;\n\t\twhile(1){\n\t\t\tX+=dx[i];\n\t\t\tY+=dy[i];\n\t\t\tif(!(X>=0&&X<b&&Y>=0&&Y<a))break;\n\t\t\tif(dat[X][Y]==2){\n\t\t\t\tif(d==n)ret++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dat[X][Y]==1){\n\t\t\t\tdat[X][Y]=-1;\n\t\t\t\tret+=solve(X,Y,d+1);\n\t\t\t\tdat[X][Y]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tscanf(\"%d\",&dat[i][j]);\n\t\t\t}\n\t\t}\n\t\tn=0;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tif(dat[i][j]==1)n++;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(dat[i][j]==2)printf(\"%d\\n\",solve(i,j,0));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint bfs(P sg,int home);\nint w,h;\nint mas[10][10];\nint dx[]={0,1,0,-1},dy[]={-1,0,1,0};\nP sg;\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tint home = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin >> mas[i][j];\n\t\t\t\tif(mas[i][j] == 1) home++;\n\t\t\t\telse if (mas[i][j] == 2) sg = P(j,i);\n\t\t\t}\n\t\t}\n\t\tcout << bfs(sg,home) << endl;\n\t}\n}\n\nint bfs(P now,int home){\n\tif(home == 0){\n\t\tif(now.first == sg.first || now.second == sg.second) return 1;\n\t\telse return 0;\n\t}\n\tint ret = 0;\n\tfor(int i=0;i<4;i++){\n\t\tP p = now;\n\t\twhile(1){\n\t\t\tp.first += dx[i]; p.second += dy[i];\n\t\t\tif(p.first >= 0 && p.second >= 0 && p.first < w && p.second < h){\n\t\t\t\tif(mas[p.second][p.first] == 1) break;\n\t\t\t}else{\n\t\t\t\tp = P(-1,-1); break;\n\t\t\t}\n\t\t}\n\t\tif(p.first == -1) continue;\n\t\tmas[p.second][p.first] = -1;\n\t\tret += bfs(p,home-1);\n\t\tmas[p.second][p.first] = 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&(house_num==0||((state>>(house_num-1))&1)==1)) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((house_num>15||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1){\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(house_num<=15&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (house_num<=15?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n, m;\nint res;\nint gx, gy;\nint map[10][10];\nbool used[10][10];\nint dx[4]={-1,1,0,0};\nint dy[4]={0,0,-1,1};\nbool isin(int x, int y) {\n    return x>=0&&y>=0&&x<m&&y<n;\n}\nvoid dfs(int x, int y) {\n    bool flag=true;\n    for (int i=0; i<m; i++) {\n        for (int j=0; j<n; j++) {\n            if (!used[i][j]) flag=false;\n        }\n    }\n    for (int i=0; i<4; i++) {\n        int nx=x+dx[i], ny=y+dy[i];\n        while (isin(nx,ny)&&(!used[nx][ny]||(used[nx][ny]&&map[nx][ny]!=1))) {\n            // printf(\"%d %d %d\\n\",nx,ny,map[nx][ny]);\n            if (map[nx][ny]==1) {\n                used[nx][ny]=true;\n                dfs(nx,ny);\n                used[nx][ny]=false;\n            }\n            if (nx==gx&&ny==gy&&flag) {\n                res++;\n                return;\n            }\n            nx+=dx[i]; ny+=dy[i];\n        }\n    }\n}\nint main() {\n    while (scanf(\"%d%d\",&n,&m)) {\n        if (!n&&!m) break;\n        res=0;\n        memset(used, 0, sizeof(used));\n        for (int i=0; i<m; i++) {\n            for (int j=0; j<n; j++) {\n                scanf(\"%d\",&map[i][j]);\n                if (map[i][j]==2) {\n                    gx=i; gy=j;\n                    used[i][j]=true;\n                } else if (map[i][j]==0) {\n                    used[i][j]=true;\n                }\n            }\n        }\n        dfs(gx,gy);\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint px[24],py[24],kx,ky;\nint num[24][4] = {0};\n\nint H,W,N,ans;\nint field[12][12] = {0};\n\nint dx[] = {0,-1,0,1} , dy[] = {1,0,-1,0};\nbool done[12][12];\n\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit){\n\tif(memo[pos].find(bit) != memo[pos].end() )return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\trep(d,4){\n\t\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\t\twhile( field[cy][cx] != -1){\n\t\t\t\tif(field[cy][cx] == 64)return 1;\n\t\t\t\tcy += dy[d] , cx += dx[d];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\trep(d,4){\n\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\twhile( field[cy][cx] == -2 || done[cy][cx] == 1 || field[cy][cx] == 64){\n\t\t\tcy += dy[d] , cx += dx[d];\n\t\t}\n\t\tif(field[cy][cx] != -1){\n\t\t\tdone[cy][cx] = 1;\n\t\t\tans += dfs(field[cy][cx],bit | (1<<field[cy][cx]) );\n\t\t\tdone[cy][cx] = 0;\n\t\t}\n\t}\n\tif(__builtin_popcount(bit) < 19){\n\t\treturn memo[pos][bit] = ans;\n\t}else{\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\twhile(cin >> W >> H ,W){\n\t\tN = ans = 0;\n\t\trep(i,24)rep(j,4)num[i][j] = -1;\n\t\trep(i,12)rep(j,12)field[i][j] = -1;\n\t\trep(i,H)rep(j,W){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tswitch(t){\n\t\t\tcase 0:\n\t\t\t\tfield[i+1][j+1] = -2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfield[i+1][j+1] = N;\n\t\t\t\tpx[N] = j+1, py[N] = i+1;\n\t\t\t\tN++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tkx = j+1 , ky = i+1;\n\t\t\t\tfield[i+1][j+1] = 64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpx[N] = kx , py[N] = ky;\n\t\trep(i,24)memo[i].clear();\n\t\tcout << dfs(N,0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nbool hs[10][10];\nbool used[10][10];\nint cx,cy;\nint ans;\nint nh;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\nvoid dfs(int x,int y,int f){\n\tif(f==nh&&(x==cx||y==cy)){\n\t\tans++;\n\t\treturn;\n\t}\n\tint i,j;\n\tfor(i=0;i<4;i++){\n\t\tfor(j=1;j<10;j++){\n\t\t\tint nx=x+j*dx[i];\n\t\t\tint ny=y+j*dy[i];\n\t\t\tif(nx>=0&&nx<h&&ny>=0&&ny<w&&hs[nx][ny]){\n\t\t\t\tif(!used[nx][ny]){\n\t\t\t\t\tused[nx][ny]=true;\n\t\t\t\t\tdfs(nx,ny,f+1);\n\t\t\t\t\tused[nx][ny]=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(1){\n\tint i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tif(w==0)return 0;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\ths[i][j]=false;\n\t\tused[i][j]=false;\n\t}\n\tnh=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ths[i][j]=true;\n\t\t\t\tused[i][j]=false;\n\t\t\t\tnh++;\n\t\t\t}\n\t\t\tif(c=='2'){cx=i;cy=j;}\n\t\t}\n\t}\n\tans=0;\n\tdfs(cx,cy,0);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int N = 25;\nconst int MEMO_LIM = (1<<23);\nbool adj[N][N];\nint up[N][N];\nint memo[MEMO_LIM][N];\nint n;\nvector<P> house;\n\nint near[N];\nint nearN[N];\nbool dame[N][N];\n\nvoid check(int an, int bn)\n{\n  P a = house[an];\n  P b = house[bn];\n  \n  if (a.first!=b.first && a.second!=b.second) {\n    return;\n  }\n\n  int st = 0;\n  if (a.second==b.second) {\n    int s = min(a.first, b.first);\n    int t = max(a.first, b.first);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].second!=a.second) continue;\n      int x = house[i].first;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n  else if (a.first==b.first) {\n    int s = min(a.second, b.second);\n    int t = max(a.second, b.second);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].first!=a.first) continue;\n      int x = house[i].second;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n\n  adj[an][bn] = adj[bn][an] = true;\n  up[an][bn] = up[bn][an] = st;\n}\n\nint f(int p, int st)\n{\n  if (p==n-1 && st==(1<<n)-1) {\n    return 1;\n  }\n  if (p==n-1 && st!=0) return 0;\n  \n  //if (st < MEMO_LIM) {\n    if (memo[st][p]!=-1) {\n      return memo[st][p];\n    }\n    //}\n\n  if ((st & near[n-1])==near[n-1]) {\n    if (st != (1<<(n-1))-1) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n  \n  \n  for (int i=0; i < n-1; ++i) {\n    if ((st & near[i])==near[i] && (st&(1<<i))==0) {\n      return memo[st][p] = 0;\n    }\n  }\n\n  int res = 0;\n\n  for (int i=0; i < n; ++i) {\n    if (!(((st&(1<<i))>0)\n\t  ||(adj[p][i]==false)\n\t  ||(up[p][i] & st)>0)) {\n      res += f(i, (st|(1<<i)));\n    }\n  }\n  \n  //if (st < MEMO_LIM) {\n    return memo[st][p] = res;\n    //}\n    //return res;\n}\n\nint main()\n{\n  int w, h;\n  while (cin>>w>>h) {\n    if (!w && !h) break;\n\n    fill(&adj[0][0], &adj[N-1][N], false);\n    fill(&up[0][0], &up[N-1][N], 0);\n\n    house.clear();\n    P ch;\n    for (int i=0; i < h; ++i) {\n      for (int j=0; j < w; ++j) {\n\tint val;\n\tcin >> val;\n\tif (val==1) {\n\t  house.push_back(P(i,j));\n\t}\n\telse if (val==2) {\n\t  ch = P(i,j);\n\t}\n      }\n    }\n\n    house.push_back(ch);\n\n    n = house.size();\n    for (int i=0; i < n; ++i) {\n      for (int j=i+1; j < n; ++j) {\n\tcheck(i, j);\n      }\n    }\n\n    for (int i=0; i < n; ++i) {\n      near[i] = 0;\n      for (int j=0; j < n; ++j) {\n\tif (adj[i][j] && up[i][j]==0) {\n\t  near[i] |= (1<<j);\n\t}\n      }\n    }\n\n    //memset(memo, sizeof(memo), 255);\n    int lim = min((1<<n),MEMO_LIM);\n    for (int i=0; i < lim; ++i) {\n      for (int j=0; j < n; ++j) {\n\tmemo[i][j] = -1;\n      }\n    }\n    //fill(&memo[0][0], &memo[MEMO_LIM-1][N], -1);\n    int ans = f(n-1, 0);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> pipi;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\nconstexpr int MAX_N = 11;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint fld[MAX_N][MAX_N], w, h, sx, sy, idx;\n\nint Solve(int x, int y, int mask, bool flg) {\n    if (flg && x == sx && y == sy) {\n        if (mask ^ ((1 << idx) - 1)) return 0;\n        return 1;\n    }\n\n    int res = 0;\n    for (int i = 0; i < 4; ++i) {\n        int tx = x, ty = y;\n        while (0 < tx && 0 < ty && tx <= w && ty <= h) {\n            tx += dx[i];\n            ty += dy[i];\n            if (sx == tx && sy == ty) res += Solve(tx, ty, mask, 1);\n\n            int num = fld[tx][ty];\n            if (num == -1) continue;\n            if (mask & (1 << num)) break;\n            res += Solve(tx, ty, mask + (1 << num), 1);\n        }\n    }\n\n    return res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> w >> h, w) {\n        memset(fld, -1, sizeof(fld));\n        idx = 0;\n\n        for (int y = 1; y <= h; ++y) {\n            for (int x = 1; x <= w; ++x) {\n                int t;\n                cin >> t;\n                if (t == 0) continue;\n                if (t == 2) {\n                    sx = x;\n                    sy = y;\n                    continue;\n                } else t = idx++;\n                fld[x][y] = t;\n            }\n        }\n\n        cout << Solve(sx, sy, 0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint m,n,gx,gy,sum;\nint house[10][10];\nbool used[10][10];\nvector<P>V[10][10][4];\nint rec(int x,int y,bool used[10][10],int cnt){\n\tif(x==gx&&y==gy){\n\t\tif(cnt!=0){\n\t\t\tif(cnt==sum)return 1;\n\t\t\telse return 0;\n\t\t}\n\t}\n\tif(sum==cnt)return 0;\n\tint res=0;\n\tREP(i,4){\n\t\tREP(j,V[x][y][i].size()){\n\t\t\tint tx=V[x][y][i][j].first,ty=V[x][y][i][j].second;\n\t\t\tif(!used[tx][ty]){\n\t\t\t\tused[tx][ty]=true;\n\t\t\t\tres+=rec(tx,ty,used,cnt+1);\n\t\t\t\tused[tx][ty]=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n  return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin>>m>>n;\n        if(m==0&&n==0)break;\n        memset(used,false,sizeof(used));\n        sum=0;\n        REP(i,n)REP(j,m){\n            cin>>house[j][i];\n            if(house[j][i]==2){gx=j;gy=i;}\n            if(house[j][i])sum++;\n        }\n\t\t\t\tREP(y,n)REP(x,m){\n\t\t\t\t\tif(house[x][y]){\n\t\t\t\t\t\tfor(int i=x-1;i>=0;i--)if(house[i][y])V[x][y][0].PB(MP(i,y));\n\t\t\t\t\t\tfor(int i=x+1;i<m ;i++)if(house[i][y])V[x][y][1].PB(MP(i,y));\n\t\t\t\t\t\tfor(int i=y-1;i>=0;i--)if(house[x][i])V[x][y][2].PB(MP(x,i));\n\t\t\t\t\t\tfor(int i=y+1;i<n ;i++)if(house[x][i])V[x][y][3].PB(MP(x,i));\n\t\t\t\t\t}\n\t\t\t\t}\n        cout<<rec(gx,gy,used,0)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], d[4] = { 1, 0, -1, 0 };\nint solve(int sx, int sy, int depth) {\n\tif (depth++ == n) return ((sx == gx || sy == gy) ? 1 : 0);\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (rng(tx, ty)) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += d[i];\n\t\t\tty += d[i ^ 1];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &x[i][j]);\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nint x,y;\nint map[10][10];\nint hmx[24],hmy[24];\nint gx,gy;\nint home;\nint ans;\nbool hm[24];\nint dx[5]={0,0,1,0,-1};\nint dy[5]={0,1,0,-1,0};\n\nvoid dfs(int mx,int my,int d,int ho2,int map2[10][10]){\n\tif(map2[mx][my]==2 && ho2==0)ans++;\n\telse{\n\t\tif(map2[mx][my]==1){\n\t\t\tmap2[mx][my]=3;\n\t\t\tdfs(mx,my,0,ho2-1,map2);\n\t\t\tmap2[mx][my]=1;\n\t\t}\n\t\telse if(d==0){\n\t\t\tfor(int i=1;i<=4;i++){\n\t\t\t\tint kx=mx+dx[i],ky=my+dy[i];\n\t\t\t\tif(kx>=0 && kx<x && ky>=0 && ky<y){\n\t\t\t\t\tdfs(kx,ky,i,ho2,map2);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint kx=mx+dx[d],ky=my+dy[d];\n\t\t\tif(kx>=0 && kx<x && ky>=0 && ky<y){\n\t\t\t\tdfs(kx,ky,d,ho2,map2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\thome=0;\n\t\tans=0;\n\t\tmemset(hm,false,sizeof(hm));\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&map[j][i]);\n\t\t\t\tif(map[j][i]==2)gx=j,gy=i;\n\t\t\t\tif(map[j][i]==1)hmx[home]=j,hmy[home]=i;\n\t\t\t\tif(map[j][i]==1)home++;\n\t\t\t}\n\t\t}\n\t\tdfs(gx,gy,0,home,map);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], d[4] = { 1, 0, -1, 0 };\nint solve(int sx, int sy, int depth) {\n\tif (depth++ == n) return ((sx == gx || sy == gy) ? 1 : 0);\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (rng(tx, ty)) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += d[i];\n\t\t\tty += d[i ^ 1];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &x[i][j]);\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int N = 25;\nconst int MEMO_LIM = (1<<23);\nbool adj[N][N];\nint up[N][N];\nint memo[MEMO_LIM][N];\nint n;\nvector<P> house;\n\nint near[N];\nint nearN[N];\nbool dame[N][N];\n\nvoid check(int an, int bn)\n{\n  P a = house[an];\n  P b = house[bn];\n  \n  if (a.first!=b.first && a.second!=b.second) {\n    return;\n  }\n\n  int st = 0;\n  if (a.second==b.second) {\n    int s = min(a.first, b.first);\n    int t = max(a.first, b.first);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].second!=a.second) continue;\n      int x = house[i].first;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n  else if (a.first==b.first) {\n    int s = min(a.second, b.second);\n    int t = max(a.second, b.second);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].first!=a.first) continue;\n      int x = house[i].second;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n\n  adj[an][bn] = adj[bn][an] = true;\n  up[an][bn] = up[bn][an] = st;\n}\n\nint f(int p, int st)\n{\n  if (p==n-1 && st==(1<<n)-1) {\n    return 1;\n  }\n  if (p==n-1 && st!=0) return 0;\n  \n  if (st < MEMO_LIM) {\n    if (memo[st][p]!=-1) {\n      return memo[st][p];\n    }\n  }\n\n  if ((st & near[n-1])==near[n-1]) {\n    if (st != (1<<(n-1))-1) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n  \n  for (int i=0; i < n-1; ++i) {\n    if ((st & near[i])==near[i] && (st&(1<<i))==0) {\n      return 0;\n    }\n  }\n\n  /*\n  static bool flag[N];\n  bool x = false;\n  fill(flag, flag+N, false);\n  for (int i=0; i < n; ++i) {\n    if ((st&(1<<i))!=0) continue;\n    if (flag[i]) continue;\n    if (x) return 0;\n    x = true;\n    queue<int> que;\n    que.push(i);\n    while (que.size()) {\n      int now = que.front();\n      que.pop();\n      if (flag[now]) continue;\n      flag[now] = true;\n      for (int j=0; j < n; ++j) {\n\tif (flag[j]) continue;\n\tif ((st&(1<<j)) > 0) continue;\n\tif (adj[now][j] == false) continue;\n\tif ((up[now][j] & st)>0) continue;\n\tque.push(j);\n      }\n    }\n  }\n  */\n  \n  int res = 0;\n\n  for (int i=0; i < n; ++i) {\n    if ((st&(1<<i))>0) continue;\n    if (adj[p][i]==false) continue;\n    if ((up[p][i] & st)>0) continue;\n    res += f(i, (st|(1<<i)));\n  }\n  \n  if (st < MEMO_LIM) {\n    memo[st][p] = res;\n  }\n  return res;\n}\n\nint main()\n{\n  int w, h;\n  while (cin>>w>>h) {\n    if (!w && !h) break;\n\n    fill(&adj[0][0], &adj[N-1][N], false);\n    fill(&up[0][0], &up[N-1][N], 0);\n\n    house.clear();\n    P ch;\n    for (int i=0; i < h; ++i) {\n      for (int j=0; j < w; ++j) {\n\tint val;\n\tcin >> val;\n\tif (val==1) {\n\t  house.push_back(P(i,j));\n\t}\n\telse if (val==2) {\n\t  ch = P(i,j);\n\t}\n      }\n    }\n\n    house.push_back(ch);\n\n    n = house.size();\n    for (int i=0; i < n; ++i) {\n      for (int j=i+1; j < n; ++j) {\n\tcheck(i, j);\n      }\n    }\n\n    for (int i=0; i < n; ++i) {\n      near[i] = 0;\n      for (int j=0; j < n; ++j) {\n\tif (adj[i][j] && up[i][j]==0) {\n\t  near[i] |= (1<<j);\n\t}\n      }\n    }\n\n    fill(&memo[0][0], &memo[MEMO_LIM-1][N], -1);\n    int ans = f(n-1, 0);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h,int k){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny],k-1);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(k >= 15) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    map<P,int> a;\n    dp = a;\n    cout << solve(1,0,c) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokann ga bokka--nn!!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nmap<P,int>ma;\nint f[15][15];\nint link[15][15];\nP za[25];\nint n,m;\nint val;\nint dp(int mask,int cur)\n{\n\tint ret=0;\n\tif(ma[mp(mask,cur)]) return ma[mp(mask,cur)];\n\tint x=za[cur].first;\n\tint y=za[cur].second;\n\tif(mask==(1<<val)-1)\n\t{\n\t\tif(x==za[23].first || y==za[23].second) return 1;\n\t\telse return 0;\n\t}\n\tfor(int i=x-1;i>=0;i--)\n\t{\n\t\tif(f[i][y]==1 && !((mask>>(link[i][y]))&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[i][y]),link[i][y]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=x+1;i<m;i++)\n\t{\n\t\tif(f[i][y]==1 && !((mask>>(link[i][y]))&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[i][y]),link[i][y]);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=y-1;i>=0;i--)\n\t{\n\t\tif(f[x][i]==1 && !((mask>>(link[x][i]))&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[x][i]),link[x][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=y+1;i<n;i++)\n\t{\n\t\tif(f[x][i]==1 && !((mask>>(link[x][i]))&1))\n\t\t{\n\t\t\tret+=dp(mask | (1<<link[x][i]),link[x][i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret) ma[mp(mask,cur)]=ret;\n\treturn ret;\n}\nint main(){\n\twhile(1)\n\t{\n\t\tcin >> n >> m;\n\t\tma.clear();\n\t\tif(!n) return 0;\n\t\tint num=0; val=0;\n\t\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++) { f[i][j]=INF; link[i][j]=-1;}\n\t\t\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t\tif(f[i][j]==1) { link[i][j]=num; za[num++]=mp(i,j); val++;}\n\t\t\t\tif(f[i][j]==2) za[23]=mp(i,j);\n\t\t\t}\n\t\t\n\t\t}\n\t\tcout << dp(0,23) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <iostream>\n#define fi first\n#define sec second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nint S;\nint ans;\nint cell[10][10];\nint dy[4] = {1,0,-1,0}, dx[4] = {0,1,0,-1};\nint used;\nmap<P,int> dp;\nvector<int> e[30][4]; //0 down 1 right 2 up 3 left\nvector<P> num;\n\nint A(int s,int cnt){\n\t/*\n\tif(dp[P(used,s)] > 0){\n\t\treturn dp[P(used,s)];\n\t}\n\t*/\n\tint ret = 0;\n\tcnt--;\n\tif(cnt == 0){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = 0; j < e[s][i].size(); j++){\n\t\t\t\tif(e[s][i][j] == S) ret++;\n\t\t\t}\n\t\t}\n\t\t//dp[P(used,s)] = ret;\n\t\treturn ret;\n\t}\n\tif(s != S) used += 1<<s;\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int j = 0; j < e[s][i].size(); j++){\n\t\t\tif(used>>e[s][i][j] & 1) continue;\n\t\t\tif(e[s][i][j] == S) continue;\n\t\t\tret += A(e[s][i][j],cnt);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(s != S) used -= 1<<s;\n\t//dp[P(used,s)] = ret;\n\treturn ret;\n}\n\nvoid solve(){\n\tans = 0;\n\tnum.clear();\n\tused = 0;\n\tdp.clear();\n\tfor(int i = 0; i < 30; i++){\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\te[i][j].clear();\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tscanf(\"%d\", &cell[i][j]);\n\t\t\tif(cell[i][j] != 0){\n\t\t\t\tif(cell[i][j] == 2) S = num.size();\n\t\t\t\tnum.push_back(P(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(cell[i][j] == 0) continue;\n\t\t\tint tmp;\n\t\t\tfor(int k = 0; k < num.size(); k++){\n\t\t\t\tif(num[k].fi == i && num[k].sec == j){\n\t\t\t\t\ttmp = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint y = i, x = j;\n\t\t\t\twhile(true){\n\t\t\t\t\ty += dy[k]; x += dx[k];\n\t\t\t\t\tif(0>y||y>=n||0>x||x>=m) break;\n\t\t\t\t\tif(cell[y][x] != 0){\n\t\t\t\t\t\tfor(int l = 0; l < num.size(); l++){\n\t\t\t\t\t\t\tif(num[l].fi == y && num[l].sec == x){\n\t\t\t\t\t\t\t\te[tmp][k].push_back(l);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans = A(S,num.size());\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &m, &n),n||m) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    auto s=make_v<Int>(h,w);\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    Int cnt=0;\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcnt+=s[i][j]==1;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};\n    \n    Int ans=0;\n    function<void(Int, Int, Int)> dfs=\n      [&](Int y,Int x,Int d){\n\tif(s[y][x]==-1) return;\n\tif(s[y][x]==2){\n\t  if(cnt==0) ans++;\n\t  if(~d) return;\n\t}\n\t\n        if(s[y][x]>=1){\n\t  if(s[y][x]==1){\n\t    cnt--;\n\t    s[y][x]=-1;\n\t  }\n\t  for(Int k=0;k<4;k++){\n\t    Int ny=y+dy[k],nx=x+dx[k],nd=k;\n\t    if(in(ny,nx)) dfs(ny,nx,nd);\n\t  }\n\t  if(s[y][x]==-1){\n\t    cnt++;\n\t    s[y][x]=1;\n\t  }\n\t}\n\t\n\tif(~d){\n\t  y+=dy[d];x+=dx[d];\n\t  if(in(y,x)) dfs(y,x,d);\n\t}\n      };\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) dfs(i,j,-1);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n//#include <ext/hash_map>\n#include <tr1/unordered_map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nusing namespace tr1;\n//using namespace __gnu_cxx;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n#define SZ 885777\n\n/*\nreal\t0m2.093s  --> \nreal\t0m2.000s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[25],hx[25],hy[25],edge[25][4][25]; //[src][dir][dest]\n//hash_map<int,int> hii(3000000);\nunordered_map<int,int> hii(SZ);\n\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\nint dfs(int S){\n  int src = S&((1<<5)-1);\n  int x = hx[src];\n  int y = hy[src];\n  int s = S>>5;\n\n  if( (1<<home)-1 == s ){ //ツ静「ツ妥篠づ可姪淞づェツづゥ\n    return 1;\n  }\n  if( isnotgoal(s) ){ //ツ仰ウツ嘉ッツづ可姪淞づゥツつスツづ淞づ個嘉づーツ湘氾ッツつオツつスツつゥツづつ、ツつゥ\n    return 0;\n  }\n  //hash_map<int,int>::iterator it = hii.find(S);\n  unordered_map<int,int>::iterator it = hii.find(S);\n  if( it!=hii.end() ){ //ツ探ツ催オツ催渉づ敖づ個湘ウツ妥板つゥツづつ、ツつゥ\n    return it->second;\n  }\n\n  // ツプツδ個ゼツδ督トツつェツ置ツつッツづ按つ「ツ嘉づ個有ツ鳴ウ\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<src)) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(((s|(1<<dest))<<5)|dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  hii.insert(make_pair(S,ret));\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    hii.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n    hx[home] = sx;\n    hy[home] = sy;\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(home));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int, int>;\nmap<tup, int> dp;\nint tb[10][10];\nint sr, sc;\nint hs;\n\nint dfs(int nr, int nc, int bits) {\n\tif (dp.count(tup{ nr,nc,bits })) return dp[tup{nr, nc, bits}];\n\tif (nr == sr && nc == sc && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if(~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(i, nc, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(i, nc, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(nr, j, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(nr, j, bits | 1 << x);\n\t}\n\t\n\treturn dp[tup{nr, nc, bits}] = res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tdp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tcout << dfs(sr, sc, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;\n    vis=0;\n    vis|=(1<<houseId[si][sj]);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n\n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;\n    qs.pop();\n\n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !( st_now.vis&(1<<houseId[next.fr][next.sc]) ) ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis|=(1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\n\t    if(st_next.cnt == nhouse){\n\t      for(int l = 0; l < MAXDIR; ++l){\n\t\tif( M[st_next.ni][st_next.nj].cexist[l] ){\n\t\t  ++ans;\n\t\t}\n\t      }\n\t      break;\n\t    }else{\n\t      qs.push( st_next );\n\t      break;\n\t    }\n\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n#define VI vector<int>\n#define VII vector<VI>\n\nusing namespace std;\n\n\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\n\nint N, M, I, J, num;\nVII mp;\n\nint solve(int x, int y, int cnt) {\n\tif (cnt == 0) {\n\t\tif (x == I || y == J) return 1;\n\t}\n\n\tint res = 0;\n\trep(i, 4) {\n\t\tint nx = x, ny = y;\n\t\twhile (true)\n\t\t{\n\t\t\tnx += dx[i], ny += dy[i];\n\t\t\tif (mp[nx][ny] == -1) break;\n\t\t\tif (mp[nx][ny] == 1) {\n\t\t\t\tmp[nx][ny] = 0;\n\t\t\t\tres += solve(nx, ny, cnt-1);\n\t\t\t\tmp[nx][ny] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> M >> N, M)\n\t{\n\t\tmp = VII(N + 2, VI(M + 2, -1));\n\t\tnum = 0;\n\t\tfor(int i=1; i<=N; i++) {\n\t\t\tfor(int j=1; j<=M; j++) {\n\t\t\t\tcin >> mp[i][j];\n\t\t\t\tif (mp[i][j] == 1) num++;\n\t\t\t\telse if (mp[i][j] == 2) {\n\t\t\t\t\tI = i; J = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(I, J, num) << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <bitset>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n#define pcout(y,x) cout << \"(\" << y << \",\" << x << \")\" << endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint w,h,x,y;\nint sx,sy,n;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nvector<vector<int> > v;\nvector<P> p;\nvector<int> next[25];\nmap<P, int> id;\n\nint ans = 0;\n\nbool can(int y,int x) {\n    if(0 <= y && y < h && 0 <= x && x < w) return true;\n    return false;\n}\n\nvoid dfs(int S, int y,int x) {\n    int now = id[P(y,x)];\n\n    bool flag = true;\n    rep(i,n) {\n        if(S & (1<<i)) continue;\n        flag = false;\n    }\n\n    vector<P> used;\n    rep(i,n) {\n        if(S & (1<<i)) used.push_back(make_pair(p[i].first, p[i].second) );\n    }\n\n    if(flag) {\n        if(x == sx) {\n            bool ch = true;\n\n            rep(i, next[now].size()) {\n                int j = next[now][i];\n                int ny = p[j].first;\n                int nx = p[j].second;\n\n                if(x == nx && min(y,sy) < ny && ny < max(y,sy) ) {\n                    ch = false;\n                }\n            }\n\n            if(ch) {\n                // cout << \"x:\" << x << \" \" << y << endl;\n                ans++;\n            }\n        } else if(y == sy) {\n            bool ch = true;\n\n            rep(i, next[now].size()) {\n                int j = next[now][i];\n                int ny = p[j].first;\n                int nx = p[j].second;\n\n                if(y == ny && min(x, sx) < nx && nx < max(x, sx) ) {\n                    ch = false;\n                }\n            }\n\n            if(ch) {\n                // cout << \"y:\" << x << \" \" << y << endl;\n                ans++;\n            }\n        }\n\n\n        return;\n    }\n\n\n    rep(i, next[now].size()) {\n        int j = next[now][i];\n        int ny = p[j].first;\n        int nx = p[j].second;\n\n        if(S & (1<<j)) continue;\n\n        bool ch = true;\n\n        rep(j,used.size()) {\n            int yy = used[i].first;\n            int xx = used[i].second;\n\n            if(x == xx && min(y, ny) < yy && yy < max(y, ny)) {\n                ch = false;\n            }\n\n            if(y == yy && min(x, nx) < xx && xx < max(x, nx)) {\n                ch = false;\n            }\n        }\n\n        if(ch) {\n            dfs(S | (1<<j) , ny, nx);\n        }\n    }\n\n    return;\n}\n\nint main() {\n\n    while(cin >> w >> h) {\n        if(w == 0 && h == 0) break;\n\n        p.clear();\n        id.clear();\n        v.resize(h);\n\n        int cnt = 0;\n\n        rep(i,h) {\n            v[i].resize(w);\n            rep(j,w) {\n                cin >> v[i][j];\n\n                if(v[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                } else if(v[i][j] == 1) {\n                    p.push_back( P(i,j));\n\n                    id[P(i,j)] = cnt;\n                    cnt++;\n                }\n            }\n        }\n\n        n = p.size();\n        rep(i,25) next[i].clear();\n\n        rep(i,h) {\n            rep(j,w) {\n                if(v[i][j] != 1) continue;\n                int me = id[P(i,j)];\n                REP(k,i+1,h) {\n                    if(v[k][j] == 1) {\n                        int to = id[P(k,j)];\n                        next[me].push_back(to);\n                    }\n                }\n\n                for(int k=i-1; k>=0; k--) {\n                    if(v[k][j] == 1) {\n                        int to = id[P(k,j)];\n                        next[me].push_back(to);\n                    }\n                }\n\n                REP(k,j+1,w) {\n                    if(v[i][k] == 1) {\n                        int to = id[P(i,k)];\n                        next[me].push_back(to);\n                    }\n                }\n\n                for(int k=j-1; k>=0 ; k--) {\n                    if(v[i][k] == 1) {\n                        int to = id[P(i,k)];\n                        next[me].push_back(to);\n                    }\n                }\n            }\n        }\n\n        rep(i,n) {\n            sort(next[i].begin(), next[i].end());\n        }\n\n        // rep(i,n) {\n        //     cout << p[i].first << \",\" << p[i].second << \" |\";\n        //     rep(j,next[i].size()) {\n        //         int iid = next[i][j];\n        //         cout << p[iid].first << \",\" << p[iid].second << \" \";\n        //     }\n        //     cout << endl;\n        // }\n\n\n        ans = 0;\n        dfs(0, sy, sx);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint vec[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint tab[12][12];\nint wx,wy;\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy;\n    nowx=nx;nowy=ny;\nLA:;\n   nowx++;\n   if(!(0<=nowx&&nowx<wx&&0<=nowy&&nowy<wy)) goto LB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB: ;        \n\n    nowx=nx,nowy=ny;\nMA:;\n   nowx--;\n   if(!(0<=nowx&&nowx<wx&&0<=nowy&&nowy<wy)) goto MB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto MB;\n   }\n   goto MA;\nMB: ;        \n\n    nowx=nx,nowy=ny;\nNA:;\n   nowy++;\n   if(!(0<=nowx&&nowx<wx&&0<=nowy&&nowy<wy)) goto NB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto NB;\n   }\n   goto NA;\nNB: ;        \n\n    nowx=nx,nowy=ny;\nOA:;\n   nowy--;\n   if(!(0<=nowx&&nowx<wx&&0<=nowy&&nowy<wy)) goto OB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;        \n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 23;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX && !(cnt >= 18 && sum == 0)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint m,n,k=0;\nint a[15][15];\nint ans=0,locx,locy;\n\nint solve(int x,int y){\n\tint ret=0;\n\tbool b=false;\n\tif(a[x][y]==1){a[x][y]=3; b=true; k--;}\n\tif(k==0){\n\t\ta[x][y]=1; k++;\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<1<<endl;\n\t\tfor(int i=x-1;i>=0;i--){\n\t\t\tif(a[i][y]==3)break;\n\t\t\tif(a[i][y]==2)return 1;\n\t\t}\n\t\tfor(int i=x+1;;i++){\n\t\t\tif(a[i][y]==3)break;\n\t\t\tif(a[i][y]==2)return 1;\n\t\t}\n\t\tfor(int j=y-1;j>=0;j--){\n\t\t\tif(a[x][j]==3)break;\n\t\t\tif(a[x][j]==2)return 1;\n\t\t}\n\t\tfor(int j=y+1;;j++){\n\t\t\tif(a[x][j]==3)break;\n\t\t\tif(a[x][j]==2)return 1;\n\t\t}\n\t\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<0<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=x-1;i>=0;i--){\n\t\tif(a[i][y]==3)break;\n\t\tif(a[i][y]==1)ret+=solve(i,y);\n\t}\n\tfor(int i=x+1;;i++){\n\t\tif(a[i][y]==3)break;\n\t\tif(a[i][y]==1)ret+=solve(i,y);\n\t}\n\tfor(int j=y-1;j>=0;j--){\n\t\tif(a[x][j]==3)break;\n\t\tif(a[x][j]==1)ret+=solve(x,j);\n\t}\n\tfor(int j=y+1;;j++){\n\t\tif(a[x][j]==3)break;\n\t\tif(a[x][j]==1)ret+=solve(x,j);\n\t}\n\tif(b){a[x][y]=1; k++;}\n\t//cout<<\"solve(\"<<x<<\",\"<<y<<\")=\"<<ret<<endl;\n\treturn ret;\n}\n\nint main(){\n\tfor(int i=0;i<15;i++)for(int j=0;j<15;j++)a[i][j]=3;\n\tscanf(\"%d%d\",&m,&n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\tif(a[i][j]==1)k++;\n\t\t\tif(a[i][j]==2){locx=i; locy=j;}\n\t\t}\n\t}\n\tans=solve(locx,locy);\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <tuple>\n#include <vector>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#include <numeric>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <array>\n#include <string>\n#include <stack>\n#include <cassert>\n#include <memory>\nstruct Coordinate {\n\tint x, y;\n\tCoordinate operator+(const Coordinate that) const {\n\t\treturn Coordinate{ x + that.x, y + that.y };\n\t}\n};\n\nconstexpr std::array<Coordinate, 4> direction{ Coordinate{1, 0}, Coordinate{-1, 0}, Coordinate{0, 1}, Coordinate{0, -1} };\nint count_route(const Coordinate current, const int delivered, const std::vector<std::vector<int>>& state) {\n\tint count{ 0 };\n\tfor (const auto dir : direction) {\n\t\tfor (auto next = current + dir; 0 <= next.x && next.x < state.size() && 0 <= next.y && next.y < state[next.x].size(); next = next + dir) {\n\t\t\tif (state[next.x][next.y] == -1) {\n\t\t\t\tif (delivered == 0) {\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (state[next.x][next.y] > 0) {\n\t\t\t\tif ((delivered & (1 << (state[next.x][next.y] - 1))) != 0) {\n\t\t\t\t\tcount += count_route(next, delivered ^ (1 << (state[next.x][next.y] - 1)), state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nint main() {\n\tint m, n; std::cin >> m >> n;\n\twhile (m != 0 && n != 0) {\n\t\tstd::vector<std::vector<int>> state(n, std::vector<int>(m));\n\t\tfor (auto& line : state) for (auto& cell : line) std::cin >> cell;\n\t\tCoordinate start{ -1, -1 };\n\t\tint count{ 0 };\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tfor (auto j = 0; j < m; ++j) {\n\t\t\t\tif (state[i][j] == 2) {\n\t\t\t\t\tstart = Coordinate{ i, j };\n\t\t\t\t\tstate[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tif (state[i][j] == 1) {\n\t\t\t\t\tstate[i][j] = ++count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << count_route(start, (1 << count) - 1, state) << '\\n';\n\t\tstd::cin >> m >> n;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n, coun, s;\nint dp[25][1024 * 1024 * 16], town[11][11];\nP p[25];\nvoid bfs(int now, int flag);\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tcoun = 1;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\ts = coun;\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = coun;\n\t\t\t\t\tp[coun] = make_pair(i, j);\n\t\t\t\t\tcoun++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for (i = 1; i <= n;i++){\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcout << town[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tbfs(s, 0);\n\t\tj = 1;\n\t\tfor (i = 0; i < coun - 1; i++)\n\t\t\tj = j * 2;\n\t\tcout << dp[s][j - 1] << endl;\n\n\t}\n}\nvoid bfs(int start, int flag) {\n\tdp[start][flag] = 1;\n\tvector<P> que;\n\tque.push_back(make_pair(flag, start));\n\twhile (!que.empty()) {\n\t\t//cout << que.size()<<' ';\n\t\tP pp;\n\t\tpp = que[0];\n\t\tstart = pp.second; flag = pp.first;\n\t\t//cout << start << ' ' <<  static_cast<std::bitset<24> >(flag)  << endl;\n\t\tque.erase(que.begin());\n\t\tif (flag & 1 << (s - 1)) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = p[start].second; j <= m; j++) {\n\t\t\tif (town[p[start].first][j]&&j!=p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]-1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tif (dp[town[p[start].first][j]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].second; j >= 1; j--) {\n\t\t\tif (town[p[start].first][j]&&j != p[start].second) {\n\t\t\t\tif (flag & 1 << (town[p[start].first][j]- 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[p[start].first][j] - 1);\n\t\t\t\t\tif (dp[town[p[start].first][j]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[p[start].first][j]));\n\t\t\t\t\t\t//\tcout << 2 << endl;\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[p[start].first][j]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j <= n; j++) {\n\t\t\tif (town[j][p[start].second]&& j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tif (dp[town[j][p[start].second]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t\t\t//\tcout << 3 << endl;\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (j = p[start].first; j >= 1; j--) {\n\t\t\tif (town[j][p[start].second] && j != p[start].first) {\n\t\t\t\tif (flag & 1 << (town[j][p[start].second] - 1)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint flag2 = flag | 1 << (town[j][p[start].second] - 1);\n\t\t\t\t\tif (dp[town[j][p[start].second]][flag2] == 0) {\n\t\t\t\t\t\tque.push_back(make_pair(flag2, town[j][p[start].second]));\n\t\t\t\t\t\t//cout << 4 << endl;\n\t\t\t\t\t\t//cout << j << ' ' << flag2 << ' ' << p[start].first << endl;\n\t\t\t\t\t}\n\t\t\t\t\tdp[town[j][p[start].second]][flag2] += dp[town[p[start].first][p[start].second]][flag];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007\n#define INF 1000000000\n#define LLINF 2000000000000000000LL\n\nint m,n;\nint mm[10][10]={0};\nint ch_y,ch_x;\nint mo4[] = {0,1,0,-1,0};\nint max_v = 1;\n\nmap<pair<pair<int,int>,int>,int> memo;\n\n//int memo[10][10][1<<23]={0};\n\nint dfs(int y,int x,int v){\n    int ret = 0;\n    \n    if(memo[{{y,x},v}]) return memo[{{y,x},v}];\n    \n    //fprintf(stderr,\"(%2d,%2d) : %d\\n\",x,y,v);\n    \n    for(int i=0;i<4;i++){\n        int tox = x,toy = y;\n        \n        while(1){\n            tox += mo4[i];\n            toy += mo4[i+1];\n            \n            if(tox<0 || m<=tox || toy<0 || n<=toy) break;\n            \n            \n            if(mm[toy][tox]==0) continue;\n            \n            if(mm[toy][tox]==-1){\n                if(max_v == v){\n                    return 1;\n                }else{\n                    continue;\n                }\n            }\n            \n            if(mm[toy][tox]&v) continue;\n            \n            ret += dfs(toy,tox,v|mm[toy][tox]);\n            break;\n        }\n    }\n    \n    //fprintf(stderr,\"memo[%2d][%2d][%2d] = %lld\\n\",x,y,v,ret%mod);\n    \n    return memo[{{y,x},v}] = ret;\n}\n\n\nvoid calc(int m,int n){\n    \n    //memset(memo,0,sizeof(memo));\n    \n    memo.clear();\n    \n    max_v = 1;\n    \n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&mm[i][j]);\n            \n            if(mm[i][j]==1){\n                mm[i][j] = max_v;\n                max_v*=2;\n            }else if(mm[i][j]==2){\n                mm[i][j] = -1;\n                ch_y = i;\n                ch_x = j;\n            }\n        }\n    }\n    \n    max_v--;\n    \n    printf(\"%d\\n\",dfs(ch_y,ch_x,0));\n    \n    return;\n}\n\nint main(){\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(m==0) break;\n        calc(m,n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint W, H, N;\nint mas[11][11];\nbool isin(int y, int x)\n{\n    return (y >= 0 && x >= 0 && y < H && x < W);\n}\nint dfs(int y, int x, int bit)\n{\n    int ret = 0;\n    if(bit == 0) return (1);\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        while(isin(ny, nx) && (mas[ny][nx] < 0 || (bit != (1 << N) && mas[ny][nx] == N) || (bit & ~(1 << mas[ny][nx])) == bit)) ny += dy[i], nx += dx[i];\n        if(isin(ny, nx)) ret += dfs(ny, nx, bit & ~(1 << mas[ny][nx]));\n    }\n    return (ret);\n}\n\nint main()\n{\n    int px, py;\n    while(cin >> W >> H, W || H) {\n        N = 0;\n        for(int i = 0; i < H; i++) {\n            for(int j = 0; j < W; j++) {\n                cin >> mas[i][j];\n                if(mas[i][j] == 0) mas[i][j] = -1;\n                else if(mas[i][j] == 1) mas[i][j] = N, N++;\n                else py = i, px = j;\n            }\n        }\n        mas[py][px] = N;\n        cout << dfs(py, px, (1 << (N + 1)) - 1) << endl;\n    }\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int N = 24;\nconst int MEMO_LIM = (1<<23);\nbool adj[N][N];\nint up[N][N];\nint memo[MEMO_LIM][N];\nint n;\nvector<P> house;\n\nint near[N];\n\nvoid check(int an, int bn)\n{\n  P a = house[an];\n  P b = house[bn];\n  \n  if (a.first!=b.first && a.second!=b.second) {\n    return;\n  }\n\n  int st = 0;\n  if (a.second==b.second) {\n    int s = min(a.first, b.first);\n    int t = max(a.first, b.first);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].second!=a.second) continue;\n      int x = house[i].first;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n  else if (a.first==b.first) {\n    int s = min(a.second, b.second);\n    int t = max(a.second, b.second);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].first!=a.first) continue;\n      int x = house[i].second;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n\n  adj[an][bn] = adj[bn][an] = true;\n  up[an][bn] = up[bn][an] = st;\n}\n\nint f(int p, int st)\n{\n  if (p==n-1 && st==(1<<n)-1) {\n    return 1;\n  }\n  if (p==n-1 && st!=0) return 0;\n  \n  if (st < MEMO_LIM) {\n    if (memo[st][p]!=-1) {\n      return memo[st][p];\n    }\n  }\n\n  if ((st & near[n-1])==near[n-1]) {\n    if (st != (1<<(n-1))-1) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n  for (int i=0; i < n-1; ++i) {\n    if ((st & near[i])==near[i] && (st&(1<<i))==0) {\n      if (st < MEMO_LIM) {\n\tmemo[st][p] = 0;\n      }\n      return 0;\n    }\n  }\n\n  int res = 0;\n\n  for (int i=0; i < n; ++i) {\n    if (!(((st&(1<<i))>0)\n\t  ||(adj[p][i]==false)\n\t  ||(up[p][i] & st)>0)) {\n      res += f(i, (st|(1<<i)));\n    }\n  }\n  \n  if (st < MEMO_LIM) {\n    return memo[st][p] = res;\n  }\n  return res;\n}\n\nint main()\n{\n  int w, h;\n  while (cin>>w>>h) {\n    if (!w && !h) break;\n\n    fill(&adj[0][0], &adj[N-1][N], false);\n    fill(&up[0][0], &up[N-1][N], 0);\n\n    house.clear();\n    P ch;\n    for (int i=0; i < h; ++i) {\n      for (int j=0; j < w; ++j) {\n\tint val;\n\tcin >> val;\n\tif (val==1) {\n\t  house.push_back(P(i,j));\n\t}\n\telse if (val==2) {\n\t  ch = P(i,j);\n\t}\n      }\n    }\n\n    house.push_back(ch);\n\n    n = house.size();\n    for (int i=0; i < n; ++i) {\n      for (int j=i+1; j < n; ++j) {\n\tcheck(i, j);\n      }\n    }\n\n    for (int i=0; i < n; ++i) {\n      near[i] = 0;\n      for (int j=0; j < n; ++j) {\n\tif (adj[i][j] && up[i][j]==0) {\n\t  near[i] |= (1<<j);\n\t}\n      }\n    }\n\n    //memset(memo, sizeof(memo), 255);\n    int lim = min((1<<n),MEMO_LIM);\n    for (int i=0; i < lim; ++i) {\n      for (int j=0; j < n; ++j) {\n\tmemo[i][j] = -1;\n      }\n    }\n    //fill(&memo[0][0], &memo[MEMO_LIM-1][N], -1);\n    int ans = f(n-1, 0);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<int, map<char, int>>dp;\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[1 << dat[nx][ny]][dat[nx][ny]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find(i) == dp.end() || dp[i].find(j) == dp[i].end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[i | 1 << dat[nx][ny]][dat[nx][ny]] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n\nconstexpr int MAX = 10;\n\nint w, h;\nint board[MAX][MAX];\nint dx[4] = { 1,-1,0,0 }, dy[4] = { 0,0,1,-1 };\n\nbool check_pre() {\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tif (board[i][j] == 1)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint dfs(int x, int y) {\n\tint res = 0;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\twhile (0 <= nx&&nx < w &&\n\t\t\t0 <= ny&&ny < h&&board[ny][nx] != -1) {\n\t\t\tif (check_pre()) {\n\t\t\t\tif (board[ny][nx] == 1) {\n\t\t\t\t\tboard[ny][nx] = -1;\n\t\t\t\t\tres += dfs(nx, ny);\n\t\t\t\t\tboard[ny][nx] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (board[ny][nx] == 2)\n\t\t\t\t\tres = 1;\n\t\t\t}\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t}\n\t}\n\treturn res;\n}\n\nint sx, sy;\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> w >> h;\n\n\t\tif (w + h == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tstd::cin >> board[i][j];\n\t\t\t\tif (board[i][j] == 2) {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << dfs(sx, sy) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint m;\nint n;\nint map[10][10] = {0};\nint cnt = 0;\nint churchx;\nint churchy;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n\nint saiki( int xinput, int yinput, int nokori ) {\n\tfor ( int i = 0; i < 4; i++ ) {\n\t\tint x = xinput;\n\t\tint y = yinput;\n\t\tif ( nokori == 0 ) {\n\t\t\tif ( y == churchy && x > churchx && i != 0 ) continue;\n\t\t\tif ( y == churchy && x < churchx && i != 1 ) continue;\n\t\t\tif ( x == churchx && y > churchy && i != 2 ) continue;\n\t\t\tif ( x == churchx && y < churchy && i != 3 ) continue;\n\t\t}\n\t\twhile(true) {\n\t\t\tx += dx[i];\n\t\t\ty += dy[i];\n\t\t\tif ( x < 0 || x >= m || y < 0 || y >= n ) break;\n\t\t\tif ( map[x][y] == 1 ) {\n\t\t\t\tmap[x][y] = 0;\n\t\t\t\tsaiki( x, y, nokori-1 );\n\t\t\t\tmap[x][y] = 1;\n\t\t\t\tbreak;\n\t\t\t}else if ( map[x][y] == 2 ) {\n\t\t\t\tif ( nokori == 0 ) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if ( map[x][y] == 3 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> m;\n\t\tcin >> n;\n\t\tif ( m == 0 ) break;\n\t\tint nokori = 0;\n\t\tfor ( int i = 0; i < n; i++ ) {\n\t\t\tfor ( int j = 0; j < m; j++ ) {\n\t\t\t\tcin >> map[j][i];\n\t\t\t\tif ( map[j][i] == 1 ) {\n\t\t\t\t\tnokori++;\n\t\t\t\t}else if ( map[j][i] == 2 ) {\n\t\t\t\t\tchurchx = j;\n\t\t\t\t\tchurchy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( nokori == 0 ) {\n\t\t\tcout << \"1\" << endl;\n\t\t}else {\n\t\t\tcnt = 0;\n\t\t\tsaiki( churchx, churchy, nokori );\n\t\t\tcout << cnt << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w;\nint m[16][16];\n\nint n;\nint sy, sx;\n\nint dfs(int y, int x, int b = (1 << n) - 1)\n{\n  if (b == 0){\n    return (y == sy || x == sx);\n  }\n\n  int ret = 0;\n  for (int i = y - 1; i >= 0; i--){\n    if (m[i][x] == -1) continue;\n    if (b & (1 << m[i][x])){\n      ret += dfs(i, x, b - (1 << m[i][x]));\n      break;\n    }\n  }\n  for (int i = y + 1; i < h; i++){\n    if (m[i][x] == -1) continue;\n    if (b & (1 << m[i][x])){\n      ret += dfs(i, x, b - (1 << m[i][x]));\n      break;\n    }\n  }\n  for (int i = x - 1; i >= 0; i--){\n    if (m[y][i] == -1) continue;\n    if (b & (1 << m[y][i])){\n      ret += dfs(y, i, b - (1 << m[y][i]));\n      break;\n    }\n  }\n  for (int i = x + 1; i < w; i++){\n    if (m[y][i] == -1) continue;\n    if (b & (1 << m[y][i])){\n      ret += dfs(y, i, b - (1 << m[y][i]));\n      break;\n    }\n  }\n\n  return ret;\n}\n\nint main()\n{\n  while (cin >> w >> h, w){\n    n = 0;\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        cin >> m[i][j];\n        if (m[i][j] == 0) m[i][j] = -1;\n        if (m[i][j] == 2) {\n          sy = i; sx = j;\n          m[i][j] = -1;\n        }\n        if (m[i][j] == 1) m[i][j] = n++;\n      }\n    }\n\n    cout << dfs(sy, sx) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nstruct Info{\n\tInfo(int arg_state,int arg_row,int arg_col){\n\t\tstate = arg_state;\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint state,row,col;\n};\n\n\nint base_map[10][10],house_index[10][10];\nint H,W;\nint POW[24],diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nqueue<Info> Q;\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\thouse_index[row][col] = -1;\n\t\t}\n\t}\n\n\tint church_row,church_col;\n\n\tint index = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&base_map[row][col]);\n\t\t\tif(base_map[row][col] == 1){\n\t\t\t\thouse_index[row][col] = index++;\n\t\t\t}else if(base_map[row][col] == 2){\n\t\t\t\tchurch_row = row;\n\t\t\t\tchurch_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0,finish_state = POW[index]-1;\n\n\n\tQ.push(Info(0,church_row,church_col));\n\n\tint next_row,next_col,next_state;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().state == finish_state){\n\t\t\tif(Q.front().row == church_row || Q.front().col == church_col){\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_row = Q.front().row+diff_row[i];\n\t\t\t\tnext_col = Q.front().col+diff_col[i];\n\n\t\t\t\twhile(rangeCheck(next_row,next_col) == true &&\n\t\t\t\t\t((base_map[next_row][next_col] != 1) || ((Q.front().state & (1 << house_index[next_row][next_col])) != 0))){\n\t\t\t\t\tnext_row += diff_row[i];\n\t\t\t\t\tnext_col += diff_col[i];\n\t\t\t\t}\n\n\t\t\t\tif(!rangeCheck(next_row,next_col))continue;\n\n\t\t\t\tnext_state = Q.front().state+POW[house_index[next_row][next_col]];\n\t\t\t\tQ.push(Info(next_state,next_row,next_col));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tfor(int i = 0; i < 24; i++)POW[i] = pow(2,i);\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <memory>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint field[12][12];\nint nums[12][12];\nmap<P, bool> ng;\n\nint dfs(int state, int x, int y){\n  if(ng[P(state, nums[y][x])]) return 0;\n  if(state == 0){\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      while(field[y2][x2] == 0){\n\ty2 += dy[i];\n\tx2 += dx[i];\n      }\n      if(field[y2][x2] == 2) return 1;\n    }\n    ng[P(state, nums[y][x])] = true;\n    return 0;\n  }\n  int res = 0;\n  rep(i, 4){\n    int x2 = x + dx[i];\n    int y2 = y + dy[i];\n    while(field[y2][x2] != 3){\n      if(field[y2][x2] == 1){\n\tfield[y2][x2] = 3;\n\tres += dfs(state - (1 << nums[y2][x2]), x2, y2);\n\tfield[y2][x2] = 1;\n      }\n      x2 += dx[i];\n      y2 += dy[i];\n    }\n  }\n  if(res == 0) ng[P(state, nums[y][x])] = true;\n  return res;\n}\n\n\nint main(){\n  int n, m, sx, sy, cnt;\n  while(cin >> m >> n && (n || m)){\n    cnt = 0;\n    fill(&field[0][0], &field[11][11] + 1, 3);\n    memset(nums, 0, sizeof(nums));\n    ng.clear();\n    rep(i, n){\n      rep(j, m){\n\tcin >> field[i+1][j+1];\n\tif(field[i+1][j+1] == 2){\n\t  sx = j + 1;\n\t  sy = i + 1;\n\t}\n\tif(field[i+1][j+1] == 1){\n\t  nums[i+1][j+1] = cnt++;\n\t}\n      }\n    }\n    cout << dfs((1 << cnt) - 1, sx, sy) << endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\ndeque<int> edge[24][4];\nint n;\n//int dp[24][1 << 23];\nmap<int, map<int, int> > dp;\nint dfs(int p, int visit)\n{\n\tif (dp[p].count(visit))\n\t\treturn dp[p][visit];\n\telse if (!visit)\n\t{\n\t\tbool f = false;\n\t\trep (i, 4)\n\t\t\tforeach (e, edge[p][i])\n\t\t\t\tf |= *e == n;\n\t\treturn dp[p][visit] = f ? 1 : 0;\n\t\t//return f ? 1 : 0;\n\t}\n\n\tint res = 0;\n\trep (i, 4)\n\t{\n\t\tforeach (e, edge[p][i])\n\t\t{\n\t\t\tif (*e == n)\n\t\t\t\tcontinue;\n\n\t\t\tif (visit & (1 << *e))\n\t\t\t{\n\t\t\t\tres += dfs(*e, visit ^ (1 << *e));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[p][visit] = res;\n\t//return res;\n}\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w | h)\n\t{\n\t\trep (i, 24)\n\t\t\trep (j, 4)\n\t\t\t\tedge[i][j].clear();\n\n\t\tpint church;\n\t\tvector<pint> pos;\n\t\trep (i, h)\n\t\t{\n\t\t\trep (j, w)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif (t == 1)\n\t\t\t\t\tpos.push_back(pint(j, i));\n\t\t\t\telse if (t == 2)\n\t\t\t\t\tchurch = pint(j, i);\n\t\t\t}\n\t\t}\n\t\tn = pos.size();\n\t\tpos.push_back(church);\n\n\t\trep (i, pos.size())\n\t\t{\n\t\t\tvector<pint> hor, ver;\n\t\t\trep (j, pos.size())\n\t\t\t{\n\t\t\t\tif (pos[i].first == pos[j].first)\n\t\t\t\t\tver.push_back(pint(pos[j].second, j));\n\t\t\t\telse if (pos[i].second == pos[j].second)\n\t\t\t\t\thor.push_back(pint(pos[j].first, j));\n\t\t\t}\n\t\t\tsort(all(hor));\n\t\t\tsort(all(ver));\n\n\t\t\tforeach (it, hor)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].first)\n\t\t\t\t\tedge[i][3].push_front(it->second);\n\t\t\t\telse if (pos[i].first < it->first)\n\t\t\t\t\tedge[i][1].push_back(it->second);\n\t\t\t}\n\t\t\tforeach (it, ver)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].second)\n\t\t\t\t\tedge[i][2].push_front(it->second);\n\t\t\t\telse if (pos[i].second < it->first)\n\t\t\t\t\tedge[i][0].push_back(it->second);\n\t\t\t}\n\t\t}\n\n\t\t//rep (i, n + 1)\n\t\t//{\n\t\t//\tprintf(\">%d: (%d, %d)\\n\", i, pos[i].first, pos[i].second);\n\t\t//\trep (j, 4)\n\t\t//\t{\n\t\t//\t\tprintf(\"%d: \", j);\n\t\t//\t\tforeach (t, edge[i][j])\n\t\t//\t\t\tprintf(\"(%d, %d) \", pos[*t].first, pos[*t].second);\n\t\t//\t\tputs(\"\");\n\t\t//\t}\n\t\t//}\n\n\t\t//memset(dp, ~0, sizeof(dp));\n\t\tdp.clear();\n\t\tint all_visit = (1 << n) - 1;\n\t\tprintf(\"%d\\n\", dfs(n, all_visit));\n\n\t\t//int s = 0;\n\t\t//rep (i, n)\n\t\t//\tif (~dp[i][0])\n\t\t//\t\ts += dp[i][0];\n\t\t//printf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <set>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nint n;\nvector<vector<vector<int> > > to;\nvector<bool> isToZero;\n\nint dfs(int curr, bitset<24> bs){\n    if(bs.count() == n){\n        if(isToZero[curr])\n            return 1;\n        else\n            return 0;\n    }\n\n    int ret = 0;\n    for(int i=0; i<4; ++i){\n        unsigned j = 0;\n        while(j < to[curr][i].size() && bs[to[curr][i][j]])\n            ++ j;\n        if(j < to[curr][i].size()){\n            j = to[curr][i][j];\n            bs[j] = true;\n            ret += dfs(j, bs);\n            bs[j] = false;\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        n = 1;\n        vector<int> y(1), x(1);\n        vector<vector<int> > grid(h, vector<int>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> grid[i][j];\n                if(grid[i][j] == 1){\n                    y.push_back(i);\n                    x.push_back(j);\n                    grid[i][j] = n;\n                    ++ n;\n                }else if(grid[i][j] == 2){\n                    y[0] = i;\n                    x[0] = j;\n                    grid[i][j] = 0;\n                }else{\n                    grid[i][j] = -1;\n                }\n            }\n        }\n\n        to.assign(n, vector<vector<int> >(4, vector<int>(0)));\n        isToZero.assign(n, false);\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                int y1 = y[i] + dy[j];\n                int x1 = x[i] + dx[j];\n                while(0 <= y1 && y1 < h && 0 <= x1 && x1 < w){\n                    if(grid[y1][x1] != -1){\n                        int k = grid[y1][x1];\n                        if(k == 0)\n                            isToZero[i] = true;\n                        else\n                            to[i][j].push_back(k);\n                    }\n                    y1 += dy[j];\n                    x1 += dx[j];\n                }\n            }\n        }\n\n        cout << dfs(0, 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nenum Direction {\n    EAST, WEST, NORTH, SOUTH\n};\n\nstruct Home {\n    int index;\n    Home *neighbor[4];\n};\n\nconst int GOAL = 100;\n\nHome homes[10][10];\n\nint dfs(Home *cur, int mask, int rem) {\n    int sum = 0;\n\n    for(int dir = 0; dir < 4; ++dir) {\n        Home *next = cur->neighbor[dir];\n        while(next) {\n            if(rem == 0) {\n                if(next->index == GOAL) return 1;\n            }\n            if(next->index != GOAL && (mask&(1<<next->index))) break;\n            if(next->index != GOAL) sum += dfs(next, mask|(1<<next->index), rem-1);\n            next = next->neighbor[dir];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> M >> N;\n        if(!N && !M) break;\n\n        memset(homes, 0, sizeof(homes));\n        for(int i = 0; i < 10; ++i) {\n            for(int j = 0; j < 10; ++j) {\n                homes[i][j].index = -1;\n            }\n        }\n\n        int home_idx = 0;\n        int rem = 0;\n        int sr, sc;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < M; ++j) {\n                int val;\n                cin >> val;\n                if(val != 0) {\n                    if(val == 1) {\n                        homes[i][j].index = home_idx++;\n                        ++rem;\n                    }\n                    else {\n                        homes[i][j].index = GOAL;\n                        sr = i;\n                        sc = j;\n                    }\n\n                    for(int jj = j-1; jj >= 0; --jj) {\n                        if(homes[i][jj].index != -1) {\n                            homes[i][jj].neighbor[EAST] = &homes[i][j];\n                            homes[i][j].neighbor[WEST] = &homes[i][jj];\n                            break;\n                        }\n                    }\n                    for(int ii = i-1; ii >= 0; --ii) {\n                        if(homes[ii][j].index != -1) {\n                            homes[ii][j].neighbor[SOUTH] = &homes[i][j];\n                            homes[i][j].neighbor[NORTH] = &homes[ii][j];\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        cout << dfs(&homes[sr][sc], 0, rem) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint px[24],py[24],kx,ky;\nint num[24][4] = {0};\n\nint H,W,N,ans;\nint field[12][12] = {0};\n\nint dx[] = {0,-1,0,1} , dy[] = {1,0,-1,0};\nbool done[12][12];\n\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit){\n\tif(memo[pos].find(bit) != memo[pos].end() )return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\trep(d,4){\n\t\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\t\twhile( field[cy][cx] != -1){\n\t\t\t\tif(field[cy][cx] == 64)return 1;\n\t\t\t\tcy += dy[d] , cx += dx[d];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\trep(d,4){\n\t\tint cx = px[pos]+dx[d] , cy = py[pos]+dy[d];\n\t\twhile( field[cy][cx] == -2 || done[cy][cx] == 1 || field[cy][cx] == 64){\n\t\t\tcy += dy[d] , cx += dx[d];\n\t\t}\n\t\tif(field[cy][cx] != -1){\n\t\t\tdone[cy][cx] = 1;\n\t\t\tans += dfs(field[cy][cx],bit | (1<<field[cy][cx]) );\n\t\t\tdone[cy][cx] = 0;\n\t\t}\n\t}\n\tif(__builtin_popcount(bit) < 15){\n\t\treturn memo[pos][bit] = ans;\n\t}else{\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\twhile(cin >> W >> H ,W){\n\t\tN = ans = 0;\n\t\trep(i,24)rep(j,4)num[i][j] = -1;\n\t\trep(i,12)rep(j,12)field[i][j] = -1;\n\t\trep(i,H)rep(j,W){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tswitch(t){\n\t\t\tcase 0:\n\t\t\t\tfield[i+1][j+1] = -2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfield[i+1][j+1] = N;\n\t\t\t\tpx[N] = j+1, py[N] = i+1;\n\t\t\t\tN++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tkx = j+1 , ky = i+1;\n\t\t\t\tfield[i+1][j+1] = 64;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpx[N] = kx , py[N] = ky;\n\t\trep(i,24)memo[i].clear();\n\t\tcout << dfs(N,0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint DP[1<<23][23];\nint M,N;\nint board[10][10];\nint X[25];int Y[25];\nint KX,KY;\nint main()\n{\n\tscanf(\"%d%d\",&M,&N);\n\tint house=1;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<M;j++){\n\t\t\tscanf(\"%d\",&board[i][j]);\n\t\t\tif(board[i][j]==1){\n\t\t\t\tboard[i][j]=house;\n\t\t\t\tX[house]=i;Y[house]=j;\n\t\t\t\thouse++;\n\t\t\t}\n\t\t\telse if(board[i][j]==2){\n\t\t\t\tboard[i][j]=30;\n\t\t\t\tKX=i;KY=j;\n\t\t\t}\n\t\t}\n\t}\n\thouse--;\n\tfor(int i=0;i<house;i++){\n\t\tif(X[i+1]!=KX&&Y[i+1]!=KY)continue;\n\t\tDP[(1<<i)][i]=1;\n\t}\n\tfor(int i=1;i<(1<<house);i++){\n\t\tfor(int j=0;j<house;j++){\n\t\t\tif(!((i>>j)&1))continue;\n\t\t\tif(DP[i][j]>0)continue;\n\t\t\tint nowX=X[j+1];int nowY=Y[j+1];\n\t\t\tfor(int k=0;k<house;k++){\n\t\t\t\tif(j==k)continue;\n\t\t\t\tif(!((i>>k)&1))continue;\n\t\t\t\tint befoX=X[k+1];int befoY=Y[k+1];\n\t\t\t\tif(nowX!=befoX&&nowY!=befoY)continue;\n\t\t\t\tif(nowX==befoX){\n\t\t\t\t\tfor(int l=min(nowY,befoY)+1;l<max(nowY,befoY);l++){\n\t\t\t\t\t\tif(board[nowX][l]>=1&&board[nowX][l]<=25){\n\t\t\t\t\t\t\tif((i>>(board[nowX][l]-1))&1)goto a56;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int l=min(nowX,befoX)+1;l<max(nowX,befoX);l++){\n\t\t\t\t\t\tif(board[l][nowY]>=1&&board[l][nowY]<=25){\n\t\t\t\t\t\t\tif((i>>(board[l][nowY]-1))&1)goto a56;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDP[i][j]+=DP[i-(1<<j)][k];\n\t\t\t\ta56:;\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<house;i++){\n\t\tif(X[i+1]!=KX&&Y[i+1]!=KY)continue;\n\t\tif(KX==X[i+1]){\n\t\t\tfor(int l=min(Y[i+1],KY)+1;l<max(Y[i+1],KY);l++){\n\t\t\t\tif(board[KX][l]>=1&&board[KX][l]<=25)goto b56;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int l=min(X[i+1],KX)+1;l<max(X[i+1],KX);l++){\n\t\t\t\tif(board[l][KY]>=1&&board[l][KY]<=25)goto b56;\n\t\t\t}\n\t\t}\n\t\tans+=DP[(1<<house)-1][i];\n\t\tb56:;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 19;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s, int &order)\n{\n\torder++;\n\tint noBits = CountBit(s);\n\tif (x == sx && y == sy && noBits == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (noBits < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0, cnt = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, noBits))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]), cnt);\n\t}\n\torder += cnt;\n\tif (noBits < MAX && !(noBits >= 14 && cnt <= 10)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0, cnt));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nint W, H, N;\nint mas[11][11];\nbool isin(int y, int x)\n{\n    return (y >= 0 && x >= 0 && y < H && x < W);\n}\nint dfs(int y, int x, int bit)\n{\n    int ret = 0;\n    if(bit == 0) return (1);\n    for(int i = 0; i < 4; i++) {\n        int ny = y + dy[i], nx = x + dx[i];\n        while(isin(ny, nx) && (mas[ny][nx] < 0 || (bit != (1 << N) && mas[ny][nx] == N) || (bit & ~(1 << mas[ny][nx])) == bit)) ny += dy[i], nx += dx[i];\n        if(isin(ny, nx)) ret += dfs(ny, nx, bit & ~(1 << mas[ny][nx]));\n    }\n    return (ret);\n}\n\nint main()\n{\n    int px, py, N = 0;\n    while(cin >> W >> H, W || H) {\n        for(int i = 0; i < H; i++) {\n            for(int j = 0; j < W; j++) {\n                cin >> mas[i][j];\n                if(mas[i][j] == 0) mas[i][j] = -1;\n                else if(mas[i][j] == 1) mas[i][j] = N, N++;\n                else py = i, px = j;\n            }\n        }\n        mas[py][px] = N;\n        cout << dfs(py, px, (1 << (N + 1)) - 1) << endl;\n    }\n    return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint c[10][10];\nint w,h;\nint sx,sy;\nbool done[10][10];\nint nh;\nint solve(int x,int y,int nd){\n\tint res=0;\n\tint i,j;\n\tfor(i=x+1;i<w;i++){\n\t\tif(done[i][y])break;\n\t\tif(nd==nh&&i==sx&&y==sy)return 1;\n\t\tif(!done[i][y]&&c[i][y]==1){\n\t\t\tdone[i][y]=true;\n\t\t\tres+=solve(i,y,nd+1);\n\t\t\tdone[i][y]=false;\n\t\t}\n\t}\n\tfor(i=x-1;i>=0;i--){\n\t\tif(done[i][y])break;\n\t\tif(nd==nh&&i==sx&&y==sy)return 1;\n\t\tif(!done[i][y]&&c[i][y]==1){\n\t\t\tdone[i][y]=true;\n\t\t\tres+=solve(i,y,nd+1);\n\t\t\tdone[i][y]=false;\n\t\t}\n\t}\n\tfor(i=y+1;i<h;i++){\n\t\tif(done[x][i])break;\n\t\tif(nd==nh&&x==sx&&i==sy)return 1;\n\t\tif(!done[x][i]&&c[x][i]==1){\n\t\t\tdone[x][i]=true;\n\t\t\tres+=solve(x,i,nd+1);\n\t\t\tdone[x][i]=false;\n\t\t}\n\t}for(i=y-1;i>=0;i--){\n\t\tif(done[x][i])break;\n\t\tif(nd==nh&&x==sx&&i==sy)return 1;\n\t\tif(!done[x][i]&&c[x][i]==1){\n\t\t\tdone[x][i]=true;\n\t\t\tres+=solve(x,i,nd+1);\n\t\t\tdone[x][i]=false;\n\t\t}\n\t}\n\treturn res;\n}\t\t\n\nint main(){\n\tint i,j;\n\twhile(1){\n\tnh=0;\n\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0)return 0;\n\tfor(i=0;i<w;i++)for(j=0;j<h;j++)done[i][j]=false;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\tscanf(\"%d\",&c[j][i]);\n\t\tif(c[j][i]==1)nh++;\n\t\tif(c[j][i]==2){sx=j;sy=i;}\n\t}\n\tint ans=solve(sx,sy,0);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint solve();\nint road(pair<int,int> now,int bit,vector<pair<int,int> > vec,int visit);\nbool able();\n\nint M,N;\nint field[20][20];\nint H;\npair<int,int> SG;\n//int mem[100][9000000] = {0};\n\nint main()\n{\n    while(scanf(\"%d%d\",&M,&N),N + M)\n    {\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < M; j++)\n            {\n                scanf(\"%d\",&field[i][j]);\n            }\n        }\n        printf(\"%d\\n\",solve());\n    }\n    return 0;\n}\n\nbool able(pair<int,int> now,pair<int,int> to,int visit[20][20])\n{\n    if(now.first == to.first)\n    {\n        int l = min(now.second,to.second),r = max(now.second,to.second);\n        for(int i = l + 1; i < r + 1; i++)\n        {\n            if(i == r)return true;\n            if(visit[now.first][i] == 1)return false;\n        }\n    }\n    if(now.second == to.second)\n    {\n        int l = min(now.first,to.first),r = max(now.first,to.first);\n        for(int i = l + 1; i < r + 1; i++)\n        {\n            if(i == r)return true;\n            if(visit[i][now.second] == 1)return false;\n        }\n    }\n    return false;\n}\n\nint road(pair<int,int> now,int bit,vector<pair<int,int> > vec,int visit[20][20])\n{\n    int new_visit[20][20];\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < M; j++)\n        {\n            new_visit[i][j] = visit[i][j];\n        }\n    }\n    if(bit == (1 << H) - 1)\n    {\n        if(able(now,SG,new_visit))return 1;\n    }\n    int SUM = 0;\n    for(int i = 0; i < H; i++)\n    {\n        if(!(bit & (1 << i)))\n        {\n            if(able(now,vec[i],new_visit))\n            {\n                new_visit[vec[i].first][vec[i].second] = 1;\n                SUM += road(vec[i],bit | (1 << i),vec,new_visit);\n            }\n        }\n    }\n    return SUM;\n}\n\nint solve()\n{\n    H = 0;\n    vector<pair<int,int> > vec;\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < M; j++)\n        {\n            if(field[i][j] == 1)\n            {\n                vec.push_back(make_pair(i,j));\n                H++;\n            }\n            if(field[i][j] == 2)\n            {\n                SG = make_pair(i,j);\n            }\n        }\n    }\n    int visit[20][20] = {0};\n    return road(SG,0,vec,visit);;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint n,m,x,y,ie,bit,l;\nint mp[10][10];\nmap<pair<int,int>,int> memo;\nmap<pair<int,int>,int> num;\nint dfs(int I, int J){\n    if(l != -1 && num.count(MP(bit,l)) != 0) return memo[MP(bit,l)];\n\n    if(bit == ie){\n        if(I != x && J != y) return 0;\n        int ans = 0;\n        for(int i=I-1; i>=0; i--){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int i=I+1; i<n; i++){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int j=J-1; j>=0; j--){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        for(int j=J+1; j<m; j++){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        return memo[MP(bit,l)] = ans;\n    }\n\n    int ans = 0;\n    int L = l;\n    for(int i=I-1; i>=0; i--){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int i=I+1; i<n; i++){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            l = num[MP(i,J)];\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int j=J-1; j>=0; j--){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n    for(int j=J+1; j<m; j++){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            l = num[MP(I,j)];\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n\n    return memo[MP(bit,l)] = ans;\n}\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    while(true){\n        cin >> m >> n;\n        if(n == 0 && m == 0) break;\n\n        num.clear();\n        ie = 0;\n        bit = 0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                cin >> mp[i][j];\n                if(mp[i][j] == 2){\n                    x = i;\n                    y = j;\n                }\n                if(mp[i][j] == 1){\n                    num[MP(i,j)] = ie;\n                    ie++;\n                }\n            }\n        }\n        ie = (1<<ie) - 1;\n        l = -1;\n        memo.clear();\n\n        cout << dfs(x,y) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <cstring>\n \nusing Pair = std::pair<int, int>;\n \nint w, h;\nPair ch;\n \nstd::vector<int> px[10], py[10];\nint map[11][11];\nstd::vector<Pair> houses;\nunsigned int mask;\n \nint dfs(int y, int x, unsigned int used) {\n    used |= 1u << map[y][x];\n     \n    if((used & mask) == mask) {\n        if(ch.first == y) {\n            return 1;\n        }else if(ch.second == x) {\n            return 1;\n        }else\n            return 0;\n    }\n     \n    int ans = 0;\n    auto pxit = std::lower_bound(px[x].begin(), px[x].end(), y);\n    auto pyit = std::lower_bound(py[y].begin(), py[y].end(), x);\n     \n    if(pxit != px[x].begin()) {\n        auto it = pxit - 1;\n        while(1) {\n            if(!(used & (1 << map[*it][x]))) {\n                ans += dfs(*it, x, used);\n                break;\n            }\n\n            if(it == px[x].begin())\n                break;\n             \n            --it;\n        }\n    }\n     \n    if(pxit != px[x].end()) {\n        for(auto it = pxit + 1; it != px[x].end(); ++it) {\n            if(!(used & (1 << map[*it][x]))) {\n                ans += dfs(*it, x, used);\n                break;\n            }\n        }\n    }\n     \n    if(pyit != py[y].begin()) {\n        auto it = pyit - 1;\n        while(1) {\n            if(!(used & (1 << map[y][*it]))) {\n                ans += dfs(y, *it, used);                \n                break;\n            }\n\n            if(it == py[y].begin())\n                break;\n             \n            --it;\n        }\n    }\n     \n    if(pyit != py[y].end()) {\n        for(auto it = pyit + 1; it != py[y].end(); ++it) {\n            if(!(used & (1 << map[y][*it]))) {\n                ans += dfs(y, *it, used);\n                break;\n            }\n        }\n    }\n     \n    return ans;\n}\n \nint main() {\n    while(std::cin >> w >> h, w + h) {\n    houses.clear();\n    for(auto&& v : px)\n        v.clear();\n    for(auto&& v : py)\n        v.clear();\n     \n    memset(map, -1, sizeof(map));\n     \n    int in;\n    for(int i = 0; i < h; ++i) {\n        for(int j = 0; j < w; ++j) {\n            std::cin >> in;\n             \n            if(in == 1) {\n                px[j].push_back(i);\n                py[i].push_back(j);\n                map[i][j] = houses.size();\n                houses.push_back({i, j});\n            }else if(in == 2) {\n                ch = {i, j};\n            }\n        }\n    }\n     \n    for(int i = 0; i < houses.size(); ++i) {\n        mask |= 1 << i;\n    }\n     \n    std::cout << dfs(ch.first, ch.second, 0) << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint memo[1<<19][23];\nint target;\nint ng;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\tif(done<(1<<19)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tif(done<(1<<19)&&table[i][j]>=0&&memo[done][table[i][j]]){\n\t\tmemo[done][table[i][j]]=ret;\n\t}\n\t//cout << done << \", \" << i << \", \" << j << \": \" << ret << endl;\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tint c=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(memo,-1,sizeof(int)*(23*(1<<min(c,19))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint dfs(vector<vector<int>>&field, int x, int y,int rest) {\n\tint ans = 0;\n\tfor (int way = 0; way < 4; ++way) {\n\t\tint nowx(x), nowy(y);\n\t\twhile (1) {\n\t\t\tint nextx = nowx + dx[way];\n\t\t\tint nexty = nowy + dy[way];\n\t\t\tif (field[nexty][nextx] ==-1000) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (field[nexty][nextx] <= 0) {\n\t\t\t\tnowx = nextx;\n\t\t\t\tnowy = nexty;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (field[nexty][nextx] == 1000) {\n\t\t\t\tif (rest) {\n\t\t\t\t\tnowx = nextx;\n\t\t\t\t\tnowy = nexty;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[nexty][nextx] = -field[nexty][nextx];\n\t\t\t\tans += dfs(field, nextx, nexty, rest - 1);\n\t\t\t\tfield[nexty][nextx] = -field[nexty][nextx];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, -1000));\n\t\tint num = 1;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tint n; cin >> n;\n\t\t\t\tif (n == 0)field[i + 1][j + 1] = 0;\n\t\t\t\telse if (n == 1)field[i + 1][j + 1] = num++;\n\t\t\t\telse {\n\t\t\t\t\tfield[i + 1][j + 1] = 1000;\n\t\t\t\t\tsx = j + 1; sy = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = dfs(field, sx, sy, num - 1);\n\t\tcout << ans << endl;\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\n#define INF (1e+9)\n#define LLINF (1e+18)\n#define LL long long\n\nusing namespace std;\n\n\nint m,n;\nint field[16][16] = {0};\nint sx,sy;\n\nint house = 0;\nint ans = 0;\n\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\nint func(int nx,int ny,int way,int num){\n\t//printf(\"###nx<%d>###ny<%d>###way<%d>###num<%d>\\n\",nx,ny,way,num);\n\tint state = field[ny][nx];\n\tif(state == 1){\n\t\tfor(int i = 0;i < 4;i++){ \n\t\t\tfield[ny][nx] = -1;\n\t\t\tfunc(nx + dx[i],ny + dy[i],i,num+1);\n\t\t\tif(i == way){\n\t\t\t\tfield[ny][nx] = state;\n\t\t\t\tfunc(nx + dx[i],ny + dy[i],i,num);\n\t\t\t}\n\t\t}\n\t}\n\telse if(state == -1);\n\telse if(state == 2){\n\t\tif(num == house)ans++;\n\t\telse func(nx + dx[way],ny + dy[way],way,num);\n\t}\n\telse if(state == 0){\n\t\tfunc(nx + dx[way],ny + dy[way],way,num);\n\t}\n\tfield[ny][nx] = state;\n\treturn 0;\n}\n\n\n\nint main (void){\n\n\twhile(true){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif((m == 0)&&(n == 0))break;\n\t\thouse = 0;\n\t\tans = 0;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= m;j++){\n\t\t\t\tscanf(\"%d\",&field[i][j]);\n\t\t\t\tif(field[i][j] == 2){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 1){\n\t\t\t\t\thouse++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i <= m + 1;i++){\n\t\t\tfield[0][i] = -1;\n\t\t\tfield[n + 1][i] = -1;\n\t\t}\n\t\tfor(int i = 0;i < n + 1;i++){\n\t\t\tfield[i][0] = -1;\n\t\t\tfield[i][m + 1] = -1;\n\t\t}\n\n\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tfunc(sx + dx[i],sy + dy[i],i,0);\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<int,int> dp[24];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(dp[id][vis])return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)<18)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    for(int i=0;i<pn-1;i++)dp[i].clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 21;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX && !(cnt >= 18 && sum == 0)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\n//int memo[1<<K][23];\nunordered_map<int, int> memo2[23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}*/\n\tif(done%11==0&&table[i][j]>=0&&memo2[table[i][j]].find(done)!=memo2[table[i][j]].end())\n\t{\n\t\treturn memo2[table[i][j]][done];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\t/*\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(table[i][j]>=0){\n\t\t\t\t\tmemo2[table[i][j]][done]=0;\n\t\t\t\t}*/\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}*/\n\tif(table[i][j]>=0&&done%11==0){\n\t\tmemo2[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tfor(int i=0;i<c;i++){\n\t\tmemo2[i].clear();\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <memory>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint field[12][12];\nint nums[12][12];\nmap<P, bool> ng;\n\nint dfs(int state, int x, int y){\n  if(ng[P(state, nums[y][x])]) return 0;\n  if(state == 0){\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      while(field[y2][x2] == 0){\n\ty2 += dy[i];\n\tx2 += dx[i];\n      }\n      if(field[y2][x2] == 2) return 1;\n    }\n    ng[P(state, nums[y][x])] = true;\n    return 0;\n  }\n  int res = 0;\n  rep(i, 4){\n    int x2 = x + dx[i];\n    int y2 = y + dy[i];\n    while(field[y2][x2] != 3){\n      if(field[y2][x2] == 1){\n\tfield[y2][x2] = 3;\n\tres += dfs(state - (1 << nums[y2][x2]), x2, y2);\n\tfield[y2][x2] = 1;\n      }\n      x2 += dx[i];\n      y2 += dy[i];\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n, m, sx, sy, cnt;\n  while(cin >> m >> n && (n || m)){\n    cnt = 0;\n    fill(&field[0][0], &field[11][11] + 1, 3);\n    memset(nums, 0, sizeof(nums));\n    ng.clear();\n    rep(i, n){\n      rep(j, m){\n\tcin >> field[i+1][j+1];\n\tif(field[i+1][j+1] == 2){\n\t  sx = j + 1;\n\t  sy = i + 1;\n\t}\n\tif(field[i+1][j+1] == 1){\n\t  nums[i+1][j+1] = cnt++;\n\t}\n      }\n    }\n    cout << dfs((1 << cnt) - 1, sx, sy) << endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <memory>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint field[12][12];\n\nint dfs(int cnt, int x, int y){\n  if(cnt == 0){\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      while(field[y2][x2] == 0){\n\ty2 += dy[i];\n\tx2 += dx[i];\n      }\n      if(field[y2][x2] == 2) return 1;\n    }\n    return 0;\n  }\n  int res = 0;\n  rep(i, 4){\n    int x2 = x + dx[i];\n    int y2 = y + dy[i];\n    while(field[y2][x2] == 0 || field[y2][x2] == 2){\n      y2 += dy[i];\n      x2 += dx[i];\n    }\n    while(field[y2][x2] == 1){\n      field[y2][x2] = 3;\n      res += dfs(cnt - 1, x2, y2);\n      field[y2][x2] = 1;\n      x2 += dx[i];\n      y2 += dy[i];\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n, m, sx, sy, cnt;\n  while(cin >> m >> n && (n || m)){\n    cnt = 0;\n    fill(&field[0][0], &field[11][11] + 1, 3);\n    rep(i, n){\n      rep(j, m){\n\tcin >> field[i+1][j+1];\n\tif(field[i+1][j+1] == 2){\n\t  sx = j + 1;\n\t  sy = i + 1;\n\t}\n\tif(field[i+1][j+1] == 1){\n\t  cnt++;\n\t}\n      }\n    }\n    cout << dfs(cnt, sx, sy) << endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nmap<P, int>dp;\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[{1 << dat[nx][ny], dat[nx][ny]}] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[{i, j}];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\tdp.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\nint w,h;\nint map[10][10];\nbool passed[10][10];\nint gx,gy;\nint count_max;\nint func(int x,int y, int count)\n{\n\t//std::cout << \"IN:\"<<x<<' '<<y<<' '<<count<<'\\n';\n\tif(count==count_max){\n\t\tif(x==gx&&y==gy){return 1;}\n\t\treturn 0;\n\t}\n\tpassed[x][y]=true;\n\tint res = 0;\n\tfor(int nx = x-1;nx>=0;--nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int nx = x+1;nx<w;++nx){\n\t\tif(!passed[nx][y] && map[nx][y]==1){\n\t\t\tres += func(nx,y,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y-1;ny>=0;--ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int ny = y+1;ny<h;++ny){\n\t\tif(!passed[x][ny] && map[x][ny]==1){\n\t\t\tres += func(x,ny,count+1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tpassed[x][y]=false;\n\treturn res;\n}\n\nint main()\n{\n\tfor(;;){\n\tstd::cin >> w>>h;if(w==0&&h==0){break;}\n\tcount_max=0;\n\tfor(int y=0;y<h;++y)for(int x=0;x<w;++x){\n\t\tstd::cin >> map[x][y];\n\t\tif(map[x][y]==1){++count_max;}\n\t\tif(map[x][y]==2){gx=x;gy=y;}\n\t}\n\t//std::cout << \"a:\"<<gx<<' '<<gy<<' '<<count_max<<'\\n';\n\t\n\tint res = 0;\n\tstd::cout << func(gx,gy,0)<<std::endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n \nint m;\nint n;\nint map[10][10] = {0};\nint cnt = 0;\nint churchx;\nint churchy;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n \nint saiki( int xinput, int yinput, int nokori ) {\n    for ( int i = 0; i < 4; i++ ) {\n        int x = xinput;\n        int y = yinput;\n        if ( nokori == 0 ) {\n            if ( y == churchy && x > churchx && i != 0 ) continue;\n            if ( y == churchy && x < churchx && i != 1 ) continue;\n            if ( x == churchx && y > churchy && i != 2 ) continue;\n            if ( x == churchx && y < churchy && i != 3 ) continue;\n        }\n\t\n        while(true) {\n            x += dx[i];\n            y += dy[i];\n            if ( x < 0 || x >= m || y < 0 || y >= n ) break;\n            \n\t    if (map[x][y] == 1){\n                map[x][y] = 3;\n                saiki(x, y, nokori-1);\n                map[x][y] = 1;\n\t\tbreak;\n            }else if(map[x][y] == 2 ){\n                if(nokori == 0){\n                    cnt++;\n                    return 0;\n                }\n            }\n        }\n    }\n    return 0;\n}\n \nint main(){\n    while(true) {\n        cin >> m;\n        cin >> n;\n        if ( m == 0 ) break;\n        int nokori = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < m; j++ ) {\n                cin >> map[j][i];\n\t\t//unvisited\n                if ( map[j][i] == 1 ) {\n                    nokori++;\n\t\t    \n\t\t//is_church\n                }else if(map[j][i] == 2) {\n                    churchx = j;\n                    churchy = i;\n                }\n            }\n        }\n\t\n\tcnt = 0;\n\tsaiki( churchx, churchy, nokori );\n\tcout << cnt << endl;\n    \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second \n#define UP 0\n#define RIGHT 1\n#define DOWN 2\n#define LEFT 3\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  int ni,nj;\n  int cnt;\n  bool vis[HSMAX];\n  state(int si, int sj):ni(si),nj(sj){cnt=0;\n    for(int i=0;i<HSMAX;++i)vis[i]=false;\n    vis[ houseId[si][sj] ]=true;\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], bool vis[][MAX], int bi, int bj, int nhouse, int cnt, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[bi][bj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[bi][bj].exist[k] ){\n\tfor(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\t  pi next = M[bi][bj].link[k][v];\n\t  if( !vis[next.fr][next.sc] ){\n\t    vis[next.fr][next.sc]=true;\n\t    dfs( M, vis, next.fr, next.sc, nhouse, cnt+1, ans );\n\t    vis[next.fr][next.sc]=false;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n\n  while(!qs.empty()){\n    bool bCont=false;\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;\n    qs.pop();\n\n    if( st_now.cnt == nhouse ){\n      for(int k = 0; k < MAXDIR; ++k){\n\tif( M[ni][nj].cexist[k] ){\n\t  ++ans;\n\t  bCont=true;\n\t}\n      }\n    }\n    if(bCont)continue;\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !st_now.vis[ houseId[next.fr][next.sc] ] ){\n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis[ houseId[next.fr][next.sc] ] = true;\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }else{\n\t    //break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    bool vis[MAX][MAX]={{false,},};\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = UP; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    vis[charch.fr][charch.sc]=true;\n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[24], y[24], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[++p] = i, y[p] = j, dat[i][j] = p;\n\t\t\tif (f[i][j] == 2)x[0] = i, y[0] = j, dat[i][j] = 0;\n\t\t}p++;\n\t\tmap<P, int>dp;\n\t\tdp[{0, 0}] = 1;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif ((f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) || (f[nx][ny] == 2 && i == (1 << p) - 2)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", dp[{(1 << p) - 1, 0}]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\nint memo[1<<K][23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint n,m,x,y,ie,bit,l;\nint mp[10][10];\nint memo[1<<23][23];\nmap<pair<int,int>,int> num;\nint dfs(int I, int J){\n    //cout << I << \" \" << J << endl;\n    if(bit == ie){\n        if(I != x && J != y) return 0;\n        int ans = 0;\n        for(int i=I-1; i>=0; i--){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int i=I+1; i<n; i++){\n            if(mp[i][J] == -1) break;\n            if(mp[i][J] == 2) ans++;\n        }\n        for(int j=J-1; j>=0; j--){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        for(int j=J+1; j<m; j++){\n            if(mp[I][j] == -1) break;\n            if(mp[I][j] == 2) ans++;\n        }\n        return ans;\n    }\n\n    int ans = 0;\n    for(int i=I-1; i>=0; i--){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int i=I+1; i<n; i++){\n        if(mp[i][J] == -1) break;\n        if(mp[i][J] == 1){\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n            ans += dfs(i,J);\n            mp[i][J] *= -1;\n            bit = bit ^ (1<<num[MP(i,J)]);\n        }\n    }\n    for(int j=J-1; j>=0; j--){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n    for(int j=J+1; j<m; j++){\n        if(mp[I][j] == -1) break;\n        if(mp[I][j] == 1){\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n            ans += dfs(I,j);\n            mp[I][j] *= -1;\n            bit = bit ^ (1<<num[MP(I,j)]);\n        }\n    }\n\n    return ans;\n}\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    while(true){\n        cin >> m >> n;\n        if(n == 0 && m == 0) break;\n\n        ie = 0;\n        bit = 0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                cin >> mp[i][j];\n                if(mp[i][j] == 2){\n                    x = i;\n                    y = j;\n                }\n                if(mp[i][j] == 1){\n                    num[MP(i,j)] = ie;\n                    ie++;\n                }\n            }\n        }\n        ie = (1<<ie) - 1;\n        l = -1;\n\n        cout << dfs(x,y) << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  /*if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  */\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    \n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    \n    /**/\n    if( st_now.cnt + 5 >= nhouse ){\n      int left = 0;\n      int chi=charch.fr;int chj=charch.sc;\n      for(int k = 0; k < MAXDIR; ++k){\n\tleft += M[chi][chj].link[k].size();\n      }\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 ) continue;\n    }\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.checkvis( houseId[next.fr][next.sc] )) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.setvis( houseId[next.fr][next.sc] );\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 11\n#define HSMAX 24\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nvector<pi> houses;\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  int linkmax[MAXDIR];\n  pi link[MAXDIR][MAX];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      linkmax[i]=0;\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  int vis;\n  state(){}\n  state(char si, char sj, char cnt, int vis):ni(si),nj(sj),cnt(cnt),vis(vis){}\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n/*\nvoid dfs(const Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  \n\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }\n\n  if( now.cnt + 6 >= nhouse ){\n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( now.checkvis( houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 )\n      return ;\n  }\n  \n  int ni = now.ni;\n  int nj = now.nj;\n  for(int k = 0; k < MAXDIR; ++k){\n    if( M[ni][nj].exist[k] ){\n      for(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\tpi pnext = M[ni][nj].link[k][v];\n\tif( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t  state next(now);\n\t  next.ni = pnext.fr;\n\t  next.nj = pnext.sc;\n\t  next.setvis( houseId[pnext.fr][pnext.sc] );\n\t  next.cnt++;\n\t  dfs( M, next, nhouse, ans );\n\t  break;\n\t}\n      }\n    }\n  }\n  return ;\n}\n*/\n/*\n    if( st_now.cnt >= 99 ){\n      bool bCont=false;\n      for(int i = 0; i < houses.size(); ++i){\n\tint hi = houses[i].fr;\n\tint hj = houses[i].sc;\n\tif( M[hi][hj].isHouse ){\n\t  if( M[hi][hj].isHouse && st_now.vis&(1<<houseId[hi][hj]) ) continue;\n\t  bool frontofcharch=false;\n\t  bCont=true;\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( M[hi][hj].cexist[k] ) frontofcharch = true;\n\t  }\n\t  for(int k = 0; k < MAXDIR; ++k){\n\t    if( !M[hi][hj].exist[k] ) continue;\n\t    for(int v = 0; v < M[hi][hj].link[k].size(); ++v){\n\t      pi house = M[hi][hj].link[k][v];\n\t      if( !( st_now.vis&(1<<houseId[house.fr][house.sc]) ) ){\n\t\tbCont=false;\n\t\tbreak;\n\t      }\n\t    }\n\t    if(!bCont)break;\n\t  }\n\t  \n\t  if(bCont && !frontofcharch ){\n\t    break;\n\t  }\n\t  bCont=false;\n\t}\n\tif( bCont ) break;\n      }\n      if(bCont)continue;\n    }\n*/\n\nstruct Queue{\n  int p;\n  state *V;\n  Queue():p(0){V=new state[1<<20];}\n  ~Queue(){delete [] V;}\n  void push(const state &t){\n    V[p++]=t;\n  }\n  state & front(){\n    return V[p-1];\n  }\n  void pop(){--p;}\n  bool empty(){\n    return p==0;\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  Queue qs;\n  qs.push( init );\n  int ni,nj;\n  int chi=charch.fr;int chj=charch.sc;\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    ni = st_now.ni;\n    nj = st_now.nj;    \n    qs.pop();\n    \n    if( st_now.cnt == nhouse ){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    //if( st_now.cnt >= 0 ){\n      int left = 0;\n\n      for(int k = 0; k < MAXDIR; ++k){\n\tleft += M[chi][chj].linkmax[k];\n      }\n      for(int k = 0; k < MAXDIR; ++k){\n\tfor(int v = 0; v < M[chi][chj].linkmax[k]; ++v){\n\t  pi hs = M[chi][chj].link[k][v];\n\t  if( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t    --left;\n\t  }\n\t}\n      }\n      if( left == 0 )\n\tcontinue ;\n      //}\n\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[ni][nj].linkmax[k]; ++v){\n\tpi next = M[ni][nj].link[k][v];\n\tif( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){\n\t  qs.push( state(next.fr,next.sc,st_now.cnt + 1,st_now.vis|( 1<<houseId[next.fr][next.sc])));\n\t  break;\n\t}\n      }\n    }\n\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    houses.clear();\n\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  houses.push_back( pi(i,j) );\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k][ M[i][j].linkmax[k]++ ] = pi(ti,tj);\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc,0,0);\n    bfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint H,W;\nint G[11][11],INDEX[11][11],ep_bitmask,sp,V;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvector<int> edges[25][4];\n//map<ii,int> memo;\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void INIT(){\n  //memo.clear();\n  ep_bitmask = 0, sp = -1;\n  rep(i,11) rep(j,11) INDEX[i][j] = -1;\n  rep(i,25) rep(j,4) edges[i][j].clear();\n}\n\ninline void make_edges(){\n  rep(i,H) rep(j,W) if( G[i][j] != 0 ) {\n    int x = j, y = i;\n    rep(k,4){\n      int nx = x + dx[k], ny = y + dy[k];\n      while( isValid(nx,ny) ){\n        if( G[ny][nx] == 1 ) edges[INDEX[i][j]][k].push_back(INDEX[ny][nx]);\n        nx += dx[k], ny += dy[k];\n      }\n    }\n  }\n}\n\ninline void calc_last_point(int x,int y){\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    while( isValid(nx,ny) ){\n      if( G[ny][nx] != 0 ) {\n        ep_bitmask |= (1<<INDEX[ny][nx]);\n        break;\n      }\n      nx += dx[i], ny += dy[i];\n    }\n  }\n}\n\nbool check(int cur,int visited){\n  bool used[V];\n  rep(i,V) used[i] = ((visited>>i)&1);\n  deque<int> deq;\n  deq.push_back(cur);\n  used[cur] = true;\n  while( !deq.empty() ){\n    int p = deq.front(); deq.pop_front();\n    if( (ep_bitmask>>p) & 1 ) return true;\n    rep(i,4){\n      rep(j,edges[p][i].size()){\n        int np = edges[p][i][j];\n        if( used[np] ) continue;\n        used[np] = true;\n        deq.push_back(np);\n      }\n    }\n  }\n  return false;\n}\n\nint dfs(int cur,int visited,int remain,int ep_remain){\n\n  if( ep_remain == 0 && remain != 0 ) return 0;\n\n  if( remain <= 0 ) return ( (ep_bitmask>>cur) & 1 );\n\n\n  //if( memo.find(ii(cur,visited)) != memo.end() ) return memo[ii(cur,visited)];\n\n  int ret = 0;\n  rep(k,4){\n    rep(i,edges[cur][k].size()){\n      int next = edges[cur][k][i];\n      assert(next>=0);\n      if( (visited>>next) & 1 ) break;\n      ret += dfs(next,visited|(1<<next),remain-(next!=sp),ep_remain-((ep_bitmask>>next)&1));\n    }\n  }\n  //if( ret >= 100 ) memo[ii(cur,visited)] = ret;\n\n  return ret;\n}\n\nint main(){\n  while( cin >> W >> H, H|W ){\n    INIT();\n    int idx = 0,remain = 0,sx,sy;\n    rep(i,H) rep(j,W) {\n      cin >> G[i][j];\n      if( G[i][j] == 1 ) INDEX[i][j] = idx++, remain++;\n      if( G[i][j] == 2 ) sx = j, sy = i;\n    }\n    sp = INDEX[sy][sx] = idx++;\n    make_edges();\n\n    calc_last_point(sx,sy);\n    assert(remain <= 23);\n    V = remain;\n    cout << dfs(sp,(1<<INDEX[sy][sx]),remain,__builtin_popcount(ep_bitmask)) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<int,int> dp[24];\n//int dp[24][1<<18];\nP pos[24];\n\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(int vis,int id){\n  if(dp[id].count(vis))return dp[id][vis];\n  //if(__builtin_popcount(vis)>6 && dp[id][vis])return dp[id][vis];\n\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\t\tres += 1;\n\t\tbreak;\n\t  }\n      if(0<g[ty][tx]){\n\t    int tmp = g[ty][tx] - 1;\n\t    if( (vis>>tmp)&1 ){\n\t      res += rec(vis-(1<<tmp),g[ty][tx]);\n\t      break;\n        }\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  if(__builtin_popcount(vis)>8)dp[id][vis] = res;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    for(int i=0;i<pn;i++)dp[i].clear();\n\t//for(int i=0;i<pn;i++)\n   \t  //for(int j=0;j<(1<<18);j++)dp[i][j] = 0;\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(upper-1,0));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\n#define MAX_H 10\n#define MAX_W 10\n#define MAX_HOUSE 23\n\nint x[MAX_H][MAX_W];\nint y[MAX_H][MAX_W];\nint a[(1 << MAX_HOUSE)];\nint o[(1 << MAX_HOUSE)];\nint b[MAX_HOUSE];\nint sum;\nqueue<int>Q;\nqueue<int>R;\nqueue<int>S;\n\nint main() {\n\tint h, w, c, d, e, f, s[4], i;\n\twhile (true) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tmemset(o, 0, sizeof(o));\n\t\tcin >> h >> w;\n\t\tif (h == 0 && w == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tc = 0;\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t\tif (x[i][j] == 1) {\n\t\t\t\t\ty[i][j] = c;\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tif (x[i][j] == 2) {\n\t\t\t\t\ty[i][j] = 100;\n\t\t\t\t\ts[0] = (i - 1)*10+j;\n\t\t\t\t\ts[1] = (i + 1)*10+j;\n\t\t\t\t\ts[2] = i * 10 + j - 1;\n\t\t\t\t\ts[3] = i * 10 + j + 1;\n\t\t\t\t\to[0] = 1;\n\t\t\t\t\tQ.push(i * 10 + j);\n\t\t\t\t}\n\t\t\t\tif (x[i][j] == 0) {\n\t\t\t\t\ty[i][j] = 1000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf = 0;\n\t\tS.push(0);\n\t\to[0] = 1;\n\t\twhile (!Q.empty() && f < c) {\n\t\t\tf++;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\ti = S.front();\n\t\t\t\tif (o[i] >= 1) {\n\t\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\t\tb[j] = (i / (1 << j)) % 2;\n\t\t\t\t\t}\n\t\t\t\t\td = Q.front() / 10;\n\t\t\t\t\te = Q.front() % 10;\n\t\t\t\t\tfor (int j = d - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (y[j][e] < 100) {\n\t\t\t\t\t\t\tif (b[y[j][e]] == 1) {\n\t\t\t\t\t\t\t\tgoto E1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tR.push(j * 10 + e);\n\t\t\t\t\t\t\t\ta[i + (1 << y[j][e])] += 1;\n\t\t\t\t\t\t\t\tS.push(i + (1 << y[j][e]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tE1:;\n\t\t\t\t\tfor (int j = d + 1; j < w; j++) {\n\t\t\t\t\t\tif (y[j][e] < 100) {\n\t\t\t\t\t\t\tif (b[y[j][e]] == 1) {\n\t\t\t\t\t\t\t\tgoto E2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tR.push(j * 10 + e);\n\t\t\t\t\t\t\t\ta[i + (1 << y[j][e])] += 1;\n\t\t\t\t\t\t\t\tS.push(i + (1 << y[j][e]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tE2:;\n\t\t\t\t\tfor (int j = e - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (y[d][j] < 100) {\n\t\t\t\t\t\t\tif (b[y[d][j]] == 1) {\n\t\t\t\t\t\t\t\tgoto E3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tR.push(d * 10 + j);\n\t\t\t\t\t\t\t\ta[i + (1 << y[d][j])] += 1;\n\t\t\t\t\t\t\t\tS.push(i + (1 << y[d][j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tE3:;\n\t\t\t\t\tfor (int j = e + 1; j < h; j++) {\n\t\t\t\t\t\tif (y[d][j] < 100) {\n\t\t\t\t\t\t\tif (b[y[d][j]] == 1) {\n\t\t\t\t\t\t\t\tgoto E4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tR.push(d * 10 + j);\n\t\t\t\t\t\t\t\ta[i + (1 << y[d][j])] += 1;\n\t\t\t\t\t\t\t\tS.push(i + (1 << y[d][j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tE4:;\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tS.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!R.empty()) {\n\t\t\t\tQ.push(R.front());\n\t\t\t\tR.pop();\n\t\t\t}\n\t\t\tfor (int i = 0; i < (1 << c); i++) {\n\t\t\t\to[i] = a[i];\n\t\t\t}\n\t\t\tmemset(a, 0, sizeof(a));\n\t\t}\n\t\tsum = 0;\n\t\twhile (!Q.empty()) {\n\t\t\td = Q.front();\n\t\t\tif (d == s[0] || d == s[1] || d == s[2] || d == s[3]) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tQ.pop();\n\t\t\tS.pop();\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\n#define PLANE (-1)\n#define HOUSE (1)\n#define CHURCH (100)\n\nusing namespace std;\n\nint x, y;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint home[10][10];\nint n;\nmap<int, int> memo[24];\n\nint goChurch(int ty, int tx)\n{\n    int i;\n    int my, mx;\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        while (0 <= my && my < y && 0 <= mx && mx < x){\n            if (home[my][mx] == CHURCH){\n                return (1);\n            }\n            my += dy[i];\n            mx += dx[i];\n        }\n    }\n    return (0);\n}\n\nint dfs(int v, int bit, int ty, int tx, char state[][11])\n{\n    int i;\n    int ky, kx;\n    int ans;\n    \n    if (memo[pos].find(bit) != memo[v].end()){\n        return (memo[v][bit]);\n    }\n    \n    if (bit == (1 << n) - 1){\n        if (__builtin_popcount(bit) < 19){\n            return (memo[v][bit] = goChurch(ty, tx));\n        }\n        return (goChurch(ty, tx));\n    }\n    \n    ans = 0;\n    \n    for (i = 0; i < 4; i++){\n\t\tkx = tx + dx[i];\n        ky = ty + dy[i];\n        //ツ逆ツ渉づ可プツδ個ゼツδ督トツづーツ置ツつ「ツづつ「ツつュ\n\t\twhile (0 <= kx && kx < x && 0 <= ky && ky < y && (home[ky][kx] == PLANE || home[ky][kx] == CHURCH || state[ky][kx] == 1)){\n\t\t\tky += dy[i];\n            kx += dx[i];\n\t\t}\n\t\tif (0 <= kx && kx < x && 0 <= ky && ky < y){\n\t\t\tstate[ky][kx] = 1;\n\t\t\tans += dfs(home[ky][kx] , bit | (1 << home[ky][kx]) , ky, kx, state);\n\t\t\tstate[ky][kx] = 0;\n\t\t}\n\t}\n    \n    if (__builtin_popcount(bit) < 19){\n        memo[v][bit] = ans;\n    }\n\treturn (ans);\n}\n\n\nint main(void)\n{\n    int sy, sx;\n    int i, j;\n    char state[10][11];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        n = 0;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &home[i][j]);\n                if (home[i][j] == 2){\n                    home[i][j] = CHURCH;\n                    sy = i;\n                    sx = j;\n                }\n                else if (home[i][j] == HOUSE){\n                    home[i][j] = n++;\n                }\n                else if (home[i][j] == 0){\n                    home[i][j] = PLANE;\n                }\n            }\n        }\n        memset(state, 0, sizeof(state));\n        for (i = 0; i < 24; i++){\n            memo[i].clear();\n        }\n        printf(\"%d\\n\", dfs(n, 0, sy, sx, state));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#pragma warning(disable : 4996)\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], zx[12][12][4], zy[12][12][4], d[4] = { 1, 0, -1, 0 };\nint solve(int sx, int sy, int depth) {\n\tif (depth == n) {\n\t\tif (sx == gx || sy == gy) return 1;\n\t\treturn 0;\n\t}\n\tdepth++;\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (tx != -1) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint rx = zx[ty][tx][i];\n\t\t\tint ry = zy[ty][tx][i];\n\t\t\ttx = rx, ty = ry;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &x[i][j]);\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\tzx[i][j][k] = -1;\n\t\t\t\t\tzy[i][j][k] = -1;\n\t\t\t\t\tint tx = j + d[k], ty = i + d[k ^ 1];\n\t\t\t\t\twhile (rng(tx, ty)) {\n\t\t\t\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\t\t\t\tzx[i][j][k] = tx;\n\t\t\t\t\t\t\tzy[i][j][k] = ty;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += d[k];\n\t\t\t\t\t\tty += d[k ^ 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint vec[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nvoid solve(int nx,int ny,int wx,int wy,int rem,vector<vector<int> > tab){\n    for(int v=0;v<4;v++){\n        int nowx=nx,nowy=ny;\n        for(;;){\n            nowx+=vec[v][0],nowy+=vec[v][1];\n            if(!(0<=nowx&&nowx<wx&&0<=nowy&&nowy<wy))break;\n            if(tab[nowx][nowy]==2){\n                if(rem==0)ans++;\n                break;\n            }\n            if(tab[nowx][nowy]==-1)break;\n            if(tab[nowx][nowy]==1){\n                tab[nowx][nowy]=-1;\n                solve(nowx,nowy,wx,wy,rem-1,tab);\n                tab[nowx][nowy]=1;\n            }\n        }\n    }\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        vector<vector<int> > table(n,vector<int>(m));\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&table[i][j]);\n            if(table[i][j]==1)homec++;\n            else if(table[i][j]==2){stx=i;sty=j;}\n        }\n        ans=0;\n        solve(stx,sty,n,m,homec,table);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\nint x,y;\nint sx,sy;\nint N;\nint hx[25],hy[25];\nint fie[12][12];\nint dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\nmap<int,int> memo[24];\n\nint dfs(int pos,int bit,bool done[12][12],int home){\n\tif(memo[pos].find(bit)!=memo[pos].end())return memo[pos][bit];\n\tif(bit==(1<<N)-1){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\t\twhile(fie[cx][cy]!=-1){\n\t\t\t\tif(fie[cx][cy]==100)return 1;\n\t\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint cx=hx[pos]+dx[i],cy=hy[pos]+dy[i];\n\t\twhile(fie[cx][cy]==-2 || fie[cx][cy]==100 || done[cx][cy]==true){\n\t\t\tcx+=dx[i],cy+=dy[i];\n\t\t}\n\t\tif(fie[cx][cy]!=-1){\n\t\t\tdone[cx][cy]=true;\n\t\t\tans+=dfs(fie[cx][cy] , bit | (1<<fie[cx][cy]), done,home+1);\n\t\t\tdone[cx][cy]=false;\n\t\t}\n\t}\n\tif(home< 19)memo[pos][bit]=ans;\n\treturn ans;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\tfor(int i=0;i<24;i++)memo[i].clear();\n\t\tfor(int i=0;i<12;i++){\n\t\t\tfor(int j=0;j<12;j++){\n\t\t\t\tfie[j][i]=-1;\n\t\t\t}\n\t\t}\n\t\tN=0;\n\t\tfor(int i=1;i<=y;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tscanf(\"%d\",&fie[j][i]);\n\t\t\t\tif(fie[j][i]==0){\n\t\t\t\t\tfie[j][i]=-2;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==2){\n\t\t\t\t\tfie[j][i]=100;\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\tif(fie[j][i]==1){\n\t\t\t\t\tfie[j][i]=N;\n\t\t\t\t\thx[N]=j;\n\t\t\t\t\thy[N]=i;\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thx[N]=sx,hy[N]=sy;\n\t\tbool done[12][12];\n\t\tmemset(done,false,sizeof(done));\n\t\tcout << dfs(N,0,done,0) << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint x,y;\nint map[10][10];\nint gx,gy;\nint home;\nint ans;\n\nint dx[5]={0,0,1,0,-1};\nint dy[5]={0,1,0,-1,0};\n\nvoid dfs(int mx,int my,int d,int ho2,int map2[10][10]){\n\tif(map2[mx][my]==2 && ho2==0)ans++;\n\telse{\n\t\tif(map2[mx][my]==1){\n\t\t\tmap2[mx][my]=3;\n\t\t\tho2-=1;\n\t\t\tdfs(mx,my,0,ho2,map2);\n\t\t\tmap2[mx][my]=1;\n\t\t\tho2+=1;\n\t\t}\n\t\tif(d==0){\n\t\t\tfor(int i=1;i<=4;i++){\n\t\t\t\tint kx=mx+dx[i],ky=my+dy[i];\n\t\t\t\tif(kx>=0 && kx<x && ky>=0 && ky<y && map2[kx][ky]!=3){\n\t\t\t\t\tdfs(kx,ky,i,ho2,map2);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tint kx=mx+dx[d],ky=my+dy[d];\n\t\t\tif(kx>=0 && kx<x && ky>=0 && ky<y && map2[kx][ky]!=3){\n\t\t\t\tdfs(kx,ky,d,ho2,map2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0 && y==0)break;\n\t\thome=0;\n\t\tans=0;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tscanf(\"%d\",&map[j][i]);\n\t\t\t\tif(map[j][i]==2)gx=j,gy=i;\n\t\t\t\tif(map[j][i]==1)home++;\n\t\t\t}\n\t\t}\n\t\tdfs(gx,gy,0,home,map);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define MAX 12\nusing namespace std;\nint h,w;\nint sum;\nint sx,sy;\nint dp[(1<<20)][23];\nint s[MAX][MAX];\nint housInd[MAX][MAX];\n/*\n 2\n1 3\n 0\n*/\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nint func(int ny, int nx, int bit){\n\tif(housInd[ny][nx] != -1 && dp[bit][housInd[ny][nx]] != -1) return dp[bit][housInd[ny][nx]];\n\t\n\tint ret = 0;\n\tbool isLast = bit == (1 << sum) - 1;\n\tfor (int i = 0; i < 4; i++) {\n\t\tfor (int x = nx+dx[i], y = ny+dy[i]; 0 <= x && x < w && 0 <= y && y < h; x += dx[i], y += dy[i]) {\n\t\t\tint ind = housInd[y][x];\n\t\t\tif (ind == -1) {\n\t\t\t\tif (isLast && s[y][x] == 2) return dp[bit][housInd[ny][nx]] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((bit & 1 << ind) != 0) break;\n\t\t\t\tif (!isLast)ret += func(y, x, bit | (1 << ind));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn housInd[ny][nx] != -1 ? (dp[bit][housInd[ny][nx]] = ret) : ret;\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\tsum=0;\n\t\tcout <<\"a\";\n//\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>s[i][j];\n\t\t\t\t\thousInd[i][j] = -1;\n\t\t\t\t\tif(s[i][j]==2){\n\t\t\t\t\t\tsy=i;sx=j;\n\t\t\t\t\t}else if(s[i][j]==1) {\n\t\t\t\t\t\thousInd[i][j] = sum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < (1 << sum); i++) {\n\t\t\tfor(int j = 0; j < sum; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint ans=func(sy,sx,0);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int N = 25;\nconst int MEMO_LIM = (1<<20);\nbool adj[N][N];\nint up[N][N];\nint memo[MEMO_LIM][N];\nint n;\nvector<P> house;\n\nint near[N];\n\nvoid check(int an, int bn)\n{\n  P a = house[an];\n  P b = house[bn];\n  \n  if (a.first!=b.first && a.second!=b.second) {\n    return;\n  }\n\n  int st = 0;\n  if (a.second==b.second) {\n    int s = min(a.first, b.first);\n    int t = max(a.first, b.first);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].second!=a.second) continue;\n      int x = house[i].first;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n  else if (a.first==b.first) {\n    int s = min(a.second, b.second);\n    int t = max(a.second, b.second);\n    for (int i=0; i < house.size()-1; ++i) {\n      if (house[i].first!=a.first) continue;\n      int x = house[i].second;\n      if (s<x && x<t) {\n\tst |= (1<<i);\n      }\n    }\n  }\n\n  adj[an][bn] = adj[bn][an] = true;\n  up[an][bn] = up[bn][an] = st;\n}\n\nint f(int p, int st)\n{\n  if (p==n-1 && st==(1<<n)-1) {\n    return 1;\n  }\n  if (p==n-1 && st!=0) return 0;\n  \n  if (st < MEMO_LIM) {\n    if (memo[st][p]!=-1) {\n      return memo[st][p];\n    }\n  }\n\n  if ((st & near[n-1])==near[n-1]) {\n    if (st != (1<<(n-1))-1) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n  \n  for (int i=0; i < n-1; ++i) {\n    if ((st & near[i])==near[i] && (st&(1<<i))==0) {\n      return 0;\n    }\n  }\n  \n  \n  int res = 0;\n\n  for (int i=0; i < n; ++i) {\n    if ((st&(1<<i))>0) continue;\n    if (adj[p][i]==false) continue;\n    if ((up[p][i] & st)>0) continue;\n    res += f(i, (st|(1<<i)));\n  }\n  \n  if (st < MEMO_LIM) {\n    memo[st][p] = res;\n  }\n  return res;\n}\n\nint main()\n{\n  int w, h;\n  while (cin>>w>>h) {\n    if (!w && !h) break;\n\n    fill(&adj[0][0], &adj[N-1][N], false);\n    fill(&up[0][0], &up[N-1][N], 0);\n\n    house.clear();\n    P ch;\n    for (int i=0; i < h; ++i) {\n      for (int j=0; j < w; ++j) {\n\tint val;\n\tcin >> val;\n\tif (val==1) {\n\t  house.push_back(P(i,j));\n\t}\n\telse if (val==2) {\n\t  ch = P(i,j);\n\t}\n      }\n    }\n\n    house.push_back(ch);\n\n    n = house.size();\n    for (int i=0; i < n; ++i) {\n      for (int j=i+1; j < n; ++j) {\n\tcheck(i, j);\n      }\n    }\n\n    for (int i=0; i < n; ++i) {\n      near[i] = 0;\n      for (int j=0; j < n; ++j) {\n\tif (adj[i][j] && up[i][j]==0) {\n\t  near[i] |= (1<<j);\n\t}\n      }\n    }\n\n    fill(&memo[0][0], &memo[MEMO_LIM-1][N], -1);\n    int ans = f(n-1, 0);\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\n//int memo[1<<K][23];\nunordered_map<int, int> memo2[23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}*/\n\tif(table[i][j]>=0&&memo2[table[i][j]].find(done)!=memo2[table[i][j]].end())\n\t{\n\t\treturn memo2[table[i][j]][done];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\t/*\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(table[i][j]>=0){\n\t\t\t\t\tmemo2[table[i][j]][done]=0;\n\t\t\t\t}*/\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}*/\n\tif(table[i][j]>=0){\n\t\tmemo2[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tfor(int i=0;i<c;i++){\n\t\tmemo2[i].clear();\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint H[10][10];\nint hx[24], hy[24];\nint dp[1 << 24][24];\n\n\nint main() {\n\tint m, n;\n\twhile(scanf(\"%d%d\", &m, &n),m){\n\tint cnt=1;\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tint h; scanf(\"%d\", &h);\n\t\t\tH[i][j] = -1;\n\t\t\tif (h == 1) {\n\t\t\t\thx[cnt] = i; hy[cnt] = j;\n\t\t\t\tH[i][j] = cnt++;\n\t\t\t}\n\t\t\tif (h == 2) { H[i][j] = 0; hx[0] = i; hy[0] = j; }\n\t\t}\n\t}\n\trep(i,1<<cnt)rep(j,cnt)dp[i][j]=0;\n\tdp[0][0] = 1;\n\trep(i, 1 << cnt) {\n\t\trep(j, cnt) {\n\t\t\tif (!dp[i][j])continue;\n\t\t\tif ((i | j) && !((i >> j) & 1))continue;\n\t\t\tint x = hx[j], y = hy[j];\n\t\t\tfor (int k = 1; x + k < n; k++) {\n\t\t\t\tif (~H[x + k][y]) {\n\t\t\t\t\tif ((i >> H[x + k][y]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x + k][y])][H[x + k][y]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; x - k >= 0; k++) {\n\t\t\t\tif (~H[x - k][y]) {\n\t\t\t\t\tif ((i >> H[x - k][y]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x - k][y])][H[x - k][y]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; y + k < m; k++) {\n\t\t\t\tif (~H[x][y + k]) {\n\t\t\t\t\tif ((i >> H[x][y + k]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x][y + k])][H[x][y + k]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; y - k >= 0; k++) {\n\t\t\t\tif (~H[x][y - k]) {\n\t\t\t\t\tif ((i >> H[x][y - k]) & 1)break;\n\t\t\t\t\tdp[i | (1 << H[x][y - k])][H[x][y - k]] += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[(1 << cnt) - 1][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nconst int B = 19;\n//int dp[24][1 << B];\nmap<P, int> dp;\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (idx == hs && bits != (1 << hs + 1) - 1) {\n\t\tif (!bits) return 1;\n\t\telse 0;\n\t}\n\t//if (bits < 1 << B && ~dp[idx][bits]) return dp[idx][bits];\n\tif (dp.count(P(idx, bits))) return dp[P(idx, bits)];\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif (!((bits >> x) & 1)) continue;\n\t\tres += dfs(x, bits & ~(1 << x));\n\t\tbreak;\n\t}\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif (!((bits >> x) & 1)) continue;\n\t\tres += dfs(x, bits & ~(1 << x));\n\t\tbreak;\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif (!((bits >> x) & 1)) continue;\n\t\tres += dfs(x, bits & ~(1 << x));\n\t\tbreak;\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif (!((bits >> x) & 1)) continue;\n\t\tres += dfs(x, bits & ~(1 << x));\n\t\tbreak;\n\t}\n\treturn dp[P(idx, bits)] = res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\t//memset(dp, -1, sizeof(dp));\n\t\tdp.clear();\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, (1 << hs + 1) - 1) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\n#define PLANE (-1)\n#define HOUSE (1)\n#define CHURCH (100)\n\nusing namespace std;\n\nint x, y;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint home[10][10];\nint n;\nmap<int, int> memo[24];\n\nint goChurch(int ty, int tx)\n{\n    int i;\n    int my, mx;\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        while (0 <= my && my < y && 0 <= mx && mx < x){\n            if (home[my][mx] == CHURCH){\n                return (1);\n            }\n            my += dy[i];\n            mx += dx[i];\n        }\n    }\n    return (0);\n}\n\nint dfs(int v, int bit, int ty, int tx, char state[][11])\n{\n    int i;\n    int ky, kx;\n    int ans;\n    \n    if (memo[v].find(bit) != memo[v].end()){\n        return (memo[v][bit]);\n    }\n    \n    if (bit == (1 << n) - 1){\n        if (__builtin_popcount(bit) < 19){\n            return (memo[v][bit] = goChurch(ty, tx));\n        }\n        return (goChurch(ty, tx));\n    }\n    \n    ans = 0;\n    \n    for (i = 0; i < 4; i++){\n\t\tkx = tx + dx[i];\n        ky = ty + dy[i];\n        //ツ逆ツ渉づ可プツδ個ゼツδ督トツづーツ置ツつ「ツづつ「ツつュ\n\t\twhile (0 <= kx && kx < x && 0 <= ky && ky < y && (home[ky][kx] == PLANE || home[ky][kx] == CHURCH || state[ky][kx] == 1)){\n\t\t\tky += dy[i];\n            kx += dx[i];\n\t\t}\n\t\tif (0 <= kx && kx < x && 0 <= ky && ky < y){\n\t\t\tstate[ky][kx] = 1;\n\t\t\tans += dfs(home[ky][kx] , bit | (1 << home[ky][kx]) , ky, kx, state);\n\t\t\tstate[ky][kx] = 0;\n\t\t}\n\t}\n    \n    if (__builtin_popcount(bit) < 19){\n        memo[v][bit] = ans;\n    }\n\treturn (ans);\n}\n\n\nint main(void)\n{\n    int sy, sx;\n    int i, j;\n    char state[10][11];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        n = 0;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &home[i][j]);\n                if (home[i][j] == 2){\n                    home[i][j] = CHURCH;\n                    sy = i;\n                    sx = j;\n                }\n                else if (home[i][j] == HOUSE){\n                    home[i][j] = n++;\n                }\n                else if (home[i][j] == 0){\n                    home[i][j] = PLANE;\n                }\n            }\n        }\n        memset(state, 0, sizeof(state));\n        for (i = 0; i < 24; i++){\n            memo[i].clear();\n        }\n        printf(\"%d\\n\", dfs(n, 0, sy, sx, state));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <memory>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint field[12][12];\n\nint dfs(int cnt, int x, int y){\n    if(cnt == 0){\n    for(int i = 0; i < 4; i++){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      while(field[y2][x2] == 0){\n\ty2 += dy[i];\n\tx2 += dx[i];\n      }\n      if(field[y2][x2] == 2) return 1;\n    }\n    return 0;\n  }\n  int res = 0;\n  for(int i = 0; i < 4; i++){\n    int x2 = x + dx[i];\n    int y2 = y + dy[i];\n    while(field[y2][x2] == 0){\n      y2 += dy[i];\n      x2 += dx[i];\n    }\n    while(field[y2][x2] == 1){\n      field[y2][x2] = 3;\n      res += dfs(cnt - 1, x2, y2);\n      field[y2][x2] = 1;\n      x2 += dx[i];\n      y2 += dy[i];\n    }\n  }\n  return res;\n}\n\nint n, m, sx, sy, cnt;\nint main(){\n  while(cin >> m >> n && (n || m)){\n    cnt = 0;\n    fill(&field[0][0], &field[11][11] + 1, 3);\n    rep(i, n){\n      rep(j, m){\n\tcin >> field[i+1][j+1];\n\tif(field[i+1][j+1] == 2){\n\t  sx = j + 1;\n\t  sy = i + 1;\n\t}\n\tif(field[i+1][j+1] == 1){\n\t  cnt++;\n\t}\n      }\n    }\n    cout << dfs(cnt, sx, sy) << endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\nsigned main(){\n\tint m,n;\n\twhile(cin >> m >> n,m){\n\tmap<P,int> dp;\n\tint field[10][10],cnt = 1,x[24],y[24];\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < m;j++){\n\t\t\tscanf(\"%d\",&field[i][j]);\n\t\t\tif(field[i][j] == 1) {\n\t\t\t\tx[cnt] = i;\n\t\t\t\ty[cnt] = j;\n\t\t\t\tfield[i][j] = cnt++;\n\t\t\t}\n\t\t\telse if(field[i][j] == 2){\n\t\t\t\tfield[i][j] = -1;\n\t\t\t\tx[0] = i;\n\t\t\t\ty[0] = j;\n\t\t\t}\n\t\t}\n\t}\n\tcnt--;\n\tfor(int i = 0;i < (1 << cnt) - 1;i++){\n\t\tif(!i){\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tint tx = x[0] + dx[j],ty = y[0] + dy[j];\n\t\t\t\twhile(tx >= 0 && tx < n && ty >= 0 && ty < m){\n\t\t\t\t\tif(field[tx][ty] > 0){\n\t\t\t\t\t\tint t = field[tx][ty] - 1;\n\t\t\t\t\t\tdp[P(1 << t,t)] = 1;\n\t\t\t\t\t}\n\t\t\t\t\ttx += dx[j];\n\t\t\t\t\tty += dy[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j < cnt;j++){\n\t\t\tif((i >> j) & 1){\n\t\t\t\tfor(int k = 0;k < 4;k++){\n\t\t\t\t\tint tx = x[j + 1] + dx[k],ty = y[j + 1] + dy[k];\n\t\t\t\t\twhile(tx >= 0 && tx < n && ty >= 0 && ty < m){\n\t\t\t\t\t\t//cout << tx << \" \" << ty << endl;\n\t\t\t\t\t\tif(field[tx][ty] > 0){\n\t\t\t\t\t\t\tint t = field[tx][ty] - 1;\n\t\t\t\t\t\t\tif((i >> t) & 1) break;\n\t\t\t\t\t\t\t//cout << i << \" \" << t << \" \" << j << \" \" << dp[P(i,j)] << endl;\n\t\t\t\t\t\t\tdp[P(i | (1 << t),t)] += dp[P(i,j)];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttx += dx[k];\n\t\t\t\t\t\tty += dy[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int i = 0;i < 4;i++){\n\t\tint tx = x[0] + dx[i],ty = y[0] + dy[i];\n\t\twhile(tx >= 0 && tx < n && ty >= 0 && ty < m){\n\t\t\tif(field[tx][ty] > 0){\n\t\t\t\tres += dp[P((1 << cnt) - 1,field[tx][ty] - 1)];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += dx[i];\n\t\t\tty += dy[i];\n\t\t}\n\t}\n\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define DEB 0\n\n/*\nreal\t0m2.117s\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint hS[24],hx[24],hy[24],edge[24][4][24]; //[src][dir][dest]\n\n#if DEB\nint already_1,already_2;\n#endif\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x=_x; y=_y; s=_s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( s==a.s ){\n      if( x==a.x ) return y<a.y;\n      else         return x<a.x;\n    }else{\n      return s<a.s;\n    }\n  }\n  \n};\n\nmap<state,int> msi;\n\ninline bool isnotgoal(int s){\n  return (((last&s)) == last);\n}\ninline bool isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (hS[i]&s)==hS[i] ) return true;\n  }\n  return false;\n}\ninline bool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s, int src){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  state tmp(x,y,s);\n  if( msi.count(tmp) ){ //ùÉÊÁ½óÔ\n#if DEB\n    if( msi[tmp]>0 ){\n      already_1++;\n    }else{\n      already_2++;\n    }\n#endif\n    return msi[tmp];\n  }\n  \n  // v[gªu¯È¢ÆÌL³\n  // numofbits(~s&mask)>1\n  if( s>0 && ((s&(s-1))!=0) && isnot(s&~(1<<num[y][x])) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int j=0; edge[src][k][j]!=-1; j++){\n      int dest = edge[src][k][j];\n      int nx = hx[dest];\n      int ny = hy[dest];\n      if( field[ny][nx]==1 ){\n\tfield[ny][nx] = 0;\n\tret += dfs(nx, ny, s|(1<<dest), dest);\n\tfield[ny][nx] = 1;\n\tbreak;\n      }\n    }\n  }\n  /*\n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  */\n  msi[tmp] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    memset(edge,-1,sizeof(edge));\n    memset(hS,0,sizeof(hS));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx=j; sy=i;\n\t}\n\tif( field[i][j]==1 ){\n\t  hx[home]=j; hy[home]=i;\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    // other homes\n    rep(i,home){\n      rep(k,4){\n\tint sz = 0;\n\tfor(int j=1; j<20; j++){\n\t  int tx = hx[i] + dx[k]*j;\n\t  int ty = hy[i] + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    hS[i] |= (1<<num[ty][tx]);\n\t    edge[i][k][sz++] = num[ty][tx];\n\t  }\n\t}\n      }\n    }\n\n#if DEB\n    rep(i,home){\n      printf(\"i:(%d,%d)\\n\",hx[i],hy[i]);\n    }\n    rep(i,home){\n      rep(k,4){\n\tfor(int j=0; edge[i][k][j]!=-1;j++){\n\t  printf(\"i:%d(%d)  --> %d\\n\",i,k,edge[i][k][j]);\n\t}\n      }\n    }\n#endif\n\n    //last homes\n    rep(k,4){\n      int sz = 0;\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t  edge[home][k][sz++] = num[ty][tx];\n\t}\n      }\n    }\n    printf(\"%d\\n\",dfs(sx,sy,0,home));\n\n#if DEB\n    int cnt = 0;\n    map<state,int>::iterator it;\n    for(it=msi.begin(); it!=msi.end(); it++){\n      if( it->second == 0 ){\n\tcnt++;\n      }\n    }\n    printf(\"msi_sz:%d  >0:%d  ==0:%d  already>0:%d , already==0:%d\\n\",msi.size(),msi.size()-cnt,cnt,already_1,already_2);\n    already_1 = already_2 = 0;\n#endif\n\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef pair<int, int> pii;\n\nmap<pii, int> data; // ????????§????¨??????????????????°, ?????¨????????? = ????????????????????°\nvector<int> g[10][4]; // 0?????????, ??????????????¶????????????g[i][j] i??????????????? j:0???????????????, 1???, 2???, 3???????????§?????????\nint maps[10][10];\nint m, n;\nint cnt;\n\nint dfs(int used, int pos) {\n\tif (data.find(pii(used, pos)) != data.end()) return data[pii(used, pos)];\n\tif (pos == 0) return used == (1<<cnt) - 1;\n\t\n\tint res = 0;\n\t\n\tREP(i, 4) {\n\t\tREP(j, g[pos][i].size()) {\n\t\t\tint to = g[pos][i][j];\n\t\t\tif ((used >> to) & 1) break;\n\t\t\tres += dfs(used | (1<<to), to);\n\t\t}\n\t}\n\t\n\treturn data[pii(used, pos)] = res;\n}\n\nint main() {\n\twhile (cin >> m >> n, m || n) {\n\t\tREP(i, n) REP(j, m) scanf(\"%d\", &maps[i][j]);\n\t\t\n\t\tcnt = 1;\n\t\tREP(i, n) {\n\t\t\tREP(j, m) {\n\t\t\t\tint tmp = -1;\n\t\t\t\tswitch(maps[i][j]) {\n\t\t\t\t\tcase 1: tmp = cnt++; break;\n\t\t\t\t\tcase 2: tmp = 0; break;\n\t\t\t\t}\n\t\t\t\tmaps[i][j] = tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(i, cnt) REP(j, 4) g[i][j].clear();\n\t\tdata.clear();\n\t\t\n\t\tREP(i, n) REP(j, m) {\n\t\t\tint from = maps[i][j];\n\t\t\tif (from != -1) {\n\t\t\t\tint tmp = 0;\n\t\t\t\tREP(k, n) if (maps[k][j] != -1) {\n\t\t\t\t\tif (k == i) tmp++;\n\t\t\t\t\telse g[from][tmp].push_back(maps[k][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttmp = 2;\n\t\t\t\tREP(k, m) if (maps[i][k] != -1) {\n\t\t\t\t\tif (k == j) tmp++;\n\t\t\t\t\telse g[from][tmp].push_back(maps[i][k]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treverse(g[from][0].begin(), g[from][0].end());\n\t\t\t\treverse(g[from][2].begin(), g[from][2].end());\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tREP(i, 4) REP(j, g[0][i].size()) ans += dfs(1<<g[0][i][j], g[0][i][j]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint a[10][10];\nint w, h;\nint sx, sy;\nint N;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint tmp1[10], tmp2[10];\nint dfs(int x, int y, int n){\n  if(n == N){\n    //REP(i, n) printf(\"(%d %d) \", tmp1[i], tmp2[i]);\n    //cout<<endl;\n    if(x == sx || y == sy) return 1;\n    else return 0;\n  }\n  int res = 0;\n  REP(r, 4){\n    int nx = x + dx[r];\n    int ny = y + dy[r];\n    while(nx >= 0 && nx < w && ny >= 0 && ny < h){\n      if(a[ny][nx] == 1){\n        break;\n      }\n      ny += dy[r];\n      nx += dx[r];\n    }\n    if(nx >= 0 && nx < w && ny >= 0 && ny < h){\n      assert(a[ny][nx] == 1);\n      a[ny][nx] = 0;\n      //tmp1[n] = nx, tmp2[n] = ny;\n      res += dfs(nx, ny, n + 1);\n      a[ny][nx] = 1;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  while(cin>>w>>h && w){\n    N = 0;\n    REP(y, h) REP(x, w){\n      cin>>a[y][x];\n      if(a[y][x] == 2){\n        a[y][x] = 0;\n        sx = x, sy = y;\n      }\n      if(a[y][x] == 1) N ++;\n    }\n    cout<<dfs(sx, sy, 0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp.find(P(bit,h)) != dp.end()){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) > 10) dp[P(bit,h)] = ret;\n  return ret;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0) << endl;\n    break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/* よいウンコードの例 */\n\n#include <cstdio>\n#include <stack>\n\nusing namespace std;\n\n#define EMPTY 0\n#define YET_DELIVERED 1\n#define CHURCH 2\n#define DELIVERED 3\n\nint m;\nint n;\nint count;\nint house_num;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0,  0, -1, 1};\nint map[10][10];\n\nvoid rec(char x, char y) {\n\tchar i;\n\tchar times = 0;\n    char x2;\n    char y2;\n    stack<char> s;\n\tchar k;\n\ncall:\n    i = 0;\n\nloop:\n    x2 = x;\n    y2 = y;\n\n\twhile (1) {\n\t\tx2 += dx[i];\n\t\ty2 += dy[i];\n\n\t\tif (x2 >= m || x2 < 0 || y2 >= n || y2 <0) break;\n\t\tif (map[y2][x2] == DELIVERED) break;\n\n\t\tif (map[y2][x2] == CHURCH) {\n\t\t\tif (times == house_num) {\n\t\t\t\t++count;\n\t\t\t}\n\t\t} else if (map[y2][x2] == YET_DELIVERED) {\n\t\t\tmap[y2][x2] = DELIVERED;\n\t\t\ts.push(i);\n\t\t\ts.push(x);\n\t\t\ts.push(y);\n\t\t\tx = x2;\n\t\t\ty = y2;\n\t\t\t++times;\n\t\t\tgoto call;\n\t\t}\n\nresume:\n        ;\n\t}\n\n\t++i;\n\tif (i < 4) {\n    \tgoto loop;\n    }\n\n\tif (s.empty()) return ;\n\n    map[y][x] = YET_DELIVERED;\n\t--times;\n\tx2 = x;\n\ty2 = y;\n\ty = s.top(); s.pop();\n\tx = s.top(); s.pop();\n\ti = s.top(); s.pop();\n\n\tgoto resume;\n}\n\n\nint main() {\n\twhile (1) {\n\t\tint i;\n\t\tint church_x, church_y;\n\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif ((m | n) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tcount = 0;\n\t\thouse_num = 0;\n\n\t\tfor (i=0; i<n; i++) {\n\t\t\tint j;\n\n\t\t\tfor (j=0; j<m; j++) {\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t\tif (map[i][j] == YET_DELIVERED) {\n\t\t\t\t\t++house_num;\n\t\t\t\t} else if (map[i][j] == CHURCH) {\n\t\t\t\t\tchurch_x = j;\n\t\t\t\t\tchurch_y = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trec((char)church_x, (char)church_y);\n\t\tprintf(\"%d\\n\", count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h)) {\n\t\tif (!w && !h)\n\t\t\tbreak;\n\t\tvector<vector<char>> mp(w, vector<char>(h, -1));\n\t\tpii cha;\n\t\tvector<pair<char, char>> homp;\n\t\tint homc = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tint a = 0;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tif (a == 2) {\n\t\t\t\t\tcha = { j,i };\n\t\t\t\t}\n\t\t\t\tif (a == 1) {\n\t\t\t\t\thomp.push_back({ j,i });\n\t\t\t\t\tmp[j][i] = homc;\n\t\t\t\t\thomc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thomp.push_back(cha);\n\t\tset<int> targets;\n\t\tint ccn;\n\t\tfor (int j = cha.first; w > j; j++) {\n\t\t\tccn = mp[j][cha.second];\n\t\t\tif (ccn > -1) {\n\t\t\t\ttargets.insert(ccn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.first; 0 <= j; j--) {\n\t\t\tccn = mp[j][cha.second];\n\t\t\tif (ccn > -1) {\n\t\t\t\ttargets.insert(ccn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; h > j; j++) {\n\t\t\tccn = mp[cha.first][j];\n\t\t\tif (ccn > -1) {\n\t\t\t\ttargets.insert(ccn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; 0 <= j; j--) {\n\t\t\tccn = mp[cha.first][j];\n\t\t\tif (ccn > -1) {\n\t\t\t\ttargets.insert(ccn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmap<pair<int, char>, int> dp[2];//?±\\??´????????¨??°\n\t\tdp[0][{0, homc}] = 1;\n\t\tbool t = 0;\n\t\tREP(i, homc) {\n\t\t\tfor (auto cur : dp[t]) {\n\t\t\t\tpii curpos = homp[cur.first.second];\n\t\t\t\tint cnum;\n\t\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!bitcheck(cur.first.first, cnum)) {\n\t\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!bitcheck(cur.first.first, cnum)) {\n\t\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!bitcheck(cur.first.first, cnum)) {\n\t\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!bitcheck(cur.first.first, cnum)) {\n\t\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[t].clear();\n\t\t\tt = 1 - t;\n\t\t}\n\t\tint ans = 0;\n\n\t\tfor (auto cur : dp[t]) {\n\t\t\tif (targets.find(cur.first.second) != targets.end())\n\t\t\t\tans += cur.second;\n\t\t}\n\n\t\tdp[1 - t].clear();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp.find(P(bit,h)) != dp.end()){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) < 13) dp[P(bit,h)] = ret;\n  return ret;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\nint m, n;\nint f[11][11];\nPII c;\nint hn = 0;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nll dfs(int x, int y, int sum){\n\tll res = 0;\n\tif(x == c.fst && y == c.snd){\n\t\tif(sum == hn){\n\t\t\treturn 1;\n\t\t}else if(sum > 0){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP(i, 4){\n\t\tint nx = dx[i]+x, ny = dy[i]+y;\n\t\twhile(1){\n\t\t\tif(nx < 0 || m <= nx || ny < 0 || n <= ny) break;\n\t\t\tif(f[nx][ny] == 2)\n\t\t\t\tres += dfs(nx, ny, sum+1);\n\t\t\tif(f[nx][ny] == 1){\n\t\t\t\tf[nx][ny] = -1;\n\t\t\t\tres += dfs(nx, ny, sum+1);\n\t\t\t\tf[nx][ny] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnx += dx[i];\n\t\t\tny += dy[i];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> m >> n && m && n){\n\thn = 0;\n\tREP(i, n){\n\t\tREP(j, m){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif(a == 1){\n\t\t\t\tf[j][i] = 1;\n\t\t\t\thn++;\n\t\t\t}else if(a == 2){\n\t\t\t\tc = {j, i};\n\t\t\t\tf[j][i] = 2;\n\t\t\t\thn++;\n\t\t\t}else{\n\t\t\t\tf[j][i] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << dfs(c.fst, c.snd, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint H[10][10];\nint hx[24], hy[24];\nint dp[1 << 24][24];\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint cnt = 1;\n\t\trep(i, n) {\n\t\t\trep(j, m) {\n\t\t\t\tint h; scanf(\"%d\", &h);\n\t\t\t\tH[i][j] = -1;\n\t\t\t\tif (h == 1) {\n\t\t\t\t\thx[cnt] = i; hy[cnt] = j;\n\t\t\t\t\tH[i][j] = cnt++;\n\t\t\t\t}\n\t\t\t\tif (h == 2) { H[i][j] = 0; hx[0] = i; hy[0] = j; }\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][0] = 1;\n\t\trep(i, 1 << cnt) {\n\t\t\trep(j, cnt) {\n\t\t\t\tif (!dp[i][j])continue;\n\t\t\t\tif ((i | j) && !((i >> j) & 1))continue;\n\t\t\t\tint x = hx[j], y = hy[j];\n\t\t\t\tfor (int k = 1; x + k < n; k++) {\n\t\t\t\t\tif (~H[x + k][y]) {\n\t\t\t\t\t\tif ((i >> H[x + k][y]) & 1)break;\n\t\t\t\t\t\tdp[i | (1 << H[x + k][y])][H[x + k][y]] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 1; x - k >= 0; k++) {\n\t\t\t\t\tif (~H[x - k][y]) {\n\t\t\t\t\t\tif ((i >> H[x - k][y]) & 1)break;\n\t\t\t\t\t\tdp[i | (1 << H[x - k][y])][H[x - k][y]] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 1; y + k < m; k++) {\n\t\t\t\t\tif (~H[x][y + k]) {\n\t\t\t\t\t\tif ((i >> H[x][y + k]) & 1)break;\n\t\t\t\t\t\tdp[i | (1 << H[x][y + k])][H[x][y + k]] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 1; y - k >= 0; k++) {\n\t\t\t\t\tif (~H[x][y - k]) {\n\t\t\t\t\t\tif ((i >> H[x][y - k]) & 1)break;\n\t\t\t\t\t\tdp[i | (1 << H[x][y - k])][H[x][y - k]] += dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dp[(1 << cnt) - 1][0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint c[10][10];\nint w,h;\nint sx,sy;\nbool done[10][10];\nint nh;\nint solve(int x,int y,int nd){\n\tint res=0;\n\tint i,j;\n\tfor(i=x+1;i<w;i++){\n\t\tif(nd==nh&&i==sx&&y==sy)return 1;\n\t\tif(done[i][y]&&c[i][y]==1){\n\t\t\tdone[i][y]=false;\n\t\t\tres+=solve(i,y,nd+1);\n\t\t\tdone[i][y]=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=x-1;i>=0;i--){\n\t\tif(nd==nh&&i==sx&&y==sy)return 1;\n\t\tif(done[i][y]&&c[i][y]==1){\n\t\t\tdone[i][y]=false;\n\t\t\tres+=solve(i,y,nd+1);\n\t\t\tdone[i][y]=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i=y+1;i<h;i++){\n\t\tif(nd==nh&&x==sx&&i==sy)return 1;\n\t\tif(done[x][i]&&c[x][i]==1){\n\t\t\tdone[x][i]=false;\n\t\t\tres+=solve(x,i,nd+1);\n\t\t\tdone[x][i]=true;\n\t\t\tbreak;\n\t\t}\n\t}for(i=y-1;i>=0;i--){\n\t\tif(nd==nh&&x==sx&&i==sy)return 1;\n\t\tif(done[x][i]&&c[x][i]==1){\n\t\t\tdone[x][i]=false;\n\t\t\tres+=solve(x,i,nd+1);\n\t\t\tdone[x][i]=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\t\t\n\nint main(){\n\tint i,j;\n\twhile(1){\n\tnh=0;\n\tscanf(\"%d %d\",&w,&h);\n\t\tif(w==0)return 0;\n\tfor(i=0;i<w;i++)for(j=0;j<h;j++)done[i][j]=true;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\tscanf(\"%d\",&c[j][i]);\n\t\tif(c[j][i]==1)nh++;\n\t\tif(c[j][i]==2){sx=j;sy=i;}\n\t}\n\tint ans=solve(sx,sy,0);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;}\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 3 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = signed;\n\nInt s[20][20],idx[20][20],cnt,pru;\nInt u[40][4];\nInt num[40],ok[40];\nvector<vector<vector<Int> > > G;\n\nInt dfs(Int z,Int b){\n  if(b==(1<<cnt)-1) return ok[z];\n  if((b&pru)==pru) return 0;\n  \n  Int res=0;\n  \n  for(Int k=0;k<4;k++){\n    for(auto w:G[z][k]){\n      if((b>>w)&1) break;\n      Int nb=b^(1<<w),flg=1;\n      for(Int i=0;i<4;i++){\n\tif(u[w][i]>=cnt) continue; \n\tnum[u[w][i]]--;\n\tif((~nb>>u[w][i])&1)\n\t  flg&=num[u[w][i]]>=1;\n      }\n      if(flg) res+=dfs(w,nb);\n      for(Int i=0;i<4;i++) num[u[w][i]]++;\n    }\n  }\n\t\n  return res;\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int w,h;\n  while(cin>>w>>h,w+h){\n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tcin>>s[i][j];\n    \n    cnt=0;\n    for(Int i=0;i<h;i++){\n      for(Int j=0;j<w;j++){\n\tidx[i][j]=cnt;\n\tcnt+=s[i][j]==1;\n      }\n    }\n    \n    for(Int i=0;i<h;i++)\n      for(Int j=0;j<w;j++)\n\tif(s[i][j]==2) idx[i][j]=cnt;\n    \n    Int dy[]={0,0,1,-1};\n    Int dx[]={1,-1,0,0};\n    auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};    \n\n    G.clear();\n    G.resize(cnt+1);\n    \n    memset(num,0,sizeof(num));    \n    memset(ok,0,sizeof(ok));\n    \n    for(Int y=0;y<h;y++){\n      for(Int x=0;x<w;x++){\n\tif(s[y][x]==0) continue;\n\tInt z=idx[y][x];\n\tG[z].resize(4);\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y,nx=x;\n\t  while(1){\n\t    ny+=dy[k],nx+=dx[k];\n\t    while(in(ny,nx)&&s[ny][nx]==0)\n\t      ny+=dy[k],nx+=dx[k];\n\t    if(!in(ny,nx)) break;\t    \n\t    if(s[ny][nx]==2) ok[z]=1;\n\t    else G[z][k].emplace_back(idx[ny][nx]);\n\t  }\n\t}\n\t\n\tfor(Int k=0;k<4;k++){\n\t  u[z][k]=cnt+1;\n\t  for(auto w:G[z][k]){\n\t    u[z][k]=w;\n\t    num[w]++;\n\t    break;\n\t  }\n\t}\n\t\n\tif(z==cnt){\n\t  pru=0;\n\t  for(Int k=0;k<4;k++){\n\t    for(auto w:G[z][k]){\n\t      pru|=(1<<w);\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    cout<<dfs(cnt,0)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nconst int LIM = 15;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=LIM){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=LIM){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\nusing namespace std;\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nmap<int,int> memo;\n\nint func( int p, int d, int u ){\n\twhile(1){\n\t\tint h = mp[p];\n\t\tif( h >= 0 ){\n\t\t\tint s = 0;\n\t\t\tmp[p] = -1;\n\t\t\ths ^= 1 << h;\n\t\t\tif( u > 12 ){\n\t\t\t\tfor(int i = 0; i < 4; i++ )\n\t\t\t\t\ts += func( p + dir[i], dir[i], u - 1 );\n\t\t\t}else{\n\t\t\t\tint mi = h << 23 | hs;\n\t\t\t\tmap<int,int>::iterator it = memo.find(mi);\n\t\t\t\tif( it == memo.end() ){\n\t\t\t\t\tfor(int i = 0; i < 4; i++ )\n\t\t\t\t\t\ts += func( p + dir[i], dir[i], u - 1 );\n\t\t\t\t\tmemo[mi] = s;\n\t\t\t\t}else{\n\t\t\t\t\ts = it->second;\n\t\t\t\t}\n\t\t\t}\n\t\t\ths |= 1 << h;\n\t\t\tmp[p] = h;\n\t\t\treturn s;\n\t\t}\n\t\tif( h == -9 )break;\n\t\tp += d;\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tmemo.clear();\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\tj = hs;\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt += func( ch + dir[i], dir[i], j );\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint m,n,map[10][10];\nint solve(int X,int Y,int L) {\n\tbool H=false;\n\tif(map[X][Y]==1) map[X][Y]=0,H=true;\n\tint R=0;\n\tfor(int x=X-1;x>=0;x--) {\n\t\tif(map[x][Y]==1) {\n\t\t\tR+=solve(x,Y,L-1); break;\n\t\t}else if(map[x][Y]==2&&L==0) {\n\t\t\tif(H) map[X][Y]=1;\n\t\t\treturn R+1;\n\t\t}\n\t}\n\tfor(int x=X+1;x<m;x++) {\n\t\tif(map[x][Y]==1) {\n\t\t\tR+=solve(x,Y,L-1); break;\n\t\t}else if(map[x][Y]==2&&L==0) {\n\t\t\tif(H) map[X][Y]=1;\n\t\t\treturn R+1;\n\t\t}\n\t}\n\tfor(int y=Y-1;y>=0;y--) {\n\t\tif(map[X][y]==1) {\n\t\t\tR+=solve(X,y,L-1); break;\n\t\t}else if(map[X][y]==2&&L==0) {\n\t\t\tif(H) map[X][Y]=1;\n\t\t\treturn R+1;\n\t\t}\n\t}\n\tfor(int y=Y+1;y<n;y++) {\n\t\tif(map[X][y]==1) {\n\t\t\tR+=solve(X,y,L-1); break;\n\t\t}else if(map[X][y]==2&&L==0) {\n\t\t\tif(H) map[X][Y]=1;\n\t\t\treturn R+1;\n\t\t}\n\t}\n\tif(H) map[X][Y]=1;\n\treturn R;\n}\nint main() {\n\twhile(scanf(\"%d %d\",&m,&n),m|n) {\n\t\tint X,Y,H=0;\n\t\tfor(int y=0;y<n;y++) for(int x=0;x<m;x++) {\n\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\tif(map[x][y]==1) H++; else if(map[x][y]==2) X=x,Y=y;\n\t\t}\n\t\tprintf(\"%d\\n\",solve(X,Y,H));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n\nint dp[1<<23][23]; //ここまで、現在地\nbool already[1<<23][23] = {};\nvector<pair<int,int>> way[23];\n\nint solve(int i, int j){\n\tif(already[i][j]) return dp[i][j];\n\tdp[i][j] = 0;\n\tif((i&(1<<j)) == 0) return 0;\n\tfor(int k=0; k<way[j].size(); k++){\n\t\tif((i&way[j][k].second) == 0 && (i&(1<<way[j][k].first)) == 0){\n\t\t\tdp[i][j] += solve(i+(1<<way[j][k].first), way[j][k].first);\n\t\t}\n\t}\n\talready[i][j] = true;\n\treturn dp[i][j];\n}\n\nint main() {\n\tiostream::sync_with_stdio(false);\n\n\tSTART:\n\t\n\tint m,n;\n\tcin >> m >> n;\n\tif(n == 0 && m == 0) return 0;\n\tint a[10][10];\n\tvector<pair<int,int> > house;\n\tpair<int,int> kyokai;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\tif(a[i][j] == 0) a[i][j] = -1; //空地\n\t\t\telse if(a[i][j] == 2){\n\t\t\t\ta[i][j] = -2; //教会\n\t\t\t\tkyokai = MP(i,j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ta[i][j] = house.size();\n\t\t\t\thouse.push_back(MP(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\t//経路計算\n\tfor(int i=0; i<house.size(); i++){\n\t\tway[i].clear();\n\t\tint x = house[i].first;\n\t\tint y = house[i].second;\n\t\tint tmp = 0;\n\t\tfor(int j=x+1; j<n; j++){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=x-1; j>=0; j--){\n\t\t\tif(a[j][y] >= 0){\n\t\t\t\tway[i].push_back(MP(a[j][y],tmp));\n\t\t\t\ttmp += 1<<a[j][y];\n\t\t\t}\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=y+1; j<m; j++){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t\ttmp = 0;\n\t\tfor(int j=y-1; j>=0; j--){\n\t\t\tif(a[x][j] >= 0){\n\t\t\t\tway[i].push_back(MP(a[x][j],tmp));\n\t\t\t\ttmp += 1<<a[x][j];\n\t\t\t}\n\t\t}\n\t}\n\n\t//教会隣接家dp初期化\n\tfor(int i=0; i<house.size(); i++){\n\t\tdp[(1<<house.size())-1][i] = 0;\n\t\talready[(1<<house.size())-1][i] = true;\n\t}\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[i][kyokai.second]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tdp[(1<<house.size())-1][a[kyokai.first][i]] = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(int i=(1<<house.size())-2; i>=0; i--){ //2^23\n\t\tfor(int j=0; j<house.size(); j++){ //23\n\t\t\talready[i][j] = false;\n\t\t}\n\t}\n\n\t/*\n\t//dp\n\tfor(int i=(1<<house.size())-2; i>=0; i--){ //2^23\n\t\tfor(int j=0; j<house.size(); j++){ //23\n\t\t\tdp[i][j] = 0;\n\t\t\tif((i&(1<<j)) == 0) continue;\n\t\t\tfor(int k=0; k<way[j].size(); k++){ //20\n\t\t\t\tif((i&way[j][k].second) == 0 && (i&(1<<way[j][k].first)) == 0){\n\t\t\t\t\tdp[i][j] += dp[i+(1<<way[j][k].first)][way[j][k].first];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t//最終的な答え\n\tint ans = 0;\n\tfor(int i=kyokai.first+1; i<n; i++){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += solve(1<<a[i][kyokai.second],a[i][kyokai.second]);\n\t\t}\n\t}\n\tfor(int i=kyokai.first-1; i>=0; i--){\n\t\tif(a[i][kyokai.second] >= 0){\n\t\t\tans += solve(1<<a[i][kyokai.second],a[i][kyokai.second]);\n\t\t}\n\t}\n\tfor(int i=kyokai.second+1; i<m; i++){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += solve(1<<a[kyokai.first][i],a[kyokai.first][i]);\n\t\t}\n\t}\n\tfor(int i=kyokai.second-1; i>=0; i--){\n\t\tif(a[kyokai.first][i] >= 0){\n\t\t\tans += solve(1<<a[kyokai.first][i],a[kyokai.first][i]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\tgoto START;\n\n\t/*\n\t//デバッグ\n\tfor(int i=0; i<house.size(); i++){\n\t\tfor(int j=0; j<way[i].size(); j++){\n\t\t\tcout << way[i][j].first << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tfor(int i=0; i<(1<<house.size()); i++){\n\t\tfor(int j=0; j<house.size(); j++){\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\nint CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\nbool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool CanDown(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tif (x == sx && y == sy && CountBit(s) == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\tif (itr != memo.end()) return itr->second;\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\treturn memo[state] = sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include <bitset>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\nint i, j, k;\nint m, n, coun, ans, jud = 1;\nint town[11][11];\nP start;\nvoid dfs(int y, int x, int flag);\n\ninline int bit(int n, int i) {\n\treturn n | 1 << (i - 1);\n}\n\ninline bool bitj(int n, int i) {\n\tif (n & 1 << (i - 1))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\nint main() {\n\twhile (cin >> m >> n&& m && n) {\n\t\tans = 0;\n\t\tcoun = 1;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tfor (j = 1; j <= m; j++) {\n\t\t\t\tcin >> town[i][j];\n\t\t\t\tif (town[i][j] == 2) {\n\t\t\t\t\tstart = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\tif (town[i][j]) {\n\t\t\t\t\ttown[i][j] = coun;\n\t\t\t\t\tcoun++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjud = 1;\n\t\tfor (i = 0; i < coun - 1; i++) {\n\t\t\tjud *= 2;\n\t\t}\n\t\tdfs(start.first, start.second, 0);\n\t\tcout << ans << endl;\n\t}\n}\nvoid dfs(int y, int x, int flag) {\n\tif (start == make_pair(y, x)) {\n\t\tif (flag == jud - 1) {\n\t\t\tans++;\n\t\t}\n\t\tif (flag) {\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (i = x + 1; i <= m; i++) {\n\t\tif (town[y][i] && bitj(flag, town[y][i])) {\n\t\t\tdfs(y, i, bit(flag, town[y][i]));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = x - 1; i > 0; i--) {\n\t\tif (town[y][i] && bitj(flag, town[y][i])) {\n\t\t\tdfs(y, i, bit(flag, town[y][i]));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = y + 1; i <= n; i++) {\n\t\tif (town[i][x] && bitj(flag, town[i][x])) {\n\t\t\tdfs(i, x, bit(flag, town[i][x]));\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = y - 1; i > 0; i--) {\n\t\tif (town[i][x] && bitj(flag, town[i][x])) {\n\t\t\tdfs(i, x, bit(flag, town[i][x]));\n\t\t\tbreak;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h,int k){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny],k-1);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) < 10) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0,c) << endl;\n    break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/10/22 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint DFS(int M[12][12], int N, int Y, int X, int Y2, int X2)\n{\n//\tcout << M[Y][X] << ' ' << N << endl;\n\n\tif(M[Y][X]==1)\n\t\tN--;\n\n\tif(N==0)\n\t\tif(Y==Y2||X==X2)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn 0;\n\n\tM[Y][X] = 0;\n\n\tint cnt = 0;\n\n\tint y = Y;\n\tint x = X;\n\ty--;\n\twhile(M[y][x]==0)\n\t\ty--;\n\tif(M[y][x]==1)\n\t\tcnt += DFS(M, N, y, x, Y2, X2);\n\n\ty = Y;\n\tx = X;\n\ty++;\n\twhile(M[y][x]==0)\n\t\ty++;\n\tif(M[y][x]==1)\n\t\tcnt += DFS(M, N, y, x, Y2, X2);\n\n\ty = Y;\n\tx = X;\n\tx--;\n\twhile(M[y][x]==0)\n\t\tx--;\n\tif(M[y][x]==1)\n\t\tcnt += DFS(M, N, y, x, Y2, X2);\n\n\ty = Y;\n\tx = X;\n\tx++;\n\twhile(M[y][x]==0)\n\t\tx++;\n\tif(M[y][x]==1)\n\t\tcnt += DFS(M, N, y, x, Y2, X2);\n\n\tM[Y][X] = 1;\n\treturn cnt;\n}\n\nint main()\n{\n\twhile(true){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m==0&&n==0)\n\t\t\tbreak;\n\n\t\tint M[12][12];\n\t\tfor(int y=0; y<n+2; y++)\n\t\t\tfor(int x=0; x<m+2; x++)\n\t\t\t\tM[y][x] = 3;\n\n\t\tint N = 0;\n\t\tint Y, X;\n\t\tfor(int y=1; y<=n; y++){\n\t\t\tfor(int x=1; x<=m; x++){\n\t\t\t\tcin >> M[y][x];\n\t\t\t\tif(M[y][x]==1){\n\t\t\t\t\tN++;\n\t\t\t\t}\n\t\t\t\telse if(M[y][x]==2){\n\t\t\t\t\tY = y;\n\t\t\t\t\tX = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cnt;\n\t\tcnt = DFS(M, N, Y, X, Y, X);\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp.find(P(bit,h)) != dp.end()){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) > 10) dp[P(bit,h)] = ret;\n  return ret;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], int bi, int bj, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( state( bi, bj ) );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    \n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    bfs(M,charch.fr,charch.sc,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T b) { a = min(a, b); }\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\ndeque<int> edge[24][4];\nint n;\n//int dp[24][1 << 23];\nint dfs(int p, int visit)\n{\n\t//if (~dp[p][visit])\n\t//\treturn dp[p][visit];\n\t//else\n\t\tif (!visit)\n\t{\n\t\tbool f = false;\n\t\trep (i, 4)\n\t\t\tif (!edge[p][i].empty())\n\t\t\t\tf |= edge[p][i].front() == n;\n\t\t//return dp[p][visit] = f ? 1 : 0;\n\t\treturn f ? 1 : 0;\n\t}\n\n\tint res = 0;\n\trep (i, 4)\n\t{\n\t\tforeach (e, edge[p][i])\n\t\t{\n\t\t\tif (*e == n)\n\t\t\t\tcontinue;\n\t\t\tif (!(visit & (1 << *e)))\n\t\t\t\tbreak;\n\n\t\t\tres += dfs(*e, visit ^ (1 << *e));\n\t\t}\n\t}\n\n\t//return dp[p][visit] = res;\n\treturn res;\n}\nint main()\n{\n\tint h, w;\n\twhile (scanf(\"%d%d\", &w, &h), w | h)\n\t{\n\t\trep (i, 30)\n\t\t\trep (j, 4)\n\t\t\t\tedge[i][j].clear();\n\n\t\tpint church;\n\t\tvector<pint> pos;\n\t\trep (i, h)\n\t\t{\n\t\t\trep (j, w)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tif (t == 1)\n\t\t\t\t\tpos.push_back(pint(j, i));\n\t\t\t\telse if (t == 2)\n\t\t\t\t\tchurch = pint(j, i);\n\t\t\t}\n\t\t}\n\t\tn = pos.size();\n\t\tpos.push_back(church);\n\n\t\trep (i, pos.size())\n\t\t{\n\t\t\tvector<pint> hor, ver;\n\t\t\trep (j, pos.size())\n\t\t\t{\n\t\t\t\tif (pos[i].first == pos[j].first)\n\t\t\t\t\tver.push_back(pint(pos[j].second, j));\n\t\t\t\telse if (pos[i].second == pos[j].second)\n\t\t\t\t\thor.push_back(pint(pos[j].first, j));\n\t\t\t}\n\t\t\tsort(all(hor));\n\t\t\tsort(all(ver));\n\n\t\t\tforeach (it, hor)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].first)\n\t\t\t\t\tedge[i][3].push_front(it->second);\n\t\t\t\telse if (pos[i].first < it->first)\n\t\t\t\t\tedge[i][1].push_back(it->second);\n\t\t\t}\n\t\t\tforeach (it, ver)\n\t\t\t{\n\t\t\t\tif (it->first < pos[i].second)\n\t\t\t\t\tedge[i][2].push_front(it->second);\n\t\t\t\telse if (pos[i].second < it->first)\n\t\t\t\t\tedge[i][0].push_back(it->second);\n\t\t\t}\n\t\t}\n\n\t\t//rep (i, n + 1)\n\t\t//{\n\t\t//\tprintf(\">%d: (%d, %d)\\n\", i, pos[i].first, pos[i].second);\n\t\t//\trep (j, 4)\n\t\t//\t{\n\t\t//\t\tprintf(\"%d: \", j);\n\t\t//\t\tforeach (t, edge[i][j])\n\t\t//\t\t\tprintf(\"(%d, %d) \", pos[*t].first, pos[*t].second);\n\t\t//\t\tputs(\"\");\n\t\t//\t}\n\t\t//}\n\n\t\t//memset(dp, ~0, sizeof(dp));\n\t\tint all_visit = (1 << n) - 1;\n\t\tprintf(\"%d\\n\", dfs(n, all_visit));\n\n\t\t//int s = 0;\n\t\t//rep (i, n)\n\t\t//\tif (~dp[i][0])\n\t\t//\t\ts += dp[i][0];\n\t\t//printf(\"%d\\n\", s);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//MLE\n#include <cstdio>\n#include <map>\nusing namespace std;\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nmap<int,int> memo;\n\nint func( int p, int d, int u ){\n\twhile(1){\n\t\tint h = mp[p];\n\t\tif( h >= 0 ){\n\t\t\tint s = 0;\n\t\t\tmp[p] = -1;\n\t\t\ths ^= 1 << h;\n\t\t\tif( u > 9 ){\n\t\t\t\tfor(int i = 0; i < 4; i++ )\n\t\t\t\t\ts += func( p + dir[i], dir[i], u - 1 );\n\t\t\t}else{\n\t\t\t\tint mi = h << 23 | hs;\n\t\t\t\tmap<int,int>::iterator it = memo.find(mi);\n\t\t\t\tif( it == memo.end() ){\n\t\t\t\t\tfor(int i = 0; i < 4; i++ )\n\t\t\t\t\t\ts += func( p + dir[i], dir[i], u - 1 );\n\t\t\t\t\tmemo[mi] = s;\n\t\t\t\t}else{\n\t\t\t\t\ts = it->second;\n\t\t\t\t}\n\t\t\t}\n\t\t\ths |= 1 << h;\n\t\t\tmp[p] = h;\n\t\t\treturn s;\n\t\t}\n\t\tif( h == -9 )break;\n\t\tp += d;\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tmemo.clear();\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\tj = hs;\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt += func( ch + dir[i], dir[i], j );\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint h,w;\nint g[111][111];\nint m[111][111];\nint c;\n\nconst int dx[]={1,0,-1,0};\nconst int dy[]={0,1,0,-1};\n\ninline bool in(int x, int y){\n    return x<w && y<h && 0<=x && 0<=y;\n}\n\nint solve(int vis, int x, int y){\n    int ans=0;\n    rep(d,4){\n        int nx=x;\n        int ny=y;\n        while(1){\n            nx+=dx[d];\n            ny+=dy[d];\n            if(!in(nx,ny)) break;\n            if(g[ny][nx]==0){\n                continue;\n            } else if(g[ny][nx]==2){\n                if(vis==(1<<c)-1) ans+=1;\n            } else if(g[ny][nx]==1){\n                int h=m[ny][nx];\n                if(vis>>h&1) break;\n                else {\n                    vis^=1<<h;\n                    ans+=solve(vis,nx,ny);\n                    vis^=1<<h;\n                }\n            }\n        }\n    }\n    //printf(\"%d=solve(%d %d %d)\\n\",ans,vis,x,y);\n    return ans;\n}\n\nint main(){\n    while(cin>>w>>h && w|h){\n        int sx,sy;\n        c=0;\n        rep(i,h)rep(j,w){\n            cin >> g[i][j];\n            if(g[i][j]==2){\n                sx=j;\n                sy=i;\n            } else if(g[i][j]==1){\n                m[i][j]=c++;\n            }\n        }\n        cout << solve(0,sx,sy) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   (a >> b) & 1\n#define bitset(a,b)       a |= (1 << b)\n#define bitunset(a,b)    a &= ~(1 << b)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w,h;\n\twhile (scanf(\"%d %d\", &w, &h)) {\n\t\tif (!w && !h)\n\t\t\tbreak;\n\t\tvector<vector<char>> mp(w, vector<char>(h, -1));\n\t\tpii cha;\n\t\tvector<pair<char,char>> homp;\n\t\tint homc = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tint a = 0;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tif (a == 2) {\n\t\t\t\t\tcha = { j,i };\n\t\t\t\t}\n\t\t\t\tif (a == 1) {\n\t\t\t\t\thomp.push_back({ j,i });\n\t\t\t\t\tmp[j][i] = homc;\n\t\t\t\t\thomc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thomp.push_back(cha);\n\tmap<pair<int,char>, int> dp[2];//?±\\??´????????¨??°\n\t\tdp[0][{0, homc}] = 1;\n\t\tbool t = 0;\n\t\tREP(i, homc) {\n\t\t\tfor (auto cur : dp[t]) {\n\t\t\t\tpii curpos = homp[cur.first.second];\n\t\t\t\tint cnum;\n\t\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tif ((!dp[1 - t].count({ buf,cnum }) && cur.second <= 2000000) || ((dp[1 - t][{buf, cnum}] + cur.second) < 2000000))\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tif ((!dp[1 - t].count({ buf,cnum }) && cur.second <= 2000000) || ((dp[1 - t][{buf, cnum}] + cur.second) < 2000000))\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tif ((!dp[1 - t].count({ buf,cnum }) && cur.second <= 2000000) || ((dp[1 - t][{buf, cnum}] + cur.second) < 2000000))\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tif ((!dp[1 - t].count({ buf,cnum }) && cur.second <= 2000000) || ((dp[1 - t][{buf, cnum}] + cur.second) < 2000000))\n\t\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[t].clear();\n\t\t\tt = 1 - t;\n\t\t}\n\t\tint cnum, ans = 0;\n\t\tset<int> targets;\n\t\tfor (int j = cha.first; w > j; j++) {\n\t\t\tcnum = mp[j][cha.second];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.first; 0 <= j; j--) {\n\t\t\tcnum = mp[j][cha.second];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; h > j; j++) {\n\t\t\tcnum = mp[cha.first][j];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; 0 <= j; j--) {\n\t\t\tcnum = mp[cha.first][j];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (auto cur : dp[t]) {\n\t\t\tif (targets.find(cur.first.second) != targets.end())\n\t\t\t\tans += cur.second;\n\t\t}\n\n\t\tdp[1-t].clear();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <memory>\n#include <memory.h>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint field[12][12];\nint nums[12][12];\nmap<P, bool> ng;\n\nint dfs(int state, int x, int y){\n  if(ng[P(state, nums[y][x])]) return 0;\n  if(state == 0){\n    rep(i, 4){\n      int x2 = x + dx[i];\n      int y2 = y + dy[i];\n      while(field[y2][x2] == 0){\n\ty2 += dy[i];\n\tx2 += dx[i];\n      }\n      if(field[y2][x2] == 2) return 1;\n    }\n    ng[P(state, nums[y][x])] = true;\n    return 0;\n  }\n  int res = 0;\n  rep(i, 4){\n    int x2 = x + dx[i];\n    int y2 = y + dy[i];\n    while(field[y2][x2] != 3){\n      if(field[y2][x2] == 1){\n\tfield[y2][x2] = 3;\n\tres += dfs(state - (1 << nums[y2][x2]), x2, y2);\n\tfield[y2][x2] = 1;\n      }\n      x2 += dx[i];\n      y2 += dy[i];\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n, m, sx, sy, cnt;\n  while(cin >> m >> n && (n || m)){\n    cnt = 0;\n    fill(&field[0][0], &field[11][11] + 1, 3);\n    memset(nums, 0, sizeof(nums));\n    ng.clear();\n    rep(i, n){\n      rep(j, m){\n\tcin >> field[i+1][j+1];\n\tif(field[i+1][j+1] == 2){\n\t  sx = j + 1;\n\t  sy = i + 1;\n\t}\n\tif(field[i+1][j+1] == 1){\n\t  nums[i+1][j+1] = cnt++;\n\t}\n      }\n    }\n    cout << dfs((1 << cnt) - 1, sx, sy) << endl;\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint fi[11][11];\n\nint n, m;\nint res, tot, sx, sy;\n\nvoid rec(int x, int y, int con) {\n    ++con;\n    if (con == tot) {\n        if (x == sx || y == sy) ++res;\n        return;\n    }\n        \n    fi[x][y] = 3;\n    for (int i = 0; i < 4; ++i) {\n        int nx = x, ny = y;\n        while (true) {\n            nx += dx[i], ny += dy[i];\n            if (nx < 0 || nx >= n || ny < 0 || ny >= m) break;\n            if (fi[nx][ny] == 1) {\n                rec(nx, ny, con);\n                break;\n            }\n        }\n    }\n    fi[x][y] = 1;\n}\n\nint main() {\n    while (scanf(\"%d%d\", &m, &n), n) {\n        if (m == 0) break;\n        tot = 0;\n        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {\n            scanf(\"%d\", &fi[i][j]);\n            if (fi[i][j] == 1) ++tot;\n            if (fi[i][j] == 2) sx = i, sy = j;\n        }\n        res = 0;\n        rec(sx, sy, -1);\n        \n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 19;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s, int &order)\n{\n\torder++;\n\tint noBits = CountBit(s);\n\tif (x == sx && y == sy && noBits == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (noBits < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0, cnt = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, noBits))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]), cnt);\n\t}\n\torder += cnt;\n\tif (noBits < MAX && !(noBits >= 16 && cnt <= 10)) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0, cnt));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint grid[10][10];\n\nstruct STATE\n{\n\tint done, x, y;\n\t\n\tbool operator < (const STATE& t) const{\n\t\tif (done == t.done){\n\t\t\tif (x == t.x){\n\t\t\t\treturn y < t.y;\n\t\t\t}\n\t\t\treturn x < t.x;\n\t\t}\n\t\treturn done < t.done;\n\t}\n};\n\nint main()\n{\n\tint m, n;\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tint num = 0;\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < m; j++){\n\t\t\t\tscanf(\"%d\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 0){\n\t\t\t\t\tgrid[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 1){\n\t\t\t\t\tgrid[i][j] = num++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgrid[i][j] = -2;\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmap<STATE, int> dp;\n\t\tmap<STATE, int> dp2;\n\t\tdp[{0, sx, sy}] = 1;\n\t\tint res = 0;\n\t\twhile (true){\n\t\t\tif (dp.count({(1 << num) - 1, sx, sy})){\n\t\t\t\tres = dp[{(1 << num) - 1, sx, sy}];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor (auto ite = dp.begin(); ite != dp.end(); ++ite){\n\t\t\t\tSTATE st = (*ite).first;\n\t\t\t\t\n\t\t\t\t//printf(\"%d %d %d %d\\n\", st.done, st.x, st.y, dp[st]);\n\t\t\t\t\n\t\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\t\tint i = 1;\n\t\t\t\t\twhile (true){\n\t\t\t\t\t\tint tx = st.x + dx[dir] * i;\n\t\t\t\t\t\tint ty = st.y + dy[dir] * i;\n\t\t\t\t\t\tif (tx < 0 || tx >= n || ty < 0 || ty >= m) break;\n\t\t\t\t\t\tif (grid[tx][ty] == -2){\n\t\t\t\t\t\t\tif (st.done == (1 << num) - 1){\n\t\t\t\t\t\t\t\tdp2[{st.done, tx, ty}] += dp[st];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((grid[tx][ty] != -1) && (~st.done & (1 << grid[tx][ty]))){\n\t\t\t\t\t\t\tdp2[{st.done | (1 << grid[tx][ty]), tx, ty}] += dp[st];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdp = dp2;\n\t\t\tdp2.clear();\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODI 10000\n#define bitcheck(a,b)   (a >> b) & 1\n#define bitset(a,b)       a |= (1 << b)\n#define bitunset(a,b)    a &= ~(1 << b)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nsigned main() {\n\tint w,h;\n\twhile (scanf(\"%d %d\", &w, &h)) {\n\t\tif (!w && !h)\n\t\t\tbreak;\n\t\tvector<vector<char>> mp(w, vector<char>(h, -1));\n\t\tpii cha;\n\t\tvector<pair<char,char>> homp;\n\t\tint homc = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tint a = 0;\n\t\t\t\tscanf(\"%d\", &a);\n\t\t\t\tif (a == 2) {\n\t\t\t\t\tcha = { j,i };\n\t\t\t\t}\n\t\t\t\tif (a == 1) {\n\t\t\t\t\thomp.push_back({ j,i });\n\t\t\t\t\tmp[j][i] = homc;\n\t\t\t\t\thomc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thomp.push_back(cha);\n\t\tmap<pair<int,char>, int> dp[2];//?±\\??´????????¨??°\n\t\tdp[0][{0, homc}] = 1;\n\t\tbool t = 0;\n\t\tREP(i, homc) {\n\t\t\tfor (auto cur : dp[t]) {\n\t\t\t\tpii curpos = homp[cur.first.second];\n\t\t\t\tint cnum;\n\t\t\t\tfor (int j = curpos.second + 1; h > j; j++) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.second - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[curpos.first][j];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first + 1; w > j; j++) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t\tfor (int j = curpos.first - 1; 0 <= j; j--) {//???\n\t\t\t\t\tcnum = mp[j][curpos.second];\n\t\t\t\t\tif (cnum == -1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (bitcheck(cur.first.first, cnum))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tint buf = cur.first.first; bitset(buf, cnum);\n\t\t\t\t\tdp[1 - t][{buf, cnum}] += cur.second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[t].clear();\n\t\t\tt = 1 - t;\n\t\t}\n\t\tint cnum, ans = 0;\n\t\tset<int> targets;\n\t\tfor (int j = cha.first; w > j; j++) {\n\t\t\tcnum = mp[j][cha.second];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.first; 0 <= j; j--) {\n\t\t\tcnum = mp[j][cha.second];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; h > j; j++) {\n\t\t\tcnum = mp[cha.first][j];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = cha.second; 0 <= j; j--) {\n\t\t\tcnum = mp[cha.first][j];\n\t\t\tif (cnum > -1) {\n\t\t\t\ttargets.insert(cnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (auto cur : dp[t]) {\n\t\t\tif (targets.find(cur.first.second) != targets.end())\n\t\t\t\tans += cur.second;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\n/*\nconst int dx[] = {0,1,0,-1}; //u,r,d,l\nconst int dy[] = {-1,0,1,0};\n*/\nconst int dx[] = {1,0,-1,0}; //r,d,l,u\nconst int dy[] = {0,1,0,-1};\n\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\nint kari[32];\nvector<pair<int,int> > v;\n\n#if DEB\nstack<int> st;\n#endif\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( s==a.s ){\n      if( x==a.x ) return y<a.y;\n      else         return x<a.x;\n    }else{\n      return s<a.s;\n    }\n  }\n  \n};\n\nmap<state,int> msi;\n\nint numofbits(int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nbool isnotgoal(int s){\n  return (((last&s)) == last);\n}\nint isnot(int s){\n  rep(i,home)if( !(s&(1<<i)) ){\n    if( (kari[i]&s)==kari[i] ) return i;\n  }\n  return -1;\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ //âÎÉßêé\n    return 1;\n  }\n  if( isnotgoal(s) ){ //³ïÉßé½ßÌÆðÁïµ½©Ç¤©\n    return 0;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½óÔ\n    return msi[state(x,y,s)];\n  }\n  \n  int mask = (1<<home)-1;\n  if( s>0 && numofbits(~s&mask)>1 && isnot(s&~(1<<num[y][x]))!=-1 ){ //v[gªu¯È¢ÆÌL³\n#if DEB\n    printf(\"s:%d ,(%d,%d)  __%d  ___isnot:%d\\n\",s,x,y,s&~num[y][x],isnot(s&~num[y][x]));\n    stack<int> tmp = st;\n    while( !tmp.empty() ){\n      printf(\"%d,\",tmp.top());\n      tmp.pop();\n    }\n    puts(\"\\n\");\n#endif\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif\n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n\tfield[ty][tx] = 1;\n\n#if DEB\n\tst.pop();\n#endif\n\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    v.clear();\n    memset(num,-1,sizeof(num));\n    memset(kari,0,sizeof(kari));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t  v.pb(mp(j,i));\n\t}\n      }\n    }\n\n    // other homes\n    rep(i,v.size()){\n      rep(k,4){\n\tfor(int j=1; j<20; j++){\n\t  int tx = v[i].first + dx[k]*j;\n\t  int ty = v[i].second + dy[k]*j;\n\t  if( inside(tx,ty) ) break;\n\t  if( field[ty][tx]==1 ){\n\t    kari[i] |= (1<<num[ty][tx]);\n\t  }\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n#if DEB\n    printf(\"sz:%d\\n\",v.size());\n    printf(\"last:%d\\n\",last);\n    rep(i,v.size()){\n      printf(\"home:%d  , %d\\n\",i,kari[i]);\n    }\n#endif\n    \n    \n\n    printf(\"%d\\n\",dfs(sx,sy,0));\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <set>\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1};\nint dx[] = {1, -1, 0, 0};\n\nclass Edge{\npublic:\n    bool isAccess;\n    bitset<24> pass;\n    Edge(){\n        isAccess = false;\n    }\n};\n\nint n;\nvector<vector<Edge> > edges;\n\nint dfs(int curr, bitset<24> bs){\n    if(curr == 0 && bs.any()){\n        if(bs.count() == n)\n            return 1;\n        else\n            return 0;\n    }\n\n    int ret = 0;\n    for(int i=0; i<n; ++i){\n        if(bs[i] || !edges[curr][i].isAccess)\n            continue;\n        if((bs & edges[curr][i].pass).any())\n            continue;\n        bs[i] = true;\n        ret += dfs(i, bs);\n        bs[i] = false;\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        n = 1;\n        vector<int> y(1), x(1);\n        vector<vector<int> > grid(h, vector<int>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                cin >> grid[i][j];\n                if(grid[i][j] == 1){\n                    y.push_back(i);\n                    x.push_back(j);\n                    grid[i][j] = n;\n                    ++ n;\n                }else if(grid[i][j] == 2){\n                    y[0] = i;\n                    x[0] = j;\n                    grid[i][j] = 0;\n                }else{\n                    grid[i][j] = -1;\n                }\n            }\n        }\n\n        edges.assign(n, vector<Edge>(n, Edge()));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<4; ++j){\n                int y1 = y[i] + dy[j];\n                int x1 = x[i] + dx[j];\n                bitset<24> bs;\n                while(0 <= y1 && y1 < h && 0 <= x1 && x1 < w){\n                    if(grid[y1][x1] != -1){\n                        int k = grid[y1][x1];\n                        edges[i][k].isAccess = true;\n                        edges[i][k].pass = bs;\n                        bs[k] = true;\n                    }\n                    y1 += dy[j];\n                    x1 += dx[j];\n                }\n            }\n        }\n\n        cout << dfs(0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\nint H,W;\nint G[11][11],INDEX[11][11],ep_bitmask,sp,V;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvector<int> edges[25][4];\nmap<ii,int> memo;\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\ninline void INIT(){\n  memo.clear();\n  ep_bitmask = 0, sp = -1;\n  rep(i,11) rep(j,11) INDEX[i][j] = -1;\n  rep(i,25) rep(j,4) edges[i][j].clear();\n}\n\ninline void make_edges(){\n  rep(i,H) rep(j,W) if( G[i][j] != 0 ) {\n    int x = j, y = i;\n    rep(k,4){\n      int nx = x + dx[k], ny = y + dy[k];\n      while( isValid(nx,ny) ){\n        if( G[ny][nx] == 1 ) edges[INDEX[i][j]][k].push_back(INDEX[ny][nx]);\n        nx += dx[k], ny += dy[k];\n      }\n    }\n  }\n}\n\ninline void calc_last_point(int x,int y){\n  rep(i,4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    while( isValid(nx,ny) ){\n      if( G[ny][nx] != 0 ) {\n        ep_bitmask |= (1<<INDEX[ny][nx]);\n        break;\n      }\n      nx += dx[i], ny += dy[i];\n    }\n  }\n}\n\nbool check(int cur,int visited){\n  bool used[V];\n  rep(i,V) used[i] = ((visited>>i)&1);\n  deque<int> deq;\n  deq.push_back(cur);\n  used[cur] = true;\n  while( !deq.empty() ){\n    int p = deq.front(); deq.pop_front();\n    if( (ep_bitmask>>p) & 1 ) return true;\n    rep(i,4){\n      rep(j,edges[p][i].size()){\n        int np = edges[p][i][j];\n        if( used[np] ) continue;\n        used[np] = true;\n        deq.push_back(np);\n      }\n    }\n  }\n  return false;\n}\n\nint dfs(int cur,int visited,int remain,int ep_remain){\n\n  if( ep_remain == 0 && remain != 0 ) return 0;\n\n  if( remain <= 0 ) return ( (ep_bitmask>>cur) & 1 );\n\n\n  if( memo.find(ii(cur,visited)) != memo.end() ) return memo[ii(cur,visited)];\n\n  int ret = 0;\n  rep(k,4){\n    rep(i,edges[cur][k].size()){\n      int next = edges[cur][k][i];\n      assert(next>=0);\n      if( (visited>>next) & 1 ) break;\n      ret += dfs(next,visited|(1<<next),remain-(next!=sp),ep_remain-((ep_bitmask>>next)&1));\n    }\n  }\n  if( ret >= 10 ) memo[ii(cur,visited)] = ret;\n\n  return ret;\n}\n\nint main(){\n  while( cin >> W >> H, H|W ){\n    INIT();\n    int idx = 0,remain = 0,sx,sy;\n    rep(i,H) rep(j,W) {\n      cin >> G[i][j];\n      if( G[i][j] == 1 ) INDEX[i][j] = idx++, remain++;\n      if( G[i][j] == 2 ) sx = j, sy = i;\n    }\n    sp = INDEX[sy][sx] = idx++;\n    make_edges();\n\n    calc_last_point(sx,sy);\n    assert(remain <= 23);\n    V = remain;\n    cout << dfs(sp,(1<<INDEX[sy][sx]),remain,__builtin_popcount(ep_bitmask)) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint h, w;\nll k = 1, l;\nint b[10][10], o;\nll c[100];\nint dp[24][16777216];\nint a[10][10];\nll solve(int i, int j, ll s) {\n\tif (l == s) {\n\t\tif (b[i][j] == o)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tll sum = 0;\n\tfor (int x = i + 1; x < h; x++) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int x = i - 1; x >= 0; x--) {\n\t\tif (a[x][j] == 3)\n\t\t\tbreak;\n\t\tif (a[x][j]) {\n\t\t\tint d = b[x][j];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[x][j] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(x, j, s | c[d]));\n\t\t\t\ta[x][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j + 1; y < w; y++) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int y = j - 1; y >= 0; y--) {\n\t\tif (a[i][y] == 3)\n\t\t\tbreak;\n\t\tif (a[i][y]) {\n\t\t\tint d = b[i][y];\n\t\t\tif (dp[d][s | c[d]] != -1)\n\t\t\t\tsum += dp[d][s | c[d]];\n\t\t\telse {\n\t\t\t\ta[i][y] = 3;\n\t\t\t\tsum += (dp[d][s | c[d]] = solve(i, y, s | c[d]));\n\t\t\t\ta[i][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}\nint main() {\n\twhile (cin >> w >> h&&w!=0&&h!=0) {\n\t\tint sx, sy;\n\t\tll sum = 0;\n\t\tl = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == 2) {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\to = sum;\n\t\t\t\t}\n\t\t\t\tif (a[i][j]) {\n\t\t\t\t\tb[i][j] = sum;\n\t\t\t\t\tc[sum++] = k;\n\t\t\t\t\tl += k;\n\t\t\t\t\tk *= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < sum; i++) {\n\t\t\tfor (ll j = 0; j <= l; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcout << solve(sx, sy, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint solve(vvi& field,pii church,pii now,int n)\n{\n\tif(n==0)\n\t\treturn church.first==now.first || church.second==now.second;\n\t\n\tstatic const int di[]={-1,1,0,0};\n\tstatic const int dj[]={0,0,-1,1};\n\tint h=field.size(),w=field[0].size();\n\tint res=0;\n\trep(i,4){\n\t\tint pi=now.first,pj=now.second;\n\t\tfor(;;){\n\t\t\tpi+=di[i];\n\t\t\tpj+=dj[i];\n\t\t\tif(pi<0 || h<=pi || pj<0 || w<=pj)\n\t\t\t\tbreak;\n\t\t\tif(field[pi][pj]==1){\n\t\t\t\tfield[pi][pj]=0;\n\t\t\t\tres+=solve(field,church,mp(pi,pj),n-1);\n\t\t\t\tfield[pi][pj]=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"(%d,%d) %d: %d\\n\",now.first,now.second,n,res);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvvi field(h,vi(w));\n\t\trep(i,h) rep(j,w)\n\t\t\tcin>>field[i][j];\n\t\tvector<pii> homes;\n\t\trep(i,h) rep(j,w)\n\t\t\tif(field[i][j]==1)\n\t\t\t\thomes.push_back(mp(i,j));\n\t\t\telse if(field[i][j]==2)\n\t\t\t\thomes.insert(homes.begin(),mp(i,j));\n\t\t\n\t\t//printf(\"h:%d w:%d homes:%d\\n\",h,w,homes.size()-1);\n\t\t//clock_t begin=clock();\n\t\tcout<<solve(field,homes[0],homes[0],homes.size()-1)<<endl;\n\t\t//printf(\"time: %ldms\\n\",clock()-begin);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\n#define INF (1e+9)\n#define LLINF (1e+18)\n#define LL long long\n\nusing namespace std;\n\ntypedef struct state{\n\tint kind;\n\tint number;\n\tstate(){\n\t\tkind = -1;\n\t\tnumber = -1;\n\t}\n}state;\n\ntypedef struct info{\n\tint nx;\n\tint ny;\n\tint way;\n\tint record;\n\tinfo(int a,int b,int c,int d){\n\t\tnx = a;\n\t\tny = b;\n\t\tway = c;\n\t\trecord = d;\n\t}\n}info;\n\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n\n\nint m,n;\nint sx,sy;\nint housenum = 0;\nint ans = 0;\n\nstate field[16][16];\n\nqueue<info> que;\n\nint bfs(void){\n\tinfo now(0,0,0,0);\n\tinfo next(0,0,0,0);\n\tint nextrecord = 0;\n\tnext = info(sx,sy,-1,0);\n\tque.push(next);\n\twhile(!que.empty()){\n\t\tnow = que.front();\n\t\t//printf(\"###nx<%d>###ny<%d>###way<%d>###record<%d>\\n\",now.nx,now.ny,now.way,now.record);\n\t\tque.pop();\n\t\tswitch(field[now.ny][now.nx].kind){\n\t\tcase 1:\n\t\t\tif(now.record & (1 << field[now.ny][now.nx].number));\n\t\t\telse{\n\t\t\t\tnext = info(now.nx + dx[now.way],now.ny + dy[now.way],now.way,now.record);\n\t\t\t\tque.push(next);\n\t\t\t\tnextrecord = now.record | (1 << field[now.ny][now.nx].number);\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tnext = info(now.nx + dx[i],now.ny + dy[i],i,nextrecord);\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif(now.way == -1){\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tnext = info(now.nx + dx[i],now.ny + dy[i],i,nextrecord);\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(now.record == (0x1 << housenum) - 1){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnext = info(now.nx + dx[now.way],now.ny + dy[now.way],now.way,now.record);\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnext = info(now.nx + dx[now.way],now.ny + dy[now.way],now.way,now.record);\n\t\t\tque.push(next);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nint main (void){\n\n\twhile(true){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif((m == 0)&&(n == 0))break;\n\t\thousenum = 0;\n\t\tans = 0;\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 1;j <= m;j++){\n\t\t\t\tscanf(\"%d\",&(field[i][j].kind));\n\t\t\t\tif(field[i][j].kind == 1){\n\t\t\t\t\tfield[i][j].number = housenum;\n\t\t\t\t\thousenum++;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j].kind == 2){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 1;i <= n;i++){\n\t\t\tprintf(\"###\");\n\t\t\tfor(int j = 1;j <= m;j++){\n\t\t\t\tprintf(\"%d\\t\",field[i][j].number);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\npi charch;\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /**/  \n    int left = 0;\n    int chi=charch.fr;int chj=charch.sc;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[chi][chj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[chi][chj].link[k].size(); ++v){\n\tpi hs = M[chi][chj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    \n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef int ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\nstruct T{\n\tll first,second,third;\n\tbool operator<(const T& t)const{\n\t\treturn first!=t.first?(first<t.first):(second!=t.second?second<t.second:third<t.third);\n\t}\n};\nll w,h,g[10][10];\nll cx,cy;\ninline vector<P> doko(ll y,ll x){\n\tvector<P> v;\n\tfor(ll nx=x+1;nx<w;nx++){\n\t\tif(g[y][nx]>0) v.push_back(P(y,nx));\n\t\tif(g[y][nx]==1) break;\n\t}\n\tfor(ll nx=x-1;nx>=0;nx--){\n\t\tif(g[y][nx]>0) v.push_back(P(y,nx));\n\t\tif(g[y][nx]==1) break;\n\t}\n\tfor(ll ny=y+1;ny<h;ny++){\n\t\tif(g[ny][x]>0) v.push_back(P(ny,x));\n\t\tif(g[ny][x]==1) break;\n\t}\n\tfor(ll ny=y-1;ny>=0;--ny){\n\t\tif(g[ny][x]>0) v.push_back(P(ny,x));\n\t\tif(g[ny][x]==1) break;\n\t}\n\treturn v;\n}\nll n;\nll id[10][10];\nset<T> t;\nll dfs(ll y,ll x,ll s){\n\tif(t.count((T){y,x,s})) return 0;\n\tll res=0;\n\tvector<P> v=doko(y,x);\n\tif(s==(1<<n)-1){\n\t\tfor(ll i=0;i<v.size();i++){\n\t\t\tif(g[v[i].first][v[i].second]==2) return 1;\n\t\t}\n\t\tt.insert((T){y,x,s});\n\t\treturn 0;\n\t}\n\tif(s) g[y][x]=-1;\n\tfor(ll i=0;i<v.size();i++){\n\t\tif(g[v[i].first][v[i].second]==2) continue;\n\t\tres+=dfs(v[i].first,v[i].second,s|(1<<id[v[i].first][v[i].second]));\n\t}\n\tg[y][x]=1;\n\tif(res==0) t.insert((T){y,x,s});\n\treturn res;\n}\n\nint main()\n{while(1){\n\tscanf(\"%d%d\",&w,&h);\n\tn=0;\n\tt.clear();\n\tmemset(id,-1,sizeof(id));\n\tif(!w) return 0;\n\tfor(ll i=0;i<h;i++) for(ll j=0;j<w;j++){\n\t\tscanf(\"%d\",&g[i][j]);\n\t\tif(g[i][j]==2){\n\t\t\tcx=j,cy=i;\n\t\t}\n\t\telse if(g[i][j]){\n\t\t\tid[i][j]=n;\n\t\t\tn++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(cy,cx,0));\n}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], d[4] = { 1, 0, -1, 0 };\ninline int solve(int sx, int sy, int depth) {\n\tif (depth == n) {\n\t\tif (sx == gx || sy == gy) return 1;\n\t\treturn 0;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (rng(tx, ty)) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth + 1);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += d[i];\n\t\t\tty += d[i ^ 1];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &x[i][j]);\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nint f(int cur,int mask){\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif(mask>>a[y][x]&1)break;\n\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<short,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nmap<P,int> memo;\n\ninline void MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << ' ' << ((1<<(houses.size()-1))-1) << endl;\n\tif((state&((1<<(houses.size()-1))-1))==((1<<(houses.size()-1))-1)&&house_num==0) return 1;\n\tint result1=0,result2=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&(house_num==0||((state>>(house_num-1))&1)==1)) result1+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif((__builtin_popcount(state)>15||memo[MP(house_num,state)]==0)&&house_num!=0&&((state>>(house_num-1))&1)!=1){\n\t\t\tresult2+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<(house_num-1)));\n\t\t}\n\t}\n\t//cout << result1 << ' ' << result2 << endl;\n\tif(__builtin_popcount(state)<=15&&memo[MP(house_num,state)]==0) memo[MP(house_num,state)]=result2+1;\n\treturn (__builtin_popcount(state)<=15?memo[MP(house_num,state)]:result2+1)+result1-1;\n}\n\ninline lli Solve(){\n\thouses.clear();\n\tmemo.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==2) houses[MP(y,x)]=0;\n\t}\n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint search(int i, int j, int done)\n{\n\tint ret=0;\n\tint dx=1;\n\tint dy=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(done&(1<<table[x][y])){\n\t\t\t\t\tret+=search(x,y,done^(1<<table[x][y]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(done==0&&table[x][y]==-1){\n\t\t\t\tret++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tint c=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\ttable[i][j]=c++;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-2;\n\t\t\t}\n\t\t}\n\t}\n\tint ret=search(s,t,(1<<c)-1);\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#define rep(i, n) for ( int i = 0; i < n; i++)\nusing namespace std;\n\n#define MAX 10\n#define PMAX 23\n#define HOUSE 3\n#define SPACE 0\n#define SMOKE 1\n#define START 2\n#define BLOCK 4\n\nint H, W, n;\n\nclass State{\npublic:\n  unsigned short pi, pj, total;\n  bool V[PMAX];\n\n  State(){total = 0;}\n\n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    for ( int i = 0; i < n; i++ ){\n      if ( V[i] == s.V[i] ) continue;\n      return V[i] < s.V[i];\n    }\n    return false;\n  }\n};\n\nstatic int di[4] = {0, -1, 0, 1};\nstatic int dj[4] = {1, 0, -1, 0};\n\nint  G[MAX+2][MAX+2], I[MAX+2][MAX+2];\n\nmain(){\n  int si, sj;\n\n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    int total = 0;\n    n = 0;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) G[i][j] = BLOCK;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n\tcin >> G[i][j];\n\tif ( G[i][j] == START ){ si = i; sj = j;}\n\tif ( G[i][j] == SMOKE ) { total++; I[i][j] = n++; }\n      }\n    }\n\n    State s = State();\n    \n    for ( int i = 0; i < n; i++ ) s.V[i] = true;\n\n    map<State, int> M;\n    State v;\n\n    int ni, nj;\n    M[s] = 0;\n    \n    for ( int r = 0; r < 4; r++ ){\n      ni = si + di[r];\n      nj = sj + dj[r];\n\n      while(1){\n\tif ( G[ni][nj] == SMOKE && s.V[I[ni][nj]] ){\n\t  v = s;\n\t  v.pi = ni;\n\t  v.pj = nj;\n\t  v.V[I[ni][nj]] = false;\n\t  v.total = 1;\n\t  M[v] = 1;\n\t  break;\n\t} else if ( G[ni][nj] == BLOCK ) break;\n\tni += di[r];\n\tnj += dj[r];\n      }\n    }\n\n    map<State, int>::iterator it;\n    \n    int presize = M.size();\n\n    int cc = 0;\n    int x = 0;\n    bool f;\n    map<State, int> nM;\n\n    while(1){\n      nM.clear();\n      f = true;\n      for ( it = M.begin(); it != M.end(); it++ ){\n\tState cur = (*it).first;\n\tint cost = (*it).second;\n\tif ( cost == 0 ) continue;\n\n\tfor ( int r = 0; r < 4; r++ ){\n\t  ni = cur.pi + di[r];\n\t  nj = cur.pj + dj[r];\n\n\t  while(1){\n\t    if ( G[ni][nj] == SMOKE && cur.V[I[ni][nj]]){\n\t      v = cur;\n\t      v.pi = ni;\n\t      v.pj = nj;\n\t      v.V[I[ni][nj]] = false;\n\t      v.total++;\n\t      f = false;\n\t      nM[v] += cost;\n\t      break;\n\t    } else if ( ni == si && nj == sj && cur.total == total ){\n\t      x += cost;\n\t      break;\n\t    } else if ( G[ni][nj] == BLOCK ) {\n\t      break;\n\t    }\n\t    ni += di[r];\n\t    nj += dj[r];\n\t  }\n\t}\n      }\n      if ( f ) break;\n      M = nM;\n    }\n\n    cout << x << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n\nusing namespace std;\n\ntypedef pair<int,int> Pt;\n#define fr first\n#define sc second\n\nint mas[10][10],h,w,dx[]={0,1,-1,0},dy[]={1,0,0,-1};\nPt gl;\nPt Move(Pt p,int n){\n  while(true){\n    p.fr += dx[n] , p.sc += dy[n];\n    if(p.fr >= 0 && p.fr < h && p.sc >= 0 && p.sc < w){\n      if( mas[p.fr][p.sc] == 1 ) return p;\n    }else return Pt(-1,-1);\n  }\n}\nint solve(Pt p,int home){\n  if( !home ){\n    return ( p.fr == gl.fr || p.sc == gl.sc ? 1 : 0 );\n  }\n  int rec = 0;\n  for(int i=0;i<4;i++){\n    Pt s = Move(p,i);\n    if(s.fr == -1) continue;\n    mas[s.fr][s.sc] = -1;\n    rec += solve(s,home-1);\n    mas[s.fr][s.sc] = 1;\n  }\n  return rec;\n}\nint main(){\n  while(cin >> w >> h && w){\n    int home = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mas[i][j];\n        if( mas[i][j] == 1 ) home++;\n        else if(mas[i][j] == 2 ) gl = Pt(i,j);\n      }\n    }\n    cout << solve(gl,home) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> grd;\nint m,n;\nint mx[]={1,-1,0,0},my[]={0,0,1,-1};\nint dfs(int x,int y,int left){\n\tint ans=0;\n\tfor(int i=0;i<4;i++){\n\t\tint tx=x+mx[i],ty=y+my[i];\n\t\twhile(0<=tx&&tx<m&&0<=ty&&ty<n){\n\t\t\tif(grd[ty][tx]==-1)\tbreak;\n\t\t\tif(grd[ty][tx]==2&&left==0)\treturn 1;\n\t\t\telse if(grd[ty][tx]==1){\n\t\t\t\tgrd[ty][tx]=-1;\n\t\t\t\tans+=dfs(tx,ty,left-1);\n\t\t\t\tgrd[ty][tx]=1;\n\t\t\t}\n\t\t\ttx+=mx[i];\tty+=my[i];\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(true){\n\t\tcin>>m>>n;\n\t\tif(m==0)\treturn 0;\n\t\tgrd.clear();\n\t\tgrd.assign(n,vector<int>(m,0));\n\t\tint cnt=0,sx,sy;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin>>grd[i][j];\n\t\t\t\tif(grd[i][j]==1)\tcnt++;\n\t\t\t\telse if(grd[i][j]==2){\n\t\t\t\t\tsx=j;\tsy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dfs(sx,sy,cnt)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 }, dp[1 << 23][23];\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[1 << dat[nx][ny]][dat[nx][ny]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp[i][j] == 0)continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[i][j];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[i | 1 << dat[nx][ny]][dat[nx][ny]] += dp[i][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[12][12],sx,sy,n;\nint fn(int x,int y,int p){\n  int i;\n  int ct=0;\n  if(p==n){\n    for(i=1;a[x+i][y]!=-1;i++){\n      if(x+i==sx&&y==sy)\n\tct=1;\n    }\n    for(i=1;a[x-i][y]!=-1;i++){\n      if(x-i==sx&&y==sy)\n\tct=1;\n    }\n    for(i=1;a[x][y+i]!=-1;i++){\n      if(x==sx&&y+i==sy)\n\tct=1;\n    }\n    for(i=1;a[x][y-i]!=-1;i++){\n      if(x==sx&&y-i==sy)\n\tct=1;\n    }\n  }else{\n    for(i=1;a[x+i][y]!=-1;i++){\n      if(a[x+i][y]==1){\n\ta[x+i][y]=-1;\n\tct+=fn(x+i,y,p+1);\n\ta[x+i][y]=1;\n      }\n    }\n    for(i=1;a[x-i][y]!=-1;i++){\n      if(a[x-i][y]==1){\n\ta[x-i][y]=-1;\n\tct+=fn(x-i,y,p+1);\n\ta[x-i][y]=1;\n      }\n    }\n    for(i=1;a[x][y+i]!=-1;i++){\n      if(a[x][y+i]==1){\n\ta[x][y+i]=-1;\n\tct+=fn(x,y+i,p+1);\n\ta[x][y+i]=1;\n      }\n    }\n    for(i=1;a[x][y-i]!=-1;i++){\n      if(a[x][y-i]==1){\n\ta[x][y-i]=-1;\n\tct+=fn(x,y-i,p+1);\n\ta[x][y-i]=1;\n      }\n    }\n  }\n  return ct;\n}\nint main(){\n  int i,j;\n  int w,h;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    n=0;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>a[j][i];\n\tif(0){\n\t}else if(a[j][i]==1){\n\t  n++;\n\t}else if(a[j][i]==2){\n\t  a[j][i]=0;\t  \n\t  sx=j;\n\t  sy=i;\n\t}\n      }\n    }\n    cout<<fn(sx,sy,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cassert>\n#define rep(i, n) for ( int i = 0; i < n; i++)\nusing namespace std;\n \n#define MAX 10\n#define PMAX 23\n#define HOUSE 3\n#define SPACE 0\n#define SMOKE 1\n#define START 2\n#define BLOCK 4\n \nint H, W, n;\n \nclass State{\npublic:\n  unsigned short pi, pj, total;\n  bool V[PMAX];\n \n  State(){total = 0;}\n \n  bool operator < ( const State &s) const{\n    if ( pi != s.pi ) return pi < s.pi;\n    if ( pj != s.pj ) return pj < s.pj;\n    for ( int i = 0; i < n; i++ ){\n      if ( V[i] == s.V[i] ) continue;\n      return V[i] < s.V[i];\n    }\n    return false;\n  }\n};\n \nstatic int di[4] = {0, -1, 0, 1};\nstatic int dj[4] = {1, 0, -1, 0};\n \nint  G[MAX+2][MAX+2], I[MAX+2][MAX+2];\n \nmain(){\n  int si, sj;\n \n  while(1){\n    cin >> W >> H;\n    if ( W == 0 && H == 0 ) break;\n    int total = 0;\n    n = 0;\n    for ( int i = 0; i < H+2; i++ )\n      for ( int j = 0; j < W+2; j++ ) G[i][j] = BLOCK;\n    for ( int i = 1; i <= H; i++ ){\n      for ( int j = 1; j <= W; j++ ){\n    cin >> G[i][j];\n    if ( G[i][j] == START ){ si = i; sj = j;}\n    if ( G[i][j] == SMOKE ) { total++; I[i][j] = n++; }\n      }\n    }\n \n    State s = State();\n     \n    for ( int i = 0; i < n; i++ ) s.V[i] = true;\n \n    map<State, int> M;\n    State v;\n \n    int ni, nj;\n    M[s] = 0;\n     \n    for ( int r = 0; r < 4; r++ ){\n      ni = si + di[r];\n      nj = sj + dj[r];\n \n      while(1){\n    if ( G[ni][nj] == SMOKE && s.V[I[ni][nj]] ){\n      v = s;\n      v.pi = ni;\n      v.pj = nj;\n      v.V[I[ni][nj]] = false;\n      v.total = 1;\n      M[v] = 1;\n      break;\n    } else if ( G[ni][nj] == BLOCK ) break;\n    ni += di[r];\n    nj += dj[r];\n      }\n    }\n \n    map<State, int>::iterator it;\n     \n    int presize = M.size();\n \n    int cc = 0;\n    int x = 0;\n    bool f;\n    map<State, int> nM;\n \n    while(1){\n      nM.clear();\n      f = true;\n      for ( it = M.begin(); it != M.end(); it++ ){\n    State cur = (*it).first;\n    int cost = (*it).second;\n    if ( cost == 0 ) continue;\n \n    for ( int r = 0; r < 4; r++ ){\n      ni = cur.pi + di[r];\n      nj = cur.pj + dj[r];\n \n      while(1){\n        if ( G[ni][nj] == SMOKE && cur.V[I[ni][nj]]){\n          v = cur;\n          v.pi = ni;\n          v.pj = nj;\n          v.V[I[ni][nj]] = false;\n          v.total++;\n          f = false;\n          nM[v] += cost;\n          break;\n        } else if ( ni == si && nj == sj && cur.total == total ){\n          x += cost;\n          break;\n        } else if ( G[ni][nj] == BLOCK ) {\n          break;\n        }\n        ni += di[r];\n        nj += dj[r];\n      }\n    }\n      }\n      if ( f ) break;\n      M = nM;\n    }\n \n    cout << x << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstatic const int di[] = {-1,0,1,0};\nstatic const int dj[] = {0,1,0,-1};\n\ntypedef pair<int,int> pi;\n\n#define MAX 16\n#define HSMAX 32\n#define fr first\n#define sc second\n#define MAXDIR 4\n\nint houseId[MAX][MAX];\n\nstruct Node{\n  bool isCharch;\n  bool isHouse;\n  vector<pi> link[MAXDIR];\n  bool exist[MAXDIR];\n  bool cexist[MAXDIR];\n  Node():isCharch(false),isHouse(false){\n    for(int i=0;i<MAXDIR;++i){\n      cexist[i]=exist[i]=false;\n    }\n  }\n};\n\nstruct state{\n  char ni,nj;\n  char cnt;\n  //char pad[2];\n  int vis;\n  state(int si, int sj):ni(si),nj(sj){cnt=0;vis=0;\n    /*vis|=(1<<houseId[si][sj]);*/\n  }\n  inline bool checkvis(int b)const{\n    return vis&(1<<b);\n  }\n  inline void setvis(int b){\n    vis|=(1<<b);\n  }\n};\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans);\n\ninline bool isinside(int H, int W, int i, int j){\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\n\nvoid dfs(Node M[][MAX], const state &now, int nhouse, int &ans){\n  //cout << \"DFS\" << endl;\n  //bi << ' ' << bj << \" : \" << cnt << endl;\n  if( now.cnt + 18 > nhouse ){\n    bfs(M,now,nhouse,ans);\n    return ;\n  }\n  if( now.cnt == nhouse ){\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[now.ni][now.nj].cexist[k] ){\n\t++ans;\n\treturn ;\n      }\n    }\n  }else{\n    int ni = now.ni;\n    int nj = now.nj;\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi pnext = M[ni][nj].link[k][v];\n\t  if( !now.checkvis( houseId[pnext.fr][pnext.sc] ) ){\n\t    state next(now);\n\t    next.ni = pnext.fr;\n\t    next.nj = pnext.sc;\n\t    next.setvis( houseId[pnext.fr][pnext.sc] );\n\t    next.cnt++;\n\t    dfs( M, next, nhouse, ans );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nvoid bfs(Node M[][MAX], state init, int nhouse, int &ans){\n  queue<state> qs;\n  qs.push( init );\n  \n  while(!qs.empty()){\n    state st_now = qs.front();\n    int ni = st_now.ni;\n    int nj = st_now.nj;    \n    qs.pop();\n\n    if(st_now.cnt == nhouse){\n      for(int l = 0; l < MAXDIR; ++l){\n\tif( M[ni][nj].cexist[l] ){\n\t  ++ans;\n\t  break;\n\t}\n      }\n      continue;\n    }\n\n    /*\n    if( st_now.cnt + 7 >= nhouse){\n      dfs(M,st_now,nhouse,ans);\n      continue;\n    }\n    */\n    \n    /*  \n    int left = 0;\n    for(int k = 0; k < MAXDIR; ++k){\n      left += M[bi][bj].link[k].size();\n    }\n    for(int k = 0; k < MAXDIR; ++k){\n      for(int v = 0; v < M[bi][bj].link[k].size(); ++v){\n\tpi hs = M[bi][bj].link[k][v];\n\tif( st_now.vis&(1<<houseId[hs.fr][hs.sc]) ){\n\t  --left;\n\t}\n      }\n    }\n    if( left == 0 ) continue;\n    */\n\n    for(int k = 0; k < MAXDIR; ++k){\n      if( M[ni][nj].exist[k] ){\n\tfor(int v = 0; v < M[ni][nj].link[k].size(); ++v){\n\t  pi next = M[ni][nj].link[k][v];\n\t  if( !(st_now.vis&(1<<houseId[next.fr][next.sc])) ){ \n\t    state st_next(st_now);\n\t    st_next.ni = next.fr;\n\t    st_next.nj = next.sc;\n\t    st_next.vis |= (1<<houseId[next.fr][next.sc]);\n\t    st_next.cnt++;\n\t    qs.push( st_next );\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  return ;\n}\n\nint main()\n{\n  while(true){\n    int ans = 0;\n    int W,H;cin>>W>>H;\n    if(W==0&&W==H)break;\n    int iM[MAX][MAX];\n    Node M[MAX][MAX];\n    pi charch;\n    int nhouse=0;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tcin >> iM[i][j];\n\tif(iM[i][j]==1){\n\t  ++nhouse;\n\t  houseId[i][j]=nhouse;\n\t  M[i][j].isHouse=true;\n\t}else if(iM[i][j]==2){\n\t  M[i][j].isCharch=true;\n\t  charch = pi(i,j);\n\t}\n      }\n    }\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tfor(int k = 0; k < MAXDIR; ++k){\n\t  int ti=i+di[k];\n\t  int tj=j+dj[k];\n\t  while(isinside(H,W,ti,tj)){\n\t    if(M[ti][tj].isHouse){\n\t      M[i][j].link[k].push_back( pi(ti,tj) );\n\t      M[i][j].exist[k]=true;\n\t    }else if(M[ti][tj].isCharch){\n\t      M[i][j].cexist[k]=true;\n\t    }\n\t    ti+=di[k];tj+=dj[k];\n\t  }\n\t}\n      }\n    }\n    \n    state init(charch.fr,charch.sc);\n    dfs(M,init,nhouse,ans);\n    cout << ans << endl;\n\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint m,n,pn,tmp;\nint ans,upper;\nmap<P,int> dp;\nP pos[24];\nint g[10][10];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint rec(P s){\n  if(dp[s])return dp[s];\n\n  int vis = s.first, id = s.second;\n  if(!vis && !id)return 1;\n\n  int res = 0;\n  int y = pos[id].first, x = pos[id].second;\n  for(int k=0;k<4;k++){\n    int ty = y+dy[k], tx = x+dx[k];\n    for(;;){\n      if(ty<0 || tx<0 || n<=ty || m<=tx)break;\n      if(!vis && !g[ty][tx]){\n\tres += 1;\n\tbreak;\n      }\n      if(0<g[ty][tx]){\n\tint tmp = g[ty][tx] - 1;\n\tif( (vis>>tmp)&1 ){\n\t  res += rec(P(vis-(1<<tmp),g[ty][tx]));\n\t  break;\n\t}\n      }\n      ty += dy[k]; tx += dx[k];\n    }\n  }\n  return dp[s] = res;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n), m||n){\n    pn = 1;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tscanf(\"%d\",&tmp);\n\tif(tmp==1){\n\t  g[i][j] = pn;\n\t  pos[pn] = P(i,j);\n\t  pn++;\n\t}else if(tmp==2){\n\t  g[i][j] = 0;\n\t  pos[0] = P(i,j);\n\t}else g[i][j] = -1;\n      }\n    }\n\n    dp.clear();\n    upper = (1<<(pn-1));\n    printf(\"%d\\n\",rec(P(upper-1,0)));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#define rng(x, y) (0 <= x && x < W && 0 <= y && y < H)\nint H, W, n, gx, gy, x[12][12], d[4] = { 1, 0, -1, 0 };\nint solve(int sx, int sy, int depth) {\n\tif (depth == n) {\n\t\tif (sx == gx || sy == gy) return 1;\n\t\treturn 0;\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint tx = sx + d[i], ty = sy + d[i ^ 1];\n\t\twhile (rng(tx, ty)) {\n\t\t\tif (x[ty][tx] == 1) {\n\t\t\t\tx[ty][tx] = 0;\n\t\t\t\tret += solve(tx, ty, depth + 1);\n\t\t\t\tx[ty][tx] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx += d[i];\n\t\t\tty += d[i ^ 1];\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d%d\", &W, &H), W | H) {\n\t\tn = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tscanf(\"%d\", &x[i][j]);\n\t\t\t\tif (x[i][j] == 1) n++;\n\t\t\t\tif (x[i][j] == 2) gx = j, gy = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", solve(gx, gy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<char,int> P;\n\nint n,m;\nint table[10][10];\nint goal[10][10];\nint gs[23];\nconst int K=16;\n//int memo[1<<K][23];\nunordered_map<int, int> memo2[23];\nint half;\nint target;\nint ng;\nint ngs[23];\nint hx[23];\nint hy[23];\nint c;\nint search(int i, int j, int done)\n{\n\tif(done==target){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << goal[i][j] << endl;\n\t\treturn goal[i][j];\n\t}\n\tif((done&ng)==ng){\n\t\treturn 0;\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0&&memo[done][table[i][j]]!=-1){\n\t\t//cout << done << \", \" << i << \", \" << j << \": \" << memo[done][table[i][j]] << endl;\n\t\treturn memo[done][table[i][j]];\n\t}*/\n\tif(table[i][j]>=0&&memo2[table[i][j]].find(done)!=memo2[table[i][j]].end())\n\t{\n\t\treturn memo2[table[i][j]][done];\n\t}\n\tif(table[i][j]>=0){\n\tfor(int a=0;a<c;a++){\n\t\tif(gs[a]==0 &&(done&(1<<a))==0){\n\t\t\tif((ngs[a]&done)==ngs[a]){\n\t\t\t\t/*\n\t\t\t\tif(done<(1<<K)&&table[i][j]>=0){\n\t\t\t\t\tmemo[done][table[i][j]]=0;\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(table[i][j]>=0){\n\t\t\t\t\tmemo2[table[i][j]][done]=0;\n\t\t\t\t}*/\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t}\n\tint dx=1;\n\tint dy=0;\n\tint ret=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=i+dx;\n\t\tint y=j+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tif(!(done&(1<<table[x][y])))\n\t\t\t\t{\n\t\t\t\t\t//cout << (done|(1<<table[x][y])) << \": \" << done << \", \" << table[x][y] << endl;\n\t\t\t\t\tret+=search(x,y,done|(1<<table[x][y]));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\t/*\n\tif(done<(1<<K)&&table[i][j]>=0){\n\t\tmemo[done][table[i][j]]=ret;\n\t}*/\n\tif(table[i][j]>=0){\n\t\tmemo2[table[i][j]][done]=ret;\n\t}\n\treturn ret;\n}\nint main() {\nwhile(1){\n\tcin >> m >> n;\n\tif(m==0)return 0;\n\tint s=0,t=0;\n\tc=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tif(v==1){\n\t\t\t\thx[c]=i;\n\t\t\t\thy[c]=j;\n\t\t\t\ttable[i][j]=c++;\n\t\t\t\t//cout << i << \", \" << j << \": \" << table[i][j] << endl;\n\t\t\t}\n\t\t\telse if(v==2)\n\t\t\t{\n\t\t\t\ts=i;\n\t\t\t\tt=j;\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttable[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t//memset(memo,-1,sizeof(int)*(23*(1<<min(c,K))));\n\tmemset(goal,0,sizeof(goal));\n\ttarget=(1<<c)-1;\n\tint dx=1;\n\tint dy=0;\n\tng=0;\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=s+dx;\n\t\tint y=t+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tgoal[x][y]=1;\n\t\t\t\tgs[table[x][y]]=1;\n\t\t\t\tng|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\n\tmemset(ngs,0,sizeof(ngs));\n\tfor(int i=0;i<c;i++)\n\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\tint x=hx[i]+dx;\n\t\tint y=hy[i]+dy;\n\t\twhile(0<=x&&x<n&&0<=y&&y<m){\n\t\t\tif(table[x][y]>=0){\n\t\t\t\tngs[i]|=(1<<table[x][y]);\n\t\t\t\t//cout << \"goal \" << x << \", \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx+=dx;\n\t\t\ty+=dy;\n\t\t}\n\t}\n\tint ret=search(s,t,0);\n\tfor(int i=0;i<c;i++){\n\t\tmemo2[i].clear();\n\t}\n\tcout << ret << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\n\nint m,n,pr;\nint fie[12][12];\nint check[12][12];\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nint solve(int x,int y,int cost){\n  int ret=0;\n  for(int i=0;i<4;i++){\n    for(int j=1;j<=10;j++){\n      int mx=x+dx[i]*j;\n      int my=y+dy[i]*j;\n      if(mx<0 || mx>=m) break;\n      if(my<0 || my>=n) break;\n      if(fie[mx][my]==0) continue;\n      if(fie[mx][my]==1 && check[mx][my]==1) break;\n      if(fie[mx][my]==2 && cost<pr) break;\n      if(fie[mx][my]==2) return 1;\n      if(fie[mx][my]==1) cost++;\n      check[mx][my]=1;\n      ret+=solve(mx,my,cost);\n      if(fie[mx][my]==1) cost--;\n      check[mx][my]=0;\n    }\n  }\n  return ret;\n}\n  \n  \nmain(){\n  while(1){\n    cin >> m >> n;\n    if(m==0 && n==0) break;\n    int sx,sy;\n    pr=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tcin >> fie[j][i];\n\tif(fie[j][i]==2){ sx=j;sy=i;}\n\tif(fie[j][i]==1) pr++;\n      }\n    }\n    int res=solve(sx,sy,0);\n    cout << res << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\t//for(int w,h;cin>>w>>h,w|h;){\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w|h;){\n\t\t//clock_t begin=clock();\n\t\t\n\t\t//vvi field(h,vi(w));\n\t\tint field[11][11];\n\t\trep(i,h) rep(j,w)\n\t\t\t//cin>>field[i][j];\n\t\t\tscanf(\"%d\",&field[i][j]);\n\t\t\n\t\tvector<pii> homes;\n\t\tint counter=0;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(field[i][j]==1){\n\t\t\t\tfield[i][j]=++counter;\n\t\t\t\thomes.push_back(mp(i,j));\n\t\t\t}\n\t\t\telse if(field[i][j]==2){\n\t\t\t\tfield[i][j]=0;\n\t\t\t\thomes.insert(homes.begin(),mp(i,j));\n\t\t\t}\n\t\t\telse\n\t\t\t\tfield[i][j]=-1;\n\t\t}\n\t\t\n\t\tmap<pair<int,int>,int> m;\n\t\tm[mp(1,0)]=1;\n\t\tforeach(iter,m){\n\t\t\tif(iter!=m.begin())\n\t\t\t\tm.erase(m.begin());\n\t\t\t//m.erase(m.begin(),iter);\t// svÉÈÁ½vfðÁ³È¢ÆMLEÉÈé\n\t\t\t\n\t\t\tint state=iter->first.first;\n\t\t\tint prev=iter->first.second;\n\t\t\tif(state==(1<<homes.size())-1)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t//const int di[]={-1,1,0,0};\n\t\t\t//const int dj[]={0,0,-1,1};\n\t\t\t//rep(i,4){\n\t\t\t//\t//int pi=homes[prev].first,pj=homes[prev].second;\n\t\t\t//\t//for(;;){\n\t\t\t//\t//\tpi+=di[i];\n\t\t\t//\t//\tpj+=dj[i];\n\t\t\t//\tfor(int pi=homes[prev].first+di[i],pj=homes[prev].second+dj[i];0<=pi && pi<h && 0<=pj && pj<w;pi+=di[i],pj+=dj[i]){\n\t\t\t//\t\tif(pi<0 || h<=pi || pj<0 || w<=pj)\n\t\t\t//\t\t\tbreak;\n\t\t\t//\t\tint homei=field[pi][pj];\n\t\t\t//\t\tif(homei>=1 && !(state&(1<<homei))){\n\t\t\t//\t\t\tm[mp(state|(1<<homei),homei)]+=iter->second;\n\t\t\t//\t\t\tbreak;\n\t\t\t//\t\t}\n\t\t\t//\t}\n\t\t\t//}\n\t\t\tfor(int pi=homes[prev].first-1,pj=homes[prev].second;0<=pi && pi<h && 0<=pj && pj<w;pi--){\n\t\t\t\tint homei=field[pi][pj];\n\t\t\t\tif(homei>=1 && !(state&(1<<homei))){\n\t\t\t\t\tm[mp(state|(1<<homei),homei)]+=iter->second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int pi=homes[prev].first+1,pj=homes[prev].second;0<=pi && pi<h && 0<=pj && pj<w;pi++){\n\t\t\t\tint homei=field[pi][pj];\n\t\t\t\tif(homei>=1 && !(state&(1<<homei))){\n\t\t\t\t\tm[mp(state|(1<<homei),homei)]+=iter->second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int pi=homes[prev].first,pj=homes[prev].second-1;0<=pi && pi<h && 0<=pj && pj<w;pj--){\n\t\t\t\tint homei=field[pi][pj];\n\t\t\t\tif(homei>=1 && !(state&(1<<homei))){\n\t\t\t\t\tm[mp(state|(1<<homei),homei)]+=iter->second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int pi=homes[prev].first,pj=homes[prev].second+1;0<=pi && pi<h && 0<=pj && pj<w;pj++){\n\t\t\t\tint homei=field[pi][pj];\n\t\t\t\tif(homei>=1 && !(state&(1<<homei))){\n\t\t\t\t\tm[mp(state|(1<<homei),homei)]+=iter->second;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tforeach(iter,m){\n\t\t\tint prev=iter->first.second;\n\t\t\tint pi=homes[prev].first,pj=homes[prev].second;\n\t\t\tif(pi==homes[0].first || pj==homes[0].second)\n\t\t\t\tres+=iter->second;\n\t\t}\n\t\t//cout<<res<<endl;\n\t\tprintf(\"%d\\n\",res);\n\t\t\n\t\t//printf(\"time: %ldms\\n\",clock()-begin);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate<typename T>\nvoid fill_all(T& ar,const T& v){\n\tar=v;\n}\ntemplate<typename T,size_t N,typename U>\nvoid fill_all(T(& ar)[N],const U& v){\n\tfor(auto&i:ar){fill_all(i,v);}\n}\n\n\nint w,h;\nconst int goal = 23;\nconst int empty = 24;\n\nint graph[25][4][25];//????????????\nint map[10][10];\n\nconst int nposmax = 8;\nconst int bitmax = 1<<21;\n//bit????????????\nint dp[nposmax][bitmax];\nint func(int now, int bit){\n\tif(now==empty){return 0;}\n\tif(now==goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTg0:\" << now <<' '<<bit<<':'<<((now==goal&&bit==0)?1:0)<<std::endl;\n\t#endif\n\t\treturn ((now==goal&&bit==0)?1:0);\n\t}\n\tif(bit==0){\n\t\tfor(auto& g:graph[now]){\n\t\t\tif(g[0] == goal){\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<1<<std::endl;\n\t#endif\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUTb0:\" << now <<' '<<bit<<':'<<0<<std::endl;\n\t#endif\n\t\treturn 0;\n\t}\n\t\n\tif(bit<bitmax&&now<nposmax)if(dp[now][bit]>=0){return dp[now][bit];}\n\tint res = 0;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tif(bit&(1<<*iter)){\n\t\t\t\tres += func(*iter,bit&(~(1<<*iter)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t#ifdef DEBUG\n\tstd::cout<<\"OUT:\" << now <<' '<<bit<<':'<<res<<std::endl;\n\tfor(int graph_num =0;graph_num<4;++graph_num){\n\t\tfor(auto iter=graph[now][graph_num];*iter!=empty;++iter){\n\t\t\tstd::cout << ' '<<*iter;\n\t\t\tif(bit&(1<<*iter)){std::cout<<\"(OK:\"<<(bit&(~(1<<*iter)))<<\")\";}\n\t\t\telse{break;}\n\t\t}\n\t}\n\tstd::cout<< std::endl;\n\t#endif\n\tif(bit<bitmax&&now<nposmax)return dp[now][bit]=res;\n\treturn res;\n}\nint main()\n{\n\tfor(;;){\n\tfill_all(dp,-1);\n\tfill_all(map,empty);\n\tfill_all(graph,empty);\n\tstd::cin>>w>>h;if(w==0&&h==0){break;}\n\tint count = 0;\n\tfor(auto y=0;y<h;++y)for(auto x=0;x<w;++x){\n\t\tstd::cin >> map[y][x];\n\t\tif(map[y][x]==0){\n\t\t\tmap[y][x]=empty;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(map[y][x]==1){\n\t\t\tmap[y][x]=count++;\n\t\t}\n\t\telse if(map[y][x]==2){\n\t\t\tmap[y][x]=goal;\n\t\t}\n\t\t\tauto pushback=[](int*g, int v){\n\t\t\t\twhile(*g!=empty){++g;}*g=v;\n\t\t\t};\n\t\t\tauto iter = graph[map[y][x]][0];\n\t\t\tfor(int ox=x-1;ox>=0;--ox){\n\t\t\t\tif(empty>map[y][ox]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSx \"<<x<<' '<<y<<\"<->\"<<ox<<' '<<y<<' '<<map[y][ox] <<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[y][ox];\n\t\t\t\t\tpushback(graph[map[y][ox]][2],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\titer = graph[map[y][x]][1];\n\t\t\tfor(int oy=y-1;oy>=0;--oy){\n\t\t\t\tif(empty>map[oy][x]){\n\t#ifdef DEBUG\n\tstd::cout <<\"PASSy \"<<x<<' '<<y<<\"<->\"<<x<<' '<<oy<<' '<<map[oy][x]<<\"\\n\";\n\t#endif\n\t\t\t\t\t*(iter++) = map[oy][x];\n\t\t\t\t\tpushback(graph[map[oy][x]][3],map[y][x]);\n\t#ifdef DEBUG\n\tstd::cout <<\"graph \"<<*(iter-1) <<' '<<map[y][x]<<\"\\n\";\n\t#endif\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint bit = 0;\n\twhile(--count>=0){bit<<=1;bit|=1;}\n\t#ifdef DEBUG\n\tstd::cout<<bit<<std::endl;\n\tfor(auto& g:graph[goal])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[4])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\tfor(auto& g:graph[3])for(auto iter=g;iter!=g+5;++iter){\n\tstd::cout << *iter << ' ';\n\t}std::cout<<std::endl;\n\t#endif\n\tint res = 0;\n\tfor(auto& arr : graph[goal]){\n\t\tfor(auto iter=arr;*iter!=empty;++iter){\n\t\t\tres+=func(*iter,bit&(~(1<<*iter)));\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define mp make_pair\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define EPS 1e-8\n#define DEB 0\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint w,h,sx,sy,home,last;\nint field[16][16];\nint num[16][16];\n\n#if DEB\nstack<int> st;\n#endif\n\nclass state{\npublic:\n  char x,y;\n  int s;\n  state(char _x, char _y, int _s){\n    x = _x;\n    y = _y;\n    s = _s;\n  }\n  \n  bool operator<(const state& a)const{\n    if( x==a.x ){\n      if( y==a.y ) return s<a.s;\n      else         return y<a.y;\n    }else{\n      return x<a.x;\n    }\n  }\n  \n};\n\n\nmap<state,int> msi;\n\nbool ischeck(int s){\n  return (((last&s)) == last) ;\n}\nbool inside(int x, int y){\n  return (x<0 || y<0 || x>=w || y>=h);\n}\n\n\nint dfs(int x, int y, int s){\n  if( (1<<home)-1 == s ){ // ÆÍ³ïÉßêé©Ç¤©\n    /*\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = x + dx[k]*i;\n\tint ty = y + dy[k]*i;\n\t//if( inside(tx,ty) || field[ty][tx]==1 )break;\n\tif( inside(tx,ty) )break;\n\n\tif( field[ty][tx]==2 ){\n#if DEB\n\t  printf(\"goal , (%d,%d)  s:%d\\n\",x,y,s);\n\t  stack<int> tmp = st;\n\t  while( !tmp.empty() ){\n\t    printf(\"%d,\",tmp.top());\n\t    tmp.pop();\n\t  }\n\t  puts(\"\\n\");\n#endif\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n    */\n    return 1;\n  }\n  if( msi.count(state(x,y,s)) ){ //ùÉÊÁ½ê\n    return msi[state(x,y,s)];\n  }\n  if( ischeck(s) ){\n    return 0;\n  }\n  \n  int ret = 0;\n  rep(k,4){\n    for(int i=1; i<20; i++){\n      int tx = x + dx[k]*i;\n      int ty = y + dy[k]*i;\n      if( inside(tx,ty) ) break;\n      if( field[ty][tx]==1 ){\n\t//if( s&(1<<num[ty][tx]) ) break;\t\n\tfield[ty][tx] = 0;\n#if DEB\n\tst.push(num[ty][tx]);\n#endif \n\tret += dfs(tx,ty,s|(1<<num[ty][tx]));\n#if DEB\n\tst.pop();\n#endif\n\tfield[ty][tx] = 1;\n\tbreak;\n      }\n    }\n  }\n  msi[state(x,y,s)] = ret;\n  return ret;\n}\n\nint main(){\n\n  while(scanf(\"%d%d\",&w,&h),w|h){\n    msi.clear();\n    memset(num,-1,sizeof(num));\n    home = last = 0;\n    rep(i,h){\n      rep(j,w){\n\tscanf(\"%d\",&field[i][j]);\n\tif( field[i][j]==2 ){\n\t  sx = j;\n\t  sy = i;\n\t}\n\tif( field[i][j]==1 ){\n\t  num[i][j] = home;\n\t  home++;\n\t}\n      }\n    }\n\n    //last homes\n    rep(k,4){\n      for(int i=1; i<20; i++){\n\tint tx = sx + dx[k]*i;\n\tint ty = sy + dy[k]*i;\n\tif( inside(tx,ty) )break;\n\tif( field[ty][tx]==1 ){\n\t  last |= (1<<num[ty][tx]);\n\t}\n      }\n    }\n#if DEB\n    printf(\"home:%d  sx,sy = %d,%d\\n\",home,sx,sy);\n    printf(\"last:%d\\n\",last);\n    rep(i,h){\n      rep(j,w){\n\tprintf(\"%2d \",num[i][j]);\n      }\n      puts(\"\");\n    }\n#endif   \n    dfs(sx,sy,0);\n    printf(\"%d\\n\",msi[state(sx,sy,0)]);\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint c;\nint f[22][22];\ntypedef pair<int,int> P;\nvector<P> v;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nbool used[33];\nmap<P,int> dp;\nint solve(int bit,int h){\n  //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \")\" << endl;\n  if(bit == (1<<c)-1){\n    if(v[h].F == v[0].F || v[h].S == v[0].S){\n      return 1;\n    }\n    return 0;\n  }\n\n  if(dp[P(bit,h)] != 0){\n    //cout << h << \" = (\" << v[h].F << \",\" << v[h].S << \") : \" << dp[P(bit,h)] << endl;\n    if(dp[P(bit,h)] < 0) return 0;\n    return dp[P(bit,h)];\n  }\n\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = v[h].F + dx[i];\n    int ny = v[h].S + dy[i];\n    while(0 < nx && nx <= n && 0 < ny && ny <= m){\n      if(f[nx][ny] && !used[f[nx][ny]]){\n\tused[f[nx][ny]] = true;\n\tret += solve(bit | (1<<f[nx][ny]),f[nx][ny]);\n\tused[f[nx][ny]] = false;\n\tbreak;\n      }\n      nx += dx[i];\n      ny += dy[i];\n    }\n  }\n  //cout << h << \" : \" << ret << endl;\n  if(__builtin_popcount(bit) < 10) dp[P(bit,h)] = (ret > 0)?ret:-1;\n  return (ret > 0)?ret:0;\n}\n\nint main(void){\n  while(1){\n    cin >> n >> m; if(!n) break;\n    c = 1;\n    v.clear();\n    v.push_back(P(0,0));\n    memset(f,0,sizeof(f));\n    memset(used,false,sizeof(used));\n    for(int i = 1; i <= m; i++){\n      for(int j = 1; j <= n; j++){\n\tcin >> f[j][i];\n\tif(f[j][i] == 2){\n\t  v[0].F = j;\n\t  v[0].S = i;\n\t  f[j][i] = 0;\n\t}else if(f[j][i] == 1){\n\t  f[j][i] = c;\n\t  v.push_back(P(j,i));\n\t  c++;\n\t}\n      }\n    }\n\n    dp.clear();\n    cout << solve(1,0) << endl;\n    //break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, char>P;\n\nint f[10][10], x[23], y[23], dat[10][10], dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tint p = 0, sx, sy;\n\t\trep(i, n)rep(j, m) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t\tif (f[i][j] == 1)x[p] = i, y[p] = j, dat[i][j] = p++;\n\t\t\tif (f[i][j] == 2)sx = i, sy = j;\n\t\t}\n\t\tmap<P, int>dp;\n\t\trep(k, 4) {\n\t\t\tfor (int nx = sx, ny = sy; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\tif (f[nx][ny] == 1) {\n\t\t\t\t\tdp[{1 << dat[nx][ny], dat[nx][ny]}] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0, o = 0;\n\t\trep(i, 1 << p)rep(j, p) {\n\t\t\tif (dp.find({ i,j }) == dp.end())continue;\n\t\t\tif (i == (1 << p) - 1) {\n\t\t\t\tif (x[j] == sx || y[j] == sy)ans += dp[{i, j}];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(k, 4) {\n\t\t\t\tfor (int nx = x[j], ny = y[j]; 0 <= nx&&nx < n && 0 <= ny&&ny < m; nx += dx[k], ny += dy[k]) {\n\t\t\t\t\tif (f[nx][ny] == 1 && !(i >> dat[nx][ny] & 1)) {\n\t\t\t\t\t\tdp[{i | 1 << dat[nx][ny], dat[nx][ny]}] += dp[{i, j}];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++o >= 100000)dp.erase({ i,j });\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\nconst int dx[]={1,-1,0,0};\nconst int dy[]={0,0,1,-1};\n\n\nint N,M;\nint temp[110][110];\nint feld[110][110];\nint cnt;\npii last;\nint ans;\nint t;\nvector<pii> vect[110][110];\n\nvoid dfs(int x,int y,int sum,int pdx,int pdy,bool down){\n    t++;\n    if(x<0||x>=N||y<0||y>=M){\n        return ;\n    }\n    //cout<<x<<\" \"<<y<<\" \"<<sum<<endl;\n    if(feld[y][x]==1&&down)feld[y][x]=-1;\n    if(y==last.FI&&x==last.SE&&sum==cnt){\n        ans++;\n        return;\n    }\n    if(down){\n        for(int i=0;i<vect[y][x].size();++i){\n            int nx=vect[y][x][i].FI;\n            int ny=vect[y][x][i].SE;\n            int tx=vect[y][x][i].FI-x;\n            int ty=vect[y][x][i].SE-y;\n            if(tx!=0)tx/=abs(tx);\n            if(ty!=0)ty/=abs(ty);\n            if(feld[ny][nx]==-1)continue;\n            if(feld[ny][nx]==1){\n                dfs(nx,ny,sum+1,tx,ty,true);\n                dfs(nx,ny,sum,tx,ty,false);\n            }\n            else dfs(nx,ny,sum,tx,ty,false);\n        }\n    }\n    else{\n        for(int i=0;i<vect[y][x].size();++i){\n            int nx=vect[y][x][i].FI;\n            int ny=vect[y][x][i].SE;\n            int tx=vect[y][x][i].FI-x;\n            int ty=vect[y][x][i].SE-y;\n            if(tx!=0)tx/=abs(tx);\n            if(ty!=0)ty/=abs(ty);\n            if(pdx==tx&&pdy==ty){\n                if(feld[ny][nx]==-1){\n                    if(feld[y][x]==-1)feld[y][x]=1;\n                    return;\n                }\n                else if(feld[ny][nx]==1){\n                    dfs(nx,ny,sum+1,pdx,pdy,true);\n                    dfs(nx,ny,sum,pdx,pdy,false);\n                }\n                else dfs(nx,ny,sum,pdx,pdy,false);\n            }\n        }\n    }\n    if(feld[y][x]==-1)feld[y][x]=1;\n    return ;\n}\n\n\nsigned main(){\n    while(1){\n        cin>>N>>M;\n        if(N==0&&M==0)break;\n        memset(feld,0,sizeof(feld));\n        for(int i=0;i<M;++i){\n            for(int j=0;j<N;++j){\n                cin>>feld[i][j];\n                if(feld[i][j]==2){\n                    last.FI=i;\n                    last.SE=j;\n                }\n                else if(feld[i][j]!=0)cnt++;\n            }\n        }\n\n        for(int i=0;i<M;++i){\n            for(int j=0;j<N;++j){\n                for(int k=0;k<4;++k){\n                    for(int l=1;l<100;++l){\n                        int nx=dx[k]*l;\n                        int ny=dy[k]*l;\n                        if(j+nx<0||j+nx>=N||i+ny<0||i+ny>=M)break;\n                        if(feld[i+ny][j+nx]!=0){\n                            vect[i][j].push_back(pii(j+nx,i+ny));\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        /*for(int i=0;i<M;++i){\n            for(int j=0;j<N;++j){\n                cout<<\"[\"<<j<<\" \"<<i<<\"]\"<<endl;\n                for(int k=0;k<vect[i][j].size();++k)cout<<vect[i][j][k].FI<<\" \"<<vect[i][j][k].SE<<endl;\n            }\n        }*/\n        dfs(last.SE,last.FI,0,0,0,true);\n        //for(int i=0;i<4;++i)dfs(last.SE,last.FI,0,dx[i],dy[i],false);\n        cout<<ans<<endl;\n        ans=0;\n        cnt=0;\n        for(int i=0;i<M;++i)for(int j=0;j<N;++j)vect[i][j].clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nusing namespace std;\nint ans;\nint tab[12][12];\nint wx,wy;\nint nx,ny,rem;\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy;\n    nowx=nx;nowy=ny;\nLA:;\n   nowx++;\n   if(nowx>=wx) goto LB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB: ;        \n\n    nowx=nx,nowy=ny;\nMA:;\n   nowx--;\n   if(0>nowx) goto MB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto MB;\n   }\n   goto MA;\nMB: ;        \n\n    nowx=nx,nowy=ny;\nNA:;\n   nowy++;\n   if(nowy>=wy) goto NB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto NB;\n   }\n   goto NA;\nNB: ;        \n\n    nowx=nx,nowy=ny;\nOA:;\n   nowy--;\n   if(0>nowy) goto OB;\n   if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;        \n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pa;\ntypedef pair<int,vector<int> > pv;\n\nint ary[20][20],ban[20][20],dp[1<<23][24];\nint M,N,house;\nvector<pa > ve;\nvector<pv> cango[25];\n\n\nint main(){\n\tint chx,chy,cnt;\n\twhile(true){\n\t\tcin>>M>>N;\n\t\tif(M==0&&N==0) break;\n\t\tcnt=0;\n\t\tve.clear();\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tfor(int j=1;j<=M;j++){\n\t\t\t\tban[i][j]=-1;\n\t\t\t\tcin>>ary[i][j];\n\t\t\t\tif(ary[i][j]==1){\n\t\t\t\t\tban[i][j]=ve.size();\n\t\t\t\t\tve.push_back(pa(i,j));\n\t\t\t\t}\n\t\t\t\telse if(ary[i][j]==2){\n\t\t\t\t\tchx=i;chy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tban[chx][chy]=ve.size();\n\t\tve.push_back(pa(chx,chy));\n\t\thouse=ve.size();\n\t\tfor(int i=0;i<house;i++) cango[i].clear();\n\n\t\tvector<int> tmp;\n\t\tfor(int i=0;i<house;i++){\n\t\t\tfor(int j=i+1;j<house;j++){\n\t\t\t\tif(ve[i].first==ve[j].first){\n\t\t\t\t\ttmp.clear();\n\t\t\t\t\tfor(int k=ve[i].second+1;k<ve[j].second;k++){\n\t\t\t\t\t\tif(ban[ve[i].first][k]!=-1){\n\t\t\t\t\t\t\ttmp.push_back(ban[ve[i].first][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcango[i].push_back(pv(j,tmp));\n\t\t\t\t\tcango[j].push_back(pv(i,tmp));\n\t\t\t\t}\n\t\t\t\telse if(ve[i].second==ve[j].second){\n\t\t\t\t\ttmp.clear();\n\t\t\t\t\tfor(int k=ve[i].first+1;k<ve[j].first;k++){\n\t\t\t\t\t\tif(ban[k][ve[i].second]!=-1) tmp.push_back(ban[k][ve[i].second]);\n\t\t\t\t\t}\n\t\t\t\t\tcango[i].push_back(pv(j,tmp));\n\t\t\t\t\tcango[j].push_back(pv(i,tmp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool fla;\n\t\tfor(int i=0;i<(1<<house);i++)fill(dp[i],dp[i]+house,0);\n\t\tdp[0][house-1]=1;\n\t\tfor(int i=0;i<(1<<(house-1));i++){\n\t\t\tfor(int j=0;j<(house-1);j++){\n\t\t\t\tif(!((1<<j)&i)) continue;\n\t\t\t\tfor(auto it=cango[j].begin();it!=cango[j].end();it++){\n\t\t\t\t\tfla=true;\n\t\t\t\t\tif(it->first!=house-1&&!((1<<(it->first))&i)) continue;\n\t\t\t\t\tfor(auto it2=it->second.begin();it2!=it->second.end();it2++){\n\t\t\t\t\t\tif((1<<(*it2))&i)fla=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(fla){\n\t\t\t\t\t\tdp[i][j]+=dp[i-(1<<j)][it->first];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(auto it=cango[house-1].begin();it!=cango[house-1].end();it++){\n\t\t\tif(it->second.empty()) res+=dp[(1<<(house-1))-1][it->first];\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint m,n,a[111][111];\nint h,Y[30],X[30];\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\n\nmap<int,int> M;\n\nint f(int cur,int mask){\n\tif(__builtin_popcount(mask)<=12){\n\t\tif(M.find(cur<<24|mask)!=M.end())return M[cur<<24|mask];\n\t}\n\tint res=0;\n\trep(d,4){\n\t\tint y=Y[cur],x=X[cur];\n\t\twhile(1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\tif(y<0 || y>=n || x<0 || x>=m)break;\n\t\t\tif(a[y][x]==0){\n\t\t\t\tif(mask==(1<<h)-2)res++;\n\t\t\t}\n\t\t\tif(a[y][x]>=1){\n\t\t\t\tif((mask>>a[y][x]&1)==0){\n\t\t\t\t\tres+=f(a[y][x],mask|1<<a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(__builtin_popcount(mask)<=20){\n\t\tM[cur<<24|mask]=res;\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\twhile(cin>>m>>n && m){\n\t\tM.clear();\n\t\th=1;\n\t\trep(i,n)rep(j,m){\n\t\t\tcin>>a[i][j];\n\t\t\tif(a[i][j]==0){\n\t\t\t\ta[i][j]=-1;\n\t\t\t}\n\t\t\telse if(a[i][j]==1){\n\t\t\t\tY[h]=i,X[h]=j;\n\t\t\t\ta[i][j]=h++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tY[0]=i,X[0]=j;\n\t\t\t\ta[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcout<<f(0,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\nint m, n;\nusing tup = tuple<int, int>;\nint tb[10][10];\nconst int B = 19;\n//int dp[24][1 << B];\nmap<P, int> dp;\nvector<P> vp;\nint sr, sc;\nint hs;\n\nint dfs(int idx, int bits) {\n\tif (idx == hs && bits) {\n\t\tif (bits == (1 << hs + 1) - 1) return 1;\n\t\telse return 0;\n\t}\n\t//if (bits < 1 << B && ~dp[idx][bits]) return dp[idx][bits];\n\tif (dp.count(P(idx, bits))) return dp[P(idx, bits)];\n\n\tint nr, nc;\n\ttie(nr, nc) = vp[idx];\n\n\tint res = 0;\n\t// ??????\n\trep(i, nr + 1, n) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\telse res += dfs(x, bits | 1 << x);\n\t}\n\t// ??????\n\trrep(i, nr - 1) if (~tb[i][nc]) {\n\t\tint x = tb[i][nc];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\n\trep(j, nc + 1, m) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\trrep(j, nc - 1) if (~tb[nr][j]) {\n\t\tint x = tb[nr][j];\n\t\tif ((bits >> x) & 1) break;\n\t\tres += dfs(x, bits | 1 << x);\n\t}\n\t//if (bits < 1 << B)\n\t//\treturn dp[idx][bits] = res;\n\t//else return res;\n\treturn dp[P(idx, bits)] = res;\n}\n\nsigned main() {\n\twhile (cin >> m >> n && m) {\n\t\tvp.clear();\n\t\ths = 0;\n\t\tmemset(tb, -1, sizeof(tb));\n\t\t//memset(dp, -1, sizeof(dp));\n\t\tdp.clear();\n\t\trep(i, n) rep(j, m) {\n\t\t\tint x; cin >> x;\n\t\t\tif (x == 2) {\n\t\t\t\tsr = i;\n\t\t\t\tsc = j;\n\t\t\t}\n\t\t\tif (x == 1) {\n\t\t\t\tvp.push_back(P(i, j));\n\t\t\t\ttb[i][j] = hs++;\n\t\t\t}\n\t\t}\n\t\ttb[sr][sc] = hs;\n\t\tvp.push_back(P(sr, sc));\n\t\tcout << dfs(hs, 0) << endl;\n\t}\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define SORT(x) sort((x).begin(),(x).end())\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=1<<30;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const long long int INF_=1<<60;\n\nint M,N;\nmap<P,int> houses;\nint memo[24][1<<24];\n\nvoid MakeGraph(vector<vector<P> > &G,vector<vector<int> >&g){\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tif(g[y][x]==1||g[y][x]==2){\n\t\t\t//cout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,4){\n\t\t\t\tint ny=y,nx=x;\n\t\t\t\twhile(true){\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tif(!(0<=ny&&ny<N&&0<=nx&&nx<M)) break;\n\t\t\t\t\tif(g[ny][nx]==1||g[ny][nx]==2){\n\t\t\t\t\t\tG[houses[MP(y,x)]].push_back(MP(i,houses[MP(ny,nx)]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tcout << houses[MP(y,x)] << endl;\n\t\t\tREP(i,0,G[houses[MP(y,x)]].size()){\n\t\t\t\tcout << G[houses[MP(y,x)]][i].F_ << ' ' << G[houses[MP(y,x)]][i].S_ << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t}\n\t}\n}\n\nint DFS(vector<vector<P> > &G,int house_num,int dir,int state){\n\t//cout << house_num << ' ' << dir << ' ' << state << endl;\n\tif((state&1)==1&&!(((state|1)&((1<<houses.size())-1))==((1<<houses.size())-1)&&house_num==0)) return 0;\n\tif(((state|1)&((1<<houses.size())-1))==((1<<houses.size())-1)&&house_num==0) return 1;\n\tif(memo[house_num][state]!=-1) return memo[house_num][state];\n\tint result=0;\n\tREP(i,0,G[house_num].size()){\n\t\tif(G[house_num][i].F_==dir&&((state>>G[house_num][i].S_)&1)!=1) result+=DFS(G,G[house_num][i].S_,dir,state);\n\t\tif(((state>>G[house_num][i].S_)&1)!=1){\n\t\t\t//cout << (state|(1<<house_num)) << endl;\n\t\t\tresult+=DFS(G,G[house_num][i].S_,G[house_num][i].F_,state|(1<<house_num));\n\t\t}\n\t}\n\treturn memo[house_num][state]=result;\n}\n\nlli Solve(){\n\thouses.clear();\n\tvector<vector<int> > g(N,vector<int>(M));\n\tint cnt=1;\n\tREP(y,0,N) REP(x,0,M){\n\t\t//cout << y << ' ' << x << endl;\n\t\tcin >> g[y][x];\n\t\tif(g[y][x]==1){\n\t\t\thouses[MP(y,x)]=cnt;\n\t\t\t++cnt;\n\t\t}else if(g[y][x]==1) houses[MP(y,x)]=0;\n\t}\n\tREP(i,0,cnt) REP(j,0,1<<cnt) memo[i][j]=-1; \n\tvector<vector<P> > G(cnt);\n\tMakeGraph(G,g);\n\tlli ans=0;\n\tREP(i,0,G[0].size()){\n\t\tans+=DFS(G,G[0][i].S_,G[0][i].F_,0);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile(cin >> M >> N&&M&&N){\n\t\tcout << Solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 1 << 15;\nint W, H, fld[10][10];\nint P, sx, sy;\nint memo[MAX][10][10];\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (s < MAX)\n\t{\n\t\tif (memo[s][x][y] != -1) return memo[s][x][y];\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (s < MAX) memo[s][x][y] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfill_n((int*)memo, min(1 << P, MAX) * 10 * 10, -1);\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n#include<cctype>\n#include<climits>\n#include<bitset>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, 1, 0, -1 };\nconst int MAX = 18;\nint W, H, fld[10][10];\nint P, sx, sy;\nmap<pair<pair<int, int>, int>, int> memo;\n\ninline int CountBit(int s)\n{\n\tint res = 0;\n\tfor (int i = 0; i < P; i++) res += (s >> i) & 1;\n\treturn res;\n}\n\ninline bool IsInside(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\ninline bool CanDown(int x, int y, int s, int noBits)\n{\n\tif (x == sx && y == sy && noBits == P) return true;\n\tif (fld[y][x] == -1) return false;\n\treturn ((s >> fld[y][x]) & 1) == 0;\n}\n\nint DFS(int x, int y, int s)\n{\n\tint cnt = CountBit(s);\n\tif (x == sx && y == sy && cnt == P) return 1;\n\tpair<pair<int, int>, int> state = make_pair(make_pair(x, y), s);\n\tif (cnt < MAX)\n\t{\n\t\tmap<pair<pair<int, int>, int>, int>::iterator itr = memo.find(state);\n\t\tif (itr != memo.end()) return itr->second;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\twhile (IsInside(nx, ny) && !CanDown(nx, ny, s, cnt))\n\t\t\tnx += dx[i], ny += dy[i];\n\t\tif (!IsInside(nx, ny)) continue;\n\t\tsum += DFS(nx, ny, s | (1 << fld[ny][nx]));\n\t}\n\tif (cnt < MAX) memo[state] = sum;\n\treturn sum;\n}\n\nsigned main()\n{\n\twhile (cin >> W >> H, W || H)\n\t{\n\t\tmemo.clear();\n\t\tP = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif (fld[i][j] == 0) fld[i][j] = -1;\n\t\t\t\telse if (fld[i][j] == 1) fld[i][j] = P++;\n\t\t\t\telse sx = j, sy = i, fld[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", DFS(sx, sy, 0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint chousa(int[][],int,int,int,int,int);\n\nint main(void) {\n\tint x,y;\n\tint map[10][10];\n\tint m,n;\n\tint kx,ky;\n\tint kazu=0;\n\tscanf(\"%d %d\",&m,&n);\n\t/*読み込み*/\n\tfor(y=0;y<n;y++) {\n\t\tfor(x=0;x<m;x++) {\n\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\tkx=x;\n\t\t\t\tky=y;\n\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t}\n\t}\n\t/*計算*/\n\tprintf(\"%d\\n\",chousa(map,kx,ky,kazu,m,n));\n\treturn 0;\n}\n\nint chousa(int map[10][10],int kx,int ky,int nokori,int m,int n) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][10];\nint m,n;\n\nint chousa(int kx,int ky,int nokori) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(nokori<0)return 0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(x,ky,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\treturn result;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(x,ky,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\treturn result;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(kx,y,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\treturn result;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(kx,y,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\treturn result;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}\n\nint main(void) {\n\tint x,y;\n\tint kx,ky;\n\tint kazu;\n\twhile(1) {\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0)break;\n\t\tkazu=0;\n\t\t/*読み込み*/\n\t\tfor(y=0;y<n;y++) {\n\t\t\tfor(x=0;x<m;x++) {\n\t\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\t\tkx=x;\n\t\t\t\t\tky=y;\n\t\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t\t}\n\t\t}\n\t\t/*計算*/\n\t\tprintf(\"%d\\n\",chousa(kx,ky,kazu));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][10];\nint m,n;\n\nint chousa(int kx,int ky,int nokori) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}\n\nint main(void) {\n\tint x,y;\n\tint kx,ky;\n\tint kazu;\n\twhile(1) {\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0)break;\n\t\tkazu=0;\n\t\t/*読み込み*/\n\t\tfor(y=0;y<n;y++) {\n\t\t\tfor(x=0;x<m;x++) {\n\t\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\t\tkx=x;\n\t\t\t\t\tky=y;\n\t\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t\t}\n\t\t}\n\t\t/*計算*/\n\t\tprintf(\"%d\\n\",chousa(map,kx,ky,kazu,m,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int, int);\ninline int solve2(int idn, int flag){\n  if(flag == (1 << n) - 1)\n    return can[idn];\n  return solve(idn, flag);\n}\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  if(idn != n)\n    if(likely((ok[flag] & (1 << idn)) == 0)) return 0;\n\n  int ret = 0;\n\n  REP(i,4){\n    int xxx = xx;\n    int yyy = yy;\n\n    while(1){\n      int xxxx = nx[i][yyy][xxx];\n      int yyyy = ny[i][yyy][xxx];\n      if(xxxx == -1) break;\n      int idn = id[yyyy][xxxx];\n      if(idn != n){\n        if(flag & (1 << idn)) break;\n        ret += solve(idn, (flag | (1 << idn)));\n      }\n      xxx = xxxx; yyy = yyyy;\n    }\n  }\n\n  if(!ret && idn - n)\n    ok[flag] &= ~(1 << idn);\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n    REP(i,1<<n) ok[i] = (1 << n) - 1;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ans,wx,wy,rem;\nint tab[10][10];\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy,*p,*pat=&tab[nx][ny];\n\n    nowx=nx;nowy=ny;\n    p=pat;\nLA:\n   nowx++;\n   if(nowx>=wx) goto LB;\n   p+=10;\n   if(*p==2&&rem==0)ans++;\n   else if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto LB;\n   }\n   goto LA;\nLB:         \n\n    nowx=nx,nowy=ny;\n    p=pat;\nMA:\n   nowx--;\n   if(0>nowx) goto MB;\n   p-=10;\n   if(*p==2&&rem==0)ans++;\n   else if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto MB;\n   }\n   goto MA;\nMB:         \n\n    nowx=nx,nowy=ny;\n    p=pat;\nNA:\n   nowy++;\n   if(nowy>=wy) goto NB;\n   p++;\n   if(*p==2&&rem==0)ans++;\n   else if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto NB;\n   }\n   goto NA;\nNB:        \n\n    nowx=nx,nowy=ny;\n    p=pat;\nOA:\n   nowy--;\n   if(0>nowy) goto OB;\n   p--;\n   if(*p==2&&rem==0)ans++;\n   else if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        int i,j;\n        for(i=0;i<n;i++)for(j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define PLANE (-1)\n#define HOUSE (1)\n#define CHURCH (2)\n#define FIRE  (3)\n\nint x, y;\nint memo[24][1 << 23];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint home[10][10];\nint n;\n\nint goChurch(int ty, int tx, int map[][10])\n{\n    int i;\n    int my, mx;\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        while (0 <= my && my < y && 0 <= mx && mx < x){\n            if (map[my][mx] == n){\n                return (1);\n            }\n            if (map[my][mx] == FIRE){\n                break;\n            }\n            my += dy[i];\n            mx += dx[i];\n        }\n    }\n    return (0);\n}\n\nint goHome(int dir, int *ky, int *kx, int map[][10])\n{\n    *ky += dy[dir];\n    *kx += dx[dir];\n    while (0 <= *ky && *ky < y && 0 <= *kx && *kx < x){\n        if (map[*ky][*kx] == HOUSE){\n            return (1);\n        }\n        if (map[*ky][*kx] == FIRE){\n            return (0);\n        }\n        *ky += dy[dir];\n        *kx += dx[dir];\n    }\n    \n    return (0);\n}\n\nint dfs(int v, int bit, int ty, int tx, int map[][10])\n{\n    int i;\n    int ky, kx;\n    int ans;\n    \n    if (memo[v][bit] >= 0){\n        return (memo[v][bit]);\n    }\n    \n    if (bit == (1 << n) - 1){\n        return (memo[v][bit] = goChurch(ty, tx, map));\n    }\n    \n    ans = 0;\n    for (i = 0; i < 4; i++){\n        ky = ty;\n        kx = tx;\n        while (goHome(i, &ky, &kx, map)){\n            map[ky][kx] = FIRE;\n            ans += dfs(home[ky][kx], bit | (1 << home[ky][kx]), ky, kx, map);\n            map[ky][kx] = HOUSE;\n        }\n    }\n    \n    return (memo[v][bit] = ans);\n}\n\n\nint main(void)\n{\n    int sy, sx;\n    int i, j;\n    int map[10][10];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        memset(home, PLANE, sizeof(home));\n        n = 0;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &map[i][j]);\n                if (map[i][j] == CHURCH){\n                    sy = i;\n                    sx = j;\n                }\n                else if (map[i][j] == HOUSE){\n                    home[i][j] = n++;\n                }\n            }\n        }\n        map[sy][sx] = n;\n        memset(memo, -1, sizeof(memo));\n        \n        printf(\"%d\\n\", dfs(n, 0, sy, sx, map));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int, int);\n\ninline int solve2(int idn, int flag){\n  if(unlikely((idn != n) & ((ok[flag] & (1 << idn)) == 0)))\n      return 0;\n  if(likely(flag == (1 << n) - 1))\n    return can[idn];\n  return solve(idn, flag);\n}\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  int ret = 0;\n\n\n#define q(i)                                    \\\n  {                                             \\\n  int xxxx = nx[i][yyy][xxx];                   \\\n  yyy = ny[i][yyy][xxx];                        \\\n  if(unlikely(xxxx == -1)) goto end##i;         \\\n  int idn = id[yyy][xxxx];                              \\\n  if(idn != n){                                         \\\n    if(likely(flag & (1 << idn))) goto end##i;          \\\n    ret += solve2(idn, (flag | (1 << idn)));            \\\n  }                                                     \\\n  xxx = xxxx;                                           \\\n}\n\n\n#define p(i)                                    \\\n  {                                             \\\n    int xxx = xx;                               \\\n    int yyy = yy;                               \\\n  q(i);                                         \\\n  q(i);                                         \\\n  q(i);                                         \\\n  q(i);                                         \\\n end##i:;                                       \\\n}                                               \\\n\n  p(0);\n  p(1);\n  p(2);\n  p(3);\n\n  if(likely(!ret & (idn != n)))\n    ok[flag] &= ~(1 << idn);\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n    REP(i,1<<n) ok[i] = (1 << n) - 1;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve2(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint chousa(int map[10][10],int kx,int ky,int nokori,int m,int n);\n\nint main(void) {\n\tint x,y;\n\tint map[10][10];\n\tint m,n;\n\tint kx,ky;\n\tint kazu=0;\n\twhile(1) {\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0)break;\n\t\t/*読み込み*/\n\t\tfor(y=0;y<n;y++) {\n\t\t\tfor(x=0;x<m;x++) {\n\t\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\t\tkx=x;\n\t\t\t\t\tky=y;\n\t\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t\t}\n\t\t}\n\t\t/*計算*/\n\t\tprintf(\"%d\\n\",chousa(map,kx,ky,kazu,m,n));\n\t}\n\treturn 0;\n}\n\nint chousa(int map[10][10],int kx,int ky,int nokori,int m,int n) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n  if(unlikely(flag == (1 << n) - 1)){\n    return can[idn];\n  }else{\n    if(idn != n)\n      if(likely((ok[flag] & (1 << idn)) == 0)) return 0;\n\n    // printf(\"%d %d %d\\n\", xx, yy, flag);\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(1){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        if(unlikely(idn != n)){\n          if(flag & (1 << idn)) break;\n          ret += solve(idn, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(!ret && idn - n)\n      ok[flag] &= ~(1 << idn);\n\n    return ret;\n  }\n}\n\nint main(){\n  int cc = 0;\n  while(++cc < 5){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    /*\n    REP(i,1<<n){\n      ok[i] = false;\n      REP(j,n) if((i & (1 << j)) == 0){\n        int xx = x[j];\n        int yy = y[j];\n        REP(k,4){\n          int xxx = nx[k][yy][xx];\n          int yyy = ny[k][yy][xx];\n          if(f[yyy][xxx] == 2){\n            ok[i] = true;\n            goto next;\n          }\n        }\n      }\n    next:;\n    }\n    */\n\n    REP(i, 1<<n) ok[i] = (1 << n) - 1;\n\n    int ans = solve(n, 0);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int, int);\n\ninline int solve2(int idn, int flag){\n  if((idn != n) & ((ok[flag] & (1 << idn)) == 0))\n      return 0;\n  if(likely(flag == (1 << n) - 1))\n    return can[idn];\n  return solve(idn, flag);\n}\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  int ret = 0;\n\n#define q(i)                                    \\\n  {                                             \\\n  xxxx = nx[i][yyy][xxx];                       \\\n  yyy = ny[i][yyy][xxx];                        \\\n  if(unlikely(xxxx == -1)) goto end##i;         \\\n  idn = id[yyy][xxxx];                          \\\n  if(idn != n){                                         \\\n    if(likely(flag & (1 << idn))) goto end##i;          \\\n    ret += solve2(idn, (flag | (1 << idn)));            \\\n  }                                                     \\\n  xxx = xxxx;                                           \\\n}\n\n\n#define p(i)                                    \\\n  {                                             \\\n    int xxx = xx;                               \\\n    int yyy = yy;                               \\\n    int xxxx;                                   \\\n    int idn;                                    \\\n  q(i);                                         \\\n  q(i);                                         \\\n  q(i);                                         \\\n  q(i);                                         \\\n end##i:;                                       \\\n}                                               \\\n\n  p(0);\n  p(1);\n  p(2);\n  p(3);\n\n  if(likely(!ret & (idn != n)))\n    ok[flag] &= ~(1 << idn);\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    int flag = 0; REP(i,n) if(can[i]) flag |= 1 << i;\n    n = cnt;\n    REP(i,1<<n){\n      int b = 0;\n      REP(j,n) if(((i & (1 << j)) == 0) && can[j])\n        b = 1;\n\n      if(b == 0)\n        ok[i] = flag;\n      else\n        ok[i] = (1 << n) - 1;\n    }\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve2(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nint memo[23*(1<<23)];\n\nint func( int p, int d ){\n\twhile(1){\n\t\tint h = mp[p];\n\t\tif( h >= 0 ){\n\t\t\tmp[p] = -1;\n\t\t\ths ^= 1 << h;\n\t\t\td = h << 23 | hs;\n\t\t\tif( memo[d] < 0 ){\n\t\t\t\tint s = 0, i, j;\n\t\t\t\tfor( i = 0; i < 4; i++ )\n\t\t\t\t\ts += func( p + dir[i], dir[i] );\n\t\t\t\tmemo[d] = s;\n\t\t\t}\n\t\t\ths |= 1 << h;\n\t\t\tmp[p] = h;\n\t\t\treturn memo[d];\n\t\t}\n\t\tif( h == -9 )break;\n\t\tp += d;\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = sizeof memo / sizeof *memo; i--; memo[i] = -1 );\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt += func( ch + dir[i], dir[i] );\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nbool hs[10][10];\nbool used[10][10];\nint cx,cy;\nint nh;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint w,h;\nint dfs(int x,int y,int f){\n\tif(f==nh){\n\t\tif(x==cx||y==cy)return 1;\n\t\treturn 0;\n\t}\n\tint i,j;\n\tint res=0;\n\tfor(i=0;i<4;i++){\n\t\tfor(j=1;j<10;j++){\n\t\t\tint nx=x+j*dx[i];\n\t\t\tint ny=y+j*dy[i];\n\t\t\tif(nx<0||nx>=h||ny<0||ny>=w)break;\n\t\t\tif(hs[nx][ny]){\n\t\t\t\tif(!used[nx][ny]){\n\t\t\t\t\tused[nx][ny]=true;\n\t\t\t\t\tres+=dfs(nx,ny,f+1);\n\t\t\t\t\tused[nx][ny]=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(1){\n\tint i,j;\n\tscanf(\"%d %d\",&w,&h);\n\tif(w==0)return 0;\n\tfor(i=0;i<h;i++)for(j=0;j<w;j++){\n\t\ths[i][j]=false;\n\t\tused[i][j]=false;\n\t}\n\tnh=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tchar c;\n\t\t\tscanf(\" %c\",&c);\n\t\t\tif(c=='1'){\n\t\t\t\ths[i][j]=true;\n\t\t\t\tused[i][j]=false;\n\t\t\t\tnh++;\n\t\t\t}\n\t\t\tif(c=='2'){cx=i;cy=j;}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dfs(cx,cy,0));\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0548 Reindeer with no sense of direction\n// 2018.2.23 bal4u\n\n#include <stdio.h>\n\nint w, h, cnt, ans;\nchar map[13][13];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dfs(int r, int c, int s)\n{\n\tint i, nr, nc;\n\t\n\tfor (i = 0; i < 4; i++) {\n\t\tnr = r, nc = c;\n\t\twhile (1) {\n\t\t\tnr += mv[i][0], nc += mv[i][1];\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w) break;\n\t\t\tif (map[nr][nc] == 1) {\n\t\t\t\tmap[nr][nc] = -1;\n\t\t\t\tdfs(nr, nc, s+1);\n\t\t\t\tmap[nr][nc] = 1;\n\t\t\t\tbreak;\n\t\t\t} else if (map[nr][nc] == 2) {\n\t\t\t\tif (s == cnt) { ans++; return; }\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint k, r, c, sr, sc;\n\n\twhile (w = in()) {\n\t\th = in();\n\t\tcnt = 0;\n\t\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\t\tmap[r][c] = k = in();\n\t\t\tif      (k == 1) cnt++;\n\t\t\telse if (k == 2) sr = r, sc = c;\n\t\t}\n\t\tans = 0;\n\t\tdfs(sr, sc, 0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint memo[23][1<<16];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n  if(unlikely(flag == (1 << n) - 1)){\n    return can[idn];\n  }else{\n    if(idn < 23 && flag < (1 << 16))\n      if(memo[idn][flag] != -1)\n        return memo[idn][flag];\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(1){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        if(idn != n){\n          if(flag & (1 << idn)) break;\n          ret += solve(idn, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(idn < 23 && flag < (1 << 16))\n      memo[idn][flag] = ret;\n\n    return ret;\n  }\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n    memset(memo, -1, sizeof(memo));\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][10];\nint m,n;\n\nint chousa(int kx,int ky,int nokori) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(x,ky,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(x,ky,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(kx,y,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(kx,y,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}\n\nint main(void) {\n\tint x,y;\n\tint kx,ky;\n\tint kazu;\n\twhile(1) {\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0)break;\n\t\tkazu=0;\n\t\t/*読み込み*/\n\t\tfor(y=0;y<n;y++) {\n\t\t\tfor(x=0;x<m;x++) {\n\t\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\t\tkx=x;\n\t\t\t\t\tky=y;\n\t\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t\t}\n\t\t}\n\t\t/*計算*/\n\t\tprintf(\"%d\\n\",chousa(kx,ky,kazu));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n  if(unlikely(flag == (1 << n) - 1)){\n    return can[idn];\n  }else{\n    if(idn != n)\n      if(likely((ok[flag] & (1 << idn)) == 0)) return 0;\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(1){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        if(idn != n){\n          if(flag & (1 << idn)) break;\n          ret += solve(idn, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(!ret && idn - n)\n      ok[flag] &= ~(1 << idn);\n\n    return ret;\n  }\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n    REP(i,1<<n) ok[i] = (1 << n) - 1;\n    REP(i,1<<n){\n      REP(j,n) if((i & (1 << j)) == 0){\n        int xx = x[j];\n        int yy = y[j];\n        REP(k,4){\n          int xxx = nx[k][yy][xx];\n          int yyy = ny[k][yy][xx];\n          if(f[yyy][xxx] == 2){\n            goto next;\n          }\n        }\n      }\n      ok[i] = 0;\n    next:;\n    }\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint chousa(int map[10][10],int kx,int ky,int nokori,int m,int n);\n\nint main(void) {\n\tint x,y;\n\tint map[10][10];\n\tint m,n;\n\tint kx,ky;\n\tint kazu=0;\n\tscanf(\"%d %d\",&m,&n);\n\t/*読み込み*/\n\tfor(y=0;y<n;y++) {\n\t\tfor(x=0;x<m;x++) {\n\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\tkx=x;\n\t\t\t\tky=y;\n\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t}\n\t}\n\t/*計算*/\n\tprintf(\"%d\\n\",chousa(map,kx,ky,kazu,m,n));\n\treturn 0;\n}\n\nint chousa(int map[10][10],int kx,int ky,int nokori,int m,int n) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  if(unlikely(flag == (1 << n) - 1)){\n    return can[idn];\n  }else{\n    if(idn != n)\n      if(likely((ok[flag] & (1 << idn)) == 0)) return 0;\n\n    // printf(\"%d %d %d\\n\", xx, yy, flag);\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(1){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        if(unlikely(idn != n)){\n          if(flag & (1 << idn)) break;\n          ret += solve(idn, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(!ret && idn - n)\n      ok[flag] &= ~(1 << idn);\n\n    return ret;\n  }\n}\n\nint main(){\n  while(1){\n    int w = getInt();\n    int h = getInt();\n\n    int i, j, k;\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      f[i][j] = getInt();\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j] != 0){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    /*\n    REP(i,1<<n){\n      ok[i] = false;\n      REP(j,n) if((i & (1 << j)) == 0){\n        int xx = x[j];\n        int yy = y[j];\n        REP(k,4){\n          int xxx = nx[k][yy][xx];\n          int yyy = ny[k][yy][xx];\n          if(f[yyy][xxx] == 2){\n            ok[i] = true;\n            goto next;\n          }\n        }\n      }\n    next:;\n    }\n    */\n\n    REP(i, 1<<n) ok[i] = (1 << n) - 1;\n\n    int ans = 0; //solve(n, 0);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define PLANE (-1)\n#define HOUSE (1)\n#define CHURCH (100)\n\nint x, y;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint home[10][10];\nint n;\nint memo[24][1 << 19];\n\nint goChurch(int ty, int tx)\n{\n    int i;\n    int my, mx;\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        while (0 <= my && my < y && 0 <= mx && mx < x){\n            if (home[my][mx] == CHURCH){\n                return (1);\n            }\n            my += dy[i];\n            mx += dx[i];\n        }\n    }\n    return (0);\n}\n\nint dfs(int v, int bit, int ty, int tx, char state[][11])\n{\n    int i;\n    int ky, kx;\n    int ans;\n    \n    if (bit < 1 << 19 && memo[v][bit] >= 0){\n        return (memo[v][bit]);\n    }\n    \n    if (bit == (1 << n) - 1){\n        if (bit < 1 << 19){\n            return (memo[v][bit] = goChurch(ty, tx));\n        }\n        return (goChurch(ty, tx));\n    }\n    \n    ans = 0;\n    \n    for (i = 0; i < 4; i++){\n\t\tkx = tx + dx[i];\n        ky = ty + dy[i];\n        //ツ逆ツ渉づ可プツδ個ゼツδ督トツづーツ置ツつ「ツづつ「ツつュ\n\t\twhile (0 <= kx && kx < x && 0 <= ky && ky < y && (home[ky][kx] == PLANE || home[ky][kx] == CHURCH || state[ky][kx] == 1)){\n\t\t\tky += dy[i];\n            kx += dx[i];\n\t\t}\n\t\tif (0 <= kx && kx < x && 0 <= ky && ky < y){\n\t\t\tstate[ky][kx] = 1;\n\t\t\tans += dfs(home[ky][kx] , bit | (1 << home[ky][kx]) , ky, kx, state);\n\t\t\tstate[ky][kx] = 0;\n\t\t}\n\t}\n    \n    if (bit < 1 << 19){\n        memo[v][bit] = ans;\n    }\n\treturn (ans);\n}\n\n\nint main(void)\n{\n    int sy, sx;\n    int i, j;\n    char state[10][11];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        n = 0;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &home[i][j]);\n                if (home[i][j] == 2){\n                    home[i][j] = CHURCH;\n                    sy = i;\n                    sx = j;\n                }\n                else if (home[i][j] == HOUSE){\n                    home[i][j] = n++;\n                }\n                else if (home[i][j] == 0){\n                    home[i][j] = PLANE;\n                }\n            }\n        }\n        memset(state, 0, sizeof(state));\n        memset(memo, -1, sizeof(memo));\n        \n        printf(\"%d\\n\", dfs(n, 0, sy, sx, state));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nint memo[23*(1<<23)];\nint d;\n\nint func( int p){\n\twhile(1){\n\t\tint h = mp[p];\n\t\tif( h >= 0 ){\n\t\t\tint mi;\n\t\t\tmp[p] = -1;\n\t\t\ths ^= 1 << h;\n\t\t\tmi = h << 23 | hs;\n\t\t\tif( memo[mi] < 0 ){\n\t\t\t\tint s = 0, i, j;\n\t\t\t\tfor( i = 0; i < 4; i++ ){\n\t\t\t\t\td = dir[i];\n\t\t\t\t\ts += func( p + d );\n\t\t\t\t}\n\t\t\t\tmemo[mi] = s;\n\t\t\t}\n\t\t\ths |= 1 << h;\n\t\t\tmp[p] = h;\n\t\t\treturn memo[mi];\n\t\t}\n\t\tif( h == -9 )break;\n\t\tp += d;\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = sizeof memo / sizeof *memo; i--; memo[i] = -1 );\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\td = dir[i];\n\t\t\tt += func( ch + d);\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int tx;\n    int ty;\n} POINT;\n\nint main(void)\n{\n    int x, y;\n    int i, j;\n    int map[10][10];\n    int (*stat)[24];\n    POINT house[24];\n    int num;\n    char adj[24][24];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        num = 1;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &map[i][j]);\n                if (map[i][j] == 1){\n                    house[num].tx = j;\n                    house[num].ty = i;\n                    num++;\n                }\n                else if (map[i][j] == 2){\n                    house[0].ty = i;\n                    house[0].tx = j;\n                }\n            }\n        }\n        stat = (int(*)[24])malloc((1 << num) * sizeof(int));\n        memset(stat, 0, sizeof(stat));\n        \n        free(stat);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define N 1001\n\nchar map[N][N];\nint w, h;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nenum {R, D, L, U, F};\n\n//\t(x, y), 残りプレゼントの数, 前回の向き\nint getWay(int x, int y, int n, int d)\n{\n\tint ret = 0;\n\tint i;\n\t\n\t//\tすべて配り終え、教会に戻ってきたら\n\tif (n == 0 && map[x][y] == 2){\n\t\treturn (1);\n\t}\n\t\n\tfor (i = 0; i < 4; i++){\n\t\t\n\t\tif (d == F || d == i){\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\t\n\t\t\tif (nx >= 0 && nx < w && ny >= 0 && ny < h){\n\t\t\t\t\n\t\t\t\t//\t家に降りたので曲がってもいい（Free)\n\t\t\t\tif (map[nx][ny] == 1){\n\t\t\t\t\tmap[nx][ny] = -1;\n\t\t\t\t\tret += getWay(nx, ny, n - 1, F);\n\t\t\t\t\tmap[nx][ny] = 1;\n\t\t\t\t}\n\t\t\t\tif (map[nx][ny] != -1){\n\t\t\t\t\tret += getWay(nx, ny, n, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint main(void)\n{\n\tint i, j;\n\tint sx, sy;\n\t\n\twhile (1){\n\t\tint num = 0;\t\t\t//\tプレゼントの数\n\t\tscanf(\"%d %d\", &w, &h);\n\t\t\n\t\tif (w == 0 || h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (j = 0; j < h; j++){\n\t\t\tfor (i = 0; i < w; i++){\n\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t\tif (map[i][j] == 2){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (map[i][j] == 1){\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", getWay(sx, sy, num, F));\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int, int);\n\ninline int solve2(int idn, int flag){\n  if(unlikely((idn != n) & ((ok[flag] & (1 << idn)) == 0)))\n      return 0;\n  if(likely(flag == (1 << n) - 1))\n    return can[idn];\n  return solve(idn, flag);\n}\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  int ret = 0;\n\n  REP(i,4){\n    int xxx = xx;\n    int yyy = yy;\n\n    while(1){\n      int xxxx = nx[i][yyy][xxx];\n      yyy = ny[i][yyy][xxx];\n      if(unlikely(xxxx == -1)) break;\n      int idn = id[yyy][xxxx];\n      if(idn != n){\n        if(likely(flag & (1 << idn))) break;\n        ret += solve2(idn, (flag | (1 << idn)));\n      }\n      xxx = xxxx;\n    }\n  }\n\n  if(likely(!ret & (idn != n)))\n    ok[flag] &= ~(1 << idn);\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n    REP(i,1<<n) ok[i] = (1 << n) - 1;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve2(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ans,wx,wy,rem;\nint tab[10][10];\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy,*p,*pat=&tab[nx][ny];\n\n    nowx=nx;nowy=ny;\n    p=pat;\nLA:\n   nowx++;\n   if(nowx>=wx) goto LB;\n   p+=10;\n   if(*p==2&&rem==0)ans++;\n   if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto LB;\n   }\n   goto LA;\nLB:         \n\n    nowx=nx,nowy=ny;\n    p=pat;\nMA:\n   nowx--;\n   if(0>nowx) goto MB;\n   p-=10;\n   if(*p==2&&rem==0)ans++;\n   if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto MB;\n   }\n   goto MA;\nMB:         \n\n    nowx=nx,nowy=ny;\n    p=pat;\nNA:\n   nowy++;\n   if(nowy>=wy) goto NB;\n   p++;\n   if(*p==2&&rem==0)ans++;\n   if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto NB;\n   }\n   goto NA;\nNB:        \n\n    nowx=nx,nowy=ny;\n    p=pat;\nOA:\n   nowy--;\n   if(0>nowy) goto OB;\n   p--;\n   if(*p==2&&rem==0)ans++;\n   if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        int i,j;\n        for(i=0;i<n;i++)for(j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int, int);\n\ninline int solve2(int idn, int flag){\n  if(unlikely((idn != n) & ((ok[flag] & (1 << idn)) == 0)))\n      return 0;\n  if(likely(flag == (1 << n) - 1))\n    return can[idn];\n  return solve(idn, flag);\n}\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  int ret = 0;\n\n#define q(i)                                    \\\n  {                                             \\\n  xxxx = nx[i][yyy][xxx];                       \\\n  yyy = ny[i][yyy][xxx];                        \\\n  if(unlikely(xxxx == -1)) goto end##i;         \\\n  idn = id[yyy][xxxx];                          \\\n  if(idn != n){                                         \\\n    if(likely(flag & (1 << idn))) goto end##i;          \\\n    ret += solve2(idn, (flag | (1 << idn)));            \\\n  }                                                     \\\n  xxx = xxxx;                                           \\\n}\n\n\n#define p(i)                                    \\\n  {                                             \\\n    int xxx = xx;                               \\\n    int yyy = yy;                               \\\n    int xxxx;                                   \\\n    int idn;                                    \\\n  q(i);                                         \\\n  q(i);                                         \\\n  q(i);                                         \\\n  q(i);                                         \\\n end##i:;                                       \\\n}                                               \\\n\n  p(0);\n  p(1);\n  p(2);\n  p(3);\n\n  if(likely(!ret & (idn != n)))\n    ok[flag] &= ~(1 << idn);\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    int flag = 0; REP(i,n) if(can[i]) flag |= 1 << i;\n    n = cnt;\n    REP(i,1<<n){\n      int b = 0;\n      REP(j,n) if(((i & (1 << j)) == 0) && can[j])\n        b = 1;\n\n      if(n > 16 && b == 0)\n        ok[i] = flag;\n      else\n        ok[i] = (1 << n) - 1;\n    }\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve2(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ans;\nint tab[12][12];\nint wx,wy;\nint nx,ny,rem;\nvoid solve(int nx,int ny,int rem){\n    int nowx,nowy;\n    nowx=nx;nowy=ny;\nLA:\n   nowx++;\n   if(nowx>=wx) goto LB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto LB;\n   }\n   goto LA;\nLB:         \n\n    nowx=nx,nowy=ny;\nMA:\n   nowx--;\n   if(0>nowx) goto MB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto MB;\n   }\n   goto MA;\nMB:         \n    nowx=nx,nowy=ny;\nNA:\n   nowy++;\n   if(nowy>=wy) goto NB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto NB;\n   }\n   goto NA;\nNB:        \n    nowx=nx,nowy=ny;\nOA:\n   nowy--;\n   if(0>nowy) goto OB;\n   else if(tab[nowx][nowy]==2&&rem==0)ans++;\n   else if(tab[nowx][nowy]==1){\n       tab[nowx][nowy]=-1;\n       solve(nowx,nowy,rem-1);\n       tab[nowx][nowy]=1;\n       goto OB;\n   }\n   goto OA;\nOB: ;\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        int i,j;\n        for(i=0;i<n;i++)for(j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint chousa(int map[10][10],int kx,int ky,int nokori,int m,int n);\n\nint main(void) {\n\tint x,y;\n\tint map[10][10];\n\tint m,n;\n\tint kx,ky;\n\tint kazu;\n\twhile(1) {\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0)break;\n\t\tkazu=0;\n\t\t/*読み込み*/\n\t\tfor(y=0;y<n;y++) {\n\t\t\tfor(x=0;x<m;x++) {\n\t\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\t\tkx=x;\n\t\t\t\t\tky=y;\n\t\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t\t}\n\t\t}\n\t\t/*計算*/\n\t\tprintf(\"%d\\n\",chousa(map,kx,ky,kazu,m,n));\n\t}\n\treturn 0;\n}\n\nint chousa(int map[10][10],int kx,int ky,int nokori,int m,int n) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint mp[144], m, n, cnt, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\n\nvoid func2( int p ){\n\tint d = ch - p;\n\tif( d % 12 ){\n\t\tif( p / 12 != ch / 12 ) return;\n\t\td = d < 0 ? -1: 1;\n\t}\n\telse{\n\t\td = d < 0 ? -12 : 12;\n\t}\n\tfor(; p != ch; ){\n\t\tif( mp[p+=d] == -1 ) return;\n\t}\n\t++cnt;\n}\n\nvoid func( int p, int d ){\n\tint i;\n\tswitch( mp[p] ){\n\t\tcase 1:\n\t\t\tmp[p] = -1;\n\t\t\tif( !--hs ){\n\t\t\t\tfunc2( p );\n\t\t\t}\n\t\t\telse for( i = 0; i < 4; i++ ){\n\t\t\t\tfunc( p + dir[i], dir[i] );\n\t\t\t}\n\t\t\tmp[p] = 1;\n\t\t\ths++;\n\t\tcase 0:\n\t\tcase 2:\n\t\t\tfunc(p+d,d); break;\n\t}\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = cnt = 0;\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -1;\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tmp[i*12+j] = t;\n\t\t\t\tif( t == 1 ) hs++;\n\t\t\t\telse if( t == 2 ) ch = p = i * 12 + j;\n\t\t\t}\n\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tfunc( p + dir[i], dir[i] );\n\t\t}\n\t\tprintf(\"%d\\n\", cnt );\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  if(unlikely(flag == (1 << n) - 1)){\n    return can[idn];\n  }else{\n    if(idn != n)\n      if(likely((ok[flag] & (1 << idn)) == 0)) return 0;\n\n    // printf(\"%d %d %d\\n\", xx, yy, flag);\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(1){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        if(unlikely(idn != n)){\n          if(flag & (1 << idn)) break;\n          ret += solve(idn, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(!ret && idn - n)\n      ok[flag] &= ~(1 << idn);\n\n    return ret;\n  }\n}\n\nint main(){\n  while(1){\n    int w = getInt();\n    int h = getInt();\n\n    int i, j, k;\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      f[i][j] = getInt();\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j] != 0){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    /*\n    REP(i,1<<n){\n      ok[i] = false;\n      REP(j,n) if((i & (1 << j)) == 0){\n        int xx = x[j];\n        int yy = y[j];\n        REP(k,4){\n          int xxx = nx[k][yy][xx];\n          int yyy = ny[k][yy][xx];\n          if(f[yyy][xxx] == 2){\n            ok[i] = true;\n            goto next;\n          }\n        }\n      }\n    next:;\n    }\n    */\n\n    REP(i, 1<<n) ok[i] = (1 << n) - 1;\n\n    int ans = solve(n, 0);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define PLANE (-1)\n#define HOUSE (1)\n#define CHURCH (100)\n\nint x, y;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint home[10][10];\nint n;\nint memo[24][1 << 20];\n\nint goChurch(int ty, int tx)\n{\n    int i;\n    int my, mx;\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        while (0 <= my && my < y && 0 <= mx && mx < x){\n            if (home[my][mx] == CHURCH){\n                return (1);\n            }\n            my += dy[i];\n            mx += dx[i];\n        }\n    }\n    return (0);\n}\n\nint dfs(int v, int bit, int ty, int tx, int state[][10])\n{\n    int i;\n    int ky, kx;\n    int ans;\n    \n    if (bit < 1 << 20 && memo[v][bit] >= 0){\n        return (memo[v][bit]);\n    }\n    \n    if (bit == (1 << n) - 1){\n        if (bit < 1 << 20){\n            return (memo[v][bit] = goChurch(ty, tx));\n        }\n        return (goChurch(ty, tx));\n    }\n    \n    ans = 0;\n    \n    for (i = 0; i < 4; i++){\n\t\tkx = tx + dx[i], ky = ty + dy[i];\n        //ツ逆ツ渉づ可プツδ個ゼツδ督トツづーツ置ツつ「ツづつ「ツつュ\n\t\twhile (0 <= kx && kx < x && 0 <= ky && ky < y && (home[ky][kx] == PLANE || home[ky][kx] == CHURCH || state[ky][kx] == 1)){\n\t\t\tky += dy[i];\n            kx += dx[i];\n\t\t}\n\t\tif (0 <= kx && kx < x && 0 <= ky && ky < y){\n\t\t\tstate[ky][kx] = 1;\n\t\t\tans += dfs(home[ky][kx] , bit | (1 << home[ky][kx]) , ky, kx, state);\n\t\t\tstate[ky][kx] = 0;\n\t\t}\n\t}\n    \n    if (bit < 1 << 20){\n        memo[v][bit] = ans;\n    }\n\treturn (ans);\n}\n\n\nint main(void)\n{\n    int sy, sx;\n    int i, j;\n    int state[10][10];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        memset(home, PLANE, sizeof(home));\n        n = 0;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &state[i][j]);\n                if (state[i][j] == 2){\n                    home[i][j] = CHURCH;\n                    sy = i;\n                    sx = j;\n                }\n                else if (state[i][j] == HOUSE){\n                    home[i][j] = n++;\n                }\n            }\n        }\n        memset(state, 0, sizeof(state));\n        memset(memo, -1, sizeof(memo));\n        \n        printf(\"%d\\n\", dfs(n, 0, sy, sx, state));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int, int);\n\ninline int solve2(int idn, int flag){\n  if((idn != n) & ((ok[flag] & (1 << idn)) == 0))\n      return 0;\n  if(likely(flag == (1 << n) - 1))\n    return can[idn];\n  return solve(idn, flag);\n}\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  int ret = 0;\n\n#define q(i)                                    \\\n  {                                             \\\n  xxxx = nx[i][yyy][xxx];                       \\\n  yyy = ny[i][yyy][xxx];                        \\\n  if(unlikely(xxxx == -1)) goto end##i;         \\\n  idn = id[yyy][xxxx];                          \\\n  if(idn != n){                                         \\\n    if(likely(flag & (1 << idn))) goto end##i;          \\\n    ret += solve2(idn, (flag | (1 << idn)));            \\\n  }                                                     \\\n  xxx = xxxx;                                           \\\n}\n\n\n#define p(i)                                    \\\n  {                                             \\\n    int xxx = xx;                               \\\n    int yyy = yy;                               \\\n    int xxxx;                                   \\\n    int idn;                                    \\\n  q(i);                                         \\\n  q(i);                                         \\\n  q(i);                                         \\\n  q(i);                                         \\\n end##i:;                                       \\\n}                                               \\\n\n  p(0);\n  p(1);\n  p(2);\n  p(3);\n\n  if(likely(!ret & (idn != n)))\n    ok[flag] &= ~(1 << idn);\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    int flag = 0; REP(i,n) if(can[i]) flag |= 1 << i;\n    n = cnt;\n    REP(i,1<<n){\n      int b = 0;\n      REP(j,n) if(((i & (1 << j)) == 0) && can[j])\n        b = 1;\n\n      if(b == 0)\n        ok[i] = flag;\n      else\n        ok[i] = (1 << n) - 1;\n    }\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve2(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int, int);\n\ninline int solve2(int idn, int flag){\n  if(unlikely((idn != n) & ((ok[flag] & (1 << idn)) == 0)))\n      return 0;\n  if(likely(flag == (1 << n) - 1))\n    return can[idn];\n  return solve(idn, flag);\n}\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  int ret = 0;\n\n#define p(i)                                    \\\n  {                                             \\\n    int xxx = xx;                               \\\n    int yyy = yy;                               \\\n                                                \\\n    while(1){                                   \\\n      int xxxx = nx[i][yyy][xxx];               \\\n      yyy = ny[i][yyy][xxx];                    \\\n      if(unlikely(xxxx == -1)) break;           \\\n      int idn = id[yyy][xxxx];                  \\\n      if(idn != n){                             \\\n        if(likely(flag & (1 << idn))) break;            \\\n        ret += solve2(idn, (flag | (1 << idn)));        \\\n      }                                                 \\\n      xxx = xxxx;                                       \\\n    }                                                   \\\n  }\n  p(0);\n  p(1);\n  p(2);\n  p(3);\n\n  if(likely(!ret & (idn != n)))\n    ok[flag] &= ~(1 << idn);\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n    REP(i,1<<n) ok[i] = (1 << n) - 1;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve2(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint ok[1<<23];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int, int);\ninline int solve2(int idn, int flag){\n  if(idn != n)\n    if(likely((ok[flag] & (1 << idn)) == 0))\n      return 0;\n\n  if(flag == (1 << n) - 1)\n    return can[idn];\n\n  return solve(idn, flag);\n}\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n\n  int ret = 0;\n\n  REP(i,4){\n    int xxx = xx;\n    int yyy = yy;\n\n    while(1){\n      int xxxx = nx[i][yyy][xxx];\n      int yyyy = ny[i][yyy][xxx];\n      if(xxxx == -1) break;\n      int idn = id[yyyy][xxxx];\n      if(idn != n){\n        if(flag & (1 << idn)) break;\n        ret += solve2(idn, (flag | (1 << idn)));\n      }\n      xxx = xxxx; yyy = yyyy;\n    }\n  }\n\n  if(!ret && idn - n)\n    ok[flag] &= ~(1 << idn);\n\n  return ret;\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n    REP(i,1<<n) ok[i] = (1 << n) - 1;\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve2(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint mp[144];\nint dir[] = { -12, -1, 1, 12 };\nint cnt;\n\nvoid func(int p, int d, int hs ){\n\tif( mp[p] & 1 ){\n\t\tif( mp[p] != 9 ){\n\t\t\tint i;\n\t\t\tif( !--hs ){\n\t\t\t\tif( mp[p] & 2 ) cnt++;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmp[p] ^= 1;\n\t\t\tfor( i = 0; i < 4; i++ ){\n\t\t\t\tfunc( p + dir[i], dir[i], hs );\n\t\t\t}\n\t\t\tmp[p] |= 1;\n\t\t}\n\t}\n\telse func( p+d, d, hs );\n}\n\nint main(void){\n\tint m,n,i,j,p,t,ch,hs;\n\tfor(;scanf(\"%d%d\",&m,&n),m;){\n\t\tcnt = hs = 0;\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = 9;\n\t\tfor( i = 1; i <= n; i++ ){\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch(t){\n\t\t\t\t\tcase 2:\tch = p;\n\t\t\t\t\tcase 0: mp[p] = 0; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmp[p] = 1;\n\t\t\t\t\t\ths++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != 9; )\n\t\t\t\tif(mp[j]==1)mp[j]=3;\n\t\t}\n\t\tfor(i=0;i<4;i++){\n\t\t\tfunc( ch+dir[i], dir[i], hs );\n\t\t}\n\t\tprintf(\"%d\\n\", cnt );\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nint *memo;\nint d;\n\nint func( int p){\n\twhile(1){\n\t\tint h = mp[p];\n\t\tif( h >= 0 ){\n\t\t\tint mi;\n\t\t\tmp[p] = -1;\n\t\t\ths ^= 1 << h;\n\t\t\tmi = h << 23 | hs;\n\t\t\tif( memo[mi] < 0 ){\n\t\t\t\tint s = 0, i, j;\n\t\t\t\tfor( i = 0; i < 4; i++ ){\n\t\t\t\t\td = dir[i];\n\t\t\t\t\ts += func( p + d );\n\t\t\t\t}\n\t\t\t\tmemo[mi] = s;\n\t\t\t}\n\t\t\ths |= 1 << h;\n\t\t\tmp[p] = h;\n\t\t\treturn memo[mi];\n\t\t}\n\t\tif( h == -9 )break;\n\t\tp += d;\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tmemo = malloc( sizeof(int) *  23 * ( 1 << 23 ) );\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = 23*(1<<23); i--; memo[i] = -1 );\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\td = dir[i];\n\t\t\tt += func( ch + d);\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n\tfree( memo );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nint memo[23*(1<<23)];\n\nint func( int p, int d ){\n\tint h = mp[p];\n\tif( h >= 0 ){\n\t\tint mi;\n\t\tmp[p] = -1;\n\t\ths ^= 1 << h;\n\t\tmi = h << 23 | hs;\n\t\tif( memo[mi] < 0 ){\n\t\t\tint s = 0, i, j;\n\t\t\tfor( i = 0; i < 4; i++ )\n\t\t\t\ts += func( p + dir[i], dir[i] );\n\t\t\tmemo[mi] = s;\n\t\t}\n\t\ths |= 1 << h;\n\t\tmp[p] = h;\n\t\treturn memo[mi];\n\t}\n\tif( h != -9 ){\n\t\treturn func( p + d, d );\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = sizeof memo / sizeof *memo; i--; memo[i] = -1 );\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt += func( ch + dir[i], dir[i] );\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0548: Reindeer with no sense of direction\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nsigned char map[11][11]; int m, n;\nint cnt, ans;\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nvoid dfs(int rr, int cc, int s)\n{\n\tint i, r, c;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tr = rr, c = cc;\n\t\twhile (1) {\n\t\t\tr += mv[i][0], c += mv[i][1];\n\t\t\tif (map[r][c] < 0) break;\n\t\t\tif (map[r][c] == 1) {\n\t\t\t\tmap[r][c] = 0;\n\t\t\t\tdfs(r, c, s+1);\n\t\t\t\tmap[r][c] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (map[r][c] == 2 && s == cnt) { ans++; return; }\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint r, c, v, sr, sc;\n\n\twhile (scanf(\"%d%d\", &m, &n) && m > 0) {\n\t\tmemset(map, -1, sizeof(map));\n\t\tfor (cnt = 0, r = 1; r <= n; r++) for (c = 1; c <= m; c++) {\n\t\t\tscanf(\"%d\", &v);\n\t\t\tmap[r][c] = v;\n\t\t\tif (v == 1) cnt++;\n\t\t\telse if (v == 2) sr = r, sc = c;\n\t\t}\n\t\tans = 0, dfs(sr, sc, 0);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define PLANE (-1)\n#define HOUSE (1)\n#define CHURCH (100)\n\nint x, y;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nint home[10][10];\nint n;\nint memo[24][1 << 20];\n\nint goChurch(int ty, int tx)\n{\n    int i;\n    int my, mx;\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        while (0 <= my && my < y && 0 <= mx && mx < x){\n            if (home[my][mx] == CHURCH){\n                return (1);\n            }\n            my += dy[i];\n            mx += dx[i];\n        }\n    }\n    return (0);\n}\n\nint dfs(int v, int bit, int ty, int tx, char state[][11])\n{\n    int i;\n    int ky, kx;\n    int ans;\n    \n    if (bit < 1 << 20 && memo[v][bit] >= 0){\n        return (memo[v][bit]);\n    }\n    \n    if (bit == (1 << n) - 1){\n        if (bit < 1 << 20){\n            return (memo[v][bit] = goChurch(ty, tx));\n        }\n        return (goChurch(ty, tx));\n    }\n    \n    ans = 0;\n    \n    for (i = 0; i < 4; i++){\n\t\tkx = tx + dx[i], ky = ty + dy[i];\n        //ツ逆ツ渉づ可プツδ個ゼツδ督トツづーツ置ツつ「ツづつ「ツつュ\n\t\twhile (0 <= kx && kx < x && 0 <= ky && ky < y && (home[ky][kx] == PLANE || home[ky][kx] == CHURCH || state[ky][kx] == 1)){\n\t\t\tky += dy[i];\n            kx += dx[i];\n\t\t}\n\t\tif (0 <= kx && kx < x && 0 <= ky && ky < y){\n\t\t\tstate[ky][kx] = 1;\n\t\t\tans += dfs(home[ky][kx] , bit | (1 << home[ky][kx]) , ky, kx, state);\n\t\t\tstate[ky][kx] = 0;\n\t\t}\n\t}\n    \n    if (bit < 1 << 20){\n        memo[v][bit] = ans;\n    }\n\treturn (ans);\n}\n\n\nint main(void)\n{\n    int sy, sx;\n    int i, j;\n    char state[10][11];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        n = 0;\n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%d\", &home[i][j]);\n                if (home[i][j] == 2){\n                    home[i][j] = CHURCH;\n                    sy = i;\n                    sx = j;\n                }\n                else if (home[i][j] == HOUSE){\n                    home[i][j] = n++;\n                }\n                else if (home[i][j] == 0){\n                    home[i][j] = PLANE;\n                }\n            }\n        }\n        memset(state, 0, sizeof(state));\n        memset(memo, -1, sizeof(memo));\n        \n        printf(\"%d\\n\", dfs(n, 0, sy, sx, state));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint ans,wx,wy,rem;\nint tab[10][10];\ninline void solve(int nx,int ny,int rem){\n    int nowx,nowy,*p,*pat=&tab[nx][ny];\n\n    nowx=nx;nowy=ny;\n    p=pat;\nLA:\n   nowx++;\n   if(nowx>=wx) goto LB;\n   p+=10;\n   if(*p==2&&rem==0)ans++;\n   else if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto LB;\n   }\n   goto LA;\nLB:         \n\n    nowx=nx,nowy=ny;\n    p=pat;\nMA:\n   nowx--;\n   if(0>nowx) goto MB;\n   p-=10;\n   if(*p==2&&rem==0)ans++;\n   else if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto MB;\n   }\n   goto MA;\nMB:         \n\n    nowx=nx,nowy=ny;\n    p=pat;\nNA:\n   nowy++;\n   if(nowy>=wy) goto NB;\n   p++;\n   if(*p==2&&rem==0)ans++;\n   else if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       goto NB;\n   }\n   goto NA;\nNB:        \n\n    nowx=nx,nowy=ny;\n    p=pat;\nOA:\n   nowy--;\n   if(0>nowy) return;\n   p--;\n   if(*p==2&&rem==0)ans++;\n   else if(*p==1){\n       *p=-1;\n       solve(nowx,nowy,rem-1);\n       *p=1;\n       return;\n   }\n   goto OA;\n}\nint main(){\n    for(;;){\n        int m,n;\n        scanf(\"%d%d\",&m,&n);\n        if(m==0&&n==0)break;\n        int stx,sty,homec=0;\n        int i,j;\n        for(i=0;i<n;i++)for(j=0;j<m;j++){\n            scanf(\"%d\",&tab[i][j]);\n            if(tab[i][j]==1)homec++;\n            else if(tab[i][j]==2){stx=i;sty=j;}\n        }\n        wx=n;wy=m;\n        ans=0;\n        solve(stx,sty,homec);\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* constant */\n\n#define MAX_M           (10)\n#define MAX_N           (10)\n#define MAX_HOME        (23)\n\n/* typedef */\n\ntypedef int nbr_t[MAX_HOME + 1];\n\n/* global variables */\n\nstatic int m, n;\nstatic int nhome;\n\nstatic int toch[MAX_HOME], visited[MAX_HOME];\nstatic nbr_t nbrs[MAX_HOME][4];\n\nstatic int drcs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n/* subroutines */\n\nvoid find_nbr(int y0, int x0, int sects[], nbr_t *nbr) {\n  int dx, dy, hid, i, j, x, y;\n\n  for (i = 0; i < 4; i++) {\n    dy = drcs[i][0];\n    dx = drcs[i][1];\n    y = y0 + dy;\n    x = x0 + dx;\n    j = 0;\n\n    while (y >= 0 && y < n && x >= 0 && x < m) {\n      hid = sects[y * m + x];\n      if (hid != -1) nbr[i][j++] = hid;\n      y += dy;\n      x += dx;\n    }\n\n    nbr[i][j] = -1;\n  }\n}\n\nint count_rt(int k, int hid) {\n  int count, i;\n  int *nb0;\n\n  if (k == 0)\n    return (toch[hid] ? 1 : 0);\n\n  count = 0;\n\n  for (i = 0; i < 4; i++) {\n    for (nb0 = nbrs[hid][i]; *nb0 != -1; nb0++) {\n      if (! visited[*nb0]) {\n        visited[*nb0] = 1;\n        count += count_rt(k - 1, *nb0);\n        visited[*nb0] = 0;\n        break;\n      }\n    }\n  }\n\n  return count;\n}\n\n/* main */\n\nint main(int argc, char **argv) {\n  int chx, chy, count, d, hid, i, *nb0, x, y;\n  static int homes[MAX_HOME][2];\n  static int sects[MAX_N * MAX_M];\n  static nbr_t fromch[4];\n\n  for (;;) {\n    scanf(\"%d %d\", &m, &n);\n    if ((m | n) == 0) break;\n\n    nhome = 0;\n\n    for (y = 0; y < n; y++) {\n      for (x = 0; x < m; x++) {\n        scanf(\"%d\", &d);\n\n        switch (d) {\n        case 1:\n          homes[nhome][0] = y;\n          homes[nhome][1] = x;\n          sects[y * m + x] = nhome++;\n          break;\n        case 2:\n          chy = y;\n          chx = x;\n        default:\n          sects[y * m + x] = -1;\n        }\n      }\n    }\n\n    find_nbr(chy, chx, sects, fromch);\n\n    memset(toch, 0, sizeof(int) * nhome);\n\n    for (i = 0; i < 4; i++)\n      for (nb0 = fromch[i]; *nb0 != -1; nb0++)\n        toch[*nb0] = 1;\n\n    for (i = 0; i < nhome; i++)\n      find_nbr(homes[i][0], homes[i][1], sects, nbrs[i]);\n\n    memset(visited, 0, sizeof(int) * nhome);\n\n    count = 0;\n\n    for (i = 0; i < 4; i++) {\n      hid = *(fromch[i]);\n      if (hid != -1) {\n        visited[hid] = 1;\n        count += count_rt(nhome - 1, hid);\n        visited[hid] = 0;\n      }\n    }\n\n    printf(\"%d\\n\", count);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define REP(i,n) for(i=0; i<(int)(n); i++)\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define likely(x)       __builtin_expect(!!(x), 1)\n#define unlikely(x)     __builtin_expect(!!(x), 0)\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint memo[23][1<<16];\nint f[10][10];\nint id[10][10];\nint nx[4][10][10];\nint ny[4][10][10];\nint x[24];\nint y[24];\nint n;\nint can[23];\n\nint solve(int idn, int flag){\n  int i;\n  int xx = x[idn];\n  int yy = y[idn];\n  if(unlikely(flag == (1 << n) - 1)){\n    return can[idn];\n  }else{\n    if(idn < 23 && flag < (1 << 16))\n      if(memo[idn][flag] != -1)\n        return memo[idn][flag];\n\n    int ret = 0;\n\n    REP(i,4){\n      int xxx = xx;\n      int yyy = yy;\n\n      while(1){\n        int xxxx = nx[i][yyy][xxx];\n        int yyyy = ny[i][yyy][xxx];\n        if(xxxx == -1) break;\n        int idn = id[yyyy][xxxx];\n        if(idn != n){\n          if(flag & (1 << idn)) break;\n          ret += solve(idn, (flag | (1 << idn)));\n        }\n        xxx = xxxx; yyy = yyyy;\n      }\n    }\n\n    if(idn < 23 && flag < (1 << 16))\n      memo[idn][flag] = ret;\n\n    return ret;\n  }\n}\n\nint main(){\n  while(1){\n    int w, h;\n    int i, j, k;\n\n    scanf(\"%d%d\", &w, &h);\n\n    if(w + h == 0) break;\n\n    REP(i,h) REP(j,w)\n      scanf(\"%d\", &f[i][j]);\n\n    int cnt = 0;\n    REP(i,h) REP(j,w) if(f[i][j]){\n      if(f[i][j] == 1){\n        y[cnt] = i;\n        x[cnt] = j;\n        id[i][j] = cnt;\n        can[cnt] = 0;\n        cnt++;\n      }\n\n      REP(k,4){\n        int xx = j + _dx[k];\n        int yy = i + _dy[k];\n        nx[k][i][j] = ny[k][i][j] = -1;\n        while(ISIN(xx, yy, w, h)){\n          if(f[yy][xx] != 0){\n            nx[k][i][j] = xx;\n            ny[k][i][j] = yy;\n            if(f[yy][xx] == 2)\n              can[cnt - 1] = 1;\n            break;\n          }\n          xx += _dx[k];\n          yy += _dy[k];\n        }\n      }\n    }\n\n    n = cnt;\n    memset(memo, -1, sizeof(memo));\n\n    REP(i,h) REP(j,w) if(f[i][j] == 2){\n      x[n] = j; y[n] = i;\n      id[i][j] = n;\n    }\n\n    printf(\"%d\\n\", solve(n, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n/* constant */\n \n#define MAX_M           (10)\n#define MAX_N           (10)\n#define MAX_HOME        (23)\n \n/* typedef */\n \ntypedef int nbr_t[MAX_HOME + 1];\n \n/* global variables */\n \nstatic int m, n;\nstatic int nhome;\n \nstatic int toch[MAX_HOME], visited[MAX_HOME];\nstatic nbr_t nbrs[MAX_HOME][4];\n \nstatic int drcs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n \n/* subroutines */\n \nvoid find_nbr(int y0, int x0, int sects[], nbr_t *nbr) {\n  int dx, dy, hid, i, j, x, y;\n \n  for (i = 0; i < 4; i++) {\n    dy = drcs[i][0];\n    dx = drcs[i][1];\n    y = y0 + dy;\n    x = x0 + dx;\n    j = 0;\n \n    while (y >= 0 && y < n && x >= 0 && x < m) {\n      hid = sects[y * m + x];\n      if (hid != -1) nbr[i][j++] = hid;\n      y += dy;\n      x += dx;\n    }\n \n    nbr[i][j] = -1;\n  }\n}\n \nint count_rt(int k, int hid) {\n  int count, i;\n  int *nb0;\n \n  if (k == 0)\n    return (toch[hid] ? 1 : 0);\n \n  count = 0;\n \n  for (i = 0; i < 4; i++) {\n    for (nb0 = nbrs[hid][i]; *nb0 != -1; nb0++) {\n      if (! visited[*nb0]) {\n        visited[*nb0] = 1;\n        count += count_rt(k - 1, *nb0);\n        visited[*nb0] = 0;\n        break;\n      }\n    }\n  }\n \n  return count;\n}\n \n/* main */\n \nint main(int argc, char **argv) {\n  int chx, chy, count, d, hid, i, *nb0, x, y;\n  static int homes[MAX_HOME][2];\n  static int sects[MAX_N * MAX_M];\n  static nbr_t fromch[4];\n \n  for (;;) {\n    scanf(\"%d %d\", &m, &n);\n    if ((m | n) == 0) break;\n \n    nhome = 0;\n \n    for (y = 0; y < n; y++) {\n      for (x = 0; x < m; x++) {\n        scanf(\"%d\", &d);\n \n        switch (d) {\n        case 1:\n          homes[nhome][0] = y;\n          homes[nhome][1] = x;\n          sects[y * m + x] = nhome++;\n          break;\n        case 2:\n          chy = y;\n          chx = x;\n        default:\n          sects[y * m + x] = -1;\n        }\n      }\n    }\n \n    find_nbr(chy, chx, sects, fromch);\n \n    memset(toch, 0, sizeof(int) * nhome);\n \n    for (i = 0; i < 4; i++)\n      for (nb0 = fromch[i]; *nb0 != -1; nb0++)\n        toch[*nb0] = 1;\n \n    for (i = 0; i < nhome; i++)\n      find_nbr(homes[i][0], homes[i][1], sects, nbrs[i]);\n \n    memset(visited, 0, sizeof(int) * nhome);\n \n    count = 0;\n \n    for (i = 0; i < 4; i++) {\n      hid = *(fromch[i]);\n      if (hid != -1) {\n        visited[hid] = 1;\n        count += count_rt(nhome - 1, hid);\n        visited[hid] = 0;\n      }\n    }\n \n    printf(\"%d\\n\", count);\n  }\n \n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][10];\nint m,n;\n\nint chousa(int kx,int ky,int nokori) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(map,x,ky,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(map,kx,y,nokori-1,m,n);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tbreak;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}\n\nint main(void) {\n\tint x,y;\n\tint kx,ky;\n\tint kazu;\n\twhile(1) {\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0)break;\n\t\tkazu=0;\n\t\t/*読み込み*/\n\t\tfor(y=0;y<n;y++) {\n\t\t\tfor(x=0;x<m;x++) {\n\t\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\t\tkx=x;\n\t\t\t\t\tky=y;\n\t\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t\t}\n\t\t}\n\t\t/*計算*/\n\t\tprintf(\"%d\\n\",chousa(kx,ky,kazu));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][10];\nint m,n;\n\nint chousa(int kx,int ky,int nokori) {\n\tint x,y;\n\tint result=0;\n\tint house=0;\n\tif(nokori<0)return 0;\n\tif(map[kx][ky]==1) {/*今いる家を通ったことにする*/\n\t\tmap[kx][ky]=0;\n\t\thouse=1;\n\t}\n\t/*左に道順を調査*/\n\tfor(x=kx-1;x>=0;x--) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(x,ky,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\t\t\treturn result;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*右に道順を調査*/\n\tfor(x=kx+1;x<m;x++) {\n\t\t/*家に降りる*/\n\t\tif(map[x][ky]==1) {\n\t\t\tresult+=chousa(x,ky,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[x][ky]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\t\t\treturn result;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[x][ky]==3)break;\n\t}\n\t/*上に道順を調査*/\n\tfor(y=ky-1;y>=0;y--) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(kx,y,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\t\t\treturn result;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\t/*下に道順を調査*/\n\tfor(y=ky+1;y<n;y++) {\n\t\t/*家に降りる*/\n\t\tif(map[kx][y]==1) {\n\t\t\tresult+=chousa(kx,y,nokori-1);\n\t\t\tbreak;/*家の上を通る場合には必ずプレゼントを拾う*/\n\t\t}\n\t\t/*教会に戻る*/\n\t\telse if(map[kx][y]==2 && nokori==0) {\n\t\t\tresult++;\n\t\t\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\t\t\treturn result;\n\t\t}\n\t\t/*通れない*/\n\t\telse if(map[kx][y]==3)break;\n\t}\n\tif(house)map[kx][ky]=1;/*通った家を元に戻す*/\n\treturn result;\n}\n\nint main(void) {\n\tint x,y;\n\tint kx,ky;\n\tint kazu;\n\twhile(1) {\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0)break;\n\t\tkazu=0;\n\t\tkx=ky=0;\n\t\t/*読み込み*/\n\t\tfor(y=0;y<n;y++) {\n\t\t\tfor(x=0;x<m;x++) {\n\t\t\t\tscanf(\"%d\",&map[x][y]);\n\t\t\t\tif(map[x][y]==2) {/*教会*/\n\t\t\t\t\tkx=x;\n\t\t\t\t\tky=y;\n\t\t\t\t} else if(map[x][y]==1)kazu++;/*家*/\n\t\t\t}\n\t\t}\n\t\t/*計算*/\n\t\tprintf(\"%d\\n\",chousa(kx,ky,kazu));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint mp[144], m, n, hs, ch;\nint dir[] = { -12, -1, 1, 12 };\nint memo[23*(1<<23)];\n\nint func( int p, int d ){\n\twhile(1){\n\t\tint h = mp[p];\n\t\tif( h >= 0 ){\n\t\t\tint mi;\n\t\t\tmp[p] = -1;\n\t\t\ths ^= 1 << h;\n\t\t\tmi = h << 23 | hs;\n\t\t\tif( memo[mi] < 0 ){\n\t\t\t\tint s = 0, i, j;\n\t\t\t\tfor( i = 0; i < 4; i++ )\n\t\t\t\t\ts += func( p + dir[i], dir[i] );\n\t\t\t\tmemo[mi] = s;\n\t\t\t}\n\t\t\ths |= 1 << h;\n\t\t\tmp[p] = h;\n\t\t\treturn memo[mi];\n\t\t}\n\t\tif( h == -9 )break;\n\t\tp += d;\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i,j,p,t;\n\tfor(; scanf(\"%d%d\",&m,&n),m;){\n\t\ths = 0;\n\t\tfor( i = 0; i < 144; i++ ) mp[i] = -9;\n\t\tfor( i = sizeof memo / sizeof *memo; i--; memo[i] = -1 );\n\t\tfor( i = 1; i <= n; i++ )\n\t\t\tfor( j = 1; j <= m; j++ ){\n\t\t\t\tp = i * 12 + j;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\tswitch( t ){\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tch = p;\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tmp[p] = -1; break;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tmemo[hs<<23] = 0;\n\t\t\t\t\t\tmp[p] = hs++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt = dir[i];\n\t\t\tfor( j = ch; mp[j+=t] != -9; )\n\t\t\t\tif( mp[j] >= 0 )memo[ mp[j]<<23 ] = 1;\n\t\t}\n\t\ths = ( 1 << hs ) - 1;\n\t\tt = 0;\n\t\tfor( i = 0; i < 4; i++ ){\n\t\t\tt += func( ch + dir[i], dir[i] );\n\t\t}\n\t\tprintf(\"%d\\n\", t );\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tpairs = new Pair[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tpairs[h] = new Pair(i, j);\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpairs[0] = new Pair(i, j);\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int bit) {\n\t\tint k = cur << 24 | bit;\n\t\tif (M.containsKey(k))\n\t\t\treturn M.get(k);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = pairs[cur].y;\n\t\t\tint x = pairs[cur].x;\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (Integer.bitCount(bit) == h) {\n\t\t\t\t\t\treturn res + 1;\n\t\t\t\t\t}\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((bit >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], bit | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(k, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tclass Pair{\n\t\tint y,x;\n\n\t\tpublic Pair(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\t\t\n\t}\n\n\tint m, n, h;\n\tPair[] pairs;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, res, GS;\n\tint[][] map, pos;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] deg;\n\tList<Integer>[][] adj;\n\tboolean[] visited;\n\t\n\tvoid dfs(int v, int S, boolean head){\n//\t\tSystem.out.println(\"V:\"+v+\" S:\"+S+\" Head:\"+head);\n//\t\tdebug(visited);\n\t\tif(!head&&v==N){\n\t\t\tres+=S==GS?1:0;\n\t\t\treturn;\n\t\t}\n\t\tboolean ok = true;\n\t\tif(v!=N){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(adj[v][k].isEmpty())continue;\n\t\t\t\tint nv = adj[v][k].get(0);\n\t\t\t\tif(nv==N)continue;\n\t\t\t\tif(--deg[nv]<=0&&!visited[nv])ok = false;\n\t\t\t}\n\t\t}\n//\t\tdebug(deg);\n\t\tif(!ok){\n//\t\t\tSystem.out.println(\"BAD COND.!!\");\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(adj[v][k].isEmpty())continue;\n\t\t\t\tint nv = adj[v][k].get(0);\n\t\t\t\tif(nv==N)continue;\n\t\t\t\tdeg[nv]++;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(visited[nv])break;\n\t\t\tvisited[nv] = true;\n\t\t\tdfs(nv, S+(1<<nv), false);\n\t\t\tvisited[nv] = false;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(adj[v][k].isEmpty())continue;\n\t\t\tint nv = adj[v][k].get(0);\n\t\t\tif(nv==N)continue;\n\t\t\tdeg[nv]++;\n\t\t}\n\t\treturn;\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tpos = new int[N+1][2];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tpos[id][0] = i; pos[id][1] = j;\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpos[N][0] = i; pos[N][1] = j;\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n\t\t\tdeg = new int[N+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t\tdeg[map[i][j]]+=adj[map[i][j]][k].isEmpty()?0:1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdebug(deg);\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int j=0;j<w;j++)System.out.printf(\"%3d\", map[i][j]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tfor(int i=0;i<=N;i++){\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\t\tSystem.out.print(\"Dir \"+k+\":\");\n//\t\t\t\t\tfor(int nv:adj[i][k])System.out.print(\" \"+nv);\n//\t\t\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tres = 0;\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tvisited = new boolean[N+1];\n\t\t\tdfs(N, 0, true);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final Scanner S=new Scanner(System.in);\n\tprivate static final PrintStream O=System.out;\n\tprivate static final int H=1,K=2;\n\t\n\tprivate static class B {\n\t\tprivate final int i,j;\n\t\t\n\t\tprivate B(final int i, final int j) {\n\t\t\tthis.i=i;\n\t\t\tthis.j=j;\n\t\t}\n\t}\n\t\n\tprivate static class C {\n\t\tprivate final B h[],k;\n\t\tprivate final int m,n;\n\t\t\n\t\tprivate C(final B h[], final B k, final int m, final int n) {\n\t\t\tthis.h=h;\n\t\t\tthis.k=k;\n\t\t\tthis.m=m;\n\t\t\tthis.n=n;\n\t\t}\n\t\t\n\t\tprivate class S {\n\t\t\tprivate final B r;\n\t\t\tprivate final boolean sp[];\n\t\t\t\n\t\t\tprivate S(final B r, final boolean sp[]) {\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.sp=sp;\n\t\t\t}\n\t\t\t\n\t\t\tprivate int hn(final B b) {\n\t\t\t\tfor(int i=0;i<h.length;i++) if(b.i==h[i].i && b.j==h[i].j && sp[i]) return i;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tprivate static final int U=0,D=1,L=2,R=3;\n\t\t\tprivate boolean b(final int d, S ps[], int np) {\n\t\t\t\tB pr;\n\t\t\t\tint hn;\n\t\t\t\tif(d==U) {\n\t\t\t\t\tfor(int pi=r.i;(hn=hn(pr=new B(pi,r.j)))<0;pi--) if(pi<=0) return false;\n\t\t\t\t} else if(d==D) {\n\t\t\t\t\tfor(int pi=r.i;(hn=hn(pr=new B(pi,r.j)))<0;pi++) if(pi>=n-1) return false;\n\t\t\t\t} else if(d==L) {\n\t\t\t\t\tfor(int pj=r.j;(hn=hn(pr=new B(r.i,pj)))<0;pj--) if(pj<=0) return false;\n\t\t\t\t} else if(d==R) {\n\t\t\t\t\tfor(int pj=r.j;(hn=hn(pr=new B(r.i,pj)))<0;pj++) if(pj>=m-1) return false;\n\t\t\t\t} else return false;\n\t\t\t\tboolean psp[]=sp.clone();\n\t\t\t\tpsp[hn]=false;\n\t\t\t\tps[np]=new S(pr,psp);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean rk(final int d) {\n\t\t\t\tif(d==U) {\n\t\t\t\t\tfor(int pi=r.i;pi!=k.i || r.j!=k.j;pi--) if(pi<=0) return false;\n\t\t\t\t} else if(d==D) {\n\t\t\t\t\tfor(int pi=r.i;pi!=k.i || r.j!=k.j;pi++) if(pi>=n-1) return false;\n\t\t\t\t} else if(d==L) {\n\t\t\t\t\tfor(int pj=r.j;r.i!=k.i || pj!=k.j;pj--) if(pj<=0) return false;\n\t\t\t\t} else if(d==R) {\n\t\t\t\t\tfor(int pj=r.j;r.i!=k.i || pj!=k.j;pj++) if(pj>=m-1) return false;\n\t\t\t\t} else return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean cmp(S a) {\n\t\t\t\tif(r.i!=a.r.i || r.j!=a.r.j) return false;\n\t\t\t\tfor(int i=0;i<sp.length;i++) if(sp[i]!=a.sp[i]) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate int getp() {\n\t\t\tint nc=1;\n\t\t\tS cs[]=new S[nc];\n\t\t\tboolean sp[]=new boolean[h.length];\n\t\t\tfor(int i=0;i<sp.length;i++) sp[i]=true;\n\t\t\tcs[0]=new S(new B(k.i,k.j), sp);\n\t\t\tint ca[]=new int[cs.length];\n\t\t\tca[0]=1;\n\t\t\tfor(int i=0;i<h.length;i++) {\n\t\t\t\tlong s=System.currentTimeMillis();\n\t\t\t\tint np=0;\n\t\t\t\tS ps[]=new S[nc*4];\n\t\t\t\tint pa[]=new int[ps.length];\n\t\t\t\tfor(int j=0;j<nc;j++) for(int k=0;k<4;k++) if(cs[j].b(k, ps, np)) {\n\t\t\t\t\tint l;\n\t\t\t\t\tfor(l=0;l<np;l++) if(ps[np].cmp(ps[l])) {\n\t\t\t\t\t\tpa[l]+=ca[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l>=np) {\n\t\t\t\t\t\tpa[np]=ca[j];\n\t\t\t\t\t\tnp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnc=np;\n\t\t\t\tcs=ps;\n\t\t\t\tca=pa;\n\t\t\t\tO.println(i+\":\"+nc+\",\"+(System.currentTimeMillis()-s));\n\t\t\t}\n\t\t\tint a=0;\n\t\t\tfor(int i=0;i<nc;i++) for(int j=0;j<4;j++) if(cs[i].rk(j)) a+=ca[i];\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint m,n;\n\t\twhile((m=S.nextInt())!=0 && (n=S.nextInt())!=0) {\n\t\t\tB th[]=new B[23],k=null;\n\t\t\tint nh=0;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) {\n\t\t\t\tswitch(S.nextInt()) {\n\t\t\t\t\tcase K:\n\t\t\t\t\t\tk=new B(i,j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase H:\n\t\t\t\t\t\tth[nh++]=new B(i,j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tB h[]=new B[nh];\n\t\t\tfor(int i=0;i<h.length;i++) h[i]=th[i];\n\t\t\tif(k!=null) O.println(new C(h,k,m,n).getp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, GS, REST = 13;\n\tint[][] map, pos;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tList<Integer>[][] adj;\n\tboolean[] visited;\n\tMap<Integer, Integer>[][] mem;\n\t\n\tboolean check(int v){\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tif(visited[i]||i==v)continue;\n\t\t\tint c = 0;\n\t\t\tfor(int k=0;k<4;k++)for(int nv:adj[i][k]){\n\t\t\t\tif(visited[nv]){\n\t\t\t\t\tif(nv==v)c++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n//\t\t\tSystem.out.println(\"ID:\" +i+\" C:\"+c);\n\t\t\tif(i==N){\n\t\t\t\tif(c==0)return false;\n\t\t\t}\n\t\t\telse if(c<2)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint dfs(int v, int S, boolean head, int rest){\n//\t\tSystem.out.println(\"V:\"+v);\n//\t\tdebug(visited);\n\t\tif(!head&&v==N){\n\t\t\treturn S==GS?1:0;\n\t\t}\n\t\tif(rest<=REST&&mem[rest][v].containsKey(S))return mem[rest][v].get(S);\n\t\tif(!check(v)){\n//\t\t\tSystem.out.println(\"CHECK OUT\");\n\t\t\treturn 0;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(visited[nv])break;\n\t\t\tvisited[nv] = true;\n\t\t\tres += dfs(nv, S+(1<<nv), false, rest-1);\n\t\t\tvisited[nv] = false;\n\t\t}\n\t\tif(rest<=REST)mem[rest][v].put(S, res);\n\t\treturn res;\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tpos = new int[N+1][2];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tpos[id][0] = i; pos[id][1] = j;\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpos[N][0] = i; pos[N][1] = j;\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int i=0;i<=N;i++){\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\t\tSystem.out.print(\"Dir \"+k+\":\");\n//\t\t\t\t\tfor(int nv:adj[i][k])System.out.print(\" \"+nv);\n//\t\t\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tmem = new Map[REST+1][N+1];\n\t\t\tfor(int i=0;i<=REST;i++)for(int j=0;j<=N;j++)mem[i][j]=new HashMap<Integer, Integer>();\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tvisited = new boolean[N+1];\n//\t\t\tdfs(N, 0, true);\n\t\t\tSystem.out.println(dfs(N, 0, true, N));\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tint km(boolean[] a, int b) {\n\n\t\tint z = 0;\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\n\t\t\tz += a[i] ? 1 : 0;\n\n\t\t\tz *= 2;\n\n\t\t}\n\n\t\treturn z * 100 + b;\n\n\t}\n\n\n\n\tint rec(boolean[] used, int now, int count, int[][] map) {\n\n\t\tif (ht.containsKey(km(used, now))) {\n\n\t\t\treturn ht.get(km(used, now));\n\n\t\t}\n\n\t\tif (count == used.length - 1) {\n\n\t\t\tif (!list.get(now).reachable(list.get(0))){\n\n//\t\t\t\tht.put(km(used, now),0);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n//\t\t\tht.put(km(used, now),1);\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tint[] dx = { -1, 1, 0, 0 };\n\n\t\tint[] dy = { 0, 0, -1, 1 };\n\n\t\tb bnow = list.get(now);\n\n\t\tfor (int i = 0; i < 4; i++) {\n\n\t\t\tint x = bnow.j;\n\n\t\t\tint y = bnow.i;\n\n\t\t\tfor (;; x += dx[i], y += dy[i]) {\n\n\t\t\t\tif (y >= map.length || x >= map[0].length || x < 0 || y < 0) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (map[y][x] > 0) {\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"push\"+i);\n\n\t\t\t\t\tint q = map[y][x];\n\n\t\t\t\t\tused[q] = true;\n\n\t\t\t\t\tmap[y][x] = -1;\n\n\t\t\t\t\tsum += rec(used, q, count + 1, map);\n\n\t\t\t\t\tmap[y][x] = q;\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"pop\"+i);\n\n\t\t\t\t\tused[q] = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tht.put(km(used, now),sum);\n\n\t\treturn sum;\n\n\t}\n\n\n\n\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\tHashMap<Integer, Integer> ht = new HashMap<Integer, Integer>();\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tb start = null;\n\n\t\t\tlist.clear();\n\n\t\t\tht = new HashMap<Integer, Integer>();\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used, 0, 0, map));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tclass R{\n\t\tint id, S;\n\t\tpublic R(int id, int s) {\n\t\t\tthis.id = id;\n\t\t\tS = s;\n\t\t}\n\t}\n\n\tint n, NS, c;\n\tList<R>[] l;\n\tMap<Integer, Integer>[] mem;\n\n\tint dfs(int k, int S){\n//\t\tSystem.out.println(\"C:\"+(c++));\n//\t\tSystem.out.println(\"k:\"+k+\" S:\"+S);\n\t\tInteger g = mem[k].get(S);\n\t\tif(g!=null)return g;\n\t\tif(k==n){\n\t\t\treturn S==(1<<(n+1))-1?1:0;\n\t\t}\n\t\tif(S!=(1<<n)-1&&(S&NS)==NS)return 0;\n\t\tint res = 0;\n\t\tfor(R r:l[k]){\n\t\t\tif((r.S&S)==0)res += dfs(r.id, S+(1<<r.id));\n\t\t}\n\t\tmem[k].put(S, res);\n\t\treturn res;\n\t}\n\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tn = 0;\n\t\t\tint si = 0, sj = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==0)map[i][j]=-1;\n\t\t\t\telse if(map[i][j]==1)map[i][j]=n++;\n\t\t\t\telse {\n\t\t\t\t\tsi = i; sj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap[si][sj] = n;\n\t\t\tNS = 0;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint pi = si, pj = sj;\n\t\t\t\tfor(;;){\n\t\t\t\t\tpi += d[k][0]; pj += d[k][1];\n\t\t\t\t\tif(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1){\n\t\t\t\t\t\t\tNS += 1<<map[pi][pj]; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdebug(map);\n//\t\t\tSystem.out.println(\"NS:\"+NS);\n\t\t\tl = new List[n+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tint x = map[i][j];\n\t\t\t\tl[x] = new ArrayList<R>();\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i, pj = j, S = 0;\n\t\t\t\t\tfor(;;){\n\t\t\t\t\t\tpi += d[k][0]; pj += d[k][1];\n\t\t\t\t\t\tif(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\t\tint nx = map[pi][pj];\n\t\t\t\t\t\t\tif(0<=nx&&nx<n)S+=1<<nx;\n\t\t\t\t\t\t\tif(nx!=-1)l[x].add(new R(nx, S));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"ID:\"+x+\" L:\"+l[x].size());\n//\t\t\t\tfor(R r:l[x]){\n//\t\t\t\t\tSystem.out.println(\"Next:\"+r.id+\" S:\"+r.S);\n//\t\t\t\t}\n\t\t\t}\n\t\t\tmem = new Map[n+1];\n\t\t\tfor(int i=0;i<=n;i++)mem[i] = new HashMap<Integer, Integer>();\n\t\t\tint res = 0;\n//\t\t\tc = 0;\n\t\t\tfor(R r:l[n]){\n//\t\t\t\tSystem.out.println(\"RID:\"+r.id);\n\t\t\t\tres += dfs(r.id, 1<<r.id);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tboolean and(int a, boolean[] b) {\n\n\t\tfor (int i = 1; i < b.length; i++) {\n\n\t\t\tif ((1 & (a >> i)) == 1 && !b[i])\n\n\t\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tint ansC = 0;\n\n\tint rec(boolean[] used, int now, int count, boolean[][] reachableS,\n\n\t\t\tint[][] reachableP) {\n\n\t\tif (count == used.length - 1) {\n\n\t\t\tif (!reachableS[now][0])\n\n\t\t\t\treturn 0;\n\n\t\t\tif (and(reachableP[now][0], used))\n\n\t\t\t\treturn 0;\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tfor (int i = 1; i < used.length; i++) {\n\n\t\t\tif (!used[i]) {\n\n\t\t\t\tif (!reachableS[now][i])\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (and(reachableP[now][i], used))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tused[i] = true;\n\n\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t// System.out.println(\"push\"+i);\n\n\t\t\t\tsum += rec(used, i, count + 1, reachableS, reachableP);\n\n\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t// System.out.println(\"pop\"+i);\n\n\t\t\t\tused[i] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn sum;\n\n\t}\n\n\n\n\tint[] setCost(boolean[][] reachable) {\n\n\t\tint[] ret = new int[reachable.length];\n\n\t\tint count = 1;\n\n\t\tboolean cnt = true;\n\n\t\tLinkedList<Integer> v = new LinkedList<Integer>();\n\n\t\tv.add(0);\n\n\t\twhile (cnt) {\n\n\t\t\tcnt = false;\n\n\t\t\tLinkedList<Integer> nextv = new LinkedList<Integer>();\n\n\t\t\tfor (int i = 1; i < reachable.length; i++) {\n\n\t\t\t\tif (ret[i] == 0) {\n\n\t\t\t\t\tfor (int k : v) {\n\n\t\t\t\t\t\tif (reachable[i][k]) {\n\n\t\t\t\t\t\t\tret[i] = count;\n\n\t\t\t\t\t\t\tcnt |= true;\n\n\t\t\t\t\t\t\tnextv.add(i);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tv=nextv;\n\n\t\t\tcount++;\n\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\t\t\tb start = null;\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\t\t\tboolean[][] reachableS = new boolean[n][n];\n\n\t\t\tint[][] reachableP = new int[n][n];\n\n\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = j + 1; k < w; k++) {\n\n\t\t\t\t\t\t\tif (map[i][k] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[i][k];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[i][k]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = i + 1; k < h; k++) {\n\n\t\t\t\t\t\t\tif (map[k][j] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[k][j];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[k][j]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used, 0, 0, reachableS, reachableP));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final Scanner S=new Scanner(System.in);\n\tprivate static final PrintStream O=System.out;\n\tprivate static final int H=1,K=2;\n\tprivate static final int U=0,D=1,L=2,R=3;\n\t\n\tprivate static class B {\n\t\tprivate final int i,j;\n\t\t\n\t\tprivate B(final int i, final int j) {\n\t\t\tthis.i=i;\n\t\t\tthis.j=j;\n\t\t}\n\t}\n\t\n\tprivate static class C {\n\t\tprivate final int nh,bh[][][],nbh[][];\n\t\t\n\t\tprivate C(final B h[], final int m, final int n) {\n\t\t\tint nh=h.length;\n\t\t\tbh=new int[nh][4][nh];\n\t\t\tnbh=new int[nh][4];\n\t\t\tfor(int i=0;i<4;i++) for(int j=0;j<nh;j++) nbh[j][i]=0;\n\t\t\tfor(int i=0;i<nh;i++) for(int j=0;j<nh;j++) {\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(h[i].i==h[j].i) {\n\t\t\t\t\tif(h[i].j<h[j].j) bh[j][L][nbh[j][L]++]=i;\n\t\t\t\t\telse bh[j][R][nbh[j][R]++]=i;\n\t\t\t\t} else if(h[j].j==h[i].j) {\n\t\t\t\t\tif(h[i].i<h[j].i) bh[j][U][nbh[j][U]++]=i;\n\t\t\t\t\telse bh[j][D][nbh[j][D]++]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.nh=nh-1;\n\t\t}\n\t\t\n\t\tprivate class S {\n\t\t\tprivate final int r;\n\t\t\tprivate final boolean sp[];\n\t\t\t\n\t\t\tprivate S(final int r, final boolean sp[]) {\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.sp=sp;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean b(final int d, S ps[], int np) {\n\t\t\t\tint pr=0;\n\t\t\t\tboolean f=false;\n\t\t\t\tif(d==D || d==R) {\n\t\t\t\t\tfor(int i=0;i<nbh[r][d];i++) if(sp[(pr=bh[r][d][i])]) {\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if(d==U || d==L) {\n\t\t\t\t\tfor(int i=nbh[r][d]-1;i>=0;i--) if(sp[(pr=bh[r][d][i])]) {\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f) {\n\t\t\t\t\tboolean psp[]=sp.clone();\n\t\t\t\t\tpsp[pr]=false;\n\t\t\t\t\tps[np]=new S(pr,psp);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean cmp(S a) {\n\t\t\t\tif(r!=a.r) return false;\n\t\t\t\tfor(int i=0;i<sp.length;i++) if(sp[i]!=a.sp[i]) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean tumi() {\n\t\t\t\tfor(int i=0;i<nh;i++) if(sp[i] && tumih(i)) return true;\n\t\t\t\tif(tumik()) return true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean tumih(final int i) {\n\t\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<nbh[i][j];k++) if(sp[bh[i][j][k]] || bh[i][j][k]==r) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean tumik() {\n\t\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<nbh[nh][j];k++) if(sp[bh[nh][j][k]]) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean tumi2() {\n\t\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<nbh[nh][j];k++) if(bh[nh][j][k]==r) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate int getp() {\n\t\t\tint nc=1;\n\t\t\tS cs[]=new S[nc];\n\t\t\tboolean sp[]=new boolean[nh+1];\n\t\t\tfor(int i=0;i<nh;i++) sp[i]=true;\n\t\t\tsp[nh]=false;\n\t\t\tcs[0]=new S(nh, sp);\n\t\t\tint ca[]=new int[cs.length];\n\t\t\tca[0]=1;\n\t\t\tfor(int i=0;i<nh;i++) {\n\t\t\t\tint np=0;\n\t\t\t\tS ps[]=new S[nc*4];\n\t\t\t\tint pa[]=new int[ps.length];\n\t\t\t\tfor(int j=0;j<nc;j++) for(int k=0;k<4;k++) if(cs[j].b(k, ps, np)) {\n\t\t\t\t\tif(i<nh-1 && ps[np].tumi()) continue;\n\t\t\t\t\tif(i>=nh-1 && ps[np].tumi2()) continue;\n\t\t\t\t\tint l;\n\t\t\t\t\tfor(l=0;l<np;l++) if(ps[np].cmp(ps[l])) {\n\t\t\t\t\t\tpa[l]+=ca[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l>=np) {\n\t\t\t\t\t\tpa[np]=ca[j];\n\t\t\t\t\t\tnp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnc=np;\n\t\t\t\tcs=ps;\n\t\t\t\tca=pa;\n\t\t\t}\n\t\t\tint a=0;\n\t\t\tfor(int i=0;i<nc;i++) a+=ca[i];\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint m,n;\n\t\twhile((m=S.nextInt())!=0 && (n=S.nextInt())!=0) {\n\t\t\tB th[]=new B[23],k=null;\n\t\t\tint nh=0;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) {\n\t\t\t\tswitch(S.nextInt()) {\n\t\t\t\t\tcase K:\n\t\t\t\t\t\tk=new B(i,j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase H:\n\t\t\t\t\t\tth[nh++]=new B(i,j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tB h[]=new B[nh+1];\n\t\t\tfor(int i=0;i<nh;i++) h[i]=th[i];\n\t\t\th[nh]=k;\n\t\t\tO.println(new C(h,m,n).getp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\t\t\tb start = null;\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\t\t\tint dp[][] = new int[1 << n][n];\n\n\t\t\tboolean[][] reachableS = new boolean[n][n];\n\n\t\t\tint[][] reachableP = new int[n][n];\n\n\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = j + 1; k < w; k++) {\n\n\t\t\t\t\t\t\tif (map[i][k] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[i][k];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[i][k]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = i + 1; k < h; k++) {\n\n\t\t\t\t\t\t\tif (map[k][j] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[k][j];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[k][j]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tdp[0][0] = 1;\n\n\t\t\tfor (int i = 0; i < 1 << n; i++) {\n\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\n\t\t\t\t\tint sh = (1 << j);\n\n\t\t\t\t\tif ((i & sh) == 0)\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint sum = 0;\n\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\n\t\t\t\t\t\t// System.out.println(i+\" \"+(i^sh)+\" \"+j+\" ,\"+k+\" reachable = \"+reachable[j][k]+\" \"+dp[i^sh][k]);\n\n\t\t\t\t\t\tif (!reachableS[j][k])\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif ((reachableP[j][k] & i) != 0)\n\n\t\t\t\t\t\t\tcontinue;\n\n\n\n\t\t\t\t\t\tsum += dp[i ^ sh][k];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[i][j] = sum;\n\n\t\t\t\t}\n\n\t\t\t\t// System.out.printf(\"%o\"+Arrays.toString(dp[i])+\"\\n\",i);\n\n\t\t\t}\n\n\n\n\t\t\tSystem.out.println(dp[(1 << n) - 1][0]);\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n, m;\n\tint[][] map;\n//\tint[][] mem;\n\tint size;\n\tint sg;\n\tint[] nodes;\n\tHashMap<Integer, Integer> node_ind;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif( (m|n) == 0 ) break;\n\t\t\tmap = new int[n][m];\n\t\t\tsize = 0;\n\t\t\tnode_ind = new HashMap<Integer, Integer>();\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) {\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif( map[i][j] == 1 ) {\n\t\t\t\t\tnode_ind.put(p2int(j, i), size);\n\t\t\t\t\ttmp.add(p2int(j, i));\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\t\t\t\tif( map[i][j] == 2 ) sg = p2int(j, i);\n\t\t\t}\n\t\t\t\n\t\t\tnodes = new int[size+1];\n\t\t\tfor(int i=0;i<size;i++) nodes[i] = tmp.removeFirst();\n\t\t\tnodes[size] = sg;\n//\t\t\tmem = new int[size+1][1<<size];\n//\t\t\tfor(int[] a: mem) fill(a, -1);\n\t\t\t\n//\t\t\tdebug(nodes);\n//\t\t\tdebug(size, sg);\n\t\t\tSystem.out.println(solve(size, (1<<size)-1));\n\t\t\t\n\t\t}\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tint solve(int i, int S) {\n//\t\tdebug(i, S);\n//\t\tif( mem[i][S] >= 0 ) return mem[i][S];\n\t\t\n\t\tint[] p = int2p(nodes[i]);\n\t\t\n\t\tif( S == 0 ) {\n\t\t\tfor(int j=0;j<4;j++) for(int k=1;;k++) {\n\t\t\t\tif(!allow(p[0]+dx[j]*k, p[1]+dy[j]*k)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[p[1]+dy[j]*k][p[0]+dx[j]*k] == 3)\n\t\t\t\t\tbreak;\n\t\t\t\tif(map[p[1]+dy[j]*k][p[0]+dx[j]*k] == 2)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint cnt = 0;\n\t\t\n\t\tfor(int j=0;j<4;j++) for(int k=1;;k++) {\n\t\t\tif(!allow(p[0]+dx[j]*k, p[1]+dy[j]*k)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(map[p[1]+dy[j]*k][p[0]+dx[j]*k] == 3)\n\t\t\t\tbreak;\n\t\t\tif(map[p[1]+dy[j]*k][p[0]+dx[j]*k] == 1) {\n\t\t\t\tint pp = p2int( p[0]+dx[j]*k, p[1]+dy[j]*k );\n\t\t\t\tint ind = node_ind.get(pp);\n\t\t\t\tmap[p[1]+dy[j]*k][p[0]+dx[j]*k] = 3;\n\t\t\t\tcnt += solve(ind, S - (1<<ind));\n\t\t\t\tmap[p[1]+dy[j]*k][p[0]+dx[j]*k] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn /*mem[i][S] =*/ cnt;\n\t}\n\t\n\tint p2int(int x, int y) {\n\t\treturn x*100 + y;\n\t}\n\tint[] int2p(int val) {\n\t\tint[] p = new int[2];\n\t\tp[0] = val/100;\n\t\tp[1] = val-p[0]*100;\n\t\treturn p;\n\t}\n\t\n\tboolean allow(int x, int y) {\n\t\treturn !( x<0 || y<0 || x>=m || y>= n );\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, GS;\n\tint[][] map;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tList<Integer>[][] adj;\n\tMap<Integer, Integer>[] dp;\n\t\n\tint get(int v, int S, int rest){\n\t\tif(dp[v].containsKey(S))return dp[v].get(S);\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(((S>>nv)&1)==0)continue;\n\t\t\tif(nv==N&&3<=rest)continue;\n\t\t\tres+=get(nv, S-(1<<v), rest-1);\n\t\t\tbreak;\n\t\t}\n\t\tdp[v].put(S, res);\n\t\treturn res;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tdp = new Map[N+1];\n\t\t\tfor(int i=0;i<=N;i++)dp[i]=new HashMap<Integer, Integer>();\n\t\t\tdp[N].put(1<<N, 1);\n\t\t\tint res = 0;\n\t\t\tfor(int k=0;k<4;k++)if(!adj[N][k].isEmpty())res+=get(adj[N][k].get(0), GS, N+1);\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tY = new int[24];\n\t\t\tX = new int[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tY[h] = i;\n\t\t\t\t\t\tX[h] = j;\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tY[0] = i;\n\t\t\t\t\t\tX[0] = j;\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int bit) {\n\t\tint k = cur << 24 | bit;\n\t\tif (M.containsKey(k))\n\t\t\treturn M.get(k);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = Y[cur];\n\t\t\tint x = X[cur];\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (Integer.bitCount(bit) == h) {\n\t\t\t\t\t\treturn res + 1;\n\t\t\t\t\t}\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((bit >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], bit | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(k, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint m, n, h;\n\tint[] Y, X;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, GS, R = 4;\n\tint[][] map;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tList<Integer>[][] adj;\n\tMap<Integer, Integer>[] dp;\n\t\n\tint get(int v, int S, int rest){\n\t\tif(rest==1&&S==(1<<N))return 1;\n\t\tif(R<=rest&&dp[v].containsKey(S))return dp[v].get(S);\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(((S>>nv)&1)==0)continue;\n\t\t\tif(nv==N&&3<=rest)continue;\n\t\t\tres+=get(nv, S-(1<<v), rest-1);\n\t\t\tbreak;\n\t\t}\n\t\tif(R<=rest)dp[v].put(S, res);\n\t\treturn res;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tdp = new Map[N+1];\n\t\t\tfor(int i=0;i<=N;i++)dp[i]=new HashMap<Integer, Integer>();\n\t\t\tdp[N].put(1<<N, 1);\n\t\t\tint res = 0;\n\t\t\tfor(int k=0;k<4;k++)if(!adj[N][k].isEmpty())res+=get(adj[N][k].get(0), GS, N+1);\n\t\t\tSystem.out.println(res);\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, GS, REST = 12;\n\tint[][] map, pos;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tList<Integer>[][] adj;\n\tboolean[] visited;\n\tMap<Integer, Integer>[][] mem;\n\t\n\tboolean check(int v){\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tif(visited[i]||i==v)continue;\n\t\t\tint c = 0;\n\t\t\tfor(int k=0;k<4;k++)for(int nv:adj[i][k]){\n\t\t\t\tif(visited[nv]){\n\t\t\t\t\tif(nv==v)c++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n//\t\t\tSystem.out.println(\"ID:\" +i+\" C:\"+c);\n\t\t\tif(i==N){\n\t\t\t\tif(c==0)return false;\n\t\t\t}\n\t\t\telse if(c<2)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint dfs(int v, int S, boolean head, int rest){\n//\t\tSystem.out.println(\"V:\"+v);\n//\t\tdebug(visited);\n\t\tif(!head&&v==N){\n\t\t\treturn S==GS?1:0;\n\t\t}\n\t\tif(rest<=REST&&mem[rest][v].containsKey(S))return mem[rest][v].get(S);\n\t\tif(!check(v)){\n//\t\t\tSystem.out.println(\"CHECK OUT\");\n\t\t\treturn 0;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(visited[nv])break;\n\t\t\tvisited[nv] = true;\n\t\t\tres += dfs(nv, S+(1<<nv), false, rest-1);\n\t\t\tvisited[nv] = false;\n\t\t}\n\t\tif(rest<=REST)mem[rest][v].put(S, res);\n\t\treturn res;\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tpos = new int[N+1][2];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tpos[id][0] = i; pos[id][1] = j;\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpos[N][0] = i; pos[N][1] = j;\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int i=0;i<=N;i++){\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\t\tSystem.out.print(\"Dir \"+k+\":\");\n//\t\t\t\t\tfor(int nv:adj[i][k])System.out.print(\" \"+nv);\n//\t\t\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tmem = new Map[REST+1][N+1];\n\t\t\tfor(int i=0;i<=REST;i++)for(int j=0;j<=N;j++)mem[i][j]=new HashMap<Integer, Integer>();\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tvisited = new boolean[N+1];\n//\t\t\tdfs(N, 0, true);\n\t\t\tSystem.out.println(dfs(N, 0, true, N));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, n;\n\tint[][] map;\n\tint goal = 25;\n\tint[][] dp;\n\tint[][] id;\n\tMap<Integer, Integer>[] m;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\n\tint get(int i, int j, int s){\n\t\tint v = id[i][j];\n//\t\tSystem.out.println(\"I:\" + i + \" J:\" + j + \" S:\" + s);\n\t\tif(s!=0&&v==goal){\n\t\t\t//\t\t\tSystem.out.println(\"I:\" + i + \" J:\" + j + \" S:\" + s + \" RES: \" + (s==(1<<n)-1?1:0));\n\t\t\treturn 1;\n\t\t}\n\t\tif(v!=goal&&m[v].containsKey(s))return m[v].get(s);\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++){\n//\t\t\tSystem.out.println(\"K:\" + k + \" RES:\" + res);\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\twhile(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\tif(map[ni][nj]!=-1){\n\t\t\t\t\tint u = map[ni][nj];\n\t\t\t\t\tif(u==goal){\n\t\t\t\t\t\tif(s==(1<<n)-1)res++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif((s&(1<<u))>0)break;\n\t\t\t\t\t\tres += get(ni, nj, s+(1<<u));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tni += move[k][0];\n\t\t\t\tnj += move[k][1];\n\t\t\t}\n\t\t}\n\t\tm[v].put(s, res);\n\t\treturn res;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tmap = new int[h][w];\n\t\t\tid = new int[h][w];\n\t\t\tn = 0;\n\t\t\tint si, sj;\n\t\t\tsi = sj = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t\tif(map[i][j]==0)map[i][j] = -1;\n\t\t\t\t\telse if(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j] = n;\n\t\t\t\t\t\tid[i][j] = n++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmap[i][j] = goal;\n\t\t\t\t\t\tid[i][j] = goal;\n\t\t\t\t\t\tsi = i;\n\t\t\t\t\t\tsj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm = new HashMap[goal+1];\n\t\t\tfor(int i=0;i<=goal;i++)m[i]=new HashMap<Integer, Integer>();\n\t\t\tSystem.out.println(get(si, sj, 0));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\tstatic P[][] f;\n\n\tstatic int dfs(P c, int d) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tP n = c.neib[i];\n\t\t\tP next = n;\n\t\t\tif (n.home) {\n\t\t\t\tif (d == 0) return 1;\n\t\t\t\tnext = n.neib[i];\n\t\t\t}\n\t\t\tif (next == NIL) continue;\n\t\t\tif (!c.home) {\n\t\t\t\tc.neib[(i + 2) % 4].neib[i] = c.neib[i];\n\t\t\t\tc.neib[i].neib[(i + 2) % 4] = c.neib[(i + 2) % 4];\n\t\t\t\tc.neib[(i + 1) % 4].neib[(i + 3) % 4] = c.neib[(i + 3) % 4];\n\t\t\t\tc.neib[(i + 3) % 4].neib[(i + 1) % 4] = c.neib[(i + 1) % 4];\n\t\t\t}\n\t\t\tret += dfs(next, d - 1);\n\t\t\tif (!c.home) {\n\t\t\t\tc.neib[(i + 2) % 4].neib[i] = c;\n\t\t\t\tc.neib[i].neib[(i + 2) % 4] = c;\n\t\t\t\tc.neib[(i + 1) % 4].neib[(i + 3) % 4] = c;\n\t\t\t\tc.neib[(i + 3) % 4].neib[(i + 1) % 4] = c;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tM = sc.nextInt();\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tf = new P[N][M];\n\t\t\tint d = 0;\n\t\t\tP start = null;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\t\tint v = sc.nextInt();\n\t\t\t\t\tif (v == 1) {\n\t\t\t\t\t\t++d;\n\t\t\t\t\t\tf[i][j] = new P();\n\t\t\t\t\t} else if (v == 2) {\n\t\t\t\t\t\tstart = f[i][j] = new P();\n\t\t\t\t\t\tstart.home = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\t\tif (f[i][j] != null) {\n\t\t\t\t\t\tfor (int k = i + 1; k < N; ++k) {\n\t\t\t\t\t\t\tif (f[k][j] != null) {\n\t\t\t\t\t\t\t\tf[i][j].neib[0] = f[k][j];\n\t\t\t\t\t\t\t\tf[k][j].neib[2] = f[i][j];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = j + 1; k < M; ++k) {\n\t\t\t\t\t\t\tif (f[i][k] != null) {\n\t\t\t\t\t\t\t\tf[i][j].neib[1] = f[i][k];\n\t\t\t\t\t\t\t\tf[i][k].neib[3] = f[i][j];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(start, d));\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tP[] neib = new P[4];\n\t\tboolean home;\n\n\t\tP() {\n\t\t\tArrays.fill(neib, NIL);\n\t\t}\n\n\t}\n\n\tstatic P NIL = new P();\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final Scanner S=new Scanner(System.in);\n\tprivate static final PrintStream O=System.out;\n\tprivate static final int H=1,K=2;\n\t\n\tprivate static class B {\n\t\tprivate final int i,j;\n\t\t\n\t\tprivate B(final int i, final int j) {\n\t\t\tthis.i=i;\n\t\t\tthis.j=j;\n\t\t}\n\t}\n\t\n\tprivate static class C {\n\t\tprivate final B h[],k;\n\t\tprivate final int m,n;\n\t\t\n\t\tprivate C(final B h[], final B k, final int m, final int n) {\n\t\t\tthis.h=h;\n\t\t\tthis.k=k;\n\t\t\tthis.m=m;\n\t\t\tthis.n=n;\n\t\t}\n\t\t\n\t\tprivate class S {\n\t\t\tprivate final B r;\n\t\t\tprivate final boolean sp[];\n\t\t\t\n\t\t\tprivate S(final B r, final boolean sp[]) {\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.sp=sp;\n\t\t\t}\n\t\t\t\n\t\t\tprivate int hn(final B b) {\n\t\t\t\tfor(int i=0;i<h.length;i++) if(b.i==h[i].i && b.j==h[i].j && sp[i]) return i;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tprivate static final int U=0,D=1,L=2,R=3;\n\t\t\tprivate boolean b(final int d, S ps[], int np) {\n\t\t\t\tB pr;\n\t\t\t\tint hn;\n\t\t\t\tif(d==U) {\n\t\t\t\t\tfor(int pi=r.i;(hn=hn(pr=new B(pi,r.j)))<0;pi--) if(pi<=0) return false;\n\t\t\t\t} else if(d==D) {\n\t\t\t\t\tfor(int pi=r.i;(hn=hn(pr=new B(pi,r.j)))<0;pi++) if(pi>=n-1) return false;\n\t\t\t\t} else if(d==L) {\n\t\t\t\t\tfor(int pj=r.j;(hn=hn(pr=new B(r.i,pj)))<0;pj--) if(pj<=0) return false;\n\t\t\t\t} else if(d==R) {\n\t\t\t\t\tfor(int pj=r.j;(hn=hn(pr=new B(r.i,pj)))<0;pj++) if(pj>=m-1) return false;\n\t\t\t\t} else return false;\n\t\t\t\tboolean psp[]=sp.clone();\n\t\t\t\tpsp[hn]=false;\n\t\t\t\tps[np]=new S(pr,psp);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean rk(final int d) {\n\t\t\t\tif(d==U) {\n\t\t\t\t\tfor(int pi=r.i;pi!=k.i || r.j!=k.j;pi--) if(pi<=0) return false;\n\t\t\t\t} else if(d==D) {\n\t\t\t\t\tfor(int pi=r.i;pi!=k.i || r.j!=k.j;pi++) if(pi>=n-1) return false;\n\t\t\t\t} else if(d==L) {\n\t\t\t\t\tfor(int pj=r.j;r.i!=k.i || pj!=k.j;pj--) if(pj<=0) return false;\n\t\t\t\t} else if(d==R) {\n\t\t\t\t\tfor(int pj=r.j;r.i!=k.i || pj!=k.j;pj++) if(pj>=m-1) return false;\n\t\t\t\t} else return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate int getp() {\n\t\t\tint nc=1;\n\t\t\tS cs[]=new S[nc];\n\t\t\tboolean sp[]=new boolean[h.length];\n\t\t\tfor(int i=0;i<sp.length;i++) sp[i]=true;\n\t\t\tcs[0]=new S(new B(k.i,k.j), sp);\n\t\t\tint ca[]=new int[cs.length];\n\t\t\tca[0]=1;\n\t\t\tfor(int i=0;i<h.length;i++) {\n\t\t\t\tlong s=System.currentTimeMillis();\n\t\t\t\tint np=0;\n\t\t\t\tS ps[]=new S[nc*4];\n\t\t\t\tint hc[]=new int[ps.length];\n\t\t\t\tint pa[]=new int[ps.length];\n\t\t\t\tfor(int j=0;j<nc;j++) for(int k=0;k<4;k++) if(cs[j].b(k, ps, np)) {\n\t\t\t\t\thc[np]=ps[np].hashCode();\n\t\t\t\t\tint l;\n\t\t\t\t\tfor(l=0;l<np;l++) if(hc[np]==hc[l]) {\n\t\t\t\t\t\tpa[l]+=ca[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l>=np) {\n\t\t\t\t\t\tpa[np]=ca[j];\n\t\t\t\t\t\tnp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tO.println(nc+\":\"+(System.currentTimeMillis()-s));\n\t\t\t\tnc=np;\n\t\t\t\tcs=ps;\n\t\t\t\tca=pa;\n\t\t\t}\n\t\t\tint a=0;\n\t\t\tfor(int i=0;i<nc;i++) for(int j=0;j<4;j++) if(cs[i].rk(j)) a+=ca[i];\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint m,n;\n\t\twhile((m=S.nextInt())!=0 && (n=S.nextInt())!=0) {\n\t\t\tB th[]=new B[23],k=null;\n\t\t\tint nh=0;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) {\n\t\t\t\tswitch(S.nextInt()) {\n\t\t\t\t\tcase K:\n\t\t\t\t\t\tk=new B(i,j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase H:\n\t\t\t\t\t\tth[nh++]=new B(i,j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tB h[]=new B[nh];\n\t\t\tfor(int i=0;i<h.length;i++) h[i]=th[i];\n\t\t\tif(k!=null) O.println(new C(h,k,m,n).getp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tY = new int[24];\n\t\t\tX = new int[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tY[h] = i;\n\t\t\t\t\t\tX[h] = j;\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tY[0] = i;\n\t\t\t\t\t\tX[0] = j;\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int mask) {\n\t\tif (Integer.bitCount(mask) >= 12) {\n\t\t\tint k = cur << 24 | mask;\n\t\t\tif (M.containsKey(k))\n\t\t\t\treturn M.get(k);\n\t\t}\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = Y[cur];\n\t\t\tint x = X[cur];\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (mask == (1 << h) - 1)\n\t\t\t\t\t\tres++;\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((mask >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], mask | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Integer.bitCount(mask) >= 12)\n\t\t\tM.put(cur << 24 | mask, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint m, n, h;\n\tint[] Y, X;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tint km(boolean[] a, int b) {\n\n\t\tint z = 0;\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\n\t\t\tz += a[i] ? 1 : 0;\n\n\t\t\tz *= 2;\n\n\t\t}\n\n\t\treturn z * 100 + b;\n\n\t}\n\n\n\n\tint rec(boolean[] used, int now, int count, int[][] map) {\n\n\t\tif (ht.containsKey(km(used, now))) {\n\n\t\t\treturn ht.get(km(used, now));\n\n\t\t}\n\n\t\tif (count == used.length - 1) {\n\n\t\t\tif (!list.get(now).reachable(list.get(0))){\n\n\t\t\t\tht.put(km(used, now),0);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tht.put(km(used, now),1);\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tint[] dx = { -1, 1, 0, 0 };\n\n\t\tint[] dy = { 0, 0, -1, 1 };\n\n\t\tb bnow = list.get(now);\n\n\t\tfor (int i = 0; i < 4; i++) {\n\n\t\t\tint x = bnow.j;\n\n\t\t\tint y = bnow.i;\n\n\t\t\tfor (;; x += dx[i], y += dy[i]) {\n\n\t\t\t\tif (y >= map.length || x >= map[0].length || x < 0 || y < 0) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (map[y][x] > 0) {\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"push\"+i);\n\n\t\t\t\t\tint q = map[y][x];\n\n\t\t\t\t\tused[q] = true;\n\n\t\t\t\t\tmap[y][x] = -1;\n\n\t\t\t\t\tsum += rec(used, q, count + 1, map);\n\n\t\t\t\t\tmap[y][x] = q;\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"pop\"+i);\n\n\t\t\t\t\tused[q] = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tht.put(km(used, now),sum);\n\n\t\treturn sum;\n\n\t}\n\n\n\n\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\tHashMap<Integer, Integer> ht = new HashMap<Integer, Integer>();\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tb start = null;\n\n\t\t\tlist.clear();\n\n\t\t\tht = new HashMap<Integer, Integer>();\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used, 0, 0, map));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tboolean and(int a,boolean[] b){\n\n\t\tfor(int i=0; i < b.length ; i++){\n\n\t\t\tif((1&(a>>i))==1 && b[i]) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t\n\n\tint rec(boolean[] used,int now, int count, boolean[][] reachableS,int[][] reachableP ){\n\n\t\tif(count == used.length){\n\n\t\t\tif(now != 0)\n\n\t\t\t\treturn 0;\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tfor(int i=0;i<used.length;i++){\n\n\t\t\tif(!used[i]){\n\n\t\t\t\tif (!reachableS[now][i])\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (and(reachableP[now][i] , used))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tused[i] = true;\n\n//\t\t\t\tSystem.out.printf(\"%x \",1<<(count*4));\n\n//\t\t\t\tSystem.out.println(\"push\"+i);\n\n\t\t\t\tsum += rec(used,i,count+1,reachableS,reachableP);\n\n//\t\t\t\tSystem.out.printf(\"%x \",1<<(count*4));\n\n//\t\t\t\tSystem.out.println(\"pop\"+i);\n\n\t\t\t\tused[i] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn sum;\n\n\t}\n\n\t\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\t\t\tb start = null;\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\t\t\tboolean[][] reachableS = new boolean[n][n];\n\n\t\t\tint[][] reachableP = new int[n][n];\n\n\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = j + 1; k < w; k++) {\n\n\t\t\t\t\t\t\tif (map[i][k] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[i][k];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[i][k]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = i + 1; k < h; k++) {\n\n\t\t\t\t\t\t\tif (map[k][j] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[k][j];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[k][j]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used,0,0,reachableS,reachableP));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint move[][] = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint w, h, n, gi, gj, G = -2;\n\tint[][] a;\n\tint res;\n\t\n\tvoid dfs(int state, int i, int j){\n//\t\tSystem.out.println(\"State:\"+state+\" \"+i+\",\"+j);\n\t\tif(state==(1<<n)-1){\n\t\t\tif(i==gi||j==gj)res++;\n\t\t\treturn;\n\t\t}\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0], nj = j+move[k][1];\n\t\t\twhile(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\tif(a[ni][nj]>=0){\n\t\t\t\t\tif(((state>>a[ni][nj])&1)==0){\n\t\t\t\t\t\tdfs(state+(1<<a[ni][nj]), ni, nj);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tni += move[k][0]; nj += move[k][1];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tn = 0;\n\t\t\ta = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\ta[i][j] = sc.nextInt();\n\t\t\t\tif(a[i][j]==1)a[i][j] = n++;\n\t\t\t\telse if(a[i][j]==2){\n\t\t\t\t\ta[i][j] = G; gi = i; gj = j;\n\t\t\t\t}\n\t\t\t\telse if(a[i][j]==0)a[i][j] = -1;\n\t\t\t}\n\t\t\tres = 0;\n\t\t\tdfs(0, gi, gj);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tY = new int[24];\n\t\t\tX = new int[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tY[h] = i;\n\t\t\t\t\t\tX[h] = j;\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tY[0] = i;\n\t\t\t\t\t\tX[0] = j;\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int bit) {\n\t\tint k = cur << 24 | bit;\n\t\tif (M.containsKey(k))\n\t\t\treturn M.get(k);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = Y[cur];\n\t\t\tint x = X[cur];\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (Integer.bitCount(bit)==h){\n\t\t\t\t\t\tres++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((bit >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], bit | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(cur << 24 | bit, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint m, n, h;\n\tint[] Y, X;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\tstatic int[][] f;\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\n\tstatic int dfs(int r, int c, int d) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint nr = r + DR[i];\n\t\t\tint nc = c + DC[i];\n\t\t\twhile (0 <= nr && nr < N && 0 <= nc && nc < M) {\n\t\t\t\tif (f[nr][nc] == 1) {\n\t\t\t\t\tf[nr][nc] = -1;\n\t\t\t\t\tret += dfs(nr, nc, d - 1);\n\t\t\t\t\tf[nr][nc] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (f[nr][nc] == 2 && d == 0) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tnr += DR[i];\n\t\t\t\tnc += DC[i];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tM = sc.nextInt();\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tf = new int[N][M];\n\t\t\tint d = 0;\n\t\t\tint r = 0;\n\t\t\tint c = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\t\tf[i][j] = sc.nextInt();\n\t\t\t\t\tif (f[i][j] == 1) ++d;\n\t\t\t\t\tif (f[i][j] == 2) {\n\t\t\t\t\t\tr = i;\n\t\t\t\t\t\tc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(r, c, d));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, res, GS;\n\tint[][] map, pos;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] deg;\n\tList<Integer>[][] adj;\n\tboolean[] visited;\n\t\n\tboolean check(int v){\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tif(visited[i]||i==v)continue;\n\t\t\tint c = 0;\n\t\t\tfor(int k=0;k<4;k++)for(int nv:adj[i][k]){\n\t\t\t\tif(visited[nv]){\n\t\t\t\t\tif(nv==v)c++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n//\t\t\tSystem.out.println(\"ID:\" +i+\" C:\"+c);\n\t\t\tif(i==N){\n\t\t\t\tif(c==0)return false;\n\t\t\t}\n\t\t\telse if(c<2)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid dfs(int v, int S, boolean head){\n//\t\tSystem.out.println(\"V:\"+v);\n//\t\tdebug(visited);\n\t\tif(!head&&v==N){\n\t\t\tres+=S==GS?1:0;\n\t\t\treturn;\n\t\t}\n\t\tif(!check(v)){\n//\t\t\tSystem.out.println(\"CHECK OUT\");\n\t\t\treturn;\n\t\t}\n//\t\tboolean ok = true;\n//\t\tif(v!=N){\n//\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\tif(adj[v][k].isEmpty())continue;\n//\t\t\t\tint nv = adj[v][k].get(0);\n//\t\t\t\tif(nv==N)continue;\n//\t\t\t\tif(--deg[nv]<=0&&!visited[nv])ok = false;\n//\t\t\t}\n//\t\t}\n//\t\tdebug(deg);\n//\t\tif(!ok){\n////\t\t\tSystem.out.println(\"BAD COND.!!\");\n//\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\tif(adj[v][k].isEmpty())continue;\n//\t\t\t\tint nv = adj[v][k].get(0);\n//\t\t\t\tif(nv==N)continue;\n//\t\t\t\tdeg[nv]++;\n//\t\t\t}\n//\t\t\treturn;\n//\t\t}\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(visited[nv])break;\n\t\t\tvisited[nv] = true;\n\t\t\tdfs(nv, S+(1<<nv), false);\n\t\t\tvisited[nv] = false;\n\t\t}\n//\t\tfor(int k=0;k<4;k++){\n//\t\t\tif(adj[v][k].isEmpty())continue;\n//\t\t\tint nv = adj[v][k].get(0);\n//\t\t\tif(nv==N)continue;\n//\t\t\tdeg[nv]++;\n//\t\t}\n\t\treturn;\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tpos = new int[N+1][2];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tpos[id][0] = i; pos[id][1] = j;\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpos[N][0] = i; pos[N][1] = j;\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n//\t\t\tdeg = new int[N+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n//\t\t\t\t\tdeg[map[i][j]]+=adj[map[i][j]][k].isEmpty()?0:1;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdebug(deg);\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int j=0;j<w;j++)System.out.printf(\"%3d\", map[i][j]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tfor(int i=0;i<=N;i++){\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\t\tSystem.out.print(\"Dir \"+k+\":\");\n//\t\t\t\t\tfor(int nv:adj[i][k])System.out.print(\" \"+nv);\n//\t\t\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tres = 0;\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tvisited = new boolean[N+1];\n\t\t\tdfs(N, 0, true);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\n\tstatic int w,h,si,sj,n;\n\tstatic int[][] table,hs;\n\tstatic int[][] dp;\n\n\tstatic boolean solve() {\n\t\tw = in.nextInt();\n\t\th = in.nextInt();\n\t\tif (w == 0 && h == 0) return false;\n\t\ttable = new int[h][w];\n\n\t\tsi = -1; sj = -1;\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tint tmp = in.nextInt();\n\t\t\t\ttable[i][j] = -1;\n\t\t\t\tif (tmp == 1) {\n\t\t\t\t\ttable[i][j] = list.size();\n\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t} else {\n\t\t\t\t\tsi = i; sj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tn = list.size();\n\t\ths = new int[n][2];\n\t\tfor (int i=0; i<n; i++) {\n\t\t\ths[i] = list.get(i);\n\t\t}\n\n\t\tdp = new int[1<<n][n];\n\t\tfor (int i=0; i<1<<n; i++) {\n\t\t\tArrays.fill(dp[i],-1);\n\t\t}\n\n\t\tout.println(rec(0,si,sj));\n\t\treturn true;\n\t}\n\n\tstatic int rec(int visited, int ci, int cj) {\n\t\tint cur = table[ci][cj];\n\t\tif (cur >= 0 && dp[visited][cur] != -1) return dp[visited][cur];\n\t\tif (Integer.bitCount(visited) == n) {\n\t\t\treturn check(visited, ci, cj, si, sj) ? 1 : 0;\n\t\t}\n\n\t\tint res = 0;\n\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint ni = hs[i][0], nj = hs[i][1];\n\t\t\tif (((visited>>i)&1) == 1) continue;\n\t\t\tif (check(visited, ci, cj, ni, nj)) {\n\t\t\t\tres += rec(((1<<i)|visited), ni, nj);\n\t\t\t}\n\t\t}\n\n\t\treturn cur >= 0 ? dp[visited][cur] = res : res;\n\t}\n\n\tstatic boolean check(int visited, int ci, int cj, int ti, int tj) {\n\t\tif (ci != ti && cj != tj) return false;\n\t\tif (ci == ti) {\n\t\t\tint from = Math.min(cj,tj);\n\t\t\tint to = Math.max(cj,tj);\n\t\t\tfor (int j=from+1; j<to; j++) {\n\t\t\t\tif (table[ci][j] >= 0 && ((visited>>table[ci][j])&1) == 1) return false;\n\t\t\t}\n\t\t} else if (cj == tj) {\n\t\t\tint from = Math.min(ci,ti);\n\t\t\tint to = Math.max(ci,ti);\n\t\t\tfor (int i=from+1; i<to; i++) {\n\t\t\t\tif (table[i][cj] >= 0 && ((visited>>table[i][cj])&1) == 1) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\t//trace(end-start + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final Scanner S=new Scanner(System.in);\n\tprivate static final PrintStream O=System.out;\n\tprivate static final int H=1,K=2;\n\tprivate static final int U=0,D=1,L=2,R=3;\n\t\n\tprivate static class B {\n\t\tprivate final int i,j;\n\t\t\n\t\tprivate B(final int i, final int j) {\n\t\t\tthis.i=i;\n\t\t\tthis.j=j;\n\t\t}\n\t}\n\t\n\tprivate static class C {\n\t\tprivate final int nh,bh[][][],nbh[][];\n\t\t\n\t\tprivate C(final B h[], final int m, final int n) {\n\t\t\tint nh=h.length;\n\t\t\tbh=new int[nh][4][nh];\n\t\t\tnbh=new int[nh][4];\n\t\t\tfor(int i=0;i<4;i++) for(int j=0;j<nh;j++) nbh[j][i]=0;\n\t\t\tfor(int i=0;i<nh;i++) for(int j=0;j<nh;j++) {\n\t\t\t\tif(i==j) continue;\n\t\t\t\tif(h[i].i==h[j].i) {\n\t\t\t\t\tif(h[i].j<h[j].j) bh[j][L][nbh[j][L]++]=i;\n\t\t\t\t\telse bh[j][R][nbh[j][R]++]=i;\n\t\t\t\t} else if(h[j].j==h[i].j) {\n\t\t\t\t\tif(h[i].i<h[j].i) bh[j][U][nbh[j][U]++]=i;\n\t\t\t\t\telse bh[j][D][nbh[j][D]++]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.nh=nh-1;\n\t\t}\n\t\t\n\t\tprivate class S {\n\t\t\tprivate final int r;\n\t\t\tprivate final boolean sp[];\n\t\t\t\n\t\t\tprivate S(final int r, final boolean sp[]) {\n\t\t\t\tthis.r=r;\n\t\t\t\tthis.sp=sp;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean b(final int d, S ps[], int np) {\n\t\t\t\tint pr=0;\n\t\t\t\tboolean f=false;\n\t\t\t\tif(d==D || d==R) {\n\t\t\t\t\tfor(int i=0;i<nbh[r][d];i++) if(sp[(pr=bh[r][d][i])]) {\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if(d==U || d==L) {\n\t\t\t\t\tfor(int i=nbh[r][d]-1;i>=0;i--) if(sp[(pr=bh[r][d][i])]) {\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f) {\n\t\t\t\t\tboolean psp[]=sp.clone();\n\t\t\t\t\tpsp[pr]=false;\n\t\t\t\t\tps[np]=new S(pr,psp);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean tumi() {\n\t\t\t\tfor(int i=0;i<nh;i++) if(sp[i] && tumih(i)) return true;\n\t\t\t\tif(tumik()) return true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean tumih(final int i) {\n\t\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<nbh[i][j];k++) if(sp[bh[i][j][k]] || bh[i][j][k]==r) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean tumik() {\n\t\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<nbh[nh][j];k++) if(sp[bh[nh][j][k]]) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tprivate boolean tumi2() {\n\t\t\t\tfor(int j=0;j<4;j++) for(int k=0;k<nbh[nh][j];k++) if(bh[nh][j][k]==r) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate int getp() {\n\t\t\tint nc=1;\n\t\t\tS cs[]=new S[nc];\n\t\t\tboolean sp[]=new boolean[nh+1];\n\t\t\tfor(int i=0;i<nh;i++) sp[i]=true;\n\t\t\tsp[nh]=false;\n\t\t\tcs[0]=new S(nh, sp);\n\t\t\tint ca[]=new int[cs.length];\n\t\t\tca[0]=1;\n\t\t\tfor(int i=0;i<nh;i++) {\n\t\t\t\tint np=0;\n\t\t\t\tS ps[]=new S[nc*4];\n\t\t\t\tint pa[]=new int[ps.length];\n\t\t\t\tfor(int j=0;j<nc;j++) for(int k=0;k<4;k++) if(cs[j].b(k, ps, np)) {\n\t\t\t\t\tif(i<nh-1 && ps[np].tumi()) continue;\n\t\t\t\t\tif(i>=nh-1 && ps[np].tumi2()) continue;\n\t\t\t\t\tpa[np]=ca[j];\n\t\t\t\t\tnp++;\n\t\t\t\t}\n\t\t\t\tnc=np;\n\t\t\t\tcs=ps;\n\t\t\t\tca=pa;\n\t\t\t}\n\t\t\tint a=0;\n\t\t\tfor(int i=0;i<nc;i++) a+=ca[i];\n\t\t\treturn a;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint m,n;\n\t\twhile((m=S.nextInt())!=0 && (n=S.nextInt())!=0) {\n\t\t\tB th[]=new B[23],k=null;\n\t\t\tint nh=0;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) {\n\t\t\t\tswitch(S.nextInt()) {\n\t\t\t\t\tcase K:\n\t\t\t\t\t\tk=new B(i,j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase H:\n\t\t\t\t\t\tth[nh++]=new B(i,j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tB h[]=new B[nh+1];\n\t\t\tfor(int i=0;i<nh;i++) h[i]=th[i];\n\t\t\th[nh]=k;\n\t\t\tO.println(new C(h,m,n).getp());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tY = new int[24];\n\t\t\tX = new int[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tY[h] = i;\n\t\t\t\t\t\tX[h] = j;\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tY[0] = i;\n\t\t\t\t\t\tX[0] = j;\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int mask) {\n\t\tint k = cur << 24 | mask;\n\t\tif (M.containsKey(k))\n\t\t\treturn M.get(k);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = Y[cur];\n\t\t\tint x = X[cur];\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (mask == (1 << h) - 1)\n\t\t\t\t\t\tres++;\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((mask >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], mask | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(cur << 24 | mask, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint m, n, h;\n\tint[] Y, X;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tString km(boolean[] a, int b) {\n\n\t\tint z = 0;\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\n\t\t\tz += a[i] ? 1 : 0;\n\n\t\t\tz *= 2;\n\n\t\t}\n\n\t\treturn z * 100 + b + \"\";\n\n\t}\n\n\n\n\tint rec(boolean[] used, int now, int count, int[][] map) {\n\n\t\tif (ht.containsKey(km(used, now))) {\n\n\t\t\treturn ht.get(km(used, now));\n\n\t\t}\n\n\t\tif (count == used.length - 1) {\n\n\t\t\tif (!list.get(now).reachable(list.get(0))){\n\n\t\t\t\tht.put(km(used, now),0);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tht.put(km(used, now),1);\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tint[] dx = { -1, 1, 0, 0 };\n\n\t\tint[] dy = { 0, 0, -1, 1 };\n\n\t\tb bnow = list.get(now);\n\n\t\tfor (int i = 0; i < 4; i++) {\n\n\t\t\tint x = bnow.j;\n\n\t\t\tint y = bnow.i;\n\n\t\t\tfor (;; x += dx[i], y += dy[i]) {\n\n\t\t\t\tif (y >= map.length || x >= map[0].length || x < 0 || y < 0) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (map[y][x] > 0) {\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"push\"+i);\n\n\t\t\t\t\tint q = map[y][x];\n\n\t\t\t\t\tused[q] = true;\n\n\t\t\t\t\tmap[y][x] = -1;\n\n\t\t\t\t\tsum += rec(used, q, count + 1, map);\n\n\t\t\t\t\tmap[y][x] = q;\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"pop\"+i);\n\n\t\t\t\t\tused[q] = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tht.put(km(used, now),sum);\n\n\t\treturn sum;\n\n\t}\n\n\n\n\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\tHashMap<String, Integer> ht = new HashMap<String, Integer>();\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tb start = null;\n\n\t\t\tlist.clear();\n\n\t\t\tht = new HashMap<String, Integer>();\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used, 0, 0, map));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tclass R{\n\t\tint id, S;\n\t\tpublic R(int id, int s) {\n\t\t\tthis.id = id;\n\t\t\tS = s;\n\t\t}\n\t}\n\n\tint n, NS, c;\n\tList<R>[] l;\n\tMap<Integer, Integer>[] mem;\n\n\tint dfs(int k, int S){\n//\t\tSystem.out.println(\"C:\"+(c++));\n//\t\tSystem.out.println(\"k:\"+k+\" S:\"+S);\n\t\tif(mem[k].containsKey(S))return mem[k].get(S);\n\t\tif(k==n){\n\t\t\treturn S==(1<<(n+1))-1?1:0;\n\t\t}\n\t\tif(S!=(1<<n)-1&&(S&NS)==NS)return 0;\n\t\tint res = 0;\n\t\tfor(R r:l[k]){\n\t\t\tif((r.S&S)==0)res += dfs(r.id, S+(1<<r.id));\n\t\t}\n\t\tmem[k].put(S, res);\n\t\treturn res;\n\t}\n\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif((h|w)==0)break;\n\t\t\tint[][] map = new int[h][w];\n\t\t\tn = 0;\n\t\t\tint si = 0, sj = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==0)map[i][j]=-1;\n\t\t\t\telse if(map[i][j]==1)map[i][j]=n++;\n\t\t\t\telse {\n\t\t\t\t\tsi = i; sj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap[si][sj] = n;\n\t\t\tNS = 0;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint pi = si, pj = sj;\n\t\t\t\tfor(;;){\n\t\t\t\t\tpi += d[k][0]; pj += d[k][1];\n\t\t\t\t\tif(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1){\n\t\t\t\t\t\t\tNS += 1<<map[pi][pj]; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdebug(map);\n//\t\t\tSystem.out.println(\"NS:\"+NS);\n\t\t\tl = new List[n+1];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tint x = map[i][j];\n\t\t\t\tl[x] = new ArrayList<R>();\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i, pj = j, S = 0;\n\t\t\t\t\tfor(;;){\n\t\t\t\t\t\tpi += d[k][0]; pj += d[k][1];\n\t\t\t\t\t\tif(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\t\tint nx = map[pi][pj];\n\t\t\t\t\t\t\tif(0<=nx&&nx<n)S+=1<<nx;\n\t\t\t\t\t\t\tif(nx!=-1)l[x].add(new R(nx, S));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"ID:\"+x+\" L:\"+l[x].size());\n//\t\t\t\tfor(R r:l[x]){\n//\t\t\t\t\tSystem.out.println(\"Next:\"+r.id+\" S:\"+r.S);\n//\t\t\t\t}\n\t\t\t}\n\t\t\tmem = new Map[n+1];\n\t\t\tfor(int i=0;i<=n;i++)mem[i] = new HashMap<Integer, Integer>();\n\t\t\tint res = 0;\n//\t\t\tc = 0;\n\t\t\tfor(R r:l[n]){\n//\t\t\t\tSystem.out.println(\"RID:\"+r.id);\n\t\t\t\tres += dfs(r.id, 1<<r.id);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>(1000000);\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tpairs = new Pair[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tpairs[h] = new Pair(i, j);\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpairs[0] = new Pair(i, j);\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int bit) {\n\t\tint k = cur << 24 | bit;\n\t\tif (M.containsKey(k))\n\t\t\treturn M.get(k);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = pairs[cur].y;\n\t\t\tint x = pairs[cur].x;\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (Integer.bitCount(bit) == h) {\n\t\t\t\t\t\treturn res + 1;\n\t\t\t\t\t}\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((bit >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], bit | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(k, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tclass Pair{\n\t\tint y,x;\n\n\t\tpublic Pair(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\t\t\n\t}\n\n\tint m, n, h;\n\tPair[] pairs;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime(), stopCpuTime = 0;\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0545-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint m = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tif (m == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(m, n);\n\t\t\tfor (int y = 0; y < n; y++)\n\t\t\t\tfor (int x = 0; x < m; x++)\n\t\t\t\t\tmp.add(x, y, scan.nextInt());\n\t\t\tSystem.out.println(mp.count());\n\t\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\t}\n\n\t\tscan.close();\n\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t// System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tint[][] mp;\n\tboolean[][] flg;\n\tint stx = -1, sty = -1;\n\tint cnt = 0;\n\n\tpublic Map(int m, int n) {\n\t\tmp = new int[m][n];\n\t\tflg = new boolean[m][n];\n\t}\n\n\tpublic int count() {\n\t\treturn search(stx, sty, cnt);\n\t}\n\n\tprivate int search(int x, int y, int c) {\n\t\tif (c == 0)\n\t\t\tif (isReach(x, y, stx, sty))\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\n\t\tint ret = 0;\n\t\tfor (int i = x + 1; i < flg.length; i++)\n\t\t\tif (flg[i][y]) {\n\t\t\t\tflg[i][y] = false;\n\t\t\t\tret += search(i, y, c - 1);\n\t\t\t\tflg[i][y] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor (int i = x - 1; i >= 0; i--)\n\t\t\tif (flg[i][y]) {\n\t\t\t\tflg[i][y] = false;\n\t\t\t\tret += search(i, y, c - 1);\n\t\t\t\tflg[i][y] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor (int i = y + 1; i < flg[0].length; i++)\n\t\t\tif (flg[x][i]) {\n\t\t\t\tflg[x][i] = false;\n\t\t\t\tret += search(x, i, c - 1);\n\t\t\t\tflg[x][i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor (int i = y - 1; i >= 0; i--)\n\t\t\tif (flg[x][i]) {\n\t\t\t\tflg[x][i] = false;\n\t\t\t\tret += search(x, i, c - 1);\n\t\t\t\tflg[x][i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate boolean isReach(int x, int y, int x2, int y2) {\n\t\tif (x == x2) {\n\t\t\tfor (int i = y + 1; i <= y2; i++)\n\t\t\t\tif (i == y2)\n\t\t\t\t\treturn true;\n\t\t\tfor (int i = y - 1; i >= y2; i--)\n\t\t\t\tif (i == y2)\n\t\t\t\t\treturn true;\n\t\t}\n\t\tif (y == y2) {\n\t\t\tfor (int i = x + 1; i <= x2; i++)\n\t\t\t\tif (i == x2)\n\t\t\t\t\treturn true;\n\t\t\tfor (int i = x - 1; i >= x2; i--)\n\t\t\t\tif (i == x2)\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void add(int x, int y, int s) {\n\t\tmp[x][y] = s;\n\t\tif (s == 2) {\n\t\t\tstx = x;\n\t\t\tsty = y;\n\t\t}\n\t\tif (s == 1) {\n\t\t\tcnt++;\n\t\t\tflg[x][y] = true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tint km(boolean[] a, int b) {\n\n\t\tint z = 0;\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\n\t\t\tz += a[i] ? 1 : 0;\n\n\t\t\tz *= 2;\n\n\t\t}\n\n\t\treturn z * 100 + b;\n\n\t}\n\n\n\n\tint rec(boolean[] used, int now, int count, int[][] map) {\n\n\t\tif (ht.containsKey(km(used, now))) {\n\n\t\t\treturn ht.get(km(used, now));\n\n\t\t}\n\n\t\tif (count == used.length - 1) {\n\n\t\t\tif (!list.get(now).reachable(list.get(0))){\n\n//\t\t\t\tht.put(km(used, now),0);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n//\t\t\tht.put(km(used, now),1);\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tint[] dx = { -1, 1, 0, 0 };\n\n\t\tint[] dy = { 0, 0, -1, 1 };\n\n\t\tb bnow = list.get(now);\n\n\t\tfor (int i = 0; i < 4; i++) {\n\n\t\t\tint x = bnow.j;\n\n\t\t\tint y = bnow.i;\n\n\t\t\tfor (;; x += dx[i], y += dy[i]) {\n\n\t\t\t\tif (y >= map.length || x >= map[0].length || x < 0 || y < 0) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (map[y][x] > 0) {\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"push\"+i);\n\n\t\t\t\t\tint q = map[y][x];\n\n\t\t\t\t\tused[q] = true;\n\n\t\t\t\t\tmap[y][x] = -1;\n\n\t\t\t\t\tsum += rec(used, q, count + 1, map);\n\n\t\t\t\t\tmap[y][x] = q;\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"pop\"+i);\n\n\t\t\t\t\tused[q] = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tht.put(km(used, now),sum);\n\n\t\treturn sum;\n\n\t}\n\n\n\n\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\tHashMap<Integer, Integer> ht = new HashMap<Integer, Integer>();\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tb start = null;\n\n\t\t\tlist.clear();\n\n\t\t\tht = new HashMap<Integer, Integer>();\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used, 0, 0, map));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tY = new int[24];\n\t\t\tX = new int[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tY[h] = i;\n\t\t\t\t\t\tX[h] = j;\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tY[0] = i;\n\t\t\t\t\t\tX[0] = j;\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int bit) {\n\t\tint k = cur << 24 | bit;\n\t\tif (M.containsKey(k))\n\t\t\treturn M.get(k);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = Y[cur];\n\t\t\tint x = X[cur];\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (Integer.bitCount(bit)==h)\n\t\t\t\t\t\tres++;\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((bit >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], bit | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(cur << 24 | bit, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint m, n, h;\n\tint[] Y, X;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\tstatic P[][] f;\n\n\tstatic int dfs(P c, int d) {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tP n = c.neib[i];\n\t\t\tif (n == NIL) continue;\n\t\t\tif (n.home) {\n\t\t\t\tif (d == 0) return 1;\n\t\t\t} else {\n\t\t\t\tif (!c.home) {\n\t\t\t\t\tc.neib[(i + 2) % 4].neib[i] = c.neib[i];\n\t\t\t\t\tc.neib[i].neib[(i + 2) % 4] = c.neib[(i + 2) % 4];\n\t\t\t\t\tc.neib[(i + 1) % 4].neib[(i + 3) % 4] = c.neib[(i + 3) % 4];\n\t\t\t\t\tc.neib[(i + 3) % 4].neib[(i + 1) % 4] = c.neib[(i + 1) % 4];\n\t\t\t\t}\n\t\t\t\tret += dfs(n, d - 1);\n\t\t\t\tif (!c.home) {\n\t\t\t\t\tc.neib[(i + 2) % 4].neib[i] = c;\n\t\t\t\t\tc.neib[i].neib[(i + 2) % 4] = c;\n\t\t\t\t\tc.neib[(i + 1) % 4].neib[(i + 3) % 4] = c;\n\t\t\t\t\tc.neib[(i + 3) % 4].neib[(i + 1) % 4] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tM = sc.nextInt();\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tf = new P[N][M];\n\t\t\tint d = 0;\n\t\t\tP start = null;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\t\tint v = sc.nextInt();\n\t\t\t\t\tif (v == 1) {\n\t\t\t\t\t\t++d;\n\t\t\t\t\t\tf[i][j] = new P();\n\t\t\t\t\t} else if (v == 2) {\n\t\t\t\t\t\tstart = f[i][j] = new P();\n\t\t\t\t\t\tstart.home = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\t\tif (f[i][j] != null) {\n\t\t\t\t\t\tfor (int k = i + 1; k < N; ++k) {\n\t\t\t\t\t\t\tif (f[k][j] != null) {\n\t\t\t\t\t\t\t\tf[i][j].neib[0] = f[k][j];\n\t\t\t\t\t\t\t\tf[k][j].neib[2] = f[i][j];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = j + 1; k < M; ++k) {\n\t\t\t\t\t\t\tif (f[i][k] != null) {\n\t\t\t\t\t\t\t\tf[i][j].neib[1] = f[i][k];\n\t\t\t\t\t\t\t\tf[i][k].neib[3] = f[i][j];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\t\tif (f[i][j] != null) {\n\t\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\t\tif (k != i && f[k][j] != null) {\n\t\t\t\t\t\t\t\tf[i][j].c++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = 0; k < M; ++k) {\n\t\t\t\t\t\t\tif (k != j && f[i][k] != null) {\n\t\t\t\t\t\t\t\tf[i][j].c++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(dfs(start, d));\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tP[] neib = new P[4];\n\t\tboolean home;\n\t\tint c;\n\n\t\tP() {\n\t\t\tArrays.fill(neib, NIL);\n\t\t}\n\n\t}\n\n\tstatic P NIL = new P();\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tY = new int[24];\n\t\t\tX = new int[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tY[h] = i;\n\t\t\t\t\t\tX[h] = j;\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tY[0] = i;\n\t\t\t\t\t\tX[0] = j;\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int bit) {\n\t\tif (Integer.bitCount(bit) <= 15) {\n\t\t\tint k = cur << 24 | bit;\n\t\t\tif (M.containsKey(k))\n\t\t\t\treturn M.get(k);\n\t\t}\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = Y[cur];\n\t\t\tint x = X[cur];\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (bit == (1 << h) - 1)\n\t\t\t\t\t\tres++;\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((bit >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], bit | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Integer.bitCount(bit) <= 15)\n\t\t\tM.put(cur << 24 | bit, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint m, n, h;\n\tint[] Y, X;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Integer, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tY = new int[24];\n\t\t\tX = new int[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tY[h] = i;\n\t\t\t\t\t\tX[h] = j;\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tY[0] = i;\n\t\t\t\t\t\tX[0] = j;\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int bit) {\n\t\tint k = cur << 24 | bit;\n\t\tif (M.containsKey(k))\n\t\t\treturn M.get(k);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = Y[cur];\n\t\t\tint x = X[cur];\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (Integer.bitCount(bit) == h) {\n\t\t\t\t\t\treturn res + 1;\n\t\t\t\t\t}\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((bit >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], bit | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(cur << 24 | bit, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint m, n, h;\n\tint[] Y, X;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Integer, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\t\t\tb start = null;\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\t\t\tlong dp[][] = new long[1 << n][n];\n\n\t\t\tboolean[][] reachableS = new boolean[n][n];\n\n\t\t\tint[][] reachableP = new int[n][n];\n\n\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = j + 1; k < w; k++) {\n\n\t\t\t\t\t\t\tif (map[i][k] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[i][k];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[i][k]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = i + 1; k < h; k++) {\n\n\t\t\t\t\t\t\tif (map[k][j] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[k][j];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[k][j]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tdp[0][0] = 1;\n\n\t\t\tfor (int i = 0; i < 1 << n; i++) {\n\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\n\t\t\t\t\tint sh = (1 << j);\n\n\t\t\t\t\tif ((i & sh) == 0)\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint sum = 0;\n\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\n\t\t\t\t\t\t// System.out.println(i+\" \"+(i^sh)+\" \"+j+\" ,\"+k+\" reachable = \"+reachable[j][k]+\" \"+dp[i^sh][k]);\n\n\t\t\t\t\t\tif (!reachableS[j][k])\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif ((reachableP[j][k] & i) != 0)\n\n\t\t\t\t\t\t\tcontinue;\n\n\n\n\t\t\t\t\t\tsum += dp[i ^ sh][k];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[i][j] = sum;\n\n\t\t\t\t}\n\n\t\t\t\t// System.out.printf(\"%o\"+Arrays.toString(dp[i])+\"\\n\",i);\n\n\t\t\t}\n\n\n\n\t\t\tSystem.out.println(dp[(1 << n) - 1][0]);\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\n\tstatic int w,h,si,sj,n;\n\tstatic int[][] table;\n\tstatic int[][] dp;\n\n\tstatic boolean solve() {\n\t\tw = in.nextInt();\n\t\th = in.nextInt();\n\t\tif (w == 0 && h == 0) return false;\n\t\ttable = new int[h][w];\n\n\t\tsi = -1; sj = -1;\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tint tmp = in.nextInt();\n\t\t\t\ttable[i][j] = -1;\n\t\t\t\tif (tmp == 1) {\n\t\t\t\t\ttable[i][j] = list.size();\n\t\t\t\t\tlist.add(new int[]{i,j});\n\t\t\t\t} else {\n\t\t\t\t\tsi = i; sj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tn = list.size();\n\n\t\tdp = new int[1<<n][n];\n\t\tfor (int i=0; i<1<<n; i++) {\n\t\t\tArrays.fill(dp[i],-1);\n\t\t}\n\n\t\tout.println(rec(0,si,sj));\n\t\treturn true;\n\t}\n\n\tstatic int[] di = {0,1,0,-1};\n\tstatic int[] dj = {1,0,-1,0};\n\n\tstatic int rec(int visited, int ci, int cj) {\n\t\tint cur = table[ci][cj];\n\t\tif (cur >= 0 && dp[visited][cur] != -1) return dp[visited][cur];\n\t\tif (Integer.bitCount(visited) == n) {\n\t\t\treturn check(visited, ci, cj, si, sj) ? 1 : 0;\n\t\t}\n\n\t\tint res = 0;\n\n\t\tfor (int k=0; k<4; k++) {\n\t\t\tint ni = ci + di[k];\n\t\t\tint nj = cj + dj[k];\n\t\t\twhile (0 <= ni && 0 <= nj && ni < h && nj < w) {\n\t\t\t\tif (table[ni][nj] >= 0) {\n\t\t\t\t\tif (((visited>>table[ni][nj])&1) == 0) res += rec(((1<<table[ni][nj])|visited), ni, nj);\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tni += di[k];\n\t\t\t\tnj += dj[k];\n\t\t\t}\n\t\t}\n\n\t\treturn cur >= 0 ? dp[visited][cur] = res : res;\n\t}\n\n\tstatic boolean check(int visited, int ci, int cj, int ti, int tj) {\n\t\tif (ci != ti && cj != tj) return false;\n\t\tif (ci == ti) {\n\t\t\tint from = Math.min(cj,tj);\n\t\t\tint to = Math.max(cj,tj);\n\t\t\tfor (int j=from+1; j<to; j++) {\n\t\t\t\tif (table[ci][j] >= 0 && ((visited>>table[ci][j])&1) == 1) return false;\n\t\t\t}\n\t\t} else if (cj == tj) {\n\t\t\tint from = Math.min(ci,ti);\n\t\t\tint to = Math.max(ci,ti);\n\t\t\tfor (int i=from+1; i<to; i++) {\n\t\t\t\tif (table[i][cj] >= 0 && ((visited>>table[i][cj])&1) == 1) return false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\t//trace(end-start + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n, m;\n\tint[][] map;\n\tint[][] mem;\n\tint size;\n\tint sg;\n\tint[] nodes;\n\tHashMap<Integer, Integer> node_ind;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif( (m|n) == 0 ) break;\n\t\t\tmap = new int[n][m];\n\t\t\tsize = 0;\n\t\t\tnode_ind = new HashMap<Integer, Integer>();\n\t\t\tLinkedList<Integer> tmp = new LinkedList<Integer>();\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) {\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif( map[i][j] == 1 ) {\n\t\t\t\t\tnode_ind.put(p2int(j, i), size);\n\t\t\t\t\ttmp.add(p2int(j, i));\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\t\t\t\tif( map[i][j] == 2 ) sg = p2int(j, i);\n\t\t\t}\n\t\t\t\n\t\t\tnodes = new int[size+1];\n\t\t\tfor(int i=0;i<size;i++) nodes[i] = tmp.removeFirst();\n\t\t\tnodes[size] = sg;\n\t\t\tmem = new int[size+1][1<<size];\n\t\t\tfor(int[] a: mem) fill(a, -1);\n\t\t\t\n//\t\t\tdebug(nodes);\n//\t\t\tdebug(size, sg);\n\t\t\tSystem.out.println(solve(size, (1<<size)-1));\n\t\t\t\n\t\t}\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tint solve(int i, int S) {\n//\t\tdebug(i, S);\n\t\tif( mem[i][S] >= 0 ) return mem[i][S];\n\t\t\n\t\tint[] p = int2p(nodes[i]);\n\t\t\n\t\tif( S == 0 ) {\n\t\t\tfor(int j=0;j<4;j++) for(int k=1;;k++) {\n\t\t\t\tif(!allow(p[0]+dx[j]*k, p[1]+dy[j]*k)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(map[p[1]+dy[j]*k][p[0]+dx[j]*k] == 3)\n\t\t\t\t\tbreak;\n\t\t\t\tif(map[p[1]+dy[j]*k][p[0]+dx[j]*k] == 2)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint cnt = 0;\n\t\t\n\t\tfor(int j=0;j<4;j++) for(int k=1;;k++) {\n\t\t\tif(!allow(p[0]+dx[j]*k, p[1]+dy[j]*k)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(map[p[1]+dy[j]*k][p[0]+dx[j]*k] == 3)\n\t\t\t\tbreak;\n\t\t\tif(map[p[1]+dy[j]*k][p[0]+dx[j]*k] == 1) {\n\t\t\t\tint pp = p2int( p[0]+dx[j]*k, p[1]+dy[j]*k );\n\t\t\t\tint ind = node_ind.get(pp);\n\t\t\t\tmap[p[1]+dy[j]*k][p[0]+dx[j]*k] = 3;\n\t\t\t\tcnt += solve(ind, S - (1<<ind));\n\t\t\t\tmap[p[1]+dy[j]*k][p[0]+dx[j]*k] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn mem[i][S] = cnt;\n\t}\n\t\n\tint p2int(int x, int y) {\n\t\treturn x*100 + y;\n\t}\n\tint[] int2p(int val) {\n\t\tint[] p = new int[2];\n\t\tp[0] = val/100;\n\t\tp[1] = val-p[0]*100;\n\t\treturn p;\n\t}\n\t\n\tboolean allow(int x, int y) {\n\t\treturn !( x<0 || y<0 || x>=m || y>= n );\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include <math.h>\n#include <utility>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n \nint m;\nint n;\nint map[10][10] = {0};\nint cnt = 0;\nint churchx;\nint churchy;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n \nint saiki( int xinput, int yinput, int nokori ) {\n    for ( int i = 0; i < 4; i++ ) {\n        int x = xinput;\n        int y = yinput;\n        if ( nokori == 0 ) {\n            if ( y == churchy && x > churchx && i != 0 ) continue;\n            if ( y == churchy && x < churchx && i != 1 ) continue;\n            if ( x == churchx && y > churchy && i != 2 ) continue;\n            if ( x == churchx && y < churchy && i != 3 ) continue;\n        }\n\t\n        while(true) {\n            x += dx[i];\n            y += dy[i];\n            if ( x < 0 || x >= m || y < 0 || y >= n ) break;\n            \n\t    if (map[x][y] == 1){\n                map[x][y] = 3;\n                saiki(x, y, nokori-1);\n                map[x][y] = 1;\n\t\tbreak;\n            }else if(map[x][y] == 2 ){\n                if(nokori == 0){\n                    cnt++;\n                    return 0;\n                }\n            }\n        }\n    }\n    return 0;\n}\n \nint main(){\n    while(true) {\n        cin >> m;\n        cin >> n;\n        if ( m == 0 ) break;\n        int nokori = 0;\n        for ( int i = 0; i < n; i++ ) {\n            for ( int j = 0; j < m; j++ ) {\n                cin >> map[j][i];\n\t\t//unvisited\n                if ( map[j][i] == 1 ) {\n                    nokori++;\n\t\t    \n\t\t//is_church\n                }else if(map[j][i] == 2) {\n                    churchx = j;\n                    churchy = i;\n                }\n            }\n        }\n\t\n\tcnt = 0;\n\tsaiki( churchx, churchy, nokori );\n\tcout << cnt << endl;\n    \n    }\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Pair, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tpairs = new Pair[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tpairs[h] = new Pair(i, j);\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpairs[0] = new Pair(i, j);\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(slove(0, 1));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, int bit) {\n\t\tPair p = new Pair(cur, bit);\n\t\tif (M.containsKey(p))\n\t\t\treturn M.get(p);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = pairs[cur].y;\n\t\t\tint x = pairs[cur].x;\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (Integer.bitCount(bit) == h) {\n\t\t\t\t\t\treturn res + 1;\n\t\t\t\t\t}\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif ((bit >> a[y][x] & 1) == 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tres += slove(a[y][x], bit | 1 << a[y][x]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(p, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tclass Pair {\n\t\tint y, x;\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic Pair(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n\n\tint m, n, h;\n\tPair[] pairs;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Pair, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class Main {\n\tprivate static final Scanner S=new Scanner(System.in);\n\tprivate static final PrintStream O=System.out;\n\t\n\tprivate static class State {\n\t\tprivate static final int H=1,K=2,Z=3;\n\t\tprivate static final int U=0,D=1,L=2,R=3;\n\n\t\tprivate final int is,js,t[][];\n\t\t\n\t\tprivate State(final int is, final int js, final int[][] t) {\n\t\t\tthis.is=is;\n\t\t\tthis.js=js;\n\t\t\tthis.t=t.clone();\n\t\t\tfor(int i=0;i<t.length;i++) this.t[i]=t[i].clone();\n\t\t}\n\t\t\n\t\tprivate boolean b(final int d, State ps[], int n) {\n\t\t\tif(d==U) {\n\t\t\t\tint pis;\n\t\t\t\tfor(pis=is;t[pis][js]!=H;pis--) if(pis<=0) return false;\n\t\t\t\tps[n]=new State(pis,js,t);\n\t\t\t\tps[n].t[pis][js]=Z;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(d==D) {\n\t\t\t\tint pis;\n\t\t\t\tfor(pis=is;t[pis][js]!=H;pis++) if(pis>=t.length-1) return false;\n\t\t\t\tps[n]=new State(pis,js,t);\n\t\t\t\tps[n].t[pis][js]=Z;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(d==L) {\n\t\t\t\tint pjs;\n\t\t\t\tfor(pjs=js;t[is][pjs]!=H;pjs--) if(pjs<=0) return false;\n\t\t\t\tps[n]=new State(is,pjs,t);\n\t\t\t\tps[n].t[is][pjs]=Z;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(d==R) {\n\t\t\t\tint pjs;\n\t\t\t\tfor(pjs=js;t[is][pjs]!=H;pjs++) if(pjs>=t[is].length-1) return false;\n\t\t\t\tps[n]=new State(is,pjs,t);\n\t\t\t\tps[n].t[is][pjs]=Z;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tprivate boolean r(final int d) {\n\t\t\tif(d==U) {\n\t\t\t\tfor(int pis=is;t[pis][js]!=K;pis--) if(pis<=0) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(d==D) {\n\t\t\t\tfor(int pis=is;t[pis][js]!=K;pis++) if(pis>=t.length-1) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(d==L) {\n\t\t\t\tfor(int pjs=js;t[is][pjs]!=K;pjs--) if(pjs<=0) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(d==R) {\n\t\t\t\tfor(int pjs=js;t[is][pjs]!=K;pjs++) if(pjs>=t[is].length-1) return false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint m,n;\n\t\twhile((m=S.nextInt())!=0 && (n=S.nextInt())!=0) {\n\t\t\tint is=0,js=0,t[][]=new int[n][m],nh=0;\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) {\n\t\t\t\tt[i][j]=S.nextInt();\n\t\t\t\tif(t[i][j]==State.K) {\n\t\t\t\t\tis=i;\n\t\t\t\t\tjs=j;\n\t\t\t\t} else if(t[i][j]==State.H) nh++;\n\t\t\t}\n\t\t\tint nc=1;\n\t\t\tState cs[]=new State[nc];\n\t\t\tcs[0]=new State(is, js, t);\n\t\t\tint ca[]=new int[cs.length];\n\t\t\tca[0]=1;\n\t\t\tfor(int i=0;i<nh;i++) {\n\t\t\t\tint np=0;\n\t\t\t\tState ps[]=new State[nc*4];\n\t\t\t\tint pa[]=new int[ps.length];\n\t\t\t\tfor(int j=0;j<nc;j++) for(int k=0;k<4;k++) if(cs[j].b(k, ps, np)) {\n\t\t\t\t\tint l;\n\t\t\t\t\tfor(l=0;l<np;l++) if(ps[np].equals(ps[l])) {\n\t\t\t\t\t\tpa[l]+=ca[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(l>=np) {\n\t\t\t\t\t\tpa[np]=ca[j];\n\t\t\t\t\t\tnp++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnc=np;\n\t\t\t\tcs=ps;\n\t\t\t\tca=pa;\n\t\t\t}\n\t\t\tint a=0;\n\t\t\tfor(int i=0;i<nc;i++) for(int j=0;j<4;j++) if(cs[i].r(j)) a+=ca[i];\n\t\t\tO.println(a);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = scanner.nextInt();\n\t\t\tn = scanner.nextInt();\n\t\t\tif ((m | n) == 0)\n\t\t\t\tbreak;\n\t\t\tM = new HashMap<Pair, Integer>();\n\t\t\th = 1;\n\t\t\ta = new int[n][m];\n\t\t\tpairs = new Pair[24];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tint t = scanner.nextInt();\n\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\t} else if (t == 1) {\n\t\t\t\t\t\tpairs[h] = new Pair(i, j);\n\t\t\t\t\t\ta[i][j] = h++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpairs[0] = new Pair(i, j);\n\t\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tBitSet bit = new BitSet();\n\t\t\tbit.set(0);\n\t\t\tSystem.out.println(slove(0, bit));\n\t\t}\n\t}\n\n\tprivate int slove(int cur, BitSet bit) {\n\t\tPair p = new Pair(cur, bit);\n\t\tif (M.containsKey(p))\n\t\t\treturn M.get(p);\n\t\tint res = 0;\n\t\tfor (int[] mo : move) {\n\t\t\tint y = pairs[cur].y;\n\t\t\tint x = pairs[cur].x;\n\t\t\twhile (true) {\n\t\t\t\ty += mo[0];\n\t\t\t\tx += mo[1];\n\t\t\t\tif (!isOK(y, x))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a[y][x] == 0)\n\t\t\t\t\tif (bit.cardinality() == h) {\n\t\t\t\t\t\treturn res + 1;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (a[y][x] >= 1) {\n\t\t\t\t\tif (bit.get(a[y][x]))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tBitSet newbit = (BitSet) bit.clone();\n\t\t\t\t\tnewbit.set(a[y][x]);\n\t\t\t\t\tres += slove(a[y][x],newbit);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tM.put(p, res);\n\t\treturn res;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\tif (0 <= y && y < n && 0 <= x && x < m)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tclass Pair {\n\t\tint y, x;\n\t\tBitSet bit;\n\n\t\tpublic Pair(int y, BitSet bit) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.bit = bit;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + ((bit == null) ? 0 : bit.hashCode());\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (bit == null) {\n\t\t\t\tif (other.bit != null)\n\t\t\t\t\treturn false;\n\t\t\t} else if (!bit.equals(other.bit))\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic Pair(int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t}\n\n\tint m, n, h;\n\tPair[] pairs;\n\tint[][] a;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\tMap<Pair, Integer> M;\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tint km(boolean[] a, int b) {\n\n\t\tint z = 0;\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\n\t\t\tz += a[i] ? 1 : 0;\n\n\t\t\tz *= 2;\n\n\t\t}\n\n\t\treturn z * 100 + b;\n\n\t}\n\n\n\n\tint rec(boolean[] used, int now, int count, int[][] map) {\n\n\t\tif (ht.containsKey(km(used, now))) {\n\n\t\t\treturn ht.get(km(used, now));\n\n\t\t}\n\n\t\tif (count == used.length - 1) {\n\n\t\t\tif (!list.get(now).reachable(list.get(0))) {\n\n\t\t\t\t// ht.put(km(used, now),0);\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// ht.put(km(used, now),1);\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tint[] dx = { -1, 1, 0, 0 };\n\n\t\tint[] dy = { 0, 0, -1, 1 };\n\n\t\tb bnow = list.get(now);\n\n\t\tfor (int i = 0; i < 4; i++) {\n\n\t\t\tint x = bnow.j;\n\n\t\t\tint y = bnow.i;\n\n\t\t\tfor (;; x += dx[i], y += dy[i]) {\n\n\t\t\t\tif (y >= map.length || x >= map[0].length || x < 0 || y < 0) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (map[y][x] > 0) {\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"push\"+i);\n\n\t\t\t\t\tint q = map[y][x];\n\n\t\t\t\t\tused[q] = true;\n\n\t\t\t\t\tmap[y][x] = -1;\n\n\t\t\t\t\tsum += rec(used, q, count + 1, map);\n\n\t\t\t\t\tmap[y][x] = q;\n\n\t\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t\t// System.out.println(\"pop\"+i);\n\n\t\t\t\t\tused[q] = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (count % 3 == 1)\n\n\t\t\tht.put(km(used, now), sum);\n\n\t\treturn sum;\n\n\t}\n\n\n\n\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\tHashMap<Integer, Integer> ht = new HashMap<Integer, Integer>();\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tb start = null;\n\n\t\t\tlist.clear();\n\n\t\t\tht = new HashMap<Integer, Integer>();\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used, 0, 0, map));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tboolean and(int a,boolean[] b){\n\n\t\tfor(int i=0; i < b.length ; i++){\n\n\t\t\tif((1&(a>>i))==1 && b[i]) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t\n\n\tint rec(boolean[] used,int now, int count, boolean[][] reachableS,int[][] reachableP ){\n\n\t\tif(count == used.length-1){\n\n\t\t\tif (!reachableS[now][0])\n\n\t\t\t\treturn 0;\n\n\t\t\tif (and(reachableP[now][0] , used))\n\n\t\t\t\treturn 0;\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tfor(int i=1;i<used.length;i++){\n\n\t\t\tif(!used[i]){\n\n\t\t\t\tif (!reachableS[now][i])\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (and(reachableP[now][i] , used))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tused[i] = true;\n\n//\t\t\t\tSystem.out.printf(\"%x \",1<<(count*4));\n\n//\t\t\t\tSystem.out.println(\"push\"+i);\n\n\t\t\t\tsum += rec(used,i,count+1,reachableS,reachableP);\n\n//\t\t\t\tSystem.out.printf(\"%x \",1<<(count*4));\n\n//\t\t\t\tSystem.out.println(\"pop\"+i);\n\n\t\t\t\tused[i] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn sum;\n\n\t}\n\n\t\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\t\t\tb start = null;\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\t\t\tboolean[][] reachableS = new boolean[n][n];\n\n\t\t\tint[][] reachableP = new int[n][n];\n\n\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = j + 1; k < w; k++) {\n\n\t\t\t\t\t\t\tif (map[i][k] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[i][k];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[i][k]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = i + 1; k < h; k++) {\n\n\t\t\t\t\t\t\tif (map[k][j] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[k][j];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[k][j]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used,0,0,reachableS,reachableP));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, GS, R = 8;\n\tint[][] map;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tList<Integer>[][] adj;\n\tMap<Integer, Integer>[] dp;\n\t\n\tint get(int v, int S, int rest){\n\t\tif(rest==1&&S==(1<<N))return 1;\n\t\tif(R<=rest&&dp[v].containsKey(S))return dp[v].get(S);\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(((S>>nv)&1)==0)continue;\n\t\t\tif(nv==N&&3<=rest)continue;\n\t\t\tres+=get(nv, S-(1<<v), rest-1);\n\t\t\tbreak;\n\t\t}\n\t\tif(R<=rest)dp[v].put(S, res);\n\t\treturn res;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tdp = new Map[N+1];\n\t\t\tfor(int i=0;i<=N;i++)dp[i]=new HashMap<Integer, Integer>();\n\t\t\tdp[N].put(1<<N, 1);\n\t\t\tint res = 0;\n\t\t\tfor(int k=0;k<4;k++)if(!adj[N][k].isEmpty())res+=get(adj[N][k].get(0), GS, N+1);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, GS;\n\tint[][] map, pos;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tList<Integer>[][] adj;\n\tboolean[] visited;\n\tMap<Integer, Integer>[][] mem;\n\t\n\tboolean check(int v){\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tif(visited[i]||i==v)continue;\n\t\t\tint c = 0;\n\t\t\tfor(int k=0;k<4;k++)for(int nv:adj[i][k]){\n\t\t\t\tif(visited[nv]){\n\t\t\t\t\tif(nv==v)c++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n//\t\t\tSystem.out.println(\"ID:\" +i+\" C:\"+c);\n\t\t\tif(i==N){\n\t\t\t\tif(c==0)return false;\n\t\t\t}\n\t\t\telse if(c<2)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint dfs(int v, int S, boolean head, int rest){\n//\t\tSystem.out.println(\"V:\"+v);\n//\t\tdebug(visited);\n\t\tif(!head&&v==N){\n\t\t\treturn S==GS?1:0;\n\t\t}\n\t\tif(rest<=10&&mem[rest][v].containsKey(S))return mem[rest][v].get(S);\n\t\tif(!check(v)){\n//\t\t\tSystem.out.println(\"CHECK OUT\");\n\t\t\treturn 0;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(visited[nv])break;\n\t\t\tvisited[nv] = true;\n\t\t\tres += dfs(nv, S+(1<<nv), false, rest-1);\n\t\t\tvisited[nv] = false;\n\t\t}\n\t\tif(rest<=10)mem[rest][v].put(S, res);\n\t\treturn res;\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tpos = new int[N+1][2];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tpos[id][0] = i; pos[id][1] = j;\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpos[N][0] = i; pos[N][1] = j;\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int i=0;i<=N;i++){\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\t\tSystem.out.print(\"Dir \"+k+\":\");\n//\t\t\t\t\tfor(int nv:adj[i][k])System.out.print(\" \"+nv);\n//\t\t\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tmem = new Map[11][N+1];\n\t\t\tfor(int i=0;i<=10;i++)for(int j=0;j<=N;j++)mem[i][j]=new HashMap<Integer, Integer>();\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tvisited = new boolean[N+1];\n//\t\t\tdfs(N, 0, true);\n\t\t\tSystem.out.println(dfs(N, 0, true, N));\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\n//Reindeer with no sense of direction\npublic class Main{\n\n\tint w, h, N, GS, REST = 20;\n\tint[][] map, pos;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tList<Integer>[][] adj;\n\tboolean[] visited;\n\tMap<Integer, Integer>[][] mem;\n\tMap<Integer, Integer>[] dp;\n\t\n\tboolean check(int v){\n//\t\tfor(int j=0;j<4;j++){\n//\t\t\tif(adj[v][j].isEmpty())continue;\n//\t\t\tint i = adj[v][j].get(0);\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tif(visited[i]||i==v)continue;\n\t\t\tint c = 0;\n\t\t\tfor(int k=0;k<4;k++)for(int nv:adj[i][k]){\n\t\t\t\tif(visited[nv]){\n\t\t\t\t\tif(nv==v)c++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n//\t\t\tSystem.out.println(\"ID:\" +i+\" C:\"+c);\n\t\t\tif(i==N){\n\t\t\t\tif(c==0)return false;\n\t\t\t}\n\t\t\telse if(c<2)return false;\n//\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tint get(int v, int S, int rest){\n//\t\tSystem.out.println(\"V:\"+v+\" S:\"+S);\n\t\tif(dp[v].containsKey(S))return dp[v].get(S);\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(((S>>nv)&1)==0)continue;\n\t\t\tif(nv==N&&3<=rest)continue;\n\t\t\tres+=get(nv, S-(1<<v), rest-1);\n\t\t\tbreak;\n\t\t}\n\t\tdp[v].put(S, res);\n\t\treturn res;\n\t}\n\t\n\tint dfs(int v, int S, boolean head, int rest){\n//\t\tSystem.out.println(\"V:\"+v);\n//\t\tdebug(visited);\n\t\tif(!head&&v==N){\n\t\t\treturn S==GS?1:0;\n\t\t}\n\t\tif(rest<=REST&&mem[rest][v].containsKey(S))return mem[rest][v].get(S);\n\t\tif(!check(v)){\n//\t\t\tSystem.out.println(\"CHECK OUT\");\n\t\t\treturn 0;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int k=0;k<4;k++)for(int nv:adj[v][k]){\n\t\t\tif(visited[nv])break;\n\t\t\tvisited[nv] = true;\n\t\t\tres += dfs(nv, S+(1<<nv), false, rest+1);\n\t\t\tvisited[nv] = false;\n\t\t}\n\t\tif(rest<=REST)mem[rest][v].put(S, res);\n\t\treturn res;\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tsc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tN = 0;\n\t\t\tmap = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\tif(map[i][j]==1)N++;\n\t\t\t\telse if(map[i][j]==0)map[i][j]=-1;\n\t\t\t}\n\t\t\tint id = 0;\n\t\t\tpos = new int[N+1][2];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==-1)continue;\n\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\tpos[id][0] = i; pos[id][1] = j;\n\t\t\t\t\tmap[i][j]=id++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpos[N][0] = i; pos[N][1] = j;\n\t\t\t\t\tmap[i][j] = N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new List[N+1][4];\n\t\t\tfor(int i=0;i<=N;i++)for(int j=0;j<4;j++)adj[i][j]=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(map[i][j]!=-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint pi = i+d[k][0], pj = j+d[k][1];\n\t\t\t\t\twhile(0<=pi&&pi<h&&0<=pj&&pj<w){\n\t\t\t\t\t\tif(map[pi][pj]!=-1)adj[map[i][j]][k].add(map[pi][pj]);\n\t\t\t\t\t\tpi+=d[k][0]; pj+=d[k][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(int i=0;i<=N;i++){\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int k=0;k<4;k++){\n//\t\t\t\t\tSystem.out.print(\"Dir \"+k+\":\");\n//\t\t\t\t\tfor(int nv:adj[i][k])System.out.print(\" \"+nv);\n//\t\t\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t}\n\t\t\tmem = new Map[REST+1][N+1];\n\t\t\tfor(int i=0;i<=REST;i++)for(int j=0;j<=N;j++)mem[i][j]=new HashMap<Integer, Integer>();\n\t\t\tGS = (1<<(N+1))-1;\n\t\t\tvisited = new boolean[N+1];\n//\t\t\tdfs(N, 0, true);\n\t\t\tdp = new Map[N+1];\n\t\t\tfor(int i=0;i<=N;i++)dp[i]=new HashMap<Integer, Integer>();\n\t\t\tdp[N].put(1<<N, 1);\n\t\t\tint res = 0;\n\t\t\tfor(int k=0;k<4;k++)if(!adj[N][k].isEmpty())res+=get(adj[N][k].get(0), GS, N+1);\n\t\t\tSystem.out.println(res);\n//\t\t\tSystem.out.println(dfs(N, 0, true, 0));\n\t\t}\n//\t\tSystem.out.println((System.currentTimeMillis()-T)+\" ms.\");\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tclass b {\n\n\t\tint i;\n\n\t\tint j;\n\n\n\n\t\tb(int a, int c) {\n\n\t\t\ti = a;\n\n\t\t\tj = c;\n\n\t\t}\n\n\n\n\t\tboolean reachable(b o) {\n\n\t\t\treturn this.i == o.i || this.j == o.j;\n\n\t\t}\n\n\t}\n\n\n\n\tboolean and(int a, boolean[] b) {\n\n\t\tfor (int i = 0; i < b.length; i++) {\n\n\t\t\tif ((1 & (a >> i)) == 1 && !b[i])\n\n\t\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tint ansC = 0;\n\n\tint rec(boolean[] used, int now, int count, boolean[][] reachableS,\n\n\t\t\tint[][] reachableP) {\n\n\t\tif (count == used.length - 1) {\n\n\t\t\tif (!reachableS[now][0])\n\n\t\t\t\treturn 0;\n\n\t\t\tif (and(reachableP[now][0], used))\n\n\t\t\t\treturn 0;\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t\tint sum = 0;\n\n\t\tfor (int i = 1; i < used.length; i++) {\n\n\t\t\tif (!used[i]) {\n\n\t\t\t\tif (!reachableS[now][i])\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (and(reachableP[now][i], used))\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\tused[i] = true;\n\n\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t// System.out.println(\"push\"+i);\n\n\t\t\t\tsum += rec(used, i, count + 1, reachableS, reachableP);\n\n\t\t\t\t// System.out.printf(\"%x \",1<<(count*4));\n\n\t\t\t\t// System.out.println(\"pop\"+i);\n\n\t\t\t\tused[i] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn sum;\n\n\t}\n\n\n\n\tint[] setCost(boolean[][] reachable) {\n\n\t\tint[] ret = new int[reachable.length];\n\n\t\tint count = 1;\n\n\t\tboolean cnt = true;\n\n\t\tLinkedList<Integer> v = new LinkedList<Integer>();\n\n\t\tv.add(0);\n\n\t\twhile (cnt) {\n\n\t\t\tcnt = false;\n\n\t\t\tLinkedList<Integer> nextv = new LinkedList<Integer>();\n\n\t\t\tfor (int i = 1; i < reachable.length; i++) {\n\n\t\t\t\tif (ret[i] == 0) {\n\n\t\t\t\t\tfor (int k : v) {\n\n\t\t\t\t\t\tif (reachable[i][k]) {\n\n\t\t\t\t\t\t\tret[i] = count;\n\n\t\t\t\t\t\t\tcnt |= true;\n\n\t\t\t\t\t\t\tnextv.add(i);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tv=nextv;\n\n\t\t\tcount++;\n\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint w = sc.nextInt();\n\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif ((h | w) == 0) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tLinkedList<b> list = new LinkedList<Main.b>();\n\n\t\t\tb start = null;\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tint id = 1;\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tmap[i][j] = -1;\n\n\t\t\t\t\tint z = sc.nextInt();\n\n\t\t\t\t\tif (z == 1) {\n\n\t\t\t\t\t\tlist.addLast(new b(i, j));\n\n\t\t\t\t\t\tmap[i][j] = id;\n\n\t\t\t\t\t\tid++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (z == 2) {\n\n\t\t\t\t\t\tstart = new b(i, j);\n\n\t\t\t\t\t\tlist.addFirst(start);\n\n\t\t\t\t\t\tmap[i][j] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tint n = list.size();\n\n\t\t\tboolean[][] reachableS = new boolean[n][n];\n\n\t\t\tint[][] reachableP = new int[n][n];\n\n\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = j + 1; k < w; k++) {\n\n\t\t\t\t\t\t\tif (map[i][k] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[i][k];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[i][k]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\n\t\t\t\t\tif (map[i][j] != -1) {\n\n\t\t\t\t\t\tint dst = map[i][j];\n\n\t\t\t\t\t\tint rP = 0;\n\n\t\t\t\t\t\tfor (int k = i + 1; k < h; k++) {\n\n\t\t\t\t\t\t\tif (map[k][j] != -1) {\n\n\t\t\t\t\t\t\t\tint dpt = map[k][j];\n\n\t\t\t\t\t\t\t\treachableS[dpt][dst] = true;\n\n\t\t\t\t\t\t\t\treachableS[dst][dpt] = true;\n\n\t\t\t\t\t\t\t\treachableP[dpt][dst] = rP;\n\n\t\t\t\t\t\t\t\treachableP[dst][dpt] = rP;\n\n\t\t\t\t\t\t\t\trP |= (1 << map[k][j]);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\t\t\tboolean[] used = new boolean[n];\n\n\t\t\tSystem.out.println(rec(used, 0, 0, reachableS, reachableP));\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime(), stopCpuTime = 0;\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0545-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint m = scan.nextInt();\n\t\t\tint n = scan.nextInt();\n\t\t\tif (m == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tMap mp = new Map(m, n);\n\t\t\tfor (int y = 0; y < n; y++)\n\t\t\t\tfor (int x = 0; x < m; x++)\n\t\t\t\t\tmp.add(x, y, scan.nextInt());\n\t\t\tSystem.out.println(mp.count());\n\t\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\t}\n\n\t\tscan.close();\n\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t// System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Map {\n\tint[][] mp;\n\tboolean[][] flg;\n\tint stx = -1, sty = -1;\n\tint[] cnt;\n\n\tpublic Map(int m, int n) {\n\t\tmp = new int[m][n];\n\t\tflg = new boolean[m][n];\n\t\tcnt = new int[0x07fffff];\n\t\tfor (int i = 0; i < cnt.length; i++)\n\t\t\tcnt[i] = -1;\n\t}\n\n\tpublic int count() {\n\t\t// TODO Auto-generated method stub\n\t\treturn -1;\n\t}\n\n\tint uno = 0;\n\n\tpublic void add(int x, int y, int s) {\n\t\tif (s == 0)\n\t\t\tmp[x][y] = -1;\n\t\tif (s == 1)\n\t\t\tmp[x][y] = uno++;\n\t\tif (s == 2) {\n\t\t\tmp[x][y] = 99;\n\t\t\tstx = x;\n\t\t\tsty = y;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\n\tstatic int w,h,si,sj,n;\n\tstatic int[] di = {0,1,0,-1};\n\tstatic int[] dj = {1,0,-1,0};\n\tstatic int[][] table;\n\tstatic BitSet visited;\n\n\tstatic boolean solve() {\n\t\tw = in.nextInt();\n\t\th = in.nextInt();\n\t\tif (w == 0 && h == 0) return false;\n\t\ttable = new int[h][w];\n\t\tsi = -1; sj = -1;\n\t\tn = 0;\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\ttable[i][j] = in.nextInt();\n\t\t\t\tif (table[i][j] == 1) {\n\t\t\t\t\tn++;\n\t\t\t\t} else if (table[i][j] == 2) {\n\t\t\t\t\tsi = i; sj = j;\n\t\t\t\t\ttable[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvisited = new BitSet();\n\t\tout.println(rec(si,sj));\n\t\tout.flush();\n\t\treturn true;\n\t}\n\n\tstatic int rec(int ci, int cj) {\n\n\t\tif (visited.cardinality() == n) {\n\t\t\treturn ci == si || cj == sj ? 1 : 0;\n\t\t}\n\n\t\tint res = 0;\n\n\t\tfor (int k=0; k<4; k++) {\n\t\t\tint ni = ci + di[k];\n\t\t\tint nj = cj + dj[k];\n\t\t\twhile (0 <= ni && 0 <= nj && ni < h && nj < w) {\n\t\t\t\tif (table[ni][nj] > 0 && !visited.get(ni*w+nj)) {\n\t\t\t\t\tvisited.set(ni*w+nj);\n\t\t\t\t\tres += rec(ni, nj);\n\t\t\t\t\tvisited.set(ni*w+nj, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tni += di[k];\n\t\t\t\tnj += dj[k];\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\t//trace(end-start + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nDRCS = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n\n### subroutines\n\ndef reachable?(y0, x0, y1, x1)\n  dy = (y1 <=> y0)\n  dx = (x1 <=> x0)\n\n  return false if dy != 0 && dx != 0\n\n  if dy == 0\n    x0 += dx\n    while x0 != x1\n      return false if ! $pass[y0][x0]\n      x0 += dx\n    end\n  else\n    y0 += dy\n    while y0 != y1\n      return false if ! $pass[y0][x0]\n      y0 += dy\n    end\n  end\n\n  true\nend\n\ndef count_rt(k, y, x)\n  if k == 0\n    return (reachable?(y, x, $sy, $sx) ? 1 : 0)\n  end\n\n  count = 0\n\n  for dxy in DRCS\n    dy, dx = dxy\n    y0 = y + dy\n    x0 = x + dx\n\n    while y0 >= 0 && y0 < $n && x0 >= 0 && x0 < $m && $pass[y0][x0]\n      if $sects[y0][x0] == 1\n        $pass[y0][x0] = false\n        count += count_rt(k - 1, y0, x0)\n        $pass[y0][x0] = true\n      end\n\n      y0 += dy\n      x0 += dx\n    end\n  end\n\n  count\nend\n\n### main\n\nloop do\n  $m, $n = gets.strip.split(' ').map{|s| s.to_i}\n  break if ($m | $n) == 0\n\n  $sects = $n.times.map{[]}\n  $sy = $sx = -1\n  home = 0\n\n  for y in (0...$n)\n    hl = gets.strip.split(' ').map{|s| s.to_i}\n    for x in (0...$m)\n      $sects[y][x] = hl[x]\n\n      case hl[x]\n      when 1\n        home += 1\n      when 2\n        $sy = y\n        $sx = x\n      end\n    end\n  end\n\n  $pass = $n.times.map{$m.times.map{true}}\n\n  puts count_rt(home, $sy, $sx)\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nint m, n;\nint[int][23] cache;\nint[M][M] id;\nint vCount;\nP[] pos;\nF cur;\n\nint[] next(int v) {\n    int[] ret;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    foreach (i; 0 .. 4) {\n        int y = pos[v].y, x = pos[v].x;\n        while (true) {\n            y += dy[i];\n            x += dx[i];\n            if (y < 0 || y >= n) break;\n            if (x < 0 || x >= m) break;\n            if (cur[y][x] == 2) {\n                ret ~= id[y][x];\n                continue;\n            }\n            if (cur[y][x] == 1) {\n                ret ~= id[y][x];\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint dfs(int v, int used) {\n    if (used in cache[v - 1]) return cache[v - 1][used];\n    int ans = 0;\n    //writeln(pos[v], next(v).map!((i) => pos[i]));\n    int[] z = next(v);\n    foreach (i; z) {\n        if (i == 0) {\n            //writefln(\"%b\", used);\n            if (used == (1 << vCount - 1) - 1) ans++;\n            continue;\n        }\n        if (used & (1 << i-1)) continue;\n        int ny = pos[i].y,\n            nx = pos[i].x;\n        if (cur[ny][nx] == 1) {\n            cur[ny][nx] = 3;\n            ans += dfs(i, used | (1 << i-1));\n            cur[ny][nx] = 1;\n        } \n    }\n    delete(z);\n    return cache[v - 1][used] = ans;\n}\n\nvoid main() {\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        memset(cast(void*)id, -1, id.sizeof);\n        vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &cur[i][j]);\n                if (cur[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (cur[i][j] == 2) {\n                    id[i][j] = 0;\n                }\n            }\n        }\n        pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport core.stdc.stdio;\nimport core.memory;\n\nvoid main(){\n\twhile(true){\n\tGC.collect;\n\n\tint[][4][23] nextTown;\n\tint[4] beTown;\n\tbeTown[] = -1;\n\tint[10][10] mapData;\n\tint[] dx = [0,-1,0,1];\n\tint[] dy = [-1,0,1,0];\n\tint w,h;\n\tscanf(\"%d%d\",&w,&h);\n\tif(w==0&&h==0)\n\t\tbreak;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&mapData[i][j]);\n\t\t}\n\t}\n\tint tc=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(mapData[i][j] == 0){\n\t\t\t\tmapData[i][j] = 255;\n\t\t\t}else if(mapData[i][j] == 1){\n\t\t\t\tmapData[i][j] = tc++;\n\t\t\t}else{\n\t\t\t\tmapData[i][j] = 114;\n\t\t\t}\n\t\t}\n\t}\n\tbool[] sl = new bool[tc];\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(mapData[i][j] < 23){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ny=i+dy[k],nx=j+dx[k];\n\t\t\t\t\twhile(0<=nx&&nx<w&&0<=ny&&ny<h){\n\t\t\t\t\t\tif(mapData[ny][nx] < 23)\n\t\t\t\t\t\t\tnextTown[mapData[i][j]][k] ~= mapData[ny][nx];\n\t\t\t\t\t\tny += dy[k];\n\t\t\t\t\t\tnx += dx[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mapData[i][j] == 114){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ny=i+dy[k],nx=j+dx[k];\n\t\t\t\t\twhile(0<=nx&&nx<w&&0<=ny&&ny<h){\n\t\t\t\t\t\tif(mapData[ny][nx] < 23){\n\t\t\t\t\t\t\tif(beTown[k] == -1)\n\t\t\t\t\t\t\t\tbeTown[k] = mapData[ny][nx];\n\t\t\t\t\t\t\tsl[mapData[ny][nx]]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tny += dy[k];\n\t\t\t\t\t\tnx += dx[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint[int] now;\n\tfor(int k=0;k<4;k++){\n\t\tif(beTown[k] >= 0){\n\t\t\tnow[(beTown[k]<<tc)|(1<<beTown[k])] = 1;\n\t\t}\n\t}\n\tfor(int _=1;_<tc;_++){\n\t\tint[int] next;\n\t\tforeach(int state,int num;now){\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tforeach(s;nextTown[state>>tc][k]){\n\t\t\t\t\tif((state&(1<<s))==0){\n\t\t\t\t\t\tint idx = (s<<tc)|(1<<s)|(state&((1<<tc)-1));\n\t\t\t\t\t\tint* np = idx in next;\n\t\t\t\t\t\tif(np == null)\n\t\t\t\t\t\t\tnext[idx] = num;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t(*np)+=num;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(now,next);\n\t}\n\tint ans=0;\n\tforeach(int state,int num;now){\n\t\tif(sl[state>>tc]){\n\t\t\tans += num;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nint m, n;\nint[int][23] cache;\nint[M][M] id;\nint vCount;\nP[] pos;\nF cur;\n\nint[] next(int v) {\n    int[] ret;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    int sy = pos[v].y, sx = pos[v].x;\n    foreach (i; 0 .. 4) {\n        int y = sy, x = sx;\n        while (true) {\n            y += dy[i];\n            x += dx[i];\n            if (y < 0 || y >= n) break;\n            if (x < 0 || x >= m) break;\n            if (cur[y][x] == 2) {\n                ret ~= id[y][x];\n                continue;\n            }\n            if (cur[y][x] == 1) {\n                ret ~= id[y][x];\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint dfs(int v, int used) {\n    if (used in cache[v - 1]) return cache[v - 1][used];\n    int y = pos[v].y, x = pos[v].x;\n    int ans = 0;\n    //writeln(pos[v], next(v).map!((i) => pos[i]));\n    int[] z = next(v);\n    foreach (i; z) {\n        if (i == 0) {\n            //writefln(\"%b\", used);\n            if (used == (1 << vCount - 1) - 1) ans++;\n            continue;\n        }\n        if (used & (1 << i-1)) continue;\n        int ny = pos[i].y,\n            nx = pos[i].x;\n        //assert(cur[ny][nx] == 1);\n        if (cur[ny][nx] == 1) {\n            cur[ny][nx] = 3;\n            ans += dfs(i, used | (1 << i-1));\n            cur[ny][nx] = 1;\n        } \n    }\n    delete(z);\n    return cache[v - 1][used] = ans;\n}\n\nvoid main() {\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        int sy, sx;\n        memset(cast(void*)id, -1, id.sizeof);\n        vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &cur[i][j]);\n                if (cur[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (cur[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nvoid main() {\n    int m, n;\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        F f;\n        int sy, sx;\n        int[M][M] id; memset(cast(void*)id, -1, id.sizeof);\n        int vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &f[i][j]);\n                if (f[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (f[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        P[] pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        F cur = f;\n        int[] next(int v) {\n            int[] ret;\n            static const dy = [0, 1, 0, -1],\n                         dx = [1, 0, -1, 0];\n            int sy = pos[v].y, sx = pos[v].x;\n            foreach (i; 0 .. 4) {\n                int y = sy, x = sx;\n                while (true) {\n                    y += dy[i];\n                    x += dx[i];\n                    if (y < 0 || y >= n) break;\n                    if (x < 0 || x >= m) break;\n                    //if (cur[y][x] == 3) break;\n                    //if (cur[y][x] == 1 || cur[y][x] == 2) {\n                    if (cur[y][x] == 2) {\n                        ret ~= id[y][x];\n                    }\n                    if (cur[y][x] == 1) {\n                        ret ~= id[y][x];\n                        break;\n                    }\n                }\n            }\n            return ret;\n        }\n        int[int][24] cache;\n        int dfs(int v, int used) {\n            if (v == 0 && (used & 1)) {\n                foreach (i; 1 .. vCount) {\n                    if (!(used & (1 << i))) return 0;\n                }\n                return 1;\n            }\n            if (used in cache[v]) return cache[v][used];\n            int y = pos[v].y, x = pos[v].x;\n            int ans = 0;\n            //writeln(pos[v], next(v).map!((i) => pos[i]));\n            foreach (i; next(v)) {\n                if (used & (1 << i)) continue;\n                int ny = pos[i].y,\n                    nx = pos[i].x;\n                assert(cur[ny][nx] == 1 || cur[ny][nx] == 2);\n                if (cur[ny][nx] == 1) {\n                    cur[ny][nx] = 3;\n                    ans += dfs(i, used | (1 << i));\n                    cur[ny][nx] = 1;\n                } else {\n                    ans += dfs(i, used | (1 << i));\n                }\n            }\n            return cache[v][used] = ans;\n        }\n        dfs(0, 0).writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nvoid main() {\n    int m, n;\n    int[int][23] cache;\n    int[M][M] id;\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        F f;\n        int sy, sx;\n        memset(cast(void*)id, -1, id.sizeof);\n        int vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &f[i][j]);\n                if (f[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (f[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        P[] pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        F cur = f;\n        int[] next(int v) {\n            int[] ret;\n            static const dy = [0, 1, 0, -1],\n                         dx = [1, 0, -1, 0];\n            int sy = pos[v].y, sx = pos[v].x;\n            foreach (i; 0 .. 4) {\n                int y = sy, x = sx;\n                while (true) {\n                    y += dy[i];\n                    x += dx[i];\n                    if (y < 0 || y >= n) break;\n                    if (x < 0 || x >= m) break;\n                    if (cur[y][x] == 2) {\n                        ret ~= id[y][x];\n                        continue;\n                    }\n                    if (cur[y][x] == 1) {\n                        ret ~= id[y][x];\n                        break;\n                    }\n                }\n            }\n            return ret;\n        }\n\n        int dfs(int v, int used) {\n            if (used in cache[v- 1]) return cache[v - 1][used];\n            int y = pos[v].y, x = pos[v].x;\n            int ans = 0;\n            //writeln(pos[v], next(v).map!((i) => pos[i]));\n            int[] z = next(v);\n            foreach (i; z) {\n                if (i == 0) {\n                    //writefln(\"%b\", used);\n                    if (used == (1 << vCount - 1) - 1) ans++;\n                    continue;\n                }\n                if (used & (1 << i-1)) continue;\n                int ny = pos[i].y,\n                    nx = pos[i].x;\n                assert(cur[ny][nx] == 1);\n                if (cur[ny][nx] == 1) {\n                    cur[ny][nx] = 3;\n                    ans += dfs(i, used | (1 << i-1));\n                    cur[ny][nx] = 1;\n                } \n            }\n            delete(z);\n            return cache[v - 1][used] = ans;\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nint m, n;\nint[int][23] cache;\nbyte[M][M] id;\nbyte vCount;\nP[] pos;\nF cur;\n\nbyte[] next(int v) {\n    byte[] ret;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    int sy = pos[v].y, sx = pos[v].x;\n    foreach (i; 0 .. 4) {\n        int y = sy, x = sx;\n        while (true) {\n            y += dy[i];\n            x += dx[i];\n            if (y < 0 || y >= n) break;\n            if (x < 0 || x >= m) break;\n            if (cur[y][x] == 2) {\n                ret ~= id[y][x];\n                continue;\n            }\n            if (cur[y][x] == 1) {\n                ret ~= id[y][x];\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint dfs(byte v, int used) {\n    if (used in cache[v - 1]) return cache[v - 1][used];\n    int ans = 0;\n    //writeln(pos[v], next(v).map!((i) => pos[i]));\n    byte[] z = next(v);\n    foreach (i; z) {\n        if (i == 0) {\n            //writefln(\"%b\", used);\n            if (used == (1 << vCount - 1) - 1) ans++;\n            continue;\n        }\n        if (used & (1 << i-1)) continue;\n        int ny = pos[i].y,\n            nx = pos[i].x;\n        if (cur[ny][nx] == 1) {\n            cur[ny][nx] = 3;\n            int nused = used | (1 << i - 1);\n            if (nused in cache[i - 1]) \n                ans += cache[i - 1][nused];\n            else \n                ans += dfs(i, used | (1 << i-1));\n            cur[ny][nx] = 1;\n        } \n    }\n    delete(z);\n    return cache[v - 1][used] = ans;\n}\n\nvoid main() {\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        int sy, sx;\n        memset(cast(void*)id, -1, id.sizeof);\n        vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &cur[i][j]);\n                if (cur[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (cur[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        int ans = 0;\n        foreach(byte i; next(0)) {\n            foreach (j; 0 .. 23) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.typecons;\nimport std.container;\nimport std.range;\n\nalias Tuple!(int,\"y\",int,\"x\") p;\n\nstruct w{\n\tuint visited;\n\tint last;\n\t\n\tthis(int a,uint b){\n\t\tlast = a;\n\t\tvisited = b;\n\t}\n\t\n\tint opCmp(w rhs){\n\t\tif(visited != rhs.visited)\n\t\t\treturn 2 * (visited > rhs.visited) - 1;\n\t\tif(last != rhs.last)\n\t\t\treturn 2 * (visited > rhs.visited) - 1;\n\t\treturn 0;\n\t}\n}\n\nvoid main(){\n\twhile(true){\n\tuint mask[23];\n\tfor(int i=0;i<23;++i){\n\t\tmask[i] = 1U<<i;\n\t}\n\t\n\tauto inmn = readln().split();\n\tint m = to!int(inmn[0]);\n\tint n = to!int(inmn[1]);\n\tif(m==0&&n==0)\n\t\tbreak;\n\tp[] houses;\n\tp church;\n\t\n\tfor(int i=0;i<n;++i){\n\t\tauto inmp = readln().split();\n\t\tfor(int j=0;j<m;++j){\n\t\t\tif(to!int(inmp[j]) == 1){\n\t\t\t\thouses ~= p(i,j);\n\t\t\t}\n\t\t\tif(to!int(inmp[j]) == 2){\n\t\t\t\tchurch = p(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint hn = to!int(houses.length);\n\thouses ~= church;\n\tint[4][24] nearhouse = -1;\n\t\n\tforeach(int i,p h;houses){\n\t\tint[4] nd = 10000;\n\t\tforeach(int j,p g;houses){\n\t\t\tif(i != j && j != hn){\n\t\t\t\tif(h.x == g.x){\n\t\t\t\t\tif(h.y>g.y){\n\t\t\t\t\t\tif(nd[0] > h.y-g.y){\n\t\t\t\t\t\t\tnd[0] = h.y-g.y;\n\t\t\t\t\t\t\tnearhouse[i][0] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(h.y<g.y){\n\t\t\t\t\t\tif(nd[2] > g.y-h.y){\n\t\t\t\t\t\t\tnd[2] = g.y-h.y;\n\t\t\t\t\t\t\tnearhouse[i][2] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h.y == g.y){\n\t\t\t\t\tif(h.x>g.x){\n\t\t\t\t\t\tif(nd[3] > h.x-g.x){\n\t\t\t\t\t\t\tnd[3] = h.x-g.x;\n\t\t\t\t\t\t\tnearhouse[i][3] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(h.x<g.x){\n\t\t\t\t\t\tif(nd[1] > g.x-h.x){\n\t\t\t\t\t\t\tnd[1] = g.x-h.x;\n\t\t\t\t\t\t\tnearhouse[i][1] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tSList!w list1;\n\tauto now = &list1;\n\tSList!w list2;\n\tauto next = &list2;\n\t\n\tnow.insert(w(hn,0U));\n\t\n\tint res = 0;\n\t\n\tfor(int i=0;i<hn;++i){\n\t\tforeach(w k;*now){\n\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\tif(nearhouse[k.last][j] != -1){\n\t\t\t\t\tint d = nearhouse[k.last][j];\n\t\t\t\t\twhile(mask[d] & k.visited){\n\t\t\t\t\t\td = nearhouse[d][j];\n\t\t\t\t\t\tif(d == -1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(d != -1){\n\t\t\t\t\t\tnext.insert(w(d,mask[d] | k.visited));\n\t\t\t\t\t\tif((mask[d] | k.visited) == (1U<<hn)-1){\n\t\t\t\t\t\t\tif(houses[d].x == church.x || houses[d].y == church.y)\n\t\t\t\t\t\t\t\tres++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnow.clear();\n\t\tauto tmp = now;\n\t\tnow = next;\n\t\tnext = tmp;\n\t}\n\t\n\twriteln(res);\n}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.bitop;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nint m, n;\nint[int][23] cache;\nint[M][M] id;\nint vCount;\nP[] pos;\nF cur;\n\nint[] next(int v) {\n    int[] ret;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    foreach (i; 0 .. 4) {\n        int y = pos[v].y, x = pos[v].x;\n        while (true) {\n            y += dy[i];\n            x += dx[i];\n            if (y < 0 || y >= n) break;\n            if (x < 0 || x >= m) break;\n            if (cur[y][x] == 2) {\n                ret ~= id[y][x];\n                continue;\n            }\n            if (cur[y][x] == 1) {\n                ret ~= id[y][x];\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint dfs(int v, int used) {\n    int popCount = used.popcnt;\n    if (popCount > 5) {\n        if (used in cache[v - 1]) return cache[v - 1][used];\n    }\n    int ans = 0;\n    //writeln(pos[v], next(v).map!((i) => pos[i]));\n    int[] z = next(v);\n    foreach (i; z) {\n        if (i == 0) {\n            //writefln(\"%b\", used);\n            if (used == (1 << vCount - 1) - 1) ans++;\n            continue;\n        }\n        if (used & (1 << i-1)) continue;\n        int ny = pos[i].y,\n            nx = pos[i].x;\n        if (cur[ny][nx] == 1) {\n            cur[ny][nx] = 3;\n            ans += dfs(i, used | (1 << i-1));\n            cur[ny][nx] = 1;\n        } \n    }\n    delete(z);\n    if (popCount > 5) {\n        cache[v - 1][used] = ans;\n    }\n    return ans;\n}\n\nvoid main() {\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        memset(cast(void*)id, -1, id.sizeof);\n        vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &cur[i][j]);\n                if (cur[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (cur[i][j] == 2) {\n                    id[i][j] = 0;\n                }\n            }\n        }\n        pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.bitop;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nint m, n;\nint[int][23] cache;\nint[M][M] id;\nint vCount;\nP[] pos;\nF cur;\n\nint[] next(int v) {\n    int[] ret;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    foreach (i; 0 .. 4) {\n        int y = pos[v].y, x = pos[v].x;\n        while (true) {\n            y += dy[i];\n            x += dx[i];\n            if (y < 0 || y >= n) break;\n            if (x < 0 || x >= m) break;\n            if (cur[y][x] == 2) {\n                ret ~= id[y][x];\n                continue;\n            }\n            if (cur[y][x] == 1) {\n                ret ~= id[y][x];\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint dfs(int v, int used) {\n    int popCount = used.popcnt;\n    if (popCount >= 3) {\n        if (used in cache[v - 1]) return cache[v - 1][used];\n    }\n    int ans = 0;\n    //writeln(pos[v], next(v).map!((i) => pos[i]));\n    int[] z = next(v);\n    foreach (i; z) {\n        if (i == 0) {\n            //writefln(\"%b\", used);\n            if (used == (1 << vCount - 1) - 1) ans++;\n            continue;\n        }\n        if (used & (1 << i-1)) continue;\n        int ny = pos[i].y,\n            nx = pos[i].x;\n        if (cur[ny][nx] == 1) {\n            cur[ny][nx] = 3;\n            ans += dfs(i, used | (1 << i-1));\n            cur[ny][nx] = 1;\n        } \n    }\n    delete(z);\n    if (popCount >= 3) {\n        cache[v - 1][used] = ans;\n    }\n    return ans;\n}\n\nvoid main() {\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        memset(cast(void*)id, -1, id.sizeof);\n        vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &cur[i][j]);\n                if (cur[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (cur[i][j] == 2) {\n                    id[i][j] = 0;\n                }\n            }\n        }\n        pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.typecons;\nimport std.container;\nimport std.range;\n\nalias Tuple!(int,\"y\",int,\"x\") p;\n\nstruct w{\n\tuint visited;\n\tint last;\n\t\n\tthis(int a,uint b){\n\t\tlast = a;\n\t\tvisited = b;\n\t}\n\t\n\tint opCmp(w rhs){\n\t\tif(visited != rhs.visited)\n\t\t\treturn 2 * (visited > rhs.visited) - 1;\n\t\tif(last != rhs.last)\n\t\t\treturn 2 * (visited > rhs.visited) - 1;\n\t\treturn 0;\n\t}\n}\n\nvoid main(){\n\twhile(true){\n\tuint mask[23];\n\tfor(int i=0;i<23;++i){\n\t\tmask[i] = 1U<<i;\n\t}\n\t\n\tauto inmn = readln().split();\n\tint m = to!int(inmn[0]);\n\tint n = to!int(inmn[1]);\n\tif(m==0&&n==0)\n\t\tbreak;\n\tp[] houses;\n\tp church;\n\t\n\tfor(int i=0;i<n;++i){\n\t\tauto inmp = readln().split();\n\t\tfor(int j=0;j<m;++j){\n\t\t\tif(to!int(inmp[j]) == 1){\n\t\t\t\thouses ~= p(i,j);\n\t\t\t}\n\t\t\tif(to!int(inmp[j]) == 2){\n\t\t\t\tchurch = p(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint hn = houses.length;\n\thouses ~= church;\n\tint[4][24] nearhouse = -1;\n\t\n\tforeach(int i,p h;houses){\n\t\tint[4] nd = 10000;\n\t\tforeach(int j,p g;houses){\n\t\t\tif(i != j && j != hn){\n\t\t\t\tif(h.x == g.x){\n\t\t\t\t\tif(h.y>g.y){\n\t\t\t\t\t\tif(nd[0] > h.y-g.y){\n\t\t\t\t\t\t\tnd[0] = h.y-g.y;\n\t\t\t\t\t\t\tnearhouse[i][0] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(h.y<g.y){\n\t\t\t\t\t\tif(nd[2] > g.y-h.y){\n\t\t\t\t\t\t\tnd[2] = g.y-h.y;\n\t\t\t\t\t\t\tnearhouse[i][2] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h.y == g.y){\n\t\t\t\t\tif(h.x>g.x){\n\t\t\t\t\t\tif(nd[3] > h.x-g.x){\n\t\t\t\t\t\t\tnd[3] = h.x-g.x;\n\t\t\t\t\t\t\tnearhouse[i][3] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(h.x<g.x){\n\t\t\t\t\t\tif(nd[1] > g.x-h.x){\n\t\t\t\t\t\t\tnd[1] = g.x-h.x;\n\t\t\t\t\t\t\tnearhouse[i][1] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tSList!w list1;\n\tauto now = &list1;\n\tSList!w list2;\n\tauto next = &list2;\n\t\n\tnow.insert(w(hn,0U));\n\t\n\tint res = 0;\n\t\n\tfor(int i=0;i<hn;++i){\n\t\tforeach(w k;*now){\n\t\t\tfor(int j=0;j<4;++j){\n\t\t\t\tif(nearhouse[k.last][j] != -1){\n\t\t\t\t\tint d = nearhouse[k.last][j];\n\t\t\t\t\twhile(mask[d] & k.visited){\n\t\t\t\t\t\td = nearhouse[d][j];\n\t\t\t\t\t\tif(d == -1)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(d != -1){\n\t\t\t\t\t\tnext.insert(w(d,mask[d] | k.visited));\n\t\t\t\t\t\tif((mask[d] | k.visited) == (1U<<hn)-1){\n\t\t\t\t\t\t\tif(houses[d].x == church.x || houses[d].y == church.y)\n\t\t\t\t\t\t\t\tres++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnow.clear();\n\t\tauto tmp = now;\n\t\tnow = next;\n\t\tnext = tmp;\n\t}\n\t\n\twriteln(res);\n}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nvoid main() {\n    int m, n;\n    int[int][23] cache;\n    int[M][M] id;\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        F f;\n        int sy, sx;\n        memset(cast(void*)id, -1, id.sizeof);\n        int vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &f[i][j]);\n                if (f[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (f[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        P[] pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        F cur = f;\n        int[] next(int v) {\n            int[] ret;\n            static const dy = [0, 1, 0, -1],\n                         dx = [1, 0, -1, 0];\n            int sy = pos[v].y, sx = pos[v].x;\n            foreach (i; 0 .. 4) {\n                int y = sy, x = sx;\n                while (true) {\n                    y += dy[i];\n                    x += dx[i];\n                    if (y < 0 || y >= n) break;\n                    if (x < 0 || x >= m) break;\n                    if (cur[y][x] == 2) {\n                        ret ~= id[y][x];\n                        continue;\n                    }\n                    if (cur[y][x] == 1) {\n                        ret ~= id[y][x];\n                        break;\n                    }\n                }\n            }\n            return ret;\n        }\n\n        int dfs(int v, int used) {\n            if (used in cache[v- 1]) return cache[v - 1][used];\n            int y = pos[v].y, x = pos[v].x;\n            int ans = 0;\n            //writeln(pos[v], next(v).map!((i) => pos[i]));\n            foreach (i; next(v)) {\n                if (i == 0) {\n                    //writefln(\"%b\", used);\n                    if (used == (1 << vCount - 1) - 1) ans++;\n                    continue;\n                }\n                if (used & (1 << i-1)) continue;\n                int ny = pos[i].y,\n                    nx = pos[i].x;\n                assert(cur[ny][nx] == 1);\n                if (cur[ny][nx] == 1) {\n                    cur[ny][nx] = 3;\n                    ans += dfs(i, used | (1 << i-1));\n                    cur[ny][nx] = 1;\n                } \n            }\n            return cache[v - 1][used] = ans;\n        }\n        int ans = 0;\n        foreach (j; 0 .. 23) cache[j] = null;\n        foreach(i; next(0)) {\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nvoid main() {\n    int m, n;\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        F f;\n        int sy, sx;\n        int[M][M] id; memset(cast(void*)id, -1, id.sizeof);\n        int vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &f[i][j]);\n                if (f[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (f[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        P[] pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        F cur = f;\n        int[] next(int v) {\n            int[] ret;\n            static const dy = [0, 1, 0, -1],\n                         dx = [1, 0, -1, 0];\n            int sy = pos[v].y, sx = pos[v].x;\n            foreach (i; 0 .. 4) {\n                int y = sy, x = sx;\n                while (true) {\n                    y += dy[i];\n                    x += dx[i];\n                    if (y < 0 || y >= n) break;\n                    if (x < 0 || x >= m) break;\n                    if (cur[y][x] == 2) {\n                        ret ~= id[y][x];\n                        continue;\n                    }\n                    if (cur[y][x] == 1) {\n                        ret ~= id[y][x];\n                        break;\n                    }\n                }\n            }\n            return ret;\n        }\n\n        int[][] cache = new int[][](23, 1<<23);\n        int dfs(int v, int used) {\n            if (cache[v - 1][used] >= 0) return cache[v - 1][used];\n            int y = pos[v].y, x = pos[v].x;\n            int ans = 0;\n            //writeln(pos[v], next(v).map!((i) => pos[i]));\n            foreach (i; next(v)) {\n                if (i == 0) {\n                    //writefln(\"%b\", used);\n                    if (used == (1 << vCount - 1) - 1) ans++;\n                    continue;\n                }\n                if (used & (1 << i-1)) continue;\n                int ny = pos[i].y,\n                    nx = pos[i].x;\n                assert(cur[ny][nx] == 1 || cur[ny][nx] == 2);\n                if (cur[ny][nx] == 1) {\n                    cur[ny][nx] = 3;\n                    ans += dfs(i, used | (1 << i-1));\n                    cur[ny][nx] = 1;\n                } else {\n                    ans += dfs(i, used | (1 << i-1));\n                }\n            }\n            return cache[v - 1][used] = ans;\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j][] = -1;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nvoid main() {\n    int m, n;\n    int[int][23] cache;\n    int[M][M] id;\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        F f;\n        int sy, sx;\n        memset(cast(void*)id, -1, id.sizeof);\n        int vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &f[i][j]);\n                if (f[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (f[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        P[] pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        F cur = f;\n        int[] next(int v) {\n            int[] ret;\n            static const dy = [0, 1, 0, -1],\n                         dx = [1, 0, -1, 0];\n            int sy = pos[v].y, sx = pos[v].x;\n            foreach (i; 0 .. 4) {\n                int y = sy, x = sx;\n                while (true) {\n                    y += dy[i];\n                    x += dx[i];\n                    if (y < 0 || y >= n) break;\n                    if (x < 0 || x >= m) break;\n                    if (cur[y][x] == 2) {\n                        ret ~= id[y][x];\n                        continue;\n                    }\n                    if (cur[y][x] == 1) {\n                        ret ~= id[y][x];\n                        break;\n                    }\n                }\n            }\n            return ret;\n        }\n\n        int dfs(int v, int used) {\n            if (used in cache[v- 1]) return cache[v - 1][used];\n            int y = pos[v].y, x = pos[v].x;\n            int ans = 0;\n            //writeln(pos[v], next(v).map!((i) => pos[i]));\n            foreach (i; next(v)) {\n                if (i == 0) {\n                    //writefln(\"%b\", used);\n                    if (used == (1 << vCount - 1) - 1) ans++;\n                    continue;\n                }\n                if (used & (1 << i-1)) continue;\n                int ny = pos[i].y,\n                    nx = pos[i].x;\n                assert(cur[ny][nx] == 1 || cur[ny][nx] == 2);\n                if (cur[ny][nx] == 1) {\n                    cur[ny][nx] = 3;\n                    if ((used | (1 << i-1)) in cache[i - 1]) \n                        ans += cache[i - 1][used | (1 << i - 1)];\n                    else\n                        ans += dfs(i, used | (1 << i-1));\n                    cur[ny][nx] = 1;\n                } \n            }\n            return cache[v - 1][used] = ans;\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. n) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nvoid main() {\n    int m, n;\n    int[][] cache = new int[][](23, 1<<23);\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        F f;\n        int sy, sx;\n        int[M][M] id; memset(cast(void*)id, -1, id.sizeof);\n        int vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &f[i][j]);\n                if (f[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (f[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        P[] pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        F cur = f;\n        int[] next(int v) {\n            int[] ret;\n            static const dy = [0, 1, 0, -1],\n                         dx = [1, 0, -1, 0];\n            int sy = pos[v].y, sx = pos[v].x;\n            foreach (i; 0 .. 4) {\n                int y = sy, x = sx;\n                while (true) {\n                    y += dy[i];\n                    x += dx[i];\n                    if (y < 0 || y >= n) break;\n                    if (x < 0 || x >= m) break;\n                    if (cur[y][x] == 2) {\n                        ret ~= id[y][x];\n                        continue;\n                    }\n                    if (cur[y][x] == 1) {\n                        ret ~= id[y][x];\n                        break;\n                    }\n                }\n            }\n            return ret;\n        }\n\n        int dfs(int v, int used) {\n            if (cache[v - 1][used] >= 0) return cache[v - 1][used];\n            int y = pos[v].y, x = pos[v].x;\n            int ans = 0;\n            //writeln(pos[v], next(v).map!((i) => pos[i]));\n            foreach (i; next(v)) {\n                if (i == 0) {\n                    //writefln(\"%b\", used);\n                    if (used == (1 << vCount - 1) - 1) ans++;\n                    continue;\n                }\n                if (used & (1 << i-1)) continue;\n                int ny = pos[i].y,\n                    nx = pos[i].x;\n                assert(cur[ny][nx] == 1 || cur[ny][nx] == 2);\n                if (cur[ny][nx] == 1) {\n                    cur[ny][nx] = 3;\n                    ans += dfs(i, used | (1 << i-1));\n                    cur[ny][nx] = 1;\n                } else {\n                    ans += dfs(i, used | (1 << i-1));\n                }\n            }\n            return cache[v - 1][used] = ans;\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j][] = -1;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nvoid main() {\n    int m, n;\n    int[int][23] cache;\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        F f;\n        int sy, sx;\n        int[M][M] id; memset(cast(void*)id, -1, id.sizeof);\n        int vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &f[i][j]);\n                if (f[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (f[i][j] == 2) {\n                    sy = i;\n                    sx = j;\n                    id[i][j] = 0;\n                }\n            }\n        }\n        P[] pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        F cur = f;\n        int[] next(int v) {\n            int[] ret;\n            static const dy = [0, 1, 0, -1],\n                         dx = [1, 0, -1, 0];\n            int sy = pos[v].y, sx = pos[v].x;\n            foreach (i; 0 .. 4) {\n                int y = sy, x = sx;\n                while (true) {\n                    y += dy[i];\n                    x += dx[i];\n                    if (y < 0 || y >= n) break;\n                    if (x < 0 || x >= m) break;\n                    if (cur[y][x] == 2) {\n                        ret ~= id[y][x];\n                        continue;\n                    }\n                    if (cur[y][x] == 1) {\n                        ret ~= id[y][x];\n                        break;\n                    }\n                }\n            }\n            return ret;\n        }\n\n        int dfs(int v, int used) {\n            if (used in cache[v- 1]) return cache[v - 1][used];\n            int y = pos[v].y, x = pos[v].x;\n            int ans = 0;\n            //writeln(pos[v], next(v).map!((i) => pos[i]));\n            foreach (i; next(v)) {\n                if (i == 0) {\n                    //writefln(\"%b\", used);\n                    if (used == (1 << vCount - 1) - 1) ans++;\n                    continue;\n                }\n                if (used & (1 << i-1)) continue;\n                int ny = pos[i].y,\n                    nx = pos[i].x;\n                assert(cur[ny][nx] == 1 || cur[ny][nx] == 2);\n                if (cur[ny][nx] == 1) {\n                    cur[ny][nx] = 3;\n                    ans += dfs(i, used | (1 << i-1));\n                    cur[ny][nx] = 1;\n                } else {\n                    ans += dfs(i, used | (1 << i-1));\n                }\n            }\n            return cache[v - 1][used] = ans;\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport core.bitop;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst M = 10;\nalias int[M][M] F;\n\nstruct P {\n    int y, x;\n}\n\nint m, n;\nint[int][23] cache;\nint[M][M] id;\nint vCount;\nP[] pos;\nF cur;\n\nint[] next(int v) {\n    int[] ret;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    foreach (i; 0 .. 4) {\n        int y = pos[v].y, x = pos[v].x;\n        while (true) {\n            y += dy[i];\n            x += dx[i];\n            if (y < 0 || y >= n) break;\n            if (x < 0 || x >= m) break;\n            if (cur[y][x] == 2) {\n                ret ~= id[y][x];\n                continue;\n            }\n            if (cur[y][x] == 1) {\n                ret ~= id[y][x];\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint dfs(int v, int used) {\n    int popCount = used.popcnt;\n    if (popCount < 18) {\n        if (used in cache[v - 1]) return cache[v - 1][used];\n    }\n    int ans = 0;\n    //writeln(pos[v], next(v).map!((i) => pos[i]));\n    int[] z = next(v);\n    foreach (i; z) {\n        if (i == 0) {\n            //writefln(\"%b\", used);\n            if (used == (1 << vCount - 1) - 1) ans++;\n            continue;\n        }\n        if (used & (1 << i-1)) continue;\n        int ny = pos[i].y,\n            nx = pos[i].x;\n        if (cur[ny][nx] == 1) {\n            cur[ny][nx] = 3;\n            ans += dfs(i, used | (1 << i-1));\n            cur[ny][nx] = 1;\n        } \n    }\n    delete(z);\n    if (popCount < 18) {\n        cache[v - 1][used] = ans;\n    }\n    return ans;\n}\n\nvoid main() {\n    while (scanf(\"%d %d\\n\", &m, &n), m || n) {\n        memset(cast(void*)id, -1, id.sizeof);\n        vCount = 1;\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                scanf(\"%d\", &cur[i][j]);\n                if (cur[i][j] == 1) {\n                    id[i][j] = vCount++;\n                }\n                if (cur[i][j] == 2) {\n                    id[i][j] = 0;\n                }\n            }\n        }\n        pos = new P[vCount];\n        foreach (i; 0 .. n) {\n            foreach (j; 0 .. m) {\n                if (id[i][j] >= 0) {\n                    pos[id[i][j]] = P(i, j);\n                }\n            }\n        }\n        int ans = 0;\n        foreach(i; next(0)) {\n            foreach (j; 0 .. 23) cache[j] = null;\n            cur[pos[i].y][pos[i].x] = 3;\n            ans += dfs(i, 1 << i-1);\n            cur[pos[i].y][pos[i].x] = 1;\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "'''\n今年も JOI 町にサンタクロースが空からやってきた．JOI 町にある全ての家には子供がいるので，この\nサンタクロースは JOI 町の全ての家にプレゼントを配ってまわらなければならない．しかし，今年は連れ\nているトナカイが少々方向音痴であり，また建物の上以外に降りることができないため，全ての家にプレゼ\nントを配るためには少々道順を工夫しなければならないようだ．\n\nJOI 町は東西南北に区画整理されており，各区画は家，教会，空き地のいずれかである．JOI 町には 1\nつだけ教会がある．次のルールに従い，サンタクロースとトナカイは教会から出発し，全ての家に 1 回ず\nつプレゼントを配った後，教会に戻る．\n\n- 今年のトナカイは少々方向音痴であるため，東西南北いずれかの方向にまっすぐ飛ぶことしかできず，空\n  中では方向転換できない．\n- まだプレゼントを配っていない家の上は自由に通過できる．まだプレゼントを配っていない家には降りる\n  ことができる．家に降りた時は必ずプレゼントを配り，その後は東西南北いずれかの方向に飛び立つ．\n- JOI 町の家では，クリスマスの夜はサンタクロースが来るまでは暖炉をつけずに過ごしているが，サン\n  タクロースが飛び立った後は暖炉をつける．暖炉をつけると煙突から煙が出るので，プレゼントを配り終\n  えた家の上を通過することはできない．\n- 教会の上は自由に通過することができる．しかし，教会では礼拝が行われているので，全てのプレゼント\n  を配り終えるまで教会に降りることはできない．\n- 空き地の上は自由に通過することができるが，空き地に降りることはできない．\n\n入力として町の構造が与えられたとき，サンタクロースとトナカイがプレゼントを配る道順が何通りあるか\nを求めるプログラムを作成せよ．\n'''\nimport copy\ndc = copy.deepcopy\nans = 0\nM = N = 0\n\n\ndef walk(field, pos_x, pos_y, direction):\n    now_state = field[pos_y][pos_x]\n    if now_state == 2:\n        if sum(sum(field, [])) == 2:\n            global ans\n            ans += 1\n        return\n    field[pos_y][pos_x] = 0\n    if (now_state or direction == 'r') and pos_x < M - 1:\n        walk(dc(field), pos_x + 1, pos_y, 'r')\n    if (now_state or direction == 'l') and 0 < pos_x:\n        walk(dc(field), pos_x - 1, pos_y, 'l')\n    if (now_state or direction == 'u') and 0 < pos_y:\n        walk(dc(field), pos_x, pos_y - 1, 'u')\n    if (now_state or direction == 'd') and pos_y < N - 1:\n        walk(dc(field), pos_x, pos_y + 1, 'd')\n\n\nfor e in iter(input, '0 0'):\n    M, N = map(int, e.split())\n    field = []\n    for i in range(N):\n        row = list(map(int, input().split()))\n        field.append(row)\n        if 2 in row:\n            ch_x = row.index(2)\n            ch_y = i\n    if ch_x < M - 1:\n        walk(dc(field), ch_x + 1, ch_y, 'r')\n    if 0 < ch_x:\n        walk(dc(field), ch_x - 1, ch_y, 'l')\n    if 0 < ch_y:\n        walk(dc(field), ch_x, ch_y - 1, 'u')\n    if ch_y < N - 1:\n        walk(dc(field), ch_x, ch_y + 1, 'd')\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def search(town, remains, i, j):\n    if not remains:\n        if i == church[0]:\n            direction = 1 if j < church[1] else -1\n            for cj in range(j + direction, church[1], direction):\n                if town[i][cj] == 3:\n                    return 0\n            return 1\n        elif j == church[1]:\n            direction = 1 if i < church[0] else -1\n            for ci in range(i + direction, church[0], direction):\n                if town[ci][j] == 3:\n                    return 0\n            return 1\n        return 0\n\n    counter = 0\n    for ci in range(i - 1, -1, -1):\n        if town[ci][j] == 1:\n            town[ci][j] = 3\n            counter += search(town, remains - 1, ci, j)\n            town[ci][j] = 1\n        elif town[ci][j] == 3:\n            break\n\n    for ci in range(i + 1, n):\n        if town[ci][j] == 1:\n            town[ci][j] = 3\n            counter += search(town, remains - 1, ci, j)\n            town[ci][j] = 1\n        elif town[ci][j] == 3:\n            break\n\n    for cj in range(j - 1, -1, -1):\n        if town[i][cj] == 1:\n            town[i][cj] = 3\n            counter += search(town, remains - 1, i, cj)\n            town[i][cj] = 1\n        elif town[i][cj] == 3:\n            break\n\n    for cj in range(j + 1, m):\n        if town[i][cj] == 1:\n            town[i][cj] = 3\n            counter += search(town, remains - 1, i, cj)\n            town[i][cj] = 1\n        elif town[i][cj] == 3:\n            break\n\n    return counter\n\n\nwhile True:\n    m, n = map(int, input().split())\n    if not n:\n        break\n    town = [list(map(int, input().split())) for _ in range(n)]\n    remains = 0\n    for i in range(n):\n        for j in range(m):\n            house = town[i][j]\n            if house == 2:\n                church = (i, j)\n            elif house == 1:\n                remains += 1\n    print(search(town, remains, *church))"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::io::{stdin, Read, StdinLock};\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::str::FromStr;\n#[allow(unused_imports)]\nuse std::collections::{HashSet, HashMap, BinaryHeap, VecDeque};\n#[allow(unused_imports)]\nuse std::vec::Vec;\n\n#[allow(dead_code)]\nconst INF: i32 = 1000_000_000;\n#[allow(dead_code)]\nconst INFLL: i64 = 1000_000_000_000_000_000;\n#[allow(dead_code)]\nconst EPS: f64 = 1.0e-10;\n#[allow(dead_code)]\nconst MOD: i32 = 1000_000_007;\n#[allow(dead_code)]\nconst MODLL: i64 = 1000_000_007;\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\n#[allow(dead_code)]\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner {cin: cin}\n    }\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n                    .skip_while(|c| c.is_whitespace())\n                    .take_while(|c| !c.is_whitespace())\n                    .collect::<String>();\n        token.parse::<T>().ok()\n    }\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n}\n\nfn solve(y: i32, x: i32, map: &mut Vec<Vec<i32>>, cnt: usize, sy: i32, sx: i32) -> i32 {\n    let h = map.len() as i32;\n    let w = map[0].len() as i32;\n    if cnt == 0 {\n        if sy == y || x == sx {\n            return 1\n        } else {\n            return 0\n        }\n    }\n\n    let mut ans = 0;\n    let dx = [0, 1, 0, -1];\n    let dy = [1, 0, -1, 0];\n    for d in 0..4 {\n        let mut ny = y;\n        let mut nx = x;\n        loop {\n            ny += dy[d]; nx += dx[d];\n            if ny < 0 || ny >= h || nx < 0 || nx >= w {\n                break;\n            }\n            let ny = ny as usize;\n            let nx = nx as usize;\n            if map[ny][nx] == 1 {\n                map[ny][nx] = -1;\n                ans += solve(ny as i32, nx as i32, map, cnt - 1, sy, sx);\n                map[ny][nx] = 1;\n                break;\n            }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n\n    loop {\n        let (m, n): (usize, usize) = (sc.read(), sc.read());\n        if (m, n) == (0, 0) {\n            break;\n        }\n        let mut map: Vec<Vec<i32>> = vec![vec![0; m]; n];\n        let mut cnt = 0;\n        let (mut sy, mut sx) = (0, 0);\n        for i in 0..n {\n            for j in 0..m {\n                map[i][j] = sc.read();\n                if map[i][j] == 2 {\n                    sy = i as i32; sx = j as i32;\n                }\n                if map[i][j] == 1 {\n                    cnt += 1;\n                }\n            }\n        }\n        let cnt = cnt;\n\n        println!(\"{}\", solve(sy, sx, &mut map, cnt, sy, sx));\n    }\n}\n"
  }
]